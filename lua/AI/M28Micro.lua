---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 18/01/2023 06:57
---
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local XZDist = import('/lua/utilities.lua').XZDistanceTwoVectors
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local NavUtils = M28Utilities.NavUtils
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')

refbMicroResetChecker = 'M28MicChk' --True if we have an active thread checking if micro time has expired

function MoveAwayFromTargetTemporarily(oUnit, iTimeToRun, tPositionToRunFrom)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MoveAwayFromTargetTemporarily'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bMoveInStages = false --set to true later if hardly have any time to run, but in reality this functionality isn't expected to be used in most cases, left in since took a while to get it to work to a basic level, but turns out it's probably better to just move in a straight line rather than trying multiple move orders

    local tUnitPosition = oUnit:GetPosition()
    local oBP = oUnit:GetBlueprint()
    local iUnitSpeed = (oBP.Physics.MaxSpeed or 0)
    if iUnitSpeed > 0 then
        local iDistanceToMove = (iTimeToRun + 1) * iUnitSpeed
        --local tRevisedPositionToRunFrom

        local iCurFacingDirection = M28UnitInfo.GetUnitFacingAngle(oUnit)
        local iAngleFromUnitToBomb
        if tUnitPosition[1] == tPositionToRunFrom[1] and tUnitPosition[3] == tPositionToRunFrom[3] then
            iAngleFromUnitToBomb = iCurFacingDirection - 180
            if iAngleFromUnitToBomb < 0 then iAngleFromUnitToBomb = iAngleFromUnitToBomb + 360 end
        else
            iAngleFromUnitToBomb = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tPositionToRunFrom)
        end

        local iAngleAdjFactor
        local iFacingAngleWanted = iAngleFromUnitToBomb + 180
        if iFacingAngleWanted >= 360 then iFacingAngleWanted = iFacingAngleWanted - 360 end

        local iTurnRate = (oBP.Physics.TurnRate or 90)
        local iBackupDist = (oBP.Physics.BackUpDistance or 0)
        local iTimeToTurn
        local bBackupInsteadOfTurning = false
        local iDistToBomb = M28Utilities.GetDistanceBetweenPositions(tPositionToRunFrom, oUnit:GetPosition())
        if iBackupDist >= 4 then
            bBackupInsteadOfTurning = true
            iTimeToTurn = 0
            if M28Utilities.GetAngleDifference(iCurFacingDirection, iFacingAngleWanted) <= 90 then
                iFacingAngleWanted = iCurFacingDirection
            else
                iFacingAngleWanted = iCurFacingDirection + 180
                if iFacingAngleWanted >= 360 then iFacingAngleWanted = iFacingAngleWanted - 360 end
            end
            iDistanceToMove = iDistanceToMove + math.min(iDistToBomb, iDistanceToMove * 0.5)
        else
            if iTurnRate <= 0 then iTimeToTurn = 0 else iTimeToTurn = math.abs(iFacingAngleWanted - iCurFacingDirection) / iTurnRate end
            if iDistToBomb * 2 / iUnitSpeed <= iTimeToTurn then
                iFacingAngleWanted = iCurFacingDirection
                iDistanceToMove = iDistanceToMove + iDistToBomb
            end
        end

        if iTimeToTurn > iTimeToRun and not(bBackupInsteadOfTurning) then bMoveInStages = true end

        local tTempLocationToMove

        if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop for move commands for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTimeToRun='..iTimeToRun..'; iCurFacingDirection='..iCurFacingDirection..'; iAngleFromUnitToBomb='..iAngleFromUnitToBomb..'; iFacingAngleWanted='..iFacingAngleWanted..'; tUnitStartPosition='..repru(oUnit:GetPosition())..'; tPositionToRunFrom='..repru(tPositionToRunFrom)..'; bBackupInsteadOfTurning='..tostring(bBackupInsteadOfTurning)) end
        M28Orders.IssueTrackedClearCommands(oUnit)
        TrackTemporaryUnitMicro(oUnit, iTimeToRun)
        tTempLocationToMove = oUnit:GetPosition()
        local iDistanceAlreadyMoved = 0


        --Turn around while moving away if we're not facing the right direction:
        if bMoveInStages then
            local iInitialAngleAdj = 30
            local iAngleMaxSingleAdj = 45
            local iTempDistanceAwayToMove = 3
            local iDistanceIncreasePerCycle = 1.5
            local iDistanceIncreaseCompoundFactor = 1.5
            local iLoopCount = 0

            if math.abs(iCurFacingDirection - iFacingAngleWanted) > (iAngleMaxSingleAdj + iInitialAngleAdj) then
                local iTempAngleDirectionToMove = iCurFacingDirection

                if iCurFacingDirection - iFacingAngleWanted > 0 then
                    if iCurFacingDirection - iFacingAngleWanted > 180 then iAngleAdjFactor = 1 --Clockwise
                    else iAngleAdjFactor = -1 --AntiClockwise
                    end

                elseif iCurFacingDirection - iFacingAngleWanted < -180 then iAngleAdjFactor = -1
                else iAngleAdjFactor = 1
                end --Clockwise



                while iLoopCount < 6 do
                    iLoopCount = iLoopCount + 1

                    iTempAngleDirectionToMove = iCurFacingDirection + (iInitialAngleAdj + iLoopCount * iAngleMaxSingleAdj) * iAngleAdjFactor
                    if iTempAngleDirectionToMove > 360 then iTempAngleDirectionToMove = iTempAngleDirectionToMove - 360
                    elseif iTempAngleDirectionToMove < 0 then iTempAngleDirectionToMove = iTempAngleDirectionToMove + 360
                    end

                    if bDebugMessages == true then LOG(sFunctionRef..': iLoopCount='..iLoopCount..'; iTempAngleDirectionToMove='..iTempAngleDirectionToMove..'; iInitialAngleAdj='..iInitialAngleAdj..'; iAngleAdjFactor='..iAngleAdjFactor..'; iCurFacingDirection='..iCurFacingDirection..'; iFacingAngleWanted='..iFacingAngleWanted) end


                    iTempDistanceAwayToMove = iTempDistanceAwayToMove + iDistanceIncreasePerCycle * iDistanceIncreasePerCycle * (iDistanceIncreaseCompoundFactor ^ iLoopCount - 1)
                    tTempLocationToMove = M28Utilities.MoveInDirection(oUnit:GetPosition(), iTempAngleDirectionToMove, iTempDistanceAwayToMove, true, false, true)
                    M28Orders.IssueTrackedMove(oUnit, tTempLocationToMove, 0.25, true, 'TempMA', true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Just issued move order to tTempLocationToMove='..repru(tTempLocationToMove)..'; iTempAngleDirectionToMove='..iTempAngleDirectionToMove) end
                    if math.abs(iTempAngleDirectionToMove - iFacingAngleWanted) <= iAngleMaxSingleAdj then break
                    elseif math.abs(iTempAngleDirectionToMove - iFacingAngleWanted) > 360 then
                        M28Utilities.ErrorHandler('Something has gone wrong with dodge micro, will stop trying to turn around')
                        break
                    end
                end
                iDistanceAlreadyMoved = M28Utilities.GetDistanceBetweenPositions(tTempLocationToMove, tPositionToRunFrom)
            end
        end
        --Should now be facing close to the right direction, so move further in this direction


        --If are backing up, then consider queuing up multiple move orders
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we should backup, bBackupInsteadOfTurning='..tostring(bBackupInsteadOfTurning or false)) end
        if bBackupInsteadOfTurning and iBackupDist - 1 > 0 and iDistanceToMove > iDistanceAlreadyMoved then
            --First stop and wait 1 tick (so we can actually backup)
            TrackTemporaryUnitMicro(oUnit, iTimeToRun)
            --For backing up to work reliably the unit should be stationery
            if oUnit:IsUnitState('Moving') then
                M28Orders.IssueTrackedClearCommands(oUnit)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
            local iPlateauWanted = NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oUnit:GetPosition())
            local iCurDistToMove
            local iTotalTimeWaited = 0
            local bFirstCycle = true
            while iDistanceAlreadyMoved < iDistanceToMove and M28UnitInfo.IsUnitValid(oUnit) do

                if bFirstCycle then
                    while M28UnitInfo.IsUnitValid(oUnit) and M28UnitInfo.GetUnitSpeed(oUnit) >= 0.75 and iTotalTimeWaited <= 9 do
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        iTotalTimeWaited = iTotalTimeWaited + 1
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        if bDebugMessages == true then LOG(sFunctionRef..': Speed after waiting 1 tick='..M28UnitInfo.GetUnitSpeed(oUnit)..'; iTotalTimeWaited in ticks='..iTotalTimeWaited) end
                    end
                    if not(M28UnitInfo.IsUnitValid(oUnit)) then break end
                end


                iCurDistToMove = math.min(iBackupDist - 1, math.max(1, iDistanceToMove - iDistanceAlreadyMoved))
                local tViaPoint = M28Utilities.MoveInDirection(oUnit:GetPosition(), iFacingAngleWanted, iCurDistToMove + iDistanceAlreadyMoved, true, false, true)
                if NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, tViaPoint) == iPlateauWanted then
                    --Are we either an amphibious/hover unit, of a land unit on the same island, or a naval unit on the same pond
                    if EntityCategoryContains(M28UnitInfo.refCategoryAmphibious + categories.AIR, oUnit.UnitId)
                            or (EntityCategoryContains(categories.LAND, oUnit.UnitId) and NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, oUnit:GetPosition()) == NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tViaPoint))
                            or (EntityCategoryContains(categories.NAVAL, oUnit.UnitId) and NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, oUnit:GetPosition()) == NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tViaPoint)) then
                        M28Orders.IssueTrackedMove(oUnit, tViaPoint, 0.25, true, 'BckupDodMv', true)
                        iDistanceAlreadyMoved = iDistanceAlreadyMoved + iCurDistToMove
                        if bDebugMessages == true then LOG(sFunctionRef..': Backing up to via point, iCurDistToMove='..iCurDistToMove..'; iDistanceAlreadyMoved='..iDistanceAlreadyMoved) end
                    else
                        --Abort
                        break
                    end
                else
                    break
                end
                bFirstCycle = false
            end
        end
        if not(bBackupInsteadOfTurning) or iDistanceToMove < iDistanceAlreadyMoved then
            local tNewTargetIgnoringGrouping = M28Utilities.MoveInDirection(oUnit:GetPosition(), iFacingAngleWanted, math.max(1, iDistanceToMove - iDistanceAlreadyMoved), true, false, true)
            if bDebugMessages == true then LOG(sFunctionRef..': Finished trying to face the right direction, tNewTargetIgnoringGrouping='..repru(tNewTargetIgnoringGrouping)..'; tUnitPosition='..repru(tUnitPosition)..'; iDistanceToMove='..iDistanceToMove..'; iDistanceAlreadyMoved='..iDistanceAlreadyMoved) end
            if EntityCategoryContains(M28UnitInfo.refCategoryAllAir, oUnit.UnitId) then
                M28Orders.IssueTrackedMove(oUnit, tNewTargetIgnoringGrouping, 0.25, true, 'TempGA', true)
                if bDebugMessages == true then LOG(sFunctionRef..': Dodging bomb for air unit, tNewTargetIgnoringGrouping='..repru(tNewTargetIgnoringGrouping)..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
            else
                local tNewTargetInSameGroup = M28Map.GetPositionAtOrNearTargetInPathingGroup(tUnitPosition, tNewTargetIgnoringGrouping, 0, 0, oUnit, true, false)
                if tNewTargetInSameGroup then
                    if bDebugMessages == true then LOG(sFunctionRef..': Starting bomber dodge for unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; tNewTargetInSameGroup='..repru(tNewTargetInSameGroup)) end

                    M28Orders.IssueTrackedMove(oUnit, tNewTargetInSameGroup, 0.25, true, 'TempMA', true)
                    TrackTemporaryUnitMicro(oUnit, iTimeToRun)
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code at time='..GetGameTimeSeconds()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetBombTarget(weapon, projectile)
    --based on CalcBallisticAcceleration

    --Copy of CalcBallisticAcceleration core part of calculation to determine bomb target; ignores multiple bombs
    local acc = 4.75
    if projectile and projectile.GetLauncher and not(projectile:BeenDestroyed()) then
        local launcher = projectile:GetLauncher()
        if launcher then
            -- Get projectile position and velocity
            -- velocity needs to multiplied by 10 due to being returned /tick instead of /s
            local proj = {pos=projectile:GetPosition(), vel=VMult(Vector(launcher:GetVelocity()), 10)}
            local entity = launcher:GetTargetEntity()

            local target
            if entity and IsUnit(entity) then
                -- target is a entity
                target = {pos=entity:GetPosition(), vel=VMult(Vector(entity:GetVelocity()), 10)}
            else
                -- target is something else i.e. attack ground
                target = {pos=weapon:GetCurrentTargetPos(), vel=Vector(0, 0, 0)}
            end

            -- calculate flat(exclude y-axis) distance and velocity between projectile and target
            if M28Utilities.IsTableEmpty(target) == false and M28Utilities.IsTableEmpty(proj.pos) == false and target.pos and target.vel and proj.pos and target.pos then
                local dist = {pos=XZDist(proj.pos, target.pos), vel=XZDist(proj.vel, target.vel)}

                -- how many seconds until the bomb hits the target in xz-space
                local time = dist.pos / dist.vel
                if time == 0 then return acc end

                -- find out where the target will be at that point in time (it could be moving)
                target.tpos = {target.pos[1] + time * target.vel[1], 0, target.pos[3] + time * target.vel[3]}
                -- what is the height at that future position
                target.tpos[2] = GetSurfaceHeight(target.tpos[1], target.tpos[3])
                return target.tpos
            end
        end
    elseif not(projectile) then
        if weapon.GetCurrentTarget then
            if weapon:GetCurrentTarget().GetPosition then return weapon:GetCurrentTarget():GetPosition() end
        end
        if weapon.GetCurrentTargetPos then
            if weapon:GetCurrentTargetPos() then return weapon:GetCurrentTargetPos() end
        end
    end
    return nil
end

function FriendlyGunshipsAvoidBomb(oBomber, oWeapon, projectile)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'FriendlyGunshipsAvoidBomb'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local tBombTarget = GetBombTarget(oWeapon, projectile)
    if tBombTarget then
        local iBombSize = oWeapon:GetBlueprint().DamageRadius
        if bDebugMessages == true then LOG(sFunctionRef..': Near start, oBomber='..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; tBombTarget='..repru(tBombTarget)..'; iBombSize='..iBombSize) end
        if iBombSize then
            local iCategoriesToRun = M28UnitInfo.refCategoryGunship
            local iRadiusSize = iBombSize + 10
            local aiBrain = oBomber:GetAIBrain()
            local tUnitsToRun = aiBrain:GetUnitsAroundPoint(iCategoriesToRun, tBombTarget, iRadiusSize, 'Ally')
            if M28Utilities.IsTableEmpty(tUnitsToRun) == false then
                local tTemporaryDestination = M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.reftAirSubRallyPoint]
                if M28Utilities.IsTableEmpty(tTemporaryDestination) then
                    --Campaign cutscene like fort clarke assault - wont exist yet
                    if not(ScenarioInfo.OpEnded) then
                        M28Utilities.ErrorHandler('Dont have an air rally point')
                    end
                    --Backup - try and get the start position of the first unit
                    tTemporaryDestination = M28Map.GetPlayerStartPosition(tUnitsToRun[1]:GetAIBrain())
                end

                local tAltTempDestination
                local oCurUnitBrain
                local iTeam = aiBrain.M28Team
                local iCurDistToBomb, iCurAngleFromBomb, bMoveToAltDestination
                local iAngleFromBombToBase = M28Utilities.GetAngleFromAToB(tBombTarget, tTemporaryDestination)
                local bCampaignMap = M28Map.bIsCampaignMap
                for iUnit, oUnit in tUnitsToRun do
                    oCurUnitBrain = oUnit:GetAIBrain()
                    if oCurUnitBrain.M28AI and oCurUnitBrain.M28Team == iTeam then
                        if not(oUnit[M28UnitInfo.refbEasyBrain]) then
                            --If gunship runs to temp destination is it likely to be going the wrong way to avoid the bomb? if so then have it run in a different direction
                            iCurDistToBomb = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBombTarget)
                            bMoveToAltDestination = false
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDistToBomb='..iCurDistToBomb..'; ANgle from bomb='..M28Utilities.GetAngleFromAToB(tBombTarget, oUnit:GetPosition())..'; iAngleFromBombToBase='..iAngleFromBombToBase) end
                            if iCurDistToBomb >= 4 then
                                iCurAngleFromBomb = M28Utilities.GetAngleFromAToB(tBombTarget, oUnit:GetPosition())
                                if M28Utilities.GetAngleDifference(iCurAngleFromBomb, iAngleFromBombToBase) > 50 then
                                    bMoveToAltDestination = true
                                    tAltTempDestination = M28Utilities.MoveInDirection(oUnit:GetPosition(), iCurAngleFromBomb, iRadiusSize, true, false, bCampaignMap)
                                end
                            end
                            M28Orders.IssueTrackedClearCommands(oUnit)
                            if bMoveToAltDestination then
                                M28Orders.IssueTrackedMove(oUnit, tAltTempDestination, 3, false, 'AhwRunH', true)
                            else
                                M28Orders.IssueTrackedMove(oUnit, tTemporaryDestination, 3, false, 'AhwRunT', true)
                            end
                            TrackTemporaryUnitMicro(oUnit, 4) --takes roughly 4s for bomb to land
                        end
                    end
                end
            end
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': tBombTarget is nil') end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DodgeBomb(oBomber, oWeapon, projectile)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DodgeBombsFiredByUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tBombTarget = GetBombTarget(oWeapon, projectile)
    if bDebugMessages == true then LOG(sFunctionRef..': Start fo code for bomber '..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; is tBombTarget nil='..tostring(tBombTarget == nil)..'; Time='..GetGameTimeSeconds()) end
    --LOUD - recall Sprouto saying that bombs home in on target, so dont try and dodge
    if tBombTarget and not(M28Utilities.bLoudModActive) then
        if bDebugMessages == true then LOG(sFunctionRef..': bomb fired by oBomber='..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; Dist to target from bomber='..M28Utilities.GetDistanceBetweenPositions(oBomber:GetPosition(), tBombTarget)..'; Bomber speed='..M28UnitInfo.GetUnitSpeed(oBomber)) end
        oBomber[M28UnitInfo.refiLastDodgeBombEvent] = GetGameTimeSeconds()
        local iBombSize = 2.5
        if oWeapon.GetBlueprint then iBombSize = math.max(iBombSize, (oWeapon:GetBlueprint().DamageRadius or iBombSize)) end
        local iTimeToRun = 2.4 --T1, was 1.75 for v83 and earlier but it turned out to not be long enough for a t1 engi to dodge a t1 bomber
        if iBombSize > 2.5 then iTimeToRun = math.min(2.9, iTimeToRun + (iBombSize - 2.5) * 0.5) end --increased the min to 2.9 as of v84
        if EntityCategoryContains(categories.TECH2, oBomber.UnitId) then
            iBombSize = 3
            iTimeToRun = 2.4 --1.95 for v83 and earlier
            if iBombSize > 3 then iTimeToRun = math.min(2.9, iTimeToRun + (iBombSize - 3) * 0.5) end --increased the min to 2.9 as of v84
        elseif EntityCategoryContains(categories.TECH3, oBomber.UnitId) then
            iTimeToRun = 2.5
            --Consider recording for special asf suicide logic
            if bDebugMessages == true then LOG(sFunctionRef..': Will consider logic for suiciding into strat bomber') end
            ForkThread(M28Air.ConsiderRecordingStratBomberToSuicideInto, oBomber)
        end --Some t2 bombers do damage in a spread (cybran, uef)
        --local iTimeToRun = math.min(7, iBombSize + 1)
        local iRadiusSize = iBombSize + 2.5 --was +1 for v83 and earlier, but found if an engi was running towards the bomb target already it wouldn't get picked up and would die

        local iBomberArmyIndex = oBomber:GetAIBrain():GetArmyIndex()

        if bDebugMessages == true then
            LOG(sFunctionRef..': oBomber='..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; Bomber position='..repru(oBomber:GetPosition())..'; tBombTarget='..repru(tBombTarget)..'; Dist between position and target='..M28Utilities.GetDistanceBetweenPositions(oBomber:GetPosition(), tBombTarget)..'; Angle='..M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), tBombTarget)..'; Bomber facing direction='..M28UnitInfo.GetUnitFacingAngle(oBomber)..'; will draw bomb target in black')
            M28Utilities.DrawLocation(tBombTarget, 3, 20)
        end --black ring around target

        local tAllUnitsInArea = GetUnitsInRect(Rect(tBombTarget[1]-iRadiusSize, tBombTarget[3]-iRadiusSize, tBombTarget[1]+iRadiusSize, tBombTarget[3]+iRadiusSize))
        local bDontCheckIfFriendlyGunships = true
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of units in rectangle around bomb radius empty='..tostring(M28Utilities.IsTableEmpty(tAllUnitsInArea))) end
        if M28Utilities.IsTableEmpty(tAllUnitsInArea) == false then
            local tMobileLandAndGunshipsInArea
            if iBombSize <= 9 then tMobileLandAndGunshipsInArea = EntityCategoryFilterDown(M28UnitInfo.refCategoryMobileLand - categories.EXPERIMENTAL, tAllUnitsInArea)
            else
                if EntityCategoryContains(categories.EXPERIMENTAL, oBomber.UnitId) then
                    tMobileLandAndGunshipsInArea = EntityCategoryFilterDown(M28UnitInfo.refCategoryGunship, tAllUnitsInArea)
                    bDontCheckIfFriendlyGunships = false --we get friendly gunships to split up via separate logic
                    iTimeToRun = math.max(iTimeToRun + 1.5, 5.5) --v68 - increased time from iTimeToRun, 3.5 due to issue with ahwassa bomb damage being spread over time
                    table.insert(M28Air.tiRecentExpBomberTargets, {tBombTarget[1], tBombTarget[2], tBombTarget[3]})
                    ForkThread(M28Air.RemoveFirstExpBomberTarget, 10)
                else
                    tMobileLandAndGunshipsInArea = EntityCategoryFilterDown(M28UnitInfo.refCategoryMobileLand - categories.EXPERIMENTAL + M28UnitInfo.refCategoryGunship, tAllUnitsInArea)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Are including gunships in the category of unit to consider dodging') end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of mobile land units in rectangle around bomb radius empty='..tostring(M28Utilities.IsTableEmpty(tMobileLandAndGunshipsInArea))) end
            if M28Utilities.IsTableEmpty(tMobileLandAndGunshipsInArea) == false then
                local oCurBrain
                for iUnit, oUnit in tMobileLandAndGunshipsInArea do
                    if not(oUnit.Dead) and oUnit.GetUnitId and oUnit.GetPosition and oUnit.GetAIBrain then
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Does unit already have micro active='..tostring((oUnit[M28UnitInfo.refbSpecialMicroActive] or false))..'; refbLowerPriorityMicroActive='..tostring(oUnit[M28UnitInfo.refbLowerPriorityMicroActive] or false)..'; iTimeToRun='..iTimeToRun) end
                        oCurBrain = oUnit:GetAIBrain()
                        if oCurBrain.M28AI and not(oCurBrain.M28IsDefeated) and not(oCurBrain:IsDefeated()) and IsEnemy(oCurBrain:GetArmyIndex(), iBomberArmyIndex) then
                            if not(oUnit[M28UnitInfo.refbEasyBrain]) then
                                --ACU specific
                                if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                                    local aiBrain = oCurBrain
                                    --If ACU is upgrading might not want to cancel
                                    local bDontTryAndDodge = false
                                    if oUnit:IsUnitState('Upgrading') then
                                        --Are we facing a T1 bomb?
                                        if EntityCategoryContains(categories.TECH1, oBomber.UnitId) then
                                            bDontTryAndDodge = true
                                        else
                                            --Facing T2+ bomb, so greater risk if we dont try and dodge; dont dodge if are almost complete
                                            if oUnit:GetWorkProgress() >= 0.9 then
                                                bDontTryAndDodge = true
                                            else
                                                --Is it a T2 bomber, and there arent many bombers nearby?
                                                if EntityCategoryContains(categories.TECH2, oBomber.UnitId) then
                                                    local tNearbyBombers = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryBomber + M28UnitInfo.refCategoryGunship - categories.TECH1, oUnit:GetPosition(), 100, 'Enemy')
                                                    if M28Utilities.IsTableEmpty(tNearbyBombers) == true then
                                                        bDontTryAndDodge = true
                                                    else
                                                        local iEnemyBomberCount = 0
                                                        for iEnemy, oEnemy in tNearbyBombers do
                                                            if M28UnitInfo.IsUnitValid(oEnemy) then
                                                                iEnemyBomberCount = iEnemyBomberCount + 1
                                                                if iEnemyBomberCount >= 4 then break end
                                                            end
                                                        end
                                                        if iEnemyBomberCount < 4 then bDontTryAndDodge = true end
                                                    end
                                                end
                                            end
                                        end
                                    elseif oUnit:IsUnitState('Teleporting') then
                                        bDontTryAndDodge = true
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': bDontTryAndDodge after checking if upgrading='..tostring(bDontTryAndDodge)) end
                                    if not(bDontTryAndDodge) then
                                        --Is there a significant enemy land threat and we are against a T1 bomber?
                                        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                                        if iLandZone > 0 and EntityCategoryContains(categories.TECH1, oBomber.UnitId) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefTThreatEnemyCombatTotal] * 1.2 > math.min(300, M28UnitInfo.GetCombatThreatRating({ oUnit }, false, false, false, false, false, false, false)) then
                                            bDontTryAndDodge = true
                                        end
                                    end

                                    if not(bDontTryAndDodge) then
                                        if oUnit[M28UnitInfo.refbSpecialMicroActive] and not(EntityCategoryContains(categories.AIR, oUnit.UnitId)) and not(oUnit[M28UnitInfo.refbLowerPriorityMicroActive]) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will move in a circle as micro is already active') end
                                            MoveInCircleTemporarily(oUnit, iTimeToRun)
                                        else
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will move away from bomb target temporarily') end
                                            MoveAwayFromTargetTemporarily(oUnit, iTimeToRun, tBombTarget)
                                            oUnit[M28UnitInfo.refiGameTimeMicroStarted] = GetGameTimeSeconds()
                                        end
                                    end

                                else
                                    --If we are already in the process of dodging then dont try dodging some more, unless our micro is about to expire
                                    if oUnit[M28UnitInfo.refbSpecialMicroActive] and not(oUnit[M28UnitInfo.refbLowerPriorityMicroActive]) and (oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] or 0) - GetGameTimeSeconds() > 0.5 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Unit has recently tried dodging so dont want to give it another dodge order as it might end up not moving') end
                                    else
                                        --Are we a mobile shield that isn't on the same team as the bomber? If so, then dont worry about dodging
                                        if not(EntityCategoryContains(M28UnitInfo.refCategoryMobileLandShield, oUnit.UnitId)) or not(oUnit.MyShield.GetHealth) or oUnit.MyShield:GetHealth() == 0 or not(oUnit.MyShield.Enabled) or oUnit.MyShield.DepletedByEnergy then
                                            if bDontCheckIfFriendlyGunships or not(EntityCategoryContains(M28UnitInfo.refCategoryGunship, oUnit.UnitId)) or not(oUnit:GetAIBrain().M28Team == oBomber:GetAIBrain().M28Team) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': about to call moveawayfromtargettemporarily') end
                                                MoveAwayFromTargetTemporarily(oUnit, iTimeToRun, tBombTarget)
                                                oUnit[M28UnitInfo.refiGameTimeMicroStarted] = GetGameTimeSeconds()
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': tBombTarget is nil or are in LOUD') end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedRemovalOfTargetToAvoid(tTargetLZTeamData, tTargetToAvoid, iDelayInSeconds)
    WaitSeconds(iDelayInSeconds)
    if M28Utilities.IsTableEmpty(tTargetLZTeamData[M28Map.reftiLocationsToAvoid]) == false then
        for iEntry, tEntry in tTargetLZTeamData[M28Map.reftiLocationsToAvoid] do
            if tEntry[1] == tTargetToAvoid[1] and tEntry[3] == tTargetToAvoid[3] then
                table.remove(tTargetLZTeamData[M28Map.reftiLocationsToAvoid], iEntry)
                break
            end
        end
    end
end

function ConsiderDodgingShot(oUnit, oWeapon)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderDodgingShot'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if not(ScenarioInfo.Options.M28DodgeMicro == 2) and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit.UnitId)) then
        local oWeaponBP = oWeapon.Blueprint or oWeapon.bp
        if bDebugMessages == true then
            LOG(sFunctionRef..': Just fired, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit combat range='..(oUnit[M28UnitInfo.refiCombatRange] or 'nil')..'; oWeaponBP.RangeCategory='..(oWeaponBP.RangeCategory or 'nil'))
            if oWeapon.GetCurrentTarget then
                LOG(sFunctionRef..': Is current target valid='..tostring(M28UnitInfo.IsUnitValid(oWeapon:GetCurrentTarget()))..'; Weapon category='..(oWeaponBP.WeaponCategory or 'nil'))
                if not(M28UnitInfo.IsUnitValid(oWeapon:GetCurrentTarget())) then
                    LOG(sFunctionRef..': Invalid target, will do reprs of it:'..reprs(oWeapon:GetCurrentTarget())..' will also draw black square around the weapon target position which is '..repru(oWeapon:GetCurrentTargetPos()))
                    local tCurTargetPos = oWeapon:GetCurrentTargetPos()
                    if M28Utilities.IsTableEmpty(tCurTargetPos) == false then
                        M28Utilities.DrawLocation(tCurTargetPos, nil, 3, 200)
                    end
                else
                    LOG(sFunctionRef..': Valid target='..oWeapon:GetCurrentTarget().UnitId..M28UnitInfo.GetUnitLifetimeCount(oWeapon:GetCurrentTarget()))
                end
            else
                LOG(sFunctionRef..': Dont have a current target for this weapon')
            end
        end
        --Direct fire, t1 mobile arti, t2 mobile missile launchers, and experimental land
        if oWeapon.GetCurrentTarget and (oWeaponBP.WeaponCategory == 'Direct Fire' or oWeaponBP.WeaponCategory == 'Direct Fire Naval' or oWeaponBP.WeaponCategory == 'Direct Fire Experimental' or (oWeaponBP.WeaponCategory == 'Artillery' and EntityCategoryContains(categories.TECH1, oUnit.UnitId)) or (oWeaponBP.WeaponCategory == 'Missile' and oWeaponBP.MaxRadius <= 80) or (not(M28Utilities.bFAFActive) and (oUnit[M28UnitInfo.refiCombatRange] or 0) > 0 and (oWeaponBP.RangeCategory == 'UWRC_IndirectFire' or oWeaponBP.RangeCategory == 'UWRC_DirectFire'))) or (oWeaponBP.WeaponCategory == 'Indirect Fire' and oWeaponBP.MuzzleVelocity <= 25) then
            if bDebugMessages == true then LOG(sFunctionRef..': Have a valid weapon category, will see if have targets to consider dodging') end
            local oWeaponTarget
            local iRadiusSize = math.min(5, 1 + math.max(oWeaponBP.DamageRadius + 0.5 + 7 * (oWeaponBP.FiringRandomness or 0), 1))
            local tWeaponTarget
            if oWeapon.GetCurrentTarget and not(oWeapon:BeenDestroyed()) then oWeaponTarget = oWeapon:GetCurrentTarget() end
            local bConsiderUnitsInArea = false
            if not(M28UnitInfo.IsUnitValid(oWeaponTarget)) or EntityCategoryContains(categories.NAVAL * categories.MOBILE, oWeaponTarget.UnitId) or ((oWeaponBP.DamageRadius or 0) >= 1 and ((oWeaponBP.FiringTolerance or 0) >= 0.5 or oWeapon.WeaponCategory == 'Artillery')) then bConsiderUnitsInArea = true end

            local tUnitsToConsiderDodgeFor = {}
            function ConsiderAddingUnitToTable(oCurUnit, bIncludeBusyUnits)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we should add oCurUnit='..oCurUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oCurUnit)..'; Brain='..oCurUnit:GetAIBrain().Nickname..'; Unit state='..M28UnitInfo.GetUnitState(oCurUnit)..'; Special micro active='..tostring(oCurUnit[M28UnitInfo.refbSpecialMicroActive] or false)..'; Time='..GetGameTimeSeconds()..'; refiGameTimeToResetMicroActive='..(oCurUnit[M28UnitInfo.refiGameTimeToResetMicroActive] or 'nil')) end
                if oCurUnit:GetAIBrain().M28AI and not(oCurUnit:GetAIBrain().M28Easy) and (bIncludeBusyUnits or (not(oCurUnit:IsUnitState('Upgrading')) and (not(oCurUnit[M28UnitInfo.refbSpecialMicroActive]) or oCurUnit[M28UnitInfo.refbLowerPriorityMicroActive]))) then
                    if EntityCategoryContains(categories.AIR + categories.STRUCTURE, oCurUnit.UnitId) then
                        --Do nothing
                    elseif EntityCategoryContains(categories.MOBILE, oCurUnit.UnitId) then
                        if oCurUnit:GetFractionComplete() == 1 and M28UnitInfo.IsUnitValid(oCurUnit) then
                            if not(oUnit[M28UnitInfo.refbEasyBrain]) then
                                --Engineers - dont dodge if almost done construction
                                if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oCurUnit.UnitId) and oCurUnit:GetWorkProgress() >= 0.95 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Wont dodge shot as almost done with construction') end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': Added unit to table of units to consider dodging for') end
                                    table.insert(tUnitsToConsiderDodgeFor, oCurUnit)
                                end
                            end
                        end
                    end
                end
            end
            local bIncludeBusyUnits = false
            if oWeaponBP.Damage >= 5000 then bIncludeBusyUnits = true end
            if not(bConsiderUnitsInArea) then
                --Is it a unit with a shield?
                if EntityCategoryContains(categories.SHIELD, oWeaponTarget.UnitId) then
                    --local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oWeaponTarget, true)
                    if oUnit.MyShield.GetHealth and oUnit.MyShield:GetHealth() > 0 then --was 0.2 pre-v130, and 0.05 pre v150
                        ConsiderAddingUnitToTable(oWeaponTarget, bIncludeBusyUnits)
                    end
                else
                    ConsiderAddingUnitToTable(oWeaponTarget, bIncludeBusyUnits)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Dont want to consider units in area so will only consider oWeaponTarget') end

            else
                --Does the weapon have an aoe?
                if bDebugMessages == true then LOG(sFunctionRef..': oWeaponBP.DamageRadius='..(oWeaponBP.DamageRadius or 'nil')..'; will consider units in an area if it is an aoe attack, oWeaponTarget='..(oWeaponTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oWeaponTarget) or 'nil')) end
                if (oWeaponBP.DamageRadius or 0) > 0.1 then
                    --Get all units in area
                    if oWeaponTarget then
                        tWeaponTarget = oWeaponTarget:GetPosition()
                        --Add to list of locations in the zone to avoid if its an M28 unit  and we arent getting close to unit cap and early-mid game
                        --Commented out as not sure it makes things better
                        --[[if oWeaponTarget:GetAIBrain().M28AI and GetGameTimeSeconds() <= 1800 and (oWeaponTarget:GetAIBrain()[M28Overseer.refiExpectedRemainingCap] or 0) >= 200 and tWeaponTarget[2] >= M28Map.iMapWaterHeight then
                            local tTargetLZData, tTargetLZTeamData = M28Map.GetLandOrWaterZoneData(tWeaponTarget, true, oWeaponTarget:GetAIBrain().M28Team)
                            local iExistingEntries = 0
                            if M28Utilities.IsTableEmpty(tTargetLZTeamData[M28Map.reftiLocationsToAvoid]) == false then
                                iExistingEntries = table.getn(tTargetLZTeamData[M28Map.reftiLocationsToAvoid])
                            else
                                tTargetLZTeamData[M28Map.reftiLocationsToAvoid] = {}
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iExistingEntries in locations to avoid='..iExistingEntries..'; if <10 then will insert') end
                            if iExistingEntries < 10 then
                                local tTargetToAvoid = {tWeaponTarget[1], tWeaponTarget[2], tWeaponTarget[3]}
                                table.insert(tTargetLZTeamData[M28Map.reftiLocationsToAvoid], tTargetToAvoid)
                                ForkThread(DelayedRemovalOfTargetToAvoid, tTargetLZTeamData, tTargetToAvoid, 3)
                            end
                        end--]]
                    else
                        tWeaponTarget = oWeapon:GetCurrentTargetPos()
                    end

                    if M28Utilities.IsTableEmpty(tWeaponTarget) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': iRadiusSize='..iRadiusSize..'; based ond amage radius='..oWeaponBP.DamageRadius..'; and firing randomness='..(oWeaponBP.FiringRandomness or 'nil')..'; will draw weapon target')
                            M28Utilities.DrawLocation(tWeaponTarget, 1)
                        end
                        local tAllUnitsInArea = GetUnitsInRect(Rect(tWeaponTarget[1]-iRadiusSize, tWeaponTarget[3]-iRadiusSize, tWeaponTarget[1]+iRadiusSize, tWeaponTarget[3]+iRadiusSize))
                        if M28Utilities.IsTableEmpty(tAllUnitsInArea) == false then
                            --Do we have shield units in the area with at least 20% shield? Will assume shield covers all the units
                            local tShieldsInArea = EntityCategoryFilterDown(categories.SHIELD, tAllUnitsInArea)
                            local bUnderMobileShield = false
                            if M28Utilities.IsTableEmpty(tShieldsInArea) == false then
                                local iCurShield, iMaxShield
                                for iShield, oShield in tShieldsInArea do
                                    iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                                    if bDebugMessages == true then LOG(sFunctionRef..': oCurUnit='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; iCurShield='..iCurShield..'; iMaxShield='..iMaxShield) end
                                    if (iCurShield or 0) > (iMaxShield or 0) * 0.2 then
                                        bUnderMobileShield = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': Unit has at least 20% shield remaining so wont dodge') end
                                        break
                                    end
                                end
                            end
                            if not(bUnderMobileShield) then
                                for iNearbyUnit, oNearbyUnit in tAllUnitsInArea do
                                    --Exclude shields (note we also exclude shields that are directly targeted further above)
                                    if oUnit.MyShield.GetHealth and oUnit.MyShield:GetHealth() > 0 and (oUnit:GetBlueprint().Defense.Shield.ShieldSize or 0) > 1.5 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Mobile shield that is still active so wont try and dodge') end
                                    else
                                        ConsiderAddingUnitToTable(oNearbyUnit, bIncludeBusyUnits)
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of units to consider dodging empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToConsiderDodgeFor))..'; Weapon damage='..oWeaponBP.Damage) end
            if M28Utilities.IsTableEmpty(tUnitsToConsiderDodgeFor) == false then
                local bOnlyDodgeIfNotMoving = false
                --Calculate time to impact
                local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oWeapon:GetCurrentTargetPos())
                local iMaxTimeToRun = 3
                if oWeaponBP.WeaponCategory == 'Artillery' or ((M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) and oWeaponBP.BallisticArc == 'RULEUBA_HighArc') then
                    iDistToTarget = iDistToTarget + 15
                    iMaxTimeToRun = 0.8
                elseif oWeaponBP.WeaponCategory == 'Missile' or oWeaponBP.Label == 'MissileWeapon' or oWeaponBP.Label == 'MissileRack' then
                    iDistToTarget = iDistToTarget + 10
                    iMaxTimeToRun = 0.8
                    if tWeaponTarget and iRadiusSize then
                        bOnlyDodgeIfNotMoving = true
                    end
                end
                local iShotSpeed = oWeaponBP.MuzzleVelocity
                local iTimeUntilImpact = iDistToTarget / iShotSpeed
                local bCancelDodge = false
                local iHoverMaxTimeToRun

                if iMaxTimeToRun < 1.1 then iHoverMaxTimeToRun = 1.1 end
                if bDebugMessages == true then LOG(sFunctionRef..': Dist to target='..iDistToTarget..'; Shot speed='..iShotSpeed..'; iTimeUntilImpact='..iTimeUntilImpact..'; Is weapon target a bot='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryLightAttackBot, (oWeaponTarget.UnitId or 'uel0001')))..'; bOnlyDodgeIfNotMoving='..tostring(bOnlyDodgeIfNotMoving)..'; tWeaponTarget='..repru(tWeaponTarget)..'; iRadiusSize='..(iRadiusSize or 'nil')..'; oWeaponBP.WeaponCategory='..(oWeaponBP.WeaponCategory or 'nil')..'; oWeaponBP.Label='..(oWeaponBP.Label or 'nil')..'; bOnlyDodgeIfNotMoving='..tostring(bOnlyDodgeIfNotMoving)) end
                if iTimeUntilImpact > 0.8 or (oWeaponTarget and EntityCategoryContains(M28UnitInfo.refCategoryLightAttackBot, oWeaponTarget.UnitId) and iTimeUntilImpact >= 0.2) then
                    for iTarget, oTarget in tUnitsToConsiderDodgeFor do
                        bCancelDodge = false
                        if bDebugMessages == true then LOG(sFunctionRef..': oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Weapon damage='..oWeaponBP.Damage..'; Target health='..oTarget:GetHealth()) end
                        --Does the shot do enough damage that we want to try and dodge it? (experimentals - consider high damage shots like ythotha ball)
                        if ((oTarget[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oTarget)) < 12500 or oWeaponBP.Damage >= 3000) and (oWeaponBP.Damage / oTarget:GetHealth() >= 0.01 or (EntityCategoryContains(categories.COMMAND, oTarget.UnitId) and ((oWeaponBP.WeaponCategory == 'Artillery' and EntityCategoryContains(categories.INDIRECTFIRE - categories.TECH3, oUnit.UnitId) and (oWeaponBP.Damage / oTarget:GetHealth() >= 0.0035)) or (oWeaponBP.WeaponCategory == 'Missile' and EntityCategoryContains(categories.INDIRECTFIRE - categories.TECH3, oUnit.UnitId) and (oWeaponBP.Damage / oTarget:GetHealth() >= 0.006))))) then
                            --Dont bother dodging if missile attack and we are moving away from it
                            if bOnlyDodgeIfNotMoving then
                                local tFirstOrder = oUnit[M28Orders.reftiLastOrders][1]
                                if bDebugMessages == true then LOG(sFunctionRef..': Only want to dodge if we are moving and will be far away from the waepon target, order type='..(tFirstOrder[M28Orders.subrefiOrderType] or 'nil')..'; Dist from weapon target='..M28Utilities.GetDistanceBetweenPositions(tWeaponTarget, oUnit:GetPosition())..'; iRadiusSize='..iRadiusSize) end
                                if tFirstOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueMove and M28Utilities.GetDistanceBetweenPositions(tWeaponTarget, oUnit:GetPosition()) > 2 + iRadiusSize then
                                    bCancelDodge = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Dodging missile - we are already planning on moving away from the missile') end
                                end
                            end
                            if not(bCancelDodge) then
                                --Do we think we can dodge the shot?
                                --If we are a large unit then only dodge if will be a while for the shot to hit
                                local oBP = oTarget:GetBlueprint()
                                local iAverageSize = (oBP.SizeX + oBP.SizeZ) * 0.5
                                if bDebugMessages == true then LOG(sFunctionRef..': iAverageSize='..iAverageSize..'; Is unit underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; Unit speed='..oBP.Physics.MaxSpeed..'; iTimeUntilImpact='..iTimeUntilImpact..';  math.min(2.5, 0.4 + iAverageSize * 1.5 / oBP.Physics.MaxSpeed)='.. math.min(2.5, 0.4 + iAverageSize * 1.5 / oBP.Physics.MaxSpeed)) end
                                if iAverageSize < 0.89 or (iTimeUntilImpact > math.min(2.5, 0.4 + iAverageSize * 1.5 / oBP.Physics.MaxSpeed) and (iTimeUntilImpact >= 2 or not(EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId)))) then
                                    --Are we not underwater?
                                    if not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                                        --If dealing with an ACU then drastically reduce the dodge time so we can overcharge if we havent recently and have enemies in range and enough power
                                        if EntityCategoryContains(categories.COMMAND, oTarget.UnitId) then
                                            if oTarget:IsUnitState('Teleporting') or (oTarget:IsUnitState('Upgrading') and M28UnitInfo.GetUnitHealthPercent(oTarget) >= 0.9 - oTarget:GetWorkProgress()) then
                                                --Dont cancel upgrade/teleport
                                                bCancelDodge = true
                                                --Dont have ACU dodge missiles if it is retreating (since missiles arent homing)
                                            elseif oTarget:IsUnitState('Moving') and GetGameTimeSeconds() - (oTarget[M28ACU.refiTimeLastWantedToRun] or 0) <= 2 and oWeaponBP.WeaponCategory == 'Missile' and EntityCategoryContains(categories.INDIRECTFIRE - categories.STRUCTURE, oUnit.UnitId) and oTarget[M28Orders.reftiLastOrders][oTarget[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueMove and M28Utilities.GetDistanceBetweenPositions(oTarget[M28Orders.reftiLastOrders][oTarget[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition], oTarget:GetPosition()) >= 5 then
                                                bCancelDodge = true
                                            elseif M28Conditions.CanUnitUseOvercharge(oTarget:GetAIBrain(), oTarget) and (GetGameTimeSeconds() - (oTarget[M28UnitInfo.refiTimeOfLastOverchargeShot] or 0)) > 5 then
                                                --If we have units we can hit then cancel
                                                if oTarget:GetHealth() >= 5000 and (GetGameTimeSeconds() - (oTarget[M28UnitInfo.refiLastWeaponEvent] or 0) <= 2 or M28Utilities.IsTableEmpty(oTarget:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat, oTarget:GetPosition(), oTarget[M28UnitInfo.refiDFRange], 'Enemy')) == false) then
                                                    bCancelDodge = true
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will cancel dodge as we can overcharge instead, time since last overcharge='..(GetGameTimeSeconds() - (oTarget[M28UnitInfo.refiTimeOfLastOverchargeShot] or 0))..'; Brain energy stored='..oTarget:GetAIBrain():GetEconomyStored('ENERGY')) end
                                                else
                                                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                                                    local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
                                                    if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 200 then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Reducing dodge time drastically as have ACU that can overcharge enemies in range but it also wants to dodge a shot; will cancel if damage is very low that are dodging. oWeaponBP.Damage='..oWeaponBP.Damage) end
                                                        if oWeaponBP.Damage <= 100 then
                                                            bCancelDodge = true
                                                        else
                                                            iMaxTimeToRun = math.min(0.8, iMaxTimeToRun) --(M27 uses 0.9; if set too low then ACU may not actually move)
                                                        end
                                                    end
                                                end
                                            end
                                        elseif EntityCategoryContains(categories.EXPERIMENTAL, oTarget.UnitId) then
                                            --If we are a GC, Monkey or Ythotha that has an enemy experimental nearby but not in range, then cancel dodging as want to get in range to be able to  fire
                                            local oTargetBP = oTarget:GetBlueprint()
                                            if bDebugMessages == true then LOG(sFunctionRef..': Deciding if experimental wants to dodge shot, iDistToTarget='..iDistToTarget..'; Damage='..oWeaponBP.Damage..'; Experimental size='..math.max(oTargetBP.SizeX, oTargetBP.SizeZ)..'; Time since last weapon event='..GetGameTimeSeconds() - (oTarget[M28UnitInfo.refiLastWeaponEvent] or 0)) end
                                            --Dont dodge at all if we have fired recently and the damage isn't massive
                                            if GetGameTimeSeconds() - (oTarget[M28UnitInfo.refiLastWeaponEvent] or 0) <= 5 and oWeaponBP.Damage <= 4000 then
                                                bCancelDodge = true
                                                if bDebugMessages == true then LOG(sFunctionRef..': Target is an experimental that has fired recently and the damage isnt massive so we dont want to dodge, weapon damage='..(oWeaponBP.Damage or 'nil')) end
                                            elseif iDistToTarget <= 90 and math.max(oTargetBP.SizeX, oTargetBP.SizeZ) >= 7 and (GetGameTimeSeconds() - (oTarget[M28UnitInfo.refiLastWeaponEvent] or 0) <= 20 or oWeaponBP.Damage <= 4000) then --megalith and fatboy
                                                bCancelDodge = true
                                                if bDebugMessages == true then LOG(sFunctionRef..': Megalith or fatboy in size so wont dodge shot') end
                                            else
                                                local tLastOrder = oTarget[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]]
                                                if tLastOrder[M28Orders.refiOrderIssueAttack] and M28UnitInfo.IsUnitValid(tLastOrder[M28Orders.subrefoOrderUnitTarget]) and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental + categories.COMMAND, tLastOrder[M28Orders.subrefoOrderUnitTarget].UnitId) and (not(EntityCategoryContains(M28UnitInfo.refCategoryYthotha, tLastOrder[M28Orders.subrefoOrderUnitTarget].UnitId)) or oWeaponBP.Damage <= 4000) then
                                                    bCancelDodge = true
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Target '..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..' was trying to attack an enemy exp or ACU, targets target='..tLastOrder[M28Orders.subrefoOrderUnitTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(tLastOrder[M28Orders.subrefoOrderUnitTarget])..'; so will cancel dodge') end
                                                end
                                            end
                                            if not(bCancelDodge) and not(oUnit[M28UnitInfo.refbCanKite]) then
                                                --Special case - if dealing with say a GC that is trying to dodge a shot from a ythotha, then get its facing to that unit, and dont dodge if angle dif is so large that it would likely cause it to stop firing at the unit if it was to dodge
                                                if oTarget.UnitId == 'ual0401' and oUnit.UnitId and M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), oUnit:GetPosition()) <= oTarget[M28UnitInfo.refiDFRange] then
                                                    local iCurFacingAngle = M28UnitInfo.GetUnitFacingAngle(oTarget)
                                                    local iAngleToAttacker = M28Utilities.GetAngleFromAToB(oTarget:GetPosition(), oUnit:GetPosition())
                                                    local iAngleDif = M28Utilities.GetAngleDifference(iCurFacingAngle, iAngleToAttacker)
                                                    if iAngleDif > 15 then bCancelDodge = true end
                                                    if bDebugMessages == true then LOG(sFunctionRef..'; Considering whether to abort dodge, iAngleDif='..iAngleDif..'; bCancelDodge='..tostring(bCancelDodge)) end
                                                end
                                            end
                                        end

                                        if not(bCancelDodge) then
                                            iMaxTimeToRun = math.min(2.5, iMaxTimeToRun)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will try to dodge shot. iTimeUntilImpact='..iTimeUntilImpact..'; iMaxTimeToRun='..iMaxTimeToRun..'; iAverageSize='..iAverageSize) end
                                            if iHoverMaxTimeToRun and EntityCategoryContains(categories.HOVER, oTarget.UnitId) then
                                                DodgeShot(oTarget, oUnit, oWeapon, math.min(math.max(0.95, iTimeUntilImpact), iHoverMaxTimeToRun))
                                            elseif iAverageSize < 1 and iTimeUntilImpact <= 1.1 and oBP.Physics.MaxSpeed >= 3 and oBP.Physics.MaxAcceleration >= 3 and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oTarget.UnitId)) then
                                                AltDodgeShot(oTarget, oUnit, oWeapon, math.min(iTimeUntilImpact, iMaxTimeToRun))
                                            else
                                                DodgeShot(oTarget, oUnit, oWeapon, math.min(iTimeUntilImpact, iMaxTimeToRun))
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DodgeShot(oTarget, oWeapon, oAttacker, iTimeToDodge)
    --Should have already checked oTarget is a valid unit that has a chance of dodging the shot in time before claling this
    --Gets unit to move at a slightly different angle to its current facing direction for iTimeToDodge
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DodgeShot'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..' owned by brain '..oTarget:GetAIBrain().Nickname..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oTarget))..'; oAttacker='..(oAttacker.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oAttacker) or 'nil')) end

    M28Orders.UpdateRecordedOrders(oTarget)
    local tCurDestination
    local bAttackMove = false
    --ACU special - if ACU wants to run, then ignore hte last order and instead treat it as tyring to run to base
    if oTarget[M28ACU.refiTimeLastWantedToRun] and GetGameTimeSeconds() - (oTarget[M28ACU.refiTimeLastWantedToRun] or -100) <= 5 or (EntityCategoryContains(categories.COMMAND, oTarget.UnitId) and M28UnitInfo.GetUnitHealthPercent(oTarget) <= 0.6) then
        local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oTarget:GetPosition(), true, oTarget:GetAIBrain().M28Team)
        if tLZOrWZTeamData then tCurDestination = {tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][1], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][2], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][3]} end
    elseif EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryIndirect - categories.EXPERIMENTAL, oTarget.UnitId) then
        local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oTarget:GetPosition(), true, oTarget:GetAIBrain().M28Team)
        if tLZOrWZTeamData then tCurDestination = {tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][1], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][2], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][3]} end
    elseif oTarget[M28Orders.refiOrderCount] > 0 then
        if oTarget[M28Orders.reftMoveDestinationIgnoredDueToMicro] then tCurDestination = {oTarget[M28Orders.reftMoveDestinationIgnoredDueToMicro][1], oTarget[M28Orders.reftMoveDestinationIgnoredDueToMicro][2], oTarget[M28Orders.reftMoveDestinationIgnoredDueToMicro][3]}
        else
            local tLastOrder = oTarget[M28Orders.reftiLastOrders][oTarget[M28Orders.refiOrderCount]]
            tCurDestination = tLastOrder[M28Orders.subreftOrderPosition]
            if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAttack or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAggressiveMove or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAggressiveFormMove then
                bAttackMove = true
            end
        end
    end

    local iCurFacingAngle = M28UnitInfo.GetUnitFacingAngle(oTarget)
    local iAngleToDestination
    if tCurDestination then iAngleToDestination = M28Utilities.GetAngleFromAToB(oTarget:GetPosition(), tCurDestination)
    else
        iAngleToDestination = iCurFacingAngle
        tCurDestination = oTarget:GetPosition()
    end

    local oBP = oTarget:GetBlueprint()
    local iSpeed = oBP.Physics.MaxSpeed
    local iDistanceToRun = (iTimeToDodge + (M28Land.iTicksPerLandCycle - 1) / 10) * iSpeed
    local iUnitSize = oBP.SizeX + oBP.SizeZ
    local iAngleAdjust = math.max(15, oBP.Physics.TurnRate * 0.3)
    if iUnitSize >= 2 then
        if iUnitSize >= 4 then iAngleAdjust = iAngleAdjust * 2.5
        else iAngleAdjust = iAngleAdjust * 1.75
        end
        if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oTarget.UnitId) then
            iAngleAdjust = math.min(iAngleAdjust, 30)
        end
    end

    --Non-experimental skirmishers - try to move at an adjustment to the angle to the destination rather htan the unit facing direction so less likely to move into range of enemy
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if have skirmisher or ACU; ACU time since last wanted to retreat (if this was an ACU)='..GetGameTimeSeconds() - (oTarget[M28ACU.refiTimeLastWantedToRun] or 0)) end
    if EntityCategoryContains(M28UnitInfo.refCategorySkirmisher - categories.EXPERIMENTAL, oTarget.UnitId) or (oTarget[M28UnitInfo.refiTimeLastTriedRetreating] and GetGameTimeSeconds() - oTarget[M28UnitInfo.refiTimeLastTriedRetreating] <= math.max(2, M28Land.iTicksPerLandCycle * 0.1 + 0.1)) or (EntityCategoryContains(categories.COMMAND, oTarget.UnitId) and oTarget[M28ACU.refiTimeLastWantedToRun] and GetGameTimeSeconds() - oTarget[M28ACU.refiTimeLastWantedToRun] <= 3)
    --MMLs - we might be near PD meaning dodging will take us in range of it
    or ((oTarget[M28UnitInfo.refiIndirectRange] or 0) > 0 and not(EntityCategoryContains(categories.TECH1, oTarget.UnitId)) and not(oTarget[M28UnitInfo.refbSpecialMicroActive]) and not(oTarget[M28Orders.reftiLastOrders][1][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueMove)) then
        local iAngleDifToDestination = M28Utilities.GetAngleDifference(iCurFacingAngle, iAngleToDestination)
        if bDebugMessages == true then LOG(sFunctionRef..': iAngleDifToDestination='..iAngleDifToDestination..'; iAngleAdjust='..iAngleAdjust) end
        if iAngleDifToDestination >= math.max(iAngleAdjust, 45) then
            if bDebugMessages == true then LOG(sFunctionRef..': Increasing angle adjust as have a skirmisher or retreating ACU, iAngleAdjust before increase='..iAngleAdjust..'; iAngleDifToDestination='..iAngleDifToDestination) end
            iAngleAdjust = math.max(iAngleAdjust, iAngleDifToDestination * 0.7)
        end
    end

    if M28Utilities.GetAngleDifference(iCurFacingAngle + iAngleAdjust, iAngleToDestination) > M28Utilities.GetAngleDifference(iCurFacingAngle - iAngleAdjust, iAngleToDestination) then
        iAngleAdjust = iAngleAdjust * -1
    end

    local tTempDestination = M28Utilities.MoveInDirection(oTarget:GetPosition(), iCurFacingAngle + iAngleAdjust, iDistanceToRun, true, false, true)
    if bDebugMessages == true then LOG(sFunctionRef..': oTarget (ie unit that is dodging)='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; clearing current orders which have a possible destination of '..repru(tCurDestination)..'; and giving an order to move to '..repru(tTempDestination)..'; Dist from our position to temp position='..M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), tTempDestination)..'; iAngleAdjust='..iAngleAdjust..'; Unit size='..iUnitSize..'; iTimeToDodge='..iTimeToDodge) end
    --M28Orders.IssueTrackedClearCommands(oTarget)
    TrackTemporaryUnitMicro(oTarget, iTimeToDodge)
    M28Orders.IssueTrackedMove(oTarget, tTempDestination, 0.25, false, 'MiDod1', true)
    --Also send an order to go to the destination that we had before
    if bAttackMove then
        M28Orders.IssueTrackedAttackMove(oTarget, tCurDestination, 0.25, true, 'MiDod2', true)
    else
        --M28Orders.IssueTrackedMove(oTarget, tCurDestination, 0.25, true, 'MiDod3', true)
        --Disabled for v89 given new 'get goal' position and increase in the micro dodge distance
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AltDodgeShot(oTarget, oWeapon, oAttacker, iTimeToDodge)
    --Intended for units like LABs, making use of new logic to change existing move order
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AltDodgeShot'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oTarget))) end

    M28Orders.UpdateRecordedOrders(oTarget)
    local iCurFacingAngle = M28UnitInfo.GetUnitFacingAngle(oTarget)
    local iAngleToMove = iCurFacingAngle + 120
    if iAngleToMove > 360 then iAngleToMove = iAngleToMove - 360 end
    local oBP = oTarget:GetBlueprint()
    local iSpeed = oBP.Physics.MaxSpeed
    local iDistanceToRun = iTimeToDodge * iSpeed
    local tTempDestination = M28Utilities.MoveInDirection(oTarget:GetPosition(), iAngleToMove, iDistanceToRun, true, false, true)
    TrackTemporaryUnitMicro(oTarget, iTimeToDodge)
    M28Orders.IssueTrackedMove(oTarget, tTempDestination, 0.1, false, 'MiAltDod1', true)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function EnableUnitMicroUntilManuallyTurnOff(oUnit, bLowerPriorityMicro)
    oUnit[M28UnitInfo.refbSpecialMicroActive] = true
    if bLowerPriorityMicro then oUnit[M28UnitInfo.refbLowerPriorityMicroActive] = true
    else
        if oUnit[M28UnitInfo.refbLowerPriorityMicroActive] then oUnit[M28UnitInfo.refbLowerPriorityMicroActive] = nil end
    end
    oUnit[M28UnitInfo.refiGameTimeMicroStarted] = GetGameTimeSeconds()
    oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] = -1
end

function TrackTemporaryUnitMicro(oUnit, iSecondsActiveFor, sOptionalAdditionalTrackingVar, bLowerPriorityMicro)
    --Where we are doing all actions upfront can call this to enable micro and then turn the flag off after set period of time
    --Note that air logic currently doesnt make use of this
    --bLowerPriorityMicro - if this is true then this will be ignored by 'higher priority micro'
    --if iSecondsActiveFor is 0 then treat as infinite and dont reset the flag
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TrackTemporaryUnitMicro'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    oUnit[M28UnitInfo.refbSpecialMicroActive] = true
    if bLowerPriorityMicro then oUnit[M28UnitInfo.refbLowerPriorityMicroActive] = true
    else
        if oUnit[M28UnitInfo.refbLowerPriorityMicroActive] then oUnit[M28UnitInfo.refbLowerPriorityMicroActive] = nil end
    end
    oUnit[M28UnitInfo.refiGameTimeMicroStarted] = GetGameTimeSeconds()
    oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] = GetGameTimeSeconds() + iSecondsActiveFor
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[M28UnitInfo.refbSpecialMicroActive]='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive] or false)..'; oUnit[M28UnitInfo.refiGameTimeMicroStarted]='..oUnit[M28UnitInfo.refiGameTimeMicroStarted]..'; oUnit[M28UnitInfo.refiGameTimeToResetMicroActive]='..oUnit[M28UnitInfo.refiGameTimeToResetMicroActive]..'; iSecondsActiveFor='..iSecondsActiveFor) end
    if iSecondsActiveFor == 0 then
        --Do nothing
    else
        ForkThread(ForkedResetMicroFlag, oUnit, iSecondsActiveFor - 0.01, sOptionalAdditionalTrackingVar)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ForkedResetMicroFlag(oUnit, iTimeToWait, sOptionalAdditionalTrackingVar, bCalledFromResetChecker)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ForkedResetMicroFlag'

    oUnit[M28UnitInfo.refbSpecialMicroActive] = true --As if we are calling an action for the micro that clears commands, then that will reset the micro flag
    if iTimeToWait > 0 then
        WaitSeconds(iTimeToWait)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28UnitInfo.IsUnitValid(oUnit) then
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if micro flag can be reset to false for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at time='..GetGameTimeSeconds()..'; Time to reset flag='..(oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] or 'nil')) end
        if GetGameTimeSeconds() + 0.02 > oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] or not(oUnit[M28UnitInfo.refbSpecialMicroActive]) then
            if bDebugMessages == true then LOG(sFunctionRef..': Have reset flag') end
            oUnit[refbMicroResetChecker] = nil
            oUnit[M28UnitInfo.refbSpecialMicroActive] = false
            oUnit[M28UnitInfo.refbLowerPriorityMicroActive] = nil
            if sOptionalAdditionalTrackingVar then
                oUnit[sOptionalAdditionalTrackingVar] = false
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Will try waiting one more cycle to see if we need to reset the flag unless already got an active reset checker, MicroResetChecker='..tostring(oUnit[refbMicroResetChecker] or false)) end
            if not(oUnit[refbMicroResetChecker]) or bCalledFromResetChecker then
                oUnit[refbMicroResetChecker] = true
                ForkThread(ForkedResetMicroFlag,oUnit, math.max(oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] - GetGameTimeSeconds() - 0.01, 0.2), sOptionalAdditionalTrackingVar, true)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ForkedMoveInCircleOld(oUnit, iTimeToRun, bDontTreatAsMicroAction, bDontClearCommandsFirst, iCircleSizeOverride, iTickWaitOverride)
    --More intensive version of MoveAwayFromTargetTemporarily, intended e.g. for ACUs
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ForkedMoveInCircle'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local refbActiveCircleMicro = 'M28MicroActiveCircleMicro'

    if bDebugMessages == true then LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..'; Unit has active circle micro='..tostring(oUnit[refbActiveCircleMicro] or false)) end
    if not(oUnit[refbActiveCircleMicro]) then

        --KEY CONFIG SETTINGS: (these will work sometimes but not always against an aeon strat)
        local iInitialAngleAdj = 15
        local iInitialDistanceAdj = -1
        local iDistanceAwayToMove = (iCircleSizeOverride or 2)
        local iAngleMaxSingleAdj = 45
        local iTicksBetweenOrders = (iTickWaitOverride or 4)

        if iDistanceAwayToMove > oUnit:GetBlueprint().Physics.MaxSpeed * 1.5 then
            iAngleMaxSingleAdj = math.max(25, iAngleMaxSingleAdj * 2.5 / iDistanceAwayToMove)
        end



        local iStartTime = GetGameTimeSeconds()
        oUnit[M28UnitInfo.refiGameTimeMicroStarted] = iStartTime
        local iLoopCount = 0
        local iMaxLoop = iTimeToRun * 10 + 1
        --Distance from point A to point B will be much less than distanceaway to move, since that is the distance from the centre (radius) rather than the distance between 1 points on the circle edge; for simplicity will assume that distance is 0.25 of the distance from the centre
        if bDontTreatAsMicroAction then iMaxLoop = math.ceil(iTimeToRun / (iDistanceAwayToMove / oUnit:GetBlueprint().Physics.MaxSpeed)) * 4 end
        local tUnitStartPosition = oUnit:GetPosition()

        local iCurFacingDirection = M28UnitInfo.GetUnitFacingAngle(oUnit)
        local iAngleAdjFactor = 1

        local tTempLocationToMove

        local bRecentMicro = false
        local iRecentMicroThreshold = 1
        local iGameTime = GetGameTimeSeconds()
        if oUnit[M28UnitInfo.refbSpecialMicroActive] and iGameTime - oUnit[M28UnitInfo.refiGameTimeMicroStarted] < iRecentMicroThreshold then bRecentMicro = true end
        if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop for move commands for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTimeToRun='..iTimeToRun..'; iStartTime='..iStartTime..'; iCurFacingDirection='..iCurFacingDirection..'; tUnitStartPosition='..repru(tUnitStartPosition)..'; bRecentMicro='..tostring((bRecentMicro or false))..'; bDontClearCommandsFirst='..tostring(bDontClearCommandsFirst or false)..'; oUnit[M28UnitInfo.refbSpecialMicroActive]='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive])..'; oUnit[M28UnitInfo.refiGameTimeMicroStarted]='..(oUnit[M28UnitInfo.refiGameTimeMicroStarted] or 'nil')..'; GameTime='..iGameTime..'; Dif='..iGameTime-(oUnit[M28UnitInfo.refiGameTimeMicroStarted] or 0)..'; bDontTreatAsMicroAction='..tostring((bDontTreatAsMicroAction or false))) end
        if bRecentMicro == false and not(bDontClearCommandsFirst) then
            M28Orders.IssueTrackedClearCommands(oUnit)
            if bDebugMessages == true then LOG(sFunctionRef..': Issued clear commands order to the unit') end
        end
        if not(bDontTreatAsMicroAction) then
            TrackTemporaryUnitMicro(oUnit, iTimeToRun, refbActiveCircleMicro)
            if bDebugMessages == true then LOG(sFunctionRef..': Will temporarily track the unit micro. iTimeToRun='..(iTimeToRun or 'nil')) end
        else
            TrackTemporaryUnitMicro(oUnit, iTimeToRun)
        end

        local iTempAngleDirectionToMove = iCurFacingDirection + iInitialAngleAdj * iAngleAdjFactor
        local iTempDistanceAwayToMove
        local bTimeToStop = false
        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; refbSpecialMicroActive='..tostring((oUnit[M28UnitInfo.refbSpecialMicroActive] or false))..'; iMaxLoop='..iMaxLoop) end
        while bTimeToStop == false do
            iLoopCount = iLoopCount + 1
            if iLoopCount > iMaxLoop then break
            elseif M28UnitInfo.IsUnitValid(oUnit) == false then break end --No longer give error message as may be calling this for intel scouts now

            iTempAngleDirectionToMove = iTempAngleDirectionToMove + iAngleMaxSingleAdj * iAngleAdjFactor
            if iTempAngleDirectionToMove > 360 then iTempAngleDirectionToMove = iTempAngleDirectionToMove - 360 end
            --end
            iTempDistanceAwayToMove = iDistanceAwayToMove
            if iLoopCount == 1 then iTempDistanceAwayToMove = iDistanceAwayToMove + iInitialDistanceAdj end
            tTempLocationToMove = M28Utilities.MoveInDirection(tUnitStartPosition, iTempAngleDirectionToMove, iTempDistanceAwayToMove, true, false, true)
            M28Orders.IssueTrackedMove(oUnit, tTempLocationToMove, 0.25, true, 'MiCirc1', true)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(iTicksBetweenOrders)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if not(bDontTreatAsMicroAction) and not((oUnit[M28UnitInfo.refiGameTimeMicroStarted] == iStartTime and GetGameTimeSeconds() - iStartTime < iTimeToRun)) then bTimeToStop = true end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ForkedMoveInCircle(oUnit, iTimeToRun, bDontTreatAsMicroAction, bDontClearCommandsFirst, iCircleSizeOverride, iTickWaitOverride)
    --More intensive version of MoveAwayFromTargetTemporarily, intended e.g. for ACUs
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ForkedMoveInCircle'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local refbActiveCircleMicro = 'M28MicroActiveCircleMicro'

    if bDebugMessages == true then LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..'; Unit has active circle micro='..tostring(oUnit[refbActiveCircleMicro] or false)) end
    if not(oUnit[refbActiveCircleMicro]) then

        --KEY CONFIG SETTINGS: (these will work sometimes but not always against an aeon strat)
        local iDistanceAwayToMove = (iCircleSizeOverride or 2)
        local iAngleMaxSingleAdj = 20 --pre v101 was 120; see v101 devlog for testing that did; in 2 scenarios 20 degrees performed the best, although I suspect given the variance that in some scenarios it could be worse
        local iTicksBetweenOrders = (iTickWaitOverride or 1) --prev 4 (pre the change to readjust move orders instead of clearing I think)

        if iDistanceAwayToMove > oUnit:GetBlueprint().Physics.MaxSpeed * 1.5 then
            iAngleMaxSingleAdj = math.max(25, iAngleMaxSingleAdj * 2.5 / iDistanceAwayToMove)
        end



        local iStartTime = GetGameTimeSeconds()
        oUnit[M28UnitInfo.refiGameTimeMicroStarted] = iStartTime
        local iLoopCount = 0
        local iMaxLoop = iTimeToRun * 10 + 1
        --Distance from point A to point B will be much less than distanceaway to move, since that is the distance from the centre (radius) rather than the distance between 1 points on the circle edge; for simplicity will assume that distance is 0.25 of the distance from the centre
        if bDontTreatAsMicroAction then iMaxLoop = math.ceil(iTimeToRun / (iDistanceAwayToMove / oUnit:GetBlueprint().Physics.MaxSpeed)) * 4 end
        local tUnitStartPosition = oUnit:GetPosition()

        local iCurFacingDirection = M28UnitInfo.GetUnitFacingAngle(oUnit)


        local iAngleAdjFactor = 1

        local tTempLocationToMove

        local bRecentMicro = false
        local iRecentMicroThreshold = 1
        local iGameTime = GetGameTimeSeconds()
        if oUnit[M28UnitInfo.refbSpecialMicroActive] and iGameTime - oUnit[M28UnitInfo.refiGameTimeMicroStarted] < iRecentMicroThreshold then bRecentMicro = true end
        if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop for move commands for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTimeToRun='..iTimeToRun..'; iStartTime='..iStartTime..'; iCurFacingDirection='..iCurFacingDirection..'; tUnitStartPosition='..repru(tUnitStartPosition)..'; bRecentMicro='..tostring((bRecentMicro or false))..'; bDontClearCommandsFirst='..tostring(bDontClearCommandsFirst or false)..'; oUnit[M28UnitInfo.refbSpecialMicroActive]='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive])..'; oUnit[M28UnitInfo.refiGameTimeMicroStarted]='..(oUnit[M28UnitInfo.refiGameTimeMicroStarted] or 'nil')..'; GameTime='..iGameTime..'; Dif='..iGameTime-(oUnit[M28UnitInfo.refiGameTimeMicroStarted] or 0)..'; bDontTreatAsMicroAction='..tostring((bDontTreatAsMicroAction or false))..'; iAngleMaxSingleAdj='..iAngleMaxSingleAdj..'; iTicksBetweenOrders='..iTicksBetweenOrders) end
        if bRecentMicro == false and not(bDontClearCommandsFirst) then
            M28Orders.UpdateRecordedOrders(oUnit)
            local tLastOrder = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]]
            if not(tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueMove) then
                M28Orders.IssueTrackedClearCommands(oUnit)
                if bDebugMessages == true then LOG(sFunctionRef..': Issued clear commands order to the unit') end
            elseif bDebugMessages == true then LOG(sFunctionRef..': Unit last order was a move order so wont clear orders')
            end
        end
        if not(bDontTreatAsMicroAction) then
            TrackTemporaryUnitMicro(oUnit, iTimeToRun, refbActiveCircleMicro)
            if bDebugMessages == true then LOG(sFunctionRef..': Will temporarily track the unit micro. iTimeToRun='..(iTimeToRun or 'nil')) end
        else
            TrackTemporaryUnitMicro(oUnit, iTimeToRun)
        end

        local bTimeToStop = false
        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; refbSpecialMicroActive='..tostring((oUnit[M28UnitInfo.refbSpecialMicroActive] or false))..'; iMaxLoop='..iMaxLoop) end
        while bTimeToStop == false do
            iLoopCount = iLoopCount + 1
            if iLoopCount > iMaxLoop then break
            elseif M28UnitInfo.IsUnitValid(oUnit) == false then break end --No longer give error message as may be calling this for intel scouts now


            tTempLocationToMove = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28UnitInfo.GetUnitFacingAngle(oUnit) + iAngleMaxSingleAdj, iDistanceAwayToMove, true, false, true)
            M28Orders.IssueTrackedMove(oUnit, tTempLocationToMove, 0.25, false, 'MiCirc1', true)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(iTicksBetweenOrders)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if not(bDontTreatAsMicroAction) and not((oUnit[M28UnitInfo.refiGameTimeMicroStarted] == iStartTime and GetGameTimeSeconds() - iStartTime < iTimeToRun)) then bTimeToStop = true end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MoveInCircleTemporarily(oUnit, iTimeToRun, bDontTreatAsMicroAction, bDontClearCommandsFirst, iCircleSizeOverride, iTickWaitOverride)
    ForkThread(ForkedMoveInCircle, oUnit, iTimeToRun, bDontTreatAsMicroAction, bDontClearCommandsFirst, iCircleSizeOverride, iTickWaitOverride)
end

function GetOverchargeTarget(tLZData, aiBrain, oUnitWithOvercharge, bOnlyConsiderEnemiesInRange)
    --should have already confirmed overcharge action is available using CanUnitUseOvercharge
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetOverchargeTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oUnitWithOvercharge[refbOnlyOverchargeHighValueTargets]='..tostring(oUnitWithOvercharge[M28ACU.refbOnlyOverchargeHighValueTargets]  or false)..'; Brain='..oUnitWithOvercharge:GetAIBrain().Nickname) end
    local oOverchargeTarget
    if not(oUnitWithOvercharge[M28UnitInfo.refbEasyBrain]) then
        --Do we have positive energy income? If not, then only overcharge if ACU is low on health as an emergency
        local reftiAngleFromACUToUnit = 'M28AngleFromACUToUnit'
        local reftiDistFromACUToUnit = 'M28DistFromACUToUnit'
        local toStructuresAndACU

        --Subfunction
        function IsBuildingOrACUBlockingShot(oFiringUnit, oTargetUnit)
            --Assumes have already been through tBlockingUnits and set their angle to the firing unit, so we just need to compare to firing unit
            if bDebugMessages == true then LOG(sFunctionRef..': Will see if any buildings or ACU are blocking the shot; if dont get log saying result was false then means was true') end
            if M28Utilities.IsTableEmpty(toStructuresAndACU) == false then
                local iAngleToTargetUnit = M28Utilities.GetAngleFromAToB(oFiringUnit:GetPosition(), oTargetUnit:GetPosition())
                local iDistToTargetUnit = M28Utilities.GetDistanceBetweenPositions(oFiringUnit:GetPosition(), oTargetUnit:GetPosition())
                local iCurAngleDif
                if bDebugMessages == true then LOG(sFunctionRef..': iAngleToTargetUnit='..iAngleToTargetUnit..'; iDistToTargetUnit='..iDistToTargetUnit) end
                for iUnit, oUnit in toStructuresAndACU do
                    if not(oUnit == oTargetUnit) and iDistToTargetUnit > oUnit[reftiDistFromACUToUnit][aiBrain:GetArmyIndex()] then
                        iCurAngleDif = iAngleToTargetUnit - oUnit[reftiAngleFromACUToUnit][aiBrain:GetArmyIndex()]
                        if iCurAngleDif < 0 then iCurAngleDif = iCurAngleDif + 360 end
                        if bDebugMessages == true then LOG(sFunctionRef..': Checking if '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' will block a shot from the ACU to the target '..oTargetUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTargetUnit)..'; iCurAngleDif='..iCurAngleDif..'; 180 / iDistToTargetUnit='..180 / iDistToTargetUnit..'; oUnit[reftiAngleFromACUToUnit][aiBrain:GetArmyIndex()]='..oUnit[reftiAngleFromACUToUnit][aiBrain:GetArmyIndex()]..'; oUnit[reftiDistFromACUToUnit]='..oUnit[reftiDistFromACUToUnit][aiBrain:GetArmyIndex()]..'; angle from ACU to unit='..oUnit[reftiAngleFromACUToUnit][aiBrain:GetArmyIndex()]) end
                        if iCurAngleDif <= math.max(8, 180 / iDistToTargetUnit) then
                            return true
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': End of code, will return false') end
            return false
        end

        --Subfunction
        function WillShotHit(oFiringUnit, oTargetUnit)
            --Check for units in a transport
            if oTargetUnit:IsUnitState('Attached') or M28Logic.IsShotBlocked(oFiringUnit, oTargetUnit) or IsBuildingOrACUBlockingShot(oFiringUnit, oTargetUnit) then
                if bDebugMessages == true then LOG(sFunctionRef..': oTargetUnit='..oTargetUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTargetUnit)..'; shot is blocked so wont hit. IsShotBlocked='..tostring(M28Logic.IsShotBlocked(oFiringUnit, oTargetUnit))) end
                return false
            else return true
            end
        end

        local tUnitPosition = oUnitWithOvercharge:GetPosition()
        local iACURange = oUnitWithOvercharge[M28UnitInfo.refiDFRange]
        if (iACURange or 0) > 0 then
            local iOverchargeArea = 2.5

            --Consider flagging to only target high value targets if we have big gun upgrade
            if oUnitWithOvercharge[M28ACU.refiUpgradeCount] >= 2 and not(oUnitWithOvercharge[M28ACU.refbOnlyOverchargeHighValueTargets]) and (oUnitWithOvercharge:HasEnhancement('MicrowaveLaserGenerator') or oUnitWithOvercharge:HasEnhancement('BlastAttack')) then
                oUnitWithOvercharge[M28ACU.refbOnlyOverchargeHighValueTargets] = true
            end
            if bDebugMessages == true then LOG(sFunctionRef..' FInished considering if want to set to only OC high value targets due to big gun, oUnitWithOvercharge[M28ACU.refbOnlyOverchargeHighValueTargets]='..tostring(oUnitWithOvercharge[M28ACU.refbOnlyOverchargeHighValueTargets] or false)..'; Upgrade count='..(oUnitWithOvercharge[M28ACU.refiUpgradeCount] or 'nil')..'; Unit has laser or splash='..tostring((oUnitWithOvercharge:HasEnhancement('MicrowaveLaserGenerator') or oUnitWithOvercharge:HasEnhancement('BlastAttack')))) end

            --First locate where any blocking units are - will assume non-wall structures larger than a T1 pgen will block the shot, and ACUs will block
            local iMaxSearchDistance
            if bOnlyConsiderEnemiesInRange then iMaxSearchDistance = iACURange - 1
            else iMaxSearchDistance = 50
            end
            toStructuresAndACU = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure - categories.SIZE4 + categories.COMMAND, tUnitPosition, iMaxSearchDistance, 'Enemy')

            if bDebugMessages == true then LOG(sFunctionRef..': First locating blocking units; is table empty='..tostring(M28Utilities.IsTableEmpty(toStructuresAndACU))..'; iACURange='..iACURange..'; iOverchargeArea='..iOverchargeArea) end
            if M28Utilities.IsTableEmpty(toStructuresAndACU) == false then
                for iUnit, oUnit in toStructuresAndACU do
                    if not(oUnit[reftiAngleFromACUToUnit]) then
                        oUnit[reftiAngleFromACUToUnit] = {}
                        oUnit[reftiDistFromACUToUnit] = {}
                    end
                    oUnit[reftiAngleFromACUToUnit][aiBrain:GetArmyIndex()] = M28Utilities.GetAngleFromAToB(tUnitPosition, oUnit:GetPosition())
                    oUnit[reftiDistFromACUToUnit][aiBrain:GetArmyIndex()] = M28Utilities.GetDistanceBetweenPositions(tUnitPosition, oUnit:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': Angle from oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to our ACU='..repru(oUnit[reftiAngleFromACUToUnit])..'; distance='..repru(oUnit[reftiDistFromACUToUnit])) end

                    --If enemy ACU is nearby and low health then target as top priority
                    if oUnit[reftiDistFromACUToUnit][aiBrain:GetArmyIndex()] < (iACURange - 2) and EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and oUnit:GetHealth() < 1400 then
                        oOverchargeTarget = oUnit
                    end
                end
            end


            if not(oOverchargeTarget) then
                --Cycle through every land combat non-ACU, and/or surface naval, unit within firing range to see if can find one that reduces the damage the most, or failing that does the most mass damage; will include all navy on the assumption isshotblocked will trigger if shot will go underwater (as otherwise we might ignore sera T2 destroyers)
                local tEnemyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand - categories.COMMAND + M28UnitInfo.refCategoryPD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryAllNavy, tUnitPosition, iACURange, 'Enemy')

                local iMostMassDamage = 0
                local oMostMassDamage, iKillsExpected
                local iMaxOverchargeDamage = (aiBrain:GetEconomyStored('ENERGY') * 0.9) * 0.25
                local iCurDamageDealt, iCurKillsExpected
                if bDebugMessages == true then LOG(sFunctionRef..': Will consider enemy mobile units and PD within 2 of the ACU max range; is the table empty='..tostring(M28Utilities.IsTableEmpty(tEnemyUnits))) end
                if M28Utilities.IsTableEmpty(tEnemyUnits) == false then
                    for iUnit, oUnit in tEnemyUnits do
                        --Reduce range to consider if unit is moving and isn't moving towards ACU
                        if not(oUnit:IsUnitState('Moving')) or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnitWithOvercharge:GetPosition()) < iACURange - 1 or M28Utilities.GetAngleDifference(M28UnitInfo.GetUnitFacingAngle(oUnit), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnitWithOvercharge:GetPosition())) <= 25 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if shot will hit for ACU '..(oUnitWithOvercharge.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitWithOvercharge) or 'nil')..' to hit oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' unit position='..repru(oUnit:GetPosition())..'; Is unit underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; Will shot hit='..tostring(WillShotHit(oUnitWithOvercharge, oUnit))) end
                            if WillShotHit(oUnitWithOvercharge, oUnit) then
                                iCurDamageDealt, iCurKillsExpected = M28Logic.GetDamageFromOvercharge(aiBrain, oUnit, iOverchargeArea, iMaxOverchargeDamage)
                                if bDebugMessages == true then LOG(sFunctionRef..': Shot will hit enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; damage result='..iCurDamageDealt) end
                                if iCurDamageDealt > iMostMassDamage then
                                    iMostMassDamage = iCurDamageDealt
                                    oMostMassDamage = oUnit
                                    iKillsExpected = iCurKillsExpected

                                end
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished searching through enemy mobile untis and PD in range, iMostMassDamage='..iMostMassDamage..'; iKillsExpected='..(iKillsExpected or 0)..'; Energy stored %='..aiBrain:GetEconomyStoredRatio('ENERGY')..'; E stored='..aiBrain:GetEconomyStored('ENERGY')) end

                --if iMostMobileCombatMassDamage >= 80 then
                --    oOverchargeTarget = oMostCombatMassDamage
                if (not(oUnitWithOvercharge[M28ACU.refbOnlyOverchargeHighValueTargets]) and iMostMassDamage >= 200 or iKillsExpected >= 3 or (iKillsExpected >= 1 and iMostMassDamage >= 100) or (iMostMassDamage >= 60 and aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.9 and (aiBrain:GetEconomyStored('ENERGY') >= 10000 or (aiBrain[M28Economy.refiNetEnergyBaseIncome] >= 1 and aiBrain:GetEconomyStored('ENERGY') >= 8000))))
                        or (oUnitWithOvercharge[M28ACU.refbOnlyOverchargeHighValueTargets] and (iMostMassDamage >= 500 or iKillsExpected >= 6 or (oOverchargeTarget and EntityCategoryContains(M28UnitInfo.refCategoryPD, oOverchargeTarget.UnitId)))) then --e.g. striker is 56 mass; lobo is 36
                    oOverchargeTarget = oMostMassDamage
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a mobile or PD unit in range that will do enough damage to, oOverchargeTarget='..oOverchargeTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOverchargeTarget)) end
                else
                    --Check we aren't running before considering whether to target walls or T2 PDs
                    if GetGameTimeSeconds() - (oUnitWithOvercharge[M28ACU.refiTimeLastWantedToRun] or -30) >= 30 then
                        --No decent combat targets; Check for lots of walls that might be blocking our path (dont reduce ACU range given these are structures)
                        --Only consider overcharging walls if no enemies within our combat range + 3
                        if not(oUnitWithOvercharge[M28ACU.refbOnlyOverchargeHighValueTargets]) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPlayerWallSegments]) == false and table.getn(tLZData[M28Map.subrefLZPlayerWallSegments]) >= 9 then
                            local tAllEnemies = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryNavalSurface, tUnitPosition, math.min(iMaxSearchDistance, iACURange + 3), 'Enemy')
                            if M28Utilities.IsTableEmpty(tAllEnemies) then
                                tEnemyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryWall, tUnitPosition, iACURange, 'Enemy')
                                if bDebugMessages == true then LOG(sFunctionRef..': iMostMassDamage='..iMostMassDamage..'; so will check for walls and other structure targets; is table of wall units empty='..tostring(M28Utilities.IsTableEmpty(tEnemyUnits))) end
                                if M28Utilities.IsTableEmpty(tEnemyUnits) == false and table.getn(tEnemyUnits) >= 5 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have at least 5 wall units in range, so potential blockage; size='..table.getn(tEnemyUnits)) end
                                    local bSuspectedPathBlock = false
                                    --If more than 10 then assume blocking our path

                                    if table.getn(tEnemyUnits) >= 10 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': At least 10 wall units so assuming a blockage') end
                                        bSuspectedPathBlock = true
                                    else
                                        local tFirstWall = tEnemyUnits[1]:GetPosition()
                                        for iWall, oWall in tEnemyUnits do
                                            if iWall > 1 then
                                                if M28Utilities.GetDistanceBetweenPositions(oWall:GetPosition(), tFirstWall) >= 4 then
                                                    bSuspectedPathBlock = true
                                                    break
                                                end
                                            end
                                        end
                                    end
                                    if bSuspectedPathBlock then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Think enemy has walls in a line so will overcharge them unless they are all closer to our base than us') end
                                        iMostMassDamage = 0
                                        oMostMassDamage = nil
                                        bSuspectedPathBlock = false

                                        local iOurDistToBase = M28Utilities.GetDistanceBetweenPositions(tUnitPosition, M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()])
                                        local iWallDistToBase
                                        for iWall, oUnit in tEnemyUnits do
                                            if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()]) <= iOurDistToBase + 4 then
                                                bSuspectedPathBlock = true
                                                break
                                            end
                                        end
                                        if bSuspectedPathBlock then
                                            for iWall, oUnit in tEnemyUnits do
                                                if WillShotHit(oUnitWithOvercharge, oUnit) then
                                                    iCurDamageDealt = M28Logic.GetDamageFromOvercharge(aiBrain, oUnit, iOverchargeArea, iMaxOverchargeDamage, true)
                                                    if iCurDamageDealt > iMostMassDamage then
                                                        iMostMassDamage = iCurDamageDealt
                                                        oMostMassDamage = oUnit
                                                    end
                                                end
                                            end
                                            if oMostMassDamage then oOverchargeTarget = oMostMassDamage end
                                        elseif bDebugMessages == true then LOG(sFunctionRef..': Walls are all closer to our base than we are so probably not blocking us')
                                        end
                                    elseif bDebugMessages == true then LOG(sFunctionRef..': Dont think the walls are in a line so wont try and OC')
                                    end
                                end
                            end
                        end
                        if not(oOverchargeTarget) and not(oUnitWithOvercharge[M28ACU.refbOnlyOverchargeHighValueTargets]) then
                            --Check further away incase enemy has T2 PD that can see us
                            if bDebugMessages == true then LOG(sFunctionRef..': Checking if any T2 PD further away') end
                            tEnemyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryT2PlusPD, tUnitPosition, iMaxSearchDistance, 'Enemy')
                            if M28Utilities.IsTableEmpty(tEnemyUnits) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have enemy T2 defence that can hit us but is out of our range - considering if OC it will bring us in range of T1 PD, and/or if shot is blocked, and/or if the T2PD cant even see us') end
                                local tNearbyT1PD
                                local iNearestT1PD = 10000
                                local iCurDistance
                                if 50 - iACURange > 0 then tNearbyT1PD = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryPD * categories.TECH1, tUnitPosition, 50 - iACURange, 'Enemy') end
                                if M28Utilities.IsTableEmpty(tNearbyT1PD) == false then
                                    for iT1PD, oT1PD in tNearbyT1PD do
                                        iCurDistance = M28Utilities.GetDistanceBetweenPositions(oT1PD:GetPosition(), tUnitPosition)
                                        if iCurDistance < iNearestT1PD then iNearestT1PD = iCurDistance end
                                    end
                                end

                                for iUnit, oEnemyT2PD in tEnemyUnits do
                                    --Can we get in range of the T2 PD without getting in range of the T1 PD? (approximates just based on distances rather than considering the likely path to take)
                                    if M28Utilities.GetDistanceBetweenPositions(oEnemyT2PD:GetPosition(), tUnitPosition) - iACURange + 2 < iNearestT1PD then
                                        if M28Logic.IsShotBlocked(oUnitWithOvercharge, oEnemyT2PD) == false then
                                            --Can the T2 PD see us?
                                            if M28UnitInfo.CanSeeUnit(oEnemyT2PD:GetAIBrain(), oUnitWithOvercharge) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Setting target to T2 PD') end
                                                oOverchargeTarget = oEnemyT2PD
                                                break
                                            else
                                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy T2 PDs owner can see our ACU') end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        if not(oOverchargeTarget) and not(oUnitWithOvercharge[M28ACU.refbOnlyOverchargeHighValueTargets]) then
                            --Consider all structures (can do ACU max range since before when structures were considered we were looking at reduced range)
                            tEnemyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure, tUnitPosition, iACURange, 'Enemy')
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering all enemy structures within range of ACU; is table empty='..tostring(M28Utilities.IsTableEmpty(tEnemyUnits))) end
                            --local iMostMobileCombatMassDamage = 0
                            --local oMostCombatMassDamage
                            if M28Utilities.IsTableEmpty(tEnemyUnits) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering other enemy structures in range; iMostMassDamage before looking='..iMostMassDamage) end
                                for iUnit, oUnit in tEnemyUnits do
                                    if WillShotHit(oUnitWithOvercharge, oUnit) then
                                        iCurDamageDealt, iCurKillsExpected = M28Logic.GetDamageFromOvercharge(aiBrain, oUnit, iOverchargeArea, iMaxOverchargeDamage)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Shot will hit enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; damage result='..iCurDamageDealt) end
                                        if iCurDamageDealt > iMostMassDamage then
                                            iMostMassDamage = iCurDamageDealt
                                            oMostMassDamage = oUnit
                                            iKillsExpected = iCurKillsExpected
                                        end
                                    end
                                end
                            end
                            if iMostMassDamage >= 110 then
                                oOverchargeTarget = oMostMassDamage
                            end
                        end
                    end
                end
            end
        end
        if oOverchargeTarget == nil then
            if bDebugMessages == true then LOG(sFunctionRef..': No OC targets found') end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Overcharge target='..oOverchargeTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOverchargeTarget)) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oOverchargeTarget
end

function TurnAirUnitAndMoveToTarget(oBomber, tDirectionToMoveTo, iMaxAcceptableAngleDif, iOptionalSecondsToMoveAtEndIfFarFromTarget)
    --Based on hoverbomb logic - may give unexpected results if not using with T3 bombers
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TurnAirUnitAndMoveToTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oBomber='..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; GameTime='..GetGameTimeSeconds()) end
    --First delay microing until finished our salvo if dealing with T1-T3 bomber
    if M28UnitInfo.DoesBomberFireSalvo(oBomber) and EntityCategoryContains(M28UnitInfo.refCategoryBomber - categories.EXPERIMENTAL, oBomber.UnitId) then
        if bDebugMessages == true then LOG(sFunctionRef..': Will wait a second so bomber can finish firing') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1.1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting for bomber '..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; is bomber valid='..tostring(M28UnitInfo.IsUnitValid(oBomber))) end
    end
    if M28UnitInfo.IsUnitValid(oBomber) then
        local bContinue = true
        if M28Utilities.IsTableEmpty(tDirectionToMoveTo) then
            if M28Map.bIsCampaignMap and ((ScenarioInfo.OpEnded and GetGameTimeSeconds() <= 120) or (oBomber:GetAIBrain().HostileCampaignAI and tonumber(ScenarioInfo.Options.CmpAIDelay) > GetGameTimeSeconds())) then
                bContinue = false
            else
                --Set direction to move to to the start position
                tDirectionToMoveTo = M28Map.PlayerStartPoints[oBomber:GetAIBrain():GetArmyIndex()]
            end
        end
        if bContinue then
            local iStartTime = GetGameTimeSeconds()
            --local iAngleToTarget

            --Config:
            local iTicksBetweenOrders = 5
            local iDistanceAwayToMove = 10
            local iAngleAdjust = 50


            --Other variables:
            local iActualAngleToUse
            local iCurAngleDif
            local iAngleAdjustToUse
            local iFacingDirection
            local iAngleToTarget

            local iCurTick = 0
            local bTriedMovingForwardsAndTurning = false
            local iDistToTarget
            local tTempTarget

            local iMaxMicroTime = 5 --will micro for up to 5 seconds
            if EntityCategoryContains(categories.EXPERIMENTAL, oBomber.UnitId) then iMaxMicroTime = 10 end



            --Clear trackers so we dont think we're targeting anything - commented out as this is called via the clearairunitassignmenttracker so causes issues
            --M27AirOverseer.ClearAirUnitAssignmentTrackers(aiBrain, oBomber, true)
            TrackTemporaryUnitMicro(oBomber, 60) --60s is redundancy



            while GetGameTimeSeconds() - iStartTime < iMaxMicroTime do
                iCurTick = iCurTick + 1

                iFacingDirection = M28UnitInfo.GetUnitFacingAngle(oBomber)
                iAngleToTarget = M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), tDirectionToMoveTo)
                iCurAngleDif = iFacingDirection - iAngleToTarget
                iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oBomber:GetPosition(), tDirectionToMoveTo)
                --e.g. if bomber is facing 350 degrees, and the target is at 10 degrees, then it means there's only a dif of 20 degrees, but we want the bomber to go 350+50, rather than 350-50.  Facing - Angle would result in a positive value
                --if instead bomber was facing 10 degrees, and the target was 30 degrees, then would get -20 as the result, and so want to also increase
                --the effect of the below is that when bomber is facing 350 degrees and target 10 degrees, it will treat the difference as being 350 - 10 - 360 = -20, and want the bomber to go 350+50; if insteadbomber 10 and target 30, then dif = -20 and no adjustment made
                if math.abs(iCurAngleDif) > 180 then
                    if iCurAngleDif > 180 then
                        --iFacingDirection is too high so decrease the angle difference
                        iCurAngleDif = iCurAngleDif - 360
                    else --Curangledif must be < -180, so angletotarget is too high
                        iCurAngleDif = iCurAngleDif + 360
                    end
                end


                if iCurAngleDif < 0 then
                    iAngleAdjustToUse = iAngleAdjust
                else iAngleAdjustToUse = -iAngleAdjust
                end

                --Are we close enough to the direction wanted?
                iCurAngleDif = math.abs(iCurAngleDif)
                if iCurAngleDif <= (iMaxAcceptableAngleDif or 15) then
                    --Are close enough in angle so can stop the micro
                    break
                else
                    if iCurTick == 1 then
                        iActualAngleToUse = iFacingDirection + iAngleAdjustToUse
                        tTempTarget = M28Utilities.MoveInDirection(oBomber:GetPosition(), iActualAngleToUse, iDistanceAwayToMove, true, false, true)
                        M28Orders.IssueTrackedMove(oBomber, tTempTarget, 0, false, 'BMicrM', true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Just issued move order, iFacingDirection='..iFacingDirection..'; iCurAngleDif='..iCurAngleDif..'; iAngleAdjustToUse='..iAngleAdjustToUse..'; iActualAngleToUse='..iActualAngleToUse..'; angle from bomber to target='..M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), tDirectionToMoveTo)) end
                    elseif iCurTick >= iTicksBetweenOrders then iCurTick = 0
                    end

                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(1)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    if not(M28UnitInfo.IsUnitValid(oBomber)) then
                        break
                    end
                end
            end

            if M28UnitInfo.IsUnitValid(oBomber) then
                M28Orders.IssueTrackedMove(oBomber, tDirectionToMoveTo, 5, false, 'BMicMTR', true)
                if bDebugMessages == true then LOG(sFunctionRef..': Just cleared bomber '..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..' commands and told it to move to '..repru(tDirectionToMoveTo)..'; Dist to target='..M28Utilities.GetDistanceBetweenPositions(tDirectionToMoveTo, oBomber:GetPosition())..'; GameTime='..GetGameTimeSeconds()..'; iOptionalSecondsToMoveAtEndIfFarFromTarget='..(iOptionalSecondsToMoveAtEndIfFarFromTarget or 'nil')) end
                if iOptionalSecondsToMoveAtEndIfFarFromTarget then
                    local iTimeToWait = math.min(iOptionalSecondsToMoveAtEndIfFarFromTarget, M28Utilities.GetDistanceBetweenPositions(oBomber:GetPosition(), tDirectionToMoveTo) / (oBomber:GetBlueprint().Physics.MaxSpeed or 10))
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitSeconds(iTimeToWait)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                end

                oBomber[M28UnitInfo.refbSpecialMicroActive] = false
                oBomber[M28UnitInfo.refiGameTimeToResetMicroActive] = GetGameTimeSeconds()
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TurnAirUnitAndAttackTarget(oBomber, oTarget, bDontAdjustMicroFlag, bContinueAttackingUntilTargetDead)
    --Currently just used for ahwassa and T1 bomber
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TurnAirUnitAndAttackTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oBomber='..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; bDontAdjustMicroFlag='..tostring(bDontAdjustMicroFlag or false)..'; GameTime='..GetGameTimeSeconds()) end
    if M28UnitInfo.IsUnitValid(oBomber) and M28UnitInfo.IsUnitValid(oTarget) then
        local iStartTime = GetGameTimeSeconds()
        --local iAngleToTarget

        --Config:
        local iTicksBetweenOrders = 5
        local iDistanceAwayToMove = 10
        local iAngleAdjust = 50
        local iMaxAcceptableAngleDif = 30
        local iAOE, iDamage = M28UnitInfo.GetBomberAOEAndStrikeDamage(oBomber)
        local iBombStraightLineDistance = 8.5 --i.e. will consider firing a bomb in bombers current facing direction by this distance, and seeing if the aoe will hit the target
        local iPotentialAbortDistance = iBombStraightLineDistance + iAOE - 1
        local tGroundTarget
        --local iReloadTime = oBomber[M28UnitInfo.refiTimeBetweenBombs] + iDelayForHoverBomb
        --local iTimeUntilCanFire = GetGameTimeSeconds() + math.max(0, iReloadTime - GetGameTimeSeconds() - (oBomber[M28UnitInfo.refiLastBombFired] or 0))

        --Other variables:
        local bConsiderIfTooFast = true
        local iTooCloseIfFastDist, iFastSpeedThreshold, iCurSpeed
        local iActualAngleToUse
        local iCurAngleDif
        local iAngleAdjustToUse
        local iFacingDirection
        local iAngleToTarget

        local iCurTick = 0
        local iDistToTarget
        local tTempTarget

        local iMaxMicroTime = 5 --will micro for up to 5 seconds
        if EntityCategoryContains(categories.EXPERIMENTAL, oBomber.UnitId) then
            iMaxMicroTime = 10
            bConsiderIfTooFast = false
        elseif bContinueAttackingUntilTargetDead then iMaxMicroTime = 1000
        end
        if bConsiderIfTooFast then
            iTooCloseIfFastDist = (oBomber[M28UnitInfo.refiBomberRange] or 40) * 0.75
            iFastSpeedThreshold = oBomber:GetBlueprint().Air.MaxAirspeed * 0.85 --the function to get a units speed typically gives higher than actual speed since it is measuring 2 axis
        end

        if not(bDontAdjustMicroFlag) then
            EnableUnitMicroUntilManuallyTurnOff(oBomber)
        end

        while GetGameTimeSeconds() - iStartTime < iMaxMicroTime do
            iCurTick = iCurTick + 1

            iFacingDirection = M28UnitInfo.GetUnitFacingAngle(oBomber)
            iAngleToTarget = M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), oTarget:GetPosition())
            iCurAngleDif = iFacingDirection - iAngleToTarget
            iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oBomber:GetPosition(), oTarget:GetPosition())
            --e.g. if bomber is facing 350 degrees, and the target is at 10 degrees, then it means there's only a dif of 20 degrees, but we want the bomber to go 350+50, rather than 350-50.  Facing - Angle would result in a positive value
            --if instead bomber was facing 10 degrees, and the target was 30 degrees, then would get -20 as the result, and so want to also increase
            --the effect of the below is that when bomber is facing 350 degrees and target 10 degrees, it will treat the difference as being 350 - 10 - 360 = -20, and want the bomber to go 350+50; if insteadbomber 10 and target 30, then dif = -20 and no adjustment made
            if math.abs(iCurAngleDif) > 180 then
                if iCurAngleDif > 180 then
                    --iFacingDirection is too high so decrease the angle difference
                    iCurAngleDif = iCurAngleDif - 360
                else --Curangledif must be < -180, so angletotarget is too high
                    iCurAngleDif = iCurAngleDif + 360
                end
            end

            if iCurAngleDif < 0 then
                iAngleAdjustToUse = iAngleAdjust
            else iAngleAdjustToUse = -iAngleAdjust
            end

            --Are we close enough to the direction wanted?
            iCurAngleDif = math.abs(iCurAngleDif)
            if iCurAngleDif <= (iMaxAcceptableAngleDif or 15) or iDistToTarget <= iPotentialAbortDistance then
                --Are close enough in angle so can stop the micro
                if iDistToTarget <= iPotentialAbortDistance then
                    local tPotentialTarget = M28Utilities.MoveInDirection(oBomber:GetPosition(), iFacingDirection, iBombStraightLineDistance, true, false, true)
                    if tPotentialTarget and M28Utilities.GetDistanceBetweenPositions(tPotentialTarget, oTarget:GetPosition()) <= iAOE - 1 then
                        tGroundTarget = {tPotentialTarget[1], tPotentialTarget[2], tPotentialTarget[3]}
                    elseif iCurAngleDif <= (iMaxAcceptableAngleDif or 15) * 0.6 then
                        --We are fairly close and aiming in the right direction so just attack rather than trying aoe attack to reduce the risk we just stay hovering in the air never attacking
                        tGroundTarget = oTarget:GetPosition()
                    end
                else
                    tGroundTarget = oTarget:GetPosition()
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iCurAngleDif='..iCurAngleDif..'; iMaxAcceptableAngleDif='..iMaxAcceptableAngleDif..'; iDistToTarget='..iDistToTarget..'; iTooCloseIfFastDist='..(iTooCloseIfFastDist or 'nil')..'; iPotentialAbortDistance='..iPotentialAbortDistance..'; Is tGroundTarget empty='..tostring(M28Utilities.IsTableEmpty(tGroundTarget))..'; Time='..GetGameTimeSeconds()) end
            if tGroundTarget and M28UnitInfo.GetTimeUntilReadyToFireBomb(oBomber) > 0 then
                --If we cant fire yet then clear the ground target and keep microing
                tGroundTarget = nil
            elseif bConsiderIfTooFast and iDistToTarget < iTooCloseIfFastDist then
                iCurSpeed = M28UnitInfo.GetUnitSpeed(oBomber)
                if bDebugMessages == true then LOG(sFunctionRef..': iCurSpeed='..iCurSpeed..'; iFastSpeedThreshold='..iFastSpeedThreshold) end
                if iCurSpeed > iFastSpeedThreshold then

                    tGroundTarget = nil
                end

            end
            if tGroundTarget then
                break
            else
                if iCurTick == 1 then
                    iActualAngleToUse = iFacingDirection + iAngleAdjustToUse
                    tTempTarget = M28Utilities.MoveInDirection(oBomber:GetPosition(), iActualAngleToUse, iDistanceAwayToMove, true, false, true)
                    M28Orders.IssueTrackedMove(oBomber, tTempTarget, 0, false, 'BMicrM', true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Just issued move order, iFacingDirection='..iFacingDirection..'; iCurAngleDif='..iCurAngleDif..'; iAngleAdjustToUse='..iAngleAdjustToUse..'; iActualAngleToUse='..iActualAngleToUse..'; angle from bomber to target='..M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), tTempTarget)) end
                elseif iCurTick >= iTicksBetweenOrders then iCurTick = 0
                end

                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if not(M28UnitInfo.IsUnitValid(oBomber)) or not(M28UnitInfo.IsUnitValid(oTarget)) then
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': end of loop for turning to face the target, is tGroundTarget empty='..tostring(M28Utilities.IsTableEmpty(tGroundTarget))..'; Is bomber valid='..tostring(M28UnitInfo.IsUnitValid(oBomber))..'; Is target valid='..tostring(M28UnitInfo.IsUnitValid(oTarget))) end
        if tGroundTarget and M28UnitInfo.IsUnitValid(oBomber) and M28UnitInfo.IsUnitValid(oTarget) then
            --Fire the bomb
            if not(bDontAdjustMicroFlag) then
                oBomber[M28UnitInfo.refbSpecialMicroActive] = false
                oBomber[M28UnitInfo.refiGameTimeToResetMicroActive] = GetGameTimeSeconds()
            end
            --T1 bombers - dont ground-fire engineers that are moving or else we wont hit them
            if iAOE <= 4 and oTarget:IsUnitState('Moving') and M28UnitInfo.GetUnitSpeed(oTarget) >= 0.5 then
                M28Orders.IssueTrackedAttack(oBomber, oTarget, false, 'BMicMA', true)
                if bDebugMessages == true then LOG(sFunctionRef..': Will do manual attack order') end
            else
                M28Orders.IssueTrackedGroundAttack(oBomber, tGroundTarget, 1, false, 'BMicGA', true, oTarget)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Just cleared bomber '..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..' commands and told it to attack tGroundTarget='..repru(tGroundTarget)..'which is expected to hit oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; bContinueAttackingUntilTargetDead='..tostring(bContinueAttackingUntilTargetDead or false)..'; GameTime='..GetGameTimeSeconds()) end
            if bContinueAttackingUntilTargetDead then
                local iDelayForHoverBomb = 0
                if M28UnitInfo.DoesBomberFireSalvo(oBomber) then iDelayForHoverBomb = 2 end
                if bDebugMessages == true then LOG(sFunctionRef..': Will wait '..iDelayForHoverBomb..' seconds (or 1, if higher)') end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitSeconds(math.max(1, iDelayForHoverBomb))
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                --If we have fired recently then wait some more
                if iDelayForHoverBomb > 0 and oBomber[M28UnitInfo.refiLastBombFired] and GetGameTimeSeconds() - oBomber[M28UnitInfo.refiLastBombFired] < iDelayForHoverBomb then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitSeconds(iDelayForHoverBomb - (GetGameTimeSeconds() - oBomber[M28UnitInfo.refiLastBombFired]))
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': want to keep attacking target so will call this function again') end
                TurnAirUnitAndAttackTarget(oBomber, oTarget, bDontAdjustMicroFlag, bContinueAttackingUntilTargetDead)
            elseif not(bDontAdjustMicroFlag) then oBomber[M28UnitInfo.refbSpecialMicroActive] = false
            end
        elseif not(bDontAdjustMicroFlag) then oBomber[M28UnitInfo.refbSpecialMicroActive] = false
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MoveAwayFromFactory(oUnit, oFactory)
    if EntityCategoryContains(categories.STRUCTURE, oFactory.UnitId) then --and not(EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId)) then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'MoveAwayFromFactory'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


        local aiBrain = oFactory:GetAIBrain()
        if aiBrain.M28AI then --redundancy
            local iTeam = aiBrain.M28Team
            local tLZOrWZData, tLZOrWZTeamData
            local iPlateauOrZero, iLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oFactory:GetPosition())
            if iLZOrWZ > 0 then
                if iPlateauOrZero == 0 then
                    tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLZOrWZ]][M28Map.subrefPondWaterZones][iLZOrWZ]
                    tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                else
                    tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLZOrWZ]
                    tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                end
                if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) == false then
                    local iFactorySize = M28UnitInfo.GetBuildingSize(oFactory.UnitId)
                    local tOrderPosition = M28Utilities.MoveInDirection(oFactory:GetPosition(), M28Utilities.GetAngleFromAToB(oFactory:GetPosition(), tLZOrWZTeamData[M28Map.reftClosestEnemyBase]), iFactorySize + 2, true, false, true)
                    --If dealing with land fac then rotate engineer
                    local bLandFacRotatedEngineer = false
                    if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oFactory.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                        local iAngleToDestination = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tOrderPosition)
                        if oUnit.SetRotation then oUnit:SetRotation(iAngleToDestination) end

                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Will try and rotate engineer '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..' since FAF code does this, unit facing direction='..M28UnitInfo.GetUnitFacingAngle(oUnit)..'; Angle to factory rally='..iAngleToDestination..'; will draw tOrderPosition, is set rotation nil='..tostring(oUnit.SetRotation == nil))
                            M28Utilities.DrawLocation(tOrderPosition)
                        end
                    end
                    M28Orders.IssueTrackedMove(oUnit, tOrderPosition, 0, false, 'JustBuilt', true)
                    local iMicroDelay = 1.5
                    if EntityCategoryContains(M28UnitInfo.refCategoryQuantumGateway, oFactory.UnitId) then iMicroDelay = 4 --done as when was 1.5 would have RAS SACUs given new orders like GE template just after being built and getting stuck
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oFactory.UnitId) and EntityCategoryContains(M28UnitInfo.categories.TECH3 * M28UnitInfo.refCategoryNavalSurface, oUnit.UnitId) then iMicroDelay = 4
                    end
                    TrackTemporaryUnitMicro(oUnit, 1.5)
                end

            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished for oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' built from factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..' at time='..GetGameTimeSeconds()) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function DelayedUnitMove(oUnit, tMoveDirection, iMoveThreshold, bAddToExistingQueue, sOptionalOrderDesc, bOverrideMicroOrder, iSecondsToWait)

    WaitSeconds(iSecondsToWait)
    if M28UnitInfo.IsUnitValid(oUnit) then
        M28Orders.IssueTrackedMove(oUnit, tMoveDirection, iMoveThreshold, bAddToExistingQueue, sOptionalOrderDesc, bOverrideMicroOrder)
    end
end

function MegalithRetreatMicro(oUnit, tRallyPoint, tClosestFriendlyBase)
    --Tries to retreat the unit, returns false if couldnt find suitable retreat location
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MegalithRetreatMicro'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bGivenOrder = false

    if not(oUnit[M28UnitInfo.refbEasyBrain]) then

        --Only consider applying micro if moving in opposite direction to that which we are facing should result in us moving in similar direction to rally point or closest base
        local iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)
        local iAngleToClosestBase = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tClosestFriendlyBase)
        local iFacingDirection = M28UnitInfo.GetUnitFacingAngle(oUnit)
        local iAngleIfMoving = iFacingDirection + 180
        if iAngleIfMoving > 360 then iAngleIfMoving = iAngleIfMoving - 360 end
        local tMoveDirection



        if M28Utilities.GetAngleDifference(iAngleToRally, iAngleIfMoving) <= 60 or M28Utilities.GetAngleDifference(iAngleToClosestBase, iAngleIfMoving) <= 60 then
            local iDistanceToMove = 8 --worked ok with value of 5
            tMoveDirection = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleIfMoving, iDistanceToMove, true, false, true)
            if M28Utilities.IsTableEmpty(tMoveDirection) == false then
                --Looks like megalith has to be stationery or reversing for this to work?
                local tCurOrder = oUnit[M28Orders.reftiLastOrders][1]
                local bClearAndWait = false
                if tCurOrder then
                    if tCurOrder[M28Orders.refiOrderIssueMove] == M28Orders.refiOrderIssueMove and M28Utilities.IsTableEmpty(tCurOrder[M28Orders.subreftOrderPosition]) == false then
                        if M28Utilities.GetDistanceBetweenPositions(tMoveDirection, tCurOrder[M28Orders.subreftOrderPosition]) >= iDistanceToMove then
                            bClearAndWait = true
                        end
                    else
                        bClearAndWait = true
                    end

                end
                if bClearAndWait then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will clear orders then do delayed move') end
                    M28Orders.IssueTrackedClearCommands(oUnit)
                    ForkThread(DelayedUnitMove, oUnit, tMoveDirection, iDistanceToMove * 0.45, false, 'MegDelM', false, 0.75) --tried with 0.25s delay and led to megalith turning around; 0.75 worked in the replay where megalith moved in a circle before; if find it doesnt work in other caess though the nincrease to 1s and add unit micro tracking
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Are already trying to kite so will just check if move order needs updating') end
                    M28Orders.IssueTrackedMove(oUnit, tMoveDirection, iDistanceToMove * 0.45, false, 'MegMiRM', false)
                end
                bGivenOrder = true
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bGivenOrder='..tostring(bGivenOrder or false)..'; tMoveDirection='..repru(tMoveDirection)..'; iFacingDirection='..iFacingDirection..'; iAngleToRally='..iAngleToRally..'; iAngleToClosestBase='..iAngleToClosestBase..'; iAngleIfMoving='..iAngleIfMoving..'; Time='..GetGameTimeSeconds()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bGivenOrder
end

function MoveAndKillAirUnit(oUnit)
    --Move to a random nearby positionand then ctrl-k; reason is to reduce likelihood we are detsroying existing wrecks
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MoveAndKillAirUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28UnitInfo.IsUnitValid(oUnit) then --redundancy
        if bDebugMessages == true then LOG(sFunctionRef..': About to give more and kill order to unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; time='..GetGameTimeSeconds()) end
        if oUnit[M28UnitInfo.refbEasyBrain] then
            M28Orders.IssueTrackedKillUnit(oUnit)
        else
            local iPotentialXAdjust, iPotentialZAdjust
            local iSearchRadius = 30
            local bHaveLowHealthUnitOrReclaim
            local iMaxSearchAttempt = 10
            for iSearchAttempt = 1, iMaxSearchAttempt do
                bHaveLowHealthUnitOrReclaim = false
                iPotentialXAdjust = math.random(1,iSearchRadius*2) - iSearchRadius
                iPotentialZAdjust = math.random(1,iSearchRadius*2) - iSearchRadius
                local tPotentialPosition = oUnit:GetPosition()
                tPotentialPosition[1] = tPotentialPosition[1] + iPotentialXAdjust
                tPotentialPosition[3] = tPotentialPosition[3] + iPotentialXAdjust
                --Check no low health units (e.g. radar, shields) at the target position unless cant find any
                if iSearchAttempt < iMaxSearchAttempt then
                    local rRectangleToSearch = M28Utilities.GetRectAroundLocation(tPotentialPosition, 1)
                    local tUnitsNearPosition = GetUnitsInRect(rRectangleToSearch)
                    if M28Utilities.IsTableEmpty(tUnitsNearPosition) == false then
                        local tBuildings = EntityCategoryFilterDown(categories.STRUCTURE + categories.EXPERIMENTAL,  tUnitsNearPosition)
                        if M28Utilities.IsTableEmpty(tBuildings) == false then
                            for iNearbyUnit, oNearbyUnit in tBuildings do
                                if oNearbyUnit:GetHealth() <= 110 then
                                    bHaveLowHealthUnitOrReclaim = true
                                    break
                                end
                            end
                        end
                    end
                    if not(bHaveLowHealthUnitOrReclaim) then
                        local iReclaimNearby = M28Map.GetReclaimInRectangle(3, rRectangleToSearch)
                        if iReclaimNearby >= 10 then
                            bHaveLowHealthUnitOrReclaim = true
                        end
                        --iReturnType: 1 = true/false; 2 = number of wrecks; 3 = total mass, 4 = valid wrecks, 5 = energy
                    end
                end
                if not(bHaveLowHealthUnitOrReclaim) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have got location to move to for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; .Dead='..tostring(oUnit.Dead or false)..'; been destroyed='..tostring(oUnit:BeenDestroyed())..'; tPotentialPosition='..repru(tPotentialPosition)) end
                    M28Orders.IssueTrackedMove(oUnit, tPotentialPosition, 0, false, 'MveToDie', true)
                    TrackTemporaryUnitMicro(oUnit, 3)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitSeconds(3)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        M28Orders.IssueTrackedKillUnit(oUnit)
                    end
                    break
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MonitorNukeTargetForNukeWeHaveIntelOf(oProjectile, oLauncher, iTeam, bEnemyNuke)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MonitorNukeTargetForNukeWeHaveIntelOf'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(oProjectile:BeenDestroyed()) and oProjectile.GetCurrentTargetPosition then
        --LOG('Blueprint for projectile repru='..repru(oProjectile.Blueprint))
        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        if aiBrain then
            if bDebugMessages == true then LOG(sFunctionRef..': Outer ring='..repru(oProjectile.OuterRing)..'; Inner ring='..repru(oProjectile.InnerRing)..'; oLauncher='..(oLauncher.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oLauncher) or 'nil')) end
            --Record in friendly nuke table
            local tTarget = oProjectile:GetCurrentTargetPosition()
            ForkThread(M28Building.RecordNukeTarget, iTeam, tTarget)
            local iSearchArea = math.min((oProjectile.OuterRing.Radius or 50), math.max(56, (oProjectile.InnerRing.Radius or 35) + 15)) + 4
            local iCategoriesToSearch = M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryMobileLand * categories.TECH3 + M28UnitInfo.refCategoryAllNavy * categories.MOBILE - categories.TECH1 + categories.COMMAND + categories.SUBCOMMANDER
            local iSpeed = (oProjectile.Blueprint.Physics.MaxSpeed or 10)
            local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(tTarget, oProjectile:GetPosition())
            local iTimeToTarget = iDistToTarget / iSpeed
            if bDebugMessages == true then LOG(sFunctionRef..': iSpeed='..iSpeed..'; iDistToTarget='..iDistToTarget..'; iTimeToTarget='..iTimeToTarget..'; iSearchArea='..iSearchArea..'; Excess time='..(iTimeToTarget - iSearchArea / 2)*10) end
            if iTimeToTarget >= iSearchArea / 2 then --want to allow enough time for a unit in the middle of the target to get out of the way
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(math.floor((iTimeToTarget - iSearchArea / 2)*10))
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
            local iAngleToUnit
            local iMoveDistance = iSearchArea + 15
            local bKeepInCampaignArea = M28Map.bIsCampaignMap
            while not(oProjectile:BeenDestroyed()) and not(aiBrain.M28IsDefeated)  do
                --Every second check for friendly experimental, ACU, and T3 land units around the target area and have them move away
                --First check the missile is close enough that we should try and have units run
                local tFriendlyUnitsNearTarget = aiBrain:GetUnitsAroundPoint(iCategoriesToSearch, tTarget, iSearchArea, 'Ally')
                if M28Utilities.IsTableEmpty(tFriendlyUnitsNearTarget) == false then
                    for iUnit, oUnit in tFriendlyUnitsNearTarget do
                        if oUnit:GetAIBrain().M28AI and (not(oUnit:GetAIBrain().M28Easy) or (not(bEnemyNuke) and EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER + M28UnitInfo.refCategoryExperimentalLevel, oUnit.UnitId))) then
                            iAngleToUnit = M28Utilities.GetAngleFromAToB(tTarget, oUnit:GetPosition())
                            local tMoveAwayPoint = M28Utilities.MoveInDirection(tTarget, iAngleToUnit, iMoveDistance, true, false, bKeepInCampaignArea)
                            M28Orders.IssueTrackedMove(oUnit, tMoveAwayPoint, 5, false, 'NukeDodge', true)
                            TrackTemporaryUnitMicro(oUnit, 1)
                        end
                    end
                end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitSeconds(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MonitorEnemyNukeForIntel(oProjectile, iTeam)
    --Intended for hostile nuke - want to try and take evasive action once we see hten uke being launched
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MonitorEnemyNukeForIntel'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of loop for iTeam='..iTeam..'; oProjectile.Launcher='..(oProjectile.Launcher.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oProjectile.Launcher) or 'nil')..'; Time='..GetGameTimeSeconds()) end
    if not(oProjectile:BeenDestroyed()) and oProjectile.GetCurrentTargetPosition then
        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        if aiBrain then
            local iCurDist
            local iTickDelayBetweenChecks = 1
            if M28Land.iTicksPerLandCycle > 11 then iTickDelayBetweenChecks = math.floor(M28Land.iTickDelayBetweenChecks / 10) end
            local bHaveIntel = false
            while not(oProjectile:BeenDestroyed()) do
                --Check if we have intel of this position (i.e. visual)
                local tCurLZData, tCurLZTeamData = M28Map.GetLandOrWaterZoneData(oProjectile:GetPosition(), true, iTeam)
                if bDebugMessages == true then
                    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oProjectile:GetPosition())
                    LOG(sFunctionRef..': Considering if we have units in the zone where the missile is, iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; is table of units empty='..tostring(M28Utilities.IsTableEmpty(tCurLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))..'; Time='..GetGameTimeSeconds())
                end
                if M28Utilities.IsTableEmpty(tCurLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                    local tCurMissilePosition = oProjectile:GetPosition()
                    for iUnit, oUnit in tCurLZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(tCurMissilePosition, oUnit:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..iCurDist..'; Dist less vision='..iCurDist - (oUnit:GetBlueprint().Intel.VisionRadius or 0)) end
                            if iCurDist <= 100 and iCurDist - (oUnit:GetBlueprint().Intel.VisionRadius or 0) < 0 then
                                if bDebugMessages == true then LOG(sFunctionRef..': We have intel so aborting') end
                                bHaveIntel = true
                                break
                            end
                        end
                    end
                    if bHaveIntel then break end
                end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(iTickDelayBetweenChecks)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Exited the projectile monitor loop, bHaveIntel='..tostring(bHaveIntel)..'; Time='..GetGameTimeSeconds()) end
            if bHaveIntel then
                MonitorNukeTargetForNukeWeHaveIntelOf(oProjectile, oProjectile.Launcher, iTeam)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderAirAAHoverAttackTowardsTarget(oUnit, oWeapon)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderAirAAHoverAttackTowardsTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local oTarget = oWeapon:GetCurrentTarget()
    if bDebugMessages == true then
        LOG(sFunctionRef..': Start of code, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is oTarget valid='..tostring(M28UnitInfo.IsUnitValid(oTarget))..'; oTarget='..(oTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTarget) or 'nil'))
        if M28UnitInfo.IsUnitValid(oTarget) then
            LOG(sFunctionRef..': Unit state of target='..M28UnitInfo.GetUnitState(oTarget)..'; Time since oUnit last fired='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0))
        end
    end
    if M28UnitInfo.IsUnitValid(oTarget) and oTarget:GetFractionComplete() == 1 then
        --LOUD - check unit isn't on ground
        local bProceedWithMicro = true
        if (M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) and not(oTarget:IsUnitState('Moving')) and not(oTarget:IsUnitState('Attacking')) then
            local tTargetPosition = oTarget:GetPosition()
            if tTargetPosition[2] - GetSurfaceHeight(tTargetPosition[1], tTargetPosition[3]) < 1 then
                bProceedWithMicro = false
            end
        end
        if bProceedWithMicro then
            local iOurSpeed = oUnit:GetBlueprint().Air.MaxAirspeed
            local iEnemySpeed = oTarget:GetBlueprint().Air.MaxAirspeed
            --Want to consider hover-turning against enemy asfs if we have same speed as them and we arent chasing them (suggesting they might be turning or they might be facing us)
            --(wont use hover-logic on enemy asfs once we have reached 100+ asfs to avoid massive slowdown)
            if bDebugMessages == true then LOG(sFunctionRef..': iOurSpeed='..(iOurSpeed or 'nil')..'; iEnemySpeed='..(iEnemySpeed or 'nil')) end
            if iOurSpeed and iEnemySpeed and iOurSpeed >= iEnemySpeed and (iOurSpeed >= iEnemySpeed * 1.2 or (M28UnitInfo.GetUnitLifetimeCount(oUnit) <= 100 and M28Utilities.GetAngleDifference(M28UnitInfo.GetUnitFacingAngle(oUnit), M28UnitInfo.GetUnitFacingAngle(oTarget)) <= 130)) then
                local iOurRange = (oUnit[M28UnitInfo.refiAARange] or 0)
                if bDebugMessages == true then LOG(sFunctionRef..': iOurRange='..iOurRange..'; oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Is it an air unit='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAllAir, oTarget.UnitId))) end
                if iOurRange > 0 and EntityCategoryContains(M28UnitInfo.refCategoryAllAir, oTarget.UnitId) then
                    --Want to try and do hover-micro
                    EnableUnitMicroUntilManuallyTurnOff(oUnit)
                    --oUnit[M28UnitInfo.refbSpecialMicroActive] = true
                    local iCurDistToTarget
                    local iCurAngleToTarget
                    local iCurFacingAngle
                    local iMinDistToTarget = math.min(iOurRange * 0.8, math.max(iOurRange * 0.5, iOurRange - 5))
                    local iHalfDistThreshold = iOurRange * 0.5
                    local iCurAngleDif
                    local bTurnClockwise
                    local bAbortIfTooFar = false
                    if iEnemySpeed >= iOurSpeed * 0.95 then bAbortIfTooFar = true end
                    local iReorderDist
                    local iDistToMoveTowardsTarget, iAngleToMove
                    local iMaxTimeBetweenShotsWanted = oUnit[M28UnitInfo.refiTimeBetweenAirAAShots]
                    if not(iMaxTimeBetweenShotsWanted) then iMaxTimeBetweenShotsWanted = 5
                    else iMaxTimeBetweenShotsWanted = iMaxTimeBetweenShotsWanted + math.max(0.5, iMaxTimeBetweenShotsWanted * 0.15)
                    end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(1)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    local bManualAttack
                    while M28UnitInfo.IsUnitValid(oTarget) and M28UnitInfo.IsUnitValid(oUnit) do
                        local tMoveViaPoint
                        --First decide if we want to move towards target
                        iCurDistToTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTarget:GetPosition())
                        if iCurDistToTarget > iMinDistToTarget then
                            tMoveViaPoint = oTarget:GetPosition()
                            iReorderDist = 0.5
                            if bDebugMessages == true then LOG(sFunctionRef..': Too far from target so want to move to target, iCurDistToTarget='..iCurDistToTarget..'; Target unit state='..M28UnitInfo.GetUnitState(oTarget)) end
                        else
                            --Move towards target
                            --Check target is in the air not on the ground (if on the ground then want to issue manual attack order)
                            bManualAttack = false
                            if not(oTarget:IsUnitState('Moving') or oTarget:IsUnitState('Attacking')) then
                                local tCurTargetPosition = oTarget:GetPosition()
                                if bDebugMessages == true then LOG(sFunctionRef..': Consideringi f want manual attack, target vertical dist from surface='..tCurTargetPosition[2] - GetSurfaceHeight(tCurTargetPosition[1], tCurTargetPosition[3])) end
                                if tCurTargetPosition[2] - GetSurfaceHeight(tCurTargetPosition[1], tCurTargetPosition[3]) <= 1 then
                                    bManualAttack = true
                                end
                            end
                            if bManualAttack then
                                if bDebugMessages == true then LOG(sFunctionRef..': Target appears to be on ground so will do manual attack') end
                                tMoveViaPoint = nil
                            else
                                iCurAngleToTarget = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oTarget:GetPosition())
                                iCurFacingAngle = M28UnitInfo.GetUnitFacingAngle(oUnit)
                                iCurAngleDif = M28Utilities.GetAngleDifference(iCurAngleToTarget, iCurFacingAngle)
                                if bDebugMessages == true then LOG(sFunctionRef..': iCurDistToTarget='..iCurDistToTarget..'; iCurAngleToTarget='..iCurAngleToTarget..'; iCurFacingAngle='..iCurFacingAngle..'; iCurAngleDif='..iCurAngleDif..'; Target unit state='..M28UnitInfo.GetUnitState(oTarget)..'; Dist from ground='..(oTarget:GetPosition()[2] - GetSurfaceHeight(oTarget:GetPosition()[1], oTarget:GetPosition()[3]))..'; Time since last fired weapon='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0)) end
                                if iCurAngleDif > 15 then
                                    iReorderDist = 0.1
                                    --Turn towards target - decide which is closest way

                                    if iCurAngleToTarget > iCurFacingAngle then
                                        if iCurAngleToTarget - iCurFacingAngle > 180 then
                                            --Clockwise means increasing our cur facing angle; however if gap between the angles is more than 180 would be better to decrease our facing angle
                                            bTurnClockwise = false
                                        else
                                            bTurnClockwise = true
                                        end
                                    else --curfacingangle is >= angle to target
                                        if iCurFacingAngle - iCurAngleToTarget > 180 then
                                            --Gap between the two is so large, that increasing our facing angle should get us to the target quicker
                                            bTurnClockwise = true
                                        else
                                            bTurnClockwise = false
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will turn towards target, bTurnClockwise='..tostring(bTurnClockwise)) end

                                    if GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0) > iMaxTimeBetweenShotsWanted then
                                        if iCurDistToTarget >= 10 then
                                            iDistToMoveTowardsTarget = math.max(2, iCurDistToTarget * 0.3)
                                        else
                                            bManualAttack = true --issues with asfs not turning properly when facing a target when they have got too close, so if we are close to a taret and facing the wrong direction, will switch to a manual attack
                                        end
                                        iAngleToMove = 15
                                    else
                                        iDistToMoveTowardsTarget = 0.1
                                        iAngleToMove = 15
                                    end
                                    if bManualAttack then
                                        tMoveViaPoint = nil
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will switch to manual attack as been a while since we have moved') end
                                    else
                                        if bTurnClockwise then
                                            tMoveViaPoint = M28Utilities.MoveInDirection(oUnit:GetPosition(), iCurFacingAngle + iAngleToMove, iDistToMoveTowardsTarget, true, false, false)
                                        else
                                            tMoveViaPoint = M28Utilities.MoveInDirection(oUnit:GetPosition(), iCurFacingAngle - iAngleToMove, iDistToMoveTowardsTarget, true, false, false)
                                        end
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef..': Dist to tMoveViaPoint='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMoveViaPoint)..'; Angle='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tMoveViaPoint)..'; Time between shots='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0)..'; iMaxTimeBetweenShotsWanted='..iMaxTimeBetweenShotsWanted..'; iDistToMoveTowardsTarget='..iDistToMoveTowardsTarget)
                                            M28Utilities.DrawLocation(oUnit:GetPosition(), 2)
                                            M28Utilities.DrawLocation(tMoveViaPoint, 1)
                                        end
                                    end
                                elseif iCurDistToTarget < iHalfDistThreshold then
                                    --Move a fraction of the way towards target
                                    iReorderDist = 0.1
                                    tMoveViaPoint = M28Utilities.MoveInDirection(oUnit:GetPosition(), iCurAngleToTarget, 0.1, true, false, false)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will move towards unti by 0.1 distance but with the correct angle') end
                                else
                                    --Move 25% towards target
                                    iReorderDist = math.min(iCurDistToTarget * 0.25, iCurDistToTarget - iHalfDistThreshold)

                                    tMoveViaPoint = M28Utilities.MoveInDirection(oUnit:GetPosition(), iCurAngleToTarget, iReorderDist, true, false, false)
                                    if iReorderDist > 5 then iReorderDist = 5 end
                                    if bDebugMessages == true then LOG(sFunctionRef..': will move 25% of the way towards the target') end
                                end
                            end
                        end
                        iReorderDist = nil
                        if bDebugMessages == true then LOG(sFunctionRef..': Unit cur position='..repru(oUnit:GetPosition())..'; tMoveViaPoint='..repru(tMoveViaPoint)..'; Time='..GetGameTimeSeconds()..'; Time since last weapon event='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0)) end
                        if tMoveViaPoint then
                            M28Orders.IssueTrackedMove(oUnit, tMoveViaPoint, iReorderDist, false, 'AAHvM', true)
                        elseif bManualAttack then
                            --LOUD - abort as cant actually target air units on the ground
                            if M28Utilities.bLoudModActive or M28Utilities.bQuietModActive then break end
                            M28Orders.IssueTrackedAttack(oUnit, oTarget, false, 'AMAHvM', true)
                        else
                            M28Utilities.ErrorHandler('Made mistake have nil move via point')
                        end
                        --Abort if enemy same speed as us and out of our range
                        if bAbortIfTooFar and iCurDistToTarget > iOurRange then
                            break
                        end
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    end
                    oUnit[M28UnitInfo.refbSpecialMicroActive] = false
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function T1HoverBombTarget(oBomber, oTarget, bDontAdjustMicroFlag, bContinueAttackingUntilTargetDead, bAbortForGroundAAUnlessTargetIsEngineer)
    --Based on combination of ahwassa approach and hoverAA approach
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TurnAirUnitAndAttackTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oBomber='..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; GameTime='..GetGameTimeSeconds()) end
    if M28UnitInfo.IsUnitValid(oBomber) and M28UnitInfo.IsUnitValid(oTarget) then
        local iStartTime = GetGameTimeSeconds()
        local iCurAngleDif
        local iMaxMicroTime = 5 --will micro for up to 5 seconds
        if EntityCategoryContains(categories.EXPERIMENTAL, oBomber.UnitId) then
            iMaxMicroTime = 10
        elseif bContinueAttackingUntilTargetDead then iMaxMicroTime = 1000
        end

        if not(bDontAdjustMicroFlag) then TrackTemporaryUnitMicro(oBomber, 60) end --60s is redundancy
        local iMaxTimeBetweenShotsWanted = oBomber[M28UnitInfo.refiTimeBetweenBombs]
        local iCurAngleToTarget, iCurFacingAngle, iReorderDist, iCurDistToTarget, bTurnClockwise, iDistToMoveTowardsTarget, bManualAttack, iAngleToMove, tMoveViaPoint
        local iHalfDistThreshold = (oBomber[M28UnitInfo.refiBomberRange] or 40) * 0.5
        local iMinTimeAfterFiringBeforeGivingNewOrders = 0
        if M28UnitInfo.DoesBomberFireSalvo(oBomber) then iMinTimeAfterFiringBeforeGivingNewOrders = 1.1 end
        local iTeam = oBomber:GetAIBrain().M28Team
        local bAbortForGroundAA = (bAbortForGroundAAUnlessTargetIsEngineer and not(EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oTarget.UnitId)))
        if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop, bAbortForGroundAA='..tostring(bAbortForGroundAA or false)..'; iStartTime='..iStartTime..'; Cur time='..GetGameTimeSeconds()..'; iMaxMicroTime='..iMaxMicroTime..'; Is bomber valid='..tostring(M28UnitInfo.IsUnitValid(oBomber) )..'; Is target valid='..tostring(M28UnitInfo.IsUnitValid(oTarget))) end
        while GetGameTimeSeconds() - iStartTime < iMaxMicroTime and M28UnitInfo.IsUnitValid(oBomber) and M28UnitInfo.IsUnitValid(oTarget) do
            --If have recently fired then dont want to give orders if have a salvo
            if iMinTimeAfterFiringBeforeGivingNewOrders > 0 and GetGameTimeSeconds() - (oBomber[M28UnitInfo.refiLastBombFired] or 0) < iMinTimeAfterFiringBeforeGivingNewOrders then
                --Just wait, dont give orders, so all our bombs can drop
                if bDebugMessages == true then LOG(sFunctionRef..': Bomber fired recently so wont give new orders, time since last fired='..( GetGameTimeSeconds() - oBomber[M28UnitInfo.refiLastBombFired])) end
            else
                --Do we want to abort  micro?
                if bAbortForGroundAA then
                    local tTargetLZData, tTargetLZTeamData = M28Map.GetLandOrWaterZoneData(oTarget:GetPosition(), true, iTeam)
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to abort due to enemy groundAA='..tTargetLZTeamData[M28Map.subrefiThreatEnemyGroundAA]..'; Does the zone have too much AA for base bomber='..tostring(M28Conditions.EnemyZoneHasTooMuchAAForBaseBomber(tTargetLZTeamData) or false)) end
                    if M28Conditions.EnemyZoneHasTooMuchAAForBaseBomber(tTargetLZTeamData) then
                        --Return to nearest base
                        if oBomber[M28Air.rebEarlyBomberTargetBase] then oBomber[M28Air.rebEarlyBomberTargetBase] = false end
                        M28Orders.IssueTrackedMove(oBomber, tTargetLZTeamData[M28Map.reftClosestFriendlyBase], 5, false, 'AbortHBM', true)
                        break
                    end
                end
                iCurDistToTarget = M28Utilities.GetDistanceBetweenPositions(oBomber:GetPosition(), oTarget:GetPosition())
                iCurAngleToTarget = M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), oTarget:GetPosition())
                iCurFacingAngle = M28UnitInfo.GetUnitFacingAngle(oBomber)
                iCurAngleDif = M28Utilities.GetAngleDifference(iCurAngleToTarget, iCurFacingAngle)
                bManualAttack = false

                --Are we facing the target? if not, then turn towards them
                if bDebugMessages == true then LOG(sFunctionRef..': iCurDistToTarget='..iCurDistToTarget..'; iCurAngleToTarget='..iCurAngleToTarget..'; iCurFacingAngle='..iCurFacingAngle..'; iCurAngleDif='..iCurAngleDif..'; Target unit state='..M28UnitInfo.GetUnitState(oTarget)..'; Dist from ground='..(oTarget:GetPosition()[2] - GetSurfaceHeight(oTarget:GetPosition()[1], oTarget:GetPosition()[3]))..'; Time since last fired weapon='..GetGameTimeSeconds() - (oBomber[M28UnitInfo.refiLastWeaponEvent] or 0)) end
                if iCurAngleDif > 15 then
                    iReorderDist = 0.1
                    --Turn towards target - decide which is closest way

                    if iCurAngleToTarget > iCurFacingAngle then
                        if iCurAngleToTarget - iCurFacingAngle > 180 then
                            --Clockwise means increasing our cur facing angle; however if gap between the angles is more than 180 would be better to decrease our facing angle
                            bTurnClockwise = false
                        else
                            bTurnClockwise = true
                        end
                    else --curfacingangle is >= angle to target
                        if iCurFacingAngle - iCurAngleToTarget > 180 then
                            --Gap between the two is so large, that increasing our facing angle should get us to the target quicker
                            bTurnClockwise = true
                        else
                            bTurnClockwise = false
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Will turn towards target, bTurnClockwise='..tostring(bTurnClockwise)) end

                    if GetGameTimeSeconds() - (oBomber[M28UnitInfo.refiLastWeaponEvent] or 0) > iMaxTimeBetweenShotsWanted then
                        if iCurDistToTarget >= 10 then
                            iDistToMoveTowardsTarget = math.max(2, iCurDistToTarget * 0.3)
                        else
                            bManualAttack = true --issues with asfs not turning properly when facing a target when they have got too close, so if we are close to a taret and facing the wrong direction, will switch to a manual attack
                        end
                        iAngleToMove = 15
                    else
                        iDistToMoveTowardsTarget = 0.1
                        iAngleToMove = 15
                    end
                    if bManualAttack then
                        tMoveViaPoint = nil
                        if bDebugMessages == true then LOG(sFunctionRef..': Will switch to manual attack as been a while since we have moved') end
                    else
                        if bTurnClockwise then
                            tMoveViaPoint = M28Utilities.MoveInDirection(oBomber:GetPosition(), iCurFacingAngle + iAngleToMove, iDistToMoveTowardsTarget, true, false, false)
                        else
                            tMoveViaPoint = M28Utilities.MoveInDirection(oBomber:GetPosition(), iCurFacingAngle - iAngleToMove, iDistToMoveTowardsTarget, true, false, false)
                        end
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Dist to tMoveViaPoint='..M28Utilities.GetDistanceBetweenPositions(oBomber:GetPosition(), tMoveViaPoint)..'; Angle='..M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), tMoveViaPoint)..'; Time between shots='..GetGameTimeSeconds() - (oBomber[M28UnitInfo.refiLastWeaponEvent] or 0)..'; iMaxTimeBetweenShotsWanted='..iMaxTimeBetweenShotsWanted..'; iDistToMoveTowardsTarget='..iDistToMoveTowardsTarget)
                            M28Utilities.DrawLocation(oBomber:GetPosition(), 2)
                            M28Utilities.DrawLocation(tMoveViaPoint, 1)
                        end
                    end
                    --We are facing the target, if we are able to fire then drop a bomb, otherwise slowly approach
                elseif GetGameTimeSeconds() - (oBomber[M28UnitInfo.refiLastWeaponEvent] or 0) > iMaxTimeBetweenShotsWanted then
                    --Are facing the right direction and able to fire
                    bManualAttack = true
                else
                    --Facing the right direction but unable to fire, so move closer
                    if iCurDistToTarget > oBomber[M28UnitInfo.refiBomberRange] then
                        bManualAttack = true
                    elseif iCurDistToTarget < iHalfDistThreshold then
                        --Move a fraction of the way towards target
                        iReorderDist = 0.1
                        tMoveViaPoint = M28Utilities.MoveInDirection(oBomber:GetPosition(), iCurAngleToTarget, 0.1, true, false, false)
                        if bDebugMessages == true then LOG(sFunctionRef..': Will move towards unti by 0.1 distance but with the correct angle') end
                    else
                        --Move 25% towards target
                        iReorderDist = math.min(iCurDistToTarget * 0.25, iCurDistToTarget - iHalfDistThreshold)
                        tMoveViaPoint = M28Utilities.MoveInDirection(oBomber:GetPosition(), iCurAngleToTarget, iReorderDist, true, false, false)
                        if iReorderDist > 5 then iReorderDist = 5 end
                        if bDebugMessages == true then LOG(sFunctionRef..': will move 25% of the way towards the target') end
                    end
                end
                if bManualAttack then
                    M28Orders.IssueTrackedAttack(oBomber, oTarget, false, 'HoverBmA', true)
                elseif tMoveViaPoint then
                    M28Orders.IssueTrackedMove(oBomber, tMoveViaPoint, iReorderDist, false, 'HverBmM', true)
                else
                    M28Utilities.ErrorHandler('Made mistake have nil move via point')
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': end of loop') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if not(bDontAdjustMicroFlag) and oBomber[M28UnitInfo.refbSpecialMicroActive] then
                oBomber[M28UnitInfo.refbSpecialMicroActive] = false
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of hover bomb code') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SuicideExperimentalIntoEnemyACU(oUnit, oClosestACUNearUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SuicideExperimentalIntoEnemyACU'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Time='..GetGameTimeSeconds()) end
    if M28UnitInfo.IsUnitValid(oUnit) and M28UnitInfo.IsUnitValid(oClosestACUNearUnit) and not(oUnit[M28UnitInfo.refbSpecialMicroActive]) then
        EnableUnitMicroUntilManuallyTurnOff(oUnit, false)
        --Set weapon prioritisation
        M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityExpSnipeACU, false)
        local iCurDist
        local bLastOrderWasManualAttack
        if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop, oUnit (experimental)='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by brain '..oUnit:GetAIBrain().Nickname..'; oClosestACUNearUnit='..oClosestACUNearUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestACUNearUnit)..' owned by '..oClosestACUNearUnit:GetAIBrain().Nickname..'; Dist between them='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestACUNearUnit:GetPosition())) end
        while M28UnitInfo.IsUnitValid(oUnit) and M28UnitInfo.IsUnitValid(oClosestACUNearUnit) and not(oClosestACUNearUnit:IsUnitState('Attached')) and not(M28UnitInfo.IsUnitUnderwater(oClosestACUNearUnit)) do
            --Move towards the ACU
            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestACUNearUnit:GetPosition())
            if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..'; iCurDist='..iCurDist..'; bLastOrderWasManualAttack='..tostring(bLastOrderWasManualAttack)..'; Time='..GetGameTimeSeconds()) end
            if iCurDist >= 8 or (iCurDist >= 5 and not(bLastOrderWasManualAttack)) then
                M28Orders.IssueTrackedMove(oUnit, oClosestACUNearUnit:GetPosition(), 0.5, false, 'ExpKACUM', true)
                bLastOrderWasManualAttack = false
            else
                --Manual attack
                bLastOrderWasManualAttack = true
                M28Orders.IssueTrackedAttack(oUnit, oClosestACUNearUnit, false, 'ExpKACUA', true)
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        if M28UnitInfo.IsUnitValid(oUnit) then
            oUnit[M28UnitInfo.refbSpecialMicroActive] = false
            --Use megalith weapon prioritisation as a proxy for what we are likely to want
            M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityMegalith, false)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderAllInLandPushOnACU(aiBrain, oACU)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderAllInLandPushOnACU'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Separate to the snipe logic, this instead considers if we have enough threat in the vicinity to do an all-in push with just our tanks
    if M28UnitInfo.IsUnitValid(oACU) and not(aiBrain.M28IsDefeated) then
        local iEnemyACUThreat = M28UnitInfo.GetCombatThreatRating({ oACU}, true)
        if bDebugMessages == true then LOG(sFunctionRef..': iEnemyACUThreat='..iEnemyACUThreat..'; ACU owner='..oACU:GetAIBrain().Nickname..'; our brain='..aiBrain.Nickname..'; Time='..GetGameTimeSeconds()) end
        if iEnemyACUThreat <= 3000 then
            local tNearbyFriendlyTanks = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryDFTank - M28UnitInfo.refCategorySkirmisher - categories.COMMAND, oACU:GetPosition(), 60, 'Ally')
            if M28Utilities.IsTableEmpty(tNearbyFriendlyTanks) == false then
                local iFriendlyTankThreat = M28UnitInfo.GetCombatThreatRating(tNearbyFriendlyTanks, false)
                if bDebugMessages == true then LOG(sFunctionRef..': iFriendlyTankThreat='..iFriendlyTankThreat) end
                if iFriendlyTankThreat > math.max(800, iEnemyACUThreat + math.max(400, iEnemyACUThreat * 0.4)) then --Min wanted for an unupgraded enemy ACU
                    local tEnemyThreat = oACU:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategoryPD  - M28UnitInfo.refCategorySkirmisher + categories.COMMAND, oACU:GetPosition(), 90, 'Ally')
                    local iEnemyTotalThreat = M28UnitInfo.GetCombatThreatRating(tEnemyThreat, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': iEnemyTotalThreat='..iEnemyTotalThreat) end
                    if iFriendlyTankThreat > iEnemyTotalThreat then
                        --Suicide all the tanks into the ACU
                        if bDebugMessages == true then LOG(sFunctionRef..': Will suicide tanks into enemy ACU') end
                        AssignACUAttackGridSlot(tNearbyFriendlyTanks, oACU)
                        for iUnit, oUnit in tNearbyFriendlyTanks do
                            if not(oUnit[M28UnitInfo.refbSpecialMicroActive]) then
                                ForkThread(MoveLandUnitNearACU, oUnit, oACU)
                                if bDebugMessages == true then LOG(sFunctionRef..': Will send unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to suicide into enemy ACU') end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MoveLandUnitNearACU(oUnit, oACU)
    --If we are on the same island/plateau as the ACU then will move towards it, switching to attack-move once close
    if M28UnitInfo.IsUnitValid(oUnit) and M28UnitInfo.IsUnitValid(oACU) then
        TrackTemporaryUnitMicro(oUnit, 0, nil, true) --i.e. still want to dodge t1 arti shots
        local sPathingRef
        if EntityCategoryContains(categories.HOVER, oUnit.UnitId) then sPathingRef = M28Map.refPathingTypeHover
        elseif (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > 0 then sPathingRef = M28Map.refPathingTypeAmphibious
        else sPathingRef = M28Map.refPathingTypeLand
        end
        local iNavUtilsWanted = NavUtils.GetLabel(sPathingRef, oUnit:GetPosition())
        if NavUtils.GetLabel(sPathingRef, oACU:GetPosition()) == iNavUtilsWanted then
            --Focus down ACU
            M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityExpSnipeACU, false)
            local tMovePosition            
            local iXOffset
            local iZOffset
            if oUnit[M28UnitInfo.refiACUGridSlot] and oACU[M28UnitInfo.reftoGridXZAdjust][oUnit[M28UnitInfo.refiACUGridSlot]] then
                iXOffset = oACU[M28UnitInfo.reftoGridXZAdjust][oUnit[M28UnitInfo.refiACUGridSlot]][1]
                iZOffset = oACU[M28UnitInfo.reftoGridXZAdjust][oUnit[M28UnitInfo.refiACUGridSlot]][2]
            else
                iXOffset = 0
                iZOffset = 0
                M28Utilities.ErrorHandler('Dont have a valid ACU grid slot assigned')
            end

            while M28UnitInfo.IsUnitValid(oUnit) and M28UnitInfo.IsUnitValid(oACU) and not(oACU:IsUnitState('Attached')) and NavUtils.GetLabel(sPathingRef, oACU:GetPosition()) == iNavUtilsWanted do                 
                tMovePosition = oACU:GetPosition()
                tMovePosition[1] = tMovePosition[1] + iXOffset
                tMovePosition[3] = tMovePosition[3] + iZOffset
                tMovePosition[2] = GetSurfaceHeight(tMovePosition[1], tMovePosition[3])                     
                if M28Utilities.IsTableEmpty(tMovePosition) or not(NavUtils.GetLabel(sPathingRef, tMovePosition) == iNavUtilsWanted) then
                    tMovePosition = oACU:GetPosition()
                end
                M28Orders.IssueTrackedMove(oUnit, tMovePosition, 3, false, 'ACUAllIn', true)                
                WaitSeconds(1)
            end
            if M28UnitInfo.IsUnitValid(oUnit) then
                oUnit[M28UnitInfo.refbSpecialMicroActive] = false
                oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] = GetGameTimeSeconds()
            end
        end
    end
end

function AssignACUAttackGridSlot(tUnits, oACU)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignACUAttackGridSlot'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --First setup the grid slots for the ACU - for now will just do the same every time, but in theory could adjust these baesd on the size of tUnits

    local iMaxGridSize = 64 --8x8
    if not(oACU[M28UnitInfo.reftoGridXZAdjust]) then
        oACU[M28UnitInfo.reftoUnitAssignedToGridSlot] = {}
        oACU[M28UnitInfo.reftoGridXZAdjust] = {}
        local iSpacingBetweenPositions = 3 --so for an 8x8 grid this means a radius of 12
        local iCurSlot = 1
        local iCycleLength = 1
        local iCurX = 0
        local iCurZ = 0
        local iXAdj = 0
        local iPrevXAdj = iSpacingBetweenPositions
        local iZAdj = iSpacingBetweenPositions
        local iPrevZAdj = -iSpacingBetweenPositions
        local iTimeOfXAdjust = 0
        local iTimeOfZAdjust = 0
        local iSwitchCount = 0
        while iCurSlot <= iMaxGridSize do --i.e. an 8x8 grid around the ACU
            --Move in clockwise manner
            if iZAdj == 0 then
                iCurX = iCurX + iXAdj
                iTimeOfXAdjust = iTimeOfXAdjust + 1
                if iTimeOfXAdjust == iCycleLength then
                    iTimeOfXAdjust = 0
                    iPrevXAdj = iXAdj
                    iXAdj = 0
                    --Move up/down for Z now
                    iZAdj = iPrevZAdj * -1
                    iSwitchCount = iSwitchCount + 1
                end
            else
                --Presumably have iXAdj that is zero
                iCurZ = iCurZ + iZAdj
                iTimeOfZAdjust = iTimeOfZAdjust + 1
                if iTimeOfZAdjust == iCycleLength then
                    iTimeOfZAdjust = 0
                    iPrevZAdj = iZAdj
                    iZAdj = 0
                    --Move up/down for Z now
                    iXAdj = iPrevXAdj * -1
                    iSwitchCount = iSwitchCount + 1
                end
            end
            if iSwitchCount >= 2 then
                iCycleLength = iCycleLength + 1
                iSwitchCount = 0
            end
            oACU[M28UnitInfo.reftoGridXZAdjust][iCurSlot] = {iCurX, iCurZ}

            iCurSlot = iCurSlot + 1
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording, iMaxGridSize='..iMaxGridSize..'; iCurX and Z for this=X'..oACU[M28UnitInfo.reftoGridXZAdjust][iMaxGridSize][1]..'Z'..oACU[M28UnitInfo.reftoGridXZAdjust][iMaxGridSize][2]) end
    end

    local iUnitsWithoutAssignment = 0
    local toUnassignedUnits = {}
    local toUnassignedRefByDistance = {}
    for iUnit, oUnit in tUnits do
        if not(oUnit[M28UnitInfo.refiACUGridSlot]) then
            iUnitsWithoutAssignment = iUnitsWithoutAssignment + 1
            table.insert(toUnassignedUnits, oUnit)
            table.insert(toUnassignedRefByDistance, M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition()))
        end
    end

    if iUnitsWithoutAssignment > 0 then
        --Check we have enough slots
        local iSlotsAvailable = 0
        local iSlotsWanted = math.max(30, iUnitsWithoutAssignment) --i.e. 8+8+7+7
        local iCurUnitCount = table.getn(tUnits)
        if bDebugMessages == true then LOG(sFunctionRef..': iCurUnitCount='..iCurUnitCount..'; Do we have a slot for this already? repru='..repru(oACU[M28UnitInfo.reftoGridXZAdjust][iCurUnitCount] or 'nil')) end

        --Record available slots
        local iCurSlot = 0
        local tiAvailableSlots = {}
        local iLastAvailableSlot
        while iSlotsAvailable < iSlotsWanted do
            iCurSlot = iCurSlot + 1
            if not(M28UnitInfo.IsUnitValid(oACU[M28UnitInfo.reftoUnitAssignedToGridSlot][iCurSlot])) then
                oACU[M28UnitInfo.reftoUnitAssignedToGridSlot][iCurSlot] = nil
                iSlotsAvailable = iSlotsAvailable + 1
                table.insert(tiAvailableSlots, iCurSlot)
                if bDebugMessages == true then LOG(sFunctionRef..': No valid unit is assigned to slot '..iCurSlot..' so will increase available slots by 1 to '..iSlotsAvailable) end
            end
            if not(oACU[M28UnitInfo.reftoGridXZAdjust][iCurSlot]) then
                iLastAvailableSlot = iCurSlot - 1
                break
            end
        end

        if iLastAvailableSlot then
            local iExtraSlotsWanted = iSlotsWanted - iLastAvailableSlot
            if iExtraSlotsWanted <= 0 then iExtraSlotsWanted= 1 end --redundancy
            local iRecordedSize = iMaxGridSize
            while oACU[M28UnitInfo.reftoGridXZAdjust][iRecordedSize] do
                iRecordedSize = iRecordedSize + iMaxGridSize
            end
            iRecordedSize = iRecordedSize - iMaxGridSize
            local iSizeToRecord = math.round(iExtraSlotsWanted / iMaxGridSize) * iMaxGridSize + iRecordedSize
            if bDebugMessages == true then LOG(sFunctionRef..': iRecordedSize by interval='..iRecordedSize..'; iSizeToRecord='..iSizeToRecord..'; iSlotsWanted='..iSlotsWanted..'; iLastAvailableSlot='..iLastAvailableSlot..'; iExtraSlotsWanted='..iExtraSlotsWanted) end
            for iCurSlot = iRecordedSize + 1, iSizeToRecord, 1 do
                oACU[M28UnitInfo.reftoGridXZAdjust][iCurSlot] = {oACU[M28UnitInfo.reftoGridXZAdjust][iCurSlot - iMaxGridSize][1], oACU[M28UnitInfo.reftoGridXZAdjust][iCurSlot - iMaxGridSize][2]}
                if iSlotsAvailable <= iSlotsWanted then
                    table.insert(tiAvailableSlots, iCurSlot)
                    iSlotsAvailable = iSlotsAvailable + 1
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording new slot as available, iCurSLot='..iCurSlot..'; oACU[M28UnitInfo.reftoGridXZAdjust][iCurSlot]=X'..oACU[M28UnitInfo.reftoGridXZAdjust][iCurSlot][1]..'Z'..oACU[M28UnitInfo.reftoGridXZAdjust][iCurSlot][2]) end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished recording extra slots, iSizeToRecord='..iSizeToRecord..'; oACU[M28UnitInfo.reftoGridXZAdjust][iSizeToRecord]='..repru(oACU[M28UnitInfo.reftoGridXZAdjust][iSizeToRecord] or 'nil')..'; iSlotsAvailable (stopping once reach iSlotsWanted)='..iSlotsAvailable..'; iSlotsWanted='..iSlotsWanted) end
        end


        --Sort units awaiting for assignment by distance to the ACU, starting with the fursthest away
        local iClosestDist, iCurDist
        local iClosestSlot
        local iClosestAvailableSlotRef
        local iBaseX = oACU:GetPosition()[1]
        local iBaseZ = oACU:GetPosition()[3]
        local tGrid = oACU[M28UnitInfo.reftoGridXZAdjust]
        if bDebugMessages == true then LOG(sFunctionRef..': iSlotsAvailable='..iSlotsAvailable..'; iUnitsWithoutAssignment='..iUnitsWithoutAssignment) end
        for iUnitRef, iDistance in M28Utilities.SortTableByValue(toUnassignedRefByDistance, true) do
            local oUnit = toUnassignedUnits[iUnitRef]
            --Find the closest available slot
            iClosestSlot = nil
            iClosestAvailableSlotRef = nil
            iClosestDist = 10000
            if iSlotsAvailable > 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Sorting through available slots for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                for iAvailableTableEntry, iSlot in tiAvailableSlots do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAvailableTableEntry='..iAvailableTableEntry..'; iSlot='..iSlot..'; Is tGrid[iSlot] nil='..tostring(tGrid[iSlot] == nil)) end
                    if tGrid[iSlot] then --Im guessing that removing slots can lead to the table having nil entries at the end
                        iCurDist = M28Utilities.GetDistanceBetweenPositions({iBaseX + tGrid[iSlot][1], 0, iBaseZ + tGrid[iSlot][2]}, oUnit:GetPosition())
                        if iCurDist < iClosestDist then
                            iClosestDist = iCurDist
                            iClosestSlot = iSlot
                            iClosestAvailableSlotRef = iAvailableTableEntry
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': No valid ref so will abort if have a valid ref from earlier') end
                        if iClosestAvailableSlotRef then break end
                    end
                end
                if iClosestSlot and iClosestAvailableSlotRef then
                    oUnit[M28UnitInfo.refiACUGridSlot] = iClosestSlot
                    oACU[M28UnitInfo.reftoUnitAssignedToGridSlot][iClosestSlot] = oUnit
                    if bDebugMessages == true then LOG(sFunctionRef..': removing entry '..iClosestAvailableSlotRef..' from the table of available slots, iClosestSlot='..iClosestSlot) end
                    table.remove(tiAvailableSlots, iClosestAvailableSlotRef)
                else
                    --Redundancy
                    oUnit[M28UnitInfo.refiACUGridSlot] = 1
                end
            else
                --Redundancy
                oUnit[M28UnitInfo.refiACUGridSlot] = 1
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end