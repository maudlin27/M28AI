---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 18/01/2023 06:57
---
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local XZDist = import('/lua/utilities.lua').XZDistanceTwoVectors
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')

refbMicroResetChecker = 'M28MicChk' --True if we have an active thread checking if micro time has expired

function MoveAwayFromTargetTemporarily(oUnit, iTimeToRun, tPositionToRunFrom)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MoveAwayFromTargetTemporarily'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bMoveInStages = false --set to true later if hardly have any time to run, but in reality this functionality isn't expected to be used in most cases, left in since took a while to get it to work to a basic level, but turns out it's probably better to just move in a straight line rather than trying multiple move orders


    local tUnitPosition = oUnit:GetPosition()
    local oBP = oUnit:GetBlueprint()
    local iUnitSpeed = (oBP.Physics.MaxSpeed or 0)
    if iUnitSpeed > 0 then
        local iDistanceToMove = (iTimeToRun + 1) * iUnitSpeed
        --local tRevisedPositionToRunFrom

        local iCurFacingDirection = M28UnitInfo.GetUnitFacingAngle(oUnit)
        local iAngleFromUnitToBomb
        if tUnitPosition[1] == tPositionToRunFrom[1] and tUnitPosition[3] == tPositionToRunFrom[3] then
            iAngleFromUnitToBomb = iCurFacingDirection - 180
            if iAngleFromUnitToBomb < 0 then iAngleFromUnitToBomb = iAngleFromUnitToBomb + 360 end
        else
            iAngleFromUnitToBomb = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tPositionToRunFrom)
        end

        local iAngleAdjFactor
        local iFacingAngleWanted = iAngleFromUnitToBomb + 180
        if iFacingAngleWanted >= 360 then iFacingAngleWanted = iFacingAngleWanted - 360 end

        local iTurnRate = (oBP.Physics.TurnRate or 90)
        local iBackupDist = (oBP.Physics.BackUpDistance or 0)
        local iTimeToTurn
        local bBackupInsteadOfTurning = false
        local iDistToBomb = M28Utilities.GetDistanceBetweenPositions(tPositionToRunFrom, oUnit:GetPosition())
        if iBackupDist >= 4 then
            bBackupInsteadOfTurning = true
            iTimeToTurn = 0
            if M28Utilities.GetAngleDifference(iCurFacingDirection, iFacingAngleWanted) <= 90 then
                iFacingAngleWanted = iCurFacingDirection
            else
                iFacingAngleWanted = iCurFacingDirection + 180
                if iFacingAngleWanted >= 360 then iFacingAngleWanted = iFacingAngleWanted - 360 end
            end
            iDistanceToMove = iDistanceToMove + math.min(iDistToBomb, iDistanceToMove * 0.5)
        else
            if iTurnRate <= 0 then iTimeToTurn = 0 else iTimeToTurn = math.abs(iFacingAngleWanted - iCurFacingDirection) / iTurnRate end
            if iDistToBomb * 2 / iUnitSpeed <= iTimeToTurn then
                iFacingAngleWanted = iCurFacingDirection
                iDistanceToMove = iDistanceToMove + iDistToBomb
            end
        end

        if iTimeToTurn > iTimeToRun and not(bBackupInsteadOfTurning) then bMoveInStages = true end

        local tTempLocationToMove

        if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop for move commands for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTimeToRun='..iTimeToRun..'; iCurFacingDirection='..iCurFacingDirection..'; iAngleFromUnitToBomb='..iAngleFromUnitToBomb..'; iFacingAngleWanted='..iFacingAngleWanted..'; tUnitStartPosition='..repru(oUnit:GetPosition())..'; tPositionToRunFrom='..repru(tPositionToRunFrom)..'; bBackupInsteadOfTurning='..tostring(bBackupInsteadOfTurning)) end
        M28Orders.IssueTrackedClearCommands(oUnit)
        TrackTemporaryUnitMicro(oUnit, iTimeToRun)
        tTempLocationToMove = oUnit:GetPosition()
        local iDistanceAlreadyMoved = 0


        --Turn around while moving away if we're not facing the right direction:
        if bMoveInStages then
            local iInitialAngleAdj = 30
            local iAngleMaxSingleAdj = 45
            local iTempDistanceAwayToMove = 3
            local iDistanceIncreasePerCycle = 1.5
            local iDistanceIncreaseCompoundFactor = 1.5
            local iLoopCount = 0

            if math.abs(iCurFacingDirection - iFacingAngleWanted) > (iAngleMaxSingleAdj + iInitialAngleAdj) then
                local iTempAngleDirectionToMove = iCurFacingDirection

                if iCurFacingDirection - iFacingAngleWanted > 0 then
                    if iCurFacingDirection - iFacingAngleWanted > 180 then iAngleAdjFactor = 1 --Clockwise
                    else iAngleAdjFactor = -1 --AntiClockwise
                    end

                elseif iCurFacingDirection - iFacingAngleWanted < -180 then iAngleAdjFactor = -1
                else iAngleAdjFactor = 1
                end --Clockwise



                while iLoopCount < 6 do
                    iLoopCount = iLoopCount + 1

                    iTempAngleDirectionToMove = iCurFacingDirection + (iInitialAngleAdj + iLoopCount * iAngleMaxSingleAdj) * iAngleAdjFactor
                    if iTempAngleDirectionToMove > 360 then iTempAngleDirectionToMove = iTempAngleDirectionToMove - 360
                    elseif iTempAngleDirectionToMove < 0 then iTempAngleDirectionToMove = iTempAngleDirectionToMove + 360
                    end

                    if bDebugMessages == true then LOG(sFunctionRef..': iLoopCount='..iLoopCount..'; iTempAngleDirectionToMove='..iTempAngleDirectionToMove..'; iInitialAngleAdj='..iInitialAngleAdj..'; iAngleAdjFactor='..iAngleAdjFactor..'; iCurFacingDirection='..iCurFacingDirection..'; iFacingAngleWanted='..iFacingAngleWanted) end


                    iTempDistanceAwayToMove = iTempDistanceAwayToMove + iDistanceIncreasePerCycle * iDistanceIncreasePerCycle * (iDistanceIncreaseCompoundFactor ^ iLoopCount - 1)
                    tTempLocationToMove = M28Utilities.MoveInDirection(oUnit:GetPosition(), iTempAngleDirectionToMove, iTempDistanceAwayToMove, true, false, true)
                    M28Orders.IssueTrackedMove(oUnit, tTempLocationToMove, 0.25, true, 'TempMA', true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Just issued move order to tTempLocationToMove='..repru(tTempLocationToMove)..'; iTempAngleDirectionToMove='..iTempAngleDirectionToMove) end
                    if math.abs(iTempAngleDirectionToMove - iFacingAngleWanted) <= iAngleMaxSingleAdj then break
                    elseif math.abs(iTempAngleDirectionToMove - iFacingAngleWanted) > 360 then
                        M28Utilities.ErrorHandler('Something has gone wrong with dodge micro, will stop trying to turn around')
                        break
                    end
                end
                iDistanceAlreadyMoved = M28Utilities.GetDistanceBetweenPositions(tTempLocationToMove, tPositionToRunFrom)
            end
        end
        --Should now be facing close to the right direction, so move further in this direction


        --If are backing up, then consider queuing up multiple move orders
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we should backup, bBackupInsteadOfTurning='..tostring(bBackupInsteadOfTurning or false)) end
        if bBackupInsteadOfTurning and iBackupDist - 1 > 0 and iDistanceToMove > iDistanceAlreadyMoved then
            local iPlateauWanted = NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oUnit:GetPosition())
            local iCurDistToMove
            local bFirstTime = true
            while iDistanceAlreadyMoved < iDistanceToMove do
                iCurDistToMove = math.min(iBackupDist - 1, math.max(1, iDistanceToMove - iDistanceAlreadyMoved))
                local tViaPoint = M28Utilities.MoveInDirection(oUnit:GetPosition(), iFacingAngleWanted, iCurDistToMove + iDistanceAlreadyMoved, true, false, true)
                if NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, tViaPoint) == iPlateauWanted then
                    --Are we either an amphibious/hover unit, of a land unit on the same island, or a naval unit on the same pond
                    if EntityCategoryContains(categories.AMPHIBIOUS + categories.AIR, oUnit.UnitId)
                            or (EntityCategoryContains(categories.LAND, oUnit.UnitId) and NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, oUnit:GetPosition()) == NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tViaPoint))
                            or (EntityCategoryContains(categories.NAVAL, oUnit.UnitId) and NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, oUnit:GetPosition()) == NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tViaPoint)) then
                        M28Orders.IssueTrackedMove(oUnit, tViaPoint, 0.25, true, 'BckupDodMv', true)
                        iDistanceAlreadyMoved = iDistanceAlreadyMoved + iCurDistToMove
                        if bFirstTime then TrackTemporaryUnitMicro(oUnit, iTimeToRun) bFirstTime = false end
                        if bDebugMessages == true then LOG(sFunctionRef..': Backing up to via point, iCurDistToMove='..iCurDistToMove..'; iDistanceAlreadyMoved='..iDistanceAlreadyMoved) end
                    else
                        --Abort
                        break
                    end
                else
                    break
                end
            end
        end
        if not(bBackupInsteadOfTurning) or iDistanceToMove < iDistanceAlreadyMoved then
            local tNewTargetIgnoringGrouping = M28Utilities.MoveInDirection(oUnit:GetPosition(), iFacingAngleWanted, math.max(1, iDistanceToMove - iDistanceAlreadyMoved), true, false, true)
            if bDebugMessages == true then LOG(sFunctionRef..': Finished trying to face the right direction, tNewTargetIgnoringGrouping='..repru(tNewTargetIgnoringGrouping)..'; tUnitPosition='..repru(tUnitPosition)..'; iDistanceToMove='..iDistanceToMove..'; iDistanceAlreadyMoved='..iDistanceAlreadyMoved) end
            if EntityCategoryContains(M28UnitInfo.refCategoryAllAir, oUnit.UnitId) then
                M28Orders.IssueTrackedMove(oUnit, tNewTargetIgnoringGrouping, 0.25, true, 'TempGA', true)
                if bDebugMessages == true then LOG(sFunctionRef..': Dodging bomb for air unit, tNewTargetIgnoringGrouping='..repru(tNewTargetIgnoringGrouping)..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
            else
                local tNewTargetInSameGroup = M28Map.GetPositionAtOrNearTargetInPathingGroup(tUnitPosition, tNewTargetIgnoringGrouping, 0, 0, oUnit, true, false)
                if tNewTargetInSameGroup then
                    if bDebugMessages == true then LOG(sFunctionRef..': Starting bomber dodge for unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; tNewTargetInSameGroup='..repru(tNewTargetInSameGroup)) end

                    M28Orders.IssueTrackedMove(oUnit, tNewTargetInSameGroup, 0.25, true, 'TempMA', true)
                    TrackTemporaryUnitMicro(oUnit, iTimeToRun)
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code at time='..GetGameTimeSeconds()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetBombTarget(weapon, projectile)
    --based on CalcBallisticAcceleration

    --Copy of CalcBallisticAcceleration core part of calculation to determine bomb target; ignores multiple bombs
    local acc = 4.75
    if projectile and projectile.GetLauncher then
        local launcher = projectile:GetLauncher()
        if launcher then
            -- Get projectile position and velocity
            -- velocity needs to multiplied by 10 due to being returned /tick instead of /s
            local proj = {pos=projectile:GetPosition(), vel=VMult(Vector(launcher:GetVelocity()), 10)}
            local entity = launcher:GetTargetEntity()

            local target
            if entity and IsUnit(entity) then
                -- target is a entity
                target = {pos=entity:GetPosition(), vel=VMult(Vector(entity:GetVelocity()), 10)}
            else
                -- target is something else i.e. attack ground
                target = {pos=weapon:GetCurrentTargetPos(), vel=Vector(0, 0, 0)}
            end

            -- calculate flat(exclude y-axis) distance and velocity between projectile and target
            if M28Utilities.IsTableEmpty(target) == false and M28Utilities.IsTableEmpty(proj.pos) == false and target.pos and target.vel and proj.pos and target.pos then
                local dist = {pos=XZDist(proj.pos, target.pos), vel=XZDist(proj.vel, target.vel)}

                -- how many seconds until the bomb hits the target in xz-space
                local time = dist.pos / dist.vel
                if time == 0 then return acc end

                -- find out where the target will be at that point in time (it could be moving)
                target.tpos = {target.pos[1] + time * target.vel[1], 0, target.pos[3] + time * target.vel[3]}
                -- what is the height at that future position
                target.tpos[2] = GetSurfaceHeight(target.tpos[1], target.tpos[3])
                return target.tpos
            end
        end
    elseif not(projectile) then
        if weapon.GetCurrentTarget then
            if weapon:GetCurrentTarget().GetPosition then return weapon:GetCurrentTarget():GetPosition() end
        end
        if weapon.GetCurrentTargetPos then
            if weapon:GetCurrentTargetPos() then return weapon:GetCurrentTargetPos() end
        end
    end
    return nil
end

function FriendlyGunshipsAvoidBomb(oBomber, oWeapon, projectile)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'FriendlyGunshipsAvoidBomb'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local tBombTarget = GetBombTarget(oWeapon, projectile)
    if tBombTarget then
        local iBombSize = oWeapon:GetBlueprint().DamageRadius
        if bDebugMessages == true then LOG(sFunctionRef..': Near start, oBomber='..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; tBombTarget='..repru(tBombTarget)..'; iBombSize='..iBombSize) end
        if iBombSize then
            local iCategoriesToRun = M28UnitInfo.refCategoryGunship
            local iRadiusSize = iBombSize + 10
            local aiBrain = oBomber:GetAIBrain()
            local tUnitsToRun = aiBrain:GetUnitsAroundPoint(iCategoriesToRun, tBombTarget, iRadiusSize, 'Ally')
            if M28Utilities.IsTableEmpty(tUnitsToRun) == false then
                local tTemporaryDestination = M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.reftAirSubRallyPoint]
                local tAltTempDestination
                local oCurUnitBrain
                local iTeam = aiBrain.M28Team
                local iCurDistToBomb, iCurAngleFromBomb, bMoveToAltDestination
                local iAngleFromBombToBase = M28Utilities.GetAngleFromAToB(tBombTarget, tTemporaryDestination)
                local bCampaignMap = M28Map.bIsCampaignMap
                for iUnit, oUnit in tUnitsToRun do
                    oCurUnitBrain = oUnit:GetAIBrain()
                    if oCurUnitBrain.M28AI and oCurUnitBrain.M28Team == iTeam then
                        if not(oUnit[M28UnitInfo.refbEasyBrain]) then
                            --If gunship runs to temp destination is it likely to be going the wrong way to avoid the bomb? if so then have it run in a different direction
                            iCurDistToBomb = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBombTarget)
                            bMoveToAltDestination = false
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDistToBomb='..iCurDistToBomb..'; ANgle from bomb='..M28Utilities.GetAngleFromAToB(tBombTarget, oUnit:GetPosition())..'; iAngleFromBombToBase='..iAngleFromBombToBase) end
                            if iCurDistToBomb >= 4 then
                                iCurAngleFromBomb = M28Utilities.GetAngleFromAToB(tBombTarget, oUnit:GetPosition())
                                if M28Utilities.GetAngleDifference(iCurAngleFromBomb, iAngleFromBombToBase) > 50 then
                                    bMoveToAltDestination = true
                                    tAltTempDestination = M28Utilities.MoveInDirection(oUnit:GetPosition(), iCurAngleFromBomb, iRadiusSize, true, false, bCampaignMap)
                                end
                            end
                            M28Orders.IssueTrackedClearCommands(oUnit)
                            if bMoveToAltDestination then
                                M28Orders.IssueTrackedMove(oUnit, tAltTempDestination, 3, false, 'AhwRunH', true)
                            else
                                M28Orders.IssueTrackedMove(oUnit, tTemporaryDestination, 3, false, 'AhwRunT', true)
                            end
                            TrackTemporaryUnitMicro(oUnit, 4) --takes roughly 4s for bomb to land
                        end
                    end
                end
            end
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': tBombTarget is nil') end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DodgeBomb(oBomber, oWeapon, projectile)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DodgeBombsFiredByUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tBombTarget = GetBombTarget(oWeapon, projectile)
    if bDebugMessages == true then LOG(sFunctionRef..': Start fo code for bomber '..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; is tBombTarget nil='..tostring(tBombTarget == nil)..'; Time='..GetGameTimeSeconds()) end
    if tBombTarget then
        oBomber[M28UnitInfo.refiLastDodgeBombEvent] = GetGameTimeSeconds()
        local iBombSize = 2.5
        if oWeapon.GetBlueprint then iBombSize = math.max(iBombSize, (oWeapon:GetBlueprint().DamageRadius or iBombSize)) end
        local iTimeToRun = 2.4 --T1, was 1.75 for v83 and earlier but it turned out to not be long enough for a t1 engi to dodge a t1 bomber
        if iBombSize > 2.5 then iTimeToRun = math.min(2.9, iTimeToRun + (iBombSize - 2.5) * 0.5) end --increased the min to 2.9 as of v84
        if EntityCategoryContains(categories.TECH2, oBomber.UnitId) then
            iBombSize = 3
            iTimeToRun = 2.4 --1.95 for v83 and earlier
            if iBombSize > 3 then iTimeToRun = math.min(2.9, iTimeToRun + (iBombSize - 3) * 0.5) end --increased the min to 2.9 as of v84
        elseif EntityCategoryContains(categories.TECH3, oBomber.UnitId) then
            iTimeToRun = 2.5
            --Consider recording for special asf suicide logic
            if bDebugMessages == true then LOG(sFunctionRef..': Will consider logic for suiciding into strat bomber') end
            ForkThread(M28Air.ConsiderRecordingStratBomberToSuicideInto, oBomber)
        end --Some t2 bombers do damage in a spread (cybran, uef)
        --local iTimeToRun = math.min(7, iBombSize + 1)
        local iRadiusSize = iBombSize + 2.5 --was +1 for v83 and earlier, but found if an engi was running towards the bomb target already it wouldn't get picked up and would die

        local iBomberArmyIndex = oBomber:GetAIBrain():GetArmyIndex()

        if bDebugMessages == true then
            LOG(sFunctionRef..': oBomber='..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; Bomber position='..repru(oBomber:GetPosition())..'; tBombTarget='..repru(tBombTarget)..'; Dist between position and target='..M28Utilities.GetDistanceBetweenPositions(oBomber:GetPosition(), tBombTarget)..'; Angle='..M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), tBombTarget)..'; Bomber facing direction='..M28UnitInfo.GetUnitFacingAngle(oBomber)..'; will draw bomb target in black')
            M28Utilities.DrawLocation(tBombTarget, 3, 20)
        end --black ring around target

        local tAllUnitsInArea = GetUnitsInRect(Rect(tBombTarget[1]-iRadiusSize, tBombTarget[3]-iRadiusSize, tBombTarget[1]+iRadiusSize, tBombTarget[3]+iRadiusSize))
        local bDontCheckIfFriendlyGunships = true
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of units in rectangle around bomb radius empty='..tostring(M28Utilities.IsTableEmpty(tAllUnitsInArea))) end
        if M28Utilities.IsTableEmpty(tAllUnitsInArea) == false then
            local tMobileLandAndGunshipsInArea
            if iBombSize <= 9 then tMobileLandAndGunshipsInArea = EntityCategoryFilterDown(M28UnitInfo.refCategoryMobileLand - categories.EXPERIMENTAL, tAllUnitsInArea)
            else
                if EntityCategoryContains(categories.EXPERIMENTAL, oBomber.UnitId) then
                    tMobileLandAndGunshipsInArea = EntityCategoryFilterDown(M28UnitInfo.refCategoryGunship, tAllUnitsInArea)
                    bDontCheckIfFriendlyGunships = false --we get friendly gunships to split up via separate logic
                    iTimeToRun = math.max(iTimeToRun + 1.5, 5.5) --v68 - increased time from iTimeToRun, 3.5 due to issue with ahwassa bomb damage being spread over time
                    table.insert(M28Air.tiRecentExpBomberTargets, {tBombTarget[1], tBombTarget[2], tBombTarget[3]})
                    ForkThread(M28Air.RemoveFirstExpBomberTarget, 10)
                else
                    tMobileLandAndGunshipsInArea = EntityCategoryFilterDown(M28UnitInfo.refCategoryMobileLand - categories.EXPERIMENTAL + M28UnitInfo.refCategoryGunship, tAllUnitsInArea)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Are including gunships in the category of unit to consider dodging') end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of mobile land units in rectangle around bomb radius empty='..tostring(M28Utilities.IsTableEmpty(tMobileLandAndGunshipsInArea))) end
            if M28Utilities.IsTableEmpty(tMobileLandAndGunshipsInArea) == false then
                local oCurBrain
                for iUnit, oUnit in tMobileLandAndGunshipsInArea do
                    if not(oUnit.Dead) and oUnit.GetUnitId and oUnit.GetPosition and oUnit.GetAIBrain then
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Does unit already have micro active='..tostring((oUnit[M28UnitInfo.refbSpecialMicroActive] or false))..'; refbLowerPriorityMicroActive='..tostring(oUnit[M28UnitInfo.refbLowerPriorityMicroActive] or false)..'; iTimeToRun='..iTimeToRun) end
                        oCurBrain = oUnit:GetAIBrain()
                        if oCurBrain.M28AI and not(oCurBrain.M28IsDefeated) and not(oCurBrain:IsDefeated()) and IsEnemy(oCurBrain:GetArmyIndex(), iBomberArmyIndex) then
                            if not(oUnit[M28UnitInfo.refbEasyBrain]) then
                                --ACU specific
                                if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                                    local aiBrain = oCurBrain
                                    --If ACU is upgrading might not want to cancel
                                    local bDontTryAndDodge = false
                                    if oUnit:IsUnitState('Upgrading') then
                                        --Are we facing a T1 bomb?
                                        if EntityCategoryContains(categories.TECH1, oBomber.UnitId) then
                                            bDontTryAndDodge = true
                                        else
                                            --Facing T2+ bomb, so greater risk if we dont try and dodge; dont dodge if are almost complete
                                            if oUnit:GetWorkProgress() >= 0.9 then
                                                bDontTryAndDodge = true
                                            else
                                                --Is it a T2 bomber, and there arent many bombers nearby?
                                                if EntityCategoryContains(categories.TECH2, oBomber.UnitId) then
                                                    local tNearbyBombers = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryBomber + M28UnitInfo.refCategoryGunship - categories.TECH1, oUnit:GetPosition(), 100, 'Enemy')
                                                    if M28Utilities.IsTableEmpty(tNearbyBombers) == true then
                                                        bDontTryAndDodge = true
                                                    else
                                                        local iEnemyBomberCount = 0
                                                        for iEnemy, oEnemy in tNearbyBombers do
                                                            if M28UnitInfo.IsUnitValid(oEnemy) then
                                                                iEnemyBomberCount = iEnemyBomberCount + 1
                                                                if iEnemyBomberCount >= 4 then break end
                                                            end
                                                        end
                                                        if iEnemyBomberCount < 4 then bDontTryAndDodge = true end
                                                    end
                                                end
                                            end
                                        end
                                    elseif oUnit:IsUnitState('Teleporting') then
                                        bDontTryAndDodge = true
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': bDontTryAndDodge after checking if upgrading='..tostring(bDontTryAndDodge)) end
                                    if not(bDontTryAndDodge) then
                                        --Is there a significant enemy land threat and we are against a T1 bomber?
                                        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                                        if iLandZone > 0 and EntityCategoryContains(categories.TECH1, oBomber.UnitId) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefTThreatEnemyCombatTotal] * 1.2 > math.min(300, M28UnitInfo.GetCombatThreatRating({ oUnit }, false, false, false, false, false, false, false)) then
                                            bDontTryAndDodge = true
                                        end
                                    end

                                    if not(bDontTryAndDodge) then
                                        if oUnit[M28UnitInfo.refbSpecialMicroActive] and not(EntityCategoryContains(categories.AIR, oUnit.UnitId)) and not(oUnit[M28UnitInfo.refbLowerPriorityMicroActive]) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will move in a circle as micro is already active') end
                                            MoveInCircleTemporarily(oUnit, iTimeToRun)
                                        else
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will move away from bomb target temporarily') end
                                            MoveAwayFromTargetTemporarily(oUnit, iTimeToRun, tBombTarget)
                                            oUnit[M28UnitInfo.refiGameTimeMicroStarted] = GetGameTimeSeconds()
                                        end
                                    end

                                else
                                    --If we are already in the process of dodging then dont try dodging some more, unless our micro is about to expire
                                    if oUnit[M28UnitInfo.refbSpecialMicroActive] and not(oUnit[M28UnitInfo.refbLowerPriorityMicroActive]) and (oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] or 0) - GetGameTimeSeconds() > 0.5 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Unit has recently tried dodging so dont want to give it another dodge order as it might end up not moving') end
                                    else
                                        --Are we a mobile shield that isn't on the same team as the bomber? If so, then dont worry about dodging
                                        if not(EntityCategoryContains(M28UnitInfo.refCategoryMobileLandShield, oUnit.UnitId)) or not(oUnit.MyShield.GetHealth) or oUnit.MyShield:GetHealth() == 0 or not(oUnit.MyShield.Enabled) or oUnit.MyShield.DepletedByEnergy then
                                            if bDontCheckIfFriendlyGunships or not(EntityCategoryContains(M28UnitInfo.refCategoryGunship, oUnit.UnitId)) or not(oUnit:GetAIBrain().M28Team == oBomber:GetAIBrain().M28Team) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': about to call moveawayfromtargettemporarily') end
                                                MoveAwayFromTargetTemporarily(oUnit, iTimeToRun, tBombTarget)
                                                oUnit[M28UnitInfo.refiGameTimeMicroStarted] = GetGameTimeSeconds()
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': tBombTarget is nil') end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedRemovalOfTargetToAvoid(tTargetLZTeamData, tTargetToAvoid, iDelayInSeconds)
    WaitSeconds(iDelayInSeconds)
    if M28Utilities.IsTableEmpty(tTargetLZTeamData[M28Map.reftiLocationsToAvoid]) == false then
        for iEntry, tEntry in tTargetLZTeamData[M28Map.reftiLocationsToAvoid] do
            if tEntry[1] == tTargetToAvoid[1] and tEntry[3] == tTargetToAvoid[3] then
                table.remove(tTargetLZTeamData[M28Map.reftiLocationsToAvoid], iEntry)
                break
            end
        end
    end
end

function ConsiderDodgingShot(oUnit, oWeapon)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderDodgingShot'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then
        LOG(sFunctionRef..': Just fired, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
        if oWeapon.GetCurrentTarget then
            LOG(sFunctionRef..': Is current target valid='..tostring(M28UnitInfo.IsUnitValid(oWeapon:GetCurrentTarget()))..'; Weapon category='..oWeapon.Blueprint.WeaponCategory)
            if not(M28UnitInfo.IsUnitValid(oWeapon:GetCurrentTarget())) then
                LOG(sFunctionRef..': Invalid target, will do reprs of it:'..reprs(oWeapon:GetCurrentTarget())..' will also draw black square around the weapon target position which is '..repru(oWeapon:GetCurrentTargetPos()))
                local tCurTargetPos = oWeapon:GetCurrentTargetPos()
                if M28Utilities.IsTableEmpty(tCurTargetPos) == false then
                    M28Utilities.DrawLocation(tCurTargetPos, nil, 3, 200)
                end
            else
                LOG(sFunctionRef..': Valid target='..oWeapon:GetCurrentTarget().UnitId..M28UnitInfo.GetUnitLifetimeCount(oWeapon:GetCurrentTarget()))
            end
        else
            LOG(sFunctionRef..': Dont have a current target for this weapon')
        end
    end
    --Direct fire, t1 mobile arti, t2 mobile missile launchers, and experimental land
    if oWeapon.GetCurrentTarget and (oWeapon.Blueprint.WeaponCategory == 'Direct Fire' or oWeapon.Blueprint.WeaponCategory == 'Direct Fire Naval' or oWeapon.Blueprint.WeaponCategory == 'Direct Fire Experimental' or (oWeapon.Blueprint.WeaponCategory == 'Artillery' and EntityCategoryContains(categories.TECH1, oUnit.UnitId)) or (oWeapon.Blueprint.WeaponCategory == 'Missile' and oWeapon.Blueprint.MaxRadius <= 80)) or (oWeapon.Blueprint.WeaponCategory == 'Indirect Fire' and oWeapon.Blueprint.MuzzleVelocity <= 25) then
        if bDebugMessages == true then LOG(sFunctionRef..': Have a valid weapon category, will see if have targets to consider dodging') end
        local oWeaponTarget
        if oWeapon.GetCurrentTarget and not(oWeapon:BeenDestroyed()) then oWeaponTarget = oWeapon:GetCurrentTarget() end
        local bConsiderUnitsInArea = false
        if not(M28UnitInfo.IsUnitValid(oWeaponTarget)) or EntityCategoryContains(categories.NAVAL * categories.MOBILE, oWeaponTarget.UnitId) or ((oWeapon.Blueprint.DamageRadius or 0) >= 1 and ((oWeapon.Blueprint.FiringTolerance or 0) >= 0.5 or oWeapon.WeaponCategory == 'Artillery')) then bConsiderUnitsInArea = true end

        local tUnitsToConsiderDodgeFor = {}
        function ConsiderAddingUnitToTable(oCurUnit, bIncludeBusyUnits)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we should add oCurUnit='..oCurUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oCurUnit)..'; Brain='..oCurUnit:GetAIBrain().Nickname..'; Unit state='..M28UnitInfo.GetUnitState(oCurUnit)..'; Special micro active='..tostring(oCurUnit[M28UnitInfo.refbSpecialMicroActive] or false)..'; Time='..GetGameTimeSeconds()..'; refiGameTimeToResetMicroActive='..(oCurUnit[M28UnitInfo.refiGameTimeToResetMicroActive] or 'nil')) end
            if oCurUnit:GetAIBrain().M28AI and (bIncludeBusyUnits or (not(oCurUnit:IsUnitState('Upgrading')) and (not(oCurUnit[M28UnitInfo.refbSpecialMicroActive]) or oCurUnit[M28UnitInfo.refbLowerPriorityMicroActive]))) then
                if EntityCategoryContains(categories.AIR + categories.STRUCTURE, oCurUnit.UnitId) then
                    --Do nothing
                elseif EntityCategoryContains(categories.MOBILE, oCurUnit.UnitId) then
                    if oCurUnit:GetFractionComplete() == 1 and M28UnitInfo.IsUnitValid(oCurUnit) then
                        if not(oUnit[M28UnitInfo.refbEasyBrain]) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Added unit to table of units to consider dodging for') end
                            table.insert(tUnitsToConsiderDodgeFor, oCurUnit)
                        end
                    end
                end
            end
        end
        local bIncludeBusyUnits = false
        if oWeapon.Blueprint.Damage >= 5000 then bIncludeBusyUnits = true end
        if not(bConsiderUnitsInArea) then
            --Is it a unit with a shield?
            if EntityCategoryContains(categories.SHIELD, oWeaponTarget.UnitId) then
                local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oWeaponTarget, true)
                if (iCurShield or 0) <= (iMaxShield or 0) * 0.2 then
                    ConsiderAddingUnitToTable(oWeaponTarget, bIncludeBusyUnits)
                end
            else
                ConsiderAddingUnitToTable(oWeaponTarget, bIncludeBusyUnits)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Dont want to consider units in area so will only consider oWeaponTarget') end

        else
            --Does the weapon have an aoe?
            if bDebugMessages == true then LOG(sFunctionRef..': oWeapon.Blueprint.DamageRadius='..(oWeapon.Blueprint.DamageRadius or 'nil')..'; will consider units in an area if it is an aoe attack, oWeaponTarget='..(oWeaponTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oWeaponTarget) or 'nil')) end
            if (oWeapon.Blueprint.DamageRadius or 0) > 0.1 then
                --Get all units in area
                local tWeaponTarget
                if oWeaponTarget then
                    tWeaponTarget = oWeaponTarget:GetPosition()
                    --Add to list of locations in the zone to avoid if its an M28 unit  and we arent getting close to unit cap and early-mid game
                        --Commented out as not sure it makes things better
                    --[[if oWeaponTarget:GetAIBrain().M28AI and GetGameTimeSeconds() <= 1800 and (oWeaponTarget:GetAIBrain()[M28Overseer.refiExpectedRemainingCap] or 0) >= 200 and tWeaponTarget[2] >= M28Map.iMapWaterHeight then
                        local tTargetLZData, tTargetLZTeamData = M28Map.GetLandOrWaterZoneData(tWeaponTarget, true, oWeaponTarget:GetAIBrain().M28Team)
                        local iExistingEntries = 0
                        if M28Utilities.IsTableEmpty(tTargetLZTeamData[M28Map.reftiLocationsToAvoid]) == false then
                            iExistingEntries = table.getn(tTargetLZTeamData[M28Map.reftiLocationsToAvoid])
                        else
                            tTargetLZTeamData[M28Map.reftiLocationsToAvoid] = {}
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iExistingEntries in locations to avoid='..iExistingEntries..'; if <10 then will insert') end
                        if iExistingEntries < 10 then
                            local tTargetToAvoid = {tWeaponTarget[1], tWeaponTarget[2], tWeaponTarget[3]}
                            table.insert(tTargetLZTeamData[M28Map.reftiLocationsToAvoid], tTargetToAvoid)
                            ForkThread(DelayedRemovalOfTargetToAvoid, tTargetLZTeamData, tTargetToAvoid, 3)
                        end
                    end--]]
                else
                    tWeaponTarget = oWeapon:GetCurrentTargetPos()
                end

                if M28Utilities.IsTableEmpty(tWeaponTarget) == false then
                    local iRadiusSize = math.min(5, 1 + math.max(oWeapon.Blueprint.DamageRadius + 0.5 + 7 * (oWeapon.Blueprint.FiringRandomness or 0), 1))
                    if bDebugMessages == true then LOG(sFunctionRef..': iRadiusSize='..iRadiusSize..'; based ond amage radius='..oWeapon.Blueprint.DamageRadius..'; and firing randomness='..(oWeapon.Blueprint.FiringRandomness or 'nil')..'; will draw weapon target')
                        M28Utilities.DrawLocation(tWeaponTarget, 1)
                    end
                    local tAllUnitsInArea = GetUnitsInRect(Rect(tWeaponTarget[1]-iRadiusSize, tWeaponTarget[3]-iRadiusSize, tWeaponTarget[1]+iRadiusSize, tWeaponTarget[3]+iRadiusSize))
                    if M28Utilities.IsTableEmpty(tAllUnitsInArea) == false then
                        --Do we have shield units in the area with at least 20% shield? Will assume shield covers all the units
                        local tShieldsInArea = EntityCategoryFilterDown(categories.SHIELD, tAllUnitsInArea)
                        local bUnderMobileShield = false
                        if M28Utilities.IsTableEmpty(tShieldsInArea) == false then
                            local iCurShield, iMaxShield
                            for iShield, oShield in tShieldsInArea do
                                iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': oCurUnit='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; iCurShield='..iCurShield..'; iMaxShield='..iMaxShield) end
                                if (iCurShield or 0) > (iMaxShield or 0) * 0.2 then
                                    bUnderMobileShield = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Unit has at least 20% shield remaining so wont dodge') end
                                    break
                                end
                            end
                        end
                        if not(bUnderMobileShield) then
                            for iNearbyUnit, oNearbyUnit in tAllUnitsInArea do
                                ConsiderAddingUnitToTable(oNearbyUnit, bIncludeBusyUnits)
                            end
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of units to consider dodging empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToConsiderDodgeFor))..'; Weapon damage='..oWeapon.Blueprint.Damage) end
        if M28Utilities.IsTableEmpty(tUnitsToConsiderDodgeFor) == false then
            --Calculate time to impact
            local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oWeapon:GetCurrentTargetPos())
            local iMaxTimeToRun = 3
            if oWeapon.Blueprint.WeaponCategory == 'Artillery' then
                iDistToTarget = iDistToTarget + 15
                iMaxTimeToRun = 0.8
            elseif oWeapon.Blueprint.WeaponCategory == 'Missile' then
                iDistToTarget = iDistToTarget + 10
                iMaxTimeToRun = 0.8
            end
            local iShotSpeed = oWeapon.Blueprint.MuzzleVelocity
            local iTimeUntilImpact = iDistToTarget / iShotSpeed
            local bCancelDodge = false
            local iHoverMaxTimeToRun

            if iMaxTimeToRun < 1.1 then iHoverMaxTimeToRun = 1.1 end
            if bDebugMessages == true then LOG(sFunctionRef..': Dist to target='..iDistToTarget..'; Shot speed='..iShotSpeed..'; iTimeUntilImpact='..iTimeUntilImpact..'; Is weapon target a bot='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAttackBot, (oWeaponTarget.UnitId or 'uel0001')))) end
            if iTimeUntilImpact > 0.8 or (oWeaponTarget and EntityCategoryContains(M28UnitInfo.refCategoryAttackBot, oWeaponTarget.UnitId) and iTimeUntilImpact >= 0.2) then
                for iTarget, oTarget in tUnitsToConsiderDodgeFor do
                    bCancelDodge = false
                    if bDebugMessages == true then LOG(sFunctionRef..': oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Weapon damage='..oWeapon.Blueprint.Damage..'; Target health='..oTarget:GetHealth()) end
                    --Does the shot do enough damage that we want to try and doge it?
                    if oWeapon.Blueprint.Damage / oTarget:GetHealth() >= 0.01 or (EntityCategoryContains(categories.COMMAND, oTarget.UnitId) and ((oWeapon.Blueprint.WeaponCategory == 'Artillery' and EntityCategoryContains(categories.INDIRECTFIRE - categories.TECH3, oUnit.UnitId) and (oWeapon.Blueprint.Damage / oTarget:GetHealth() >= 0.0035)) or (oWeapon.Blueprint.WeaponCategory == 'Missile' and EntityCategoryContains(categories.INDIRECTFIRE - categories.TECH3, oUnit.UnitId) and (oWeapon.Blueprint.Damage / oTarget:GetHealth() >= 0.006)))) then
                        --Do we think we can dodge the shot?
                        --If we are a large unit then only dodge if will be a while for the shot to hit
                        local oBP = oTarget:GetBlueprint()
                        local iAverageSize = (oBP.SizeX + oBP.SizeZ) * 0.5
                        if bDebugMessages == true then LOG(sFunctionRef..': iAverageSize='..iAverageSize..'; Is unit underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; Unit speed='..oBP.Physics.MaxSpeed) end
                        if iAverageSize < 1 or (iTimeUntilImpact > math.min(2.5, 0.4 + iAverageSize * 1.5 / oBP.Physics.MaxSpeed) and (iTimeUntilImpact >= 2 or not(EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId)))) then
                            --Are we not underwater?
                            if not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                                --If dealing with an ACU then drastically reduce the dodge time so we can overcharge if we havent recently and have enemies in range and enough power
                                if EntityCategoryContains(categories.COMMAND, oTarget.UnitId) then
                                    if oTarget:IsUnitState('Teleporting') or (oTarget:IsUnitState('Upgrading') and M28UnitInfo.GetUnitHealthPercent(oTarget) >= 0.9 - oTarget:GetWorkProgress()) then
                                        --Dont cancel upgrade/teleport
                                        bCancelDodge = true
                                    --Dont have ACU dodge missiles if it is retreating (since missiles arent homing)
                                    elseif oTarget:IsUnitState('Moving') and GetGameTimeSeconds() - (oTarget[M28ACU.refiTimeLastWantedToRun] or 0) <= 2 and oWeapon.Blueprint.WeaponCategory == 'Missile' and EntityCategoryContains(categories.INDIRECTFIRE - categories.STRUCTURE, oUnit.UnitId) and oTarget[M28Orders.reftiLastOrders][oTarget[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueMove and M28Utilities.GetDistanceBetweenPositions(oTarget[M28Orders.reftiLastOrders][oTarget[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition], oTarget:GetPosition()) >= 5 then
                                        bCancelDodge = true
                                    elseif M28Conditions.CanUnitUseOvercharge(oTarget:GetAIBrain(), oTarget) and (GetGameTimeSeconds() - (oTarget[M28UnitInfo.refiTimeOfLastOverchargeShot] or 0)) > 5 then
                                        --If we have units we can hit then cancel
                                        if oTarget:GetHealth() >= 5000 and (GetGameTimeSeconds() - (oTarget[M28UnitInfo.refiLastWeaponEvent] or 0) <= 2 or M28Utilities.IsTableEmpty(oTarget:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat, oTarget:GetPosition(), oTarget[M28UnitInfo.refiDFRange], 'Enemy')) == false) then
                                            bCancelDodge = true
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will cancel dodge as we can overcharge instead, time since last overcharge='..(GetGameTimeSeconds() - (oTarget[M28UnitInfo.refiTimeOfLastOverchargeShot] or 0))..'; Brain energy stored='..oTarget:GetAIBrain():GetEconomyStored('ENERGY')) end
                                        else
                                            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                                            local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
                                            if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 200 then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Reducing dodge time drastically as have ACU that can overcharge enemies in range but it also wants to dodge a shot; will cancel if damage is very low that are dodging. oWeapon.Blueprint.Damage='..oWeapon.Blueprint.Damage) end
                                                if oWeapon.Blueprint.Damage <= 100 then
                                                    bCancelDodge = true
                                                else
                                                    iMaxTimeToRun = math.min(0.8, iMaxTimeToRun) --(M27 uses 0.9; if set too low then ACU may not actually move)
                                                end
                                            end
                                        end
                                    end
                                elseif EntityCategoryContains(categories.EXPERIMENTAL, oTarget.UnitId) then
                                    --If we are a GC, Monkey or Ythotha that has an enemy experimental nearby but not in range, then cancel dodging as want to get in range to be able to  fire
                                    local oTargetBP = oTarget:GetBlueprint()
                                    if bDebugMessages == true then LOG(sFunctionRef..': Deciding if experimental wants to dodge shot, iDistToTarget='..iDistToTarget..'; Damage='..oWeapon.Blueprint.Damage..'; Experimental size='..math.max(oTargetBP.SizeX, oTargetBP.SizeZ)..'; Time since last weapon event='..GetGameTimeSeconds() - (oTarget[M28UnitInfo.refiLastWeaponEvent] or 0)) end
                                    --Dont dodge at all if we have fired recently and the damage isn't massive
                                    if GetGameTimeSeconds() - (oTarget[M28UnitInfo.refiLastWeaponEvent] or 0) <= 5 and oWeapon.Blueprint.Damage <= 4000 then
                                        bCancelDodge = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': Target is an experimental that has fired recently and the damage isnt massive so we dont want to dodge, weapon damage='..(oWeapon.Blueprint.Damage or 'nil')) end
                                    elseif iDistToTarget <= 90 and math.max(oTargetBP.SizeX, oTargetBP.SizeZ) >= 7 and (GetGameTimeSeconds() - (oTarget[M28UnitInfo.refiLastWeaponEvent] or 0) <= 20 or oWeapon.Blueprint.Damage <= 4000) then --megalith and fatboy
                                        bCancelDodge = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': Megalith or fatboy in size so wont dodge shot') end
                                    else
                                        local tLastOrder = oTarget[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]]
                                        if tLastOrder[M28Orders.refiOrderIssueAttack] and M28UnitInfo.IsUnitValid(tLastOrder[M28Orders.subrefoOrderUnitTarget]) and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental + categories.COMMAND, tLastOrder[M28Orders.subrefoOrderUnitTarget].UnitId) and (not(EntityCategoryContains(M28UnitInfo.refCategoryYthotha, tLastOrder[M28Orders.subrefoOrderUnitTarget].UnitId)) or oWeapon.Blueprint.Damage <= 4000) then
                                            bCancelDodge = true
                                            if bDebugMessages == true then LOG(sFunctionRef..': Target '..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..' was trying to attack an enemy exp or ACU, targets target='..tLastOrder[M28Orders.subrefoOrderUnitTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(tLastOrder[M28Orders.subrefoOrderUnitTarget])..'; so will cancel dodge') end
                                        end
                                    end
                                end

                                if not(bCancelDodge) then
                                    iMaxTimeToRun = math.min(2.5, iMaxTimeToRun)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will try to dodge shot. iTimeUntilImpact='..iTimeUntilImpact..'; iMaxTimeToRun='..iMaxTimeToRun..'; iAverageSize='..iAverageSize) end
                                    if iHoverMaxTimeToRun and EntityCategoryContains(categories.HOVER, oTarget.UnitId) then
                                        DodgeShot(oTarget, oUnit, oWeapon, math.min(math.max(0.95, iTimeUntilImpact), iHoverMaxTimeToRun))
                                    elseif iAverageSize < 1 and iTimeUntilImpact <= 1.1 and oBP.Physics.MaxSpeed >= 3 then
                                        AltDodgeShot(oTarget, oUnit, oWeapon, math.min(iTimeUntilImpact, iMaxTimeToRun))
                                    else
                                        DodgeShot(oTarget, oUnit, oWeapon, math.min(iTimeUntilImpact, iMaxTimeToRun))
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DodgeShot(oTarget, oWeapon, oAttacker, iTimeToDodge)
    --Should have already checked oTarget is a valid unit that has a chance of dodging the shot in time before claling this
    --Gets unit to move at a slightly different angle to its current facing direction for iTimeToDodge
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DodgeShot'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..' owned by brain '..oTarget:GetAIBrain().Nickname..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oTarget))) end

    M28Orders.UpdateRecordedOrders(oTarget)
    local tCurDestination
    local bAttackMove = false
    --ACU special - if ACU wants to run, then ignore hte last order and instead treat it as tyring to run to base
    if oTarget[M28ACU.refiTimeLastWantedToRun] and GetGameTimeSeconds() - (oTarget[M28ACU.refiTimeLastWantedToRun] or -100) <= 5 or (EntityCategoryContains(categories.COMMAND, oTarget.UnitId) and M28UnitInfo.GetUnitHealthPercent(oTarget) <= 0.6) then
        local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oTarget:GetPosition(), true, oTarget:GetAIBrain().M28Team)
        if tLZOrWZTeamData then tCurDestination = {tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][1], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][2], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][3]} end
    elseif EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryIndirect - categories.EXPERIMENTAL, oTarget.UnitId) then
        local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oTarget:GetPosition(), true, oTarget:GetAIBrain().M28Team)
        if tLZOrWZTeamData then tCurDestination = {tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][1], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][2], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][3]} end
    elseif oTarget[M28Orders.refiOrderCount] > 0 then
        local tLastOrder = oTarget[M28Orders.reftiLastOrders][oTarget[M28Orders.refiOrderCount]]
        tCurDestination = tLastOrder[M28Orders.subreftOrderPosition]
        if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAttack or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAggressiveMove or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAggressiveFormMove then
            bAttackMove = true
        end
    end

    local iCurFacingAngle = M28UnitInfo.GetUnitFacingAngle(oTarget)
    local iAngleToDestination
    if tCurDestination then iAngleToDestination = M28Utilities.GetAngleFromAToB(oTarget:GetPosition(), tCurDestination)
    else
        iAngleToDestination = iCurFacingAngle
        tCurDestination = oTarget:GetPosition()
    end

    local oBP = oTarget:GetBlueprint()
    local iSpeed = oBP.Physics.MaxSpeed
    local iDistanceToRun = (iTimeToDodge + (M28Land.iTicksPerLandCycle - 1) / 10) * iSpeed
    local iUnitSize = oBP.SizeX + oBP.SizeZ
    local iAngleAdjust = math.max(15, oBP.Physics.TurnRate * 0.3)
    if iUnitSize >= 2 then
        if iUnitSize >= 4 then iAngleAdjust = iAngleAdjust * 2.5
        else iAngleAdjust = iAngleAdjust * 1.75
        end
        if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oTarget.UnitId) then
            iAngleAdjust = math.min(iAngleAdjust, 30)
        end
    end
    --Non-experimental skirmishers - try to move at an adjustment to the angle to the destination rather htan the unit facing direction so less likely to move into range of enemy
    if bDebugMessages == true then LOG(sFUnctionRef..': Considering if have skirmisher or ACU; ACU time since last wanted to retreat (if this was an ACU)='..GetGameTimeSeconds() - (oTarget[M28ACU.refiTimeLastWantedToRun] or 0)) end
    if EntityCategoryContains(M28UnitInfo.refCategorySkirmisher - categories.EXPERIMENTAL, oTarget.UnitId) or (EntityCategoryContains(categories.COMMAND, oTarget.UnitId) and oTarget[M28ACU.refiTimeLastWantedToRun] and GetGameTimeSeconds() - oTarget[M28ACU.refiTimeLastWantedToRun] <= 3) then
        local iAngleDifToDestination = M28Utilities.GetAngleDifference(iCurFacingAngle, iAngleToDestination)
        if bDebugMessages == true then LOG(sFunctionRef..': iAngleDifToDestination='..iAngleDifToDestination..'; iAngleAdjust='..iAngleAdjust) end
        if iAngleDifToDestination >= math.max(iAngleAdjust, 45) then
            if bDebugMessages == true then LOG(sFunctionRef..': Increasing angle adjust as have a skirmisher or retreating ACU, iAngleAdjust before increase='..iAngleAdjust..'; iAngleDifToDestination='..iAngleDifToDestination) end
            iAngleAdjust = math.max(iAngleAdjust, iAngleDifToDestination * 0.7)
        end
    end

    if M28Utilities.GetAngleDifference(iCurFacingAngle + iAngleAdjust, iAngleToDestination) > M28Utilities.GetAngleDifference(iCurFacingAngle - iAngleAdjust, iAngleToDestination) then
        iAngleAdjust = iAngleAdjust * -1
    end

    local tTempDestination = M28Utilities.MoveInDirection(oTarget:GetPosition(), iCurFacingAngle + iAngleAdjust, iDistanceToRun, true, false, true)
    if bDebugMessages == true then LOG(sFunctionRef..': oTarget (ie unit that is dodging)='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; clearing current orders which have a possible destination of '..repru(tCurDestination)..'; and giving an order to move to '..repru(tTempDestination)..'; Dist from our position to temp position='..M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), tTempDestination)..'; iAngleAdjust='..iAngleAdjust..'; Unit size='..iUnitSize..'; iTimeToDodge='..iTimeToDodge) end
    --M28Orders.IssueTrackedClearCommands(oTarget)
    TrackTemporaryUnitMicro(oTarget, iTimeToDodge)
    M28Orders.IssueTrackedMove(oTarget, tTempDestination, 0.25, false, 'MiDod1', true)
    --Also send an order to go to the destination that we had before
    if bAttackMove then
        M28Orders.IssueTrackedAttackMove(oTarget, tCurDestination, 0.25, true, 'MiDod2', true)
    else
        --M28Orders.IssueTrackedMove(oTarget, tCurDestination, 0.25, true, 'MiDod3', true)
        --Disabled for v89 given new 'get goal' position and increase in the micro dodge distance
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AltDodgeShot(oTarget, oWeapon, oAttacker, iTimeToDodge)
    --Intended for units like LABs, making use of new logic to change existing move order
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AltDodgeShot'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oTarget))) end

    M28Orders.UpdateRecordedOrders(oTarget)
    local iCurFacingAngle = M28UnitInfo.GetUnitFacingAngle(oTarget)
    local iAngleToMove = iCurFacingAngle + 120
    if iAngleToMove > 360 then iAngleToMove = iAngleToMove - 360 end
    local oBP = oTarget:GetBlueprint()
    local iSpeed = oBP.Physics.MaxSpeed
    local iDistanceToRun = iTimeToDodge * iSpeed
    local tTempDestination = M28Utilities.MoveInDirection(oTarget:GetPosition(), iAngleToMove, iDistanceToRun, true, false, true)
    TrackTemporaryUnitMicro(oTarget, iTimeToDodge)
    M28Orders.IssueTrackedMove(oTarget, tTempDestination, 0.1, false, 'MiAltDod1', true)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TrackTemporaryUnitMicro(oUnit, iSecondsActiveFor, sAdditionalTrackingVar, bLowerPriorityMicro)
    --Where we are doing all actions upfront can call this to enable micro and then turn the flag off after set period of time
    --Note that air logic currently doesnt make use of this
    --bLowerPriorityMicro - if true then this will be ignored by 'higher priority micro'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TrackTemporaryUnitMicro'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    oUnit[M28UnitInfo.refbSpecialMicroActive] = true
    if bLowerPriorityMicro then oUnit[M28UnitInfo.refbLowerPriorityMicroActive] = true
    else
        if oUnit[M28UnitInfo.refbLowerPriorityMicroActive] then oUnit[M28UnitInfo.refbLowerPriorityMicroActive] = nil end
    end
    oUnit[M28UnitInfo.refiGameTimeMicroStarted] = GetGameTimeSeconds()
    oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] = GetGameTimeSeconds() + iSecondsActiveFor
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[M28UnitInfo.refbSpecialMicroActive]='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive] or false)..'; oUnit[M28UnitInfo.refiGameTimeMicroStarted]='..oUnit[M28UnitInfo.refiGameTimeMicroStarted]..'; oUnit[M28UnitInfo.refiGameTimeToResetMicroActive]='..oUnit[M28UnitInfo.refiGameTimeToResetMicroActive]..'; iSecondsActiveFor='..iSecondsActiveFor) end
    ForkThread(ForkedResetMicroFlag, oUnit, iSecondsActiveFor - 0.01, sAdditionalTrackingVar)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ForkedResetMicroFlag(oUnit, iTimeToWait, sAdditionalTrackingVar, bCalledFromResetChecker)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ForkedResetMicroFlag'


    oUnit[M28UnitInfo.refbSpecialMicroActive] = true --As if we are calling an action for the micro that clears commands, then that will reset the micro flag
    WaitSeconds(iTimeToWait)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28UnitInfo.IsUnitValid(oUnit) then
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if micro flag can be reset to false for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at time='..GetGameTimeSeconds()..'; Time to reset flag='..(oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] or 'nil')) end
        if GetGameTimeSeconds() + 0.02 > oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] or not(oUnit[M28UnitInfo.refbSpecialMicroActive]) then
            if bDebugMessages == true then LOG(sFunctionRef..': Have reset flag') end
            oUnit[refbMicroResetChecker] = nil
            oUnit[M28UnitInfo.refbSpecialMicroActive] = false
            oUnit[M28UnitInfo.refbLowerPriorityMicroActive] = nil
            if sAdditionalTrackingVar then
                oUnit[sAdditionalTrackingVar] = false
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Will try waiting one more cycle to see if we need to reset the flag unless already got an active reset checker, MicroResetChecker='..tostring(oUnit[refbMicroResetChecker] or false)) end
            if not(oUnit[refbMicroResetChecker]) or bCalledFromResetChecker then
                oUnit[refbMicroResetChecker] = true
                ForkThread(ForkedResetMicroFlag,oUnit, math.max(oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] - GetGameTimeSeconds() - 0.01, 0.2), sAdditionalTrackingVar, true)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ForkedMoveInCircleOld(oUnit, iTimeToRun, bDontTreatAsMicroAction, bDontClearCommandsFirst, iCircleSizeOverride, iTickWaitOverride)
    --More intensive version of MoveAwayFromTargetTemporarily, intended e.g. for ACUs
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ForkedMoveInCircle'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local refbActiveCircleMicro = 'M28MicroActiveCircleMicro'

    if bDebugMessages == true then LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..'; Unit has active circle micro='..tostring(oUnit[refbActiveCircleMicro] or false)) end
    if not(oUnit[refbActiveCircleMicro]) then

        --KEY CONFIG SETTINGS: (these will work sometimes but not always against an aeon strat)
        local iInitialAngleAdj = 15
        local iInitialDistanceAdj = -1
        local iDistanceAwayToMove = (iCircleSizeOverride or 2)
        local iAngleMaxSingleAdj = 45
        local iTicksBetweenOrders = (iTickWaitOverride or 4)

        if iDistanceAwayToMove > oUnit:GetBlueprint().Physics.MaxSpeed * 1.5 then
            iAngleMaxSingleAdj = math.max(25, iAngleMaxSingleAdj * 2.5 / iDistanceAwayToMove)
        end



        local iStartTime = GetGameTimeSeconds()
        oUnit[M28UnitInfo.refiGameTimeMicroStarted] = iStartTime
        local iLoopCount = 0
        local iMaxLoop = iTimeToRun * 10 + 1
        --Distance from point A to point B will be much less than distanceaway to move, since that is the distance from the centre (radius) rather than the distance between 1 points on the circle edge; for simplicity will assume that distance is 0.25 of the distance from the centre
        if bDontTreatAsMicroAction then iMaxLoop = math.ceil(iTimeToRun / (iDistanceAwayToMove / oUnit:GetBlueprint().Physics.MaxSpeed)) * 4 end
        local tUnitStartPosition = oUnit:GetPosition()

        local iCurFacingDirection = M28UnitInfo.GetUnitFacingAngle(oUnit)
        local iAngleAdjFactor = 1

        local tTempLocationToMove

        local bRecentMicro = false
        local iRecentMicroThreshold = 1
        local iGameTime = GetGameTimeSeconds()
        if oUnit[M28UnitInfo.refbSpecialMicroActive] and iGameTime - oUnit[M28UnitInfo.refiGameTimeMicroStarted] < iRecentMicroThreshold then bRecentMicro = true end
        if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop for move commands for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTimeToRun='..iTimeToRun..'; iStartTime='..iStartTime..'; iCurFacingDirection='..iCurFacingDirection..'; tUnitStartPosition='..repru(tUnitStartPosition)..'; bRecentMicro='..tostring((bRecentMicro or false))..'; bDontClearCommandsFirst='..tostring(bDontClearCommandsFirst or false)..'; oUnit[M28UnitInfo.refbSpecialMicroActive]='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive])..'; oUnit[M28UnitInfo.refiGameTimeMicroStarted]='..(oUnit[M28UnitInfo.refiGameTimeMicroStarted] or 'nil')..'; GameTime='..iGameTime..'; Dif='..iGameTime-(oUnit[M28UnitInfo.refiGameTimeMicroStarted] or 0)..'; bDontTreatAsMicroAction='..tostring((bDontTreatAsMicroAction or false))) end
        if bRecentMicro == false and not(bDontClearCommandsFirst) then
            M28Orders.IssueTrackedClearCommands(oUnit)
            if bDebugMessages == true then LOG(sFunctionRef..': Issued clear commands order to the unit') end
        end
        if not(bDontTreatAsMicroAction) then
            TrackTemporaryUnitMicro(oUnit, iTimeToRun, refbActiveCircleMicro)
            if bDebugMessages == true then LOG(sFunctionRef..': Will temporarily track the unit micro. iTimeToRun='..(iTimeToRun or 'nil')) end
        else
            TrackTemporaryUnitMicro(oUnit, iTimeToRun)
        end

        local iTempAngleDirectionToMove = iCurFacingDirection + iInitialAngleAdj * iAngleAdjFactor
        local iTempDistanceAwayToMove
        local bTimeToStop = false
        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; refbSpecialMicroActive='..tostring((oUnit[M28UnitInfo.refbSpecialMicroActive] or false))..'; iMaxLoop='..iMaxLoop) end
        while bTimeToStop == false do
            iLoopCount = iLoopCount + 1
            if iLoopCount > iMaxLoop then break
            elseif M28UnitInfo.IsUnitValid(oUnit) == false then break end --No longer give error message as may be calling this for intel scouts now

            iTempAngleDirectionToMove = iTempAngleDirectionToMove + iAngleMaxSingleAdj * iAngleAdjFactor
            if iTempAngleDirectionToMove > 360 then iTempAngleDirectionToMove = iTempAngleDirectionToMove - 360 end
            --end
            iTempDistanceAwayToMove = iDistanceAwayToMove
            if iLoopCount == 1 then iTempDistanceAwayToMove = iDistanceAwayToMove + iInitialDistanceAdj end
            tTempLocationToMove = M28Utilities.MoveInDirection(tUnitStartPosition, iTempAngleDirectionToMove, iTempDistanceAwayToMove, true, false, true)
            M28Orders.IssueTrackedMove(oUnit, tTempLocationToMove, 0.25, true, 'MiCirc1', true)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(iTicksBetweenOrders)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if not(bDontTreatAsMicroAction) and not((oUnit[M28UnitInfo.refiGameTimeMicroStarted] == iStartTime and GetGameTimeSeconds() - iStartTime < iTimeToRun)) then bTimeToStop = true end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ForkedMoveInCircle(oUnit, iTimeToRun, bDontTreatAsMicroAction, bDontClearCommandsFirst, iCircleSizeOverride, iTickWaitOverride)
    --More intensive version of MoveAwayFromTargetTemporarily, intended e.g. for ACUs
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ForkedMoveInCircle'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local refbActiveCircleMicro = 'M28MicroActiveCircleMicro'

    if bDebugMessages == true then LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..'; Unit has active circle micro='..tostring(oUnit[refbActiveCircleMicro] or false)) end
    if not(oUnit[refbActiveCircleMicro]) then

        --KEY CONFIG SETTINGS: (these will work sometimes but not always against an aeon strat)
        local iInitialAngleAdj = 15
        local iInitialDistanceAdj = -1
        local iDistanceAwayToMove = (iCircleSizeOverride or 2)
        local iAngleMaxSingleAdj = 120
        local iTicksBetweenOrders = (iTickWaitOverride or 1) --prev 4

        if iDistanceAwayToMove > oUnit:GetBlueprint().Physics.MaxSpeed * 1.5 then
            iAngleMaxSingleAdj = math.max(25, iAngleMaxSingleAdj * 2.5 / iDistanceAwayToMove)
        end



        local iStartTime = GetGameTimeSeconds()
        oUnit[M28UnitInfo.refiGameTimeMicroStarted] = iStartTime
        local iLoopCount = 0
        local iMaxLoop = iTimeToRun * 10 + 1
        --Distance from point A to point B will be much less than distanceaway to move, since that is the distance from the centre (radius) rather than the distance between 1 points on the circle edge; for simplicity will assume that distance is 0.25 of the distance from the centre
        if bDontTreatAsMicroAction then iMaxLoop = math.ceil(iTimeToRun / (iDistanceAwayToMove / oUnit:GetBlueprint().Physics.MaxSpeed)) * 4 end
        local tUnitStartPosition = oUnit:GetPosition()

        local iCurFacingDirection = M28UnitInfo.GetUnitFacingAngle(oUnit)


        local iAngleAdjFactor = 1

        local tTempLocationToMove

        local bRecentMicro = false
        local iRecentMicroThreshold = 1
        local iGameTime = GetGameTimeSeconds()
        if oUnit[M28UnitInfo.refbSpecialMicroActive] and iGameTime - oUnit[M28UnitInfo.refiGameTimeMicroStarted] < iRecentMicroThreshold then bRecentMicro = true end
        if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop for move commands for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTimeToRun='..iTimeToRun..'; iStartTime='..iStartTime..'; iCurFacingDirection='..iCurFacingDirection..'; tUnitStartPosition='..repru(tUnitStartPosition)..'; bRecentMicro='..tostring((bRecentMicro or false))..'; bDontClearCommandsFirst='..tostring(bDontClearCommandsFirst or false)..'; oUnit[M28UnitInfo.refbSpecialMicroActive]='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive])..'; oUnit[M28UnitInfo.refiGameTimeMicroStarted]='..(oUnit[M28UnitInfo.refiGameTimeMicroStarted] or 'nil')..'; GameTime='..iGameTime..'; Dif='..iGameTime-(oUnit[M28UnitInfo.refiGameTimeMicroStarted] or 0)..'; bDontTreatAsMicroAction='..tostring((bDontTreatAsMicroAction or false))) end
        if bRecentMicro == false and not(bDontClearCommandsFirst) then
            M28Orders.IssueTrackedClearCommands(oUnit)
            if bDebugMessages == true then LOG(sFunctionRef..': Issued clear commands order to the unit') end
        end
        if not(bDontTreatAsMicroAction) then
            TrackTemporaryUnitMicro(oUnit, iTimeToRun, refbActiveCircleMicro)
            if bDebugMessages == true then LOG(sFunctionRef..': Will temporarily track the unit micro. iTimeToRun='..(iTimeToRun or 'nil')) end
        else
            TrackTemporaryUnitMicro(oUnit, iTimeToRun)
        end

        local bTimeToStop = false
        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; refbSpecialMicroActive='..tostring((oUnit[M28UnitInfo.refbSpecialMicroActive] or false))..'; iMaxLoop='..iMaxLoop) end
        while bTimeToStop == false do
            iLoopCount = iLoopCount + 1
            if iLoopCount > iMaxLoop then break
            elseif M28UnitInfo.IsUnitValid(oUnit) == false then break end --No longer give error message as may be calling this for intel scouts now


            tTempLocationToMove = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28UnitInfo.GetUnitFacingAngle(oUnit) + iAngleMaxSingleAdj, iDistanceAwayToMove, true, false, true)
            M28Orders.IssueTrackedMove(oUnit, tTempLocationToMove, 0.25, false, 'MiCirc1', true)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(iTicksBetweenOrders)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if not(bDontTreatAsMicroAction) and not((oUnit[M28UnitInfo.refiGameTimeMicroStarted] == iStartTime and GetGameTimeSeconds() - iStartTime < iTimeToRun)) then bTimeToStop = true end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MoveInCircleTemporarily(oUnit, iTimeToRun, bDontTreatAsMicroAction, bDontClearCommandsFirst, iCircleSizeOverride, iTickWaitOverride)
    ForkThread(ForkedMoveInCircle, oUnit, iTimeToRun, bDontTreatAsMicroAction, bDontClearCommandsFirst, iCircleSizeOverride, iTickWaitOverride)
end

function GetOverchargeTarget(tLZData, aiBrain, oUnitWithOvercharge, bOnlyConsiderEnemiesInRange)
    --should have already confirmed overcharge action is available using CanUnitUseOvercharge
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetOverchargeTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
    local oOverchargeTarget
    if not(oUnitWithOvercharge[M28UnitInfo.refbEasyBrain]) then
        --Do we have positive energy income? If not, then only overcharge if ACU is low on health as an emergency
        local reftiAngleFromACUToUnit = 'M28AngleFromACUToUnit'
        local reftiDistFromACUToUnit = 'M28DistFromACUToUnit'
        local toStructuresAndACU

        --Subfunction
        function IsBuildingOrACUBlockingShot(oFiringUnit, oTargetUnit)
            --Assumes have already been through tBlockingUnits and set their angle to the firing unit, so we just need to compare to firing unit
            if bDebugMessages == true then LOG(sFunctionRef..': Will see if any buildings or ACU are blocking the shot; if dont get log saying result was false then means was true') end
            if M28Utilities.IsTableEmpty(toStructuresAndACU) == false then
                local iAngleToTargetUnit = M28Utilities.GetAngleFromAToB(oFiringUnit:GetPosition(), oTargetUnit:GetPosition())
                local iDistToTargetUnit = M28Utilities.GetDistanceBetweenPositions(oFiringUnit:GetPosition(), oTargetUnit:GetPosition())
                local iCurAngleDif
                if bDebugMessages == true then LOG(sFunctionRef..': iAngleToTargetUnit='..iAngleToTargetUnit..'; iDistToTargetUnit='..iDistToTargetUnit) end
                for iUnit, oUnit in toStructuresAndACU do
                    if not(oUnit == oTargetUnit) and iDistToTargetUnit > oUnit[reftiDistFromACUToUnit][aiBrain:GetArmyIndex()] then
                        iCurAngleDif = iAngleToTargetUnit - oUnit[reftiAngleFromACUToUnit][aiBrain:GetArmyIndex()]
                        if iCurAngleDif < 0 then iCurAngleDif = iCurAngleDif + 360 end
                        if bDebugMessages == true then LOG(sFunctionRef..': Checking if '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' will block a shot from the ACU to the target '..oTargetUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTargetUnit)..'; iCurAngleDif='..iCurAngleDif..'; 180 / iDistToTargetUnit='..180 / iDistToTargetUnit..'; oUnit[reftiAngleFromACUToUnit][aiBrain:GetArmyIndex()]='..oUnit[reftiAngleFromACUToUnit][aiBrain:GetArmyIndex()]..'; oUnit[reftiDistFromACUToUnit]='..oUnit[reftiDistFromACUToUnit][aiBrain:GetArmyIndex()]..'; angle from ACU to unit='..oUnit[reftiAngleFromACUToUnit][aiBrain:GetArmyIndex()]) end
                        if iCurAngleDif <= math.max(8, 180 / iDistToTargetUnit) then
                            return true
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': End of code, will return false') end
            return false
        end

        --Subfunction
        function WillShotHit(oFiringUnit, oTargetUnit)
            --Check for units in a transport
            if oTargetUnit:IsUnitState('Attached') or M28Logic.IsShotBlocked(oFiringUnit, oTargetUnit) or IsBuildingOrACUBlockingShot(oFiringUnit, oTargetUnit) then
                if bDebugMessages == true then LOG(sFunctionRef..': oTargetUnit='..oTargetUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTargetUnit)..'; shot is blocked so wont hit. IsShotBlocked='..tostring(M28Logic.IsShotBlocked(oFiringUnit, oTargetUnit))) end
                return false
            else return true
            end
        end

        local tUnitPosition = oUnitWithOvercharge:GetPosition()
        local iACURange = oUnitWithOvercharge[M28UnitInfo.refiDFRange]
        if (iACURange or 0) > 0 then
            local iOverchargeArea = 2.5

            --First locate where any blocking units are - will assume non-wall structures larger than a T1 pgen will block the shot, and ACUs will block
            local iMaxSearchDistance
            if bOnlyConsiderEnemiesInRange then iMaxSearchDistance = iACURange - 1
            else iMaxSearchDistance = 50
            end
            toStructuresAndACU = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure - categories.SIZE4 + categories.COMMAND, tUnitPosition, iMaxSearchDistance, 'Enemy')

            if bDebugMessages == true then LOG(sFunctionRef..': First locating blocking units; is table empty='..tostring(M28Utilities.IsTableEmpty(toStructuresAndACU))..'; iACURange='..iACURange..'; iOverchargeArea='..iOverchargeArea) end
            if M28Utilities.IsTableEmpty(toStructuresAndACU) == false then
                for iUnit, oUnit in toStructuresAndACU do
                    if not(oUnit[reftiAngleFromACUToUnit]) then
                        oUnit[reftiAngleFromACUToUnit] = {}
                        oUnit[reftiDistFromACUToUnit] = {}
                    end
                    oUnit[reftiAngleFromACUToUnit][aiBrain:GetArmyIndex()] = M28Utilities.GetAngleFromAToB(tUnitPosition, oUnit:GetPosition())
                    oUnit[reftiDistFromACUToUnit][aiBrain:GetArmyIndex()] = M28Utilities.GetDistanceBetweenPositions(tUnitPosition, oUnit:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': Angle from oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to our ACU='..repru(oUnit[reftiAngleFromACUToUnit])..'; distance='..repru(oUnit[reftiDistFromACUToUnit])) end

                    --If enemy ACU is nearby and low health then target as top priority
                    if oUnit[reftiDistFromACUToUnit][aiBrain:GetArmyIndex()] < (iACURange - 2) and EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and oUnit:GetHealth() < 1400 then
                        oOverchargeTarget = oUnit
                    end
                end
            end


            if not(oOverchargeTarget) then
                --Cycle through every land combat non-ACU, and/or surface naval, unit within firing range to see if can find one that reduces the damage the most, or failing that does the most mass damage; will include all navy on the assumption isshotblocked will trigger if shot will go underwater (as otherwise we might ignore sera T2 destroyers)
                local tEnemyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand - categories.COMMAND + M28UnitInfo.refCategoryPD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryAllNavy, tUnitPosition, iACURange, 'Enemy')

                local iMostMassDamage = 0
                local oMostMassDamage, iKillsExpected
                local iMaxOverchargeDamage = (aiBrain:GetEconomyStored('ENERGY') * 0.9) * 0.25
                local iCurDamageDealt, iCurKillsExpected
                if bDebugMessages == true then LOG(sFunctionRef..': Will consider enemy mobile units and PD within 2 of the ACU max range; is the table empty='..tostring(M28Utilities.IsTableEmpty(tEnemyUnits))) end
                if M28Utilities.IsTableEmpty(tEnemyUnits) == false then
                    for iUnit, oUnit in tEnemyUnits do
                        --Reduce range to consider if unit is moving and isn't moving towards ACU
                        if not(oUnit:IsUnitState('Moving')) or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnitWithOvercharge:GetPosition()) < iACURange - 1 or M28Utilities.GetAngleDifference(M28UnitInfo.GetUnitFacingAngle(oUnit), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnitWithOvercharge:GetPosition())) <= 25 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if shot will hit for ACU '..(oUnitWithOvercharge.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitWithOvercharge) or 'nil')..' to hit oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' unit position='..repru(oUnit:GetPosition())..'; Is unit underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; Will shot hit='..tostring(WillShotHit(oUnitWithOvercharge, oUnit))) end
                            if WillShotHit(oUnitWithOvercharge, oUnit) then
                                iCurDamageDealt, iCurKillsExpected = M28Logic.GetDamageFromOvercharge(aiBrain, oUnit, iOverchargeArea, iMaxOverchargeDamage)
                                if bDebugMessages == true then LOG(sFunctionRef..': Shot will hit enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; damage result='..iCurDamageDealt) end
                                if iCurDamageDealt > iMostMassDamage then
                                    iMostMassDamage = iCurDamageDealt
                                    oMostMassDamage = oUnit
                                    iKillsExpected = iCurKillsExpected

                                end
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished searching through enemy mobile untis and PD in range, iMostMassDamage='..iMostMassDamage..'; iKillsExpected='..(iKillsExpected or 0)..'; Energy stored %='..aiBrain:GetEconomyStoredRatio('ENERGY')..'; E stored='..aiBrain:GetEconomyStored('ENERGY')) end

                --if iMostMobileCombatMassDamage >= 80 then
                --    oOverchargeTarget = oMostCombatMassDamage
                if iMostMassDamage >= 200 or iKillsExpected >= 3 or (iKillsExpected >= 1 and iMostMassDamage >= 100) or (iMostMassDamage >= 60 and aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.9 and (aiBrain:GetEconomyStored('ENERGY') >= 10000 or (aiBrain[M28Economy.refiNetEnergyBaseIncome] >= 1 and aiBrain:GetEconomyStored('ENERGY') >= 8000))) then --e.g. striker is 56 mass; lobo is 36
                    oOverchargeTarget = oMostMassDamage
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a mobile or PD unit in range that will do enough damage to, oOverchargeTarget='..oOverchargeTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOverchargeTarget)) end
                else
                    --Check we aren't running before considering whether to target walls or T2 PDs
                    if GetGameTimeSeconds() - (oUnitWithOvercharge[M28ACU.refiTimeLastWantedToRun] or -30) >= 30 then
                        --No decent combat targets; Check for lots of walls that might be blocking our path (dont reduce ACU range given these are structures)
                        --Only consider overcharging walls if no enemies within our combat range + 3
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPlayerWallSegments]) == false and table.getn(tLZData[M28Map.subrefLZPlayerWallSegments]) >= 9 then
                            local tAllEnemies = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryNavalSurface, tUnitPosition, math.min(iMaxSearchDistance, iACURange + 3), 'Enemy')
                            if M28Utilities.IsTableEmpty(tAllEnemies) then
                                tEnemyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryWall, tUnitPosition, iACURange, 'Enemy')
                                if bDebugMessages == true then LOG(sFunctionRef..': iMostMassDamage='..iMostMassDamage..'; so will check for walls and other structure targets; is table of wall units empty='..tostring(M28Utilities.IsTableEmpty(tEnemyUnits))) end
                                if M28Utilities.IsTableEmpty(tEnemyUnits) == false and table.getn(tEnemyUnits) >= 5 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have at least 5 wall units in range, so potential blockage; size='..table.getn(tEnemyUnits)) end
                                    local bSuspectedPathBlock = false
                                    --If more than 10 then assume blocking our path

                                    if table.getn(tEnemyUnits) >= 10 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': At least 10 wall units so assuming a blockage') end
                                        bSuspectedPathBlock = true
                                    else
                                        local tFirstWall = tEnemyUnits[1]:GetPosition()
                                        for iWall, oWall in tEnemyUnits do
                                            if iWall > 1 then
                                                if M28Utilities.GetDistanceBetweenPositions(oWall:GetPosition(), tFirstWall) >= 4 then
                                                    bSuspectedPathBlock = true
                                                    break
                                                end
                                            end
                                        end
                                    end
                                    if bSuspectedPathBlock then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Think enemy has walls in a line so will overcharge them unless they are all closer to our base than us') end
                                        iMostMassDamage = 0
                                        oMostMassDamage = nil
                                        bSuspectedPathBlock = false

                                        local iOurDistToBase = M28Utilities.GetDistanceBetweenPositions(tUnitPosition, M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()])
                                        local iWallDistToBase
                                        for iWall, oUnit in tEnemyUnits do
                                            if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()]) <= iOurDistToBase + 4 then
                                                bSuspectedPathBlock = true
                                                break
                                            end
                                        end
                                        if bSuspectedPathBlock then
                                            for iWall, oUnit in tEnemyUnits do
                                                if WillShotHit(oUnitWithOvercharge, oUnit) then
                                                    iCurDamageDealt = M28Logic.GetDamageFromOvercharge(aiBrain, oUnit, iOverchargeArea, iMaxOverchargeDamage, true)
                                                    if iCurDamageDealt > iMostMassDamage then
                                                        iMostMassDamage = iCurDamageDealt
                                                        oMostMassDamage = oUnit
                                                    end
                                                end
                                            end
                                            if oMostMassDamage then oOverchargeTarget = oMostMassDamage end
                                        elseif bDebugMessages == true then LOG(sFunctionRef..': Walls are all closer to our base than we are so probably not blocking us')
                                        end
                                    elseif bDebugMessages == true then LOG(sFunctionRef..': Dont think the walls are in a line so wont try and OC')
                                    end
                                end
                            end
                        end
                        if not(oOverchargeTarget) then
                            --Check further away incase enemy has T2 PD that can see us
                            if bDebugMessages == true then LOG(sFunctionRef..': Checking if any T2 PD further away') end
                            tEnemyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryT2PlusPD, tUnitPosition, iMaxSearchDistance, 'Enemy')
                            if M28Utilities.IsTableEmpty(tEnemyUnits) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have enemy T2 defence that can hit us but is out of our range - considering if OC it will bring us in range of T1 PD, and/or if shot is blocked, and/or if the T2PD cant even see us') end
                                local tNearbyT1PD
                                local iNearestT1PD = 10000
                                local iCurDistance
                                if 50 - iACURange > 0 then tNearbyT1PD = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryPD * categories.TECH1, tUnitPosition, 50 - iACURange, 'Enemy') end
                                if M28Utilities.IsTableEmpty(tNearbyT1PD) == false then
                                    for iT1PD, oT1PD in tNearbyT1PD do
                                        iCurDistance = M28Utilities.GetDistanceBetweenPositions(oT1PD:GetPosition(), tUnitPosition)
                                        if iCurDistance < iNearestT1PD then iNearestT1PD = iCurDistance end
                                    end
                                end

                                for iUnit, oEnemyT2PD in tEnemyUnits do
                                    --Can we get in range of the T2 PD without getting in range of the T1 PD? (approximates just based on distances rather than considering the likely path to take)
                                    if M28Utilities.GetDistanceBetweenPositions(oEnemyT2PD:GetPosition(), tUnitPosition) - iACURange + 2 < iNearestT1PD then
                                        if M28Logic.IsShotBlocked(oUnitWithOvercharge, oEnemyT2PD) == false then
                                            --Can the T2 PD see us?
                                            if M28UnitInfo.CanSeeUnit(oEnemyT2PD:GetAIBrain(), oUnitWithOvercharge) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Setting target to T2 PD') end
                                                oOverchargeTarget = oEnemyT2PD
                                                break
                                            else
                                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy T2 PDs owner can see our ACU') end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        if not(oOverchargeTarget) then
                            --Consider all structures (can do ACU max range since before when structures were considered we were looking at reduced range)
                            tEnemyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure, tUnitPosition, iACURange, 'Enemy')
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering all enemy structures within range of ACU; is table empty='..tostring(M28Utilities.IsTableEmpty(tEnemyUnits))) end
                            --local iMostMobileCombatMassDamage = 0
                            --local oMostCombatMassDamage
                            if M28Utilities.IsTableEmpty(tEnemyUnits) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering other enemy structures in range; iMostMassDamage before looking='..iMostMassDamage) end
                                for iUnit, oUnit in tEnemyUnits do
                                    if WillShotHit(oUnitWithOvercharge, oUnit) then
                                        iCurDamageDealt, iCurKillsExpected = M28Logic.GetDamageFromOvercharge(aiBrain, oUnit, iOverchargeArea, iMaxOverchargeDamage)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Shot will hit enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; damage result='..iCurDamageDealt) end
                                        if iCurDamageDealt > iMostMassDamage then
                                            iMostMassDamage = iCurDamageDealt
                                            oMostMassDamage = oUnit
                                            iKillsExpected = iCurKillsExpected
                                        end
                                    end
                                end
                            end
                            if iMostMassDamage >= 110 then
                                oOverchargeTarget = oMostMassDamage
                            end
                        end
                    end
                end
            end
        end
        if oOverchargeTarget == nil then
            if bDebugMessages == true then LOG(sFunctionRef..': No OC targets found') end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Overcharge target='..oOverchargeTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOverchargeTarget)) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oOverchargeTarget
end

function TurnAirUnitAndMoveToTarget(oBomber, tDirectionToMoveTo, iMaxAcceptableAngleDif, iOptionalSecondsToMoveAtEndIfFarFromTarget)
    --Based on hoverbomb logic - may give unexpected results if not using with T3 bombers
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TurnAirUnitAndMoveToTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oBomber='..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; GameTime='..GetGameTimeSeconds()) end
    if M28UnitInfo.IsUnitValid(oBomber) then
        local bContinue = true
        if M28Utilities.IsTableEmpty(tDirectionToMoveTo) then
            if M28Map.bIsCampaignMap and ((ScenarioInfo.OpEnded and GetGameTimeSeconds() <= 120) or (oBomber:GetAIBrain().HostileCampaignAI and tonumber(ScenarioInfo.Options.CmpAIDelay) > GetGameTimeSeconds())) then
                bContinue = false
            else
                --Set direction to move to to the start position
                tDirectionToMoveTo = M28Map.PlayerStartPoints[oBomber:GetAIBrain():GetArmyIndex()]
            end
        end
        if bContinue then
            local iStartTime = GetGameTimeSeconds()
            --local iAngleToTarget

            --Config:
            local iTicksBetweenOrders = 5
            local iDistanceAwayToMove = 10
            local iAngleAdjust = 50


            --Other variables:
            local iActualAngleToUse
            local iCurAngleDif
            local iAngleAdjustToUse
            local iFacingDirection
            local iAngleToTarget

            local iCurTick = 0
            local bTriedMovingForwardsAndTurning = false
            local iDistToTarget
            local tTempTarget

            local iMaxMicroTime = 5 --will micro for up to 5 seconds
            if EntityCategoryContains(categories.EXPERIMENTAL, oBomber.UnitId) then iMaxMicroTime = 10 end



            --Clear trackers so we dont think we're targeting anything - commented out as this is called via the clearairunitassignmenttracker so causes issues
            --M27AirOverseer.ClearAirUnitAssignmentTrackers(aiBrain, oBomber, true)
            TrackTemporaryUnitMicro(oBomber, 60) --60s is redundancy



            while GetGameTimeSeconds() - iStartTime < iMaxMicroTime do
                iCurTick = iCurTick + 1

                iFacingDirection = M28UnitInfo.GetUnitFacingAngle(oBomber)
                iAngleToTarget = M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), tDirectionToMoveTo)
                iCurAngleDif = iFacingDirection - iAngleToTarget
                iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oBomber:GetPosition(), tDirectionToMoveTo)
                --e.g. if bomber is facing 350 degrees, and the target is at 10 degrees, then it means there's only a dif of 20 degrees, but we want the bomber to go 350+50, rather than 350-50.  Facing - Angle would result in a positive value
                --if instead bomber was facing 10 degrees, and the target was 30 degrees, then would get -20 as the result, and so want to also increase
                --the effect of the below is that when bomber is facing 350 degrees and target 10 degrees, it will treat the difference as being 350 - 10 - 360 = -20, and want the bomber to go 350+50; if insteadbomber 10 and target 30, then dif = -20 and no adjustment made
                if math.abs(iCurAngleDif) > 180 then
                    if iCurAngleDif > 180 then
                        --iFacingDirection is too high so decrease the angle difference
                        iCurAngleDif = iCurAngleDif - 360
                    else --Curangledif must be < -180, so angletotarget is too high
                        iCurAngleDif = iCurAngleDif + 360
                    end
                end


                if iCurAngleDif < 0 then
                    iAngleAdjustToUse = iAngleAdjust
                else iAngleAdjustToUse = -iAngleAdjust
                end

                --Are we close enough to the direction wanted?
                iCurAngleDif = math.abs(iCurAngleDif)
                if iCurAngleDif <= (iMaxAcceptableAngleDif or 15) then
                    --Are close enough in angle so can stop the micro
                    break
                else
                    if iCurTick == 1 then
                        iActualAngleToUse = iFacingDirection + iAngleAdjustToUse
                        tTempTarget = M28Utilities.MoveInDirection(oBomber:GetPosition(), iActualAngleToUse, iDistanceAwayToMove, true, false, true)
                        M28Orders.IssueTrackedMove(oBomber, tTempTarget, 0, false, 'BMicrM', true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Just issued move order, iFacingDirection='..iFacingDirection..'; iCurAngleDif='..iCurAngleDif..'; iAngleAdjustToUse='..iAngleAdjustToUse..'; iActualAngleToUse='..iActualAngleToUse..'; angle from bomber to target='..M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), tDirectionToMoveTo)) end
                    elseif iCurTick >= iTicksBetweenOrders then iCurTick = 0
                    end

                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(1)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    if not(M28UnitInfo.IsUnitValid(oBomber)) then
                        break
                    end
                end
            end

            if M28UnitInfo.IsUnitValid(oBomber) then
                M28Orders.IssueTrackedMove(oBomber, tDirectionToMoveTo, 5, false, 'BMicMTR', true)
                if bDebugMessages == true then LOG(sFunctionRef..': Just cleared bomber '..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..' commands and told it to move to '..repru(tDirectionToMoveTo)..'; GameTime='..GetGameTimeSeconds()..'; iOptionalSecondsToMoveAtEndIfFarFromTarget='..(iOptionalSecondsToMoveAtEndIfFarFromTarget or 'nil')) end
                if iOptionalSecondsToMoveAtEndIfFarFromTarget then
                    local iTimeToWait = math.min(iOptionalSecondsToMoveAtEndIfFarFromTarget, M28Utilities.GetDistanceBetweenPositions(oBomber:GetPosition(), tDirectionToMoveTo) / (oBomber:GetBlueprint().Physics.MaxSpeed or 10))
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitSeconds(iOptionalSecondsToMoveAtEndIfFarFromTarget)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                end

                oBomber[M28UnitInfo.refbSpecialMicroActive] = false
                oBomber[M28UnitInfo.refiGameTimeToResetMicroActive] = GetGameTimeSeconds()
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TurnAirUnitAndAttackTarget(oBomber, oTarget)
    --Currently just used for ahwassa
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TurnAirUnitAndAttackTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oBomber='..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; GameTime='..GetGameTimeSeconds()) end
    if M28UnitInfo.IsUnitValid(oBomber) and M28UnitInfo.IsUnitValid(oTarget) then
        local iStartTime = GetGameTimeSeconds()
        --local iAngleToTarget

        --Config:
        local iTicksBetweenOrders = 5
        local iDistanceAwayToMove = 10
        local iAngleAdjust = 50
        local iMaxAcceptableAngleDif = 30
        local iAOE, iDamage = M28UnitInfo.GetBomberAOEAndStrikeDamage(oBomber)
        local iBombStraightLineDistance = 8.5 --i.e. will consider firing a bomb in bombers current facing direction by this distance, and seeing if the aoe will hit the target
        local iPotentialAbortDistance = iBombStraightLineDistance + iAOE - 1
        local tGroundTarget

        --Other variables:
        local iActualAngleToUse
        local iCurAngleDif
        local iAngleAdjustToUse
        local iFacingDirection
        local iAngleToTarget

        local iCurTick = 0
        local iDistToTarget
        local tTempTarget

        local iMaxMicroTime = 5 --will micro for up to 5 seconds
        if EntityCategoryContains(categories.EXPERIMENTAL, oBomber.UnitId) then iMaxMicroTime = 10 end

        TrackTemporaryUnitMicro(oBomber, 60) --60s is redundancy

        while GetGameTimeSeconds() - iStartTime < iMaxMicroTime do
            iCurTick = iCurTick + 1

            iFacingDirection = M28UnitInfo.GetUnitFacingAngle(oBomber)
            iAngleToTarget = M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), oTarget:GetPosition())
            iCurAngleDif = iFacingDirection - iAngleToTarget
            iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oBomber:GetPosition(), oTarget:GetPosition())
            --e.g. if bomber is facing 350 degrees, and the target is at 10 degrees, then it means there's only a dif of 20 degrees, but we want the bomber to go 350+50, rather than 350-50.  Facing - Angle would result in a positive value
            --if instead bomber was facing 10 degrees, and the target was 30 degrees, then would get -20 as the result, and so want to also increase
            --the effect of the below is that when bomber is facing 350 degrees and target 10 degrees, it will treat the difference as being 350 - 10 - 360 = -20, and want the bomber to go 350+50; if insteadbomber 10 and target 30, then dif = -20 and no adjustment made
            if math.abs(iCurAngleDif) > 180 then
                if iCurAngleDif > 180 then
                    --iFacingDirection is too high so decrease the angle difference
                    iCurAngleDif = iCurAngleDif - 360
                else --Curangledif must be < -180, so angletotarget is too high
                    iCurAngleDif = iCurAngleDif + 360
                end
            end

            if iCurAngleDif < 0 then
                iAngleAdjustToUse = iAngleAdjust
            else iAngleAdjustToUse = -iAngleAdjust
            end

            --Are we close enough to the direction wanted?
            iCurAngleDif = math.abs(iCurAngleDif)
            if iCurAngleDif <= (iMaxAcceptableAngleDif or 15) or iDistToTarget <= iPotentialAbortDistance then
                --Are close enough in angle so can stop the micro
                if iDistToTarget <= iPotentialAbortDistance then
                    local tPotentialTarget = M28Utilities.MoveInDirection(oBomber:GetPosition(), iFacingDirection, iBombStraightLineDistance, true, false, true)
                    if tPotentialTarget and M28Utilities.GetDistanceBetweenPositions(tPotentialTarget, oTarget:GetPosition()) <= iAOE - 1 then
                        tGroundTarget = {tPotentialTarget[1], tPotentialTarget[2], tPotentialTarget[3]}
                    elseif iCurAngleDif <= (iMaxAcceptableAngleDif or 15) * 0.6 then
                        --We are fairly close and aiming in the right direction so just attack rather than trying aoe attack to reduce the risk we just stay hovering in the air never attacking
                        tGroundTarget = oTarget:GetPosition()
                    end
                else
                    tGroundTarget = oTarget:GetPosition()
                end
            end
            if tGroundTarget and M28UnitInfo.GetTimeUntilReadyToFireBomb(oBomber) > 0 then
                --If we cant fire yet then clear the ground target and keep microing
                tGroundTarget = nil
            end
            if tGroundTarget then
                break
            else
                if iCurTick == 1 then
                    iActualAngleToUse = iFacingDirection + iAngleAdjustToUse
                    tTempTarget = M28Utilities.MoveInDirection(oBomber:GetPosition(), iActualAngleToUse, iDistanceAwayToMove, true, false, true)
                    M28Orders.IssueTrackedMove(oBomber, tTempTarget, 0, false, 'BMicrM', true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Just issued move order, iFacingDirection='..iFacingDirection..'; iCurAngleDif='..iCurAngleDif..'; iAngleAdjustToUse='..iAngleAdjustToUse..'; iActualAngleToUse='..iActualAngleToUse..'; angle from bomber to target='..M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), tDirectionToMoveTo)) end
                elseif iCurTick >= iTicksBetweenOrders then iCurTick = 0
                end

                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if not(M28UnitInfo.IsUnitValid(oBomber)) or not(M28UnitInfo.IsUnitValid(oTarget)) then
                    break
                end
            end
        end

        if tGroundTarget and M28UnitInfo.IsUnitValid(oBomber) and M28UnitInfo.IsUnitValid(oTarget) then
            --Fire the bomb
            oBomber[M28UnitInfo.refbSpecialMicroActive] = false
            oBomber[M28UnitInfo.refiGameTimeToResetMicroActive] = GetGameTimeSeconds()
            M28Orders.IssueTrackedGroundAttack(oBomber, tGroundTarget, 1, false, 'BMicGA', true, oTarget)
            if bDebugMessages == true then LOG(sFunctionRef..': Just cleared bomber '..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..' commands and told it to attack tGroundTarget='..repru(tGroundTarget)..'which is expected to hit oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; GameTime='..GetGameTimeSeconds()) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MoveAwayFromFactory(oUnit, oFactory)
    if EntityCategoryContains(categories.STRUCTURE, oFactory.UnitId) then --and not(EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId)) then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'MoveAwayFromFactory'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        local aiBrain = oFactory:GetAIBrain()
        if aiBrain.M28AI then --redundancy
            local iTeam = aiBrain.M28Team
            local tLZOrWZData, tLZOrWZTeamData
            local iPlateauOrZero, iLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oFactory:GetPosition())
            if iLZOrWZ > 0 then
                if iPlateauOrZero == 0 then
                    tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLZOrWZ]][M28Map.subrefPondWaterZones][iLZOrWZ]
                    tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                else
                    tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLZOrWZ]
                    tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                end
                if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) == false then
                    local iFactorySize = M28UnitInfo.GetBuildingSize(oFactory.UnitId)
                    local tOrderPosition = M28Utilities.MoveInDirection(oFactory:GetPosition(), M28Utilities.GetAngleFromAToB(oFactory:GetPosition(), tLZOrWZTeamData[M28Map.reftClosestEnemyBase]), iFactorySize + 2, true, false, true)
                    --If dealing with land fac then rotate engineer
                    local bLandFacRotatedEngineer = false
                    if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oFactory.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                        local iAngleToDestination = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tOrderPosition)
                        if oUnit.SetRotation then oUnit:SetRotation(iAngleToDestination) end

                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Will try and rotate engineer '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..' since FAF code does this, unit facing direction='..M28UnitInfo.GetUnitFacingAngle(oUnit)..'; Angle to factory rally='..iAngleToDestination..'; will draw tOrderPosition, is set rotation nil='..tostring(oUnit.SetRotation == nil))
                            M28Utilities.DrawLocation(tOrderPosition)
                        end
                    end
                    M28Orders.IssueTrackedMove(oUnit, tOrderPosition, 0, false, 'JustBuilt', true)
                    local iMicroDelay = 1.5
                    if EntityCategoryContains(M28UnitInfo.refCategoryQuantumGateway, oFactory.UnitId) then iMicroDelay = 4 --done as when was 1.5 would have RAS SACUs given new orders like GE template just after being built and getting stuck
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oFactory.UnitId) and EntityCategoryContains(M28UnitInfo.categories.TECH3 * M28UnitInfo.refCategoryNavalSurface, oUnit.UnitId) then iMicroDelay = 4
                    end
                    TrackTemporaryUnitMicro(oUnit, 1.5)
                end

            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished for oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' built from factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..' at time='..GetGameTimeSeconds()) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function DelayedUnitMove(oUnit, tMoveDirection, iMoveThreshold, bAddToExistingQueue, sOptionalOrderDesc, bOverrideMicroOrder, iSecondsToWait)

    WaitSeconds(iSecondsToWait)
    if M28UnitInfo.IsUnitValid(oUnit) then
        M28Orders.IssueTrackedMove(oUnit, tMoveDirection, iMoveThreshold, bAddToExistingQueue, sOptionalOrderDesc, bOverrideMicroOrder)
    end
end

function MegalithRetreatMicro(oUnit, tRallyPoint, tClosestFriendlyBase)
    --Tries to retreat the unit, returns false if couldnt find suitable retreat location
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MegalithRetreatMicro'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bGivenOrder = false

    if not(oUnit[M28UnitInfo.refbEasyBrain]) then

        --Only consider applying micro if moving in opposite direction to that which we are facing should result in us moving in similar direction to rally point or closest base
        local iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)
        local iAngleToClosestBase = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tClosestFriendlyBase)
        local iFacingDirection = M28UnitInfo.GetUnitFacingAngle(oUnit)
        local iAngleIfMoving = iFacingDirection + 180
        if iAngleIfMoving > 360 then iAngleIfMoving = iAngleIfMoving - 360 end
        local tMoveDirection



        if M28Utilities.GetAngleDifference(iAngleToRally, iAngleIfMoving) <= 60 or M28Utilities.GetAngleDifference(iAngleToClosestBase, iAngleIfMoving) <= 60 then
            local iDistanceToMove = 8 --worked ok with value of 5
            tMoveDirection = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleIfMoving, iDistanceToMove, true, false, true)
            if M28Utilities.IsTableEmpty(tMoveDirection) == false then
                --Looks like megalith has to be stationery or reversing for this to work?
                local tCurOrder = oUnit[M28Orders.reftiLastOrders][1]
                local bClearAndWait = false
                if tCurOrder then
                    if tCurOrder[M28Orders.refiOrderIssueMove] == M28Orders.refiOrderIssueMove and M28Utilities.IsTableEmpty(tCurOrder[M28Orders.subreftOrderPosition]) == false then
                        if M28Utilities.GetDistanceBetweenPositions(tMoveDirection, tCurOrder[M28Orders.subreftOrderPosition]) >= iDistanceToMove then
                            bClearAndWait = true
                        end
                    else
                        bClearAndWait = true
                    end

                end
                if bClearAndWait then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will clear orders then do delayed move') end
                    M28Orders.IssueTrackedClearCommands(oUnit)
                    ForkThread(DelayedUnitMove, oUnit, tMoveDirection, iDistanceToMove * 0.45, false, 'MegDelM', false, 0.75) --tried with 0.25s delay and led to megalith turning around; 0.75 worked in the replay where megalith moved in a circle before; if find it doesnt work in other caess though the nincrease to 1s and add unit micro tracking
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Are already trying to kite so will just check if move order needs updating') end
                    M28Orders.IssueTrackedMove(oUnit, tMoveDirection, iDistanceToMove * 0.45, false, 'MegMiRM', false)
                end
                bGivenOrder = true
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bGivenOrder='..tostring(bGivenOrder or false)..'; tMoveDirection='..repru(tMoveDirection)..'; iFacingDirection='..iFacingDirection..'; iAngleToRally='..iAngleToRally..'; iAngleToClosestBase='..iAngleToClosestBase..'; iAngleIfMoving='..iAngleIfMoving..'; Time='..GetGameTimeSeconds()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bGivenOrder
end

function MoveAndKillAirUnit(oUnit)
    --Move to a random nearby positionand then ctrl-k; reason is to reduce likelihood we are detsroying existing wrecks
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MoveAndKillAirUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28UnitInfo.IsUnitValid(oUnit) then --redundancy
        if bDebugMessages == true then LOG(sFunctionRef..': About to give more and kill order to unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; time='..GetGameTimeSeconds()) end
        if oUnit[M28UnitInfo.refbEasyBrain] then
            M28Orders.IssueTrackedKillUnit(oUnit)
        else
            local iPotentialXAdjust, iPotentialZAdjust
            local iSearchRadius = 30
            local bHaveLowHealthUnitOrReclaim
            local iMaxSearchAttempt = 10
            for iSearchAttempt = 1, iMaxSearchAttempt do
                bHaveLowHealthUnitOrReclaim = false
                iPotentialXAdjust = math.random(1,iSearchRadius*2) - iSearchRadius
                iPotentialZAdjust = math.random(1,iSearchRadius*2) - iSearchRadius
                local tPotentialPosition = oUnit:GetPosition()
                tPotentialPosition[1] = tPotentialPosition[1] + iPotentialXAdjust
                tPotentialPosition[3] = tPotentialPosition[3] + iPotentialXAdjust
                --Check no low health units (e.g. radar, shields) at the target position unless cant find any
                if iSearchAttempt < iMaxSearchAttempt then
                    local rRectangleToSearch = M28Utilities.GetRectAroundLocation(tPotentialPosition, 1)
                    local tUnitsNearPosition = GetUnitsInRect(rRectangleToSearch)
                    if M28Utilities.IsTableEmpty(tUnitsNearPosition) == false then
                        local tBuildings = EntityCategoryFilterDown(categories.STRUCTURE + categories.EXPERIMENTAL,  tUnitsNearPosition)
                        if M28Utilities.IsTableEmpty(tBuildings) == false then
                            for iNearbyUnit, oNearbyUnit in tBuildings do
                                if oNearbyUnit:GetHealth() <= 110 then
                                    bHaveLowHealthUnitOrReclaim = true
                                    break
                                end
                            end
                        end
                    end
                    if not(bHaveLowHealthUnitOrReclaim) then
                        local iReclaimNearby = M28Map.GetReclaimInRectangle(3, rRectangleToSearch)
                        if iReclaimNearby >= 10 then
                            bHaveLowHealthUnitOrReclaim = true
                        end
                        --iReturnType: 1 = true/false; 2 = number of wrecks; 3 = total mass, 4 = valid wrecks, 5 = energy
                    end
                end
                if not(bHaveLowHealthUnitOrReclaim) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have got location to move to for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; .Dead='..tostring(oUnit.Dead or false)..'; been destroyed='..tostring(oUnit:BeenDestroyed())..'; tPotentialPosition='..repru(tPotentialPosition)) end
                    M28Orders.IssueTrackedMove(oUnit, tPotentialPosition, 0, false, 'MveToDie', true)
                    TrackTemporaryUnitMicro(oUnit, 3)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitSeconds(3)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        M28Orders.IssueTrackedKillUnit(oUnit)
                    end
                    break
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MonitorNukeTargetForFriendlyUnits(oProjectile, oLauncher, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MonitorNukeTargetForFriendlyUnits'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(oProjectile:BeenDestroyed()) and oProjectile.GetCurrentTargetPosition then
        --LOG('Blueprint for projectile repru='..repru(oProjectile.Blueprint))
        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        if aiBrain then
            if bDebugMessages == true then LOG(sFunctionRef..': Outer ring='..repru(oProjectile.OuterRing)..'; Inner ring='..repru(oProjectile.InnerRing)) end
            local tTarget = oProjectile:GetCurrentTargetPosition()
            local iSearchArea = math.min((oProjectile.OuterRing.Radius or 50), math.max(56, (oProjectile.InnerRing.Radius or 35) + 15)) + 4
            local iCategoriesToSearch = M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryMobileLand * categories.TECH3 + M28UnitInfo.refCategoryAllNavy * categories.MOBILE - categories.TECH1 + categories.COMMAND + categories.SUBCOMMANDER
            local iSpeed = (oProjectile.Blueprint.Physics.MaxSpeed or 10)
            local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(tTarget, oProjectile:GetPosition())
            local iTimeToTarget = iDistToTarget / iSpeed
            if bDebugMessages == true then LOG(sFunctionRef..': iSpeed='..iSpeed..'; iDistToTarget='..iDistToTarget..'; iTimeToTarget='..iTimeToTarget..'; iSearchArea='..iSearchArea..'; Excess time='..(iTimeToTarget - iSearchArea / 2)*10) end
            if iTimeToTarget >= iSearchArea / 2 then --want to allow enough time for a unit in the middle of the target to get out of the way
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(math.floor((iTimeToTarget - iSearchArea / 2)*10))
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
            local iAngleToUnit
            local iMoveDistance = iSearchArea + 15
            local bKeepInCampaignArea = M28Map.bIsCampaignMap
            while not(oProjectile:BeenDestroyed()) and not(aiBrain.M28IsDefeated)  do
                --Every second check for friendly experimental, ACU, and T3 land units around the target area and have them move away
                --First check the missile is close enough that we should try and have units run
                local tFriendlyUnitsNearTarget = aiBrain:GetUnitsAroundPoint(iCategoriesToSearch, tTarget, iSearchArea, 'Ally')
                if M28Utilities.IsTableEmpty(tFriendlyUnitsNearTarget) == false then
                    for iUnit, oUnit in tFriendlyUnitsNearTarget do
                        iAngleToUnit = M28Utilities.GetAngleFromAToB(tTarget, oUnit:GetPosition())
                        local tMoveAwayPoint = M28Utilities.MoveInDirection(tTarget, iAngleToUnit, iMoveDistance, true, false, bKeepInCampaignArea)
                        M28Orders.IssueTrackedMove(oUnit, tMoveAwayPoint, 5, false, 'NukeDodge', true)
                        TrackTemporaryUnitMicro(oUnit, 1)
                    end
                end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitSeconds(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end