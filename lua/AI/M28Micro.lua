---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 18/01/2023 06:57
---
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local XZDist = import('/lua/utilities.lua').XZDistanceTwoVectors

refbMicroResetChecker = 'M28MicChk' --True if we have an active thread checking if micro time has expired

function MoveAwayFromTargetTemporarily(oUnit, iTimeToRun, tPositionToRunFrom)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MoveAwayFromTargetTemporarily'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bMoveInStages = false --set to true later if hardly have any time to run, but in reality this functionality isn't expected to be used in most cases, left in since took a while to get it to work to a basic level, but turns out it's probably better to just move in a straight line rather than trying multiple move orders


    local tUnitPosition = oUnit:GetPosition()
    local oBP = oUnit:GetBlueprint()
    local iUnitSpeed = oBP.Physics.MaxSpeed
    local iDistanceToMove = (iTimeToRun + 1) * iUnitSpeed
    --local tRevisedPositionToRunFrom

    local iCurFacingDirection = M28UnitInfo.GetUnitFacingAngle(oUnit)
    local iAngleFromUnitToBomb
    if tUnitPosition[1] == tPositionToRunFrom[1] and tUnitPosition[3] == tPositionToRunFrom[3] then
        iAngleFromUnitToBomb = iCurFacingDirection - 180
        if iAngleFromUnitToBomb < 0 then iAngleFromUnitToBomb = iAngleFromUnitToBomb + 360 end
    else
        iAngleFromUnitToBomb = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tPositionToRunFrom)
    end

    local iAngleAdjFactor
    local iFacingAngleWanted = iAngleFromUnitToBomb + 180
    if iFacingAngleWanted >= 360 then iFacingAngleWanted = iFacingAngleWanted - 360 end

    local iTurnRate = (oBP.Physics.TurnRate or 90)
    local iTimeToTurn = math.abs(iFacingAngleWanted - iCurFacingDirection) / iTurnRate
    local iDistToBomb = M28Utilities.GetDistanceBetweenPositions(tPositionToRunFrom, oUnit:GetPosition())
    if iDistToBomb * 2 / iUnitSpeed <= iTimeToTurn then
        iFacingAngleWanted = iCurFacingDirection
        iDistanceToMove = iDistanceToMove + iDistToBomb
    end
    if iTimeToTurn > iTimeToRun then bMoveInStages = true end

    local tTempLocationToMove

    if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop for move commands for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTimeToRun='..iTimeToRun..'; iCurFacingDirection='..iCurFacingDirection..'; iAngleFromUnitToBomb='..iAngleFromUnitToBomb..'; iFacingAngleWanted='..iFacingAngleWanted..'; tUnitStartPosition='..repru(oUnit:GetPosition())..'; tPositionToRunFrom='..repru(tPositionToRunFrom)) end
    M28Orders.IssueTrackedClearCommands(oUnit)
    TrackTemporaryUnitMicro(oUnit, iTimeToRun)
    tTempLocationToMove = oUnit:GetPosition()
    local iDistanceAlreadyMoved = 0


    --Turn around while moving away if we're not facing the right direction:
    if bMoveInStages then
        local iInitialAngleAdj = 30
        local iAngleMaxSingleAdj = 45
        local iTempDistanceAwayToMove = 3
        local iDistanceIncreasePerCycle = 1.5
        local iDistanceIncreaseCompoundFactor = 1.5
        local iLoopCount = 0

        if math.abs(iCurFacingDirection - iFacingAngleWanted) > (iAngleMaxSingleAdj + iInitialAngleAdj) then
            local iTempAngleDirectionToMove = iCurFacingDirection

            if iCurFacingDirection - iFacingAngleWanted > 0 then
                if iCurFacingDirection - iFacingAngleWanted > 180 then iAngleAdjFactor = 1 --Clockwise
                else iAngleAdjFactor = -1 --AntiClockwise
                end

            elseif iCurFacingDirection - iFacingAngleWanted < -180 then iAngleAdjFactor = -1
            else iAngleAdjFactor = 1
            end --Clockwise



            while iLoopCount < 6 do
                iLoopCount = iLoopCount + 1

                iTempAngleDirectionToMove = iCurFacingDirection + (iInitialAngleAdj + iLoopCount * iAngleMaxSingleAdj) * iAngleAdjFactor
                if iTempAngleDirectionToMove > 360 then iTempAngleDirectionToMove = iTempAngleDirectionToMove - 360
                elseif iTempAngleDirectionToMove < 0 then iTempAngleDirectionToMove = iTempAngleDirectionToMove + 360
                end

                if bDebugMessages == true then LOG(sFunctionRef..': iLoopCount='..iLoopCount..'; iTempAngleDirectionToMove='..iTempAngleDirectionToMove..'; iInitialAngleAdj='..iInitialAngleAdj..'; iAngleAdjFactor='..iAngleAdjFactor..'; iCurFacingDirection='..iCurFacingDirection..'; iFacingAngleWanted='..iFacingAngleWanted) end


                iTempDistanceAwayToMove = iTempDistanceAwayToMove + iDistanceIncreasePerCycle * iDistanceIncreasePerCycle * (iDistanceIncreaseCompoundFactor ^ iLoopCount - 1)
                tTempLocationToMove = M28Utilities.MoveInDirection(oUnit:GetPosition(), iTempAngleDirectionToMove, iTempDistanceAwayToMove, true, false, true)
                M28Orders.IssueTrackedMove(oUnit, tTempLocationToMove, 0.25, true, 'TempMA', true)
                if bDebugMessages == true then LOG(sFunctionRef..': Just issued move order to tTempLocationToMove='..repru(tTempLocationToMove)..'; iTempAngleDirectionToMove='..iTempAngleDirectionToMove) end
                if math.abs(iTempAngleDirectionToMove - iFacingAngleWanted) <= iAngleMaxSingleAdj then break
                elseif math.abs(iTempAngleDirectionToMove - iFacingAngleWanted) > 360 then
                    M28Utilities.ErrorHandler('Something has gone wrong with dodge micro, will stop trying to turn around')
                    break
                end
            end
            iDistanceAlreadyMoved = M28Utilities.GetDistanceBetweenPositions(tTempLocationToMove, tPositionToRunFrom)
        end
    end

    --Should now be facing close to the right direction, so move further in this direction

    local tNewTargetIgnoringGrouping = M28Utilities.MoveInDirection(oUnit:GetPosition(), iFacingAngleWanted, math.max(1, iDistanceToMove - iDistanceAlreadyMoved), true, false, true)
    if bDebugMessages == true then LOG(sFunctionRef..': Finished trying to face the right direction, tNewTargetIgnoringGrouping='..repru(tNewTargetIgnoringGrouping)..'; tUnitPosition='..repru(tUnitPosition)..'; iDistanceToMove='..iDistanceToMove..'; iDistanceAlreadyMoved='..iDistanceAlreadyMoved) end

    local tNewTargetInSameGroup = M28Map.GetPositionAtOrNearTargetInPathingGroup(tUnitPosition, tNewTargetIgnoringGrouping, 0, 0, oUnit, true, false)
    if tNewTargetInSameGroup then
        if bDebugMessages == true then LOG(sFunctionRef..': Starting bomber dodge for unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; tNewTargetInSameGroup='..repru(tNewTargetInSameGroup)) end

        M28Orders.IssueTrackedMove(oUnit, tNewTargetInSameGroup, 0.25, true, 'TempMA', true)
        TrackTemporaryUnitMicro(oUnit, iTimeToRun)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code at time='..GetGameTimeSeconds()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetBombTarget(weapon, projectile)
    --based on CalcBallisticAcceleration

    --Copy of CalcBallisticAcceleration core part of calculation to determine bomb target; ignores multiple bombs
    local acc = 4.75
    if projectile and projectile.GetLauncher then
        local launcher = projectile:GetLauncher()
        if launcher then
            -- Get projectile position and velocity
            -- velocity needs to multiplied by 10 due to being returned /tick instead of /s
            local proj = {pos=projectile:GetPosition(), vel=VMult(Vector(launcher:GetVelocity()), 10)}
            local entity = launcher:GetTargetEntity()

            local target
            if entity and IsUnit(entity) then
                -- target is a entity
                target = {pos=entity:GetPosition(), vel=VMult(Vector(entity:GetVelocity()), 10)}
            else
                -- target is something else i.e. attack ground
                target = {pos=weapon:GetCurrentTargetPos(), vel=Vector(0, 0, 0)}
            end

            -- calculate flat(exclude y-axis) distance and velocity between projectile and target
            if M28Utilities.IsTableEmpty(target) == false and M28Utilities.IsTableEmpty(proj.pos) == false and target.pos and target.vel and proj.pos and target.pos then
                local dist = {pos=XZDist(proj.pos, target.pos), vel=XZDist(proj.vel, target.vel)}

                -- how many seconds until the bomb hits the target in xz-space
                local time = dist.pos / dist.vel
                if time == 0 then return acc end

                -- find out where the target will be at that point in time (it could be moving)
                target.tpos = {target.pos[1] + time * target.vel[1], 0, target.pos[3] + time * target.vel[3]}
                -- what is the height at that future position
                target.tpos[2] = GetSurfaceHeight(target.tpos[1], target.tpos[3])
                return target.tpos
            end
        end
    elseif not(projectile) and weapon.GetCurrentTarget then
        if weapon:GetCurrentTarget().GetPosition then return weapon:GetCurrentTarget():GetPosition() end
    end
    return nil
end

function DodgeBomb(oBomber, oWeapon, projectile)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DodgeBombsFiredByUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tBombTarget = GetBombTarget(oWeapon, projectile)
    if tBombTarget then
        local iBombSize = 2.5
        if oWeapon.GetBlueprint then iBombSize = math.max(iBombSize, (oWeapon:GetBlueprint().DamageRadius or iBombSize)) end
        local iTimeToRun = 1.75 --T1
        if iBombSize > 2.5 then iTimeToRun = math.min(2.6, iTimeToRun + (iBombSize - 2.5) * 0.5) end
        if EntityCategoryContains(categories.TECH2, oBomber.UnitId) then
            iBombSize = 3
            iTimeToRun = 1.95
            if iBombSize > 3 then iTimeToRun = math.min(2.6, iTimeToRun + (iBombSize - 3) * 0.5) end
        elseif EntityCategoryContains(categories.TECH3, oBomber.UnitId) then
            iTimeToRun = 2.5
        end --Some t2 bombers do damage in a spread (cybran, uef)
        --local iTimeToRun = math.min(7, iBombSize + 1)
        local iRadiusSize = iBombSize + 1

        local iBomberArmyIndex = oBomber:GetAIBrain():GetArmyIndex()

        if bDebugMessages == true then
            LOG(sFunctionRef..': oBomber='..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; Bomber position='..repru(oBomber:GetPosition())..'; tBombTarget='..repru(tBombTarget)..'; Dist between position and target='..M28Utilities.GetDistanceBetweenPositions(oBomber:GetPosition(), tBombTarget)..'; Angle='..M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), tBombTarget)..'; Bomber facing direction='..M28UnitInfo.GetUnitFacingAngle(oBomber)..'; will draw bomb target in black')
            M28Utilities.DrawLocation(tBombTarget, 3, 20)
        end --black ring around target

        local tAllUnitsInArea = GetUnitsInRect(Rect(tBombTarget[1]-iRadiusSize, tBombTarget[3]-iRadiusSize, tBombTarget[1]+iRadiusSize, tBombTarget[3]+iRadiusSize))
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of units in rectangle around bomb radius empty='..tostring(M28Utilities.IsTableEmpty(tAllUnitsInArea))) end
        if M28Utilities.IsTableEmpty(tAllUnitsInArea) == false then
            local tMobileLandInArea = EntityCategoryFilterDown(M28UnitInfo.refCategoryMobileLand - categories.EXPERIMENTAL, tAllUnitsInArea)
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of mobile land units in rectangle around bomb radius empty='..tostring(M28Utilities.IsTableEmpty(tMobileLandInArea))) end
            if M28Utilities.IsTableEmpty(tMobileLandInArea) == false then
                local oCurBrain
                for iUnit, oUnit in tMobileLandInArea do
                    if not(oUnit.Dead) and oUnit.GetUnitId and oUnit.GetPosition and oUnit.GetAIBrain then
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Does unit already have micro active='..tostring((oUnit[M28UnitInfo.refbSpecialMicroActive] or false))..'; iTimeToRun='..iTimeToRun) end
                        oCurBrain = oUnit:GetAIBrain()
                        if oCurBrain.M28AI and not(oCurBrain.M28IsDefeated) and not(oCurBrain:IsDefeated()) and IsEnemy(oCurBrain:GetArmyIndex(), iBomberArmyIndex) then
                            --ACU specific
                            if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                                local aiBrain = oCurBrain
                                --If ACU is upgrading might not want to cancel
                                local bDontTryAndDodge = false
                                if oUnit:IsUnitState('Upgrading') then
                                    --Are we facing a T1 bomb?
                                    if EntityCategoryContains(categories.TECH1, oBomber.UnitId) then
                                        bDontTryAndDodge = true
                                    else
                                        --Facing T2+ bomb, so greater risk if we dont try and dodge; dont dodge if are almost complete
                                        if oUnit:GetWorkProgress() >= 0.9 then
                                            bDontTryAndDodge = true
                                        else
                                            --Is it a T2 bomber, and there arent many bombers nearby?
                                            if EntityCategoryContains(categories.TECH2, oBomber.UnitId) then
                                                local tNearbyBombers = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryBomber + M28UnitInfo.refCategoryGunship - categories.TECH1, oUnit:GetPosition(), 100, 'Enemy')
                                                if M28Utilities.IsTableEmpty(tNearbyBombers) == true then
                                                    bDontTryAndDodge = true
                                                else
                                                    local iEnemyBomberCount = 0
                                                    for iEnemy, oEnemy in tNearbyBombers do
                                                        if M28UnitInfo.IsUnitValid(oEnemy) then
                                                            iEnemyBomberCount = iEnemyBomberCount + 1
                                                            if iEnemyBomberCount >= 4 then break end
                                                        end
                                                    end
                                                    if iEnemyBomberCount < 4 then bDontTryAndDodge = true end
                                                end
                                            end
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': bDontTryAndDodge after checking if upgrading='..tostring(bDontTryAndDodge)) end
                                if not(bDontTryAndDodge) then
                                    --Is there a significant enemy land threat and we are against a T1 bomber?
                                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                                    if iLandZone > 0 and EntityCategoryContains(categories.TECH1, oBomber.UnitId) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefTThreatEnemyCombatTotal] * 1.2 > math.min(300, M28UnitInfo.GetCombatThreatRating({ oUnit }, false, false, false, false, false, false, false)) then
                                        bDontTryAndDodge = true
                                    end
                                end

                                if not(bDontTryAndDodge) then
                                    if oUnit[M28UnitInfo.refbSpecialMicroActive] then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will move in a circle as micro is already active') end
                                        MoveInCircleTemporarily(oUnit, iTimeToRun)
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will move away from bomb target temporarily') end
                                        MoveAwayFromTargetTemporarily(oUnit, iTimeToRun, tBombTarget)
                                        oUnit[M28UnitInfo.refiGameTimeMicroStarted] = GetGameTimeSeconds()
                                    end
                                end

                            else
                                --Are we a mobile shield that isn't on the same team as the bomber? If so, then dont worry about dodging
                                if not(EntityCategoryContains(M28UnitInfo.refCategoryMobileLandShield, oUnit.UnitId)) or not(oUnit.MyShield.GetHealth) or oUnit.MyShield:GetHealth() == 0 or not(oUnit.MyShield.Enabled) or oUnit.MyShield.DepletedByEnergy then
                                    if bDebugMessages == true then LOG(sFunctionRef..': about to call moveawayfromtargettemporarily') end
                                    MoveAwayFromTargetTemporarily(oUnit, iTimeToRun, tBombTarget)
                                    oUnit[M28UnitInfo.refiGameTimeMicroStarted] = GetGameTimeSeconds()
                                end
                            end
                        end
                    end
                end
            end
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': tBombTarget is nil') end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderDodgingShot(oUnit, oWeapon)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderDodgingShot'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then
        LOG(sFunctionRef..': Just fired, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
        if oWeapon.GetCurrentTarget then
            LOG(sFunctionRef..': Is current target valid='..tostring(M28UnitInfo.IsUnitValid(oWeapon:GetCurrentTarget()))..'; Weapon category='..oWeapon.Blueprint.WeaponCategory)
            if not(M28UnitInfo.IsUnitValid(oWeapon:GetCurrentTarget())) then
                LOG(sFunctionRef..': Invalid target, will do reprs of it:'..reprs(oWeapon:GetCurrentTarget())..' will also draw black square around the weapon target position which is '..repru(oWeapon:GetCurrentTargetPos()))
                M28Utilities.DrawLocation(oWeapon:GetCurrentTargetPos(), nil, 3, 200)
            else
                LOG(sFunctionRef..': Valid target='..oWeapon:GetCurrentTarget().UnitId..M28UnitInfo.GetUnitLifetimeCount(oWeapon:GetCurrentTarget()))
            end
        else
            LOG(sFunctionRef..': Dont have a current target for this weapon')
        end
    end
    --Direct fire, t1 mobile arti, t2 mobile missile launchers, and experimental land
    if oWeapon.GetCurrentTarget and (oWeapon.Blueprint.WeaponCategory == 'Direct Fire' or oWeapon.Blueprint.WeaponCategory == 'Direct Fire Naval' or oWeapon.Blueprint.WeaponCategory == 'Direct Fire Experimental' or (oWeapon.Blueprint.WeaponCategory == 'Artillery' and EntityCategoryContains(categories.TECH1, oUnit.UnitId)) or (oWeapon.Blueprint.WeaponCategory == 'Missile' and oWeapon.Blueprint.MaxRadius <= 80)) or (oWeapon.Blueprint.WeaponCategory == 'Indirect Fire' and oWeapon.Blueprint.MuzzleVelocity <= 25) then
        if bDebugMessages == true then LOG(sFunctionRef..': Have a valid weapon category, will see if have targets to consider dodging') end
        local oWeaponTarget = oWeapon:GetCurrentTarget()
        local bConsiderUnitsInArea = false
        if not(M28UnitInfo.IsUnitValid(oWeaponTarget)) or EntityCategoryContains(categories.NAVAL * categories.MOBILE, oWeaponTarget.UnitId) then bConsiderUnitsInArea = true end

        local tUnitsToConsiderDodgeFor = {}
        function ConsiderAddingUnitToTable(oCurUnit, bIncludeBusyUnits)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we should add oCurUnit='..oCurUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oCurUnit)..'; Brain='..oCurUnit:GetAIBrain().Nickname..'; Unit state='..M28UnitInfo.GetUnitState(oCurUnit)..'; Special micro active='..tostring(oCurUnit[M28UnitInfo.refbSpecialMicroActive] or false)..'; Time='..GetGameTimeSeconds()..'; refiGameTimeToResetMicroActive='..(oCurUnit[M28UnitInfo.refiGameTimeToResetMicroActive] or 'nil')) end
            if oCurUnit:GetAIBrain().M28AI and (bIncludeBusyUnits or (not(oCurUnit:IsUnitState('Upgrading')) and not(oCurUnit[M28UnitInfo.refbSpecialMicroActive]))) then
                if EntityCategoryContains(categories.AIR + categories.STRUCTURE, oCurUnit.UnitId) then
                    --Do nothing
                elseif EntityCategoryContains(categories.MOBILE, oCurUnit.UnitId) then
                    if oCurUnit:GetFractionComplete() == 1 and M28UnitInfo.IsUnitValid(oCurUnit) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Added unit to table of units to consider dodging for') end
                        table.insert(tUnitsToConsiderDodgeFor, oCurUnit)
                    end
                end
            end
        end
        local bIncludeBusyUnits = false
        if oWeapon.Blueprint.Damage >= 5000 then bIncludeBusyUnits = true end
        if not(bConsiderUnitsInArea) then
            --Is it a unit with a shield?
            if EntityCategoryContains(categories.SHIELD, oWeaponTarget.UnitId) then
                local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oWeaponTarget, true)
                if (iCurShield or 0) <= (iMaxShield or 0) * 0.2 then
                    ConsiderAddingUnitToTable(oWeaponTarget, bIncludeBusyUnits)
                end
            else
                ConsiderAddingUnitToTable(oWeaponTarget, bIncludeBusyUnits)
            end

        else
            --Does the weapon have an aoe?
            if (oWeapon.Blueprint.DamageRadius or 0) > 0.1 then
                --Get all units in area
                local tWeaponTarget = oWeapon:GetCurrentTargetPos()
                if M28Utilities.IsTableEmpty(tWeaponTarget) == false then
                    local iRadiusSize = math.min(3, math.max(oWeapon.Blueprint.DamageRadius, 1))
                    local tAllUnitsInArea = GetUnitsInRect(Rect(tWeaponTarget[1]-iRadiusSize, tWeaponTarget[3]-iRadiusSize, tWeaponTarget[1]+iRadiusSize, tWeaponTarget[3]+iRadiusSize))
                    if M28Utilities.IsTableEmpty(tAllUnitsInArea) == false then
                        --Do we have shield units in the area with at least 20% shield? Will assume shield covers all the units
                        local tShieldsInArea = EntityCategoryFilterDown(categories.SHIELD, tAllUnitsInArea)
                        local bUnderMobileShield = false
                        if M28Utilities.IsTableEmpty(tShieldsInArea) == false then
                            local iCurShield, iMaxShield
                            for iShield, oShield in tShieldsInArea do
                                iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': oCurUnit='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; iCurShield='..iCurShield..'; iMaxShield='..iMaxShield) end
                                if (iCurShield or 0) > (iMaxShield or 0) * 0.2 then
                                    bUnderMobileShield = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Unit has at least 20% shield remaining so wont dodge') end
                                    break
                                end
                            end
                        end
                        if not(bUnderMobileShield) then
                            for iNearbyUnit, oNearbyUnit in tAllUnitsInArea do
                                ConsiderAddingUnitToTable(oNearbyUnit, bIncludeBusyUnits)
                            end
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of units to consider dodging empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToConsiderDodgeFor))..'; Weapon damage='..oWeapon.Blueprint.Damage) end
        if M28Utilities.IsTableEmpty(tUnitsToConsiderDodgeFor) == false then
            --Calculate time to impact
            local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oWeapon:GetCurrentTargetPos())
            local iMaxTimeToRun = 3
            if oWeapon.Blueprint.WeaponCategory == 'Artillery' then
                iDistToTarget = iDistToTarget + 15
                iMaxTimeToRun = 0.8
            elseif oWeapon.Blueprint.WeaponCategory == 'Missile' then
                iDistToTarget = iDistToTarget + 10
                iMaxTimeToRun = 0.8
            end
            local iShotSpeed = oWeapon.Blueprint.MuzzleVelocity
            local iTimeUntilImpact = iDistToTarget / iShotSpeed
            local bCancelDodge = false
            if bDebugMessages == true then LOG(sFunctionRef..': Dist to target='..iDistToTarget..'; Shot speed='..iShotSpeed..'; iTimeUntilImpact='..iTimeUntilImpact) end
            if iTimeUntilImpact > 0.8 then
                for iTarget, oTarget in tUnitsToConsiderDodgeFor do
                    bCancelDodge = false
                    if bDebugMessages == true then LOG(sFunctionRef..': oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Weapon damage='..oWeapon.Blueprint.Damage..'; Target health='..oTarget:GetHealth()) end
                    --Does the shot do enough damage that we want to try and doge it?
                    if oWeapon.Blueprint.Damage / oTarget:GetHealth() >= 0.01 then
                        --Do we think we can dodge the shot?
                        --If we are a large unit then only dodge if will be a while for the shot to hit
                        local oBP = oTarget:GetBlueprint()
                        local iAverageSize = (oBP.SizeX + oBP.SizeZ) * 0.5
                        if bDebugMessages == true then LOG(sFunctionRef..': iAverageSize='..iAverageSize..'; Is unit underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; Unit speed='..oBP.Physics.MaxSpeed) end
                        if iTimeUntilImpact > math.min(2.5, 0.4 + iAverageSize * 1.5 / oBP.Physics.MaxSpeed) and (iTimeUntilImpact >= 2 or not(EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId))) then
                            --Are we not underwater?
                            if not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                                --If dealing with an ACU then drastically reduce the dodge time so we can overcharge if we havent recently and have enemies in range and enough power
                                if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and M28Conditions.CanUnitUseOvercharge(oUnit:GetAIBrain(), oUnit) and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastOverchargeShot] or 0)) > 5 then
                                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                                    local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
                                    if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 200 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Reducing dodge time drastically as have ACU that can overcharge enemies in range but it also wants to dodge a shot; will cancel if damage is very low that are dodging. oWeapon.Blueprint.Damage='..oWeapon.Blueprint.Damage) end
                                        if oWeapon.Blueprint.Damage <= 100 then
                                            bCancelDodge = true
                                        else
                                            iMaxTimeToRun = math.min(0.8, iMaxTimeToRun) --(M27 uses 0.9; if set too low then ACU may not actually move)
                                        end
                                    end
                                elseif EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then
                                    --If we are a GC, Monkey or Ythotha that has an enemy experimental nearby but not in range, then cancel dodging as want to get in range to be able to  fire
                                    iMaxTimeToRun = math.min(2.5, iMaxTimeToRun)
                                end

                                if not(bCancelDodge) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will try to dodge shot. iTimeUntilImpact='..iTimeUntilImpact..'; iMaxTimeToRun='..iMaxTimeToRun) end
                                    DodgeShot(oTarget, oUnit, oWeapon, math.min(iTimeUntilImpact, iMaxTimeToRun))
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DodgeShot(oTarget, oWeapon, oAttacker, iTimeToDodge)
    --Should have already checked oTarget is a valid unit that has a chance of dodging the shot in time before claling this
    --Gets unit to move at a slightly different angle to its current facing direction for iTimeToDodge
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DodgeShot'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oTarget))) end

    M28Orders.UpdateRecordedOrders(oTarget)
    local tCurDestination
    local bAttackMove = false
    if oTarget[M28Orders.refiOrderCount] > 0 then
        local tLastOrder = oTarget[M28Orders.reftiLastOrders][oTarget[M28Orders.refiOrderCount]]
        tCurDestination = tLastOrder[M28Orders.subreftOrderPosition]
        if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAttack or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAggressiveMove or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAggressiveFormMove then
            bAttackMove = true
        end
    end

    local iCurFacingAngle = M28UnitInfo.GetUnitFacingAngle(oTarget)
    local iAngleToDestination
    if tCurDestination then iAngleToDestination = M28Utilities.GetAngleFromAToB(oTarget:GetPosition(), tCurDestination)
    else
        iAngleToDestination = iCurFacingAngle
        tCurDestination = oTarget:GetPosition()
    end

    local oBP = oTarget:GetBlueprint()
    local iSpeed = oBP.Physics.MaxSpeed
    local iDistanceToRun = iTimeToDodge * iSpeed
    local iUnitSize = oBP.SizeX + oBP.SizeZ
    local iAngleAdjust = math.max(15, oBP.Physics.TurnRate * 0.3)
    if iUnitSize >= 2 then
        if iUnitSize >= 4 then iAngleAdjust = iAngleAdjust * 2.5
        else iAngleAdjust = iAngleAdjust * 1.75
        end
        if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oTarget.UnitId) then
            iAngleAdjust = math.min(iAngleAdjust, 30)
        end
    end
    if M28Utilities.GetAngleDifference(iCurFacingAngle + iAngleAdjust, iAngleToDestination) > M28Utilities.GetAngleDifference(iCurFacingAngle - iAngleAdjust, iAngleToDestination) then
        iAngleAdjust = iAngleAdjust * -1
    end

    local tTempDestination = M28Utilities.MoveInDirection(oTarget:GetPosition(), iCurFacingAngle + iAngleAdjust, iDistanceToRun, true, false, true)
    if bDebugMessages == true then LOG(sFunctionRef..': oTarget (ie unit that is dodging)='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; clearing current orders which have a possible destination of '..repru(tCurDestination)..'; and giving an order to move to '..repru(tTempDestination)..'; Dist from our position to temp position='..M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), tTempDestination)..'; iAngleAdjust='..iAngleAdjust..'; Unit size='..iUnitSize..'; iTimeToDodge='..iTimeToDodge) end
    M28Orders.IssueTrackedClearCommands(oTarget)
    TrackTemporaryUnitMicro(oTarget, iTimeToDodge)
    M28Orders.IssueTrackedMove(oTarget, tTempDestination, 0.25, false, 'MiDod1', true)
    --Also send an order to go to the destination that we had before
    if bAttackMove then
        M28Orders.IssueTrackedAttackMove(oTarget, tCurDestination, 0.25, true, 'MiDod2', true)
    else
        M28Orders.IssueTrackedMove(oTarget, tCurDestination, 0.25, true, 'MiDod3', true)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TrackTemporaryUnitMicro(oUnit, iSecondsActiveFor, sAdditionalTrackingVar)
    --Where we are doing all actions upfront can call this to enable micro and then turn the flag off after set period of time
    --Note that air logic currently doesnt make use of this
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TrackTemporaryUnitMicro'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    oUnit[M28UnitInfo.refbSpecialMicroActive] = true
    oUnit[M28UnitInfo.refiGameTimeMicroStarted] = GetGameTimeSeconds()
    oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] = GetGameTimeSeconds() + iSecondsActiveFor
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[M28UnitInfo.refbSpecialMicroActive]='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive] or false)..'; oUnit[M28UnitInfo.refiGameTimeMicroStarted]='..oUnit[M28UnitInfo.refiGameTimeMicroStarted]..'; oUnit[M28UnitInfo.refiGameTimeToResetMicroActive]='..oUnit[M28UnitInfo.refiGameTimeToResetMicroActive]..'; iSecondsActiveFor='..iSecondsActiveFor) end
    ForkThread(ForkedResetMicroFlag, oUnit, iSecondsActiveFor - 0.01, sAdditionalTrackingVar)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ForkedResetMicroFlag(oUnit, iTimeToWait, sAdditionalTrackingVar)
    oUnit[M28UnitInfo.refbSpecialMicroActive] = true --As if we are calling an action for the micro that clears commands, then that will reset the micro flag
    WaitSeconds(iTimeToWait)
    if M28UnitInfo.IsUnitValid(oUnit) then
        if GetGameTimeSeconds() + 0.02 > oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] or not(oUnit[M28UnitInfo.refbSpecialMicroActive]) then
            oUnit[refbMicroResetChecker] = nil
            oUnit[M28UnitInfo.refbSpecialMicroActive] = false
            if sAdditionalTrackingVar then
                oUnit[sAdditionalTrackingVar] = false
            end
        else
            if not(oUnit[refbMicroResetChecker]) then
                oUnit[refbMicroResetChecker] = true
                ForkThread(ForkedResetMicroFlag,oUnit, oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] - GetGameTimeSeconds() + 0.01, sAdditionalTrackingVar)
            end
        end
    end
end

function ForkedMoveInCircle(oUnit, iTimeToRun, bDontTreatAsMicroAction, bDontClearCommandsFirst, iCircleSizeOverride, iTickWaitOverride)
    --More intensive version of MoveAwayFromTargetTemporarily, intended e.g. for ACUs
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ForkedMoveInCircle'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local refbActiveCircleMicro = 'M28MicroActiveCircleMicro'

    if bDebugMessages == true then LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..'; Unit has active circle micro='..tostring(oUnit[refbActiveCircleMicro] or false)) end
    if not(oUnit[refbActiveCircleMicro]) then

        --KEY CONFIG SETTINGS: (these will work sometimes but not always against an aeon strat)
        local iInitialAngleAdj = 15
        local iInitialDistanceAdj = -1
        local iDistanceAwayToMove = (iCircleSizeOverride or 2)
        local iAngleMaxSingleAdj = 45
        local iTicksBetweenOrders = (iTickWaitOverride or 4)

        if iDistanceAwayToMove > oUnit:GetBlueprint().Physics.MaxSpeed * 1.5 then
            iAngleMaxSingleAdj = math.max(25, iAngleMaxSingleAdj * 2.5 / iDistanceAwayToMove)
        end



        local iStartTime = GetGameTimeSeconds()
        oUnit[M28UnitInfo.refiGameTimeMicroStarted] = iStartTime
        local iLoopCount = 0
        local iMaxLoop = iTimeToRun * 10 + 1
        --Distance from point A to point B will be much less than distanceaway to move, since that is the distance from the centre (radius) rather than the distance between 1 points on the circle edge; for simplicity will assume that distance is 0.25 of the distance from the centre
        if bDontTreatAsMicroAction then iMaxLoop = math.ceil(iTimeToRun / (iDistanceAwayToMove / oUnit:GetBlueprint().Physics.MaxSpeed)) * 4 end
        local tUnitStartPosition = oUnit:GetPosition()

        local iCurFacingDirection = M28UnitInfo.GetUnitFacingAngle(oUnit)
        local iAngleAdjFactor = 1

        local tTempLocationToMove

        local bRecentMicro = false
        local iRecentMicroThreshold = 1
        local iGameTime = GetGameTimeSeconds()
        if oUnit[M28UnitInfo.refbSpecialMicroActive] and iGameTime - oUnit[M28UnitInfo.refiGameTimeMicroStarted] < iRecentMicroThreshold then bRecentMicro = true end
        if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop for move commands for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTimeToRun='..iTimeToRun..'; iStartTime='..iStartTime..'; iCurFacingDirection='..iCurFacingDirection..'; tUnitStartPosition='..repru(tUnitStartPosition)..'; bRecentMicro='..tostring((bRecentMicro or false))..'; bDontClearCommandsFirst='..tostring(bDontClearCommandsFirst or false)..'; oUnit[M28UnitInfo.refbSpecialMicroActive]='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive])..'; oUnit[M28UnitInfo.refiGameTimeMicroStarted]='..(oUnit[M28UnitInfo.refiGameTimeMicroStarted] or 'nil')..'; GameTime='..iGameTime..'; Dif='..iGameTime-(oUnit[M28UnitInfo.refiGameTimeMicroStarted] or 0)..'; bDontTreatAsMicroAction='..tostring((bDontTreatAsMicroAction or false))) end
        if bRecentMicro == false and not(bDontClearCommandsFirst) then
            M28Orders.IssueTrackedClearCommands(oUnit)
            if bDebugMessages == true then LOG(sFunctionRef..': Issued clear commands order to the unit') end
        end
        if not(bDontTreatAsMicroAction) then
            TrackTemporaryUnitMicro(oUnit, iTimeToRun, refbActiveCircleMicro)
            if bDebugMessages == true then LOG(sFunctionRef..': Will temporarily track the unit micro. iTimeToRun='..(iTimeToRun or 'nil')) end
        else
            TrackTemporaryUnitMicro(oUnit, iTimeToRun)
        end

        local iTempAngleDirectionToMove = iCurFacingDirection + iInitialAngleAdj * iAngleAdjFactor
        local iTempDistanceAwayToMove
        local bTimeToStop = false
        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; refbSpecialMicroActive='..tostring((oUnit[M28UnitInfo.refbSpecialMicroActive] or false))..'; iMaxLoop='..iMaxLoop) end
        while bTimeToStop == false do
            iLoopCount = iLoopCount + 1
            if iLoopCount > iMaxLoop then break
            elseif M28UnitInfo.IsUnitValid(oUnit) == false then break end --No longer give error message as may be calling this for intel scouts now

            iTempAngleDirectionToMove = iTempAngleDirectionToMove + iAngleMaxSingleAdj * iAngleAdjFactor
            if iTempAngleDirectionToMove > 360 then iTempAngleDirectionToMove = iTempAngleDirectionToMove - 360 end
            --end
            iTempDistanceAwayToMove = iDistanceAwayToMove
            if iLoopCount == 1 then iTempDistanceAwayToMove = iDistanceAwayToMove + iInitialDistanceAdj end
            tTempLocationToMove = M28Utilities.MoveInDirection(tUnitStartPosition, iTempAngleDirectionToMove, iTempDistanceAwayToMove, true, false, true)
            M28Orders.IssueTrackedMove(oUnit, tTempLocationToMove, 0.25, true, 'MiCirc1', true)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(iTicksBetweenOrders)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if not(bDontTreatAsMicroAction) and not((oUnit[M28UnitInfo.refiGameTimeMicroStarted] == iStartTime and GetGameTimeSeconds() - iStartTime < iTimeToRun)) then bTimeToStop = true end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MoveInCircleTemporarily(oUnit, iTimeToRun, bDontTreatAsMicroAction, bDontClearCommandsFirst, iCircleSizeOverride, iTickWaitOverride)
    ForkThread(ForkedMoveInCircle, oUnit, iTimeToRun, bDontTreatAsMicroAction, bDontClearCommandsFirst, iCircleSizeOverride, iTickWaitOverride)
end

function GetOverchargeTarget(tLZData, aiBrain, oUnitWithOvercharge, bOnlyConsiderEnemiesInRange)
    --should have already confirmed overcharge action is available using CanUnitUseOvercharge
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetOverchargeTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
    --Do we have positive energy income? If not, then only overcharge if ACU is low on health as an emergency
    local oOverchargeTarget
    local reftiAngleFromACUToUnit = 'M28AngleFromACUToUnit'
    local reftiDistFromACUToUnit = 'M28DistFromACUToUnit'
    local toStructuresAndACU

    --Subfunction
    function IsBuildingOrACUBlockingShot(oFiringUnit, oTargetUnit)
        --Assumes have already been through tBlockingUnits and set their angle to the firing unit, so we just need to compare to firing unit
        if bDebugMessages == true then LOG(sFunctionRef..': Will see if any buildings or ACU are blocking the shot; if dont get log saying result was false then means was true') end
        if M28Utilities.IsTableEmpty(toStructuresAndACU) == false then
            local iAngleToTargetUnit = M28Utilities.GetAngleFromAToB(oFiringUnit:GetPosition(), oTargetUnit:GetPosition())
            local iDistToTargetUnit = M28Utilities.GetDistanceBetweenPositions(oFiringUnit:GetPosition(), oTargetUnit:GetPosition())
            local iCurAngleDif
            if bDebugMessages == true then LOG(sFunctionRef..': iAngleToTargetUnit='..iAngleToTargetUnit..'; iDistToTargetUnit='..iDistToTargetUnit) end
            for iUnit, oUnit in toStructuresAndACU do
                if not(oUnit == oTargetUnit) and iDistToTargetUnit > oUnit[reftiDistFromACUToUnit][aiBrain:GetArmyIndex()] then
                    iCurAngleDif = iAngleToTargetUnit - oUnit[reftiAngleFromACUToUnit][aiBrain:GetArmyIndex()]
                    if iCurAngleDif < 0 then iCurAngleDif = iCurAngleDif + 360 end
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' will block a shot from the ACU to the target '..oTargetUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTargetUnit)..'; iCurAngleDif='..iCurAngleDif..'; 180 / iDistToTargetUnit='..180 / iDistToTargetUnit..'; oUnit[reftiAngleFromACUToUnit][aiBrain:GetArmyIndex()]='..oUnit[reftiAngleFromACUToUnit][aiBrain:GetArmyIndex()]..'; oUnit[reftiDistFromACUToUnit]='..oUnit[reftiDistFromACUToUnit][aiBrain:GetArmyIndex()]..'; angle from ACU to unit='..oUnit[reftiAngleFromACUToUnit][aiBrain:GetArmyIndex()]) end
                    if iCurAngleDif <= math.max(8, 180 / iDistToTargetUnit) then
                        return true
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': End of code, will return false') end
        return false
    end

    --Subfunction
    function WillShotHit(oFiringUnit, oTargetUnit)
        --Check for units in a transport
        if oTargetUnit:IsUnitState('Attached') or M28Logic.IsShotBlocked(oFiringUnit, oTargetUnit) or IsBuildingOrACUBlockingShot(oFiringUnit, oTargetUnit) then
            if bDebugMessages == true then LOG(sFunctionRef..': oTargetUnit='..oTargetUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTargetUnit)..'; shot is blocked so wont hit. IsShotBlocked='..tostring(M28Logic.IsShotBlocked(oFiringUnit, oTargetUnit))) end
            return false
        else return true
        end
    end

    local tUnitPosition = oUnitWithOvercharge:GetPosition()
    local iACURange = oUnitWithOvercharge[M28UnitInfo.refiDFRange]
    local iOverchargeArea = 2.5

    --First locate where any blocking units are - will assume non-wall structures larger than a T1 pgen will block the shot, and ACUs will block
    local iMaxSearchDistance
    if bOnlyConsiderEnemiesInRange then iMaxSearchDistance = iACURange - 1
    else iMaxSearchDistance = 50
    end
    toStructuresAndACU = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure - categories.SIZE4 + categories.COMMAND, tUnitPosition, iMaxSearchDistance, 'Enemy')

    if bDebugMessages == true then LOG(sFunctionRef..': First locating blocking units; is table empty='..tostring(M28Utilities.IsTableEmpty(toStructuresAndACU))..'; iACURange='..iACURange..'; iOverchargeArea='..iOverchargeArea) end
    if M28Utilities.IsTableEmpty(toStructuresAndACU) == false then
        for iUnit, oUnit in toStructuresAndACU do
            if not(oUnit[reftiAngleFromACUToUnit]) then
                oUnit[reftiAngleFromACUToUnit] = {}
                oUnit[reftiDistFromACUToUnit] = {}
            end
            oUnit[reftiAngleFromACUToUnit][aiBrain:GetArmyIndex()] = M28Utilities.GetAngleFromAToB(tUnitPosition, oUnit:GetPosition())
            oUnit[reftiDistFromACUToUnit][aiBrain:GetArmyIndex()] = M28Utilities.GetDistanceBetweenPositions(tUnitPosition, oUnit:GetPosition())
            if bDebugMessages == true then LOG(sFunctionRef..': Angle from oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to our ACU='..repru(oUnit[reftiAngleFromACUToUnit])..'; distance='..repru(oUnit[reftiDistFromACUToUnit])) end

            --If enemy ACU is nearby and low health then target as top priority
            if oUnit[reftiDistFromACUToUnit][aiBrain:GetArmyIndex()] < (iACURange - 2) and EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and oUnit:GetHealth() < 1400 then
                oOverchargeTarget = oUnit
            end
        end
    end


    if not(oOverchargeTarget) then
        --Cycle through every land combat non-ACU unit within firing range to see if can find one that reduces the damage the most, or failing that does the most mass damage; will include all navy on the assumption isshotblocked will trigger if shot will go underwater (as otherwise we might ignore sera T2 destroyers)
        local tEnemyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand - categories.COMMAND + M28UnitInfo.refCategoryPD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryAllNavy, tUnitPosition, iACURange - 1, 'Enemy')

        local iMostMassDamage = 0
        local oMostMassDamage, iKillsExpected
        local iMaxOverchargeDamage = (aiBrain:GetEconomyStored('ENERGY') * 0.9) * 0.25
        local iCurDamageDealt, iCurKillsExpected
        if bDebugMessages == true then LOG(sFunctionRef..': Will consider enemy mobile units and PD within 2 of the ACU max range; is the table empty='..tostring(M28Utilities.IsTableEmpty(tEnemyUnits))) end
        if M28Utilities.IsTableEmpty(tEnemyUnits) == false then
            for iUnit, oUnit in tEnemyUnits do
                if WillShotHit(oUnitWithOvercharge, oUnit) then
                    iCurDamageDealt, iCurKillsExpected = M28Logic.GetDamageFromOvercharge(aiBrain, oUnit, iOverchargeArea, iMaxOverchargeDamage)
                    if bDebugMessages == true then LOG(sFunctionRef..': Shot will hit enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; damage result='..iCurDamageDealt) end
                    if iCurDamageDealt > iMostMassDamage then
                        iMostMassDamage = iCurDamageDealt
                        oMostMassDamage = oUnit
                        iKillsExpected = iCurKillsExpected

                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished searching through enemy mobile untis and PD in range, iMostMassDamage='..iMostMassDamage..'; iKillsExpected='..(iKillsExpected or 0)..'; Energy stored %='..aiBrain:GetEconomyStoredRatio('ENERGY')..'; E stored='..aiBrain:GetEconomyStored('ENERGY')) end

        --if iMostMobileCombatMassDamage >= 80 then
        --    oOverchargeTarget = oMostCombatMassDamage
        if iMostMassDamage >= 200 or iKillsExpected >= 3 or (iKillsExpected >= 1 and iMostMassDamage >= 100) or (iMostMassDamage >= 60 and aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.9 and (aiBrain:GetEconomyStored('ENERGY') >= 10000 or (aiBrain[M28Economy.refiNetEnergyBaseIncome] >= 1 and aiBrain:GetEconomyStored('ENERGY') >= 8000))) then --e.g. striker is 56 mass; lobo is 36
            oOverchargeTarget = oMostMassDamage
            if bDebugMessages == true then LOG(sFunctionRef..': Have a mobile or PD unit in range that will do enough damage to, oOverchargeTarget='..oOverchargeTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOverchargeTarget)) end
        else
            --Check we aren't running before considering whether to target walls or T2 PDs
            if GetGameTimeSeconds() - (oUnitWithOvercharge[M28ACU.refiTimeLastWantedToRun] or -30) >= 30 then
                --No decent combat targets; Check for lots of walls that might be blocking our path (dont reduce ACU range given these are structures)
                --Only consider overcharging walls if no enemies within our combat range + 3
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPlayerWallSegments]) == false and table.getn(tLZData[M28Map.subrefLZPlayerWallSegments]) >= 9 then
                    local tAllEnemies = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryNavalSurface, tUnitPosition, math.min(iMaxSearchDistance, iACURange + 3), 'Enemy')
                    if M28Utilities.IsTableEmpty(tAllEnemies) then
                        tEnemyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryWall, tUnitPosition, iACURange, 'Enemy')
                        if bDebugMessages == true then LOG(sFunctionRef..': iMostMassDamage='..iMostMassDamage..'; so will check for walls and other structure targets; is table of wall units empty='..tostring(M28Utilities.IsTableEmpty(tEnemyUnits))) end
                        if M28Utilities.IsTableEmpty(tEnemyUnits) == false and table.getn(tEnemyUnits) >= 5 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have at least 5 wall units in range, so potential blockage; size='..table.getn(tEnemyUnits)) end
                            local bSuspectedPathBlock = false
                            --If more than 10 then assume blocking our path

                            if table.getn(tEnemyUnits) >= 10 then
                                if bDebugMessages == true then LOG(sFunctionRef..': At least 10 wall units so assuming a blockage') end
                                bSuspectedPathBlock = true
                            else
                                local tFirstWall = tEnemyUnits[1]:GetPosition()
                                for iWall, oWall in tEnemyUnits do
                                    if iWall > 1 then
                                        if M28Utilities.GetDistanceBetweenPositions(oWall:GetPosition(), tFirstWall) >= 4 then
                                            bSuspectedPathBlock = true
                                            break
                                        end
                                    end
                                end
                            end
                            if bSuspectedPathBlock then
                                if bDebugMessages == true then LOG(sFunctionRef..': Think enemy has walls in a line so will overcharge them unless they are all closer to our base than us') end
                                iMostMassDamage = 0
                                oMostMassDamage = nil
                                bSuspectedPathBlock = false

                                local iOurDistToBase = M28Utilities.GetDistanceBetweenPositions(tUnitPosition, M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()])
                                local iWallDistToBase
                                for iWall, oUnit in tEnemyUnits do
                                    if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()]) <= iOurDistToBase + 4 then
                                        bSuspectedPathBlock = true
                                        break
                                    end
                                end
                                if bSuspectedPathBlock then
                                    for iWall, oUnit in tEnemyUnits do
                                        if WillShotHit(oUnitWithOvercharge, oUnit) then
                                            iCurDamageDealt = M28Logic.GetDamageFromOvercharge(aiBrain, oUnit, iOverchargeArea, iMaxOverchargeDamage, true)
                                            if iCurDamageDealt > iMostMassDamage then
                                                iMostMassDamage = iCurDamageDealt
                                                oMostMassDamage = oUnit
                                            end
                                        end
                                    end
                                    if oMostMassDamage then oOverchargeTarget = oMostMassDamage end
                                elseif bDebugMessages == true then LOG(sFunctionRef..': Walls are all closer to our base than we are so probably not blocking us')
                                end
                            elseif bDebugMessages == true then LOG(sFunctionRef..': Dont think the walls are in a line so wont try and OC')
                            end
                        end
                    end
                end
                if not(oOverchargeTarget) then
                    --Check further away incase enemy has T2 PD that can see us
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if any T2 PD further away') end
                    tEnemyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryT2PlusPD, tUnitPosition, iMaxSearchDistance, 'Enemy')
                    if M28Utilities.IsTableEmpty(tEnemyUnits) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have enemy T2 defence that can hit us but is out of our range - considering if OC it will bring us in range of T1 PD, and/or if shot is blocked, and/or if the T2PD cant even see us') end
                        local tNearbyT1PD
                        local iNearestT1PD = 10000
                        local iCurDistance
                        if 50 - iACURange > 0 then tNearbyT1PD = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryPD * categories.TECH1, tUnitPosition, 50 - iACURange, 'Enemy') end
                        if M28Utilities.IsTableEmpty(tNearbyT1PD) == false then
                            for iT1PD, oT1PD in tNearbyT1PD do
                                iCurDistance = M28Utilities.GetDistanceBetweenPositions(oT1PD:GetPosition(), tUnitPosition)
                                if iCurDistance < iNearestT1PD then iNearestT1PD = iCurDistance end
                            end
                        end

                        for iUnit, oEnemyT2PD in tEnemyUnits do
                            --Can we get in range of the T2 PD without getting in range of the T1 PD? (approximates just based on distances rather than considering the likely path to take)
                            if M28Utilities.GetDistanceBetweenPositions(oEnemyT2PD:GetPosition(), tUnitPosition) - iACURange + 2 < iNearestT1PD then
                                if M28Logic.IsShotBlocked(oUnitWithOvercharge, oEnemyT2PD) == false then
                                    --Can the T2 PD see us?
                                    if M28Conditions.CanSeeUnit(oEnemyT2PD:GetAIBrain(), oUnitWithOvercharge, true) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Setting target to T2 PD') end
                                        oOverchargeTarget = oEnemyT2PD
                                        break
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy T2 PDs owner can see our ACU') end
                                    end
                                end
                            end
                        end
                    end
                end
                if not(oOverchargeTarget) then
                    --Consider all structures (can do ACU max range since before when structures were considered we were looking at reduced range)
                    tEnemyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure, tUnitPosition, iACURange, 'Enemy')
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering all enemy structures within range of ACU; is table empty='..tostring(M28Utilities.IsTableEmpty(tEnemyUnits))) end
                    --local iMostMobileCombatMassDamage = 0
                    --local oMostCombatMassDamage
                    if M28Utilities.IsTableEmpty(tEnemyUnits) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering other enemy structures in range; iMostMassDamage before looking='..iMostMassDamage) end
                        for iUnit, oUnit in tEnemyUnits do
                            if WillShotHit(oUnitWithOvercharge, oUnit) then
                                iCurDamageDealt, iCurKillsExpected = M28Logic.GetDamageFromOvercharge(aiBrain, oUnit, iOverchargeArea, iMaxOverchargeDamage)
                                if bDebugMessages == true then LOG(sFunctionRef..': Shot will hit enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; damage result='..iCurDamageDealt) end
                                if iCurDamageDealt > iMostMassDamage then
                                    iMostMassDamage = iCurDamageDealt
                                    oMostMassDamage = oUnit
                                    iKillsExpected = iCurKillsExpected
                                end
                            end
                        end
                    end
                    if iMostMassDamage >= 110 then
                        oOverchargeTarget = oMostMassDamage
                    end
                end
            end
        end
    end
    if oOverchargeTarget == nil then
        if bDebugMessages == true then LOG(sFunctionRef..': No OC targets found') end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Overcharge target='..oOverchargeTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOverchargeTarget)) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oOverchargeTarget
end

function TurnAirUnitAndMoveToTarget(aiBrain, oBomber, tDirectionToMoveTo, iMaxAcceptableAngleDif, iOptionalSecondsToMoveAtEndIfFarFromTarget)
    --Based on hoverbomb logic - may give unexpected results if not using with T3 bombers
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TurnAirUnitAndMoveToTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oBomber='..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; GameTime='..GetGameTimeSeconds()) end


    local iStartTime = GetGameTimeSeconds()
    --local iAngleToTarget

    --Config:
    local iTicksBetweenOrders = 5
    local iDistanceAwayToMove = 10
    local iAngleAdjust = 50


    --Other variables:
    local iActualAngleToUse
    local iCurAngleDif
    local iAngleAdjustToUse
    local iFacingDirection
    local iAngleToTarget

    local iCurTick = 0
    local bTriedMovingForwardsAndTurning = false
    local iDistToTarget
    local tTempTarget

    local iMaxMicroTime = 5 --will micro for up to 5 seconds
    if EntityCategoryContains(categories.EXPERIMENTAL, oBomber.UnitId) then iMaxMicroTime = 10 end


    local iFacingAngleWanted = M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), tDirectionToMoveTo)

    --Clear trackers so we dont think we're targeting anything - commented out as this is called via the clearairunitassignmenttracker so causes issues
    --M27AirOverseer.ClearAirUnitAssignmentTrackers(aiBrain, oBomber, true)
    TrackTemporaryUnitMicro(oBomber, 60) --60s is redundancy



    while GetGameTimeSeconds() - iStartTime < iMaxMicroTime do
        iCurTick = iCurTick + 1

        iFacingDirection = M28UnitInfo.GetUnitFacingAngle(oBomber)
        iAngleToTarget = M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), tDirectionToMoveTo)
        iCurAngleDif = iFacingDirection - iAngleToTarget
        iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oBomber:GetPosition(), tDirectionToMoveTo)
        --e.g. if bomber is facing 350 degrees, and the target is at 10 degrees, then it means there's only a dif of 20 degrees, but we want the bomber to go 350+50, rather than 350-50.  Facing - Angle would result in a positive value
        --if instead bomber was facing 10 degrees, and the target was 30 degrees, then would get -20 as the result, and so want to also increase
        --the effect of the below is that when bomber is facing 350 degrees and target 10 degrees, it will treat the difference as being 350 - 10 - 360 = -20, and want the bomber to go 350+50; if insteadbomber 10 and target 30, then dif = -20 and no adjustment made
        if math.abs(iCurAngleDif) > 180 then
            if iCurAngleDif > 180 then
                --iFacingDirection is too high so decrease the angle difference
                iCurAngleDif = iCurAngleDif - 360
            else --Curangledif must be < -180, so angletotarget is too high
                iCurAngleDif = iCurAngleDif + 360
            end
        end


        if iCurAngleDif < 0 then
            iAngleAdjustToUse = iAngleAdjust
        else iAngleAdjustToUse = -iAngleAdjust
        end

        --Are we close enough to the direction wanted?
        iCurAngleDif = math.abs(iCurAngleDif)
        if iCurAngleDif <= (iMaxAcceptableAngleDif or 15) then
            --Are close enough in angle so can stop the micro
            break
        else
            if iCurTick == 1 then
                iActualAngleToUse = iFacingDirection + iAngleAdjustToUse
                tTempTarget = M28Utilities.MoveInDirection(oBomber:GetPosition(), iActualAngleToUse, iDistanceAwayToMove, true, false, true)
                M28Orders.IssueTrackedMove(oBomber, tTempTarget, 0, false, 'BMicrM', true)
                if bDebugMessages == true then LOG(sFunctionRef..': Just issued move order, iFacingDirection='..iFacingDirection..'; iCurANgleDif='..iCurAngleDif..'; iAngleAdjustToUse='..iAngleAdjustToUse..'; iActualAngleToUse='..iActualAngleToUse..'; angle from bomber to target='..M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), tDirectionToMoveTo)) end
            elseif iCurTick >= iTicksBetweenOrders then iCurTick = 0
            end

            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if not(M28UnitInfo.IsUnitValid(oBomber)) then
                break
            end
        end
    end

    if M28UnitInfo.IsUnitValid(oBomber) then
        M28Orders.IssueTrackedMove(oBomber, tDirectionToMoveTo, 5, false, 'BMicMTR', true)
        if bDebugMessages == true then LOG(sFunctionRef..': Just cleared bomber '..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..' commands and told it to move to '..repru(tDirectionToMoveTo)..'; GameTime='..GetGameTimeSeconds()..'; iOptionalSecondsToMoveAtEndIfFarFromTarget='..(iOptionalSecondsToMoveAtEndIfFarFromTarget or 'nil')) end
        if iOptionalSecondsToMoveAtEndIfFarFromTarget then
            local iTimeToWait = math.min(iOptionalSecondsToMoveAtEndIfFarFromTarget, M28Utilities.GetDistanceBetweenPositions(oBomber:GetPosition(), tDirectionToMoveTo) / (oBomber:GetBlueprint().Physics.MaxSpeed or 10))
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(iOptionalSecondsToMoveAtEndIfFarFromTarget)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        
        oBomber[M28UnitInfo.refbSpecialMicroActive] = false
        oBomber[M28UnitInfo.refiGameTimeToResetMicroActive] = GetGameTimeSeconds()        
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MoveAwayFromFactory(oUnit, oFactory)
    if EntityCategoryContains(categories.STRUCTURE, oFactory.UnitId) then --and not(EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId)) then
        local aiBrain = oFactory:GetAIBrain()
        if aiBrain.M28AI then --redundancy
            local iTeam = aiBrain.M28Team
            local tLZOrWZData, tLZOrWZTeamData
            local iPlateauOrZero, iLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oFactory:GetPosition())
            if iLZOrWZ > 0 then
                if iPlateauOrZero == 0 then
                    tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLZOrWZ]][M28Map.subrefPondWaterZones][iLZOrWZ]
                    tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                else
                    tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLZOrWZ]
                    tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                end
                if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) == false then
                    local iFactorySize = M28UnitInfo.GetBuildingSize(oFactory.UnitId)
                    local tOrderPosition = M28Utilities.MoveInDirection(oFactory:GetPosition(), M28Utilities.GetAngleFromAToB(oFactory:GetPosition(), tLZOrWZTeamData[M28Map.reftClosestEnemyBase]), iFactorySize + 2, true, false, true)
                    M28Orders.IssueTrackedMove(oUnit, tOrderPosition, 0, false, 'JustBuilt', true)
                    TrackTemporaryUnitMicro(oUnit, 1.5)
                end

            end
        end
    end
end