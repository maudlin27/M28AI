---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 01/12/2022 08:18
---

local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
--Dont include m28factory or m28engineer here or will get a crash at start of the game

--global (non-category) varaibles:
--Threat values
tUnitThreatByIDAndType = {} --Calculated at the start of the game
tiThreatRefsCalculated = {} --table of the threat ID references that have done blueprint checks on

tbBuildOnLandLayerCaps = {['Land'] = true, ['Air'] = true, ['9'] = true, ['3'] = true, ['11'] = true} --used to translate the result of UnitBlueprint.Physics.BuildOnLayerCaps which doesnt return the table shown in the blueprint but instead returns one of these values (or 'Air' - which is what a czar returns)
tbBuildOnWaterLayerCaps = {['Water'] = true, ['9'] = true, ['3'] = true, ['11'] = true, ['12'] = true}

bDontConsiderCombinedArmy = true --shares same desc as M28Orders (for easier referencing)
iBaseACUThreat = 1000 --i.e. approx 20 tanks
iBaseACUExpectedHealth = 11000 --Used so we can adjust iBaseACUThreat to allow for mods that give high health to ACUs (up to double threat)

--Factions
refFactionUEF = 1
refFactionAeon = 2
refFactionCybran = 3
refFactionSeraphim = 4
refFactionNomads = 5
refFactionUnrecognised = 6
tFactionsByName = {[refFactionUEF] = 'UEF', [refFactionAeon] = 'Aeon', [refFactionCybran] = 'Cybran', [refFactionSeraphim] = 'Seraphim', [refFactionNomads] = 'Nomads'}

--Radar values per blueprints (gets updated at start of game)
iT1RadarSize = 1
iT2RadarSize = 1
iT3RadarSize = 1

--Transport clamp types
refClampSmall = 1
refClampMedium = 2
refClampLarge = 3
refClampExperimental = 4 --Incase ever decide to support nomads experimental transports
refClampStinger = 5

--Variables against units;
refiLastWeaponEvent = 'M28LastWep' --Gametimeseconds that last updated onweapon
refiLastBombFired = 'M28LastBmb' --Gametimeseconds that last fired a bomb
refiLastDodgeBombEvent = 'M28LastDodB' --gametimeseconds that last triggered the onbombfired logic
reftLastKnownPositionByTeam = 'M28UnitLastPos' --[x] is the M28 team ref, returns the last known position of the unit
reftRecentUnitPositions = 'M28RcUnP' --[x] = 1, 2, 3; based on previous recorded positions; used for TML targeting logic; note that this isnt by team to reduce tables required, since if have multiple M28 then only the first one will try and record this in MonitorUnitRecentPositions
reftAssignedPlateauAndLandZoneByTeam = 'M28UnitPlateauAndZone' --[x] is the M28 team ref, returns a table {iPlateau, iLandZoneRef}
reftRecentPlateauAndZoneByTeam = 'M28UnitPrvPlatZ' --[x] is the preceding entry, returns {iPlateauOrZero, iLandOrWaterZoneRef}; will keep track of the last 8 changes (used to realise if a unit is stuck alternating between the same 2 zones)
refiPatrolStuckCount = 'M28UStCn' --number of times unit has been stuck patrolling
refbUnitStuckAlternating = 'M28UnitStckAlt' --true if the unit appears to be moving between the same two zones again and again
refiTimeLastTriedRetreating = 'M28UnitTimeLstRetr' --Gametimeseconds that unit last tried retreating
reftAssignedWaterZoneByTeam = 'M28UnitWaterZone' --[x] is the M28 team ref, returns the water zone assigned to the unit, if there is one
reftbConsideredForAssignmentByTeam = 'M28UnitConsideredForAssignment' --[x] is the M28 team ref, returns true if have sent at least once to be assigned to a plateau/land zone/air logic/navy logic
refiDFMassThreatOverride = 'M28BaseMassOverride' --e.g. for ACUs, will override the mass value suggested by the blueprint
refiAntiNavyMassThreatOverride = 'M28BNMTO' --e.g. for ACUs, so can differentiate between Cybran ACU with antinavy upgrade, and other ACUs
refbShieldIsDisabled = 'M28UnitShieldDisabled'
refbShieldDown = 'M28UShDw' --LOUD specific (as FAF has .enabled against the shield itself) - true if shield starts recharging, changed to false once at 100%
refbWaitForShieldToBeRestored = 'M28ShRsW' --true if a mobile shield should wait for its shield to almost fully recover before being assigned
refiTimeOfLastCheck = 'M28UnitTimeOfLastCheck' --Currently used for shot is blocked (M27 also used for T3 arti adjacency, when first detected enemy SMD)
refiTimeOfLastHoverLandCombatOrder = 'M28UnitTimeLstHCO' --hover units will only be given new orders every 6s to try and reduce cases where they end up not moving
refiTimeOfLastUnblockedShot = 'M28UnitTimeLastUnblockedShot'
refbLastShotBlocked = 'M28UnitLastShotBlocked' --Used for DF units to indicate if last shot was blocked
refbExpBomberShotBlocked = 'M28ULstExpBShtBlck' --true if an experimental bomber thinks a shot fired at this unit will be blocked
refiTargetShotBlockedCount = 'M28UnitTrgSBlC' --Number of times a long range unit has failed to hit this (used for naval units targeting structures - change how this is increased if want to expand usage)
refiTimeOfLastOverchargeShot = 'M28UnitTimeLastOvercharge' --Gametimeseconds
--refiFailedOCCount = 'M28UFlOCC' --intneded for QUIET - if we have tried overcharging a unit that is in our range and are firing our main gun instead then this will increase by 1
reftbInArmyIndexBigThreatTable = 'M28UnitInBigThreatTable' --[x] is army index; true if have added unit to table of big threats for that army index
refbConstructionStart = 'M28UnitConStrt' --True if constructionstarted event logic has been run for this unit
reftiTimeOfLastEnhancementComplete = 'M28TLstECmpl' --table, [x] = enhancement ID, gametimeseconds that the upgrade completed
refoClosestEnemyFromLastCloseToEnemyUnitCheck = 'M28ClEnU' --If running the 'close to enemy unit' check, this will retunr the closest enemy unit before the code aborts
refbUnitIsCloaked = 'M28UnitIsCloaked' --true if have triggered the 'cloaked unit identified' logic
refiTimeCreated = 'M28UntTimCr' --Gametimeseconds (rounded down) that unit was created
refiTimeMexConstructed = 'M28MxTimCn' --For mexes, records when it was constructed
refbIsCaptureTarget = 'M28UnitIsCapTrg' --true if we want to capture the unit
refbIsReclaimTarget = 'M28UnitIsReTrg' --true if have an objective to reclaim the unit; false if it mustnt be reclaimed (e.g. campaign objective to defend); nil otherwise
refiTeamsWithThisAsReclaimTarget = 'M28UnitTmsReclT' --[x] = 1,2,3...x; returns the M28Team ref (for any team that has this as a reclaim target via the normal 'on unit detected/add to zone' logic)
refiTimeLastDamaged = 'M28UnitTLsD' --Currently only used for shields and transports
reftLastLocationWhenGaveTeleportOrder = 'M28UnitTLoc' --lcoation when gave a teleport order, for if want to return here
reftActiveTeleportLocation = 'M28UnitTTrLoc' --Location of the last teleport command (for both M28 and non-M28 units)
refbTooMuchPDForSnipe = 'M28UnitTooMuchPD' --true if too much PD for a telesnipe attempt
refbTriedToKill = 'M28TryKill' --true if tried to kill unit
refiHealthWhenLastChecked = 'M28HlthCh' --Unit health when last checked - used for gunships
refiHealthSecondLastCheck = 'M28HlthSLC' --Unit health in the previous check - used for gunships
refbWantToHealUp = 'M28HlUp' --true if unit wants to rely on its regen to heal up - e.g. used for soulripper
refbObjectiveUnit = 'M28ObjU' --true if unit is being used for an objective
refbCampaignTriggerAdded = 'M28Trg' --true if a trigger has been recorded against the unit (may not be an objective unit, but will want to avoid e.g. ctrl-King if M28 owns it)
refbTransferredUnit = 'M28Xfer' --true if unit has been captured/transferred from its original owner
refbIsSnipeTarget = 'M28STrg' --true if is a snipe target
refiRecentBomberSnipeAttempts = 'M28BmSnAt' --number of times we have launched bombers thinking we will kill the target (resets after a long period of time)
toBombersPlanningSnipe = 'M28BmbSnT' --table of bombers that are building up in preparation for a snipe attempt on this unit
reftiTeamsRecordedAsNonM28Ally = 'M28TRNmA' --[x] = 1,2,3...' returns the iTeam value
refiUnitMassCost = 'M28UMCs' --for profiling testing
refbNonM28ExpConstruction = 'M28UUcE' --true if unit has been recorded against the table of non-M28 experimentals being constructed
refbHaveSeenUnitByTeam = 'M28UHvSn' --true if we have detected the unit in some way
refbScoutCombatOverride = 'M28ScCmO' --true if we want the scout to be treated as a normal combat unit

    --Unit micro related
refbEasyBrain = 'M28UEasAI' --True if the aiBrian owner is an M28Easy AI
refiGameTimeMicroStarted = 'M28UnitTimeMicroStarted' --Gametimeseconds that started special micro
refbSpecialMicroActive = 'M28UnitSpecialMicroActive'
refbLowerPriorityMicroActive = 'M28UnitLowerPriMicroAct' --true if the specialmicro has been flagged as lower priority
refiGameTimeToResetMicroActive = 'M28UnitTimeToResetMicro' --Gametimeseconds
refbWeaponDisabled = 'M28UnitWeaponDisabled' --True if unit weapon has been disabled by M28 code
refiTimeLastDisabledWeapon = 'M28UnitTimeDsblW' --Gametimeseconds that we wanted the unit's weapon to be disabled
refbLurkerMode = 'M28ULrkMd' --true if unit is adopting selen 'engi lurker' mode logic

    --Ranges and weapon details
refiWeaponScanRange = 'M28WpSRn' --I.e. the range the unit will move to for attack-move in LOUD; nil if unit doesnt have one
refiDFRange = 'M28UDFR' --(fatboy df range gets treated as range of its indirect cannons)
refiDFMinRange = 'M28DFMinRng' --Min range of a unit
refiDFAOE = 'M28AOEDF' --aoe of a df weapon of a unit
refiIndirectAOE = 'M28AOEIn' --aoe of an indirect weapon of a unit; includes manual ranges
refiIndirectRange = 'M28UIR' --for non-manual fire weapons
refiArtiMinRange = 'M28AtMR' --Only populated when used, e.g. used by T2 arti as part of t2 arti manual targeting logic
refiAntiNavyRange = 'M28UANR'
refiCombatRange = 'M28UCRN' --Higher of antinavy, indirectrange and dfrange for a unit
refiManualRange = 'M28UManR' --for manual fire weapons (e.g. TML)
refiMissileDefenceRange = 'M28UMDefR' --For SMD and TMD
refiAARange = 'M28UAAR'
refiBomberRange = 'M28UBR'
refbWeaponUnpacks = 'M28WUP'
refiTorpedoDefenceCount = 'M28TDef' --true if unit has torpedo defence
refiStrikeDamage = 'M28USD'
refbCanKite = 'M28CanKite' --true unless weapon unpacks or experimental with a weapon fixed to body (GC and megalith)
refiTimeBetweenDFShots = 'M28DFTime'
refiTimeBetweenIFShots = 'M28IFTime'
refiTimeBetweenAirAAShots = 'M28AATim' --intended for asfs that might be microing
refiTimeBetweenBombs = 'M28BmTime' --Time in seconds based on the bomb weapon's rate of fire
reftoEnemyProjectiles = 'M28UntProj' --table of projectiles targeting the unit
refbProjectilesMeanShouldRefuel = 'M28UnPrjRf' --true if we wanted the unit to refuel due to expected projectile damage
refbSniperRifleEnabled = 'M28UnitSniperRifleEnabled' --True if seraphim sniperbot has its long range sniperrifle enabled
refbAttackMoveInsteadOfKiting = 'M28UAMinK' --true if we want to attackmove instead of kiting due to not firing for a while

--Weapon priorities
refWeaponPriorityGunship = {'STRUCTURE EXPERIMENTAL, STRUCTURE ARTILLERY TECH3, ARTILLERY EXPERIMENTAL', 'MOBILE SHIELD', 'MOBILE ANTIAIR CRUISER', 'MOBILE ANTIAIR', 'ANTIAIR', 'STRUCTURE SHIELD', 'VOLATILE STRUCTURE', 'MASSEXTRACTION', 'VOLATILE MOBILE', 'COMMAND', 'GROUNDATTACK', 'TECH3 MOBILE', 'TECH2 MOBILE', 'TECH1 MOBILE', 'ALLUNITS'}
refWeaponPriorityGunshipShield = {'STRUCTURE EXPERIMENTAL, STRUCTURE ARTILLERY TECH3, ARTILLERY EXPERIMENTAL', 'STRUCTURE SHIELD', 'MOBILE SHIELD', 'MOBILE ANTIAIR CRUISER', 'MOBILE ANTIAIR', 'ANTIAIR', 'VOLATILE STRUCTURE', 'MASSEXTRACTION', 'VOLATILE MOBILE', 'COMMAND', 'GROUNDATTACK', 'TECH3 MOBILE', 'TECH2 MOBILE', 'TECH1 MOBILE', 'ALLUNITS'}
refWeaponPriorityGunshipSnipe = {'STRUCTURE EXPERIMENTAL, STRUCTURE ARTILLERY TECH3, ARTILLERY EXPERIMENTAL, COMMAND', 'STRUCTURE SHIELD', 'MOBILE SHIELD', 'MOBILE ANTIAIR CRUISER', 'MOBILE ANTIAIR', 'ANTIAIR', 'VOLATILE STRUCTURE', 'MASSEXTRACTION', 'VOLATILE MOBILE', 'GROUNDATTACK', 'TECH3 MOBILE', 'TECH2 MOBILE', 'TECH1 MOBILE', 'ALLUNITS'}
refWeaponPriorityDestroyer = {'SHIELD NAVAL', 'SHIELD MOBILE', 'SUBMERSIBLE', 'EXPERIMENTAL NAVAL, TECH3 NAVAL MOBILE', 'TECH2 NAVAL MOBILE', 'STRUCTURE SHIELD', 'STRUCTURE DEFENSE DIRECTFIRE TECH2, STRUCTURE DEFENSE DIRECTFIRE TECH3, STRUCTURE INDIRECTFIRE ARTILLERY', 'EXPERIMENTAL STRUCTURE, STRUCTURE TECH3 SILO, STRUCTURE TECH3 VOLATILE', 'MOBILE LAND EXPERIMENTAL, MOBILE LAND HOVER DIRECTFIRE', 'MASSPRODUCTION TECH2, MASSPRODUCTION TECH3', 'MOBILE LAND TECH3 DIRECTFIRE, MOBILE LAND TECH3 INDIRECTFIRE', 'EXPERIMENTAL', 'NAVAL', 'STRUCTURE', 'ALLUNITS'}
refWeaponPriorityBattleShip = {'EXPERIMENTAL NAVAL, TECH3 NAVAL', 'TECH2 NAVAL', 'STRUCTURE SHIELD', 'STRUCTURE INDIRECTFIRE ARTILLERY', 'EXPERIMENTAL STRUCTURE, STRUCTURE TECH3 SILO, STRUCTURE TECH3 VOLATILE', 'MOBILE LAND EXPERIMENTAL, MOBILE LAND TECH3 DIRECTFIRE, MOBILE LAND TECH3 INDIRECTFIRE', 'EXPERIMENTAL', 'NAVAL', 'STRUCTURE', 'ALLUNITS'}
refWeaponPriorityMissileShip = {'SHIELD STRUCTURE, ANTIMISSILE STRUCTURE', 'STRUCTURE INDIRECTFIRE ARTILLERY TECH2', 'EXPERIMENTAL STRUCTURE, STRUCTURE ARTILLERY TECH3, STRUCTURE TECH3 SILO', 'STRUCTURE TECH3 VOLATILE', 'STRUCTURE TECH3 ECONOMIC', 'STRUCTURE NAVAL TECH3, STRUCTURE NAVAL TECH2', 'STRUCTURE TECH3', 'STRUCTURE TECH2 ECONOMIC', 'STRUCTURE TECH2', 'STRUCTURE VOLATILE, STRUCTURE DEFENSE, STRUCTURE FACTORY, STRUCTURE INTELLIGENCE', 'STRUCTURE', 'NAVAL SHIELD', 'SHIELD', 'EXPERIMENTAL NAVAL', 'EXPERIMENTAL', 'TECH3 NAVAL', 'TECH2 NAVAL', 'INDIRECTFIRE NAVAL', 'TECH3', 'TECH2', 'ALLUNITS'}
refWeaponPrioritySub = {'SHIELD NAVAL', 'SHIELD MOBILE', 'SUBMERSIBLE', 'ANTINAVY SUBMERSIBLE MOBILE', 'ANTINAVY', 'ALLUNITS'}
refWeaponPriorityTeleSnipeInclACU = {'COMMAND', 'STRUCTURE EXPERIMENTAL, STRUCTURE ARTILLERY TECH3, ARTILLERY EXPERIMENTAL', 'STRUCTURE DEFENSE DIRECTFIRE TECH1', 'STRUCTURE DEFENSE DIRECTFIRE', 'STRUCTURE TECH3 ENERGYPRODUCTION, STRUCTURE TECH3 MASSFABRICATION', 'STRUCTURE TECH3 MASSEXTRACTION', 'ALLUNITS'}
refWeaponPriorityTeleSnipeExclACU = {'STRUCTURE EXPERIMENTAL, STRUCTURE ARTILLERY TECH3, ARTILLERY EXPERIMENTAL', 'COMMAND', 'STRUCTURE DEFENSE DIRECTFIRE TECH1', 'STRUCTURE DEFENSE DIRECTFIRE', 'STRUCTURE TECH3 ENERGYPRODUCTION, STRUCTURE TECH3 MASSFABRICATION', 'STRUCTURE TECH3 MASSEXTRACTION', 'ALLUNITS'}
refWeaponPriorityT2Arti = {'ARTILLERY EXPERIMENTAL', 'ARTILLERY STRUCTURE, SNIPER', 'SHIELD STRUCTURE', 'CRUISER, ANTISHIELD', 'INDIRECTFIRE', 'SHIELD', 'VOLATILE', 'TECH3 STRUCTURE', 'TECH3 MOBILE', 'ALLUNITS'}
refWeaponPriorityFatboy = {'ARTILLERY EXPERIMENTAL', 'STRUCTURE EXPERIMENTAL, STRUCTURE ARTILLERY TECH3, ARTILLERY EXPERIMENTAL', 'ARTILLERY STRUCTURE, SNIPER', 'SHIELD STRUCTURE', 'EXPERIMENTAL', 'MOBILE SHIELD, MOBILE ARTILLERY TECH3', 'MOBILE NAVAL TECH3, MOBILE NAVAL TECH2', 'MOBILE DIRECTFIRE TECH3', 'MOBILE ANTIAIR TECH3', 'VOLATILE', 'TECH3', 'TECH2', 'ALLUNITS'}
refWeaponPriorityMegalith = {'ARTILLERY EXPERIMENTAL', 'STRUCTURE EXPERIMENTAL, STRUCTURE ARTILLERY TECH3, ARTILLERY EXPERIMENTAL', 'ARTILLERY STRUCTURE, SNIPER', 'SHIELD STRUCTURE', 'EXPERIMENTAL', 'TECH3 STRUCTURE DEFENSE DIRECTFIRE', 'MOBILE SHIELD', 'MOBILE DIRECTFIRE TECH3', 'MOBILE ANTIAIR TECH3', 'VOLATILE', 'TECH3', 'TECH2', 'ALLUNITS'}
refWeaponPriorityACU = {'DIRECTFIRE TECH1 MOBILE, INDIRECTFIRE TECH1 MOBILE', 'DIRECTFIRE, INDIRECTFIRE MOBILE', 'MOBILE', 'ALLUNITS'}
refWeaponPriorityACUSnipe = {'COMMAND', 'DIRECTFIRE TECH1 MOBILE, INDIRECTFIRE TECH1 MOBILE', 'DIRECTFIRE, INDIRECTFIRE MOBILE', 'MOBILE', 'ALLUNITS'}
refbUsingDefaultWeaponPriority = 'M28UDfW' --true if using default weapon priroity (for unit with multiple options - e.g. gunships)

refbPaused = 'M28UnitPaused' --true if unit is paused
refiPausedPriority = 'M28UnitPsPr' --table index where the paused unit is s tored in team data
reftoUnitsAssistingThis = 'M28UnitsAssisting' --table of units given an order to guard this unit

--Categories:
--Buildings - eco
refCategoryMex = categories.STRUCTURE * categories.MASSEXTRACTION - categories.NAVAL --Some mods add a naval mex which causes issues as we will try and build on land mexes without naval exclusion
refCategoryT1Mex = refCategoryMex * categories.TECH1
refCategoryT2Mex = refCategoryMex * categories.TECH2
refCategoryT3Mex = refCategoryMex * categories.TECH3
refCategoryHydro = categories.HYDROCARBON - categories.NAVAL
refCategoryResourceUnit = categories.MASSPRODUCTION + categories.MASSFABRICATION + categories.ENERGYPRODUCTION --i.e. includes SACU
refCategoryProductionUnit = categories.ENGINEER + categories.FACTORY + categories.STRUCTURE * (categories.TECH2 + categories.TECH1) + categories.REPAIR + categories.SILO --i.e. includes buildings that can upgrade; done so if fixing a modifier it can affect build rate
if categories.urb4206 then refCategoryProductionUnit = refCategoryProductionUnit + categories.urb4206 end --ED4 shield

refCategoryPower = categories.STRUCTURE * categories.ENERGYPRODUCTION - categories.EXPERIMENTAL - categories.HYDROCARBON
refCategoryT1Power = categories.STRUCTURE * categories.ENERGYPRODUCTION * categories.TECH1 - categories.EXPERIMENTAL - categories.HYDROCARBON
refCategoryT2Power = categories.STRUCTURE * categories.ENERGYPRODUCTION * categories.TECH2 - categories.EXPERIMENTAL - categories.HYDROCARBON
refCategoryT3Power = categories.STRUCTURE * categories.ENERGYPRODUCTION * categories.TECH3 - categories.EXPERIMENTAL - categories.HYDROCARBON
refCategoryMassStorage = categories.STRUCTURE * categories.MASSSTORAGE * categories.TECH1

refCategoryEnergyStorage = categories.STRUCTURE * categories.ENERGYSTORAGE
refCategoryParagon = categories.STRUCTURE * categories.EXPERIMENTAL * categories.MASSPRODUCTION
refCategoryMassFab = categories.MASSFABRICATION * categories.STRUCTURE - categories.MASSEXTRACTION - categories.EXPERIMENTAL

--Building - intel and misc
refCategoryAirStaging = categories.STRUCTURE * categories.AIRSTAGINGPLATFORM
refCategoryRadar = categories.STRUCTURE * categories.RADAR + categories.STRUCTURE * categories.OMNI
refCategoryT1Radar = refCategoryRadar * categories.TECH1
refCategoryT2Radar = refCategoryRadar * categories.TECH2
refCategoryT3Radar = categories.TECH3 * categories.STRUCTURE * categories.OMNI -categories.FACTORY --+ categories.OMNI * categories.TECH3 (dont need this as refcategoryradar already includes omni)
refCategorySonar = categories.STRUCTURE * categories.SONAR + categories.MOBILESONAR
refCategoryT1Sonar = refCategorySonar * categories.TECH1
refCategoryT2Sonar = refCategorySonar * categories.TECH2
refCategoryT3Sonar = refCategorySonar * categories.TECH3
refCategoryStructure = categories.STRUCTURE - categories.WALL - categories.EXTERNALFACTORYUNIT
refCategoryWall = categories.STRUCTURE * categories.WALL --NOTE: Some walls are props; this is for if want a wall that can build
refCategoryUnitsWithOmni = categories.OMNI + categories.COMMAND + categories.OVERLAYOMNI


--Building - factory
refCategoryLandFactory = categories.LAND * categories.FACTORY * categories.STRUCTURE - categories.EXTERNALFACTORYUNIT
refCategoryLandHQ =refCategoryLandFactory - categories.SUPPORTFACTORY
refCategoryAirFactory = categories.AIR * categories.FACTORY * categories.STRUCTURE - categories.ORBITALSYSTEM - categories.EXTERNALFACTORYUNIT --Novax is an air factory, so excluded from being treated as an air factory by my logic
refCategoryAirHQ = refCategoryAirFactory - categories.SUPPORTFACTORY
refCategoryNavalFactory = categories.NAVAL * categories.FACTORY * categories.STRUCTURE - categories.EXTERNALFACTORYUNIT
refCategoryNavalHQ = refCategoryNavalFactory - categories.SUPPORTFACTORY
refCategoryMobileLandFactory = categories.LAND * categories.FACTORY * categories.STRUCTURE * categories.EXTERNALFACTORYUNIT
refCategorySpecialFactory = categories.FACTORY * categories.EXPERIMENTAL * categories.STRUCTURE - categories.EXTERNALFACTORYUNIT --e.g. novax centre (that can build novax)
if categories.seb3303 then
    refCategorySpecialFactory = refCategorySpecialFactory + categories.seb3303
    refCategoryLandFactory = refCategoryLandFactory - categories.seb3303
end
refCategoryFactory = refCategoryLandFactory + refCategoryAirFactory + refCategoryNavalFactory
refCategoryAllHQFactories = refCategoryFactory - categories.SUPPORTFACTORY
refCategoryQuantumGateway = categories.STRUCTURE * categories.GATE * categories.TECH3 * categories.FACTORY - categories.EXTERNALFACTORYUNIT

--Building - defensive
refCategoryT2PlusPD = categories.STRUCTURE * categories.DIRECTFIRE - categories.STRUCTURE * categories.DIRECTFIRE * categories.TECH1
refCategoryPD = categories.STRUCTURE * categories.DIRECTFIRE
refCategoryT3PD = refCategoryPD * categories.TECH3
refCategoryTMD = categories.STRUCTURE * categories.ANTIMISSILE - categories.SILO * categories.TECH3 --Not perfect but should pick up most TMD without picking up SMD
refCategoryFixedShield = categories.SHIELD * categories.STRUCTURE
refCategoryFixedT2Arti = categories.STRUCTURE * categories.INDIRECTFIRE * categories.ARTILLERY * categories.TECH2 - categories.TACTICALMISSILEPLATFORM + categories.STRUCTURE * categories.INDIRECTFIRE * categories.ARTILLERY * categories.TECH3 * categories.SIZE8 --done so mods like LOUD that add a t3 smaller arti can be built as well
refCategoryFixedT3Arti = categories.STRUCTURE * categories.INDIRECTFIRE * categories.ARTILLERY * categories.TECH3 - categories.SIZE8 --done to support mods (like in LOUD) that add a t3 arti unit like the t2 arti unit (rather than like a duke)


refCategoryExperimentalArti = categories.EXPERIMENTAL * categories.ARTILLERY - categories.MOBILE * categories.UEF - categories.MOBILE * categories.CYBRAN - categories.MOBILE * categories.AEON --e.g. one of the LOUD standard mods adds an aeon mobile experimental arti that has a short range
refCategorySML = categories.NUKE * categories.SILO
refCategorySMD = categories.ANTIMISSILE * categories.SILO * categories.TECH3 * categories.STRUCTURE
refCategoryTML = categories.SILO * categories.STRUCTURE * categories.TECH2 - categories.ANTIMISSILE
refCategoryUnitsWithTMLUpgrade = categories.COMMAND * categories.UEF + categories.COMMAND * categories.SERAPHIM + categories.SUBCOMMANDER * categories.SERAPHIM
refCategoryNovaxCentre = categories.EXPERIMENTAL * categories.STRUCTURE * categories.ORBITALSYSTEM - categories.OPTICS --OPTICS is contained in a 'spy plane novax' building in brewlan
refCategoryNovax = refCategoryNovaxCentre --had it happen too many timesn ow where forget to add centre
refCategorySatellite = categories.EXPERIMENTAL * categories.SATELLITE + categories.SATELLITE * categories.TECH1 * categories.AEON * categories.STRATEGIC --latter categories are for the blackops artemis satellite unit
--refCategorySAM = categories.ANTIAIR * categories.STRUCTURE * categories.TECH3
refCategoryQuantumOptics = categories.INTELLIGENCE * categories.OPTICS * categories.AEON * categories.STRUCTURE * categories.TECH3 - refCategoryRadar

refCategoryUpgraded = refCategoryT2Radar + refCategoryT3Radar + refCategoryT2Sonar + refCategoryT3Sonar + refCategoryFactory * categories.TECH2 + refCategoryFactory * categories.TECH3 + refCategoryFixedShield * categories.TECH3 + refCategoryT2Mex + refCategoryT3Mex

refCategoryAntiNavy = categories.ANTINAVY

--Land units
refCategoryScathis = categories.CYBRAN * categories.ARTILLERY * categories.EXPERIMENTAL
refCategoryExperimentalStructure = refCategoryScathis + categories.STRUCTURE * categories.EXPERIMENTAL -categories.OPTICS - categories.SHIELD * categories.STRUCTURE
refCategoryLandExperimental = categories.EXPERIMENTAL * categories.MOBILE * categories.LAND + categories.BUILTBYTIER3ENGINEER * categories.TECH3 * categories.MOBILE * categories.LAND * categories.DIRECTFIRE - categories.CYBRAN * categories.ARTILLERY - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryMonkeylord = refCategoryLandExperimental * categories.CYBRAN * categories.DIRECTFIRE - categories.SNIPER
refCategoryMegalith = refCategoryLandExperimental * categories.CYBRAN * categories.DIRECTFIRE * categories.SNIPER
refCategoryYthotha = refCategoryLandExperimental * categories.SERAPHIM * categories.DIRECTFIRE
refCategoryMobileLand = categories.LAND * categories.MOBILE  - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryEngineer = categories.LAND * categories.MOBILE * categories.ENGINEER - categories.COMMAND - categories.FIELDENGINEER -categories.SUBCOMMANDER --Dont include sparkys as they cant build a lot of things, so just treat them as a combat unit that can reclaim
refCategoryRASSACU = categories.SUBCOMMANDER * categories.RASPRESET + categories.SUBCOMMANDER * categories.SERAPHIM
refCategoryRover = categories.POD * categories.ENGINEER * categories.MOBILE - categories.CONSTRUCTION -refCategoryEngineer
refCategoryHive = categories.STRUCTURE * categories.STATIONASSISTPOD * categories.ENGINEERSTATION
refCategoryKennel = categories.STRUCTURE * categories.ENGINEERSTATION * categories.PODSTAGINGPLATFORM
refCategoryEngineerStation = refCategoryRover + refCategoryHive + refCategoryKennel

refCategoryAntiAir = categories.ANTIAIR --used so we can identify units with decent AA threat
refCategoryMAA = categories.LAND * categories.MOBILE * categories.ANTIAIR - categories.EXPERIMENTAL
refCategoryIndirect = categories.LAND * categories.MOBILE * categories.INDIRECTFIRE - categories.DIRECTFIRE - refCategoryLandExperimental - refCategoryScathis - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryLightAttackBot = categories.LAND * categories.DIRECTFIRE * categories.TECH1 * categories.MOBILE --Adjusted further in QUIET (see M28OtherLOUDCompatibility)
if categories.uel0106 and categories.url0106 and categories.ual0106 then
    refCategoryLightAttackBot = categories.uel0106 + categories.url0106 + categories.ual0106
else
    --Exclude certain modded units from attackbot designation, but include in T1 indirect fire
    if categories.brot1exm1 then
        refCategoryLightAttackBot = refCategoryLightAttackBot - categories.brot1exm1
    end
    if categories.brmt1exm1 then
        refCategoryLightAttackBot = refCategoryLightAttackBot - categories.brmt1exm1
    end
    if categories.uel0108 then
        refCategoryLightAttackBot = refCategoryLightAttackBot - categories.uel0108
    end
    if categories.brpt1exm1 then
        refCategoryLightAttackBot = refCategoryLightAttackBot - categories.brpt1exm1
    end
end
if categories.brot1exm1 then refCategoryIndirect = refCategoryIndirect + categories.brot1exm1 end --has indirect fire attack as well
--if categories.brmt1exm1 then refCategoryIndirect = refCategoryIndirect + categories.brmt1exm1 end --doesnt have indirect attack
--if categories.uel0108 then refCategoryIndirect = refCategoryIndirect + categories.uel0108 end --doesnt have indirect attack
--if categories.brpt1exm1 then refCategoryIndirect = refCategoryIndirect + categories.brpt1exm1 end --doesnt have indirect attack

refCategoryDFTank = categories.LAND * categories.MOBILE * categories.DIRECTFIRE - categories.SCOUT - refCategoryMAA - categories.UNSELECTABLE - categories.UNTARGETABLE --NOTE: Need to specify slowest (so dont pick LAB)
refCategoryLandScout = categories.LAND * categories.MOBILE * categories.SCOUT
refCategoryCombatScout = categories.SERAPHIM * categories.SCOUT * categories.DIRECTFIRE
refCategoryAbsolver = categories.ANTISHIELD * categories.MOBILE * categories.LAND

refCategoryT3MobileArtillery = categories.ARTILLERY * categories.LAND * categories.MOBILE * categories.TECH3 - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryMML = categories.SILO * categories.MOBILE * categories.LAND - categories.UNSELECTABLE - categories.UNTARGETABLE - categories.NUKE
refCategoryT3MML = categories.SILO * categories.MOBILE * categories.TECH3 * categories.LAND - categories.UNSELECTABLE - categories.UNTARGETABLE - categories.NUKE
refCategoryFatboy = categories.EXPERIMENTAL * categories.UEF * categories.MOBILE * categories.LAND * categories.ARTILLERY + categories.EXPERIMENTAL * categories.UEF * categories.MOBILE * categories.LAND * categories.INDIRECTFIRE - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryLandCombat = categories.MOBILE * categories.LAND * categories.DIRECTFIRE + categories.MOBILE * categories.LAND * categories.INDIRECTFIRE * categories.TECH1 + categories.FIELDENGINEER + refCategoryFatboy + categories.SUBCOMMANDER - refCategoryEngineer -refCategoryLandScout -refCategoryMAA - categories.UNSELECTABLE - categories.UNTARGETABLE

refCategoryAmphibious = categories.AMPHIBIOUS
refCategoryAmphibiousCombat = refCategoryLandCombat * categories.HOVER + refCategoryLandCombat * categories.AMPHIBIOUS - categories.ANTISHIELD --Dont include aeon T3 anti-shield here as it sucks unless against shields
refCategorySurfaceAmphibiousCombat = refCategoryLandCombat * categories.HOVER + refCategoryAntiNavy * categories.LAND * categories.MOBILE - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryGroundAA = refCategoryMAA + categories.NAVAL * categories.ANTIAIR + categories.STRUCTURE * categories.ANTIAIR + categories.NAVALCARRIER * categories.EXPERIMENTAL
refCategoryStructureAA = categories.STRUCTURE * categories.ANTIAIR
refCategoryIndirectT2Plus = categories.MOBILE * categories.LAND * categories.INDIRECTFIRE - categories.MOBILE * categories.LAND * categories.INDIRECTFIRE * categories.TECH1 - categories.DIRECTFIRE
refCategoryIndirectT2Below = categories.MOBILE * categories.INDIRECTFIRE * categories.LAND * categories.TECH1 + categories.MOBILE * categories.INDIRECTFIRE * categories.LAND * categories.TECH2
refCategoryIndirectT3 = categories.MOBILE * categories.LAND * categories.INDIRECTFIRE * categories.TECH3 - categories.DIRECTFIRE
--Obsidian special case with shields due to inconsistent categories:
refCategoryObsidian = categories.TECH2 * categories.SHIELD * categories.DIRECTFIRE * categories.MOBILE * categories.LAND + categories.PERSONALSHIELD * categories.DIRECTFIRE * categories.TECH2 * categories.MOBILE * categories.LAND
refCategoryMobileLandShield = categories.LAND * categories.MOBILE * categories.SHIELD - refCategoryObsidian -categories.EXPERIMENTAL  --Miscategorised obsidian tank
refCategoryPersonalShield = categories.PERSONALSHIELD + refCategoryObsidian
refCategoryMobileLandStealth = categories.LAND * categories.MOBILE * categories.STEALTHFIELD - categories.EXPERIMENTAL --dont want monkeylords treated as a mobile stealth unit!
refCategorySniperBot = categories.MOBILE * categories.SNIPER * categories.LAND
refCategoryMobileBomb = categories.BOMB * categories.MOBILE
refCategorySkirmisher = refCategorySniperBot - categories.EXPERIMENTAL * categories.CYBRAN
if categories.bal0403 then
    refCategorySniperBot = refCategorySniperBot + categories.bal0403
    refCategorySkirmisher = refCategorySkirmisher + categories.bal0403
    refCategoryLandCombat = refCategoryLandCombat + categories.bal0403
end
if M28Utilities.bSteamActive or M28Utilities.bLoudModActive then
    refCategorySkirmisher = refCategorySkirmisher + categories.del0204 + categories.drl0204 - refCategoryMobileBomb
else
    refCategorySkirmisher = refCategorySkirmisher +  refCategoryDFTank * categories.UEF * categories.TECH2 * categories.BOT + refCategoryDFTank * categories.CYBRAN * categories.TECH2 * categories.BOT - refCategoryMobileBomb
end
refCategoryShieldDisruptor = categories.LAND * categories.MOBILE * categories.ANTISHIELD
refCategoryAllShieldUnits = categories.SHIELD + refCategoryPersonalShield

--Air units
refCategoryAirScout = categories.AIR * categories.SCOUT
if categories.sea0002 then refCategoryAirScout = refCategoryAirScout + categories.sea0002 end --observational satellite
refCategoryAirAA = categories.AIR * categories.ANTIAIR - categories.BOMBER - categories.GROUNDATTACK - categories.EXPERIMENTAL
refCategoryBomber = categories.AIR * categories.BOMBER - refCategoryAntiNavy - categories.CANNOTUSEAIRSTAGING --excludes mercies
refCategoryFighterBomber = categories.AIR * categories.ANTIAIR * categories.BOMBER - categories.EXPERIMENTAL
refCategoryCzar = categories.AIR * categories.EXPERIMENTAL * categories.ANTIAIR * categories.AEON
refCategoryAAGunship = categories.ANTIAIR * categories.MOBILE * categories.AIR - refCategoryAirAA - categories.HIGHALTAIR - categories.BOMBER --to support blackops experimental air fortress (slow moving air experimental unit)
refCategoryGunship = categories.AIR * categories.GROUNDATTACK + categories.TARGETCHASER - refCategoryCzar --Targetchaser only used by czar, but some unit mods have it for units that dont have groundattack catgory (e.g. extreme wars)
refCategoryTorpBomber = categories.AIR * categories.BOMBER * refCategoryAntiNavy + (categories.AIR * refCategoryAntiNavy - categories.EXPERIMENTAL)
refCategoryAllAir = categories.MOBILE * categories.AIR - categories.UNTARGETABLE --Excludes novax
refCategoryAllNonExpAir = categories.MOBILE * categories.AIR * categories.TECH1 + categories.MOBILE * categories.AIR * categories.TECH2 + categories.MOBILE * categories.AIR * categories.TECH3
refCategoryAirNonScout = refCategoryAllAir - categories.SCOUT
refCategoryMercy = categories.HIGHPRIAIR * categories.AEON * categories.BOMBER * categories.TECH2 + categories.AIR * categories.MOBILE * categories.BOMB
refCategoryTransport = categories.AIR * categories.TRANSPORTATION - categories.UEF * categories.GROUNDATTACK - refCategoryTorpBomber
refCategoryRestorer = refCategoryGunship * categories.ANTIAIR
refCategoryAirToGround = refCategoryBomber + refCategoryGunship + refCategoryCzar + refCategoryMercy --i.e. excludes torp bombers

--Naval units
refCategoryFrigate = categories.NAVAL * categories.FRIGATE - categories.ENGINEER --LOUD mod has an engineering ship which is treated as a frigate
refCategoryTorpedoLauncher = refCategoryAntiNavy * categories.STRUCTURE
refCategoryHoverPD = refCategoryPD * categories.HOVER --to support LOUD which allows T2+ PD to be built on water or land
refCategoryNavalSurface = categories.NAVAL + refCategoryTorpedoLauncher - categories.SUBMERSIBLE - categories.UNSELECTABLE - categories.UNTARGETABLE --NOTE: This includes structures (e.g. torp launcher and factory)
refCategoryMobileNavalSurface = refCategoryNavalSurface * categories.MOBILE
refCategoryAllNavy = categories.NAVAL + refCategoryTorpedoLauncher - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryNavalAA = refCategoryAllNavy * categories.ANTIAIR
refCategoryCruiser = categories.NAVAL * categories.CRUISER
refCategorySalem = categories.NAVAL * categories.AMPHIBIOUS * categories.DIRECTFIRE
refCategorySeraphimDestroyer = categories.SUBMERSIBLE * categories.DESTROYER
refCategoryDestroyer = categories.DESTROYER
refCategoryCarrier = categories.NAVAL * categories.NAVALCARRIER * categories.EXTERNALFACTORY
refCategoryMobileAircraftFactory = categories.AIR * categories.EXTERNALFACTORYUNIT + categories.NAVALCARRIER * categories.EXTERNALFACTORYUNIT
refCategoryCruiserCarrier = refCategoryCruiser + categories.NAVAL * categories.NAVALCARRIER
refCategoryStealthBoat = categories.NAVAL * categories.STEALTHFIELD
refCategorySupportNavy = refCategoryCruiserCarrier + categories.SHIELD * categories.HOVER + categories.SHIELD * categories.NAVAL + categories.STEALTHFIELD * categories.HOVER + refCategoryStealthBoat --Intended for units we dont want on frontline unless in bombardment mode
refCategoryAllAmphibiousAndNavy = categories.NAVAL + categories.AMPHIBIOUS + categories.HOVER + refCategoryTMD + refCategoryTorpedoLauncher + refCategorySonar + refCategoryStructureAA --NOTE: Structures have no category indicating whether they can be built on sea (instead they have aquatic ability) hence the need to include all structures
--refCategoryPondFixedCategory = refCategoryNavalSurface - categories.AMPHIBIOUS * categories.MOBILE + refCategoryTMD + refCategoryTorpedoLauncher + refCategorySonar + refCategoryStructureAA
refCategoryNavyThatCanBeTorpedoed = categories.NAVAL + categories.AMPHIBIOUS + categories.STRUCTURE + categories.COMMAND + refCategoryEngineer - categories.HOVER --NOTE: Structures have no category indicating whether they can be built on sea (instead they have aquatic ability) hence the need to include all structures; Hover units cant be targeted
refCategoryTorpedoLandAndNavy = refCategoryAntiNavy * categories.LAND + refCategoryAntiNavy * categories.NAVAL + categories.OVERLAYANTINAVY * categories.LAND + refCategoryAntiNavy * categories.STRUCTURE --If removing overlayantinavy then think up better solution for fatboy/experimentals so they dont run when in water
refCategoryMissileShip = categories.NAVAL * categories.SILO + categories.BATTLESHIP * categories.INDIRECTFIRE - categories.BATTLESHIP * categories.SERAPHIM + categories.SERAPHIM * categories.CRUISER * categories.INDIRECTFIRE + categories.SERAPHIM * categories.CARRIER * categories.OVERLAYINDIRECTFIRE * categories.TECH3  --i.e. UEF+Sera cruisers, and nukesubs
refCategorySubmarine = categories.NAVAL * categories.SUBMERSIBLE * refCategoryAntiNavy
refCategoryCooper = categories.NAVAL * refCategoryAntiNavy * categories.TECH2 - categories.SUBMERSIBLE - categories.DESTROYER
refCategoryShieldBoat = categories.NAVAL * categories.SHIELD + categories.HOVER * categories.SHIELD --Includes mobile land shields that can hover
refCategoryBattlecruiser = categories.BATTLESHIP * categories.PRODUCTFA * categories.UEF
refCategoryBattleship = categories.BATTLESHIP - refCategoryBattlecruiser - refCategoryMissileShip
refCategoryBombardment = refCategoryFrigate + refCategoryMissileShip + refCategoryCruiserCarrier * categories.SILO + refCategoryDestroyer + refCategoryBattlecruiser + refCategoryBattleship


--Multi-category:
--Antinavy mobile units (can include land units - e.g for land factories to build antisub units)
refCategoryAntiNavy = refCategoryAntiNavy * categories.STRUCTURE + refCategoryAntiNavy * categories.MOBILE - categories.DESTROYER * categories.UEF --for some reason get error message if just use antinavy, so need to be more restrictive
--Dangerous to land units, e.g. engieners look for these when deciding reclaim area
refCategoryDangerousToLand = refCategoryLandCombat + refCategoryIndirect + refCategoryAllNavy + refCategoryBomber + refCategoryGunship + refCategoryPD + refCategoryFixedT2Arti
refCategoryAllNonAirScoutUnits = categories.MOBILE + refCategoryStructure + refCategoryAirNonScout
refCategoryStealthGenerator = categories.STEALTHFIELD
refCategoryStealthAndCloakPersonal = categories.STEALTH
refCategoryStealth = refCategoryStealthGenerator + refCategoryStealthAndCloakPersonal
refCategoryProtectFromTML = refCategoryStructure * categories.TECH2 + refCategoryStructure * categories.TECH3 + refCategoryExperimentalStructure - categories.FACTORY --Previously was: refCategoryT2Mex + refCategoryT3Mex + refCategoryT2Power + refCategoryT3Power + refCategoryFixedT2Arti
refCategoryExperimentalLevel = categories.EXPERIMENTAL + refCategoryFixedT3Arti + refCategorySML - categories.OPTICS - categories.SHIELD * categories.STRUCTURE - categories.MASSSTORAGE * categories.EXPERIMENTAL
refCategoryGameEnder = refCategoryExperimentalArti + categories.EXPERIMENTAL * categories.STRUCTURE * categories.SILO - categories.MASSSTORAGE * categories.EXPERIMENTAL + refCategoryParagon
refCategoryBigThreatCategories = refCategoryExperimentalLevel + refCategoryMissileShip + refCategorySMD + refCategoryNavalSurface * categories.BATTLESHIP --Note - this is different to M27 which only considers land experimentals as big threat categories
refCategoryFirebaseSuitable = refCategoryPD + refCategoryT1Radar + refCategoryT2Radar + refCategorySMD + refCategoryTMD + refCategoryFixedShield + refCategoryFixedT2Arti + refCategoryStructureAA
refCategoryLongRangeDFLand = refCategoryFatboy + refCategorySniperBot + refCategoryShieldDisruptor
refCategoryLongRangeMobile = refCategoryLongRangeDFLand + refCategoryNavalSurface * categories.DIRECTFIRE + refCategoryNavalSurface * categories.INDIRECTFIRE - refCategoryNavalSurface * categories.TECH1 + refCategoryIndirectT2Plus
refCategoryShortRangeMobile = refCategoryLandCombat + refCategoryFrigate - refCategoryLongRangeMobile
refCategoryReclaimable = categories.RECLAIMABLE - refCategoryAllAir
refCategoryVolatile = categories.VOLATILE --needed as LOUD doesnt have this category so want to expand this to add specific unit categories

function GetUnitLifetimeCount(oUnit)
--Returns what unique (for the unit's aiBrain) count the unit has, i.e. based on the number of previous units with the same blueprint ID
--NOTE: If want a unique value for a unit (since this value is only unique to a brain) then do oUnit.EntityId instead
    local iCount = oUnit.M28LifetimeUnitCount

    if iCount == nil then
        if oUnit.GetAIBrain and oUnit.GetUnitId then
            local aiBrain = oUnit:GetAIBrain()
            local sUnitId = (oUnit.UnitId or oUnit:GetBlueprint().BlueprintId)
            if aiBrain.M28LifetimeUnitCount == nil then aiBrain.M28LifetimeUnitCount = {} end
            if aiBrain.M28LifetimeUnitCount[sUnitId] == nil then
                aiBrain.M28LifetimeUnitCount[sUnitId] = 1
            else aiBrain.M28LifetimeUnitCount[sUnitId] = aiBrain.M28LifetimeUnitCount[sUnitId] + 1 end
            iCount = aiBrain.M28LifetimeUnitCount[sUnitId]
            oUnit.M28LifetimeUnitCount = iCount
        else
            iCount = 'nil'
        end
    end
    return iCount
end

function IsUnitValid(oUnit)
    --Returns true if unit is constructed and not dead
    if oUnit and oUnit.UnitId and not(oUnit.Dead) and oUnit.GetAIBrain then
        return true
    end
    return false
end

function GetUnitPathingType(oUnit)
    --Returns Land, Amphibious, Air or Water or None
    --if oUnit and not(oUnit.Dead) and oUnit.GetBlueprint then
    local mType = __blueprints[oUnit.UnitId].Physics.MotionType
    if (mType == 'RULEUMT_AmphibiousFloating' or mType == 'RULEUMT_Hover' or mType == 'RULEUMT_Amphibious') then
        return M28Map.refPathingTypeHover
    elseif (mType == 'RULEUMT_Water' or mType == 'RULEUMT_SurfacingSub') then
        return M28Map.refPathingTypeNavy
    elseif mType == 'RULEUMT_Air' then
        return M28Map.refPathingTypeAir
    elseif (mType == 'RULEUMT_Biped' or mType == 'RULEUMT_Land') then
        return M28Map.refPathingTypeLand
    else return M28Map.refPathingTypeNone
    end
end

function GetBlueprintFromID(sBlueprintID)
    --returns blueprint based on the blueprintID
    return __blueprints[string.lower(sBlueprintID)]
end

function GetBuildingSizeTable(sBlueprintID)
    --Returns table with X and Z size of sBlueprintID
    local tSizeXZ = {}
    local oBlueprint = GetBlueprintFromID(sBlueprintID)
    tSizeXZ[1] = oBlueprint.Physics.SkirtSizeX
    tSizeXZ[2] = oBlueprint.Physics.SkirtSizeZ
    return tSizeXZ
end

function GetBuildingSize(sBlueprintID)
    --Similar to GetBuildingSizeTable but returns a single value for the highest size
    local oBlueprint = GetBlueprintFromID(sBlueprintID)
    if oBlueprint.Physics.SkirtSizeX then
        return math.max(oBlueprint.Physics.SkirtSizeX, oBlueprint.Physics.SkirtSizeZ)
    else
        --Redundancy due to error in log for a replay I wasnt able to access
        M28Utilities.ErrorHandler('Unit doesnt have a skirtsizex, will approximate building size')
        if EntityCategoryContains(categories.SIZE4, sBlueprintID) then return 2
        elseif EntityCategoryContains(categories.SIZE8, sBlueprintID) then return 3
        elseif EntityCategoryContains(categories.SIZE12, sBlueprintID) then return 6
        elseif EntityCategoryContains(categories.SIZE16, sBlueprintID) then return 8
        elseif EntityCategoryContains(categories.SIZE20, sBlueprintID) then return 10
        else return 10
        end
    end
end

function GetUnitState(oUnit)
    --Returns a string containing oUnit's unit state. Returns '' if no unit state.
    local sUnitState = ''
    local sAllUnitStates = {'Immobile',
                            'Moving',
                            'Attacking',
                            'Guarding',
                            'Building',
                            'Upgrading',
                            'WaitingForTransport',
                            'TransportLoading',
                            'TransportUnloading',
                            'MovingDown',
                            'MovingUp',
                            'Patrolling',
                            'Busy',
                            'Attached',
                            'BeingReclaimed',
                            'Repairing',
                            'Diving',
                            'Surfacing',
                            'Teleporting',
                            'Ferrying',
                            'WaitForFerry',
                            'AssistMoving',
                            'PathFinding',
                            'ProblemGettingToGoal',
                            'NeedToTerminateTask',
                            'Capturing',
                            'BeingCaptured',
                            'Reclaiming',
                            'AssistingCommander',
                            'Refueling',
                            'GuardBusy',
                            'ForceSpeedThrough',
                            'UnSelectable',
                            'DoNotTarget',
                            'LandingOnPlatform',
                            'CannotFindPlaceToLand',
                            'BeingUpgraded',
                            'Enhancing',
                            'BeingBuilt',
                            'NoReclaim',
                            'NoCost',
                            'BlockCommandQueue',
                            'MakingAttackRun',
                            'HoldingPattern',
                            'SiloBuildingAmmo' }
    for _, sState in sAllUnitStates do
        if oUnit:IsUnitState(sState) == true then
            sUnitState = sState
            break
        end
    end
    return sUnitState
end

function GetUnitTechLevel(oUnit)
    local sUnitId = oUnit.UnitId
    local iTechLevel = 1
    if EntityCategoryContains(categories.TECH1, sUnitId) then iTechLevel = 1
    elseif EntityCategoryContains(categories.TECH2, sUnitId) then iTechLevel = 2
    elseif EntityCategoryContains(categories.TECH3, sUnitId) then iTechLevel = 3
    elseif EntityCategoryContains(categories.EXPERIMENTAL, sUnitId) then iTechLevel = 4
    end
    return iTechLevel
end

function GetBlueprintTechLevel(sUnitId)
    local iTechLevel = 1
    if EntityCategoryContains(categories.TECH1, sUnitId) then iTechLevel = 1
    elseif EntityCategoryContains(categories.TECH2, sUnitId) then iTechLevel = 2
    elseif EntityCategoryContains(categories.TECH3, sUnitId) then iTechLevel = 3
    elseif EntityCategoryContains(categories.EXPERIMENTAL, sUnitId) then iTechLevel = 4
    end
    return iTechLevel
end

function GetTechLevelOfEngineerToBuildBlueprint(sUnitId)
    local iTechLevel
    if EntityCategoryContains(categories.BUILTBYTIER1ENGINEER, sUnitId) then iTechLevel = 1
    elseif EntityCategoryContains(categories.BUILTBYTIER2ENGINEER, sUnitId) then iTechLevel = 2
    elseif EntityCategoryContains(categories.BUILTBYTIER3ENGINEER, sUnitId) then iTechLevel = 3
    end
    return iTechLevel
end

function GetUpgradeCombatWeighting(sEnhancementRef)
    --Returns the combat mass mod to apply to an enhancement
    --Obtain using aiBrain:GetFactionIndex()

    local iMinor = 0.4
    local iMajor = 1
    local iDeadly = 2
    local iNone = 0
    local iUnknown = 1

    local tEnhancementsCombatMod = {
            --UEF:
            AdvancedEngineering = iMinor, --T2
            DamageStabilization = iMajor, --Nano
            HeavyAntiMatterCannon = iMajor,
            LeftPod = iNone, --Engi
            ResourceAllocation = iNone, --RAS
            RightPod = iNone, --Engi
            Shield = iMajor, --Shield
            ShieldGeneratorField = iMajor, --Shield aoe
            T3Engineering = iMinor, --T3
            TacticalMissile = iNone, --TML
            TacticalNukeMissile = iNone, --Billy
            Teleporter = iNone, --Teleport
            --Aeon:
            --AdvancedEngineering = iMinor, --T2
            ChronoDampener = iDeadly, --ChronoDampener
            CrysalisBeam = iMajor, --Range
            EnhancedSensors = iNone, --Sensors
            HeatSink = iMajor, --ROF
            --ResourceAllocation = iNone, --RAS
            ResourceAllocationAdvanced = iNone, --RAS lev 2
            --Shield = iMajor, --Shield
            ShieldHeavy = iMajor, --Shield lev2
            --T3Engineering = iMinor, --T3
            --Teleporter = iNone, --Teleport
            --Cybran:
            --AdvancedEngineering = iMinor, --T2
            CloakingGenerator = iMinor, --Cloak
            CoolingUpgrade = iMajor, --Gun
            MicrowaveLaserGenerator = iDeadly, --Laser
            NaniteTorpedoTube = iMinor, --Torpedo
            --ResourceAllocation = iNone, --RAS
            StealthGenerator = iMajor, --Stealth
            --T3Engineering = iMinor, --T3
            --Teleporter = iNone, --Teleport
            --Sera:
            --AdvancedEngineering = iMinor, --T2
            AdvancedRegenAura = iMajor, --Regen aura lev2
            BlastAttack = iDeadly, --AOE and damage
            DamageStabilization = iMajor, --Nano
            DamageStabilizationAdvanced = iMajor, --Nano lev2
            Missile = iNone, --TML
            RateOfFire = iMajor, --Gun
            RegenAura = iDeadly, --Regen aura
            --ResourceAllocation = iNone, --RAS
            ResourceAllocationAdvanced = iNone, --RAS lev 2
            --T3Engineering = iMinor, --T3
            --Teleporter = iNone, --Teleport
    }
    return (tEnhancementsCombatMod[sEnhancementRef] or iUnknown)
end

function UpdateUnitCombatMassRatingForUpgrades(oUnit)
    --Updates oUnit[refiDFMassThreatOverride] to reflect any upgrades on the unit (e.g. for ACU and SACUs)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateUnitCombatMassRatingForUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tPossibleUpgrades = oUnit:GetBlueprint().Enhancements
    if M28Utilities.IsTableEmpty(tPossibleUpgrades) == false then
        local iCurMassValue
        local iCurMassMod
        local iTotalMassValue = iBaseACUThreat --Approx 20 tanks
        local iBaseMaxHealth = oUnit:GetBlueprint().Defense.Health
        if iBaseMaxHealth > iBaseACUExpectedHealth then
            iTotalMassValue = iTotalMassValue * math.min(2, iBaseMaxHealth / iBaseACUExpectedHealth)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': tPossibleUpgrades size='..table.getn(tPossibleUpgrades)) end
        if tPossibleUpgrades then
            for sCurUpgrade, tUpgrade in tPossibleUpgrades do
                if oUnit:HasEnhancement(sCurUpgrade) then
                    iCurMassValue = tUpgrade.BuildCostMass
                    iCurMassMod = GetUpgradeCombatWeighting(sCurUpgrade)
                    iTotalMassValue = iTotalMassValue + iCurMassMod * iCurMassValue
                    if bDebugMessages == true then LOG(sFunctionRef..': ACU has enhancement no. '..sCurUpgrade..'; iCurMassValue='..iCurMassValue..'; iCurMassMod='..iCurMassMod) end
                end
            end
        end
        oUnit[refiDFMassThreatOverride] = iTotalMassValue
        if oUnit:HasEnhancement('NaniteTorpedoTube') then
            oUnit[refiAntiNavyMassThreatOverride] = math.max(iTotalMassValue, 2500)
        else
            oUnit[refiAntiNavyMassThreatOverride] = math.min(iTotalMassValue * 0.1, 800)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetMassCostOfUnits(tUnits)
    local iMassCost = 0
    if M28Utilities.IsTableEmpty(tUnits) == false then
        for iUnit, oUnit in tUnits do
            if not(oUnit.Dead) then
                iMassCost = iMassCost + (oUnit[refiUnitMassCost] or 0)
            end
        end
    end
    return iMassCost
end

function GetCombatThreatRating(tUnits, bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, bBlueprintThreat)
    --Determines threat rating for tUnits, which in most cases will be the mass cost of the unit and adjusted for unit health; by default assumes are referring to main combat threat (e.g. tank), but the flags for indirect and naval threat can be used to adjust this
    --bJustGetMassValue - if thisi s true, will ignore things like health and just return the mass value (so none of the other values should matter if this is true - i.e. assumes tUnits is already filtered to those of interest)
    --Note that if are using this, it would generaly be much faster (about 5 times as fast) to do oUnit[M28UnitInfo.refiUnitMassCost]); alternatively use GetMassCostOfUnits if have a large table and want simplicity

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetCombatThreatRating'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if M28Utilities.IsTableEmpty(tUnits) then
        if bDebugMessages == true then LOG(sFunctionRef..': Warning: tUnits is empty, returning 0') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return 0
    else
        local iCurThreat = 0
        local iTotalThreat = 0
        local iHealthPercentage, iMaxHealth
        local iHealthFactor --if unit has 40% health, then threat reduced by (1-40%)*iHealthFactor
        local iCurShield, iMaxShield
        local iOtherAdjustFactor = 1


        local iThreatRef = '1'
        if bIndirectFireThreatOnly then iThreatRef = iThreatRef .. '1' else iThreatRef = iThreatRef .. '0' end
        if bJustGetMassValue then iThreatRef = iThreatRef .. '1' else iThreatRef = iThreatRef .. '0' end
        if bAntiNavyOnly then iThreatRef = iThreatRef .. '1' else iThreatRef = iThreatRef .. '0' end
        if bAddAntiNavy then iThreatRef = iThreatRef .. '1' else iThreatRef = iThreatRef .. '0' end
        if bSubmersibleOnly then iThreatRef = iThreatRef .. '1' else iThreatRef = iThreatRef .. '0' end
        if bLongRangeThreatOnly then iThreatRef = iThreatRef..'1' else iThreatRef = iThreatRef .. '0' end
        --E.g. if want combat (DF+IF) threat then would be 1000000

        if not(tiThreatRefsCalculated[iThreatRef]) then M28Utilities.ErrorHandler('Havent calculated threat values for iThreatRef='..iThreatRef..' refer to CalculateBlueprintThreatsByType') end

        local iBaseThreat = 0

        if bBlueprintThreat then
            local oUnit = tUnits[1]
            local oBP = __blueprints[oUnit.UnitId]
            local iMassCost = (oBP.Economy.BuildCostMass or 0)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit with ID='..(oUnit.UnitId or 'nil')..'; iMassCost='..iMassCost) end
            --ACU override
            if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                if bDebugMessages == true then LOG(sFunctionRef..': ACU threat adjustment, iMassCost pre adj='..iMassCost..'; iBaseACUThreat='..iBaseACUThreat..'; oBP.Defense.Health='..oBP.Defense.Health..'; iBaseACUExpectedHealth='..iBaseACUExpectedHealth) end
                if iMassCost < iBaseACUThreat then iMassCost = iBaseACUThreat
                else
                    --Adjust mass cost if it is too high
                    iMassCost = math.max(iBaseACUThreat, math.min(iMassCost, iBaseACUThreat * math.min(2, oBP.Defense.Health / iBaseACUExpectedHealth)))
                    if bDebugMessages == true then LOG(sFunctionRef..': Considered limiting ACU threat/mass cost (i.e. ignoring blueprint notional mass cost), iMassCost post adjustment='..iMassCost) end
                end
            end
            if bJustGetMassValue == true then iBaseThreat = iMassCost
            else
                local iMassMod = 0
                --T3 and T4 arti - assign 0 combat value
                if not(EntityCategoryContains(refCategoryFixedT3Arti + refCategoryExperimentalArti, oUnit.UnitId)) then

                    if not(bIndirectFireThreatOnly) then
                        if bAntiNavyOnly or bSubmersibleOnly then
                            iMassMod = 0
                            if (bSubmersibleOnly and (EntityCategoryContains(categories.SUBMERSIBLE, oUnit.UnitId) or oBP.Physics.MotionType == 'RULEUMT_Amphibious' or oUnit.UnitId == 'xrb2309')) or (not(bSubmersibleOnly) and bAntiNavyOnly and EntityCategoryContains(refCategoryAntiNavy+categories.OVERLAYANTINAVY + refCategoryBattleship, oUnit.UnitId)) then
                                iMassMod = 0.25 --e.g. for overlayantinavy or submersibles with no attack
                                if EntityCategoryContains(refCategoryAntiNavy, oUnit.UnitId) then
                                    iMassMod = 1
                                    if M28Utilities.bLoudModActive and not(EntityCategoryContains(categories.SUBMERSIBLE, oUnit.UnitId)) then iMassMod = 0.8 end --Destroyers dont seem sa good in a sub vs destroyer war mass for mass
                                elseif EntityCategoryContains(categories.LAND * refCategoryAntiNavy, oUnit.UnitId) then
                                    iMassMod = 0.5 --brick, wagner etc
                                    --UEF units (which are either really bad or good at antinavy)
                                elseif EntityCategoryContains(categories.UEF * refCategoryAntiNavy, oUnit.UnitId) then
                                    --Destroyer and battlecruiser
                                    if EntityCategoryContains(categories.DIRECTFIRE * categories.TECH2, oUnit.UnitId) then iMassMod = 0.25 --valiant
                                    elseif EntityCategoryContains(categories.DIRECTFIRE * categories.TECH3, oUnit.UnitId) then iMassMod = 0.15 --battlecruiser
                                    elseif EntityCategoryContains(categories.TECH2 - categories.DIRECTFIRE, oUnit.UnitId) then iMassMod = 1.2 --Cooper
                                    else
                                        --Unexpected category
                                        iMassMod = 0.5
                                    end
                                elseif EntityCategoryContains(categories.CYBRAN * refCategoryAntiNavy, oUnit.UnitId) then
                                    iMassMod = 0.8
                                elseif EntityCategoryContains(refCategoryMegalith, oUnit.UnitId) then
                                    iMassMod = 0.5
                                elseif EntityCategoryContains(refCategoryBattleship, oUnit.UnitId) then
                                    iMassMod = 0.05 --battleships could ground fire, although theyre unlikely to and very inaccurate if the target is moving
                                end
                            end
                        elseif bLongRangeThreatOnly then
                            if EntityCategoryContains(categories.DIRECTFIRE + categories.INDIRECTFIRE, oUnit.UnitId) then
                                local iUnitRange = GetBlueprintMaxGroundRange(oBP)
                                if iUnitRange >= 55 then
                                    if EntityCategoryContains(categories.SILO * categories.TECH3 * categories.SUBMERSIBLE, oUnit.UnitId) then
                                        iMassMod = 0.25 --Missile sub
                                    end
                                end
                            end
                        else
                            if EntityCategoryContains(categories.DIRECTFIRE, oUnit.UnitId) then
                                if EntityCategoryContains(refCategoryLandScout, oUnit.UnitId) then
                                    if EntityCategoryContains(categories.SERAPHIM, oUnit.UnitId) then
                                        iMassMod = 0.55 --Selen costs 20, so Selen ends up with a threat of 12; engineer logic will ignore threats <10 (so all other lands couts)
                                    else iMassMod = 0.25
                                    end
                                elseif EntityCategoryContains(refCategoryCruiserCarrier, oUnit.UnitId) then
                                    if EntityCategoryContains(categories.CYBRAN * categories.TECH2, oUnit.UnitId) then iMassMod = 0.55
                                    elseif EntityCategoryContains(categories.AEON, oUnit.UnitId) then
                                        iMassMod = 0.2 --Aeon cruiser loses vs 2 UEF frigates in sandbox (it kills 1 just before it dies)
                                    else
                                        iMassMod = 0.15 --e.g. uef cruiser - 1 frigate can almost solo it if it dodges the missiles
                                    end
                                elseif EntityCategoryContains(refCategoryLightAttackBot * categories.TECH1, oUnit.UnitId) then
                                    iMassMod = 0.85
                                elseif EntityCategoryContains(categories.BATTLESHIP - refCategoryBattlecruiser, oUnit.UnitId) then
                                    iMassMod = 0.85
                                elseif EntityCategoryContains(categories.DESTROYER, oUnit.UnitId) then
                                    iMassMod = 0.95
                                elseif EntityCategoryContains(refCategoryFrigate * categories.CYBRAN, oUnit.UnitId) then
                                    iMassMod = 1.05
                                else iMassMod = 1
                                end
                            elseif EntityCategoryContains(refCategoryFatboy, oUnit.UnitId) then
                                iMassMod = 0.55
                            elseif EntityCategoryContains(categories.SUBCOMMANDER, oUnit.UnitId) then iMassMod = 1 --SACUs dont have directfire category for some reason (they have subcommander and overlaydirectfire)
                            elseif EntityCategoryContains(categories.INDIRECTFIRE * categories.ARTILLERY * categories.STRUCTURE * categories.TECH2, oUnit.UnitId) then iMassMod = 0.1 --Gets doubled as its a structure
                            elseif EntityCategoryContains(categories.INDIRECTFIRE * categories.ARTILLERY * categories.MOBILE * categories.TECH1, oUnit.UnitId) then iMassMod = 0.9
                            elseif EntityCategoryContains(categories.INDIRECTFIRE * categories.ARTILLERY * categories.MOBILE * categories.TECH3, oUnit.UnitId) then iMassMod = 0.5
                            elseif EntityCategoryContains(refCategoryMobileLand * categories.INDIRECTFIRE * categories.SILO, oUnit.UnitId) then iMassMod = 0.1
                            elseif EntityCategoryContains(categories.SHIELD, oUnit.UnitId) then iMassMod = 0.75 --will be doubled for structures
                            elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then iMassMod = 1 --Put in just in case - code was working before this, but dont want it to be affected yb more recenlty added engineer category
                            elseif EntityCategoryContains(categories.ENGINEER,oUnit.UnitId) then iMassMod = 0.01 --Engis can reclaim and capture so can't just e.g. beat with a scout, but also dont want a combat unit to run from engineers as they could still harm them; alot of logic uses a threshold of 10 for threats, which would be c.3 T3 engineers, so will go with this
                            end
                            if bAddAntiNavy and iMassMod < 1 and EntityCategoryContains(refCategoryAntiNavy  + categories.OVERLAYANTINAVY, oUnit.UnitId) then
                                --Increase mass mod for certain units
                                if iMassMod < 0.25 then iMassMod = 0.25 end
                                if EntityCategoryContains(categories.SUBMERSIBLE + refCategoryAntiNavy, oUnit.UnitId) then
                                    iMassMod = 1 --Subs
                                elseif EntityCategoryContains(categories.LAND * refCategoryAntiNavy, oUnit.UnitId) then
                                    iMassMod = math.max(iMassMod, 0.5) --wagners, bricks etc.
                                elseif EntityCategoryContains(categories.SUBMERSIBLE * categories.SILO * categories.TECH3, oUnit.UnitId) then
                                    iMassMod = math.max(iMassMod, 0.25) --missile ship
                                end
                            end
                        end
                    else
                        if EntityCategoryContains(categories.INDIRECTFIRE, oUnit.UnitId) then
                            if EntityCategoryContains(categories.SILO * categories.TECH3 * categories.SUBMERSIBLE, oUnit.UnitId) then
                                iMassMod = 0.25 --Missile sub
                            else
                                iMassMod = 1
                            end
                            if EntityCategoryContains(categories.DIRECTFIRE, oUnit.UnitId) then iMassMod = 0.5 end
                        elseif EntityCategoryContains(categories.ANTIMISSILE, oUnit.UnitId) then iMassMod = 2 --Doubled for structures ontop of this, i.e. want 4xmass of TMD in indirect fire so can overwhelm it
                        elseif EntityCategoryContains(categories.SHIELD, oUnit.UnitId) then iMassMod = 1
                        elseif EntityCategoryContains(refCategoryLongRangeDFLand, oUnit.UnitId) then iMassMod = 0.5
                        elseif categories.BOMBARDMENT and EntityCategoryContains(categories.BOMBARDMENT, oUnit.UnitId) then
                            iMassMod = 1
                        end
                    end
                    if EntityCategoryContains(refCategoryStructure, oUnit.UnitId) then
                        --T2 arti - reduce its value because it sucks
                        if EntityCategoryContains(refCategoryFixedT2Arti, oUnit.UnitId) then
                            iMassMod = iMassMod * 0.6
                        elseif EntityCategoryContains(refCategoryStructureAA * categories.TECH1, oUnit.UnitId) then
                            iMassMod = iMassMod * 1.5
                        else
                            iMassMod = iMassMod * 2
                            if bAntiNavyOnly or (bAddAntiNavy and M28Utilities.bLoudModActive) then

                                --LOUD - looks like T2 torp launcher has 300 DPS,1160 mass cost,5600 health, 68 range; in comparison, a t1 sera sub has540 health,390 mass cost,91 DPS; so justifies similar mod to this
                                --however, LOUD also crushed T2 destroyers (3 destroyers which cost c.twice as much individually) with a t2 torp launcher, so want to increase threat further; LOUD also has torp launchers outranging destroyers
                                if M28Utilities.bLoudModActive then
                                    iMassMod = iMassMod * 2 --i.e. quadruple mass value
                                else
                                    iMassMod = iMassMod * 1.25 --increased from 1.1 pre-v128 as if we cant overwhelm the launcher we likely lose every unit
                                end
                            end
                        end
                    end
                end
                --Experimenatls are weak in LOUD, so adjust their threat rating accordingly
                if iMassMod > 0 and M28Utilities.bLoudModActive and EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then
                    iMassMod = iMassMod * 0.75
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iMassCost='..(iMassCost or 'nil')..'; iMassMod='..(iMassMod or 'nil')) end
                iBaseThreat = iMassCost * iMassMod
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return iBaseThreat
        else
            for iUnit, oUnit in tUnits do
                iCurThreat = 0
                iBaseThreat = 0
                --Get the base threat for the unit
                if IsUnitValid(oUnit) then
                    iBaseThreat = (oUnit[refiDFMassThreatOverride] or tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef])
                    if oUnit[refiAntiNavyMassThreatOverride] and (bAntiNavyOnly or bAddAntiNavy or bSubmersibleOnly) then
                        iBaseThreat = oUnit[refiAntiNavyMassThreatOverride]
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; iBaseThreat='..(iBaseThreat or 0)..'; DF threat override='..(oUnit[refiDFMassThreatOverride] or 'nil')..'; tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef]='..(tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef] or 'nil')) end
                    if not(tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef]) and not(bBlueprintThreat) then
                        iBaseThreat = GetCombatThreatRating({ { ['UnitId'] = oUnit.UnitId } }, bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, true)
                        if not(tUnitThreatByIDAndType[oUnit.UnitId]) then tUnitThreatByIDAndType[oUnit.UnitId] = {} end
                        if bDebugMessages == true then LOG(sFunctionRef..': Will rerun the blueprint logic as it seems to have missed this unit '..oUnit.UnitId..'; iBaseThreat after this='..(iBaseThreat or 'nil')) end
                        if not(tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef]) then tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef] = (iBaseThreat or 0) end

                    end
                    if iBaseThreat == 0 and bSubmersibleOnly and bEnemyUnits and EntityCategoryContains(refCategoryAmphibious, oUnit.UnitId) and IsUnitUnderwater(oUnit) then
                        iBaseThreat = oUnit[refiUnitMassCost] * 0.35
                    end
                    if iBaseThreat > 0 then
                        if bJustGetMassValue then iCurThreat = iBaseThreat
                        elseif M28Utilities.bCPUPerformanceMode then
                            if iBaseThreat <= 2000 then iCurThreat = iBaseThreat
                            else iCurThreat = iBaseThreat * oUnit:GetHealth() / oUnit:GetMaxHealth()
                            end
                        else
                            --Have got the base threat for this type of unit, now adjust threat for unit health if want to calculate actual threat
                            iCurShield, iMaxShield = GetCurrentAndMaximumShield(oUnit)
                            iMaxHealth = oUnit:GetMaxHealth() + iMaxShield
                            if iMaxHealth and iMaxHealth > 0 then
                                --Increase threat for veterancy level
                                if oUnit.Sync.VeteranLevel > 0 then iBaseThreat = iBaseThreat * (1 + oUnit.Sync.VeteranLevel * 0.1) end

                                --Adjust threat for cur health %
                                iOtherAdjustFactor = 1
                                iHealthPercentage = (oUnit:GetHealth() + iCurShield) / (iMaxHealth + iMaxShield)

                                --Reduce threat by health, with the amount depending on if its an ACU and if its an enemy
                                if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                                    iHealthFactor = iHealthPercentage --threat will be mass * iHealthFactor
                                    --iMassCost = GetACUCombatMassRating(oUnit) --have already calculated this earlier
                                    if bEnemyUnits then
                                        iOtherAdjustFactor = 1.10 --Want to allow for enemy ACU to be 10% higher threat due to potential of veterancy
                                    else
                                        if iHealthPercentage < 0.5 then iHealthFactor = iHealthPercentage * iHealthPercentage
                                        elseif iHealthPercentage < 0.9 then iHealthFactor = iHealthPercentage * (iHealthPercentage + 0.1) end
                                    end
                                else
                                    if bEnemyUnits then
                                        --For enemy damaged units treat them as still ahving high threat, since enemy likely could use them effectively still
                                        if iHealthPercentage >= 1 then iHealthFactor = iHealthPercentage
                                        else
                                            iHealthFactor = math.max(0.25, iHealthPercentage * (1 + (1 - iHealthPercentage)))
                                        end
                                    else
                                        iHealthFactor = iHealthPercentage
                                    end
                                end
                                if oUnit:GetFractionComplete() <= 0.75 then iOtherAdjustFactor = iOtherAdjustFactor * 0.1 end
                            end
                            iCurThreat = iBaseThreat * iOtherAdjustFactor * iHealthFactor
                            if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' iCurThreat='..iCurThreat..'; iBaseThreat='..iBaseThreat..'; iOtherAdjustFactor='..iOtherAdjustFactor..'; iHealthFactor='..iHealthFactor) end
                        end
                    end
                else
                    --Are we calculating blueprint threat (per code at start of game)?
                    if bBlueprintThreat then
                        local oBP = __blueprints[oUnit.UnitId]
                        local iMassCost = (oBP.Economy.BuildCostMass or 0)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering unit with ID='..(oUnit.UnitId or 'nil')..'; iMassCost='..iMassCost) end
                        --ACU override
                        if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                            if bDebugMessages == true then LOG(sFunctionRef..': ACU threat adjustment, iMassCost pre adj='..iMassCost..'; iBaseACUThreat='..iBaseACUThreat..'; oBP.Defense.Health='..oBP.Defense.Health..'; iBaseACUExpectedHealth='..iBaseACUExpectedHealth) end
                            if iMassCost < iBaseACUThreat then iMassCost = iBaseACUThreat
                            else
                                --Adjust mass cost if it is too high
                                iMassCost = math.max(iBaseACUThreat, math.min(iMassCost, iBaseACUThreat * math.min(2, oBP.Defense.Health / iBaseACUExpectedHealth)))
                                if bDebugMessages == true then LOG(sFunctionRef..': Considered limiting ACU threat/mass cost (i.e. ignoring blueprint notional mass cost), iMassCost post adjustment='..iMassCost) end
                            end
                        end
                        if bJustGetMassValue == true then iBaseThreat = iMassCost
                        else
                            local iMassMod = 0
                            --T3 and T4 arti - assign 0 combat value
                            if not(EntityCategoryContains(refCategoryFixedT3Arti + refCategoryExperimentalArti, oUnit.UnitId)) then

                                if not(bIndirectFireThreatOnly) then
                                    if bAntiNavyOnly or bSubmersibleOnly then
                                        iMassMod = 0
                                        if (bSubmersibleOnly and (EntityCategoryContains(categories.SUBMERSIBLE, oUnit.UnitId) or oBP.Physics.MotionType == 'RULEUMT_Amphibious' or oUnit.UnitId == 'xrb2309')) or (not(bSubmersibleOnly) and bAntiNavyOnly and EntityCategoryContains(refCategoryAntiNavy+categories.OVERLAYANTINAVY + refCategoryBattleship, oUnit.UnitId)) then
                                            iMassMod = 0.25 --e.g. for overlayantinavy or submersibles with no attack
                                            if EntityCategoryContains(refCategoryAntiNavy, oUnit.UnitId) then
                                                iMassMod = 1
                                                if M28Utilities.bLoudModActive and not(EntityCategoryContains(categories.SUBMERSIBLE, oUnit.UnitId)) then iMassMod = 0.8 end --Destroyers dont seem sa good in a sub vs destroyer war mass for mass
                                            elseif EntityCategoryContains(categories.LAND * refCategoryAntiNavy, oUnit.UnitId) then
                                                iMassMod = 0.5 --brick, wagner etc
                                                --UEF units (which are either really bad or good at antinavy)
                                            elseif EntityCategoryContains(categories.UEF * refCategoryAntiNavy, oUnit.UnitId) then
                                                --Destroyer and battlecruiser
                                                if EntityCategoryContains(categories.DIRECTFIRE * categories.TECH2, oUnit.UnitId) then iMassMod = 0.25 --valiant
                                                elseif EntityCategoryContains(categories.DIRECTFIRE * categories.TECH3, oUnit.UnitId) then iMassMod = 0.15 --battlecruiser
                                                elseif EntityCategoryContains(categories.TECH2 - categories.DIRECTFIRE, oUnit.UnitId) then iMassMod = 1.2 --Cooper
                                                else
                                                    --Unexpected category
                                                    iMassMod = 0.5
                                                end
                                            elseif EntityCategoryContains(categories.CYBRAN * refCategoryAntiNavy, oUnit.UnitId) then
                                                iMassMod = 0.8
                                            elseif EntityCategoryContains(refCategoryMegalith, oUnit.UnitId) then
                                                iMassMod = 0.5
                                            elseif EntityCategoryContains(refCategoryBattleship, oUnit.UnitId) then
                                                iMassMod = 0.05 --battleships could ground fire, although theyre unlikely to and very inaccurate if the target is moving
                                            end
                                        end
                                    elseif bLongRangeThreatOnly then
                                        if EntityCategoryContains(categories.DIRECTFIRE + categories.INDIRECTFIRE, oUnit.UnitId) then
                                            local iUnitRange = GetBlueprintMaxGroundRange(oBP)
                                            if iUnitRange >= 55 then
                                                if EntityCategoryContains(categories.SILO * categories.TECH3 * categories.SUBMERSIBLE, oUnit.UnitId) then
                                                    iMassMod = 0.25 --Missile sub
                                                end
                                            end
                                        end
                                    else
                                        if EntityCategoryContains(categories.DIRECTFIRE, oUnit.UnitId) then
                                            if EntityCategoryContains(refCategoryLandScout, oUnit.UnitId) then
                                                if EntityCategoryContains(categories.SERAPHIM, oUnit.UnitId) then
                                                    iMassMod = 0.55 --Selen costs 20, so Selen ends up with a threat of 12; engineer logic will ignore threats <10 (so all other lands couts)
                                                else iMassMod = 0.25
                                                end
                                            elseif EntityCategoryContains(refCategoryCruiserCarrier, oUnit.UnitId) then
                                                if EntityCategoryContains(categories.CYBRAN * categories.TECH2, oUnit.UnitId) then iMassMod = 0.55
                                                elseif EntityCategoryContains(categories.AEON, oUnit.UnitId) then
                                                    iMassMod = 0.2 --Aeon cruiser loses vs 2 UEF frigates in sandbox (it kills 1 just before it dies)
                                                else
                                                    iMassMod = 0.15 --e.g. uef cruiser - 1 frigate can almost solo it if it dodges the missiles
                                                end
                                            elseif EntityCategoryContains(refCategoryLightAttackBot * categories.TECH1, oUnit.UnitId) then
                                                iMassMod = 0.85
                                            elseif EntityCategoryContains(categories.BATTLESHIP - refCategoryBattlecruiser, oUnit.UnitId) then
                                                iMassMod = 0.85
                                            elseif EntityCategoryContains(categories.DESTROYER, oUnit.UnitId) then
                                                iMassMod = 0.95
                                            elseif EntityCategoryContains(refCategoryFrigate * categories.CYBRAN, oUnit.UnitId) then
                                                iMassMod = 1.05
                                            else iMassMod = 1
                                            end
                                        elseif EntityCategoryContains(refCategoryFatboy, oUnit.UnitId) then
                                            iMassMod = 0.55
                                        elseif EntityCategoryContains(categories.SUBCOMMANDER, oUnit.UnitId) then iMassMod = 1 --SACUs dont have directfire category for some reason (they have subcommander and overlaydirectfire)
                                        elseif EntityCategoryContains(categories.INDIRECTFIRE * categories.ARTILLERY * categories.STRUCTURE * categories.TECH2, oUnit.UnitId) then iMassMod = 0.1 --Gets doubled as its a structure
                                        elseif EntityCategoryContains(categories.INDIRECTFIRE * categories.ARTILLERY * categories.MOBILE * categories.TECH1, oUnit.UnitId) then iMassMod = 0.9
                                        elseif EntityCategoryContains(categories.INDIRECTFIRE * categories.ARTILLERY * categories.MOBILE * categories.TECH3, oUnit.UnitId) then iMassMod = 0.5
                                        elseif EntityCategoryContains(refCategoryMobileLand * categories.INDIRECTFIRE * categories.SILO, oUnit.UnitId) then iMassMod = 0.1
                                        elseif EntityCategoryContains(categories.SHIELD, oUnit.UnitId) then iMassMod = 0.75 --will be doubled for structures
                                        elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then iMassMod = 1 --Put in just in case - code was working before this, but dont want it to be affected yb more recenlty added engineer category
                                        elseif EntityCategoryContains(categories.ENGINEER,oUnit.UnitId) then iMassMod = 0.01 --Engis can reclaim and capture so can't just e.g. beat with a scout, but also dont want a combat unit to run from engineers as they could still harm them; alot of logic uses a threshold of 10 for threats, which would be c.3 T3 engineers, so will go with this
                                        end
                                        if bAddAntiNavy and iMassMod < 1 and EntityCategoryContains(refCategoryAntiNavy  + categories.OVERLAYANTINAVY, oUnit.UnitId) then
                                            --Increase mass mod for certain units
                                            if iMassMod < 0.25 then iMassMod = 0.25 end
                                            if EntityCategoryContains(categories.SUBMERSIBLE + refCategoryAntiNavy, oUnit.UnitId) then
                                                iMassMod = 1 --Subs
                                            elseif EntityCategoryContains(categories.LAND * refCategoryAntiNavy, oUnit.UnitId) then
                                                iMassMod = math.max(iMassMod, 0.5) --wagners, bricks etc.
                                            elseif EntityCategoryContains(categories.SUBMERSIBLE * categories.SILO * categories.TECH3, oUnit.UnitId) then
                                                iMassMod = math.max(iMassMod, 0.25) --missile ship
                                            end
                                        end
                                    end
                                else
                                    if EntityCategoryContains(categories.INDIRECTFIRE, oUnit.UnitId) then
                                        if EntityCategoryContains(categories.SILO * categories.TECH3 * categories.SUBMERSIBLE, oUnit.UnitId) then
                                            iMassMod = 0.25 --Missile sub
                                        else
                                            iMassMod = 1
                                        end
                                        if EntityCategoryContains(categories.DIRECTFIRE, oUnit.UnitId) then iMassMod = 0.5 end
                                    elseif EntityCategoryContains(categories.ANTIMISSILE, oUnit.UnitId) then iMassMod = 2 --Doubled for structures ontop of this, i.e. want 4xmass of TMD in indirect fire so can overwhelm it
                                    elseif EntityCategoryContains(categories.SHIELD, oUnit.UnitId) then iMassMod = 1
                                    elseif EntityCategoryContains(refCategoryLongRangeDFLand, oUnit.UnitId) then iMassMod = 0.5
                                    end
                                end
                                if EntityCategoryContains(refCategoryStructure, oUnit.UnitId) then
                                    --T2 arti - reduce its value because it sucks
                                    if EntityCategoryContains(refCategoryFixedT2Arti, oUnit.UnitId) then
                                        iMassMod = iMassMod * 0.6
                                    elseif EntityCategoryContains(refCategoryStructureAA * categories.TECH1, oUnit.UnitId) then
                                        iMassMod = iMassMod * 1.5
                                    else
                                        iMassMod = iMassMod * 2
                                        if bAntiNavyOnly or (bAddAntiNavy and M28Utilities.bLoudModActive) then

                                            --LOUD - looks like T2 torp launcher has 300 DPS,1160 mass cost,5600 health, 68 range; in comparison, a t1 sera sub has540 health,390 mass cost,91 DPS; so justifies similar mod to this
                                            --however, LOUD also crushed T2 destroyers (3 destroyers which cost c.twice as much individually) with a t2 torp launcher, so want to increase threat further; LOUD also has torp launchers outranging destroyers
                                            if M28Utilities.bLoudModActive then
                                                iMassMod = iMassMod * 2 --i.e. quadruple mass value
                                            else
                                                iMassMod = iMassMod * 1.25 --increased from 1.1 pre-v128 as if we cant overwhelm the launcher we likely lose every unit
                                            end
                                        end
                                    end
                                end
                            end
                            --Experimenatls are weak in LOUD, so adjust their threat rating accordingly
                            if iMassMod > 0 and M28Utilities.bLoudModActive and EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then
                                iMassMod = iMassMod * 0.75
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iMassCost='..(iMassCost or 'nil')..'; iMassMod='..(iMassMod or 'nil')) end
                            iBaseThreat = iMassCost * iMassMod
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' is not valid')
                    end

                    iCurThreat = iBaseThreat
                end

                iTotalThreat = iTotalThreat + iCurThreat
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iTotalThreat='..iTotalThreat) end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return iTotalThreat
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetAirThreatLevel(tUnits, bEnemyUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat, bRecordByTeam)
    --Threat value depends on inputs:
    --bIncludeAntiAir - will include anti-air on ground units
    --bIncludeNonCombatAir - adds threat value for transports and scouts
    --bIncludeAirTorpedo - Adds threat for torpedo bombers
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetAirThreatLevel'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': About to check if table is empty. bIncludeAirToAir='..tostring(bIncludeAirToAir)..'; bIncludeAirToGround='..tostring(bIncludeAirToGround or false)) end

    if M28Utilities.IsTableEmpty(tUnits) then
        --if tUnits == nil then
        if bDebugMessages == true then LOG(sFunctionRef..': Warning: tUnits is empty, returning 0') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return 0
    else
        if bIncludeAirTorpedo == nil then bIncludeAirTorpedo = bIncludeAirToGround end
        local bUnitFitsDesiredCategory

        --Determine the amount that health impacts on threat
        local iHealthFactor = 1 --if unit has 40% health, then threat reduced by (1-40%)*iHealthFactor
        if bIncludeAirToAir == true then
            if bEnemyUnits and not(bBlueprintThreat) then
                iHealthFactor = 0.5
            else
                iHealthFactor = 0.15
            end
        elseif bIncludeAirToGround == true then iHealthFactor = 0.5
        else iHealthFactor = 0 end

        local iCurThreat = 0
        local iTotalThreat = 0
        local iTotalByTeamThreat, iCurTeam
        if bRecordByTeam then iTotalByTeamThreat = {} end
        local iBaseThreat = 0
        local iHealthPercentage
        local iHealthThreatFactor
        local iGhettoGunshipAdjust = 0


        local iThreatRef = '2'
        if bIncludeAirToAir then iThreatRef = iThreatRef..'1' else iThreatRef = iThreatRef..'0' end
        if bIncludeGroundToAir then iThreatRef = iThreatRef..'1' else iThreatRef = iThreatRef..'0' end
        if bIncludeAirToGround then iThreatRef = iThreatRef..'1' else iThreatRef = iThreatRef..'0' end
        if bIncludeNonCombatAir then iThreatRef = iThreatRef..'1' else iThreatRef = iThreatRef..'0' end
        if bIncludeAirTorpedo then iThreatRef = iThreatRef..'1' else iThreatRef = iThreatRef..'0' end
        if not(tiThreatRefsCalculated[iThreatRef]) then
            M28Utilities.ErrorHandler('Dont have a thraat ref '..iThreatRef..' So CalculateBlueprintThreatsByType threat calculation likely wrong')
        end


        local bAdjustExperimentalAirToGroundThreat = false
        if not(bEnemyUnits) and bIncludeAirToGround and not(bIncludeAirToAir) then bAdjustExperimentalAirToGroundThreat = true end
        if bBlueprintThreat then
            local oUnit = tUnits[1]
            local oBP = __blueprints[oUnit.UnitId]
            if bDebugMessages == true then LOG(sFunctionRef..': About to calculate threat using actual unit data, iThreatRef='..iThreatRef) end
            --get actual threat calc
            local iMassMod = 0 --For non-offensive structures
            --Does the unit contain any of the categories of interest?
            bUnitFitsDesiredCategory = false
            --Exclude based on pathing type initially before considering more precisely:
            local sCurUnitPathing = GetUnitPathingType(oUnit)
            if sCurUnitPathing == M28Map.refPathingTypeAir then
                if bIncludeAirToAir == true then bUnitFitsDesiredCategory = true
                elseif bIncludeAirToGround == true then bUnitFitsDesiredCategory = true
                elseif bIncludeAirTorpedo == true then bUnitFitsDesiredCategory = true
                elseif bIncludeNonCombatAir == true then bUnitFitsDesiredCategory = true
                end
            elseif bIncludeGroundToAir == true then bUnitFitsDesiredCategory = true end

            --Is unit still valid? If so then consider its weapons/categories more precisely:
            if bDebugMessages == true then LOG(sFunctionRef..': bUnitFitsDesiredCategory='..tostring(bUnitFitsDesiredCategory)..'; bIncludeAirToAir='..tostring(bIncludeAirToAir)..'; bIncludeAirToGround='..tostring(bIncludeAirToGround)..'; iThreatRef='..iThreatRef) end
            if bUnitFitsDesiredCategory == true then

                local sCurUnitBP = oBP.BlueprintId

                --Get values for air units:
                if sCurUnitPathing == M28Map.refPathingTypeAir then
                    if bIncludeNonCombatAir == true then
                        iMassMod = 1
                        --Reduce to 25% for air scouts, as main concern is transports
                        if EntityCategoryContains(refCategoryAirScout, sCurUnitBP) then iMassMod = 0.25 end

                    else
                        if bIncludeAirToGround == true then
                            if EntityCategoryContains(categories.BOMBER + categories.GROUNDATTACK + categories.OVERLAYDIRECTFIRE + categories.DIRECTFIRE, sCurUnitBP) == true then iMassMod = 1
                            elseif EntityCategoryContains(categories.TRANSPORTATION, sCurUnitBP) then iMassMod = 1 --might be a ghetto
                            end
                        end
                        if bIncludeAirTorpedo == true and EntityCategoryContains(refCategoryAntiNavy, sCurUnitBP) == true then iMassMod = 1 end
                        if bDebugMessages == true then LOG(sFunctionRef..': bIncludeAirTorpedo='..tostring(bIncludeAirTorpedo)..'; iMassMod='..iMassMod) end

                        if bIncludeAirToAir == true and iMassMod < 1 then
                            if bDebugMessages == true then LOG(sFunctionRef..': bIncludeAirToAir='..tostring(bIncludeAirToAir)..'; iMassMod='..iMassMod..'; does BP contain airaa category='..tostring(EntityCategoryContains(categories.ANTIAIR * categories.AIR, sCurUnitBP))) end
                            if EntityCategoryContains(categories.ANTIAIR * categories.AIR, sCurUnitBP) == true then
                                iMassMod = 1
                                if EntityCategoryContains(categories.BOMBER + categories.GROUNDATTACK + categories.DIRECTFIRE, sCurUnitBP) then
                                    iMassMod = 0.75 --e.g. t2 bombers
                                    --Manual adjustments for units with good AA that also have direct fire
                                    if sCurUnitBP == 'xaa0305' then iMassMod = 0.8 --Restorer
                                    elseif sCurUnitBP == 'xea0306' then iMassMod = 0.7 --Continental
                                    elseif sCurUnitBP == 'uaa0310' then iMassMod = 0.55 --Czar
                                    elseif sCurUnitBP == 'xsa0402' then iMassMod = 0.3 --Sera experi bomber
                                    end
                                elseif EntityCategoryContains(categories.HIGHALTAIR, sCurUnitBP) and M28Utilities.bLoudModActive then
                                    --LOUD (and QUIET) - asfs are much worse mass for mass than inties (need 2:1 mass advantage to roughly break even) and t2 fighters (need 1.5:1 mass advantage to roughly break even)
                                    if EntityCategoryContains(categories.TECH1, sCurUnitBP) then iMassMod = 2
                                    elseif EntityCategoryContains(categories.TECH2, sCurUnitBP) then iMassMod = 1.5
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': sCurUnitBP='..sCurUnitBP..': Mass mod after checking AirAA value='..iMassMod) end
                            elseif EntityCategoryContains(categories.OVERLAYANTIAIR * categories.AIR, sCurUnitBP) then
                                iMassMod = 0.05
                            end
                            --Backup logic (e.g. for LOUD that doesnt have the AA categories for units such as restoers)
                            --Calculate based on unit weapon values the approx threat the unit provides in DPS terms, ignoring health, and use this as a miniimum threat value, while also using a category approach per below if higher
                            local iAADPS = 0
                            local iBestAirAAAOE = 0
                            local iCurDPS, bCanShootAir
                            if oBP.Weapon then
                                for iWeapon, tWeapon in oBP.Weapon do
                                    bCanShootAir = false
                                    if tWeapon.Damage and tWeapon.FireTargetLayerCapsTable then
                                        for iType, sTargets in tWeapon.FireTargetLayerCapsTable do
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering weapon with sTargets='..repru(sTargets)) end
                                            if sTargets == 'Air' and tWeapon.CannotAttackGround then
                                                bCanShootAir = true
                                                break
                                            elseif sTargets == 'Air|Land|Water|Seabed' then
                                                bCanShootAir = true
                                                break
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': AirAA bCanShootAir='..tostring(bCanShootAir or false)..'; MuzzleSalvoSize='..(tWeapon.MuzzleSalvoSize or 'nil')..'; MuzzleSalvoDelay='..(tWeapon.MuzzleSalvoDelay or 'nil')..'; Damage='..(tWeapon.Damage or 'nil')) end
                                    if bCanShootAir then
                                        iBestAirAAAOE = math.max(iBestAirAAAOE, (tWeapon.DamageRadius or 0))
                                        iCurDPS = math.min(tWeapon.Damage, 6000) * ((tWeapon.ProjectilesPerOnFire or 1) + (tWeapon.MuzzleSalvoSize or 1)) / (tWeapon.RateOfFire or 1) --Note: if muzzlesalvosize * muzzlesalvodelay doesnt conclude before the normal weapon rate of fire, then the weapon wont fire as often; for simplicity have assumed this isnt the case
                                        iAADPS = iAADPS + iCurDPS
                                        if bDebugMessages == true then LOG(sFunctionRef..': iCurDPS for this weapon='..iCurDPS) end
                                    end
                                end
                                --Cap AA DPS at 200 for ACUs (i.e. for LOUD) as wont have all upgrades initially
                                if iAADPS > 200 and EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then iAADPS = 200 end
                            end

                            if bDebugMessages == true then LOG(sFunctionRef..': iMassMod pre AA DPS adj='..iMassMod..'; iAADPS='..iAADPS) end
                            if iMassMod < 1 and iAADPS > 0 then
                                local iMassAAFactor = 2.1
                                --FAF - a sam costs 800 mass, and deals 343 dps, so 1 dps is worth about 2.3 mass; for an archer, its 26 dps for 55 mass, so 1 dps is worth about 2.1 mass; will therefore use threshold of 2.1 mass for no aoe (also about 2.1 in LOUD), and 2.3 mass for decent AOE
                                --For Air to Air - an asf deals 410 DPS, costs 660 mass, has 2300 health
                                if iBestAirAAAOE >= 1 then iMassAAFactor = 1.6 end
                                if sCurUnitPathing == M28Map.refPathingTypeNone then iMassAAFactor = iMassAAFactor * 0.5 end --needed as we double threat for structures later on

                                --Adjust AA factor further for high health units; a SAM has 5k health for 800 mass, so 6.25 health per mass; for an archer, its 5.6 health per mass
                                --For AirToAir, asf is giving 2300 health for 660 mass, so 3.5 health per mass
                                local iHealthPerMass = oBP.Defense.MaxHealth / oBP.Economy.BuildCostMass
                                if iHealthPerMass >= 6 then
                                    iMassAAFactor = iMassAAFactor * math.min(4, (iHealthPerMass - 3.5) / 5 + 1)
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': considienrg AirAA threat adjust for unit '..sCurUnitBP..'; iMassMod pre AA dps adj='..iMassMod..'; iMassAAFactor='..iMassAAFactor..'; iHealthPerMass='..iHealthPerMass) end

                                iMassMod = math.min(1, math.max(iMassMod, iMassAAFactor * iAADPS / (oBP.Economy.BuildCostMass or 1)))
                                --Add unit category to table of AA if doesnt contain AA and it is a decent AA unit - add to both refCategoryGroundAA and to refCategoryAntiAir

                                if iMassMod >= 0.4 then
                                    if not(EntityCategoryContains(refCategoryAntiAir, sCurUnitBP)) then refCategoryAntiAir = refCategoryAntiAir + categories[sCurUnitBP] end
                                end
                            end
                        end
                    end
                else
                    --Non-air pathing type
                    if bDebugMessages == true then LOG(sFunctionRef..': Unit doesnt have air pathing. bIncludeGroundToAir='..tostring(bIncludeGroundToAir)) end
                    if bIncludeGroundToAir == true then
                        --Calculate based on unit weapon values the approx threat the unit provides in DPS terms, ignoring health, and use this as a miniimum threat value, while also using a category approach per below if higher
                        local iAADPS = 0
                        local iBestAirAAAOE = 0
                        local iCurDPS, bCanShootAir
                        if oBP.Weapon then
                            for iWeapon, tWeapon in oBP.Weapon do
                                bCanShootAir = false
                                if tWeapon.Damage and tWeapon.FireTargetLayerCapsTable and (not(tWeapon.TargetRestrictOnlyAllow) or EntityCategoryContains(categories.ANTIAIR, oUnit.UnitId)) then
                                    for iType, sTargets in tWeapon.FireTargetLayerCapsTable do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering weapon with sTargets='..repru(sTargets)) end
                                        if sTargets == 'Air' then --and tWeapon.CannotAttackGround then
                                            bCanShootAir = true
                                            break
                                        elseif sTargets == 'Air|Land|Water|Seabed' then
                                            bCanShootAir = true
                                            break
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': GroundAA bCanShootAir='..tostring(bCanShootAir or false)..'; MuzzleSalvoSize='..(tWeapon.MuzzleSalvoSize or 'nil')..'; MuzzleSalvoDelay='..(tWeapon.MuzzleSalvoDelay or 'nil')..'; Damage='..(tWeapon.Damage or 'nil')) end
                                if bCanShootAir then
                                    iBestAirAAAOE = math.max(iBestAirAAAOE, (tWeapon.DamageRadius or 0))
                                    iCurDPS = math.min(tWeapon.Damage, 6000) * ((tWeapon.ProjectilesPerOnFire or 1) + (tWeapon.MuzzleSalvoSize or 1)) / (tWeapon.RateOfFire or 1) --Note: if muzzlesalvosize * muzzlesalvodelay doesnt conclude before the normal weapon rate of fire, then the weapon wont fire as often; for simplicity have assumed this isnt the case
                                    iAADPS = iAADPS + iCurDPS
                                end
                            end
                            if iAADPS > 200 and EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then iAADPS = 200 end
                        end

                        if EntityCategoryContains(categories.ANTIAIR, sCurUnitBP) == true then
                            if EntityCategoryContains(categories.SUBMERSIBLE, sCurUnitBP) then
                                if EntityCategoryContains(categories.EXPERIMENTAL, sCurUnitBP) then
                                    iMassMod = 1 --atlantis (if categorised correctly)
                                else
                                    iMassMod = 0.5 --sera sub hunter
                                end
                            elseif EntityCategoryContains(categories.EXPERIMENTAL + refCategoryFrigate, sCurUnitBP) then
                                iMassMod = 0.1 --Cybran frigate and land experimentals misclassified as anti-air
                            else
                                iMassMod = 1 --Cruisers and T3 aircraft carriers have antiair as well as overlay antiair
                            end
                        elseif EntityCategoryContains(categories.OVERLAYANTIAIR, sCurUnitBP) == true then
                            iMassMod = 0.04
                            if sCurUnitBP == 'ues0401' then iMassMod = 1 --atlantis misclassifiefd as not anti-air
                            elseif EntityCategoryContains(categories.FRIGATE, sCurUnitBP) then iMassMod = 0.18
                            elseif sCurUnitBP == 'url0402' then
                                iMassMod = 0.016 --monkeylord - it has half the dps of a t2 mobile flak with no aoe (although it has better range and health), so its threat will be equivalent to 2 mobile T2 MAA so that gunships are more likely to engage it
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iMassMod pre AA DPS adj='..iMassMod..'; iAADPS='..iAADPS) end
                        if iMassMod < 1 and iAADPS > 0 then
                            local iMassAAFactor = 2.1
                            --FAF - a sam costs 800 mass, and deals 343 dps, so 1 dps is worth about 2.3 mass; for an archer, its 26 dps for 55 mass, so 1 dps is worth about 2.1 mass; will therefore use threshold of 2.1 mass for no aoe (also about 2.1 in LOUD), and 2.3 mass for decent AOE
                            if iBestAirAAAOE >= 1 then iMassAAFactor = 2.3 end
                            if sCurUnitPathing == M28Map.refPathingTypeNone then iMassAAFactor = iMassAAFactor * 0.5 end --needed as we double threat for structures later on

                            --Adjust AA factor further for high health units; a SAM has 5k health for 800 mass, so 6.25 health per mass; for an archer, its 5.6 health per mass
                            local iHealthPerMass = oBP.Defense.MaxHealth / oBP.Economy.BuildCostMass
                            if iHealthPerMass >= 6 then
                                local iMaxHealthFactor = 2.2
                                if M28Utilities.bLoudModActive then iMaxHealthFactor = 2.5 end
                                iMassAAFactor = iMassAAFactor * math.min(iMaxHealthFactor, (iHealthPerMass - 6) / 12 + 1) --Main threat of AA unit is the damage, not the health, so cap the amount threat is increased by unit health (e.g. dont want ythotha deterring air attacks just because its high health)
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': considienrg AA threat adjust for unit '..sCurUnitBP..'; iMassMod pre AA dps adj='..iMassMod..'; iMassAAFactor='..iMassAAFactor..'; iHealthPerMass='..iHealthPerMass) end

                            iMassMod = math.min(1.5, math.max(iMassMod, iMassAAFactor * iAADPS / (oBP.Economy.BuildCostMass or 1)))
                            --Add unit category to table of AA if doesnt contain AA and it is a decent AA unit - add to both refCategoryGroundAA and to refCategoryAntiAir

                            if iMassMod >= 0.4 then
                                if not(EntityCategoryContains(refCategoryGroundAA, sCurUnitBP)) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Unit didnt have groundAA category so are adding this now') end
                                    refCategoryGroundAA = refCategoryGroundAA + categories[sCurUnitBP]
                                end
                                if EntityCategoryContains(categories.MOBILE * categories.NAVAL, sCurUnitBP) and not(EntityCategoryContains(refCategoryNavalAA, sCurUnitBP)) then
                                    refCategoryNavalAA = refCategoryNavalAA + categories[sCurUnitBP]
                                end
                                if not(EntityCategoryContains(refCategoryAntiAir, sCurUnitBP)) then refCategoryAntiAir = refCategoryAntiAir + categories[sCurUnitBP] end
                            end
                        end
                    end
                end
                --Increase AA threat for structures
                if bIncludeGroundToAir == true and sCurUnitPathing == M28Map.refPathingTypeNone then iMassMod = iMassMod * 2 end
            end

            local iMassCost = (oBP.Economy.BuildCostMass or 0)
            if bDebugMessages == true then LOG(sFunctionRef..': iMassCost='..(iMassCost or 'nil')..'; iMassMod='..(iMassMod or 'nil')) end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return iMassCost * iMassMod
        else
            for iUnit, oUnit in tUnits do
                iCurThreat = 0
                iBaseThreat = 0
                iGhettoGunshipAdjust = 0
                if bDebugMessages == true then LOG(sFunctionRef..': About to check if unit is dead') end

                if IsUnitValid(oUnit) then
                    --Get the base threat for the unit
                    iBaseThreat = (tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef] or 0)
                    --Adjust threat for health
                    if iBaseThreat > 0 then
                        if M28Utilities.bCPUPerformanceMode then
                            if iBaseThreat < 4000 then
                                iCurThreat = iBaseThreat
                            else
                                iCurThreat = iBaseThreat * oUnit:GetHealth() / oUnit:GetMaxHealth()
                            end
                        else
                            --Increase for cargo of transports
                            if bIncludeAirToGround and EntityCategoryContains(refCategoryTransport, oUnit.UnitId) and oUnit.GetCargo then --Use refcategoryTransport as Brewlan gives torp bombers the transportation category, and checking .GetCargo first doesnt prevent an error
                                if bDebugMessages == true then LOG(sFunctionRef..': Have an enemy transport, will get its cargo and see if it contains LABs') end
                                --Include threat of cargo if cargo are LABs
                                local tCargo = oUnit:GetCargo()
                                --Filter to just LABs (note unfortunately it doesnt distinguish between mantis and LABs so matnis get treated as LABs to be prudent)
                                if tCargo then
                                    tCargo = EntityCategoryFilterDown(refCategoryLightAttackBot, tCargo)
                                    if M28Utilities.IsTableEmpty(tCargo) == false then
                                        --Get mass value ignoring health:
                                        --GetCombatThreatRating(aiBrain, tUnits, bMustBeVisibleToIntelOrSight, iMassValueOfBlipsOverride, iSoloBlipMassOverride, bIndirectFireThreatOnly, bJustGetMassValue)
                                        iGhettoGunshipAdjust = GetCombatThreatRating(tCargo, bEnemyUnits)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Contains LABs so will increase threat by '..iGhettoGunshipAdjust) end
                                    end
                                end
                            end

                            --Adjust threat for health
                            iHealthThreatFactor = 1
                            if iHealthFactor > 0 then
                                --Assume low health experimental is has more health than it does - e.g. might heal, or might be under construction
                                if EntityCategoryContains(categories.EXPERIMENTAL, oUnit) then
                                    --Does unit have a shield?
                                    if EntityCategoryContains(refCategoryAllShieldUnits, oUnit.UnitId) or (oUnit.MyShield and not(M28Utilities.bFAFActive)) then
                                        local iCurShield, iMaxShield = GetCurrentAndMaximumShield(oUnit, true)
                                        iHealthPercentage = (oUnit:GetHealth() + iCurShield) / (oUnit:GetMaxHealth() + iMaxShield)
                                    else
                                        iHealthPercentage = GetUnitHealthPercent(oUnit)
                                        if iHealthPercentage < 1 and oUnit:GetFractionComplete() >= 0.2 then
                                            if bEnemyUnits then iHealthPercentage = math.min(1, math.max(0.4, iHealthPercentage * 1.5))
                                            else
                                                iHealthPercentage = math.min(1, math.max(0.3, iHealthPercentage * 1.4))
                                            end
                                        end
                                    end
                                else
                                    iHealthPercentage = GetUnitHealthPercent(oUnit)
                                end
                                iHealthThreatFactor = (1 - (1-iHealthPercentage) * iHealthFactor) * iHealthThreatFactor
                            elseif oUnit:GetFractionComplete() < 1 then
                                if oUnit:GetFractionComplete() >= 0.5 and (bEnemyUnits or oUnit:GetFractionComplete() >= 0.95) then
                                    iHealthThreatFactor = oUnit:GetFractionComplete()
                                else
                                    iHealthThreatFactor = 0
                                end
                            end
                            if bAdjustExperimentalAirToGroundThreat and EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then
                                if EntityCategoryContains(refCategoryCzar, oUnit.UnitId) then
                                    --Friendly czar
                                    iBaseThreat = iBaseThreat * 0.5
                                else
                                    --e.g. friendly soulripper
                                    iBaseThreat = iBaseThreat * 0.75
                                end
                            end
                            iCurThreat = iBaseThreat * iHealthThreatFactor + iGhettoGunshipAdjust
                            if bDebugMessages == true then LOG(sFunctionRef..': UnitBP='..(oUnit.UnitId or 'nil')..'; iBaseThreat='..(iBaseThreat or 'nil')..'; iHealthThreatFactor='..(iHealthThreatFactor or 'nil')..'iGhettoGunshipAdjust='..(iGhettoGunshipAdjust or 'nil')..'; iCurThreat='..(iCurThreat or 'nil')..'; Unit fraction complete='..oUnit:GetFractionComplete()..'; Unit health%='..GetUnitHealthPercent(oUnit)) end
                        end
                    end
                end

                if iCurThreat > 0 then
                    if bRecordByTeam then
                        iCurTeam = (oUnit:GetAIBrain().M28Team or 0)
                        iTotalByTeamThreat[iCurTeam] = (iTotalByTeamThreat[iCurTeam] or 0) + iCurThreat

                    else
                        iTotalThreat = iTotalThreat + iCurThreat
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Unit='..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; iCurThreat='..iCurThreat..'; iTotalThreat='..iTotalThreat) end
            end
        end


        if bDebugMessages == true then LOG(sFunctionRef..': End of code, iTotalThreat='..iTotalThreat..'; iTotalByTeamThreat='..repru(iTotalByTeamThreat)..'; bRecordByTeam='..tostring(bRecordByTeam or false)) end
        if bRecordByTeam then
            if M28Utilities.IsTableEmpty(iTotalByTeamThreat) == false then
                local iMaxThreat = 0
                for iTeam, iThreat in iTotalByTeamThreat do
                    iMaxThreat = math.max(iThreat, iMaxThreat)
                end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return iMaxThreat
            else
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return 0
            end
        else
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return iTotalThreat
        end
    end
    M28Profiler.ErrorHandler('Code shouldve returend before now, will return 0')
    return 0
end

function CheckBlueprintSizeSupport(oBP, sUnitId)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckBlueprintSizeSupport'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..sUnitId..'; Can this be built by T3 engi='..tostring(EntityCategoryContains(categories.BUILTBYTIER3ENGINEER, sUnitId))) end
    if EntityCategoryContains(categories.BUILTBYTIER3ENGINEER, sUnitId) then
        local iUnitSize = GetBuildingSize(sUnitId)
        local bBuildOnLand = false
        if tbBuildOnLandLayerCaps[oBP.Physics.BuildOnLayerCaps] then bBuildOnLand = true end
        local bBuildOnSea = false
        if tbBuildOnWaterLayerCaps[oBP.Physics.BuildOnLayerCaps] then bBuildOnSea = true end
        if bDebugMessages == true then LOG(sFunctionRef..': bBuildOnLand='..tostring(bBuildOnLand)..'; bBuildOnSea='..tostring(bBuildOnSea)..'; tsBlueprintsBySize='..repru(M28Engineer.tsBlueprintsBySize)..'; oBP.Physics.BuildOnLayerCaps='..repru(oBP.Physics.BuildOnLayerCaps)..'; tbBuildOnLandLayerCaps[BuildOnLayerCaps]='..tostring(tbBuildOnLandLayerCaps[oBP.Physics.BuildOnLayerCaps] or false)) end
        if bBuildOnLand and not(M28Engineer.tsBlueprintsBySize[iUnitSize]) then
            M28Engineer.tsBlueprintsBySize[iUnitSize] = sUnitId
            M28Engineer.iMaxBuildingSize = math.max(M28Engineer.iMaxBuildingSize, iUnitSize)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..sUnitId..'; iUnitSize='..iUnitSize..'; wasnt recorded in land size table so have added') end
        end
        if bBuildOnSea and not(M28Engineer.tsWZBlueprintsBySize[iUnitSize]) then
            M28Engineer.tsWZBlueprintsBySize[iUnitSize] = sUnitId
            M28Engineer.iMaxBuildingSize = math.max(M28Engineer.iMaxBuildingSize, iUnitSize)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..sUnitId..'; iUnitSize='..iUnitSize..'; wasnt recorded in water size table so have added') end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CalculateBlueprintThreatsByType()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CalculateBlueprintThreatsByType'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(tUnitThreatByIDAndType) then
        local sUnitId
        --{bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly}
        local tiLandAndNavyThreatTypes = {
            ['1000000'] = { false, false, false, false, false, false }, --Normal land threat
            ['1010000'] = { true, false, false, false, false, false, false }, --mass cost
            ['1100000'] = { false, true, false, false, false, false }, --Indirect
            ['1000100'] = { false, false, false, true, false, false }, --Normal land threat plus antinavy threat if higher
            ['1001000'] = { false, false, true, false, false, false }, --Antinavy threat only
            ['1000010'] = { false, false, false, false, true, false }, --Submersible threat only
            ['1000001'] = { false, false, false, false, false, true }, --Long range threat only
        }
        --{bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo}
        local tiAirThreatTypes = {
            ['200001'] = {false, false, false, false, true,}, --Torpedo bombers
            ['200100'] = { false, false, true, false, false }, --Air to ground
            ['200110'] = { false, false, true, true, false }, --Air to gorund and non-combat
            ['200111'] = { false, false, true, true, true }, --Air to ground and non-combat; note: The code will set TorpBombers to equal the airtoground value if it's nil, hence use of code ending 111
            ['201000'] = { false, true, false, false, false }, --Ground AA
            ['210000'] = { true, false, false, false, false }, --Air AA
            ['210110'] = { true, false, true, true, false }, --Air threat (general)
            ['210111'] = { true, false, true, true, true }, --Air threat (general)
            ['200101'] = { true, false, true, true, true }, --Bombers and torpedo bombers
            ['210011'] = { true, false, false, true, true}, --Air excluding air to ground (but including torp bombers) - i.e. 'air excluding dangerous to land tanks on land'
            ['210010'] = { true, false, false, true, false}, --Air excluding air to ground (i.e. excluding torp bombers as well)
            ['200011'] = { false, false, false, true, true}, --Used to get non-AA non-Air to ground (excl torp bomber) air, e.g. intended for land zones to determine 'other'/less important air
            ['200010'] = { false, false, false, true, false}, --Used to get non-AA non-Air to ground air, e.g. intended for water zones to determine 'other'/less important air
            --['211000'] = { true, true, false, false, false} --GroundAA and AirAA combined - was thinking of using this for recording IMAP air version but decided to stick to just airaa
        }

        for iRef, tValue in tiLandAndNavyThreatTypes do
            tiThreatRefsCalculated[iRef] = true
        end
        for iRef, tValue in tiAirThreatTypes do
            tiThreatRefsCalculated[iRef] = true
        end



        function RecordBlueprintThreatValues(oBP, sUnitId)

            tUnitThreatByIDAndType[sUnitId] = {}
            if bDebugMessages == true then LOG(sFunctionRef..': About to consider different land threat values for unit '..sUnitId..' Name='..(oBP.General.UnitName or 'nil')) end
            for iRef, tConditions in tiLandAndNavyThreatTypes do
                --GetCombatThreatRating(tUnits, bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, bBlueprintThreat)
                --{bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly}
                tUnitThreatByIDAndType[sUnitId][iRef] = GetCombatThreatRating( { {['UnitId']=sUnitId }}, false, tConditions[1], tConditions[2], tConditions[3], tConditions[4], tConditions[5], tConditions[6], true)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished calculating land threat values for '..(oBP.General.UnitName or 'nil')..', result='..reprs(tUnitThreatByIDAndType[sUnitId])) end

            for iRef, tConditions in tiAirThreatTypes do
                --GetAirThreatLevel(tUnits, bEnemyUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
                tUnitThreatByIDAndType[sUnitId][iRef] = GetAirThreatLevel({ {['UnitId']=sUnitId }}, false, tConditions[1], tConditions[2], tConditions[3], tConditions[4], tConditions[5], true)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished calculating air threat values, result of land and air for '..(oBP.General.UnitName or 'nil')..'='..reprs(tUnitThreatByIDAndType[sUnitId])) end
        end

        local iCurTechLevel
        local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
        local bCheckForVolatileUnits = false
        if not(M28Utilities.bFAFActive) or M28Utilities.IsTableEmpty(EntityCategoryGetUnitList(categories.VOLATILE)) then
            bCheckForVolatileUnits = true
        end

        for iBP, oBP in __blueprints do
            --Updates tUnitThreatByIDAndType
            sUnitId = oBP.BlueprintId
            if bDebugMessages == true then LOG('Will shortly (via a forked threat) get the blueprint threat for enemy unit sUnitId '..sUnitId..'; tUnitThreatByIDAndType[sUnitId]='..(tUnitThreatByIDAndType[sUnitId] or 'nil')..'; oBP.Economy.BuildCostMass='..(oBP.Economy.BuildCostMass or 'nil')..'; oBP.General.UnitName='..(oBP.General.UnitName or 'nil')..' if it has a build cost mass of at least 1 and we havent already called it') end


            if not(tUnitThreatByIDAndType[sUnitId]) and (oBP.Economy.BuildCostMass or 0) > 0 then
                --iCount = iCount + 1
                --if iCount >= 10 then break end
                ForkThread(RecordBlueprintThreatValues, oBP, sUnitId)
                ForkThread(CheckBlueprintSizeSupport, oBP, sUnitId)
                --Update radar values if have them
                if EntityCategoryContains(refCategoryNovax + refCategoryNovaxCentre, sUnitId) then
                    M28Building.bNovaxInGame = true
                elseif oBP.Intel.RadarRadius and EntityCategoryContains(refCategoryRadar, sUnitId) then
                    iCurTechLevel = GetBlueprintTechLevel(sUnitId)
                    if iCurTechLevel == 1 then if iT1RadarSize <= 1 then iT1RadarSize = oBP.Intel.RadarRadius end end
                    if iCurTechLevel == 2 then if iT2RadarSize <= math.max(1, iT1RadarSize) then iT2RadarSize = math.max(iT2RadarSize, oBP.Intel.RadarRadius) end end
                    if iCurTechLevel == 3 then if iT3RadarSize <= math.max(1, iT2RadarSize) then iT3RadarSize = math.max(iT3RadarSize, oBP.Intel.RadarRadius) end end


                    --Use hardcoded values if not had things set
                    if iT1RadarSize <= 1 then iT1RadarSize = 116 end
                    if iT2RadarSize <= 1 then iT2RadarSize = 200 end
                    if iT3RadarSize <= 1 then
                        if M28Utilities.bLoudModActive then
                            iT3RadarSize = 320
                        else
                            iT3RadarSize = 600
                        end
                    end
                elseif EntityCategoryContains(refCategoryAirStaging, sUnitId) then
                    M28Building.iLowestAirStagingTechAvailable = math.min(M28Building.iLowestAirStagingTechAvailable, GetBlueprintTechLevel(sUnitId), (GetTechLevelOfEngineerToBuildBlueprint(sUnitId) or 4))
                elseif EntityCategoryContains(refCategoryMassStorage + refCategoryEnergyStorage, sUnitId) then
                    local iCurTechLevel = GetBlueprintTechLevel(sUnitId)
                    local iTechLevelOfEngineerToBuildUnit = GetTechLevelOfEngineerToBuildBlueprint(sUnitId)
                    iCurTechLevel = math.max(iCurTechLevel, (iTechLevelOfEngineerToBuildUnit or 3))
                    if EntityCategoryContains(refCategoryMassStorage, sUnitId) then M28Building.iLowestMassStorageTechAvailable = math.min(M28Building.iLowestMassStorageTechAvailable, iCurTechLevel) end
                    if EntityCategoryContains(refCategoryEnergyStorage, sUnitId) then M28Building.iLowestEnergyStorageTechAvailable = math.min(M28Building.iLowestEnergyStorageTechAvailable, iCurTechLevel) end
                    if bDebugMessages == true then LOG(sFunctionRef..': Just updated details of lowest storage tech available, sUnitId='..sUnitId..'; iCurTechLevel='..iCurTechLevel..'; Is mass storage='..tostring(EntityCategoryContains(refCategoryMassStorage, sUnitId))..'; Is energy storage='..tostring(EntityCategoryContains(refCategoryEnergyStorage, sUnitId))..'; Lowest mass s torage tech='..M28Building.iLowestMassStorageTechAvailable..'; Lowest energy storage tech='..M28Building.iLowestEnergyStorageTechAvailable..'; GetBlueprintTechLevel(sUnitId)='..GetBlueprintTechLevel(sUnitId)..'; GetTechLevelOfEngineerToBuildBlueprint(sUnitId)='..(GetTechLevelOfEngineerToBuildBlueprint(sUnitId) or 'nil')) end
                elseif EntityCategoryContains(refCategoryPD, sUnitId) then
                    local iCurTechLevel = GetBlueprintTechLevel(sUnitId)
                    local tUnitRef = {['UnitId']=sUnitId}
                    RecordUnitRange(tUnitRef, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording unit '..sUnitId..' with DF range='..(tUnitRef[refiDFRange] or 0)..'; iCurTechLevel='..iCurTechLevel..'; is oBP.Physics.BuildOnLayerCaps nil='..tostring(oBP.Physics.BuildOnLayerCaps == nil)) end
                    if (tUnitRef[refiDFRange] or 0) > 0 then
                        M28Building.tiWorstPDRangeByTech[iCurTechLevel] = math.min((M28Building.tiWorstPDRangeByTech[iCurTechLevel] or 200), tUnitRef[refiDFRange])
                        if bDebugMessages == true then LOG(sFunctionRef..': tiWorstPDRangeByTech after update='..repru(M28Building.tiWorstPDRangeByTech)) end
                    end
                    --If is amphibious then record accordingly (e.g. for LOUD) - FAF doesnt have BuildOnLayerCaps recorded
                    if oBP.Physics.BuildOnLayerCaps then
                        if bDebugMessages == true then LOG(sFunctionRef..': oBP.Physics.BuildOnLayerCaps[LAYER_Land]='..tostring(oBP.Physics.BuildOnLayerCaps['LAYER_Land'] or false)..'; LAYER_water='..tostring(oBP.Physics.BuildOnLayerCaps['LAYER_Water'] or false)..'; repru of oBP.Physics.BuildOnLayerCaps='..repru(oBP.Physics.BuildOnLayerCaps)..'; oBP.General.Icon='..(oBP.General.Icon or 'nil')) end
                        if oBP.Physics.BuildOnLayerCaps['LAYER_Water'] or (oBP.General.Icon == 'amph' and M28Utilities.bLoudModActive) then
                            if refCategoryHoverPD == refCategoryPD * categories.HOVER then refCategoryHoverPD = categories[sUnitId]
                            else refCategoryHoverPD = refCategoryHoverPD + categories[sUnitId]
                            end
                            refCategoryAllAmphibiousAndNavy = refCategoryAllAmphibiousAndNavy + categories[sUnitId]
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Recorded that PD unit '..sUnitId..' can be built on both land and water, list of blueprints that meet the engineer build torp luancher cat='..repru(EntityCategoryGetUnitList(import('/mods/M28AI/lua/AI/M28Engineer.lua').tiActionCategory[import('/mods/M28AI/lua/AI/M28Engineer.lua').refActionBuildTorpLauncher]))..'; List of unit blueprints in refCategoryHoverPD='..repru(EntityCategoryGetUnitList(refCategoryHoverPD)))
                            end
                        end
                    end
                end

                if bCheckForVolatileUnits then
                    --Does unit have a death weapon with an aoe and damage?
                    if oBP.Weapon then
                        for iWeapon, tWeapon in oBP.Weapon do
                            if tWeapon.WeaponCategory == 'Death' or tWeapon.Label == 'DeathWeapon' or tWeapon.DisplayName == 'Death Weapon' then
                                if (tWeapon.DamageRadius or 0) >= 2 and tWeapon.Damage >= 100 then
                                    refCategoryVolatile = refCategoryVolatile + categories[sUnitId]
                                end
                            end
                        end
                    end
                end
            end
        end

        --Update engineer categories
        local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
        M28Engineer.tiActionCategory[M28Engineer.refActionBuildTorpLauncher] = refCategoryTorpedoLauncher + refCategoryHoverPD

        --Special eco checks - e.g. for mods that adjust resource mod of all units - will use UEF t3 mass fab as a rough proxy for this, if they both have the same ratio then will use this
        local oBP = __blueprints['ueb1303']

        local iMassRatio = 1
        if oBP then
            local iExpectedMass = 16
            if (oBP.Economy.ProductionPerSecondMass or 0) > iExpectedMass then
                iMassRatio =  (oBP.Economy.ProductionPerSecondMass or 0) / iExpectedMass
            end
        end
        local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
        M28Overseer.iMassFabRatio = iMassRatio


    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetUnitHealthPercent(oUnit)
    return oUnit:GetHealth() / oUnit:GetMaxHealth()
end

function GetUnitHealthAndShieldPercent(oUnit)
    local iCurHealth = oUnit:GetHealth()
    local iMaxHealth = oUnit:GetMaxHealth()
    if oUnit.MyShield and oUnit:GetFractionComplete() == 1 then
        iCurHealth = iCurHealth + oUnit.MyShield:GetHealth()
        iMaxHealth = iMaxHealth + oUnit.MyShield:GetMaxHealth()
    end
    return iCurHealth / iMaxHealth
end

function GetUnitMaxHealthIncludingShield(oUnit)
    --Returns unit max health; includes shield max health if unit is constructed
    local iMaxShield = 0
    if oUnit.MyShield and oUnit:GetFractionComplete() == 1 then
        iMaxShield = oUnit.MyShield:GetMaxHealth()
    end
    return (iMaxShield + oUnit:GetMaxHealth())
end

function GetUnitCurHealthAndShield(oUnit)
    if oUnit.MyShield and oUnit:GetFractionComplete() == 1 then
        return oUnit:GetHealth() + oUnit.MyShield:GetHealth()
    else
        return oUnit:GetHealth()
    end
end

function GetCurrentAndMaximumShield(oUnit, bDontTreatLowPowerShieldAsZero)
    --Returns 0, 0 if unit has no shield, or 0, [max shield] if it has a shield but it is depleted
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetCurrentAndMaximumShield'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --if oUnit.MyShield then
        local iCurShield = 0
        local iMaxShield = 0
        if oUnit.MyShield then
            iCurShield = oUnit.MyShield:GetHealth()
            iMaxShield = oUnit.MyShield:GetMaxHealth()
        else
            local tShield = oUnit:GetBlueprint().Defense
            if tShield then
                iCurShield = (oUnit:GetShieldRatio(false) or 0) * iMaxShield
            end
        end
        if iCurShield > 0 and oUnit.MyShield then
            if not(bDontTreatLowPowerShieldAsZero) then
                --GetHealth doesnt look like it factors in power stall
                if not(oUnit.MyShield.Enabled) or oUnit.MyShield.DepletedByEnergy or (oUnit:GetAIBrain():GetEconomyStored('ENERGY') == 0) then iCurShield = 0 end
            end
            if iCurShield > 0 and ((oUnit.MyShield.IsUp and not(oUnit.MyShield:IsUp())) or (not(oUnit.MyShield.IsUp) and not((oUnit.MyShield:IsOn() and oUnit.MyShield.Enabled))))  then
                --Occasional bug where shield shows as having health via gethealth, not powerstalling, but shield is actually down - below is to try and capture such cases
                if not(bDontTreatLowPowerShieldAsZero) or oUnit.MyShield.DepletedByDamage then
                    iCurShield = 0
                end
            end
        end
        --Support for LOUD mod where units have 0 shield with :GetHealth() but the shield is up
        if not(M28Utilities.bFAFActive) and iMaxShield > 0 and iCurShield == 0 and oUnit.MyShield:IsOn() and not(oUnit[refbShieldDown]) then
            iCurShield = math.min(oUnit:GetShieldRatio(true), oUnit:GetShieldRatio(false)) * iMaxShield
        end
        if bDebugMessages == true then
            LOG(sFunctionRef..': iCurShield='..iCurShield..'; iMaxShield='..iMaxShield..'; ShieldRatio False='..oUnit:GetShieldRatio(false)..'; ShieldRatio true='..oUnit:GetShieldRatio(true)..' iCurShield='..iCurShield)
            if oUnit.MyShield then LOG('Unit has MyShield; oUnit.MyShield.Enabled='..tostring(oUnit.MyShield.Enabled or false)..'; IsOn='..tostring(oUnit.MyShield:IsOn())..'; shield health='..oUnit.MyShield:GetHealth()) end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return iCurShield, iMaxShield
    --[[else
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return 0, 0
    end--]]
end

function IsUnitShieldEnabled(oUnit)
    return not(oUnit[refbShieldIsDisabled])
end
function DisableUnitShield(oUnit)
    if bDontConsiderCombinedArmy or oUnit.M28Active then
        oUnit[refbShieldIsDisabled] = true
        oUnit:DisableShield()
    end
end
function EnableUnitShield(oUnit)
    if bDontConsiderCombinedArmy or oUnit.M28Active then
        oUnit:EnableShield()
        oUnit[refbShieldIsDisabled] = false
    end
end

function DisableUnitIntel(oUnit)
    if bDontConsiderCombinedArmy or oUnit.M28Active then
        oUnit:OnScriptBitSet(3)
    end
end
function EnableUnitIntel(oUnit)
    if bDontConsiderCombinedArmy or oUnit.M28Active then
        oUnit:OnScriptBitClear(3)
    end
end

function DisableUnitJamming(oUnit)
    if bDontConsiderCombinedArmy or oUnit.M28Active then
        oUnit:OnScriptBitSet(2)
    end
end
function EnableUnitJamming(oUnit)
    if bDontConsiderCombinedArmy or oUnit.M28Active then
        oUnit:OnScriptBitClear(2)
    end
end

function DisableUnitStealth(oUnit)
    if bDontConsiderCombinedArmy or oUnit.M28Active then
        oUnit:SetScriptBit('RULEUTC_StealthToggle', true)
        oUnit:SetScriptBit('RULEUTC_CloakToggle', true)
    end
end

function EnableUnitStealth(oUnit)
    if bDontConsiderCombinedArmy or oUnit.M28Active then
        oUnit:SetScriptBit('RULEUTC_StealthToggle', false)
        oUnit:SetScriptBit('RULEUTC_CloakToggle', false)
    end
end

function GetBlueprintMaxGroundRange(oBP)
--Simpler version of recordunitrange, intended at start of game to estimate whether a unit is a long range unit for threat calculations
    local iMaxRange = 0
    if oBP.Weapon then
        for iCurWeapon, oCurWeapon in oBP.Weapon do
            if oCurWeapon.MaxRadius > iMaxRange and not(oCurWeapon.EnabledByEnhancement) and oCurWeapon.Damage > 0 then
                if oCurWeapon.FireTargetLayerCapsTable and oCurWeapon.FireTargetLayerCapsTable['Land'] == 'Land|Water|Seabed' and not(oCurWeapon.ManualFire) then
                    iMaxRange = math.max(iMaxRange, oCurWeapon.MaxRadius)
                end
            end
        end
    end
    return iMaxRange
end

function GetBomberAOEAndStrikeDamage(oUnit)
    local oBP = oUnit:GetBlueprint()
    local iAOE = 0
    local iStrikeDamage = 0
    local iFiringRandomness
    local iSalvoModifier
    for sWeaponRef, tWeapon in oBP.Weapon do
        if tWeapon.WeaponCategory == 'Bomb' or tWeapon.WeaponCategory == 'Direct Fire' or tWeapon.Label == 'Bomb' then
            if (tWeapon.DamageRadius or 0) > iAOE then
                iAOE = tWeapon.DamageRadius
                iSalvoModifier = (tWeapon.MuzzleSalvoSize or 1)
                if iSalvoModifier > 2 then iSalvoModifier = (iSalvoModifier - 1) * 0.5 + 1 end
                iStrikeDamage = tWeapon.Damage * iSalvoModifier
                iFiringRandomness = (tWeapon.FiringRandomness or 0)
            end
        end
    end
    if iStrikeDamage == 0 then
        M28Utilities.ErrorHandler('Couldnt identify strike damage for bomber with ID '..oUnit.UnitId..'; will refer to predefined value instead')
    end

    --Manual floor for strike damage due to complexity of some bomber calculations
    --Check if manual override is higher, as some weapons will fire lots of shots so above method wont be accurate
    local tiBomberStrikeDamageByFactionAndTech =
    {
        --UEF, Aeon, Cybran, Sera, Nomads (are using default), Default
        { 150, 200, 155, 250, 150, 150 }, --Tech 1
        { 350, 300, 850, 1175, 550, 550 }, --Tech 2
        { 2500, 2500, 2500, 2500, 2500, 2500}, --Tech 3 - the strike damage calculation above should be accurate so this is just as a backup, and set at a low level due to potential for more balance changes affecting this
        { 11000,11000,11000,11000,11000,11000} --Tech 4 - again as a backup
    }
    iStrikeDamage = math.max(iStrikeDamage, tiBomberStrikeDamageByFactionAndTech[GetUnitTechLevel(oUnit)][GetFactionFromBP(oBP)])


    return iAOE, iStrikeDamage, iFiringRandomness
end

function GetUnitStrikeDamage(oUnit, bReferenceIsATableWithUnitId)
    --Gets strike damage of the first weapon in oUnit (longer term might want to make better so it considers other weapons)
    --For bombers will be subject to a minimum value as some bombers will have
    local oBP
    local sBP = oUnit.UnitId
    if bReferenceIsATableWithUnitId then
        oBP = __blueprints[sBP]
    else oBP = oUnit:GetBlueprint()
    end
    local iStrikeDamage = 0


    if EntityCategoryContains(refCategoryBomber, sBP) then
        --Doublecheck strike damage based on if it references a bomb
        local iAOE
        iAOE, iStrikeDamage = GetBomberAOEAndStrikeDamage(oUnit)
    elseif EntityCategoryContains(refCategoryTorpBomber, sBP) then
        for iCurWeapon, oCurWeapon in oBP.Weapon do
            if oCurWeapon.Label == 'Bomb' or oCurWeapon.Label == 'Torpedo' or (oCurWeapon.Label and string.find(oCurWeapon.Label, 'Torpedo')) then
                iStrikeDamage = (oCurWeapon.DoTPulses or 1) * (oCurWeapon.MuzzleSalvoSize or 1) * oCurWeapon.Damage
                break
            end
        end
        if iStrikeDamage == 0 then
            iStrikeDamage = 750 --Backup
            --Nomads T2 gunship (which also has antinavy attack):
            if sBP == 'xna0203' then iStrikeDamage = 120
            else
                M28Utilities.ErrorHandler('Have torp bomber with no bomb weapon so not calculated strike damage')
            end
        end
    elseif EntityCategoryContains(refCategorySniperBot * categories.SERAPHIM, sBP) then
        iStrikeDamage = GetSniperStrikeDamage(oUnit)
    elseif oBP.Weapon and oBP.Weapon[1] then
        iStrikeDamage = oBP.Weapon[1].Damage
    end
    return iStrikeDamage
end

function GetTorpedoDefenceValue(oUnit, oCurWeapon)
    if GetUnitTechLevel(oUnit) == 1 then
        return 1
    else
        local iBaseValue = 1
        local iCurValue = oCurWeapon.RateOfFire or iBaseValue
        local iValue = 1
        if oCurWeapon.RateOfFire and oCurWeapon.RateOfFire >= 2/6 then
            if oCurWeapon.RateOfFire >= 3/6 then iValue = 2.5
            else iValue = 2
            end
        end

        if (oCurWeapon.MuzzleSalvoSize or 1) > 1 then
            iValue = iValue * oCurWeapon.MuzzleSalvoSize
        end
        return iValue
    end
end

function RecordUnitRange(oUnit, bReferenceIsATableWithUnitId)
    --Updates unit range variables - sets to nil if it has nothing with that range, otherwise records it as the highest range it has.  Factors in enhancements. Also records if unit unpacks for T3 mobile arti
    --Also updates if unit can kite
    --Also records unit strike damage for certain air units
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordUnitRange'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local oBP
    if bReferenceIsATableWithUnitId then
        oBP = __blueprints[oUnit.UnitId]
    else
        oBP = oUnit:GetBlueprint()
    end
    local bWeaponUnpacks = false
    local bWeaponIsFixed = false
    local bReplaceValues, bIgnoreValues
    local bUpdateAirAA = EntityCategoryContains(refCategoryAirAA, oUnit.UnitId)
    if oBP.Weapon then
        for iCurWeapon, oCurWeapon in oBP.Weapon do
            if oCurWeapon.MaxRadius and not(oCurWeapon.EnabledByEnhancement) or (oCurWeapon.EnabledByEnhancement and oUnit.HasEnhancement and oUnit:HasEnhancement(oCurWeapon.EnabledByEnhancement)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Considering weapon with range category='..(oCurWeapon.RangeCategory or 'nil')..'; weapon category='..(oCurWeapon.WeaponCategory or 'nil')..' and label='..(oCurWeapon.Label or 'nil')..' for unit '..oUnit.UnitId) end
                if oCurWeapon.ManualFire then
                    oUnit[refiManualRange] = math.max((oUnit[refiManualRange] or 0), oCurWeapon.MaxRadius)
                    oUnit[refiIndirectAOE] = math.max((oUnit[refiIndirectAOE] or 0), oCurWeapon.DamageRadius or 0)
                elseif oCurWeapon.RangeCategory == 'UWRC_Countermeasure' then
                    --Target restriction should catch all cases, have but the most common labels as redundancy as well (doesnt cover mega? and fatboy? torpedo defence which have antitorpedoleft, left1, left2, right, etc. labels)
                    if oCurWeapon.TargetRestrictOnlyAllow == "TORPEDO" or oCurWeapon.Label == 'AntiTorpedo' or oCurWeapon.Label == 'AntiTorpedo01' or oCurWeapon.Label == 'AntiTorpedoF' then
                        oUnit[refiTorpedoDefenceCount] = (oUnit[refiTorpedoDefenceCount] or 0) + GetTorpedoDefenceValue(oUnit, oCurWeapon)
                    else
                        oUnit[refiMissileDefenceRange] = math.max((oUnit[refiMissileDefenceRange] or 0), oCurWeapon.MaxRadius)
                    end
                elseif oCurWeapon.Label == 'Bomb' and EntityCategoryContains(categories.MOBILE * categories.AIR, oUnit.UnitId) then
                    oUnit[refiBomberRange] = math.max((oUnit[refiBomberRange] or 0), oCurWeapon.MaxRadius)
                    if oCurWeapon.RateOfFire then oUnit[refiTimeBetweenBombs] = math.max((oUnit[refiTimeBetweenBombs] or 0), 1 / oCurWeapon.RateOfFire) end
                elseif (oCurWeapon.Label == 'Torpedo' or oCurWeapon.Label == 'ClusterTorpedo') and EntityCategoryContains(categories.AIR * categories.MOBILE, oUnit.UnitId) then
                    oUnit[refiBomberRange] = math.max((oUnit[refiBomberRange] or 0), oCurWeapon.MaxRadius)
                    if oCurWeapon.RateOfFire then oUnit[refiTimeBetweenBombs] = math.max((oUnit[refiTimeBetweenBombs] or 0), 1 / oCurWeapon.RateOfFire) end
                elseif (oCurWeapon.RangeCategory == 'UWRC_DirectFire' or (oCurWeapon.RangeCategory == 'UWRC_IndirectFire' and oCurWeapon.WeaponCategory == 'Direct Fire')) then --Sera sniper bots have an 'indirectfire' range category that is actually DF
                    bReplaceValues = false
                    bIgnoreValues = false
                    --Monkeylord special - use main laser weapon values only
                    if oUnit.UnitId == 'url0402' and oUnit:GetAIBrain().M28AI then
                        if (not(oUnit[refiDFRange]) or oCurWeapon.Label == 'MainGun') then
                            bReplaceValues = true
                        else
                            bIgnoreValues = true
                        end
                    end
                    if bReplaceValues then
                        oUnit[refiDFRange] = (oCurWeapon.MaxRadius or 0)
                        oUnit[refiDFMinRange] = oCurWeapon.MinRadius
                        if (oCurWeapon.DamageRadius or 0) > 0 then oUnit[refiDFAOE] = oCurWeapon.DamageRadius end
                        if oCurWeapon.RateOfFire then oUnit[refiTimeBetweenDFShots] = 1 / oCurWeapon.RateOfFire end
                    elseif not(bIgnoreValues) then
                        oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius or 0)
                        if oCurWeapon.MinRadius then
                            if oUnit[refiDFMinRange] then oUnit[refiDFMinRange] = math.min(oUnit[refiDFMinRange], oCurWeapon.MinRadius)
                            else oUnit[refiDFMinRange] = oCurWeapon.MinRadius
                            end
                        end
                        if (oCurWeapon.DamageRadius or 0) > 0 then oUnit[refiDFAOE] = math.max((oUnit[refiDFAOE] or 0), oCurWeapon.DamageRadius) end
                        if oCurWeapon.RateOfFire then oUnit[refiTimeBetweenDFShots] = math.max((oUnit[refiTimeBetweenDFShots] or 0), 1 / oCurWeapon.RateOfFire) end
                    end

                elseif oCurWeapon.RangeCategory == 'UWRC_AntiNavy' then
                    oUnit[refiAntiNavyRange] = math.max((oUnit[refiAntiNavyRange] or 0), oCurWeapon.MaxRadius)
                elseif oCurWeapon.RangeCategory == 'UWRC_AntiAir' or oCurWeapon.WeaponCategory == 'Anti Air' then
                    oUnit[refiAARange] = math.max((oUnit[refiAARange] or 0), oCurWeapon.MaxRadius)
                    if bUpdateAirAA and oCurWeapon.RateOfFire then
                        if not(oUnit[refiTimeBetweenAirAAShots]) then oUnit[refiTimeBetweenAirAAShots] = 1000000 end
                        oUnit[refiTimeBetweenAirAAShots] = math.min(oUnit[refiTimeBetweenAirAAShots], 1 / oCurWeapon.RateOfFire)
                    end
                elseif oCurWeapon.RangeCategory == 'UWRC_IndirectFire' then
                    --GC tractor claws - dont want to include as indirect fire weapon since logic is on the assumption indirect fire is good vs structures
                    if (oCurWeapon.Damage or 0) > 0.01 or not(oCurWeapon.WeaponCategory == 'Experimental') then
                        oUnit[refiIndirectRange] = math.max((oUnit[refiIndirectRange] or 0), oCurWeapon.MaxRadius)
                        if oCurWeapon.WeaponUnpacks then oUnit[refbWeaponUnpacks] = true end
                        oUnit[refiIndirectAOE] = math.max((oUnit[refiIndirectAOE] or 0), (oCurWeapon.DamageRadius or 0))
                        if oCurWeapon.RateOfFire then oUnit[refiTimeBetweenIFShots] = math.max((oUnit[refiTimeBetweenIFShots] or 0), 1 / oCurWeapon.RateOfFire) end
                    end
                elseif not(oCurWeapon.RangeCategory) or oCurWeapon.RangeCategory == 'UWRC_Undefined' then
                    if oCurWeapon.Label == 'Bomb' or oCurWeapon.DisplayName == 'Kamikaze' or oCurWeapon.Label == 'Torpedo' or (oCurWeapon.FireTargetLayerCapsTable.Air == 'Seabed|Sub|Water' and EntityCategoryContains(categories.AIR * categories.ANTINAVY, oUnit.UnitId)) then
                        oUnit[refiBomberRange] = math.max((oUnit[refiBomberRange] or 0), oCurWeapon.MaxRadius)
                        if oCurWeapon.RateOfFire then oUnit[refiTimeBetweenBombs] = math.max((oUnit[refiTimeBetweenBombs] or 0), 1 / oCurWeapon.RateOfFire) end
                    elseif oCurWeapon.WeaponCategory == 'Direct Fire' or oCurWeapon.WeaponCategory == 'Direct Fire Experimental' or oCurWeapon.WeaponCategory == 'Kamikaze' then
                        oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                        if oCurWeapon.MinRadius then
                            if oUnit[refiDFMinRange] then oUnit[refiDFMinRange] = math.min(oUnit[refiDFMinRange], oCurWeapon.MinRadius)
                            else oUnit[refiDFMinRange] = oCurWeapon.MinRadius
                            end
                        end
                        if (oCurWeapon.DamageRadius or 0) > 0 then oUnit[refiDFAOE] = math.max((oUnit[refiDFAOE] or 0), oCurWeapon.DamageRadius) end
                        if oCurWeapon.RateOfFire then oUnit[refiTimeBetweenDFShots] = math.max((oUnit[refiTimeBetweenDFShots] or 0), 1 / oCurWeapon.RateOfFire) end
                    elseif oCurWeapon.WeaponCategory == 'Indirect Fire' then
                        oUnit[refiIndirectRange] = math.max((oUnit[refiIndirectRange] or 0), oCurWeapon.MaxRadius)
                    elseif (oCurWeapon.Damage or 0) == 0 or (oCurWeapon.MaxRadius or 0) <= 1 then
                        --Ignore
                    elseif oUnit.UnitId == 'uab4201' then
                        --Aeon TMD - ignore as it has a rangecategory for the weapon that uses the correct range so want to ignore the other waepon anyway
                    elseif oCurWeapon.WeaponCategory == 'Death' or oCurWeapon.Label == 'DeathWeapon' then
                        --Do nothing - e.g. units like energy storage
                    elseif oCurWeapon.WeaponCategory == 'Bomb' then
                        --experimental wars - experimental spaceships have a 'bomb' weapon category
                        if oCurWeapon.FireTargetLayerCapsTable and oCurWeapon.FireTargetLayerCapsTable['Land'] == 'Land|Water|Seabed' and not(oCurWeapon.ManualFire) and not(oCurWeapon.NeedToComputeBombDrop) then
                            oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                            if oCurWeapon.MinRadius then
                                if oUnit[refiDFMinRange] then oUnit[refiDFMinRange] = math.min(oUnit[refiDFMinRange], oCurWeapon.MinRadius)
                                else oUnit[refiDFMinRange] = oCurWeapon.MinRadius
                                end
                            end
                        elseif EntityCategoryContains(categories.AIR * categories.MOBILE, oUnit.UnitId) then

                        else
                            M28Utilities.ErrorHandler('Unrecognised bomb weapon for unit '..oUnit.UnitId)
                        end
                    elseif oCurWeapon.WeaponCategory == 'Anti Navy' then
                        oUnit[refiAntiNavyRange] = math.max((oUnit[refiAntiNavyRange] or 0), oCurWeapon.MaxRadius)
                        --LOUD Additional checks since often units dont have a range category for a weapon - use FireTargetLayerCapsTable to help differentiate between AA; torpedo; and ground attacks (with damaged used to ignore most 'cosmetic' and special countermeasure type weapons:
                    elseif (oCurWeapon.FireTargetLayerCapsTable.Air and oCurWeapon.CannotAttackGround) or (oCurWeapon.FireTargetLayerCapsTable.Air == 'Air' and not(oCurWeapon.FireTargetLayerCapsTable.Land)) or oCurWeapon.FireTargetLayerCapsTable.Land == 'Air' or oCurWeapon.FireTargetLayerCapsTable.Water == 'Air' then
                        oUnit[refiAARange] = math.max((oUnit[refiAARange] or 0), (oCurWeapon.MaxRadius or 0))
                        if bUpdateAirAA and oCurWeapon.RateOfFire then
                            if not(oUnit[refiTimeBetweenAirAAShots]) then oUnit[refiTimeBetweenAirAAShots] = 1000000 end
                            oUnit[refiTimeBetweenAirAAShots] = math.min(oUnit[refiTimeBetweenAirAAShots], 1 / oCurWeapon.RateOfFire)
                        end
                    elseif oCurWeapon.FireTargetLayerCapsTable.Sub and oCurWeapon.FireTargetLayerCapsTable.Water and oCurWeapon.Damage >= 4 then
                        oUnit[refiAntiNavyRange] = math.max((oUnit[refiAntiNavyRange] or 0), oCurWeapon.MaxRadius)
                    elseif oCurWeapon.Damage >= 2 and not(oCurWeapon.FireTargetLayerCapsTable.Air) and (oCurWeapon.FireTargetLayerCapsTable.Land == 'Land|Water|Seabed' or (oCurWeapon.FireTargetLayerCapsTable.Water == 'Land|Water|Seabed' and not(oCurWeapon.FireTargetLayerCapsTable.Sub))) and EntityCategoryContains(categories.DIRECTFIRE + categories.INDIRECTFIRE, oUnit.UnitId) then
                        if EntityCategoryContains(categories.DIRECTFIRE, oUnit.UnitId) then oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                        else oUnit[refiIndirectRange] = math.max((oUnit[refiIndirectRange] or 0), oCurWeapon.MaxRadius)
                        end
                    elseif( oCurWeapon.FireTargetLayerCapsTable.Air == 'Land|Water|Seabed' or oCurWeapon.FireTargetLayerCapsTable.Air == 'Air|Land|Water') and oCurWeapon.Damage >= 2 then --e.g. gunship or transport
                        oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                    elseif oCurWeapon.FireTargetLayerCapsTable.Air =='Air|Land|water' and oCurWeapon.Damage >= 2 then --e.g. loud penetration fighter
                        oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                    elseif oCurWeapon.FireTargetLayerCapsTable.Land == 'Land|Water|Seabed|Air' and oCurWeapon.Damage >= 2 then
                        oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                        oUnit[refiAARange] = math.max((oUnit[refiAARange] or 0), oCurWeapon.MaxRadius)
                        oUnit[refiBomberRange] = math.max((oUnit[refiBomberRange] or 0), oCurWeapon.MaxRadius)
                        if oCurWeapon.RateOfFire then oUnit[refiTimeBetweenBombs] = math.max((oUnit[refiTimeBetweenBombs] or 0), 1 / oCurWeapon.RateOfFire) end
                        if bUpdateAirAA and oCurWeapon.RateOfFire then
                            if not(oUnit[refiTimeBetweenAirAAShots]) then oUnit[refiTimeBetweenAirAAShots] = 1000000 end
                            oUnit[refiTimeBetweenAirAAShots] = math.min(oUnit[refiTimeBetweenAirAAShots], 1 / oCurWeapon.RateOfFire)
                        end
                    elseif oCurWeapon.Label == 'TorpedoDecoy' and not(M28Utilities.bFAFActive) then --LOUD - Cybran T2 destroyer has a weapon with no RangeCategory
                        oUnit[refiTorpedoDefenceCount] = (oUnit[refiTorpedoDefenceCount] or 0) + GetTorpedoDefenceValue(oUnit, oCurWeapon)
                    elseif oCurWeapon.Label == 'DeckGuns' and not(M28Utilities.bFAFActive) then --LOUD - Frigate weapon is missing range category
                        oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                    elseif oCurWeapon.Label == 'Flamer' or oCurWeapon.Label == 'EXFlameCannon01' or oCurWeapon.Label == 'EXFlameCannon02' or oCurWeapon.Label == 'EXEMPArray02' or oCurWeapon.Label == 'EXEMPArray03' or oCurWeapon.Label == 'EXEMPArray04' or oCurWeapon.Label == 'BolterLeft' or oCurWeapon.Label == 'Cannon' or oCurWeapon.Label == 'DeckGun' or oCurWeapon.Label == 'HeavyBolter' or oCurWeapon.Label == 'RiotGun' then
                        oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                    elseif oCurWeapon.FireTargetLayerCapsTable.Air and (oCurWeapon.Label == 'EXAA02' or oCurWeapon.Label == 'EXAA03' or oCurWeapon.Label == 'EXAA04' or oCurWeapon.Label == 'AAGun' or oCurWeapon.Label == 'AAMissile' or oCurWeapon.Label == 'AAMissle' or oCurWeapon.Label == 'GatlingCannon' or oCurWeapon.Label == 'PhalanxGun') then
                        oUnit[refiAARange] = math.max((oUnit[refiAARange] or 0), oCurWeapon.MaxRadius)
                        if bUpdateAirAA and oCurWeapon.RateOfFire then
                            if not(oUnit[refiTimeBetweenAirAAShots]) then oUnit[refiTimeBetweenAirAAShots] = 1000000 end
                            oUnit[refiTimeBetweenAirAAShots] = math.min(oUnit[refiTimeBetweenAirAAShots], 1 / oCurWeapon.RateOfFire)
                        end
                    elseif oCurWeapon.DisplayName == 'Resonance Artillery' then
                        oUnit[refiIndirectRange] = math.max((oUnit[refiIndirectRange] or 0), oCurWeapon.MaxRadius)
                    elseif oCurWeapon.Label == 'AntiTorpedo' or oCurWeapon.Label == 'AntiTorpedo2' or oCurWeapon.Label == 'AntiTorpedo3' then
                        oUnit[refiTorpedoDefenceCount] = (oUnit[refiTorpedoDefenceCount] or 0) + GetTorpedoDefenceValue(oUnit, oCurWeapon)
                    elseif oCurWeapon.Label == 'TargetPainter' or oCurWeapon.Label == 'EXChronoDampener01' or oCurWeapon.Label == 'EXChronoDampener02' then
                        --Do nothing - LOUD weapon labels where there is no or negligible damage
                    elseif oCurWeapon.FireTargetLayerCapsTable.Water == 'Land|Water|Seabed' then
                        oUnit[refiAntiNavyRange] = math.max((oUnit[refiAntiNavyRange] or 0), oCurWeapon.MaxRadius)
                    elseif (oCurWeapon.Damage or 0) >= 5 and oCurWeapon.FireTargetLayerCapsTable.Air == 'Air|Land|Water|Seabed' and oCurWeapon.FireTargetLayerCapsTable.Land == 'Air|Land|Water|Seabed' then
                        oUnit[refiAARange] = math.max((oUnit[refiAARange] or 0), oCurWeapon.MaxRadius)
                        if EntityCategoryContains(categories.AIR * categories.MOBILE, oUnit.UnitId) then
                            oUnit[refiBomberRange] = math.max((oUnit[refiBomberRange] or 0), oCurWeapon.MaxRadius)
                            oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                            if bUpdateAirAA and oCurWeapon.RateOfFire then
                                if not(oUnit[refiTimeBetweenAirAAShots]) then oUnit[refiTimeBetweenAirAAShots] = 1000000 end
                                oUnit[refiTimeBetweenAirAAShots] = math.min(oUnit[refiTimeBetweenAirAAShots], 1 / oCurWeapon.RateOfFire)
                            end
                        elseif EntityCategoryContains(categories.DIRECTFIRE + categories.OVERLAYDIRECTFIRE, oUnit.UnitId) or not(EntityCategoryContains(categories.ARTILLERY + categories.INDIRECTFIRE + categories.OVERLAYINDIRECTFIRE, oUnit.UnitId)) then
                            oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                        else
                            oUnit[refiIndirectRange] = math.max((oUnit[refiIndirectRange] or 0), oCurWeapon.MaxRadius)
                        end
                    elseif oCurWeapon.Label == 'GapingMaw' or oCurWeapon.Label == 'ClawMelee' then
                        oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                    elseif oCurWeapon.Label == 'Laser' and oCurWeapon.FireTargetLayerCapsTable.Land == 'Land|Water|Seabed' and (oCurWeapon.Damage or 0) >= 5 then
                        oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                        --Manual unit BP based where above arent working:
                    elseif oUnit.UnitId == 'bel0307' then --Testing it doesnt fire at air units or underwater
                        oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                    elseif oUnit.UnitId == 'wel0305' then
                        if oCurWeapon.Label == 'GatlingCannon' then --fires at air and ground, but not underwater
                            oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                            oUnit[refiAARange] = math.max((oUnit[refiAARange] or 0), oCurWeapon.MaxRadius)
                            if bUpdateAirAA and oCurWeapon.RateOfFire then
                                if not(oUnit[refiTimeBetweenAirAAShots]) then oUnit[refiTimeBetweenAirAAShots] = 1000000 end
                                oUnit[refiTimeBetweenAirAAShots] = math.min(oUnit[refiTimeBetweenAirAAShots], 1 / oCurWeapon.RateOfFire)
                            end
                        else --redundancy
                            oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                        end
                    elseif oUnit.UnitId == 'brb2306' then
                        --E.g. cna trigger for its stun weapon; is PD that cant hit air units
                        oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                    elseif oUnit.UnitId == 'lab2320' then --barrarge artillery (not all of its weapons have indirect range cat)
                        oUnit[refiIndirectRange] = math.max((oUnit[refiIndirectRange] or 0), oCurWeapon.MaxRadius)
                    elseif oUnit.UnitId == 'lsb2320' then --T3 artillery building
                        oUnit[refiIndirectRange] = math.max((oUnit[refiIndirectRange] or 0), oCurWeapon.MaxRadius)
                    elseif oCurWeapon.FireTargetLayerCapsTable.Land == 'Air|Land|Water|Seabed' then --Confirmed for brnt3shbm and brnt3shpd - unit itself can target air units; based on blueprint looks likely this is the riotgun for brnt3shbm, while for the pd it looks like it's all 8 of the main guns
                        oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                        oUnit[refiAARange] = math.max((oUnit[refiAARange] or 0), oCurWeapon.MaxRadius)
                        if bUpdateAirAA and oCurWeapon.RateOfFire then
                            if not(oUnit[refiTimeBetweenAirAAShots]) then oUnit[refiTimeBetweenAirAAShots] = 1000000 end
                            oUnit[refiTimeBetweenAirAAShots] = math.min(oUnit[refiTimeBetweenAirAAShots], 1 / oCurWeapon.RateOfFire)
                        end
                    elseif oCurWeapon.FireTargetLayerCapsTable.Water == 'Air' then --confirmed for Heavy cruiser bss0306 based on blueprint
                        oUnit[refiAARange] = math.max((oUnit[refiAARange] or 0), oCurWeapon.MaxRadius)
                        if bUpdateAirAA and oCurWeapon.RateOfFire then
                            if not(oUnit[refiTimeBetweenAirAAShots]) then oUnit[refiTimeBetweenAirAAShots] = 1000000 end
                            oUnit[refiTimeBetweenAirAAShots] = math.min(oUnit[refiTimeBetweenAirAAShots], 1 / oCurWeapon.RateOfFire)
                        end
                    elseif oCurWeapon.FireTargetLayerCapsTable.Water == 'Land|Water' then
                        oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                    else
                        M28Utilities.ErrorHandler('Unrecognised range category for unit '..oUnit.UnitId..'='..(oCurWeapon.WeaponCategory or 'nil')..'; Weapon label='..(oCurWeapon.Label or 'nil'))
                        --If this triggers do a reprs of the weapon to figure out why (i.e. uncomment out the below)
                        --LOG('reprs of oCurWeapon='..reprs(oCurWeapon))
                    end
                else
                    M28Utilities.ErrorHandler('Unrecognised range category '..oCurWeapon.RangeCategory..' for unit '..oUnit.UnitId)
                end
            end
            if oCurWeapon.WeaponUnpacks and oCurWeapon.WeaponUnpackLocksMotion then bWeaponUnpacks = true
            elseif oCurWeapon.SlavedToBody or oCurWeapon.SlavedToTurret then bWeaponIsFixed = true
            end
            if bDebugMessages == true then
                LOG(sFunctionRef..': just Considered weapon '..oCurWeapon.Label..'; oUnit[refiDFRange]='..(oUnit[refiDFRange] or 'nil')..'; Indirect='..(oUnit[refiIndirectRange] or 'nil')..'; Manual='..(oUnit[refiManualRange] or 'nil')..'; oCurWeapon.EnabledByEnhancement='..(oCurWeapon.EnabledByEnhancement or 'nil')..'; Weapon max radius='..(oCurWeapon.MaxRadius or 'nil'))
                if oCurWeapon.EnabledByEnhancement then
                    LOG('Have enhancement='..tostring(oUnit:HasEnhancement(oCurWeapon.EnabledByEnhancement)))
                end
            end
        end
        if M28Utilities.IsTableEmpty(oBP.Enhancements) == false and (oUnit[refiDFRange] or 0) > 0 then
            --Check if we have a max range in an enhancement
            for sEnhancement, tEnhancement in oBP.Enhancements do
                if tEnhancement.NewMaxRadius and oUnit.HasEnhancement and oUnit:HasEnhancement(sEnhancement) then
                    oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), tEnhancement.NewMaxRadius)
                end
            end
            if oUnit.UnitId == 'ual0204' and oUnit:HasEnhancement('EnhancedWeapon') then
                oUnit[refiDFRange] = oUnit[refiDFRange] * 1.25
            end
        end
        if not(bWeaponUnpacks or (bWeaponIsFixed and EntityCategoryContains(categories.EXPERIMENTAL - refCategoryFatboy, oUnit.UnitId))) then
            --Manual overrides
            if oUnit.UnitId == 'brmt3ava' or oUnit.UnitId == 'wel0405' then
                --Cant kite well so flag it cant kite
            else
                oUnit[refbCanKite] = true
            end
        end

        --Special unit adjustments:
        --Seraphim sniperbot - want to enable long range if we own it
        if oUnit.GetAIBrain and oUnit:GetAIBrain().M28AI and EntityCategoryContains(refCategorySniperBot * categories.SERAPHIM, oUnit.UnitId) then
            ForkThread(EnableLongRangeSniper, oUnit) --forked thread as in replay 22225087 April 2024 an error was caused by running this
            --LOG('Enabled long range on sniper, DFRange='..oUnit[refiDFRange]..'; Strike damage='..GetUnitStrikeDamage(oUnit))
        end
        --Fatboy - treat DF and indirect range as being the higher of its two ranges
        if EntityCategoryContains(refCategoryFatboy, oUnit.UnitId) then
            oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), (oUnit[refiIndirectRange] or 0))
            oUnit[refiIndirectRange] = oUnit[refiDFRange]
        end
        --LOG('Considering unitID '..(oUnit.UnitId or 'nil')..'; is unit valid='..tostring(IsUnitValid(oUnit)))
    end
    --LOUD - doesnt record whether weapons for ACU are enabled by enhancement or not.  As a very simplistic measure, if the unit has an enhancement count of 0 then treat its range as being 30, or 36 with 1 enhancement, or the max DF range otherwise
    if M28Utilities.bLoudModActive and EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
        local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
        if (oUnit[M28ACU.refiUpgradeCount] or 0) == 0 then
            oUnit[refiDFRange] = math.min(30, (oUnit[refiDFRange] or 0))
            if oUnit[refiAntiNavyRange] then oUnit[refiAntiNavyRange] = 0 end
            if oUnit[refiIndirectRange] then oUnit[refiIndirectRange] = 0 end
        elseif oUnit[M28ACU.refiUpgradeCount] == 1 then
            oUnit[refiDFRange] = math.min(36, (oUnit[refiDFRange] or 0))
        end
    end
    --Record unit best range
    oUnit[refiCombatRange] = math.max((oUnit[refiDFRange] or 0), (oUnit[refiIndirectRange] or 0), (oUnit[refiAntiNavyRange] or 0))
    oUnit[refiStrikeDamage] = GetUnitStrikeDamage(oUnit, bReferenceIsATableWithUnitId)
    --Record attackmove range if LOUD is active
    if oBP.AI.GuardScanRadius then oUnit[refiWeaponScanRange] = oBP.AI.GuardScanRadius end --want to be nil if not present; looks like this is a LOUD specific value from a couple of unit blueprint spot-checks

    --Record mass cost
    local iMassCost = (oBP.Economy.BuildCostMass or 0)
    if oUnit.HasEnhancement and oBP.Enhancements then
        for sEnhancement, tEnhancement in oBP.Enhancements do
            if oUnit:HasEnhancement(sEnhancement) then
                if bDebugMessages == true then LOG(sFunctionRef..': Including enhancement cost in unit mass value, unit='..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; sEnhancement='..sEnhancement..'; Enhancement mass cost='..(tEnhancement.BuildCostMass or 0)) end
                iMassCost = iMassCost + (tEnhancement.BuildCostMass or 0)
            end
        end
    end
    oUnit[refiUnitMassCost] = iMassCost
    if bDebugMessages == true then LOG(sFunctionRef..': Finished recording range, mass value and other info for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; DFRange='..(oUnit[refiDFRange] or 'nil')..'; Indirect range='..(oUnit[refiIndirectRange] or 'nil')..'; AntiNavy range='..(oUnit[refiAntiNavyRange] or 'nil')..';Mass cost='..oUnit[refiUnitMassCost]..'; Can unit kite='..tostring(oUnit[refbCanKite] or false)..'; Bomber range='..(oUnit[refiBomberRange] or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConvertTechLevelToCategory(iTechLevel)
    if iTechLevel == 2 then return categories.TECH2
    elseif iTechLevel == 3 then return categories.TECH3
    elseif iTechLevel == 4 then return categories.EXPERIMENTAL
    else return categories.TECH1
    end
end

function ConvertFactionToCategory(iFaction)
    if iFaction == refFactionUEF then return categories.UEF
    elseif iFaction == refFactionCybran then return categories.CYBRAN
    elseif iFaction == refFactionAeon then return categories.AEON
    elseif iFaction == refFactionSeraphim then return categories.SERAPHIM
    else return categories.ALLUNITS -categories.UEF -categories.CYBRAN -categories.AEON -categories.SERAPHIM
    end
end
function ConvertFactionIDToName(iFaction)
    if iFaction == refFactionUEF then return 'UEF'
    elseif iFaction == refFactionCybran then return 'Cybran'
    elseif iFaction == refFactionAeon then return 'Aeon'
    elseif iFaction == refFactionSeraphim then return 'Seraphim'
    else return 'Unrecognised'
    end
end

function GetUnitUpgradeBlueprint(oUnitToUpgrade, bGetSupportFactory)
    --Returns support factory ID if it can be built, otherwise returns normal upgrade unit (works for any unit, not just factory)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnitUpgradeBlueprint'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bGetSupportFactory == nil then bGetSupportFactory = true end
    --Gets the support factory blueprint, and checks if it can be built; if not then returns the normal UpgradesTo blueprint
    local sUpgradeBP
    if not(oUnitToUpgrade.Dead) and oUnitToUpgrade.CanBuild then
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, UnitToUpgrade='..oUnitToUpgrade.UnitId..GetUnitLifetimeCount(oUnitToUpgrade)) end
        if bGetSupportFactory == true and oUnitToUpgrade.CanBuild then
            local tsSupportFactoryBP = {

                -- Aeon
                ['uab0101']  = 'zab9501',
                ['uab0102']  = 'zab9502',
                ['uab0103']  = 'zab9503',
                ['uab0201'] = 'zab9601',
                ['uab0202'] = 'zab9602',
                ['uab0203'] = 'zab9603',

                -- UEF
                ['ueb0101']  = 'zeb9501',
                ['ueb0102']  = 'zeb9502',
                ['ueb0103']  = 'zeb9503',
                ['ueb0201'] = 'zeb9601',
                ['ueb0202'] = 'zeb9602',
                ['ueb0203'] = 'zeb9603',

                -- Cybran
                ['urb0101']  = 'zrb9501',
                ['urb0102']  = 'zrb9502',
                ['urb0103']  = 'zrb9503',
                ['urb0201'] = 'zrb9601',
                ['urb0202'] = 'zrb9602',
                ['urb0203'] = 'zrb9603',

                -- Seraphim
                ['xsb0101']  = 'zsb9501',
                ['xsb0102']  = 'zsb9502',
                ['xsb0103']  = 'zsb9503',
                ['xsb0201'] = 'zsb9601',
                ['xsb0202'] = 'zsb9602',
                ['xsb0203'] = 'zsb9603',

                -- Seraphim
                ['xsb0101']  = 'zsb9501',
                ['xsb0102']  = 'zsb9502',
                ['xsb0103']  = 'zsb9503',
                ['xsb0201'] = 'zsb9601',
                ['xsb0202'] = 'zsb9602',
                ['xsb0203'] = 'zsb9603',
            }

            local sFactoryBP = oUnitToUpgrade.UnitId
            if tsSupportFactoryBP[sFactoryBP] then
                if bDebugMessages == true then LOG(sFunctionRef..': Support factoryBP='..tsSupportFactoryBP[sFactoryBP]) end
                sUpgradeBP = tsSupportFactoryBP[sFactoryBP]
                if (M28Utilities.bFAFActive or __blueprints[sUpgradeBP]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': oUnitToUpgrade='..sFactoryBP..GetUnitLifetimeCount(oUnitToUpgrade)..'; Checking if can upgrade to sUpgradeBP='..sUpgradeBP..'; oUnitToUpgrade:CanBuild(sUpgradeBP)='..tostring(oUnitToUpgrade:CanBuild(sUpgradeBP))) end
                    if not(oUnitToUpgrade:CanBuild(sUpgradeBP)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Cant build '..sUpgradeBP) end
                        sUpgradeBP = nil
                    end
                else
                    sUpgradeBP = nil
                end
            end
        end
        if not(sUpgradeBP) then
            local oFactoryBP = oUnitToUpgrade:GetBlueprint()
            sUpgradeBP = oFactoryBP.General.UpgradesTo
            if bDebugMessages == true then LOG(sFunctionRef..': sUpgradeBP='..(sUpgradeBP or 'nil')) end
            if not(sUpgradeBP) or sUpgradeBP == '' or not(oUnitToUpgrade:CanBuild(sUpgradeBP)) then sUpgradeBP = nil end
            if bDebugMessages == true then LOG(sFunctionRef..': Didnt have valid support factory to upgrade to; blueprint UpgradesTo='..(sUpgradeBP or 'nil')) end
        end
        if sUpgradeBP == '' then
            sUpgradeBP = nil
            if bDebugMessages == true then LOG(sFunctionRef..': Have no blueprint to upgrade to') end
        elseif bDebugMessages == true then LOG(sFunctionRef..': Returning sUpgradeBP '..(sUpgradeBP or 'nil')..' subject to final unit restriction check')
        end
    end

    if sUpgradeBP then
        if not(oUnitToUpgrade:CanBuild(sUpgradeBP)) then
            if bDebugMessages == true then LOG(sFunctionRef..': oUnitToUpgrade '..oUnitToUpgrade.UnitId..GetUnitLifetimeCount(oUnitToUpgrade)..' cant build sUpgradeBP='..sUpgradeBP..' e.g. due to unit restrictions') end
            sUpgradeBP = nil
        else
            local iArmyIndex = oUnitToUpgrade.Army
            if bDebugMessages == true then LOG(sFunctionRef..': oUnitToUpgrade '..oUnitToUpgrade.UnitId..GetUnitLifetimeCount(oUnitToUpgrade)..' checking if is restricted for sUpgradeBP='..sUpgradeBP..', isrestricted='..tostring(IsUnitRestricted(sUpgradeBP, iArmyIndex))) end
            if IsUnitRestricted(sUpgradeBP, iArmyIndex) then
                sUpgradeBP = nil
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return sUpgradeBP
end

function DoesCategoryContainCategoryUSEM28UTILITIESVERSION()
end

function GetUpgradeBuildTime(oUnit, sUpgradeRef)
    --Returns nil if unit cant get enhancements
    local oBP = oUnit:GetBlueprint()
    local iUpgradeTime
    if oBP.Enhancements then
        for sUpgradeID, tUpgrade in oBP.Enhancements do
            if sUpgradeID == sUpgradeRef then
                iUpgradeTime = tUpgrade.BuildTime
            end

        end
    end
    return iUpgradeTime
end

function GetUpgradeMassCost(oUnit, sUpgradeRef)
    local oBP = oUnit:GetBlueprint()
    local iUpgradeMass
    if oBP.Enhancements then
        for sUpgradeID, tUpgrade in oBP.Enhancements do
            if sUpgradeID == sUpgradeRef then
                iUpgradeMass = tUpgrade.BuildCostMass
            end

        end
    end
    if not(iUpgradeMass) then M28Utilities.ErrorHandler('oUnit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' has no upgrade with reference '..sUpgradeRef) end
    return iUpgradeMass
end

function GetUpgradeEnergyCost(oUnit, sUpgradeRef)
    local oBP = oUnit:GetBlueprint()
    local iUpgradeEnergy
    if oBP.Enhancements then
        for sUpgradeID, tUpgrade in oBP.Enhancements do
            if sUpgradeID == sUpgradeRef then
                iUpgradeEnergy = tUpgrade.BuildCostEnergy
            end

        end
    end
    if not(iUpgradeEnergy) then M28Utilities.ErrorHandler('oUnit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' has no upgrade with reference '..sUpgradeRef) end
    return iUpgradeEnergy
end

function AddOrRemoveUnitFromListOfPausedUnits(oUnit, bPauseNotUnpause, iOptionalTeam, iPausePriority)
    --iPausePriority - if pausing unit, will reord this against the unit
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddOrRemoveUnitFromListOfPausedUnits'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Remove from list of paused units
    local iTeam = iOptionalTeam or oUnit:GetAIBrain().M28Team
    if not(bPauseNotUnpause) then
        local iUnitPausePriority = oUnit[refiPausedPriority]
        if iUnitPausePriority then
            local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
            local tUnitTable = M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority][iUnitPausePriority]
            if M28Utilities.IsTableEmpty(tUnitTable) == false then
                local iAllPausedUnits = table.getn(tUnitTable)
                for iCurUnit = iAllPausedUnits, 1, -1 do
                    if tUnitTable[iCurUnit] == oUnit then
                        table.remove(tUnitTable, iCurUnit)
                        M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount] = M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount] - 1
                        --LOG('Clearing paused priority for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit))
                        oUnit[refiPausedPriority] = nil
                        break
                    end
                end
            end
        elseif oUnit[refbPaused] then
            M28Utilities.ErrorHandler('Unpausing unit with no pause priority, so unable to locate it in the table, unit='..(oUnit.UnitId or 'nil')..(GetUnitLifetimeCount(oUnit) or 'nil'))
        end
    else
        --Are pausing unit, make sure it is in the table of paused units
        if not(oUnit[refbPaused]) or not(oUnit[refiPausedPriority]) then
            local bRecordUnit = true
            local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
            if not(M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority][iPausePriority]) then
                if bDebugMessages == true then LOG(sFunctionRef..': First time running so will setup variable, iTeam='..(iTeam or 'nil')..'; Unit='..(oUnit.UnitId or 'nil')..(GetUnitLifetimeCount(oUnit) or 'nil')) end
                if not(M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority]) then M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority] = {} end
                M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority][iPausePriority] = {}
            else
                --Check not already recorded this unit (redundancy to avoid near-infinite loop that saw in M27 where untis would keep getting added to the table resulting in the same unit considered 20+ times)
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority][iPausePriority]) == false then
                    for iRecordedUnit, oRecordedUnit in M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority][iPausePriority] do
                        if oRecordedUnit == oUnit then
                            bRecordUnit = false
                            break
                        end
                    end
                end
            end
            if bRecordUnit then
                --LOG('AddOrRemoveUnitFromListOfPausedUnits: Adding unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' to table of paused units')
                table.insert(M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority][iPausePriority], oUnit)
                oUnit[refiPausedPriority] = iPausePriority
                M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount] = M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount] + 1
                --LOG('Setting paused priority for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' equal to '..(iPausePriority or 'nil'))
                if not(iPausePriority) then M28Utilities.ErrorHandler('Havent specified pause priority for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)) end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; oUnit[refbPaused]='..tostring(oUnit[refbPaused] or false)..'; iPausePriority='..(iPausePriority or 'nil')..'; Unit owner='..oUnit:GetAIBrain().Nickname..'; bPauseNotUnpause='..tostring(bPauseNotUnpause or false)..'; time='..GetGameTimeSeconds()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    --LOG('AddOrRemove from paused table after considering unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; bPausedNotUnpause='..tostring(bPauseNotUnpause)..'; Is paused='..tostring(oUnit[refbPaused])..'; Pause priority='..(oUnit[refiPausedPriority] or 'nil'))
end

function ForkedPauseUnit(oUnit, bPauseNotUnpause)
    --Even adding a not(oUnit.Dead) check can still have an error in LOUD; however forked thread so shoudlnt matter
    --Other things tried is checking unit fraction is complete, and not trying to pause if :IsPaused is already true, but this didnt work in LOUD - i.e. would have an error when trying to pause an already paused factory

    --if not(oUnit.Dead) and oUnit:GetFractionComplete() == 1 then
        --if not(oUnit.IsPaused and bPauseNotUnpause and oUnit:IsPaused()) then
            oUnit:SetPaused(bPauseNotUnpause)
        --end
    --end
end

function PauseOrUnpauseMassUsage(oUnit, bPauseNotUnpause, iOptionalTeam, iPausePriority)
    --iPausePriority - only needed if are pausing the unit
    if bDontConsiderCombinedArmy or oUnit.M28Active then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'PauseOrUnpauseMassUsage'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



        if bDebugMessages == true then
            local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
            LOG(sFunctionRef..': Start of code time='..GetGameTimeSeconds()..', oUnit='..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; Unit state='..GetUnitState(oUnit)..'; Engineer action (if have one)='..(oUnit[M28Engineer.refiAssignedAction] or 'nil')..'; oUnit:IsPaused='..tostring(oUnit:IsPaused()))
            if oUnit.GetWorkProgress then LOG(sFunctionRef..': Unit work progress='..oUnit:GetWorkProgress()) end
        end

        if IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 and oUnit.SetPaused then
            --Want to pause unit, check for any special logic for pausing
            --Normal logic - just pause unit - exception if are dealing with a factory whose workcomplete is 100% and want to pause it
            if (not(bPauseNotUnpause) or not(oUnit:IsPaused())) and (not(EntityCategoryContains(refCategoryFactory, oUnit.UnitId)) or (oUnit.GetWorkProgress and oUnit:GetWorkProgress() > 0 and oUnit:GetWorkProgress() < 1) or (oUnit:IsPaused() and not(bPauseNotUnpause))) then

                if oUnit.UnitId == 'xsb2401' and bPauseNotUnpause then M28Utilities.ErrorHandler('Pausing Yolona') end
                if bDebugMessages == true then LOG(sFunctionRef..': About to set paused to '..tostring(bPauseNotUnpause)..' for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' Unit state='..GetUnitState(oUnit))
                    if oUnit.GetWorkProgress then LOG(sFunctionRef..': Unit work progress='..oUnit:GetWorkProgress()) end
                end
                if M28Utilities.bLoudModActive then
                    ForkThread(ForkedPauseUnit, oUnit, bPauseNotUnpause)
                else
                    oUnit:SetPaused(bPauseNotUnpause)
                end
                oUnit[refbPaused] = bPauseNotUnpause
                --If unit isnt actually paused (e.g. due to error with set paused) then clear this flag - disabled as was leading to false cases where unit was paused but this triggered
                --if oUnit[refbPaused] and not(oUnit:IsPaused()) then
                --oUnit[refbPaused] = false
                --if bDebugMessages == true then LOG(sFunctionRef..': Unit isnt actually paused so wont set this flag') end
                --end
                if bDebugMessages == true then LOG(sFunctionRef..': Will update table of paused units, iPausePriority='..(iPausePriority or 'nil')) end
                AddOrRemoveUnitFromListOfPausedUnits(oUnit, bPauseNotUnpause, iOptionalTeam, iPausePriority)

                if bDebugMessages == true then LOG(sFunctionRef..': Just set paused to '..tostring(bPauseNotUnpause)..' for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; oUnit[refbPaused]='..tostring(oUnit[refbPaused])) end
            elseif bDebugMessages == true then
                LOG(sFunctionRef..': Factory with either no workprogress or workprogress that isnt <1')
                if oUnit.GetWorkProgress then LOG(sFunctionRef..': Workprogress='..oUnit:GetWorkProgress()) end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Unit isnt valid') end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': End of mass pause, after considering unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; bPausedNotUnpause='..tostring(bPauseNotUnpause)..'; Is paused='..tostring(oUnit[refbPaused])..'; Pause priority='..(oUnit[refiPausedPriority] or 'nil')) end

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function PauseOrUnpauseEnergyUsage(oUnit, bPauseNotUnpause, bExcludeProduction, iOptionalTeam, iPausePriority)
    --iPausePriority - only needed if are pausing the unit
    if bDontConsiderCombinedArmy or oUnit.M28Active then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'PauseOrUnpauseEnergyUsage'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



        if bDebugMessages == true then
            LOG(sFunctionRef..': Start of code time='..GetGameTimeSeconds()..', oUnit='..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' owned by brain '..oUnit:GetAIBrain().Nickname..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; Unit state='..GetUnitState(oUnit)..'; Unit is paused='..tostring(oUnit:IsPaused())..'; bExcludeProduction='..tostring(bExcludeProduction or false))
            if oUnit.GetFocusUnit and oUnit:GetFocusUnit() then LOG(sFunctionRef..': Focus unit='..oUnit:GetFocusUnit().UnitId..GetUnitLifetimeCount(oUnit:GetFocusUnit())) end
            if oUnit.GetWorkProgress then LOG(sFunctionRef..': Unit work progress='..oUnit:GetWorkProgress()..'; Unit fraction complete='..oUnit:GetFractionComplete()..'; Is arti template nil='..tostring(oUnit[import('/mods/M28AI/lua/AI/M28Building.lua').reftArtiTemplateRefs] == nil)) end
        end
        if IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 and oUnit.SetPaused then
            --Normal logic - just pause unit - exception if are dealing with a factory whose workcomplete is 100%
            --Want this to run before the later stages so can properly track if unit is paused
            if not(bExcludeProduction) or bPauseNotUnpause then

                if oUnit.SetPaused and (not(bPauseNotUnpause) or not(oUnit:IsPaused())) and (not(EntityCategoryContains(refCategoryFactory, oUnit.UnitId)) or (oUnit.GetWorkProgress and oUnit:GetWorkProgress() > 0 and oUnit:GetWorkProgress() < 1)) then
                    if oUnit.UnitId == 'xsb2401'  and bPauseNotUnpause then M28Utilities.ErrorHandler('Pausing Yolona') end
                    if bDebugMessages == true then LOG(sFunctionRef..': About to set paused to '..tostring(bPauseNotUnpause)..' for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; Unit state='..GetUnitState(oUnit))
                        if oUnit.GetWorkProgress then LOG(sFunctionRef..': Unit work progress='..oUnit:GetWorkProgress()) end
                    end
                    if M28Utilities.bLoudModActive then
                        ForkThread(ForkedPauseUnit, oUnit, bPauseNotUnpause)
                    else
                        oUnit:SetPaused(bPauseNotUnpause)
                    end
                    oUnit[refbPaused] = bPauseNotUnpause
                    --If unit isnt actually paused (e.g. due to error with set paused) then clear this flag - disabled in v75 due to case with energy pause where unit would be paused but :IsPaused would return flase
                    --[[if oUnit[refbPaused] and not(oUnit:IsPaused()) then
                        oUnit[refbPaused] = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Unit isnt actually paused so wont set this flag (but will change back to paused later if we pause energy requiring abilities)') end
                    end--]]
                    AddOrRemoveUnitFromListOfPausedUnits(oUnit, bPauseNotUnpause, iOptionalTeam, iPausePriority)

                    if bDebugMessages == true then LOG(sFunctionRef..': Just set paused to '..tostring(bPauseNotUnpause)..' for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)) end
                elseif bDebugMessages == true then
                    LOG(sFunctionRef..': Factory with either no workprogress or workprogress that isnt <1; is .SetPaused nil='..tostring(oUnit.SetPaused == nil)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; Unit[refbPaused]='..tostring(oUnit[refbPaused])..'; fraction complete='..oUnit:GetFractionComplete()..'; Is unit a factory='..tostring(EntityCategoryContains(refCategoryFactory, oUnit.UnitId)))
                    if oUnit.GetWorkProgress then LOG(sFunctionRef..': Workprogress='..oUnit:GetWorkProgress()) end
                end
            end


            --Jamming - check via blueprint since no reliable category
            local oBP = oUnit:GetBlueprint()
            if oBP.Intel.JamRadius then
                if bPauseNotUnpause then DisableUnitJamming(oUnit)
                else EnableUnitJamming(oUnit)
                end
            end

            --Want to pause/unpause unit, check for any special logic for pausing
            --local bWasUnitPaused = (oUnit[refbPaused] or false)
            if oUnit.MyShield and oUnit.MyShield:GetMaxHealth() > 0 then
                if IsUnitShieldEnabled(oUnit) == bPauseNotUnpause then
                    if bPauseNotUnpause then DisableUnitShield(oUnit)
                    else EnableUnitShield(oUnit) end
                    oUnit[refbPaused] = bPauseNotUnpause
                end
            elseif oBP.Intel.ReactivateTime and (oBP.Intel.SonarRadius or oBP.Intel.RadarRadius) then
                if bPauseNotUnpause then DisableUnitIntel(oUnit)
                else EnableUnitIntel(oUnit)
                end
                oUnit[refbPaused] = bPauseNotUnpause
            elseif oBP.Intel.Cloak or oBP.Intel.RadarStealth or oBP.Intel.RadarStealthFieldRadius then
                if bPauseNotUnpause then DisableUnitStealth(oUnit)
                else EnableUnitStealth(oUnit)
                end
                oUnit[refbPaused] = bPauseNotUnpause
            end
            if bDebugMessages == true then LOG(sFunctionRef..': end of code oUnit[refbPaused]='..tostring(oUnit[refbPaused] or false)..'; oUnit[refiPausedPriority]='..(oUnit[refiPausedPriority] or 'nil')) end

        end

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end

end

--WARNING - careful using below function - added it in place of a manual :SetPaused usage that came across, but expect it will cause issues if used more generally
function PauseOrUnpauseUnitWithoutTracking(oUnit, bPauseNotUnpause)
    --WARNING - see above
    if bDontConsiderCombinedArmy or oUnit.M28Active then
        oUnit[refbPaused] = bPauseNotUnpause
        if M28Utilities.bLoudModActive then
            ForkThread(ForkedPauseUnit, oUnit, bPauseNotUnpause)
        else
            oUnit:SetPaused(bPauseNotUnpause)
        end
    end
end

function SetUnitMissileAutoBuildStatus(oUnit, bAutoBuild)
    if (bDontConsiderCombinedArmy or oUnit.M28Active) and oUnit.SetAutoMode then
        oUnit:SetAutoMode(bAutoBuild)
    end
end

function GetFactionFromBP(oBlueprint)
    --Returns faction number for oBlueprint
    --1: UEF, 2: Aeon, 3: Cybran, 4: Seraphim, 5: Nomads, 6 = not recognised
    --Note: General.FactionName property uses lowercase for some factions; the categories.x uses upper case
    --Assumed nomads is Nomads

    local tFactionsByName = {[refFactionUEF] = 'UEF', [refFactionAeon] = 'Aeon', [refFactionCybran] = 'Cybran', [refFactionSeraphim] = 'Seraphim', [refFactionNomads] = 'Nomads'}
    local sUnitFactionName = oBlueprint.General.FactionName
    for iName, sName in tFactionsByName do
        if sName == sUnitFactionName then return iName end
    end
    return refFactionUnrecognised
end

function GetFactionNumberFromBlueprint(sBlueprint)
    if EntityCategoryContains(categories.UEF, sBlueprint) then return refFactionUEF
    elseif EntityCategoryContains(categories.AEON, sBlueprint) then return refFactionAeon
    elseif EntityCategoryContains(categories.CYBRAN, sBlueprint) then return refFactionCybran
    elseif EntityCategoryContains(categories.SERAPHIM, sBlueprint) then return refFactionSeraphim
    else return refFactionUnrecognised
    end
end

function GetUnitFaction(oUnit)
    ----1: UEF, 2: Aeon, 3: Cybran, 4: Seraphim, 5: Nomads, 6 = not recognised
    return GetFactionFromBP(oUnit:GetBlueprint())
end

function GetFactoryType(oUnit)
    local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua') --Putting this at the top crashes the game

    if EntityCategoryContains(refCategoryLandFactory, oUnit.UnitId) then
        return M28Factory.refiFactoryTypeLand, refCategoryLandFactory
    elseif EntityCategoryContains(refCategoryAirFactory, oUnit.UnitId) then
        return M28Factory.refiFactoryTypeAir, refCategoryAirFactory
    elseif EntityCategoryContains(refCategoryNavalFactory, oUnit.UnitId) then
        return M28Factory.refiFactoryTypeNaval, refCategoryNavalFactory
    else return M28Factory.refiFactoryTypeOther, categories.FACTORY
    end
end

function GetUnitFacingAngle(oUnit)
    --0/360 = north, 90 = west, 180 = south, 270 = east

    --T3 arti - get the angle of the turret
    if EntityCategoryContains(categories.STRUCTURE * categories.DIRECTFIRE + categories.STRUCTURE * categories.INDIRECTFIRE, oUnit.UnitId) then
        if oUnit.GetWeapon and oUnit:GetWeaponCount() > 0 then
            --LOG('GetFacingAngle: oUnit='..oUnit.UnitId..GetUnitLifetimeCount(oUnit))
            local oWeapon = oUnit:GetWeapon(1)
            if oWeapon and oWeapon.GetAimManipulator and oWeapon:GetAimManipulator().GetHeadingPitch then
                return M28Utilities.ConvertRadiansToAngle(oWeapon:GetAimManipulator():GetHeadingPitch())
            else return 0
            end
        else return 0
        end
        if oUnit:IsValidBone('Turret') then
            --0% = south, 25% = east, 50% = north; want to convert from % into angle where 0 is north
            return M28Utilities.ConvertCounterclockwisePercentageToAngle(oUnit:GetBoneDirection('Turret'))
        else
            return 180 - oUnit:GetHeading() / math.pi * 180 --redundancy - for a building this is likeliy to be the same value every time
        end
    else
        --Other units (would expect to be mobile) - get the unit direction
        return 180 - oUnit:GetHeading() / math.pi * 180
    end

end

function IsUnitUnderwater(oUnit)
    if oUnit.GetPosition and oUnit.GetBlueprint then
        if EntityCategoryContains(categories.SUBMERSIBLE, oUnit.UnitId) then
            --E.g. tempest - sizey is 4, but when it is submerged it is only 2.6 below water level
            return M28Map.IsUnderwater({oUnit:GetPosition()[1], oUnit:GetPosition()[2] + (oUnit:GetBlueprint().SizeY or 0) * 0.5, oUnit:GetPosition()[3]}, false)
        else
            return M28Map.IsUnderwater({oUnit:GetPosition()[1], oUnit:GetPosition()[2] + (oUnit:GetBlueprint().SizeY or 0), oUnit:GetPosition()[3]}, false)
        end
    else return false
    end
end

function GetUnitUniqueRef(oUnit)
    return oUnit:GetAIBrain():GetArmyIndex()..oUnit.UnitId..GetUnitLifetimeCount(oUnit)
end

function GetClampsByType(oTransport)
    --small, medium, large, experimental, and stinger,
    --    refClampSmall = 1
    --    refClampMedium = 2
    --    refClampLarge = 3
    --    refClampExperimental = 4 --Incase ever decide to support nomads experimental transports
    --    refClampStinger = 5
    local tiClampsByType = {
        ['uea0203'] = { [refClampSmall] = 0, [refClampMedium] = 0, [refClampLarge] = 0, [refClampExperimental] = 0, [refClampStinger] = 1 }, --Stinger
        ['uea0107'] = { [refClampSmall] = 2, [refClampMedium] = 0, [refClampLarge] = 1, [refClampExperimental] = 0, [refClampStinger] = 0 }, --UEF T1
        ['ura0107'] = { [refClampSmall] = 2, [refClampMedium] = 0, [refClampLarge] = 1, [refClampExperimental] = 0, [refClampStinger] = 0 }, --Cybran t1
        ['uaa0107'] = { [refClampSmall] = 2, [refClampMedium] = 0, [refClampLarge] = 1, [refClampExperimental] = 0, [refClampStinger] = 0 }, --Aeon T1 (in some cases it can carry more)
        ['xsa0107'] = { [refClampSmall] = 0, [refClampMedium] = 2, [refClampLarge] = 1, [refClampExperimental] = 0, [refClampStinger] = 0 }, --Sera T1
        ['uea0104'] = { [refClampSmall] = 2, [refClampMedium] = 0, [refClampLarge] = 3, [refClampExperimental] = 0, [refClampStinger] = 0 }, --UEF T2
        ['ura0104'] = { [refClampSmall] = 2, [refClampMedium] = 0, [refClampLarge] = 2, [refClampExperimental] = 0, [refClampStinger] = 0 }, --Cybran T2
        ['uaa0104'] = { [refClampSmall] = 4, [refClampMedium] = 0, [refClampLarge] = 2, [refClampExperimental] = 0, [refClampStinger] = 0 }, --Aeon T2 (in some cases it can carry more)
        ['xsa0104'] = { [refClampSmall] = 0, [refClampMedium] = 0, [refClampLarge] = 4, [refClampExperimental] = 0, [refClampStinger] = 0 }, --Sera T2
        ['xea0306'] = { [refClampSmall] = 4, [refClampMedium] = 0, [refClampLarge] = 6, [refClampExperimental] = 0, [refClampStinger] = 0 }, --UEF T3
    }
    local tiUnitClampsByType =  tiClampsByType[oTransport.UnitId]
    if not(tiUnitClampsByType) then
        if EntityCategoryContains(categories.TECH1, oTransport.UnitId) then tiUnitClampsByType =  tiClampsByType['uea0107']
        else tiUnitClampsByType = tiClampsByType['ura0104']
        end
    end
    return tiUnitClampsByType
end

function GetTransportMaxCapacity(oTransport, iTechLevelToLoad)
    --https://forums.faforever.com/viewtopic.php?f=2&t=17511#:~:text=It%20can%20carry%20exactly%201,and%20more%20T2%20than%20T3.
    local iFaction = GetUnitFaction(oTransport)
    local tiCapacityByTechAndFaction --[TransportTechLevel][FactionNumber][UnitTechToHold]
    if EntityCategoryContains(categories.UEF * categories.GROUNDATTACK * categories.TECH2 * categories.AIR, oTransport.UnitId) then
        tiCapacityByTechAndFaction = {[2]={[refFactionUEF]={[1]=1,[2]=1,[3]=0,[4]=0}}}
    else tiCapacityByTechAndFaction =
    {[1]={ --T1 transports
        [refFactionUEF]={[1]=6,[2]=2,[3]=1,[4]=0},
        [refFactionAeon]={[1]=6,[2]=3,[3]=1,[4]=0},
        [refFactionCybran]={[1]=6,[2]=2,[3]=1,[4]=0},
        [refFactionSeraphim]={[1]=8,[2]=4,[3]=1,[4]=0},
        [refFactionNomads]={[1]=4,[2]=2,[3]=0,[4]=0}, --Assumed
        [refFactionUnrecognised]={[1]=2,[2]=1,[3]=0,[4]=0}, --assumed
    },
     [2]={
         [refFactionUEF]={[1]=14,[2]=6,[3]=3,[4]=0},
         [refFactionAeon]={[1]=12,[2]=6,[3]=2,[4]=0},
         [refFactionCybran]={[1]=10,[2]=4,[3]=2,[4]=0},
         [refFactionSeraphim]={[1]=16,[2]=8,[3]=4,[4]=0},
         [refFactionNomads]={[1]=8,[2]=4,[3]=2,[4]=0}, --Assumed
         [refFactionUnrecognised]={[1]=2,[2]=1,[3]=0,[4]=0}, --assumed
     },
     [3]={
         [refFactionUEF]={[1]=28,[2]=12,[3]=6,[4]=0},
         [refFactionAeon]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionCybran]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionSeraphim]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionNomads]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionUnrecognised]={[1]=1,[2]=1,[3]=1,[4]=0},
     },
     [4]={ --dummy values
         [refFactionUEF]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionAeon]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionCybran]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionSeraphim]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionNomads]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionUnrecognised]={[1]=1,[2]=1,[3]=1,[4]=0},
     },
    }
    end

    return tiCapacityByTechAndFaction[GetUnitTechLevel(oTransport)][iFaction][iTechLevelToLoad]
end

function GetACUShieldRegenRate(oUnit)
    --Cycles through every possible enhancement, sees if the unit has it, and if so what its shield regen rate is, and returns the max value
    local iRegenRate = 0
    if oUnit.HasEnhancement then
        local oBP = oUnit:GetBlueprint()
        if M28Utilities.IsTableEmpty(oBP.Enhancements) == false then
            for sEnhancement, tEnhancement in oBP.Enhancements do
                if oUnit:HasEnhancement(sEnhancement) and tEnhancement.ShieldRegenRate then
                    iRegenRate = math.max(iRegenRate, tEnhancement.ShieldRegenRate)
                end
            end
        end
    end
    return iRegenRate
end

function GetUnitHealthRegenRate(oUnit)
    --Cycles through every ACU enhancement and factors it into its health regen, along with veterancy
    local oBP = oUnit:GetBlueprint()
    local iRegenRate = (oBP.Defense.RegenRate or 0)

    --Adjust for veterancy:
    local iVetLevel = (oUnit.VetLevel or oUnit.Sync.VeteranLevel or 0)
    if iVetLevel > 0 and oBP.Buffs.Regen then
        local iCurVet = 0
        for iVet, iRegenMod in oBP.Buffs.Regen do
            iCurVet = iCurVet + 1
            if iCurVet == iVetLevel then
                iRegenRate = iRegenRate + iRegenMod
                break
            end
        end
    end

    --Adjust for enhancements
    if M28Utilities.IsTableEmpty(oBP.Enhancements) == false and oUnit.HasEnhancement then
        for iEnhancement, tEnhancement in oBP.Enhancements do
            if tEnhancement.NewRegenRate and oUnit:HasEnhancement(iEnhancement) then
                iRegenRate = iRegenRate + tEnhancement.NewRegenRate
            end
        end
    end

    return iRegenRate

end

function SetUnitWeaponTargetPriorities(oUnit, tPriorityTable, bCheckIfCanAttackGround)
    if (bDontConsiderCombinedArmy or oUnit.M28Active) and IsUnitValid(oUnit) then
        if EntityCategoryContains(refCategoryMAA, oUnit) then M28Utilities.ErrorHandler('Changing weapon priority for MAA') end
        for i =1, oUnit:GetWeaponCount() do
            local wep = oUnit:GetWeapon(i)
            if not(bCheckIfCanAttackGround) or not(wep.CannotAttackGround) then
                wep:SetWeaponPriorities(tPriorityTable)
            end
        end
    end
end

function GetLauncherAOEStrikeDamageMinAndMaxRange(oUnit)
    local oBP = oUnit:GetBlueprint()
    local iAOE = 0
    local iStrikeDamage = 0
    local iMinRange = 0
    local iMaxRange = 0
    local iSalvoSize = 1
    local iSalvoIndividualDelay
    for sWeaponRef, tWeapon in oBP.Weapon do
        if not(tWeapon.WeaponCategory == 'Death') then
            if (tWeapon.DamageRadius or 0) > iAOE then
                iAOE = tWeapon.DamageRadius
                iStrikeDamage = tWeapon.Damage * (tWeapon.MuzzleSalvoSize or 1)
                if (tWeapon.FixedSpreadRadius or 0) >= 20 then --e.g. scathis
                    iStrikeDamage = math.min(iStrikeDamage, tWeapon.Damage * math.min(3, (tWeapon.MuzzleSalvoSize or 2) * 0.5))
                end
                iSalvoSize = (tWeapon.MuzzleSalvoSize or 1)
                iSalvoIndividualDelay = (tWeapon.MuzzleSalvoDelay or 0.1)
            elseif (tWeapon.NukeInnerRingRadius or 0) > 0 and (tWeapon.NukeInnerRingDamage or 0) >= iStrikeDamage then
                iAOE = tWeapon.NukeInnerRingRadius
                iStrikeDamage = tWeapon.NukeInnerRingDamage
                iSalvoSize = (tWeapon.MuzzleSalvoSize or 1)
                iSalvoIndividualDelay = (tWeapon.MuzzleSalvoDelay or 0.1)
            end
            if (tWeapon.MinRadius or 0) > iMinRange then iMinRange = tWeapon.MinRadius end
            if (tWeapon.MaxRadius or 0) > iMaxRange then iMaxRange = tWeapon.MaxRadius end
        end
    end
    return iAOE, iStrikeDamage, iMinRange, iMaxRange, iSalvoSize, iSalvoIndividualDelay
end

function GetSniperStrikeDamage(oUnit)
    local iStrikeDamage
    local oBP = oUnit:GetBlueprint()
    local sWeaponTypeRequired
    if EntityCategoryContains(refCategorySniperBot * categories.SERAPHIM, oUnit.UnitId) then
        if oUnit[refbSniperRifleEnabled] and table.getn(oBP.Weapon) > 1 then sWeaponTypeRequired = 'SniperGun' end
    end

    if oBP.Weapon then
        for iWeapon, tWeapon in oBP.Weapon do
            if tWeapon.WeaponCategory == 'Direct Fire' then
                if not(sWeaponTypeRequired) or tWeapon.Label == sWeaponTypeRequired then
                    if iStrikeDamage then iStrikeDamage = math.min(iStrikeDamage, tWeapon.Damage)
                    else iStrikeDamage = tWeapon.Damage
                    end
                end
            end
        end
    end
    if not(iStrikeDamage) then iStrikeDamage = 100 end
    return iStrikeDamage
end

function EnableLongRangeSniper(oUnit)
    --CALL VIA FORK THREAD as workaround for Nomads error
    --If unit has a sniper weapon, then toggle it
    if bDontConsiderCombinedArmy or oUnit.M28Active then
        if oUnit.SetWeaponEnabledByLabel and not(oUnit[refbSniperRifleEnabled]) then
            local oBP = oUnit:GetBlueprint()
            local bHaveSniperWeapon = false
            if oBP.Weapon then
                for iWeapon, tWeapon in oBP.Weapon do
                    if tWeapon.Label == 'SniperGun' then
                        bHaveSniperWeapon = true
                        break
                    end
                end
            end

            if bHaveSniperWeapon then
                oUnit:OnScriptBitSet(1) --NOTE: If playing using nomads this will cause an error (as at 2024-04-07)
                oUnit[refbSniperRifleEnabled] = true
                --LOG('Enabled sniperrifle on unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit))
            end
        end
    end
end


function DisableLongRangeSniper(oUnit)
    M28Utilities.ErrorHandler('need to update sniper bot range if disabling long range sniper, for now have a hardcoded fix') --hardcoded value is oUnit[refiDFRange] = 65
    if bDontConsiderCombinedArmy or oUnit.M28Active then
        if oUnit.SetWeaponEnabledByLabel and oUnit[refbSniperRifleEnabled] then
            local bHaveSniperWeapon = true
            local oBP = oUnit:GetBlueprint()
            if oBP.Weapon then
                for iWeapon, tWeapon in oBP.Weapon do
                    if tWeapon.Label == 'SniperGun' then
                        bHaveSniperWeapon = true
                        break
                    end
                end
            end
            if bHaveSniperWeapon then
                oUnit:OnScriptBitClear(1)
                oUnit[refbSniperRifleEnabled] = false
                --LOG('Disabled long range sniper on unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit))
            end
            oUnit[refiDFRange] = 65
        end
    end
end

function GetMissileCount(oUnit)
    local iMissiles = 0 --NOTE: If this is called at the moment a missile is loaded, then this should be set to 1; only use this function for general checks
    if oUnit.GetTacticalSiloAmmoCount then iMissiles = iMissiles + oUnit:GetTacticalSiloAmmoCount() end
    if oUnit.GetNukeSiloAmmoCount then iMissiles = iMissiles + oUnit:GetNukeSiloAmmoCount() end
    return iMissiles
end

function GiveUnitTemporaryVision(oUnit, iVision)
    --LOG('Applying temporary vision buff at time='..GetGameTimeSeconds())
    local Buff = import('/lua/sim/Buff.lua')
    if not Buffs['CrateVisBuff'] then
        BuffBlueprint {
            Name = 'CrateVisBuff',
            DisplayName = 'CrateVisBuff',
            BuffType = 'CrateVisBuff',
            Stacks = 'ALWAYS',
            Duration = 3,
            Affects = {
                VisionRadius = {
                    Add = iVision,
                    Mult = 1,
                },
            },
        }
    end
    Buff.ApplyBuff(oUnit, 'CrateVisBuff')
end

function ToggleUnitDiveOrSurfaceStatus(oUnit)
    --Assumes have already checked that the unit is or isnt underwater
    if bDontConsiderCombinedArmy or oUnit.M28Active then
        if not(oUnit[refbSpecialMicroActive]) or GetGameTimeSeconds() > oUnit[refiGameTimeToResetMicroActive] then
            local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
            M28Orders.IssueTrackedClearCommands(oUnit)
            IssueDive({oUnit})
            local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')
            M28Micro.TrackTemporaryUnitMicro(oUnit, 3)
        end
    end
end

function FixUnitResourceCheatModifiers(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'FixUnitResourceCheatModifiers'

    --As of May 2023, AIx resource multipliers dont apply to upgrades such as for RAS SACUs.  The below attempts to fix this.
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if IsUnitValid(oUnit) and oUnit:GetAIBrain().CheatEnabled then
        local FAFBuffs = import('/lua/sim/Buff.lua')
        --local iBuildModifier = tonumber(ScenarioInfo.Options.BuildMult or 1.5)
        local iResourceModifier = tonumber(ScenarioInfo.Options.CheatMult or 1.5)
        local iBuildModifier = (ScenarioInfo.Options.BuildMult or 1.5)
        local oBP = oUnit:GetBlueprint()
        if bDebugMessages == true then LOG(sFunctionRef..': Considering applying resource modifier to unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..', iResourceModifier='..iResourceModifier..'; iBuildModifier='..iBuildModifier..'; oBP.Economy.BuildRate='..oBP.Economy.BuildRate) end
        if iResourceModifier > 0 then
            local iBaseMassPerSec = (oBP.Economy.ProductionPerSecondMass or 0)
            local iBaseEnergyPerSec = (oBP.Economy.ProductionPerSecondEnergy or 0)
            local iUpgradeMassPerSec = 0
            local iUpgradeEnergyPerSec = 0

            local tPossibleUpgrades = oBP.Enhancements
            if M28Utilities.IsTableEmpty(tPossibleUpgrades) == false and oUnit.HasEnhancement then
                if bDebugMessages == true then LOG(sFunctionRef..': tPossibleUpgrades size='..table.getn(tPossibleUpgrades)) end
                if tPossibleUpgrades then
                    for sCurUpgrade, tUpgrade in tPossibleUpgrades do
                        if oUnit:HasEnhancement(sCurUpgrade) then
                            iUpgradeMassPerSec = iUpgradeMassPerSec + (tUpgrade.ProductionPerSecondMass or 0)
                            iUpgradeEnergyPerSec = iUpgradeEnergyPerSec + (tUpgrade.ProductionPerSecondEnergy or 0)
                        end
                    end
                end
            end
            if iUpgradeMassPerSec > 0 or iUpgradeEnergyPerSec > 0 or iBaseMassPerSec > 0 or iBaseEnergyPerSec > 0 then
                --Buffs['CheatBuildRate'].Affects.BuildRate.Mult = iBuildModifier
                local iIndex = oUnit:GetAIBrain():GetArmyIndex()
                if not(Buffs['CheatIncome'..iIndex]) then
                    local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
                    M28Overseer.SetBuildAndResourceCheatModifiers(oUnit:GetAIBrain(), iBuildModifier, iResourceModifier, true, nil, true, false)
                end
                --Buffs['CheatIncome'..iIndex].Affects.EnergyProduction.Mult = iResourceModifier
                --Buffs['CheatIncome'..iIndex].Affects.MassProduction.Mult = iResourceModifier
                --Check if have a buff
                if bDebugMessages == true then
                    LOG(sFunctionRef..': unit.Buffs.BuffTable='..reprs(oUnit.Buffs.BuffTable)..'; Buffs[\'CheatIncome\'..iIndex].Affects.EnergyProduction.Mult='..(Buffs['CheatIncome'..iIndex].Affects.EnergyProduction.Mult or 'nil'))
                end
                if M28Utilities.IsTableEmpty(oUnit.Buffs.BuffTable) == false then
                    for sBuffType, tBuffInfo in oUnit.Buffs.BuffTable do
                        for sBuffRef, tBuffValues in tBuffInfo do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering sBuffType='..sBuffType..'; sBuffRef='..sBuffRef..'; tBuffValues='..repru(tBuffValues)) end
                            if sBuffRef == 'CheatIncome' or sBuffRef == 'CheatIncome'..iIndex then
                                if bDebugMessages == true then LOG(sFunctionRef..': Revoving buff '..sBuffRef) end
                                FAFBuffs.RemoveBuff(oUnit, sBuffRef, true)
                            end
                        end
                    end
                end
                --FAFBuffs.RemoveBuff(oUnit, 'CheatIncome'..iIndex, true)
                FAFBuffs.ApplyBuff(oUnit, 'CheatIncome'..iIndex)
                --FAFBuffs.RemoveBuff(oUnit, 'CheatBuildRate'..iIndex, true)
                oUnit:SetProductionPerSecondMass((iBaseMassPerSec + iUpgradeMassPerSec) * iResourceModifier)
                oUnit:SetProductionPerSecondEnergy((iBaseEnergyPerSec + iUpgradeEnergyPerSec) * iResourceModifier)
                --FAFBuffs.RemoveBuff(oUnit, 'CheatBuildRate', true)
                --FAFBuffs.ApplyBuff(oUnit, 'CheatBuildRate')
                if bDebugMessages == true then LOG(sFunctionRef..': Finished setting build and resource cheat modifiers for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..', iBaseMassPerSec='..iBaseMassPerSec..'; iUpgradeMassPerSec='..iUpgradeMassPerSec..'; iResourceModifier='..iResourceModifier..'; Brain='..oUnit:GetAIBrain().Nickname..'; Buffs[CheatIncome].Affects.MassProduction.Mult='..(Buffs['CheatIncome'..iIndex].Affects.MassProduction.Mult or 'nil')) end
            end
        end
        if iBuildModifier > 0 then
            if oBP.Economy.BuildRate then
                local iIndex = oUnit:GetAIBrain():GetArmyIndex()
                if not(Buffs['CheatBuildRate'..iIndex]) then
                    local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
                    M28Overseer.SetBuildAndResourceCheatModifiers(oUnit:GetAIBrain(), iBuildModifier, iResourceModifier, true, nil, true, false)
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': unit.Buffs.BuffTable='..reprs(oUnit.Buffs.BuffTable)..'; Buffs[\'BuildRate\'..iIndex].Affects.BuildRate.Mult='..(Buffs['BuildRate'..iIndex].Affects.BuildRate.Mult or 'nil'))
                    end
                end
                if M28Utilities.IsTableEmpty(oUnit.Buffs.BuffTable) == false then
                    for sBuffType, tBuffInfo in oUnit.Buffs.BuffTable do
                        for sBuffRef, tBuffValues in tBuffInfo do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering sBuffType='..sBuffType..'; sBuffRef='..sBuffRef..'; tBuffValues='..repru(tBuffValues)) end
                            if sBuffRef == 'CheatBuildRate' or sBuffRef == 'CheatBuildRate'..iIndex then
                                if bDebugMessages == true then LOG(sFunctionRef..': Revoving buff '..sBuffRef) end
                                FAFBuffs.RemoveBuff(oUnit, sBuffRef, true)
                            end
                        end
                    end
                end
                FAFBuffs.ApplyBuff(oUnit, 'CheatBuildRate'..iIndex)
                if bDebugMessages == true then LOG(sFunctionRef..': Applied build rate buff of '..(Buffs['BuildRate'..iIndex].Affects.BuildRate.Mult or 'nil')..' to the unit') end
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function IsUnitVisibleSEEBELOW()  end --To help with finding canseeunit
function CanSeeUnit(aiBrain, oUnit, bRequireVisualNotJustBlipToReturnTrue)
    --returns true if aiBrain can see oUnit
    --bRequireVisualNotJustBlipToReturnTrue - returns true if can see a blip
    if bRequireVisualNotJustBlipToReturnTrue == nil then bRequireVisualNotJustBlipToReturnTrue = false end
    local iUnitBrain = oUnit:GetAIBrain()
    if iUnitBrain == aiBrain then return true
    else
        local iArmyIndex = aiBrain:GetArmyIndex()
        if not(oUnit.Dead) then
            if not(oUnit.GetBlip) then
                ErrorHandler('oUnit with UnitID='..(oUnit.UnitId or 'nil')..' has no blip, will assume can see it')
                return true
            else
                local oBlip = oUnit:GetBlip(iArmyIndex)
                if oBlip then
                    if not(bRequireVisualNotJustBlipToReturnTrue) then return true
                    elseif oBlip:IsSeenEver(iArmyIndex) then return true end
                end
            end
        end
    end
    return false
end

function DisableUnitWeapon(oUnit)
    if bDontConsiderCombinedArmy or oUnit.M28Active then

        local iHoldFireState = 1
        oUnit:SetFireState(iHoldFireState)
        local bAlreadyRecorded = oUnit[refbWeaponDisabled]
        oUnit[refbWeaponDisabled] = true
        oUnit[refiTimeLastDisabledWeapon] = GetGameTimeSeconds()
        if not(bAlreadyRecorded) then
            local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
            local iTeam = oUnit:GetAIBrain().M28Team
            if not(M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons]) then
                M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons] = {}
            end
            table.insert(M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons], oUnit)
        end
    end
end

function EnableUnitWeapon(oUnit)
    if bDontConsiderCombinedArmy or oUnit.M28Active then
        local iReturnFireState = 0
        oUnit:SetFireState(iReturnFireState)
        local bAlreadyRecorded = not(oUnit[refbWeaponDisabled])
        oUnit[refbWeaponDisabled] = false
        oUnit[refiTimeLastDisabledWeapon] = nil
        if not(bAlreadyRecorded) then
            local iTeam = oUnit:GetAIBrain().M28Team
            local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons]) == false then
                for iRecorded, oRecorded in M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons] do
                    if oRecorded == oUnit then
                        table.remove(M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons], iRecorded)
                        break
                    end
                end
            end
        end
    end
end

function GetDeathWeaponDamageAOEAndTable(oUnit)
    --Returns nothing (i.e. nil) if unit doesnt have a death weapon
    local oBP = oUnit:GetBlueprint()
    if M28Utilities.IsTableEmpty(oBP.Weapon) == false then
        for iWeapon, tWeapon in oBP.Weapon do
            if tWeapon.FireOnDeath or tWeapon.WeaponCategory == 'Death' then --e.g. some will 'fire' a nuke (paragon, yolona), others will just do damage
                local iWeaponDamage = math.max((tWeapon.Damage or 0), (tWeapon.NukeInnerRingDamage or 0))
                local iAOE = math.max((tWeapon.NukeInnerRingRadius or 0), (tWeapon.DamageRadius or 0))
                return iWeaponDamage, iAOE, tWeapon
            end
        end

    end
end

function DischargeShield(oShield)
    if bDontConsiderCombinedArmy or oShield.M28Active then
        import("/lua/sim/commands/discharge-shields.lua").DischargeShields({ oShield }, true)
    end
end

function GetUnitMassCost(oUnit)
    if not(oUnit[refiUnitMassCost]) then
        if IsUnitValid(oUnit) then
            if not(oUnit[refiCombatRange]) then RecordUnitRange(oUnit) end
            if not(oUnit[refiUnitMassCost]) then
                oUnit[refiUnitMassCost] = (oUnit:GetBlueprint().Economy.BuildCostMass or 0)
            end
        else
            return 0
        end
    end
    return (oUnit[refiUnitMassCost] or 0)
end

function GetTimeUntilReadyToFireBomb(oUnit)
    --Returns the time since we are ready to fire, or a negative number if we have been ready to fire for a while

    --Assumes unit fires once every 10s if we dont have a delay recorded
    local iTimeBetweenShots =  oUnit[refiTimeBetweenBombs]
    if not(iTimeBetweenShots) then M28Utilities.ErrorHandler('Dont have refiTimeBetweenBombs recorded for unit with ID '..oUnit.UnitId..' so will assume a time', true)
        if EntityCategoryContains(categories.EXPERIMENTAL * categories.AIR, oUnit.UnitId) then iTimeBetweenShots = 20 else iTimeBetweenShots = 10 end
    end
    if not(oUnit[refiLastBombFired]) then
        return -(GetGameTimeSeconds() - (oUnit[refiTimeCreated] or 0))
    else
        local iTimeSinceFired = GetGameTimeSeconds() - oUnit[refiLastBombFired]
        return iTimeBetweenShots - iTimeSinceFired
    end
end

function GetUnitSpeed(oUnit)
    local iVelocityX, iVelocityY, iVelocityZ = oUnit:GetVelocity()
    return (math.abs(iVelocityX) + math.abs(iVelocityZ)) * 10 --approximate value - e.g. based on this a fatboy moving diagonally at full speed would cover roughly 2.5 vs a max speed of 1.75
end

--LOUD will reference a different function to check if a unit is restricted; this is so we can just reference M28UnitInfo.IsUnitRestricted(unit, index)
IsUnitRestricted = function(sUnitID, iArmyIndex)
end

--if not(M28Utilities.bLoudModActive) and not(M28Utilities.bFAFActive) and not(M28Utilities.bSteamActive) then M28Utilities.
if M28Utilities.bLoudModActive then
    IsUnitRestricted = function(sUnitID)
        return import('/lua/game.lua').UnitRestricted(nil, sUnitID)
    end
elseif M28Utilities.bSteamActive then
    --Dont support unit restrictions for now
    IsUnitRestricted = function(sUnitId)
        return false
    end
else
    IsUnitRestricted = function(sUnitID, iArmyIndex)
        return import('/lua/game.lua').IsRestricted(sUnitID, iArmyIndex)
    end
end

function CloakUnit(oUnit)
    if bDontConsiderCombinedArmy or oUnit.M28Active then
        if M28Utilities.bFAFActive and oUnit.HideUnit then
            oUnit:HideUnit()
        elseif oUnit.InvisState then
            oUnit:InvisState()
        else
            M28Utilities.ErrorHandler('Dont have hide or cloak option for unit '..oUnit.UnitId)
        end
    end
end

function DoesBomberFireSalvo(oUnit)
    local oBP = oUnit:GetBlueprint()
    for sWeaponRef, tWeapon in oBP.Weapon do
        if tWeapon.WeaponCategory == 'Bomb' or tWeapon.WeaponCategory == 'Direct Fire' or tWeapon.WeaponCategory == 'Anti Navy' then
            if tWeapon.MuzzleSalvoSize == 1 then
                return false
            else return true
            end
        end
    end
end