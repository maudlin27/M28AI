---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 01/12/2022 08:18
---

local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
--Dont include m28factory or m28engineer here or will get a crash at start of the game

--global (non-category) varaibles:
--Threat values
tUnitThreatByIDAndType = {} --Calculated at the start of the game
tiThreatRefsCalculated = {} --table of the threat ID references that have done blueprint checks on

--Factions
refFactionUEF = 1
refFactionAeon = 2
refFactionCybran = 3
refFactionSeraphim = 4
refFactionNomads = 5
refFactionUnrecognised = 6

--Variables against units;
reftLastKnownPositionByTeam = 'M28UnitLastPos' --[x] is the M28 team ref, returns the last known position of the unit
reftAssignedPlateauAndLandZoneByTeam = 'M28UnitPlateauAndZone' --[x] is the M28 team ref, returns a table {iPlateau, iLandZoneRef}
reftAssignedWaterZoneByTeam = 'M28UnitWaterZone' --[x] is the M28 team ref, returns the water zone assigned to the unit, if there is one
reftbConsideredForAssignmentByTeam = 'M28UnitConsideredForAssignment' --[x] is the M28 team ref, returns true if have sent at least once to be assigned to a plateau/land zone/air logic/navy logic
refiDFMassThreatOverride = 'M28BaseMassOverride' --e.g. for ACUs, will override the mass value suggested by the blueprint
refbShieldIsDisabled = 'M28UnitShieldDisabled'
refiTimeOfLastCheck = 'M28UnitTimeOfLastCheck' --Currently used for shot is blocked (M27 also used for T3 arti adjacency, when first detected enemy SMD)
refbLastShotBlocked = 'M28UnitLastShotBlocked' --Used for DF units to indicate if last shot was blocked
refiTimeOfLastOverchargeShot = 'M28UnitTimeLastOvercharge' --Gametimeseconds
reftbInArmyIndexBigThreatTable = 'M28UnitInBigThreatTable' --[x] is army index; true if have added unit to table of big threats for that army index



    --Unit micro related
refiGameTimeMicroStarted = 'M28UnitTimeMicroStarted' --Gametimeseconds that started special micro
refbSpecialMicroActive = 'M28UnitSpecialMicroActive'
refiGameTimeToResetMicroActive = 'M28UnitTimeToResetMicro' --Gametimeseconds

    --Ranges and weapon details
refiDFRange = 'M28UDFR'
refiDFAOE = 'M28AOEDF' --aoe of a df weapon of a unit
refiIndirectAOE = 'M28AOEIn' --aoe of an indirect weapon of a unit; includes manual ranges
refiIndirectRange = 'M28UIR' --for non-manual fire weapons
refiAntiNavyRange = 'M28UANR'
refiManualRange = 'M28UManR' --for manual fire weapons (e.g. TML)
refiMissileDefenceRange = 'M28UMDefR' --For SMD and TMD
refiAARange = 'M28UAAR'
refiBomberRange = 'M28UBR'
refbWeaponUnpacks = 'M28WUP'
refiStrikeDamage = 'M28USD'
refbCanKite = 'M28CanKite' --true unless weapon unpacks or experimental with a weapon fixed to body (GC and megalith)
refiTimeBetweenDFShots = 'M28DFTime'
refiTimeBetweenIFShots = 'M28IFTime'

refbSniperRifleEnabled = 'M27UnitSniperRifleEnabled' --True if seraphim sniperbot has its long range sniperrifle enabled

--Weapon priorities
refWeaponPriorityGunship = {'MOBILE SHIELD', 'MOBILE ANTIAIR CRUISER', 'MOBILE ANTIAIR', 'ANTIAIR', 'STRUCTURE SHIELD', 'VOLATILE', 'MASSEXTRACTION', 'GROUNDATTACK', 'TECH3 MOBILE', 'TECH2 MOBILE', 'TECH1 MOBILE', 'ALLUNITS'}


refbPaused = 'M28UnitPaused' --true if unit is paused
reftoUnitsAssistingThis = 'M28UnitsAssisting' --table of units given an order to guard this unit

--Categories:
--Buildings - eco
refCategoryMex = categories.STRUCTURE * categories.MASSEXTRACTION - categories.NAVAL --Some mods add a naval mex which causes issues as we will try and build on land mexes without naval exclusion
refCategoryT1Mex = refCategoryMex * categories.TECH1
refCategoryT2Mex = refCategoryMex * categories.TECH2
refCategoryT3Mex = refCategoryMex * categories.TECH3
refCategoryHydro = categories.HYDROCARBON - categories.NAVAL

refCategoryPower = categories.STRUCTURE * categories.ENERGYPRODUCTION - categories.EXPERIMENTAL - categories.HYDROCARBON
refCategoryT1Power = categories.STRUCTURE * categories.ENERGYPRODUCTION * categories.TECH1 - categories.EXPERIMENTAL - categories.HYDROCARBON
refCategoryT2Power = categories.STRUCTURE * categories.ENERGYPRODUCTION * categories.TECH2 - categories.EXPERIMENTAL - categories.HYDROCARBON
refCategoryT3Power = categories.STRUCTURE * categories.ENERGYPRODUCTION * categories.TECH3 - categories.EXPERIMENTAL - categories.HYDROCARBON
refCategoryMassStorage = categories.STRUCTURE * categories.MASSSTORAGE * categories.TECH1

refCategoryEnergyStorage = categories.STRUCTURE * categories.ENERGYSTORAGE
refCategoryParagon = categories.STRUCTURE * categories.EXPERIMENTAL * categories.MASSPRODUCTION * categories.MASSFABRICATION
refCategoryMassFab = categories.MASSFABRICATION * categories.STRUCTURE - categories.MASSEXTRACTION - categories.EXPERIMENTAL

--Building - intel and misc
refCategoryAirStaging = categories.STRUCTURE * categories.AIRSTAGINGPLATFORM
refCategoryRadar = categories.STRUCTURE * categories.RADAR + categories.STRUCTURE * categories.OMNI
refCategoryT1Radar = refCategoryRadar * categories.TECH1
refCategoryT2Radar = refCategoryRadar * categories.TECH2
refCategoryT3Radar = refCategoryRadar * categories.TECH3 --+ categories.OMNI * categories.TECH3 (dont need this as refcategoryradar already includes omni)
refCategorySonar = categories.STRUCTURE * categories.SONAR + categories.MOBILESONAR
refCategoryT1Sonar = refCategorySonar * categories.TECH1
refCategoryT2Sonar = refCategorySonar * categories.TECH2
refCategoryT3Sonar = refCategorySonar * categories.TECH3
refCategoryStructure = categories.STRUCTURE - categories.WALL
refCategoryWall = categories.STRUCTURE * categories.WALL --NOTE: Some walls are props; this is for if want a wall that can build
refCategoryUnitsWithOmni = categories.OMNI + categories.COMMAND + categories.OVERLAYOMNI


--Building - factory
refCategoryLandFactory = categories.LAND * categories.FACTORY * categories.STRUCTURE
refCategoryLandHQ =refCategoryLandFactory - categories.SUPPORTFACTORY
refCategoryAirFactory = categories.AIR * categories.FACTORY * categories.STRUCTURE - categories.ORBITALSYSTEM --Novax is an air factory, so excluded from being treated as an air factory by my logic
refCategoryAirHQ = refCategoryAirFactory - categories.SUPPORTFACTORY
refCategoryNavalFactory = categories.NAVAL * categories.FACTORY * categories.STRUCTURE
refCategoryNavalHQ = refCategoryNavalFactory - categories.SUPPORTFACTORY
refCategoryFactory = refCategoryLandFactory + refCategoryAirFactory + refCategoryNavalFactory
refCategoryAllHQFactories = refCategoryFactory - categories.SUPPORTFACTORY
refCategoryQuantumGateway = categories.STRUCTURE * categories.GATE * categories.TECH3 * categories.FACTORY

--Building - defensive
refCategoryT2PlusPD = categories.STRUCTURE * categories.DIRECTFIRE - categories.STRUCTURE * categories.DIRECTFIRE * categories.TECH1
refCategoryPD = categories.STRUCTURE * categories.DIRECTFIRE
refCategoryT3PD = refCategoryPD * categories.TECH3
refCategoryTMD = categories.STRUCTURE * categories.ANTIMISSILE - categories.SILO * categories.TECH3 --Not perfect but should pick up most TMD without picking up SMD
refCategoryFixedShield = categories.SHIELD * categories.STRUCTURE
refCategoryFixedT2Arti = categories.STRUCTURE * categories.INDIRECTFIRE * categories.ARTILLERY * categories.TECH2
refCategoryFixedT3Arti = categories.STRUCTURE * categories.INDIRECTFIRE * categories.ARTILLERY * categories.TECH3
refCategoryExperimentalArti = categories.EXPERIMENTAL * categories.ARTILLERY - categories.MOBILE * categories.UEF
refCategorySML = categories.NUKE * categories.SILO
refCategorySMD = categories.ANTIMISSILE * categories.SILO * categories.TECH3 * categories.STRUCTURE
refCategoryTML = categories.SILO * categories.STRUCTURE * categories.TECH2 - categories.ANTIMISSILE
refCategoryUnitsWithTMLUpgrade = categories.COMMAND * categories.UEF + categories.COMMAND * categories.SERAPHIM + categories.SUBCOMMANDER * categories.SERAPHIM
refCategoryNovaxCentre = categories.EXPERIMENTAL * categories.STRUCTURE * categories.ORBITALSYSTEM
refCategorySatellite = categories.EXPERIMENTAL * categories.SATELLITE
--refCategorySAM = categories.ANTIAIR * categories.STRUCTURE * categories.TECH3
refCategoryQuantumOptics = categories.INTELLIGENCE * categories.OPTICS * categories.AEON * categories.STRUCTURE * categories.TECH3 - refCategoryRadar

refCategoryUpgraded = refCategoryT2Radar + refCategoryT3Radar + refCategoryT2Sonar + refCategoryT3Sonar + refCategoryFactory * categories.TECH2 + refCategoryFactory * categories.TECH3 + refCategoryFixedShield * categories.TECH3 + refCategoryT2Mex + refCategoryT3Mex

--Land units
refCategoryScathis = categories.CYBRAN * categories.ARTILLERY * categories.EXPERIMENTAL
refCategoryExperimentalStructure = refCategoryScathis + categories.STRUCTURE * categories.EXPERIMENTAL
refCategoryLandExperimental = categories.EXPERIMENTAL * categories.MOBILE * categories.LAND - categories.CYBRAN * categories.ARTILLERY - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryMonkeylord = refCategoryLandExperimental * categories.BOT * categories.DIRECTFIRE - categories.SNIPER
refCategoryMegalith = refCategoryLandExperimental * categories.BOT * categories.DIRECTFIRE * categories.SNIPER
refCategoryMobileLand = categories.LAND * categories.MOBILE  - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryEngineer = categories.LAND * categories.MOBILE * categories.ENGINEER - categories.COMMAND - categories.FIELDENGINEER -categories.SUBCOMMANDER --Dont include sparkys as they cant build a lot of things, so just treat them as a combat unit that can reclaim
refCategoryRASSACU = categories.SUBCOMMANDER * categories.RASPRESET + categories.SUBCOMMANDER * categories.SERAPHIM
refCategoryRover = categories.POD * categories.ENGINEER * categories.MOBILE - categories.CONSTRUCTION -refCategoryEngineer
refCategoryHive = categories.STRUCTURE * categories.STATIONASSISTPOD * categories.ENGINEERSTATION
refCategoryKennel = categories.STRUCTURE * categories.ENGINEERSTATION * categories.PODSTAGINGPLATFORM
refCategoryEngineerStation = refCategoryRover + refCategoryHive + refCategoryKennel

refCategoryMAA = categories.LAND * categories.MOBILE * categories.ANTIAIR - categories.EXPERIMENTAL
refCategoryAttackBot = categories.LAND * categories.MOBILE * categories.DIRECTFIRE * categories.BOT + categories.LAND * categories.MOBILE * categories.TANK * categories.TECH1 * categories.SERAPHIM - refCategoryMAA -categories.REPAIR --(repair exclusion added as basic way to differentiate between mantis (which has repair category) and LAB; alternative way is to specify the fastest when choosing the blueprint to build
refCategoryDFTank = categories.LAND * categories.MOBILE * categories.DIRECTFIRE - categories.SCOUT - refCategoryMAA - categories.UNSELECTABLE - categories.UNTARGETABLE --NOTE: Need to specify slowest (so dont pick LAB)
refCategoryLandScout = categories.LAND * categories.MOBILE * categories.SCOUT
refCategoryCombatScout = categories.SERAPHIM * categories.SCOUT * categories.DIRECTFIRE
refCategoryIndirect = categories.LAND * categories.MOBILE * categories.INDIRECTFIRE - categories.DIRECTFIRE - refCategoryLandExperimental - refCategoryScathis - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryT3MobileArtillery = categories.ARTILLERY * categories.LAND * categories.MOBILE * categories.TECH3 - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryT3MML = categories.SILO * categories.MOBILE * categories.TECH3 * categories.LAND - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryFatboy = categories.EXPERIMENTAL * categories.UEF * categories.MOBILE * categories.LAND * categories.ARTILLERY - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryLandCombat = categories.MOBILE * categories.LAND * categories.DIRECTFIRE + categories.MOBILE * categories.LAND * categories.INDIRECTFIRE * categories.TECH1 + categories.FIELDENGINEER + refCategoryFatboy + categories.SUBCOMMANDER - refCategoryEngineer -refCategoryLandScout -refCategoryMAA - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryAmphibiousCombat = refCategoryLandCombat * categories.HOVER + refCategoryLandCombat * categories.AMPHIBIOUS - categories.ANTISHIELD * categories.AEON --Dont include aeon T3 anti-shield here as it sucks unless against shields
refCategorySurfaceAmphibiousCombat = refCategoryLandCombat * categories.HOVER + categories.ANTINAVY * categories.LAND * categories.MOBILE - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryGroundAA = refCategoryMAA + categories.NAVAL * categories.ANTIAIR + categories.STRUCTURE * categories.ANTIAIR + categories.NAVALCARRIER * categories.EXPERIMENTAL
refCategoryStructureAA = categories.STRUCTURE * categories.ANTIAIR
refCategoryIndirectT2Plus = categories.MOBILE * categories.LAND * categories.INDIRECTFIRE - categories.MOBILE * categories.LAND * categories.INDIRECTFIRE * categories.TECH1 - categories.DIRECTFIRE
refCategoryIndirectT2Below = categories.MOBILE * categories.INDIRECTFIRE * categories.LAND * categories.TECH1 + categories.MOBILE * categories.INDIRECTFIRE * categories.LAND * categories.TECH2
refCategoryIndirectT3 = categories.MOBILE * categories.LAND * categories.INDIRECTFIRE * categories.TECH3 - categories.DIRECTFIRE
--Obsidian special case with shields due to inconsistent categories:
refCategoryObsidian = categories.AEON * categories.TECH2 * categories.SHIELD * categories.DIRECTFIRE * categories.MOBILE * categories.LAND * categories.TANK --
refCategoryMobileLandShield = categories.LAND * categories.MOBILE * categories.SHIELD - refCategoryObsidian  --Miscategorised obsidian tank
refCategoryPersonalShield = categories.PERSONALSHIELD + refCategoryObsidian
refCategoryMobileLandStealth = categories.LAND * categories.MOBILE * categories.STEALTHFIELD - categories.EXPERIMENTAL --dont want monkeylords treated as a mobile stealth unit!
refCategorySniperBot = categories.MOBILE * categories.SNIPER * categories.LAND
refCategorySkirmisher = refCategorySniperBot * categories.TECH3 + refCategoryDFTank * categories.UEF * categories.TECH2 * categories.BOT + refCategoryDFTank * categories.CYBRAN * categories.TECH2 * categories.BOT - categories.BOMB --Mongoose, Hoplite, sniperbot
refCategoryShieldDisruptor = categories.LAND * categories.MOBILE * categories.ANTISHIELD


--Air units
refCategoryAirScout = categories.AIR * categories.SCOUT
refCategoryAirAA = categories.AIR * categories.ANTIAIR - categories.BOMBER - categories.GROUNDATTACK - categories.EXPERIMENTAL
refCategoryBomber = categories.AIR * categories.BOMBER - categories.ANTINAVY - categories.CANNOTUSEAIRSTAGING --excludes mercies
refCategoryFighterBomber = categories.AIR * categories.ANTIAIR * categories.BOMBER - categories.EXPERIMENTAL
refCategoryGunship = categories.AIR * categories.GROUNDATTACK
refCategoryTorpBomber = categories.AIR * categories.BOMBER * categories.ANTINAVY
refCategoryAllAir = categories.MOBILE * categories.AIR - categories.UNTARGETABLE --Excludes novax
refCategoryAllNonExpAir = categories.MOBILE * categories.AIR * categories.TECH1 + categories.MOBILE * categories.AIR * categories.TECH2 + categories.MOBILE * categories.AIR * categories.TECH3
refCategoryAirNonScout = refCategoryAllAir - categories.SCOUT
refCategoryMercy = categories.HIGHPRIAIR * categories.AEON * categories.BOMBER * categories.TECH2
refCategoryTransport = categories.AIR * categories.TRANSPORTATION - categories.UEF * categories.GROUNDATTACK
refCategoryRestorer = refCategoryGunship * categories.ANTIAIR
refCategoryCzar = categories.AIR * categories.EXPERIMENTAL * categories.ANTIAIR * categories.AEON
refCategoryAirToGround = refCategoryBomber + refCategoryGunship + refCategoryCzar + refCategoryMercy --i.e. excludes torp bombers

--Naval units
refCategoryFrigate = categories.NAVAL * categories.FRIGATE
refCategoryNavalSurface = categories.NAVAL - categories.SUBMERSIBLE - categories.UNSELECTABLE - categories.UNTARGETABLE --NOTE: This includes structures (e.g. torp launcher and factory)
refCategoryMobileNavalSurface = refCategoryNavalSurface * categories.MOBILE
refCategoryAllNavy = categories.NAVAL - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryNavalAA = refCategoryAllNavy * categories.ANTIAIR
refCategoryCruiser = categories.NAVAL * categories.CRUISER
refCategorySalem = categories.NAVAL * categories.AMPHIBIOUS * categories.DIRECTFIRE
refCategorySeraphimDestroyer = categories.SUBMERSIBLE * categories.DESTROYER
refCategoryDestroyer = categories.DESTROYER
refCategoryCruiserCarrier = refCategoryCruiser + categories.NAVAL * categories.NAVALCARRIER
refCategorySupportNavy = refCategoryCruiserCarrier + categories.SHIELD * categories.HOVER + categories.SHIELD * categories.NAVAL + categories.STEALTHFIELD * categories.HOVER + categories.STEALTHFIELD * categories.NAVAL --Intended for units we dont want on frontline unless in bombardment mode
refCategoryTorpedoLauncher = categories.ANTINAVY * categories.STRUCTURE
refCategoryAllAmphibiousAndNavy = categories.NAVAL + categories.AMPHIBIOUS + categories.HOVER + refCategoryTMD + refCategoryTorpedoLauncher + refCategorySonar + refCategoryStructureAA --NOTE: Structures have no category indicating whether they can be built on sea (instead they have aquatic ability) hence the need to include all structures
refCategoryPondFixedCategory = refCategoryNavalSurface - categories.AMPHIBIOUS * categories.MOBILE + refCategoryTMD + refCategoryTorpedoLauncher + refCategorySonar + refCategoryStructureAA
refCategoryNavyThatCanBeTorpedoed = categories.NAVAL + categories.AMPHIBIOUS + categories.STRUCTURE + categories.COMMAND + refCategoryEngineer - categories.HOVER --NOTE: Structures have no category indicating whether they can be built on sea (instead they have aquatic ability) hence the need to include all structures; Hover units cant be targeted
refCategoryTorpedoLandAndNavy = categories.ANTINAVY * categories.LAND + categories.ANTINAVY * categories.NAVAL + categories.OVERLAYANTINAVY * categories.LAND + categories.ANTINAVY * categories.STRUCTURE --If removing overlayantinavy then think up better solution for fatboy/experimentals so they dont run when in water
refCategoryMissileShip = categories.NAVAL * categories.SILO + categories.BATTLESHIP * categories.INDIRECTFIRE - categories.BATTLESHIP * categories.SERAPHIM --i.e. UEF+Sera cruisers, and nukesubs
refCategorySubmarine = categories.NAVAL * categories.SUBMERSIBLE * categories.ANTINAVY
refCategoryCooper = categories.NAVAL * categories.ANTINAVY * categories.TECH2 - categories.SUBMERSIBLE - categories.DESTROYER
refCategoryShieldBoat = categories.NAVAL * categories.SHIELD + categories.HOVER * categories.SHIELD --Includes mobile land shields that can hover
refCategoryStealthBoat = categories.NAVAL * categories.STEALTHFIELD
refCategoryBattlecruiser = categories.BATTLESHIP * categories.PRODUCTFA * categories.UEF
refCategoryBattleship = categories.BATTLESHIP - refCategoryBattlecruiser - refCategoryMissileShip


--Multi-category:
--Antinavy mobile units (can include land units - e.g for land factories to build antisub units)
refCategoryAntiNavy = categories.ANTINAVY * categories.STRUCTURE + categories.ANTINAVY * categories.MOBILE - categories.DESTROYER * categories.UEF --for some reason get error message if just use antinavy, so need to be more restrictive
--Dangerous to land units, e.g. engieners look for these when deciding reclaim area
refCategoryDangerousToLand = refCategoryLandCombat + refCategoryIndirect + refCategoryAllNavy + refCategoryBomber + refCategoryGunship + refCategoryPD + refCategoryFixedT2Arti
refCategoryAllNonAirScoutUnits = categories.MOBILE + refCategoryStructure + refCategoryAirNonScout
refCategoryStealthGenerator = categories.STEALTHFIELD
refCategoryStealthAndCloakPersonal = categories.STEALTH
refCategoryProtectFromTML = refCategoryT2Mex + refCategoryT3Mex + refCategoryT2Power + refCategoryT3Power + refCategoryFixedT2Arti
refCategoryExperimentalLevel = categories.EXPERIMENTAL + refCategoryFixedT3Arti + refCategorySML
refCategoryBigThreatCategories = refCategoryExperimentalLevel + refCategoryMissileShip + refCategorySMD --Note - this is different to M27 which only considers land experimentals as big threat categories
refCategoryFirebaseSuitable = refCategoryPD + refCategoryT1Radar + refCategoryT2Radar + refCategorySMD + refCategoryTMD + refCategoryFixedShield + refCategoryFixedT2Arti + refCategoryStructureAA
refCategoryLongRangeDFLand = refCategoryFatboy + refCategorySniperBot + refCategoryShieldDisruptor
refCategoryLongRangeMobile = refCategoryLongRangeDFLand + refCategoryNavalSurface * categories.DIRECTFIRE + refCategoryNavalSurface * categories.INDIRECTFIRE - refCategoryNavalSurface * categories.TECH1 + refCategoryIndirectT2Plus
refCategoryShortRangeMobile = refCategoryLandCombat + refCategoryFrigate - refCategoryLongRangeMobile
refCategoryReclaimable = categories.RECLAIMABLE - refCategoryAllAir

function GetUnitLifetimeCount(oUnit)
--Returns what unique (for the unit's aiBrain) count the unit has, i.e. based on the number of previous units with the same blueprint ID
    local iCount = oUnit.M28LifetimeUnitCount

    if iCount == nil then
        if oUnit.GetAIBrain and oUnit.GetUnitId then
            local aiBrain = oUnit:GetAIBrain()
            local sUnitId = oUnit.UnitId
            if aiBrain.M28LifetimeUnitCount == nil then aiBrain.M28LifetimeUnitCount = {} end
            if aiBrain.M28LifetimeUnitCount[sUnitId] == nil then
                aiBrain.M28LifetimeUnitCount[sUnitId] = 1
            else aiBrain.M28LifetimeUnitCount[sUnitId] = aiBrain.M28LifetimeUnitCount[sUnitId] + 1 end
            iCount = aiBrain.M28LifetimeUnitCount[sUnitId]
            oUnit.M28LifetimeUnitCount = iCount
        else
            iCount = 'nil'
        end
    end
    return iCount
end

function IsUnitValid(oUnit)
    --Returns true if unit is constructed and not dead
    if oUnit and oUnit.UnitId and not(oUnit.Dead) and oUnit.GetAIBrain then
        return true
    end
    return false
end

function GetUnitPathingType(oUnit)
    --Returns Land, Amphibious, Air or Water or None
    --if oUnit and not(oUnit.Dead) and oUnit.GetBlueprint then
    local mType = __blueprints[oUnit.UnitId].Physics.MotionType
    if (mType == 'RULEUMT_AmphibiousFloating' or mType == 'RULEUMT_Hover' or mType == 'RULEUMT_Amphibious') then
        return M28Map.refPathingTypeHover
    elseif (mType == 'RULEUMT_Water' or mType == 'RULEUMT_SurfacingSub') then
        return M28Map.refPathingTypeNavy
    elseif mType == 'RULEUMT_Air' then
        return M28Map.refPathingTypeAir
    elseif (mType == 'RULEUMT_Biped' or mType == 'RULEUMT_Land') then
        return M28Map.refPathingTypeLand
    else return M28Map.refPathingTypeNone
    end
end

function GetBlueprintFromID(sBlueprintID)
    --returns blueprint based on the blueprintID
    return __blueprints[string.lower(sBlueprintID)]
end

function GetBuildingSizeTable(sBlueprintID)
    --Returns table with X and Z size of sBlueprintID
    local tSizeXZ = {}
    local oBlueprint = GetBlueprintFromID(sBlueprintID)
    tSizeXZ[1] = oBlueprint.Physics.SkirtSizeX
    tSizeXZ[2] = oBlueprint.Physics.SkirtSizeZ
    return tSizeXZ
end

function GetBuildingSize(sBlueprintID)
    --Similar to GetBuildingSizeTable but returns a single value for the highest size
    local oBlueprint = GetBlueprintFromID(sBlueprintID)
    return math.max(oBlueprint.Physics.SkirtSizeX, oBlueprint.Physics.SkirtSizeZ)
end

function GetUnitState(oUnit)
    --Returns a string containing oUnit's unit state. Returns '' if no unit state.
    local sUnitState = ''
    local sAllUnitStates = {'Immobile',
                            'Moving',
                            'Attacking',
                            'Guarding',
                            'Building',
                            'Upgrading',
                            'WaitingForTransport',
                            'TransportLoading',
                            'TransportUnloading',
                            'MovingDown',
                            'MovingUp',
                            'Patrolling',
                            'Busy',
                            'Attached',
                            'BeingReclaimed',
                            'Repairing',
                            'Diving',
                            'Surfacing',
                            'Teleporting',
                            'Ferrying',
                            'WaitForFerry',
                            'AssistMoving',
                            'PathFinding',
                            'ProblemGettingToGoal',
                            'NeedToTerminateTask',
                            'Capturing',
                            'BeingCaptured',
                            'Reclaiming',
                            'AssistingCommander',
                            'Refueling',
                            'GuardBusy',
                            'ForceSpeedThrough',
                            'UnSelectable',
                            'DoNotTarget',
                            'LandingOnPlatform',
                            'CannotFindPlaceToLand',
                            'BeingUpgraded',
                            'Enhancing',
                            'BeingBuilt',
                            'NoReclaim',
                            'NoCost',
                            'BlockCommandQueue',
                            'MakingAttackRun',
                            'HoldingPattern',
                            'SiloBuildingAmmo' }
    for _, sState in sAllUnitStates do
        if oUnit:IsUnitState(sState) == true then
            sUnitState = sState
            break
        end
    end
    return sUnitState
end

function GetUnitTechLevel(oUnit)
    local sUnitId = oUnit.UnitId
    local iTechLevel = 1
    if EntityCategoryContains(categories.TECH1, sUnitId) then iTechLevel = 1
    elseif EntityCategoryContains(categories.TECH2, sUnitId) then iTechLevel = 2
    elseif EntityCategoryContains(categories.TECH3, sUnitId) then iTechLevel = 3
    elseif EntityCategoryContains(categories.EXPERIMENTAL, sUnitId) then iTechLevel = 4
    end
    return iTechLevel
end

function GetUpgradeCombatWeighting(sEnhancementRef)
    --Returns the combat mass mod to apply to an enhancement
    --Obtain using aiBrain:GetFactionIndex()

    local iMinor = 0.4
    local iMajor = 1
    local iDeadly = 2
    local iNone = 0
    local iUnknown = 1

    local tEnhancementsCombatMod = {
            --UEF:
            AdvancedEngineering = iMinor, --T2
            DamageStabilization = iMajor, --Nano
            HeavyAntiMatterCannon = iMajor,
            LeftPod = iNone, --Engi
            ResourceAllocation = iNone, --RAS
            RightPod = iNone, --Engi
            Shield = iMajor, --Shield
            ShieldGeneratorField = iMajor, --Shield aoe
            T3Engineering = iMinor, --T3
            TacticalMissile = iNone, --TML
            TacticalNukeMissile = iNone, --Billy
            Teleporter = iNone, --Teleport
            --Aeon:
            --AdvancedEngineering = iMinor, --T2
            ChronoDampener = iDeadly, --ChronoDampener
            CrysalisBeam = iMajor, --Range
            EnhancedSensors = iNone, --Sensors
            HeatSink = iMajor, --ROF
            --ResourceAllocation = iNone, --RAS
            ResourceAllocationAdvanced = iNone, --RAS lev 2
            --Shield = iMajor, --Shield
            ShieldHeavy = iMajor, --Shield lev2
            --T3Engineering = iMinor, --T3
            --Teleporter = iNone, --Teleport
            --Cybran:
            --AdvancedEngineering = iMinor, --T2
            CloakingGenerator = iMinor, --Cloak
            CoolingUpgrade = iMajor, --Gun
            MicrowaveLaserGenerator = iDeadly, --Laser
            NaniteTorpedoTube = iMinor, --Torpedo
            --ResourceAllocation = iNone, --RAS
            StealthGenerator = iMajor, --Stealth
            --T3Engineering = iMinor, --T3
            --Teleporter = iNone, --Teleport
            --Sera:
            --AdvancedEngineering = iMinor, --T2
            AdvancedRegenAura = iMajor, --Regen aura lev2
            BlastAttack = iDeadly, --AOE and damage
            DamageStabilization = iMajor, --Nano
            DamageStabilizationAdvanced = iMajor, --Nano lev2
            Missile = iNone, --TML
            RateOfFire = iMajor, --Gun
            RegenAura = iDeadly, --Regen aura
            --ResourceAllocation = iNone, --RAS
            ResourceAllocationAdvanced = iNone, --RAS lev 2
            --T3Engineering = iMinor, --T3
            --Teleporter = iNone, --Teleport
    }
    return (tEnhancementsCombatMod[sEnhancementRef] or iUnknown)
end

function UpdateUnitCombatMassRatingForUpgrades(oUnit)
    --Updates oUnit[refiDFMassThreatOverride] to reflect any upgrades on the unit (e.g. for ACU and SACUs)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateUnitCombatMassRatingForUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tPossibleUpgrades = oUnit:GetBlueprint().Enhancements
    if M28Utilities.IsTableEmpty(tPossibleUpgrades) == false then
        local iCurMassValue
        local iCurMassMod
        local iBaseMassValue = 1000 --Approx 20 tanks
        local iTotalMassValue = iBaseMassValue
        if bDebugMessages == true then LOG(sFunctionRef..': tPossibleUpgrades size='..table.getn(tPossibleUpgrades)) end
        if tPossibleUpgrades then
            for sCurUpgrade, tUpgrade in tPossibleUpgrades do
                if oUnit:HasEnhancement(sCurUpgrade) then
                    iCurMassValue = tUpgrade.BuildCostMass
                    iCurMassMod = GetUpgradeCombatWeighting(sCurUpgrade)
                    iTotalMassValue = iTotalMassValue + iCurMassMod * iCurMassValue
                    if bDebugMessages == true then LOG(sFunctionRef..': ACU has enhancement no. '..sCurUpgrade..'; iCurMassValue='..iCurMassValue..'; iCurMassMod='..iCurMassMod) end
                end
            end
        end
        oUnit[refiDFMassThreatOverride] = iTotalMassValue
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetCombatThreatRating(tUnits, bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, bBlueprintThreat)
    --Determines threat rating for tUnits, which in most cases will be the mass cost of the unit and adjusted for unit health; by default assumes are referring to main combat threat (e.g. tank), but the flags for indirect and naval threat can be used to adjust this
    --bJustGetMassValue - if thisi s true, will ignore things like health and just return the mass value (so none of the other values should matter if this is true - i.e. assumes tUnits is already filtered to those of interest)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetCombatThreatRating'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(tUnits) then
        if bDebugMessages == true then LOG(sFunctionRef..': Warning: tUnits is empty, returning 0') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return 0
    else
        local iCurThreat = 0
        local iTotalThreat = 0
        local iHealthPercentage, iMaxHealth
        local iHealthFactor --if unit has 40% health, then threat reduced by (1-40%)*iHealthFactor
        local iCurShield, iMaxShield
        local iOtherAdjustFactor = 1


        local iThreatRef = '1'
        if bIndirectFireThreatOnly then iThreatRef = iThreatRef .. '1' else iThreatRef = iThreatRef .. '0' end
        if bJustGetMassValue then iThreatRef = iThreatRef .. '1' else iThreatRef = iThreatRef .. '0' end
        if bAntiNavyOnly then iThreatRef = iThreatRef .. '1' else iThreatRef = iThreatRef .. '0' end
        if bAddAntiNavy then iThreatRef = iThreatRef .. '1' else iThreatRef = iThreatRef .. '0' end
        if bSubmersibleOnly then iThreatRef = iThreatRef .. '1' else iThreatRef = iThreatRef .. '0' end
        if bLongRangeThreatOnly then iThreatRef = iThreatRef..'1' else iThreatRef = iThreatRef .. '0' end

        if not(tiThreatRefsCalculated[iThreatRef]) then M28Utilities.ErrorHandler('Havent calculated threat values for iThreatRef='..iThreatRef..' refer to CalculateBlueprintThreatsByType') end

        local iBaseThreat = 0

        for iUnit, oUnit in tUnits do
            iCurThreat = 0
            iBaseThreat = 0
            --Get the base threat for the unit
            if IsUnitValid(oUnit) then
                iBaseThreat = (oUnit[refiDFMassThreatOverride] or tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef])
                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; iBaseThreat='..(iBaseThreat or 0)..'; DF threat override='..(oUnit[refiDFMassThreatOverride] or 'nil')..'; tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef]='..(tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef] or 'nil')) end
                if not(tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef]) and not(bBlueprintThreat) then
                    iBaseThreat = GetCombatThreatRating({ { ['UnitId'] = oUnit.UnitId } }, bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, true)
                    if not(tUnitThreatByIDAndType[oUnit.UnitId]) then tUnitThreatByIDAndType[oUnit.UnitId] = {} end
                    if bDebugMessages == true then LOG(sFunctionRef..': Will rerun the blueprint logic as it seems to have missed this unit '..oUnit.UnitId..'; iBaseThreat after this='..(iBaseThreat or 'nil')) end
                    if not(tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef]) then tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef] = (iBaseThreat or 0) end

                end
                if iBaseThreat == 0 and bSubmersibleOnly and bEnemyUnits and EntityCategoryContains(categories.AMPHIBIOUS, oUnit.UnitId) and IsUnitUnderwater(oUnit) then
                    iBaseThreat = oUnit:GetBlueprint().Economy.BuildCostMass * 0.35
                end
                if iBaseThreat > 0 then
                    if bJustGetMassValue then iCurThreat = iBaseThreat
                    else
                        --Have got the base threat for this type of unit, now adjust threat for unit health if want to calculate actual threat
                        iCurShield, iMaxShield = GetCurrentAndMaximumShield(oUnit)
                        iMaxHealth = oUnit:GetMaxHealth() + iMaxShield
                        if iMaxHealth and iMaxHealth > 0 then
                            --Increase threat for veterancy level
                            if oUnit.Sync.VeteranLevel > 0 then iBaseThreat = iBaseThreat * (1 + oUnit.Sync.VeteranLevel * 0.1) end

                            --Adjust threat for cur health %
                            iOtherAdjustFactor = 1
                            iHealthPercentage = (oUnit:GetHealth() + iCurShield) / (iMaxHealth + iMaxShield)

                            --Reduce threat by health, with the amount depending on if its an ACU and if its an enemy
                            if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                                iHealthFactor = iHealthPercentage --threat will be mass * iHealthFactor
                                --iMassCost = GetACUCombatMassRating(oUnit) --have already calculated this earlier
                                if bEnemyUnits then
                                    iOtherAdjustFactor = 1.10 --Want to allow for enemy ACU to be 10% higher threat due to potential of veterancy
                                else
                                    if iHealthPercentage < 0.5 then iHealthFactor = iHealthPercentage * iHealthPercentage
                                    elseif iHealthPercentage < 0.9 then iHealthFactor = iHealthPercentage * (iHealthPercentage + 0.1) end
                                end
                            else
                                if bEnemyUnits then
                                    --For enemy damaged units treat them as still ahving high threat, since enemy likely could use them effectively still
                                    if iHealthPercentage >= 1 then iHealthFactor = iHealthPercentage
                                    else
                                        iHealthFactor = math.max(0.25, iHealthPercentage * (1 + (1 - iHealthPercentage)))
                                    end
                                else
                                    iHealthFactor = iHealthPercentage
                                end
                            end
                            if oUnit:GetFractionComplete() <= 0.75 then iOtherAdjustFactor = iOtherAdjustFactor * 0.1 end
                        end
                        iCurThreat = iBaseThreat * iOtherAdjustFactor * iHealthFactor
                        if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' iCurThreat='..iCurThreat..'; iBaseThreat='..iBaseThreat..'; iOtherAdjustFactor='..iOtherAdjustFactor..'; iHealthFactor='..iHealthFactor) end
                    end
                end
            else
                --Are we calculating blueprint threat (per code at start of game)?
                if bBlueprintThreat then
                    local oBP = __blueprints[oUnit.UnitId]

                    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit with ID='..(oUnit.UnitId or 'nil')) end

                    if bJustGetMassValue == true then iBaseThreat = (oBP.Economy.BuildCostMass or 0)
                    else
                        local iMassMod = 0
                        --T3 and T4 arti - assign 0 combat value
                        if not(EntityCategoryContains(refCategoryFixedT3Arti + refCategoryExperimentalArti, oUnit.UnitId)) then

                            if not(bIndirectFireThreatOnly) then
                                if bAntiNavyOnly or bSubmersibleOnly then
                                    iMassMod = 0
                                    if (bSubmersibleOnly and (EntityCategoryContains(categories.SUBMERSIBLE, oUnit.UnitId) or oBP.Physics.MotionType == 'RULEUMT_Amphibious')) or (not(bSubmersibleOnly) and bAntiNavyOnly and EntityCategoryContains(categories.ANTINAVY+categories.OVERLAYANTINAVY + refCategoryBattleship, oUnit.UnitId)) then
                                        iMassMod = 0.25 --e.g. for overlayantinavy or submersibles with no attack
                                        if EntityCategoryContains(categories.ANTINAVY, oUnit.UnitId) then
                                            iMassMod = 1
                                        elseif EntityCategoryContains(categories.LAND * categories.ANTINAVY, oUnit.UnitId) then
                                            iMassMod = 0.5 --brick, wagner etc
                                            --UEF units (which are either really bad or good at antinavy)
                                        elseif EntityCategoryContains(categories.UEF * categories.ANTINAVY, oUnit.UnitId) then
                                            --Destroyer and battlecruiser
                                            if EntityCategoryContains(categories.DIRECTFIRE * categories.TECH2, oUnit.UnitId) then iMassMod = 0.25 --valiant
                                            elseif EntityCategoryContains(categories.DIRECTFIRE * categories.TECH3, oUnit.UnitId) then iMassMod = 0.15 --battlecruiser
                                            elseif EntityCategoryContains(categories.TECH2 - categories.DIRECTFIRE, oUnit.UnitId) then iMassMod = 1.2 --Cooper
                                            else
                                                --Unexpected category
                                                iMassMod = 0.5
                                            end
                                        elseif EntityCategoryContains(categories.CYBRAN * categories.ANTINAVY, oUnit.UnitId) then
                                            iMassMod = 0.8
                                        elseif EntityCategoryContains(refCategoryMegalith, oUnit.UnitId) then
                                            iMassMod = 0.5
                                        elseif EntityCategoryContains(refCategoryBattleship, oUnit.UnitId) then
                                            iMassMod = 0.05 --battleships could ground fire, although theyre unlikely to and very inaccurate if the target is moving
                                        end
                                    end
                                elseif bLongRangeThreatOnly then
                                    if EntityCategoryContains(categories.DIRECTFIRE + categories.INDIRECTFIRE, oUnit.UnitId) then
                                        local iUnitRange = GetBlueprintMaxGroundRange(oBP)
                                        if iUnitRange >= 55 then
                                            if EntityCategoryContains(categories.SILO * categories.TECH3 * categories.SUBMERSIBLE, oUnit.UnitId) then
                                                iMassMod = 0.25 --Missile sub
                                            end
                                        end
                                    end
                                else
                                    if EntityCategoryContains(categories.DIRECTFIRE, oUnit.UnitId) then
                                        if EntityCategoryContains(refCategoryLandScout, oUnit.UnitId) then
                                            if EntityCategoryContains(categories.SERAPHIM, oUnit.UnitId) then
                                                iMassMod = 0.55 --Selen costs 20, so Selen ends up with a threat of 12; engineer logic will ignore threats <10 (so all other lands couts)
                                            else iMassMod = 0.25
                                            end
                                        elseif EntityCategoryContains(refCategoryCruiserCarrier, oUnit.UnitId) then
                                            if EntityCategoryContains(categories.CYBRAN * categories.TECH2, oUnit.UnitId) then iMassMod = 0.55
                                            elseif EntityCategoryContains(categories.AEON, oUnit.UnitId) then
                                                iMassMod = 0.2 --Aeon cruiser loses vs 2 UEF frigates in sandbox (it kills 1 just before it dies)
                                            else
                                                iMassMod = 0.15 --e.g. uef cruiser - 1 frigate can almost solo it if it dodges the missiles
                                            end
                                        elseif EntityCategoryContains(refCategoryAttackBot * categories.TECH1, oUnit.UnitId) then
                                            iMassMod = 0.85
                                        elseif EntityCategoryContains(categories.BATTLESHIP - refCategoryBattlecruiser, oUnit.UnitId) then
                                            iMassMod = 0.85
                                        elseif EntityCategoryContains(categories.DESTROYER, oUnit.UnitId) then
                                            iMassMod = 0.95
                                        elseif EntityCategoryContains(refCategoryFrigate * categories.CYBRAN, oUnit.UnitId) then
                                            iMassMod = 1.05
                                        else iMassMod = 1
                                        end
                                    elseif EntityCategoryContains(refCategoryFatboy, oUnit.UnitId) then
                                        iMassMod = 0.55
                                    elseif EntityCategoryContains(categories.SUBCOMMANDER, oUnit.UnitId) then iMassMod = 1 --SACUs dont have directfire category for some reason (they have subcommander and overlaydirectfire)
                                    elseif EntityCategoryContains(categories.INDIRECTFIRE * categories.ARTILLERY * categories.STRUCTURE * categories.TECH2, oUnit.UnitId) then iMassMod = 0.1 --Gets doubled as its a structure
                                    elseif EntityCategoryContains(categories.INDIRECTFIRE * categories.ARTILLERY * categories.MOBILE * categories.TECH1, oUnit.UnitId) then iMassMod = 0.9
                                    elseif EntityCategoryContains(categories.INDIRECTFIRE * categories.ARTILLERY * categories.MOBILE * categories.TECH3, oUnit.UnitId) then iMassMod = 0.5
                                    elseif EntityCategoryContains(categories.SHIELD, oUnit.UnitId) then iMassMod = 0.75 --will be doubled for structures
                                    elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then iMassMod = 1 --Put in just in case - code was working before this, but dont want it to be affected yb more recenlty added engineer category
                                    elseif EntityCategoryContains(categories.ENGINEER,oUnit.UnitId) then iMassMod = 0.01 --Engis can reclaim and capture so can't just e.g. beat with a scout, but also dont want a combat unit to run from engineers as they could still harm them; alot of logic uses a threshold of 10 for threats, which would be c.3 T3 engineers, so will go with this
                                    end
                                    if bAddAntiNavy and iMassMod < 1 and EntityCategoryContains(categories.ANTINAVY  + categories.OVERLAYANTINAVY, oUnit.UnitId) then
                                        --Increase mass mod for certain units
                                        if iMassMod < 0.25 then iMassMod = 0.25 end
                                        if EntityCategoryContains(categories.SUBMERSIBLE + categories.ANTINAVY, oUnit.UnitId) then
                                            iMassMod = 1 --Subs
                                        elseif EntityCategoryContains(categories.LAND * categories.ANTINAVY, oUnit.UnitId) then
                                            iMassMod = math.max(iMassMod, 0.5) --wagners, bricks etc.
                                        elseif EntityCategoryContains(categories.SUBMERSIBLE * categories.SILO * categories.TECH3, oUnit.UnitId) then
                                            iMassMod = math.max(iMassMod, 0.25) --missile ship
                                        end
                                    end
                                end
                            else
                                if EntityCategoryContains(categories.INDIRECTFIRE, oUnit.UnitId) then
                                    if EntityCategoryContains(categories.SILO * categories.TECH3 * categories.SUBMERSIBLE, oUnit.UnitId) then
                                        iMassMod = 0.25 --Missile sub
                                    else
                                        iMassMod = 1
                                    end
                                    if EntityCategoryContains(categories.DIRECTFIRE, oUnit.UnitId) then iMassMod = 0.5 end
                                elseif EntityCategoryContains(categories.ANTIMISSILE, oUnit.UnitId) then iMassMod = 2 --Doubled for structures ontop of this, i.e. want 4xmass of TMD in indirect fire so can overwhelm it
                                elseif EntityCategoryContains(categories.SHIELD, oUnit.UnitId) then iMassMod = 1
                                elseif EntityCategoryContains(refCategoryLongRangeDFLand, oUnit.UnitId) then iMassMod = 0.5
                                end
                            end
                            if EntityCategoryContains(refCategoryStructure, oUnit.UnitId) then
                                --T2 arti - reduce its value because it sucks
                                if EntityCategoryContains(refCategoryFixedT2Arti, oUnit.UnitId) then
                                    iMassMod = iMassMod * 0.6
                                else
                                    iMassMod = iMassMod * 2
                                    if bAntiNavyOnly then iMassMod = iMassMod * 1.1 end
                                end
                            end
                        end
                        local iMassCost = (oBP.Economy.BuildCostMass or 0)
                        if bDebugMessages == true then LOG(sFunctionRef..': iMassCost='..(iMassCost or 'nil')..'; iMassMod='..(iMassMod or 'nil')) end
                        iBaseThreat = iMassCost * iMassMod
                    end
                elseif bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' is not valid')
                end

                iCurThreat = iBaseThreat
            end

            iTotalThreat = iTotalThreat + iCurThreat
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iTotalThreat='..iTotalThreat) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return iTotalThreat
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetAirThreatLevel(tUnits, bEnemyUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
    --Threat value depends on inputs:
    --bIncludeAntiAir - will include anti-air on ground units
    --bIncludeNonCombatAir - adds threat value for transports and scouts
    --bIncludeAirTorpedo - Adds threat for torpedo bombers
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetAirThreatLevel'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': About to check if table is empty. bIncludeAirToAir='..tostring(bIncludeAirToAir)) end

    if M28Utilities.IsTableEmpty(tUnits) then
        --if tUnits == nil then
        if bDebugMessages == true then LOG(sFunctionRef..': Warning: tUnits is empty, returning 0') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return 0
    else
        if bIncludeAirTorpedo == nil then bIncludeAirTorpedo = bIncludeAirToGround end
        local bUnitFitsDesiredCategory

        --Determine the amount that health impacts on threat
        local iHealthFactor = 1 --if unit has 40% health, then threat reduced by (1-40%)*iHealthFactor
        if bIncludeAirToAir == true then
            if bEnemyUnits and not(bBlueprintThreat) then
                iHealthFactor = 0.5
            else
                iHealthFactor = 0.15
            end
        elseif bIncludeAirToGround == true then iHealthFactor = 0.5
        else iHealthFactor = 0 end

        local iCurThreat = 0
        local iTotalThreat = 0
        local iBaseThreat = 0
        local iHealthPercentage
        local iHealthThreatFactor
        local iGhettoGunshipAdjust = 0


        local iThreatRef = '2'
        if bIncludeAirToAir then iThreatRef = iThreatRef..'1' else iThreatRef = iThreatRef..'0' end
        if bIncludeGroundToAir then iThreatRef = iThreatRef..'1' else iThreatRef = iThreatRef..'0' end
        if bIncludeAirToGround then iThreatRef = iThreatRef..'1' else iThreatRef = iThreatRef..'0' end
        if bIncludeNonCombatAir then iThreatRef = iThreatRef..'1' else iThreatRef = iThreatRef..'0' end
        if bIncludeAirTorpedo then iThreatRef = iThreatRef..'1' else iThreatRef = iThreatRef..'0' end
        if not(tiThreatRefsCalculated[iThreatRef]) then
            M28Utilities.ErrorHandler('Dont have a thraat ref '..iThreatRef..' So CalculateBlueprintThreatsByType threat calculation likely wrong')
        end




        for iUnit, oUnit in tUnits do
            iCurThreat = 0
            iBaseThreat = 0
            iGhettoGunshipAdjust = 0
            if bDebugMessages == true then LOG(sFunctionRef..': About to check if unit is dead') end

            if IsUnitValid(oUnit) then
                --Get the base threat for the unit
                iBaseThreat = (tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef] or 0)
                --Adjust threat for health
                if iBaseThreat > 0 then
                    --Increase for cargo of transports
                    if bIncludeAirToGround and EntityCategoryContains(categories.TRANSPORTATION, oUnit.UnitId) and oUnit.GetCargo then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have an enemy transport, will get its cargo and see if it contains LABs') end
                        --Include threat of cargo if cargo are LABs
                        local tCargo = oUnit:GetCargo()
                        --Filter to just LABs (note unfortunately it doesnt distinguish between mantis and LABs so matnis get treated as LABs to be prudent)
                        if tCargo then
                            tCargo = EntityCategoryFilterDown(refCategoryAttackBot, tCargo)
                            if M28Utilities.IsTableEmpty(tCargo) == false then
                                --Get mass value ignoring health:
                                --GetCombatThreatRating(aiBrain, tUnits, bMustBeVisibleToIntelOrSight, iMassValueOfBlipsOverride, iSoloBlipMassOverride, bIndirectFireThreatOnly, bJustGetMassValue)
                                iGhettoGunshipAdjust = GetCombatThreatRating(tCargo, bEnemyUnits)
                                if bDebugMessages == true then LOG(sFunctionRef..': Contains LABs so will increase threat by '..iGhettoGunshipAdjust) end
                            end
                        end
                    end

                    --Adjust threat for health
                    iHealthThreatFactor = 1
                    if iHealthFactor > 0 then
                        iHealthPercentage = GetUnitHealthPercent(oUnit)
                        --Assume low health experimental is has more health than it does - e.g. might heal, or might be under construction
                        if iHealthPercentage < 1 and EntityCategoryContains(categories.EXPERIMENTAL, oUnit) and oUnit:GetFractionComplete() >= 0.2 then iHealthPercentage = math.min(1, math.max(0.4, iHealthPercentage * 1.5)) end
                        iHealthThreatFactor = (1 - (1-iHealthPercentage) * iHealthFactor) * iHealthThreatFactor
                    end
                    iCurThreat = iBaseThreat * iHealthThreatFactor + iGhettoGunshipAdjust
                    if bDebugMessages == true then LOG(sFunctionRef..': UnitBP='..(oUnit.UnitId or 'nil')..'; iBaseThreat='..(iBaseThreat or 'nil')..'; iHealthThreatFactor='..(iHealthThreatFactor or 'nil')..'iGhettoGunshipAdjust='..(iGhettoGunshipAdjust or 'nil')..'; iCurThreat='..(iCurThreat or 'nil')) end
                end
            else
                --Calculate the base threat for hte blueprint (start of game)
                if bBlueprintThreat then
                    local oBP = __blueprints[oUnit.UnitId]
                    if bDebugMessages == true then LOG(sFunctionRef..': About to calculate threat using actual unit data, iThreatRef='..iThreatRef) end
                    --get actual threat calc
                    local iMassMod = 0 --For non-offensive structures
                    --Does the unit contain any of the categories of interest?
                    bUnitFitsDesiredCategory = false
                    --Exclude based on pathing type initially before considering more precisely:
                    local sCurUnitPathing = GetUnitPathingType(oUnit)
                    if sCurUnitPathing == M28Map.refPathingTypeAir then
                        if bIncludeAirToAir == true then bUnitFitsDesiredCategory = true
                        elseif bIncludeAirToGround == true then bUnitFitsDesiredCategory = true
                        elseif bIncludeAirTorpedo == true then bUnitFitsDesiredCategory = true
                        elseif bIncludeNonCombatAir == true then bUnitFitsDesiredCategory = true
                        end
                    elseif bIncludeGroundToAir == true then bUnitFitsDesiredCategory = true end

                    --Is unit still valid? If so then consider its weapons/categories more precisely:
                    if bDebugMessages == true then LOG(sFunctionRef..': bUnitFitsDesiredCategory='..tostring(bUnitFitsDesiredCategory)..'; bIncludeAirToAir='..tostring(bIncludeAirToAir)..'; bIncludeAirToGround='..tostring(bIncludeAirToGround)..'; iThreatRef='..iThreatRef) end
                    if bUnitFitsDesiredCategory == true then

                        local sCurUnitBP = oBP.BlueprintId

                        --Get values for air units:
                        if sCurUnitPathing == M28Map.refPathingTypeAir then
                            if bIncludeNonCombatAir == true then
                                iMassMod = 1
                                --Reduce to 25% for air scouts, as main concern is transports
                                if EntityCategoryContains(refCategoryAirScout, sCurUnitBP) then iMassMod = 0.25 end

                            else
                                if bIncludeAirToGround == true then
                                    if EntityCategoryContains(categories.BOMBER + categories.GROUNDATTACK + categories.OVERLAYDIRECTFIRE + categories.DIRECTFIRE, sCurUnitBP) == true then iMassMod = 1
                                    elseif EntityCategoryContains(categories.TRANSPORTATION, sCurUnitBP) then iMassMod = 1 --might be a ghetto
                                    end
                                end
                                if bIncludeAirTorpedo == true and EntityCategoryContains(categories.ANTINAVY, sCurUnitBP) == true then iMassMod = 1 end
                                if bDebugMessages == true then LOG(sFunctionRef..': bIncludeAirTorpedo='..tostring(bIncludeAirTorpedo)..'; iMassMod='..iMassMod) end

                                if bIncludeAirToAir == true and iMassMod < 1 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': bIncludeAirToAir='..tostring(bIncludeAirToAir)..'; iMassMod='..iMassMod..'; does BP contain airaa category='..tostring(EntityCategoryContains(categories.ANTIAIR * categories.AIR, sCurUnitBP))) end
                                    if EntityCategoryContains(categories.ANTIAIR * categories.AIR, sCurUnitBP) == true then
                                        iMassMod = 1
                                        if EntityCategoryContains(categories.BOMBER + categories.GROUNDATTACK + categories.DIRECTFIRE, sCurUnitBP) then
                                            iMassMod = 0.75 --e.g. t2 bombers
                                            --Manual adjustments for units with good AA that also have direct fire
                                            if sCurUnitBP == 'xaa0305' then iMassMod = 0.8 --Restorer
                                            elseif sCurUnitBP == 'xea0306' then iMassMod = 0.7 --Continental
                                            elseif sCurUnitBP == 'uaa0310' then iMassMod = 0.55 --Czar
                                            elseif sCurUnitBP == 'xsa0402' then iMassMod = 0.3 --Sera experi bomber
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': sCurUnitBP='..sCurUnitBP..': Mass mod after checking AirAA value='..iMassMod) end
                                    elseif EntityCategoryContains(categories.OVERLAYANTIAIR * categories.AIR, sCurUnitBP) then
                                        iMassMod = 0.05
                                    end
                                end
                            end
                        else
                            --Non-air pathing type
                            if bDebugMessages == true then LOG(sFunctionRef..': Unit doesnt have air pathing. bIncludeGroundToAir='..tostring(bIncludeGroundToAir)) end
                            if bIncludeGroundToAir == true then
                                if EntityCategoryContains(categories.ANTIAIR, sCurUnitBP) == true then
                                    iMassMod = 1 --Cruisers and T3 aircraft carriers have antiair as well as overlay antiair
                                    if sCurUnitBP == 'urs0103' or EntityCategoryContains(categories.EXPERIMENTAL, sCurUnitBP) then iMassMod = 0.1 end --Cybran frigate and land experimentals misclassified as anti-air
                                elseif EntityCategoryContains(categories.OVERLAYANTIAIR, sCurUnitBP) == true then
                                    iMassMod = 0.05
                                    if sCurUnitBP == 'ues0401' then iMassMod = 1 end --atlantis misclassifiefd as not anti-air
                                    if EntityCategoryContains(categories.FRIGATE, sCurUnitBP) then iMassMod = 0.18 end
                                end
                            end
                        end
                        --Increase AA threat for structures
                        if bIncludeGroundToAir == true and sCurUnitPathing == M28Map.refPathingTypeNone then iMassMod = iMassMod * 2 end
                    end

                    local iMassCost = (oBP.Economy.BuildCostMass or 0)
                    if bDebugMessages == true then LOG(sFunctionRef..': iMassCost='..(iMassCost or 'nil')..'; iMassMod='..(iMassMod or 'nil')) end
                    iBaseThreat = iMassCost * iMassMod
                end
                iCurThreat = iBaseThreat
            end

            iTotalThreat = iTotalThreat + iCurThreat
            if bDebugMessages == true then LOG(sFunctionRef..': Unit='..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; iCurThreat='..iCurThreat..'; iTotalThreat='..iTotalThreat) end
        end


        if bDebugMessages == true then LOG(sFunctionRef..': End of code, iTotalThreat='..iTotalThreat) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return iTotalThreat
    end
    M28Profiler.ErrorHandler('Code shouldve returend before now, will return 0')
    return 0
end

function CalculateBlueprintThreatsByType()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CalculateBlueprintThreatsByType'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(tUnitThreatByIDAndType) then
        local sUnitId
        --{bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly}
        local tiLandAndNavyThreatTypes = {
            ['1000000'] = { false, false, false, false, false, false }, --Normal land threat
            ['1010000'] = { true, false, false, false, false, false, false }, --mass cost
            ['1100000'] = { false, true, false, false, false, false }, --Indirect
            ['1000100'] = { false, false, false, true, false, false }, --Normal land threat plus antinavy threat if higher
            ['1001000'] = { false, false, true, false, false, false }, --Antinavy threat only
            ['1000010'] = { false, false, false, false, true, false }, --Submersible threat only
            ['1000001'] = { false, false, false, false, false, true }, --Long range threat only
        }
        --{bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo}
        local tiAirThreatTypes = {
            ['200001'] = {false, false, false, false, true,}, --Torpedo bombers
            ['200100'] = { false, false, true, false, false }, --Air to ground
            ['200110'] = { false, false, true, true, false }, --Air to gorund and non-combat
            ['200111'] = { false, false, true, true, true }, --Air to ground and non-combat; note: The code will set TorpBombers to equal the airtoground value if it's nil, hence use of code ending 111
            ['201000'] = { false, true, false, false, false }, --Ground AA
            ['210000'] = { true, false, false, false, false }, --Air AA
            ['210110'] = { true, false, true, true, false }, --Air threat (general)
            ['210111'] = { true, false, true, true, true }, --Air threat (general)
            ['200101'] = { true, false, true, true, true }, --Bombers and torpedo bombers
            ['210011'] = { true, false, false, true, true}, --Air excluding air to ground (but including torp bombers) - i.e. 'air excluding dangerous to land tanks on land'
            ['210010'] = { true, false, false, true, false}, --Air excluding air to ground (i.e. excluding torp bombers as well)
            ['200011'] = { false, false, false, true, true}, --Used to get non-AA non-Air to ground (excl torp bomber) air, e.g. intended for land zones to determine 'other'/less important air
            ['200010'] = { false, false, false, true, false}, --Used to get non-AA non-Air to ground air, e.g. intended for water zones to determine 'other'/less important air
            --['211000'] = { true, true, false, false, false} --GroundAA and AirAA combined - was thinking of using this for recording IMAP air version but decided to stick to just airaa
        }

        for iRef, tValue in tiLandAndNavyThreatTypes do
            tiThreatRefsCalculated[iRef] = true
        end
        for iRef, tValue in tiAirThreatTypes do
            tiThreatRefsCalculated[iRef] = true
        end



        function RecordBlueprintThreatValues(oBP, sUnitId)

            tUnitThreatByIDAndType[sUnitId] = {}
            if bDebugMessages == true then LOG(sFunctionRef..': About to consider different land threat values for unit '..sUnitId..' Name='..(oBP.General.UnitName or 'nil')) end
            for iRef, tConditions in tiLandAndNavyThreatTypes do
                --GetCombatThreatRating(tUnits, bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, bBlueprintThreat)
                --{bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly}
                tUnitThreatByIDAndType[sUnitId][iRef] = GetCombatThreatRating( { {['UnitId']=sUnitId }}, false, tConditions[1], tConditions[2], tConditions[3], tConditions[4], tConditions[5], tConditions[6], true)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished calculating land threat values for '..(oBP.General.UnitName or 'nil')..', result='..reprs(tUnitThreatByIDAndType[sUnitId])) end

            for iRef, tConditions in tiAirThreatTypes do
                --GetAirThreatLevel(tUnits, bEnemyUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
                tUnitThreatByIDAndType[sUnitId][iRef] = GetAirThreatLevel({ {['UnitId']=sUnitId }}, false, tConditions[1], tConditions[2], tConditions[3], tConditions[4], tConditions[5], true)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished calculating air threat values, result of land and air for '..(oBP.General.UnitName or 'nil')..'='..reprs(tUnitThreatByIDAndType[sUnitId])) end
        end

        local iCount = 0

        for iBP, oBP in __blueprints do
            --Updates tUnitThreatByIDAndType
            sUnitId = oBP.BlueprintId
            if bDebugMessages == true then LOG('Will shortly (via a forked threat) get the blueprint threat for enemy unit sUnitId '..sUnitId..'; tUnitThreatByIDAndType[sUnitId]='..(tUnitThreatByIDAndType[sUnitId] or 'nil')..'; oBP.Economy.BuildCostMass='..(oBP.Economy.BuildCostMass or 'nil')..'; oBP.General.UnitName='..(oBP.General.UnitName or 'nil')..' if it has a build cost mass of at least 1 and we havent already called it') end

            if not(tUnitThreatByIDAndType[sUnitId]) and (oBP.Economy.BuildCostMass or 0) > 0 then
                --iCount = iCount + 1
                --if iCount >= 10 then break end
                ForkThread(RecordBlueprintThreatValues, oBP, sUnitId)
            end
        end

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetUnitHealthPercent(oUnit)
    return oUnit:GetHealth() / oUnit:GetMaxHealth()
end

function GetCurrentAndMaximumShield(oUnit, bIgnoreIfShieldFailedFromLowPower)
    --Returns 0, 0 if unit has no shield, or 0, [max shield] if it has a shield but it is depleted
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetCurrentAndMaximumShield'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if oUnit.MyShield then
        local iCurShield = 0
        local iMaxShield = 0
        if oUnit.MyShield then
            iCurShield = oUnit.MyShield:GetHealth()
            iMaxShield = oUnit.MyShield:GetMaxHealth()
        else
            local tShield = oUnit:GetBlueprint().Defense
            if tShield then
                iCurShield = (oUnit:GetShieldRatio(false) or 0) * iMaxShield
            end
        end
        if iCurShield > 0 then
            if not(bIgnoreIfShieldFailedFromLowPower) then
                --GetHealth doesnt look like it factors in power stall
                if not(oUnit.MyShield.Enabled) or oUnit.MyShield.DepletedByEnergy or (oUnit:GetAIBrain():GetEconomyStored('ENERGY') == 0) then iCurShield = 0 end
            end
        end
        if bDebugMessages == true then
            LOG(sFunctionRef..': iCurShield='..iCurShield..'; iMaxShield='..iMaxShield..'; ShieldRatio False='..oUnit:GetShieldRatio(false)..'; ShieldRatio true='..oUnit:GetShieldRatio(true)..' iCurShield='..iCurShield)
            if oUnit.MyShield then LOG('Unit has MyShield; IsUp='..tostring(oUnit.MyShield:IsUp())..'; shield health='..oUnit.MyShield:GetHealth()) end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return iCurShield, iMaxShield
    else
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return 0, 0
    end
end

function IsUnitShieldEnabled(oUnit)
    return not(oUnit[refbShieldIsDisabled])
end
function DisableUnitShield(oUnit)
    oUnit[refbShieldIsDisabled] = true
    oUnit:DisableShield()
end
function EnableUnitShield(oUnit)
    oUnit:EnableShield()
    oUnit[refbShieldIsDisabled] = false
end

function DisableUnitIntel(oUnit)
    oUnit:OnScriptBitSet(3)
end
function EnableUnitIntel(oUnit)
    oUnit:OnScriptBitClear(3)
end

function DisableUnitJamming(oUnit)
    oUnit:OnScriptBitSet(2)
end
function EnableUnitJamming(oUnit)
    oUnit:OnScriptBitClear(2)
end

function DisableUnitStealth(oUnit)
    oUnit:SetScriptBit('RULEUTC_StealthToggle', true)
    oUnit:SetScriptBit('RULEUTC_CloakToggle', true)
end

function EnableUnitStealth(oUnit)
    oUnit:SetScriptBit('RULEUTC_StealthToggle', false)
    oUnit:SetScriptBit('RULEUTC_CloakToggle', false)
end

function GetBlueprintMaxGroundRange(oBP)
--Simpler version of recordunitrange, intended at start of game to estimate whether a unit is a long range unit for threat calculations
    local iMaxRange = 0
    if oBP.Weapon then
        for iCurWeapon, oCurWeapon in oBP.Weapon do
            if oCurWeapon.MaxRadius > iMaxRange and not(oCurWeapon.EnabledByEnhancement) and oCurWeapon.Damage > 0 then
                if oCurWeapon.FireTargetLayerCapsTable and oCurWeapon.FireTargetLayerCapsTable['Land'] == 'Land|Water|Seabed' and not(oCurWeapon.ManualFire) then
                    iMaxRange = math.max(iMaxRange, oCurWeapon.MaxRadius)
                end
            end
        end
    end
    return iMaxRange
end

function GetBomberAOEAndStrikeDamage(oUnit)
    local oBP = oUnit:GetBlueprint()
    local iAOE = 0
    local iStrikeDamage = 0
    local iFiringRandomness
    for sWeaponRef, tWeapon in oBP.Weapon do
        if tWeapon.WeaponCategory == 'Bomb' or tWeapon.WeaponCategory == 'Direct Fire' then
            if (tWeapon.DamageRadius or 0) > iAOE then
                iAOE = tWeapon.DamageRadius
                iStrikeDamage = tWeapon.Damage * tWeapon.MuzzleSalvoSize
                if tWeapon.MuzzleSalvoSize > 2 then iStrikeDamage = iStrikeDamage * 0.5 end
                iFiringRandomness = (tWeapon.FiringRandomness or 0)
            end
        end
    end
    if iStrikeDamage == 0 then
        M28Utilities.ErrorHandler('Couldnt identify strike damage for bomber '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; will refer to predefined value instead')
    end

    --Manual floor for strike damage due to complexity of some bomber calculations
    --Check if manual override is higher, as some weapons will fire lots of shots so above method wont be accurate
    local tiBomberStrikeDamageByFactionAndTech =
    {
        --UEF, Aeon, Cybran, Sera, Nomads (are using default), Default
        { 150, 200, 155, 250, 150, 150 }, --Tech 1
        { 350, 300, 850, 1175, 550, 550 }, --Tech 2
        { 2500, 2500, 2500, 2500, 2500, 2500}, --Tech 3 - the strike damage calculation above should be accurate so this is just as a backup, and set at a low level due to potential for more balance changes affecting this
        { 11000,11000,11000,11000,11000,11000} --Tech 4 - again as a backup
    }
    iStrikeDamage = math.max(iStrikeDamage, tiBomberStrikeDamageByFactionAndTech[GetUnitTechLevel(oUnit)][GetFactionFromBP(oBP)])


    return iAOE, iStrikeDamage, iFiringRandomness
end

function GetUnitStrikeDamage(oUnit)
    --Gets strike damage of the first weapon in oUnit (longer term might want to make better so it considers other weapons)
    --For bombers will be subject to a minimum value as some bombers will have
    local oBP = oUnit:GetBlueprint()
    local sBP = oUnit.UnitId
    local iStrikeDamage = 0


    if EntityCategoryContains(refCategoryBomber, sBP) then
        --Doublecheck strike damage based on if it references a bomb
        local iAOE
        iAOE, iStrikeDamage = GetBomberAOEAndStrikeDamage(oUnit)
    elseif EntityCategoryContains(refCategoryTorpBomber, sBP) then
        for iCurWeapon, oCurWeapon in oBP.Weapon do
            if oCurWeapon.Label == 'Bomb' or oCurWeapon.Label == 'Torpedo' then
                iStrikeDamage = (oCurWeapon.DoTPulses or 1) * (oCurWeapon.MuzzleSalvoSize or 1) * oCurWeapon.Damage
                break
            end
        end
        if iStrikeDamage == 0 then
            iStrikeDamage = 750 --Backup
            M28Utilities.ErrorHandler('Have torp bomber with no bomb weapon so not calculated strike damage')
        end
    elseif EntityCategoryContains(refCategorySniperBot * categories.SERAPHIM, sBP) then
        iStrikeDamage = GetSniperStrikeDamage(oUnit)
    elseif oBP.Weapon and oBP.Weapon[1] then
        iStrikeDamage = oBP.Weapon[1].Damage
    end
        return iStrikeDamage
end

function RecordUnitRange(oUnit)
    --Updates unit range variables - sets to nil if it has nothing with that range, otherwise records it as the highest range it has.  Factors in enhancements. Also records if unit unpacks for T3 mobile arti
    --Also updates if unit can kite
    --Also records unit strike damage for certain air units
    local oBP = oUnit:GetBlueprint()
    local bWeaponUnpacks = false
    local bWeaponIsFixed = false
    if oBP.Weapon then
        for iCurWeapon, oCurWeapon in oBP.Weapon do
            if not(oCurWeapon.EnabledByEnhancement) or (oCurWeapon.EnabledByEnhancement and oUnit:HasEnhancement(oCurWeapon.EnabledByEnhancement)) then
                if oCurWeapon.ManualFire then
                    oUnit[refiManualRange] = math.max((oUnit[refiManualRange] or 0), oCurWeapon.MaxRadius)
                    oUnit[refiIndirectAOE] = math.max((oUnit[refiIndirectAOE] or 0), oCurWeapon.MaxRadius or 0)
                elseif oCurWeapon.RangeCategory == 'UWRC_Countermeasure' then
                    oUnit[refiMissileDefenceRange] = math.max((oUnit[refiMissileDefenceRange] or 0), oCurWeapon.MaxRadius)
                elseif oCurWeapon.RangeCategory == 'UWRC_DirectFire' or (oCurWeapon.RangeCategory == 'UWRC_IndirectFire' and oCurWeapon.WeaponCategory == 'Direct Fire') then --Sera sniper bots have an 'indirectfire' range category that is actually DF
                    oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius or 0)
                    if (oCurWeapon.DamageRadius or 0) > 0 then oUnit[refiDFAOE] = math.max((oUnit[refiDFAOE] or 0), oCurWeapon.DamageRadius) end
                    if oCurWeapon.RateOfFire then oUnit[refiTimeBetweenDFShots] = math.max((oUnit[refiTimeBetweenDFShots] or 0), 1 / oCurWeapon.RateOfFire) end
                elseif oCurWeapon.RangeCategory == 'UWRC_AntiNavy' then
                    oUnit[refiAntiNavyRange] = math.max((oUnit[refiAntiNavyRange] or 0), oCurWeapon.MaxRadius)
                elseif oCurWeapon.RangeCategory == 'UWRC_AntiAir' or oCurWeapon.WeaponCategory == 'Anti Air' then
                    oUnit[refiAARange] = math.max((oUnit[refiAARange] or 0), oCurWeapon.MaxRadius)
                elseif oCurWeapon.RangeCategory == 'UWRC_IndirectFire' then
                    oUnit[refiIndirectRange] = math.max((oUnit[refiIndirectRange] or 0), oCurWeapon.MaxRadius)
                    if oCurWeapon.WeaponUnpacks then oUnit[refbWeaponUnpacks] = true end
                    oUnit[refiIndirectAOE] = math.max((oUnit[refiIndirectAOE] or 0), oCurWeapon.MaxRadius or 0)
                    if oCurWeapon.RateOfFire then oUnit[refiTimeBetweenIFShots] = math.max((oUnit[refiTimeBetweenIFShots] or 0), 1 / oCurWeapon.RateOfFire) end
                elseif not(oCurWeapon.RangeCategory) or oCurWeapon.RangeCategory == 'UWRC_Undefined' then
                    if oCurWeapon.Label == 'Bomb' or oCurWeapon.DisplayName == 'Kamikaze' or oCurWeapon.Label == 'Torpedo' then
                        oUnit[refiBomberRange] = math.max((oUnit[refiBomberRange] or 0), oCurWeapon.MaxRadius)
                    elseif oCurWeapon.WeaponCategory == 'Direct Fire' or oCurWeapon.WeaponCategory == 'Direct Fire Experimental' or oCurWeapon.WeaponCategory == 'Kamikaze' then
                        oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                        if (oCurWeapon.DamageRadius or 0) > 0 then oUnit[refiDFAOE] = math.max((oUnit[refiDFAOE] or 0), oCurWeapon.DamageRadius) end
                        if oCurWeapon.RateOfFire then oUnit[refiTimeBetweenDFShots] = math.max((oUnit[refiTimeBetweenDFShots] or 0), 1 / oCurWeapon.RateOfFire) end
                    elseif (oCurWeapon.Damage or 0) == 0 or (oCurWeapon.MaxRadius or 0) <= 1 then
                        --Ignore
                    elseif oUnit.UnitId == 'uab4201' then
                        --Aeon TMD - ignore as it has a rangecategory for the weapon that uses the correct range so want to ignore the other waepon anyway
                    else
                        M28Utilities.ErrorHandler('Unrecognised range category for unit '..oUnit.UnitId)
                        --If this triggers do a reprs of the weapon to figure out why
                    end
                else
                    M28Utilities.ErrorHandler('Unrecognised range category '..oCurWeapon.RangeCategory..' for unit '..oUnit.UnitId)
                end
            end
            if oCurWeapon.WeaponUnpacks and oCurWeapon.WeaponUnpackLocksMotion then bWeaponUnpacks = true
            elseif oCurWeapon.SlavedToBody or oCurWeapon.SlavedToTurret then bWeaponIsFixed = true
            end
        end
        if M28Utilities.IsTableEmpty(oBP.Enhancements) == false and (oUnit[refiDFRange] or 0) > 0 then
            --Check if we have a max range in an enhancement
            for sEnhancement, tEnhancement in oBP.Enhancements do
                if tEnhancement.NewMaxRadius and oUnit:HasEnhancement(sEnhancement) then
                    oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), tEnhancement.NewMaxRadius)
                end
            end
        end
        if not(bWeaponUnpacks or (bWeaponIsFixed and EntityCategoryContains(categories.EXPERIMENTAL - refCategoryFatboy, oUnit.UnitId))) then
            oUnit[refbCanKite] = true
        end
        --LOG('Considering unitID '..(oUnit.UnitId or 'nil')..'; is unit valid='..tostring(IsUnitValid(oUnit)))
        if oUnit.GetAIBrain and oUnit:GetAIBrain().M28AI and EntityCategoryContains(refCategorySniperBot * categories.SERAPHIM, oUnit.UnitId) then
            EnableLongRangeSniper(oUnit)
            --LOG('Enabled long range on sniper, DFRange='..oUnit[refiDFRange]..'; Strike damage='..GetUnitStrikeDamage(oUnit))
        end
    end
    oUnit[refiStrikeDamage] = GetUnitStrikeDamage(oUnit)

end

function ConvertTechLevelToCategory(iTechLevel)
    if iTechLevel == 2 then return categories.TECH2
    elseif iTechLevel == 3 then return categories.TECH3
    elseif iTechLevel == 4 then return categories.EXPERIMENTAL
    else return categories.TECH1
    end
end

function GetUnitUpgradeBlueprint(oUnitToUpgrade, bGetSupportFactory)
    --Returns support factory ID if it can be built, otherwise returns normal upgrade unit (works for any unit, not just factory)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnitUpgradeBlueprint'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bGetSupportFactory == nil then bGetSupportFactory = true end
    --Gets the support factory blueprint, and checks if it can be built; if not then returns the normal UpgradesTo blueprint
    local sUpgradeBP
    if not(oUnitToUpgrade.Dead) and oUnitToUpgrade.CanBuild then
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, UnitToUpgrade='..oUnitToUpgrade.UnitId..GetUnitLifetimeCount(oUnitToUpgrade)) end
        if bGetSupportFactory == true and oUnitToUpgrade.CanBuild then
            local tsSupportFactoryBP = {

                -- Aeon
                ['uab0101']  = 'zab9501',
                ['uab0102']  = 'zab9502',
                ['uab0103']  = 'zab9503',
                ['uab0201'] = 'zab9601',
                ['uab0202'] = 'zab9602',
                ['uab0203'] = 'zab9603',

                -- UEF
                ['ueb0101']  = 'zeb9501',
                ['ueb0102']  = 'zeb9502',
                ['ueb0103']  = 'zeb9503',
                ['ueb0201'] = 'zeb9601',
                ['ueb0202'] = 'zeb9602',
                ['ueb0203'] = 'zeb9603',

                -- Cybran
                ['urb0101']  = 'zrb9501',
                ['urb0102']  = 'zrb9502',
                ['urb0103']  = 'zrb9503',
                ['urb0201'] = 'zrb9601',
                ['urb0202'] = 'zrb9602',
                ['urb0203'] = 'zrb9603',

                -- Seraphim
                ['xsb0101']  = 'zsb9501',
                ['xsb0102']  = 'zsb9502',
                ['xsb0103']  = 'zsb9503',
                ['xsb0201'] = 'zsb9601',
                ['xsb0202'] = 'zsb9602',
                ['xsb0203'] = 'zsb9603',

                -- Seraphim
                ['xsb0101']  = 'zsb9501',
                ['xsb0102']  = 'zsb9502',
                ['xsb0103']  = 'zsb9503',
                ['xsb0201'] = 'zsb9601',
                ['xsb0202'] = 'zsb9602',
                ['xsb0203'] = 'zsb9603',
            }

            local sFactoryBP = oUnitToUpgrade.UnitId
            if tsSupportFactoryBP[sFactoryBP] then
                if bDebugMessages == true then LOG(sFunctionRef..': Support factoryBP='..tsSupportFactoryBP[sFactoryBP]) end
                sUpgradeBP = tsSupportFactoryBP[sFactoryBP]
                if bDebugMessages == true then LOG(sFunctionRef..': oUnitToUpgrade='..sFactoryBP..GetUnitLifetimeCount(oUnitToUpgrade)..'; Checking if can upgrade to sUpgradeBP='..sUpgradeBP..'; oUnitToUpgrade:CanBuild(sUpgradeBP)='..tostring(oUnitToUpgrade:CanBuild(sUpgradeBP))) end
                if not(oUnitToUpgrade:CanBuild(sUpgradeBP)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Cant build '..sUpgradeBP) end
                    sUpgradeBP = nil
                end
            end
        end
        if not(sUpgradeBP) then
            local oFactoryBP = oUnitToUpgrade:GetBlueprint()
            sUpgradeBP = oFactoryBP.General.UpgradesTo
            if bDebugMessages == true then LOG(sFunctionRef..': sUpgradeBP='..(sUpgradeBP or 'nil')) end
            if not(sUpgradeBP) or sUpgradeBP == '' or not(oUnitToUpgrade:CanBuild(sUpgradeBP)) then sUpgradeBP = nil end
            if bDebugMessages == true then LOG(sFunctionRef..': Didnt have valid support factory to upgrade to; blueprint UpgradesTo='..(sUpgradeBP or 'nil')) end
        end
        if sUpgradeBP == '' then
            sUpgradeBP = nil
            if bDebugMessages == true then LOG(sFunctionRef..': Have no blueprint to upgrade to') end
        elseif bDebugMessages == true then LOG(sFunctionRef..': Returning sUpgradeBP'..(sUpgradeBP or 'nil'))
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return sUpgradeBP
end

function DoesCategoryContainCategoryUSEM28UTILITIESVERSION()
end

function GetUpgradeBuildTime(oUnit, sUpgradeRef)
    --Returns nil if unit cant get enhancements
    local oBP = oUnit:GetBlueprint()
    local iUpgradeTime
    if oBP.Enhancements then
        for sUpgradeID, tUpgrade in oBP.Enhancements do
            if sUpgradeID == sUpgradeRef then
                iUpgradeTime = tUpgrade.BuildTime
            end

        end
    end
    return iUpgradeTime
end

function GetUpgradeMassCost(oUnit, sUpgradeRef)
    local oBP = oUnit:GetBlueprint()
    local iUpgradeMass
    if oBP.Enhancements then
        for sUpgradeID, tUpgrade in oBP.Enhancements do
            if sUpgradeID == sUpgradeRef then
                iUpgradeMass = tUpgrade.BuildCostMass
            end

        end
    end
    if not(iUpgradeMass) then M28Utilities.ErrorHandler('oUnit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' has no upgrade with reference '..sUpgradeRef) end
    return iUpgradeMass
end

function GetUpgradeEnergyCost(oUnit, sUpgradeRef)
    local oBP = oUnit:GetBlueprint()
    local iUpgradeEnergy
    if oBP.Enhancements then
        for sUpgradeID, tUpgrade in oBP.Enhancements do
            if sUpgradeID == sUpgradeRef then
                iUpgradeEnergy = tUpgrade.BuildCostEnergy
            end

        end
    end
    if not(iUpgradeEnergy) then M28Utilities.ErrorHandler('oUnit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' has no upgrade with reference '..sUpgradeRef) end
    return iUpgradeEnergy
end

function AddOrRemoveUnitFromListOfPausedUnits(oUnit, bPauseNotUnpause)
    local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
    --Remove from list of paused units

    if not(bPauseNotUnpause) then
        if oUnit[refbPaused] then
            local aiBrain = oUnit:GetAIBrain()
            if M28Utilities.IsTableEmpty(aiBrain[M28Economy.reftPausedUnits]) == false then
                for iPausedUnit, oPausedUnit in aiBrain[M28Economy.reftPausedUnits] do
                    if oPausedUnit == oUnit then
                        --LOG('AddOrRemoveUnitFromListOfPausedUnits: Removing unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' from table of paused units')
                        table.remove(aiBrain[M28Economy.reftPausedUnits], iPausedUnit)
                        break
                    end
                end
            end
        end
    else
        --Are pausing unit, make sure it is in the table of paused units
        if not(oUnit[refbPaused]) then
            local aiBrain = oUnit:GetAIBrain()
            local bRecordUnit = true
            if M28Utilities.IsTableEmpty(aiBrain[M28Economy.reftPausedUnits]) == false then
                --Check if already recorded - redundancy due to nasty near-infinite loop in M27 where it could keep adding units to the table resulting in the same unit considered 20+ times
                for iRecordedUnit, oRecordedUnit in aiBrain[M28Economy.reftPausedUnits] do
                    if oRecordedUnit == oUnit then
                        bRecordUnit = false
                        break
                    end
                end
            end
            if bRecordUnit then
                --LOG('AddOrRemoveUnitFromListOfPausedUnits: Adding unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' to table of paused units')
                table.insert(aiBrain[M28Economy.reftPausedUnits], oUnit)
            end
        end
    end
end

function PauseOrUnpauseMassUsage(oUnit, bPauseNotUnpause)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'PauseOrUnpauseMassUsage'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if bDebugMessages == true then
        local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
        LOG(sFunctionRef..': Start of code time='..GetGameTimeSeconds()..', oUnit='..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; Unit state='..GetUnitState(oUnit)..'; Engineer action (if have one)='..(oUnit[M28Engineer.refiAssignedAction] or 'nil')..'; oUnit:IsPaused='..tostring(oUnit:IsPaused()))
        if oUnit.GetWorkProgress then LOG(sFunctionRef..': Unit work progress='..oUnit:GetWorkProgress()) end
    end

    if IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 and oUnit.SetPaused then
        AddOrRemoveUnitFromListOfPausedUnits(oUnit, bPauseNotUnpause)

        --Want to pause unit, check for any special logic for pausing
        --Normal logic - just pause unit - exception if are dealing with a factory whose workcomplete is 100% and want to pause it
        if (not(bPauseNotUnpause) or not(oUnit:IsPaused())) and (not(EntityCategoryContains(refCategoryFactory, oUnit.UnitId)) or (oUnit.GetWorkProgress and oUnit:GetWorkProgress() > 0 and oUnit:GetWorkProgress() < 1) or (oUnit:IsPaused() and not(bPauseNotUnpause))) then

            if oUnit.UnitId == 'xsb2401' then M28Utilities.ErrorHandler('Pausing Yolona') end
            if bDebugMessages == true then LOG(sFunctionRef..': About to set paused to '..tostring(bPauseNotUnpause)..' for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' Unit state='..GetUnitState(oUnit))
                if oUnit.GetWorkProgress then LOG(sFunctionRef..': Unit work progress='..oUnit:GetWorkProgress()) end
            end
            oUnit:SetPaused(bPauseNotUnpause)
            oUnit[refbPaused] = bPauseNotUnpause
            --If unit isnt actually paused (e.g. due to error with set paused) then clear this flag
            if oUnit[refbPaused] and not(oUnit:IsPaused()) then
                oUnit[refbPaused] = false
                if bDebugMessages == true then LOG(sFunctionRef..': Unit isnt actually paused so wont set this flag') end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Just set paused to '..tostring(bPauseNotUnpause)..' for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)) end
        elseif bDebugMessages == true then
            LOG(sFunctionRef..': Factory with either no workprogress or workprogress that isnt <1')
            if oUnit.GetWorkProgress then LOG(sFunctionRef..': Workprogress='..oUnit:GetWorkProgress()) end
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Unit isnt valid') end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, unit paused flag='..tostring(oUnit[refbPaused] or false)) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function PauseOrUnpauseEnergyUsage(oUnit, bPauseNotUnpause)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'PauseOrUnpauseEnergyUsage'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then
        LOG(sFunctionRef..': Start of code time='..GetGameTimeSeconds()..', oUnit='..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' owned by brain '..oUnit:GetAIBrain().Nickname..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; Unit state='..GetUnitState(oUnit)..'; Unit is paused='..tostring(oUnit:IsPaused()))
        if oUnit.GetFocusUnit and oUnit:GetFocusUnit() then LOG(sFunctionRef..': Focus unit='..oUnit:GetFocusUnit().UnitId..GetUnitLifetimeCount(oUnit:GetFocusUnit())) end
        if oUnit.GetWorkProgress then LOG(sFunctionRef..': Unit work progress='..oUnit:GetWorkProgress()..'; Unit fraction complete='..oUnit:GetFractionComplete()) end
    end
    if IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 and oUnit.SetPaused then
        AddOrRemoveUnitFromListOfPausedUnits(oUnit, bPauseNotUnpause)

        --Jamming - check via blueprint since no reliable category
        local oBP = oUnit:GetBlueprint()
        if oBP.Intel.JamRadius then
            if bPauseNotUnpause then DisableUnitJamming(oUnit)
            else EnableUnitJamming(oUnit)
            end
        end

        --Want to pause/unpause unit, check for any special logic for pausing
        --local bWasUnitPaused = (oUnit[refbPaused] or false)
        if oUnit.MyShield and oUnit.MyShield:GetMaxHealth() > 0 then
            if IsUnitShieldEnabled(oUnit) == bPauseNotUnpause then
                if bPauseNotUnpause then DisableUnitShield(oUnit)
                else EnableUnitShield(oUnit) end
                oUnit[refbPaused] = bPauseNotUnpause
            end
        elseif oBP.Intel.ReactivateTime and (oBP.Intel.SonarRadius or oBP.Intel.RadarRadius) then
            if bPauseNotUnpause then DisableUnitIntel(oUnit)
            else EnableUnitIntel(oUnit)
            end
            oUnit[refbPaused] = bPauseNotUnpause
        elseif oBP.Intel.Cloak or oBP.Intel.RadarStealth or oBP.Intel.RadarStealthFieldRadius then
            if bPauseNotUnpause then DisableUnitStealth(oUnit)
            else EnableUnitStealth(oUnit)
            end
            oUnit[refbPaused] = bPauseNotUnpause
        end
        --Normal logic - just pause unit - exception if are dealing with a factory whose workcomplete is 100%
        if oUnit.SetPaused and (not(bPauseNotUnpause) or not(oUnit:IsPaused())) and (not(EntityCategoryContains(refCategoryFactory, oUnit.UnitId)) or (oUnit.GetWorkProgress and oUnit:GetWorkProgress() > 0 and oUnit:GetWorkProgress() < 1)) then
            if oUnit.UnitId == 'xsb2401' then M28Utilities.ErrorHandler('Pausing Yolona') end
            if bDebugMessages == true then LOG(sFunctionRef..': About to set paused to '..tostring(bPauseNotUnpause)..' for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; Unit state='..GetUnitState(oUnit))
                if oUnit.GetWorkProgress then LOG(sFunctionRef..': Unit work progress='..oUnit:GetWorkProgress()) end
            end
            oUnit:SetPaused(bPauseNotUnpause)
            oUnit[refbPaused] = bPauseNotUnpause
            --If unit isnt actually paused (e.g. due to error with set paused) then clear this flag
            if oUnit[refbPaused] and not(oUnit:IsPaused()) then
                oUnit[refbPaused] = false
                if bDebugMessages == true then LOG(sFunctionRef..': Unit isnt actually paused so wont set this flag') end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Just set paused to '..tostring(bPauseNotUnpause)..' for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)) end
        elseif bDebugMessages == true then
            LOG(sFunctionRef..': Factory with either no workprogress or workprogress that isnt <1; is .SetPaused nil='..tostring(oUnit.SetPaused == nil)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; Unit[refbPaused]='..tostring(oUnit[refbPaused])..'; fraction complete='..oUnit:GetFractionComplete()..'; Is unit a factory='..tostring(EntityCategoryContains(refCategoryFactory, oUnit.UnitId)))
            if oUnit.GetWorkProgress then LOG(sFunctionRef..': Workprogress='..oUnit:GetWorkProgress()) end
        end

    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function GetFactionFromBP(oBlueprint)
    --Returns faction number for oBlueprint
    --1: UEF, 2: Aeon, 3: Cybran, 4: Seraphim, 5: Nomads, 6 = not recognised
    --Note: General.FactionName property uses lowercase for some factions; the categories.x uses upper case
    --Assumed nomads is Nomads

    local tFactionsByName = {[refFactionUEF] = 'UEF', [refFactionAeon] = 'Aeon', [refFactionCybran] = 'Cybran', [refFactionSeraphim] = 'Seraphim', [refFactionNomads] = 'Nomads'}
    local sUnitFactionName = oBlueprint.General.FactionName
    for iName, sName in tFactionsByName do
        if sName == sUnitFactionName then return iName end
    end
    return refFactionUnrecognised
end

function GetUnitFaction(oUnit)
    ----1: UEF, 2: Aeon, 3: Cybran, 4: Seraphim, 5: Nomads, 6 = not recognised
    return GetFactionFromBP(oUnit:GetBlueprint())
end

function GetFactoryType(oUnit)
    local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua') --Putting this at the top crashes the game

    if EntityCategoryContains(refCategoryLandFactory, oUnit.UnitId) then
        return M28Factory.refiFactoryTypeLand
    elseif EntityCategoryContains(refCategoryAirFactory, oUnit.UnitId) then
        return M28Factory.refiFactoryTypeAir
    elseif EntityCategoryContains(refCategoryNavalFactory, oUnit.UnitId) then
        return M28Factory.refiFactoryTypeNaval
    else return M28Factory.refiFactoryTypeOther
    end
end

function GetUnitFacingAngle(oUnit)
    --0/360 = north, 90 = west, 180 = south, 270 = east

    --T3 arti - get the angle of the turret
    if EntityCategoryContains(categories.STRUCTURE * categories.DIRECTFIRE + categories.STRUCTURE * categories.INDIRECTFIRE, oUnit.UnitId) then
        if oUnit.GetWeapon and oUnit:GetWeaponCount() > 0 then
            --LOG('GetFacingAngle: oUnit='..oUnit.UnitId..GetUnitLifetimeCount(oUnit))
            local oWeapon = oUnit:GetWeapon(1)
            if oWeapon and oWeapon.GetAimManipulator then
                return M28Utilities.ConvertRadiansToAngle(oWeapon:GetAimManipulator():GetHeadingPitch())
            else return 0
            end
        else return 0
        end
        if oUnit:IsValidBone('Turret') then
            --0% = south, 25% = east, 50% = north; want to convert from % into angle where 0 is north
            return M28Utilities.ConvertCounterclockwisePercentageToAngle(oUnit:GetBoneDirection('Turret'))
        else
            return 180 - oUnit:GetHeading() / math.pi * 180 --redundancy - for a building this is likeliy to be the same value every time
        end
    else
        --Other units (would expect to be mobile) - get the unit direction
        return 180 - oUnit:GetHeading() / math.pi * 180
    end

end

function IsUnitUnderwater(oUnit)
    if oUnit.GetPosition and oUnit.GetBlueprint then
        return M28Map.IsUnderwater({oUnit:GetPosition()[1], oUnit:GetPosition()[2] + (oUnit:GetBlueprint().SizeY or 0), oUnit:GetPosition()[3]}, false)
    else return false
    end
end

function GetUnitUniqueRef(oUnit)
    return oUnit:GetAIBrain():GetArmyIndex()..oUnit.UnitId..GetUnitLifetimeCount(oUnit)
end

function GetTransportMaxCapacity(oTransport, iTechLevelToLoad)
    --https://forums.faforever.com/viewtopic.php?f=2&t=17511#:~:text=It%20can%20carry%20exactly%201,and%20more%20T2%20than%20T3.
    local iFaction = GetUnitFaction(oTransport)
    local tiCapacityByTechAndFaction --[TransportTechLevel][FactionNumber][UnitTechToHold]
    if EntityCategoryContains(categories.UEF * categories.GROUNDATTACK * categories.TECH2 * categories.AIR, oTransport.UnitId) then
        tiCapacityByTechAndFaction = {[2]={[refFactionUEF]={[1]=1,[2]=1,[3]=0,[4]=0}}}
    else tiCapacityByTechAndFaction =
    {[1]={ --T1 transports
        [refFactionUEF]={[1]=6,[2]=2,[3]=1,[4]=0},
        [refFactionAeon]={[1]=6,[2]=3,[3]=1,[4]=0},
        [refFactionCybran]={[1]=6,[2]=2,[3]=1,[4]=0},
        [refFactionSeraphim]={[1]=8,[2]=4,[3]=1,[4]=0},
        [refFactionNomads]={[1]=4,[2]=2,[3]=0,[4]=0}, --Assumed
        [refFactionUnrecognised]={[1]=2,[2]=1,[3]=0,[4]=0}, --assumed
    },
     [2]={
         [refFactionUEF]={[1]=14,[2]=6,[3]=3,[4]=0},
         [refFactionAeon]={[1]=12,[2]=6,[3]=2,[4]=0},
         [refFactionCybran]={[1]=10,[2]=4,[3]=2,[4]=0},
         [refFactionSeraphim]={[1]=16,[2]=8,[3]=4,[4]=0},
         [refFactionNomads]={[1]=8,[2]=4,[3]=2,[4]=0}, --Assumed
         [refFactionUnrecognised]={[1]=2,[2]=1,[3]=0,[4]=0}, --assumed
     },
     [3]={
         [refFactionUEF]={[1]=28,[2]=12,[3]=6,[4]=0},
         [refFactionAeon]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionCybran]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionSeraphim]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionNomads]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionUnrecognised]={[1]=1,[2]=1,[3]=1,[4]=0},
     },
     [4]={ --dummy values
         [refFactionUEF]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionAeon]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionCybran]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionSeraphim]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionNomads]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionUnrecognised]={[1]=1,[2]=1,[3]=1,[4]=0},
     },
    }
    end

    return tiCapacityByTechAndFaction[GetUnitTechLevel(oTransport)][iFaction][iTechLevelToLoad]
end

function GetACUShieldRegenRate(oUnit)
    --Cycles through every possible enhancement, sees if the unit has it, and if so what its shield regen rate is, and returns the max value
    local iRegenRate = 0
    if oUnit.HasEnhancement then
        local oBP = oUnit:GetBlueprint()
        if M28Utilities.IsTableEmpty(oBP.Enhancements) == false then
            for sEnhancement, tEnhancement in oBP.Enhancements do
                if oUnit:HasEnhancement(sEnhancement) and tEnhancement.ShieldRegenRate then
                    iRegenRate = math.max(iRegenRate, tEnhancement.ShieldRegenRate)
                end
            end
        end
    end
    return iRegenRate
end

function GetACUHealthRegenRate(oUnit)
    --Cycles through every ACU enhancement and factors it into its health regen, along with veterancy
    local oBP = oUnit:GetBlueprint()
    local iRegenRate = (oBP.Defense.RegenRate or 0)

    --Adjust for veterancy:
    local iVetLevel = (oUnit.VetLevel or oUnit.Sync.VeteranLevel or 0)
    if iVetLevel > 0 and oBP.Buffs.Regen then
        local iCurVet = 0
        for iVet, iRegenMod in oBP.Buffs.Regen do
            iCurVet = iCurVet + 1
            if iCurVet == iVetLevel then
                iRegenRate = iRegenRate + iRegenMod
                break
            end
        end
    end

    --Adjust for enhancements
    if M28Utilities.IsTableEmpty(oBP.Enhancements) == false then
        for iEnhancement, tEnhancement in oBP.Enhancements do
            if tEnhancement.NewRegenRate and oUnit:HasEnhancement(iEnhancement) then
                iRegenRate = iRegenRate + tEnhancement.NewRegenRate
            end
        end
    end

    return iRegenRate

end

function SetUnitTargetPriorities(oUnit, tPriorityTable)
    if IsUnitValid(oUnit) then
        if EntityCategoryContains(refCategoryMAA, oUnit) then M28Utilities.ErrorHandler('Changing weapon priority for MAA') end
        for i =1, oUnit:GetWeaponCount() do
            local wep = oUnit:GetWeapon(i)
            wep:SetWeaponPriorities(tPriorityTable)
        end
    end
end

function GetLauncherAOEStrikeDamageMinAndMaxRange(oUnit)
    local oBP = oUnit:GetBlueprint()
    local iAOE = 0
    local iStrikeDamage
    local iMinRange = 0
    local iMaxRange = 0
    for sWeaponRef, tWeapon in oBP.Weapon do
        if not(tWeapon.WeaponCategory == 'Death') then
            if (tWeapon.DamageRadius or 0) > iAOE then
                iAOE = tWeapon.DamageRadius
                iStrikeDamage = tWeapon.Damage * tWeapon.MuzzleSalvoSize
                if (tWeapon.FixedSpreadRadius or 0) >= 20 then --e.g. scathis
                    iStrikeDamage = math.min(iStrikeDamage, tWeapon.Damage * math.min(3, tWeapon.MuzzleSalvoSize * 0.5))
                end
            elseif (tWeapon.NukeInnerRingRadius or 0) > iAOE then
                iAOE = tWeapon.NukeInnerRingRadius
                iStrikeDamage = tWeapon.NukeInnerRingDamage
            end
            if (tWeapon.MinRadius or 0) > iMinRange then iMinRange = tWeapon.MinRadius end
            if (tWeapon.MaxRadius or 0) > iMaxRange then iMaxRange = tWeapon.MaxRadius end
        end
    end
    return iAOE, iStrikeDamage, iMinRange, iMaxRange
end

function GetSniperStrikeDamage(oUnit)
    local iStrikeDamage
    local oBP = oUnit:GetBlueprint()
    local sWeaponTypeRequired
    if EntityCategoryContains(refCategorySniperBot * categories.SERAPHIM, oUnit.UnitId) then
        if oUnit[refbSniperRifleEnabled] and table.getn(oBP.Weapon) > 1 then sWeaponTypeRequired = 'SniperGun' end
    end

    if oBP.Weapon then
        for iWeapon, tWeapon in oBP.Weapon do
            if tWeapon.WeaponCategory == 'Direct Fire' then
                if not(sWeaponTypeRequired) or tWeapon.Label == sWeaponTypeRequired then
                    if iStrikeDamage then iStrikeDamage = math.min(iStrikeDamage, tWeapon.Damage)
                    else iStrikeDamage = tWeapon.Damage
                    end
                end
            end
        end
    end
    if not(iStrikeDamage) then iStrikeDamage = 100 end
    return iStrikeDamage
end

function EnableLongRangeSniper(oUnit)
    --If unit has a sniper weapon, then toggle it
    if oUnit.SetWeaponEnabledByLabel and not(oUnit[refbSniperRifleEnabled]) then
        local oBP = oUnit:GetBlueprint()
        local bHaveSniperWeapon = false
        if oBP.Weapon then
            for iWeapon, tWeapon in oBP.Weapon do
                if tWeapon.Label == 'SniperGun' then
                    bHaveSniperWeapon = true
                    break
                end
            end
        end

        if bHaveSniperWeapon then
            oUnit:OnScriptBitSet(1)
            oUnit[refbSniperRifleEnabled] = true
            --LOG('Enabled sniperrifle on unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit))
        end
    end
end


function DisableLongRangeSniper(oUnit)
    M28Utilities.ErrorHandler('need to update sniper bot range if disabling long range sniper, for now have a hardcoded fix') --hardcoded value is oUnit[refiDFRange] = 65
    if oUnit.SetWeaponEnabledByLabel and oUnit[refbSniperRifleEnabled] then
        local bHaveSniperWeapon = true
        local oBP = oUnit:GetBlueprint()
        if oBP.Weapon then
            for iWeapon, tWeapon in oBP.Weapon do
                if tWeapon.Label == 'SniperGun' then
                    bHaveSniperWeapon = true
                    break
                end
            end
        end
        if bHaveSniperWeapon then
            oUnit:OnScriptBitClear(1)
            oUnit[refbSniperRifleEnabled] = false
            --LOG('Disabled long range sniper on unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit))
        end
        oUnit[refiDFRange] = 65
    end
end

function GetMissileCount(oUnit)
    local iMissiles = 0 --NOTE: If this is called at the moment a missile is loaded, then this should be set to 1; only use this function for general checks
    if oUnit.GetTacticalSiloAmmoCount then iMissiles = iMissiles + oUnit:GetTacticalSiloAmmoCount() end
    if oUnit.GetNukeSiloAmmoCount then iMissiles = iMissiles + oUnit:GetNukeSiloAmmoCount() end
    return iMissiles
end

function GiveUnitTemporaryVision(oUnit, iVision)
    local Buff = import('/lua/sim/Buff.lua')
    if not Buffs['CrateVisBuff'] then
        BuffBlueprint {
            Name = 'CrateVisBuff',
            DisplayName = 'CrateVisBuff',
            BuffType = 'CrateVisBuff',
            Stacks = 'ALWAYS',
            Duration = 2,
            Affects = {
                VisionRadius = {
                    Add = iVision,
                    Mult = 1,
                },
            },
        }
    end
    Buff.ApplyBuff(oUnit, 'CrateVisBuff')
end