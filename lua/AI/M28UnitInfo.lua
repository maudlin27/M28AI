---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 01/12/2022 08:18
---

local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
--Dont include m28factory or m28engineer here or will get a crash at start of the game

--global (non-category) varaibles:
--Threat values
tUnitThreatByIDAndType = {} --Calculated at the start of the game
tiThreatRefsCalculated = {} --table of the threat ID references that have done blueprint checks on

tbBuildOnLandLayerCaps = {['Land'] = true, ['Air'] = true, ['9'] = true, ['3'] = true, ['11'] = true} --used to translate the result of UnitBlueprint.Physics.BuildOnLayerCaps which doesnt return the table shown in the blueprint but instead returns one of these values (or 'Air' - which is what a czar returns)
tbBuildOnWaterLayerCaps = {['Water'] = true, ['9'] = true, ['3'] = true, ['11'] = true, ['12'] = true}

--Factions
refFactionUEF = 1
refFactionAeon = 2
refFactionCybran = 3
refFactionSeraphim = 4
refFactionNomads = 5
refFactionUnrecognised = 6

--Transport clamp types
refClampSmall = 1
refClampMedium = 2
refClampLarge = 3
refClampExperimental = 4 --Incase ever decide to support nomads experimental transports
refClampStinger = 5

--Variables against units;
refiLastWeaponEvent = 'M28LastWep' --Gametimeseconds that last updated onweapon
reftLastKnownPositionByTeam = 'M28UnitLastPos' --[x] is the M28 team ref, returns the last known position of the unit
reftAssignedPlateauAndLandZoneByTeam = 'M28UnitPlateauAndZone' --[x] is the M28 team ref, returns a table {iPlateau, iLandZoneRef}
reftAssignedWaterZoneByTeam = 'M28UnitWaterZone' --[x] is the M28 team ref, returns the water zone assigned to the unit, if there is one
reftbConsideredForAssignmentByTeam = 'M28UnitConsideredForAssignment' --[x] is the M28 team ref, returns true if have sent at least once to be assigned to a plateau/land zone/air logic/navy logic
refiDFMassThreatOverride = 'M28BaseMassOverride' --e.g. for ACUs, will override the mass value suggested by the blueprint
refiAntiNavyMassThreatOverride = 'M28BNMTO' --e.g. for ACUs, so can differentiate between Cybran ACU with antinavy upgrade, and other ACUs
refbShieldIsDisabled = 'M28UnitShieldDisabled'
refiTimeOfLastCheck = 'M28UnitTimeOfLastCheck' --Currently used for shot is blocked (M27 also used for T3 arti adjacency, when first detected enemy SMD)
refiTimeOfLastUnblockedShot = 'M28UnitTimeLastUnblockedShot'
refbLastShotBlocked = 'M28UnitLastShotBlocked' --Used for DF units to indicate if last shot was blocked
refiTargetShotBlockedCount = 'M28UnitTrgSBlC' --Number of times a long range unit has failed to hit this (used for naval units targeting structures - change how this is increased if want to expand usage)
refiTimeOfLastOverchargeShot = 'M28UnitTimeLastOvercharge' --Gametimeseconds
reftbInArmyIndexBigThreatTable = 'M28UnitInBigThreatTable' --[x] is army index; true if have added unit to table of big threats for that army index
refbConstructionStart = 'M28UnitConStrt' --True if constructionstarted event logic has been run for this unit
reftiTimeOfLastEnhancementComplete = 'M28TLstECmpl' --table, [x] = enhancement ID, gametimeseconds that the upgrade completed
refoClosestEnemyFromLastCloseToEnemyUnitCheck = 'M28ClEnU' --If running the 'close to enemy unit' check, this will retunr the closest enemy unit before the code aborts
refbUnitIsCloaked = 'M28UnitIsCloaked' --true if have triggered the 'cloaked unit identified' logic
refiTimeCreated = 'M28UntTimCr' --Gametimeseconds (rounded down) that unit was created
refbIsCaptureTarget = 'M28UnitIsCapTrg' --true if we want to capture the unit
refbIsReclaimTarget = 'M28UnitIsReTrg' --true if have an objective to reclaim the unit
refiTimeLastDamaged = 'M28UnitTLsD' --Currently only used for shields
reftLastLocationWhenGaveTeleportOrder = 'M28UnitTLoc' --lcoation when gave a teleport order, for if want to return here
refbTooMuchPDForSnipe = 'M28UnitTooMuchPD' --true if too much PD for a telesnipe attempt
refbTriedToKill = 'M28TryKill' --true if tried to kill unit
refiHealthWhenLastChecked = 'M28HlthCh' --Unit health when last checked - used for gunships
refiHealthSecondLastCheck = 'M28HlthSLC' --Unit health in the previous check - used for gunships
refbWantToHealUp = 'M28HlUp' --true if unit wants to rely on its regen to heal up - e.g. used for soulripper
refbObjectiveUnit = 'M28ObjU' --true if unit is being used for an objective
refbCampaignTriggerAdded = 'M28Trg' --true if a trigger has been recorded against the unit (may not be an objective unit, but will want to avoid e.g. ctrl-King if M28 owns it)
refbTransferredUnit = 'M28Xfer' --true if unit has been captured/transferred from its original owner
refbIsSnipeTarget = 'M28STrg' --true if is a snipe target

    --Unit micro related
refiGameTimeMicroStarted = 'M28UnitTimeMicroStarted' --Gametimeseconds that started special micro
refbSpecialMicroActive = 'M28UnitSpecialMicroActive'
refiGameTimeToResetMicroActive = 'M28UnitTimeToResetMicro' --Gametimeseconds
refbWeaponDisabled = 'M28UnitWeaponDisabled' --True if unit weapon has been disabled by M28 code
refiTimeLastDisabledWeapon = 'M28UnitTimeDsblW' --Gametimeseconds that we wanted the unit's weapon to be disabled

    --Ranges and weapon details
refiDFRange = 'M28UDFR' --(fatboy df range gets treated as range of its indirect cannons)
refiDFMinRange = 'M28DFMinRng' --Min range of a unit
refiDFAOE = 'M28AOEDF' --aoe of a df weapon of a unit
refiIndirectAOE = 'M28AOEIn' --aoe of an indirect weapon of a unit; includes manual ranges
refiIndirectRange = 'M28UIR' --for non-manual fire weapons
refiArtiMinRange = 'M28AtMR' --Only populated when used, e.g. used by T2 arti as part of t2 arti manual targeting logic
refiAntiNavyRange = 'M28UANR'
refiCombatRange = 'M28UCRN' --Higher of antinavy, indirectrange and dfrange for a unit
refiManualRange = 'M28UManR' --for manual fire weapons (e.g. TML)
refiMissileDefenceRange = 'M28UMDefR' --For SMD and TMD
refiAARange = 'M28UAAR'
refiBomberRange = 'M28UBR'
refbWeaponUnpacks = 'M28WUP'
refbHasTorpedoDefence = 'M28TDef' --true if unit has torpedo defence
refiStrikeDamage = 'M28USD'
refbCanKite = 'M28CanKite' --true unless weapon unpacks or experimental with a weapon fixed to body (GC and megalith)
refiTimeBetweenDFShots = 'M28DFTime'
refiTimeBetweenIFShots = 'M28IFTime'

refbSniperRifleEnabled = 'M28UnitSniperRifleEnabled' --True if seraphim sniperbot has its long range sniperrifle enabled

--Weapon priorities
refWeaponPriorityGunship = {'STRUCTURE EXPERIMENTAL, STRUCTURE ARTILLERY TECH3, ARTILLERY EXPERIMENTAL', 'MOBILE SHIELD', 'MOBILE ANTIAIR CRUISER', 'MOBILE ANTIAIR', 'ANTIAIR', 'STRUCTURE SHIELD', 'VOLATILE STRUCTURE', 'MASSEXTRACTION', 'VOLATILE MOBILE', 'COMMAND', 'GROUNDATTACK', 'TECH3 MOBILE', 'TECH2 MOBILE', 'TECH1 MOBILE', 'ALLUNITS'}
refWeaponPriorityGunshipShield = {'STRUCTURE EXPERIMENTAL, STRUCTURE ARTILLERY TECH3, ARTILLERY EXPERIMENTAL', 'STRUCTURE SHIELD', 'MOBILE SHIELD', 'MOBILE ANTIAIR CRUISER', 'MOBILE ANTIAIR', 'ANTIAIR', 'VOLATILE STRUCTURE', 'MASSEXTRACTION', 'VOLATILE MOBILE', 'COMMAND', 'GROUNDATTACK', 'TECH3 MOBILE', 'TECH2 MOBILE', 'TECH1 MOBILE', 'ALLUNITS'}
refWeaponPriorityGunshipSnipe = {'STRUCTURE EXPERIMENTAL, STRUCTURE ARTILLERY TECH3, ARTILLERY EXPERIMENTAL, COMMAND', 'STRUCTURE SHIELD', 'MOBILE SHIELD', 'MOBILE ANTIAIR CRUISER', 'MOBILE ANTIAIR', 'ANTIAIR', 'VOLATILE STRUCTURE', 'MASSEXTRACTION', 'VOLATILE MOBILE', 'GROUNDATTACK', 'TECH3 MOBILE', 'TECH2 MOBILE', 'TECH1 MOBILE', 'ALLUNITS'}
refWeaponPriorityDestroyer = {'SHIELD NAVAL', 'SUBMERSIBLE', 'EXPERIMENTAL NAVAL, TECH3 NAVAL MOBILE', 'TECH2 NAVAL MOBILE', 'STRUCTURE SHIELD', 'STRUCTURE DEFENSE DIRECTFIRE TECH2, STRUCTURE DEFENSE DIRECTFIRE TECH3, STRUCTURE INDIRECTFIRE ARTILLERY', 'EXPERIMENTAL STRUCTURE, STRUCTURE TECH3 SILO, STRUCTURE TECH3 VOLATILE', 'MOBILE LAND EXPERIMENTAL, MOBILE LAND HOVER DIRECTFIRE', 'MASSPRODUCTION TECH2, MASSPRODUCTION TECH3', 'MOBILE LAND TECH3 DIRECTFIRE, MOBILE LAND TECH3 INDIRECTFIRE', 'EXPERIMENTAL', 'NAVAL', 'STRUCTURE', 'ALLUNITS'}
refWeaponPriorityBattleShip = {'EXPERIMENTAL NAVAL, TECH3 NAVAL', 'TECH2 NAVAL', 'STRUCTURE SHIELD', 'STRUCTURE INDIRECTFIRE ARTILLERY', 'EXPERIMENTAL STRUCTURE, STRUCTURE TECH3 SILO, STRUCTURE TECH3 VOLATILE', 'MOBILE LAND EXPERIMENTAL, MOBILE LAND TECH3 DIRECTFIRE, MOBILE LAND TECH3 INDIRECTFIRE', 'EXPERIMENTAL', 'NAVAL', 'STRUCTURE', 'ALLUNITS'}
refWeaponPriorityMissileShip = {'SHIELD STRUCTURE, ANTIMISSILE STRUCTURE', 'STRUCTURE INDIRECTFIRE ARTILLERY TECH2', 'EXPERIMENTAL STRUCTURE, STRUCTURE ARTILLERY TECH3, STRUCTURE TECH3 SILO', 'STRUCTURE TECH3 VOLATILE', 'STRUCTURE TECH3 ECONOMIC', 'STRUCTURE NAVAL TECH3, STRUCTURE NAVAL TECH2', 'STRUCTURE TECH3', 'STRUCTURE TECH2 ECONOMIC', 'STRUCTURE TECH2', 'STRUCTURE VOLATILE, STRUCTURE DEFENSE, STRUCTURE FACTORY, STRUCTURE INTELLIGENCE', 'STRUCTURE', 'NAVAL SHIELD', 'SHIELD', 'EXPERIMENTAL NAVAL', 'EXPERIMENTAL', 'TECH3 NAVAL', 'TECH2 NAVAL', 'INDIRECTFIRE NAVAL', 'TECH3', 'TECH2', 'ALLUNITS'}
refWeaponPriorityTeleSnipeInclACU = {'COMMAND', 'STRUCTURE EXPERIMENTAL, STRUCTURE ARTILLERY TECH3, ARTILLERY EXPERIMENTAL', 'STRUCTURE DEFENSE DIRECTFIRE TECH1', 'STRUCTURE DEFENSE DIRECTFIRE', 'STRUCTURE TECH3 ENERGYPRODUCTION, STRUCTURE TECH3 MASSFABRICATION', 'STRUCTURE TECH3 MASSEXTRACTION', 'ALLUNITS'}
refWeaponPriorityTeleSnipeExclACU = {'STRUCTURE EXPERIMENTAL, STRUCTURE ARTILLERY TECH3, ARTILLERY EXPERIMENTAL', 'COMMAND', 'STRUCTURE DEFENSE DIRECTFIRE TECH1', 'STRUCTURE DEFENSE DIRECTFIRE', 'STRUCTURE TECH3 ENERGYPRODUCTION, STRUCTURE TECH3 MASSFABRICATION', 'STRUCTURE TECH3 MASSEXTRACTION', 'ALLUNITS'}
refWeaponPriorityT2Arti = {'ARTILLERY EXPERIMENTAL', 'ARTILLERY STRUCTURE, SNIPER', 'SHIELD STRUCTURE', 'CRUISER, ANTISHIELD', 'INDIRECTFIRE', 'SHIELD', 'VOLATILE', 'TECH3 STRUCTURE', 'TECH3 MOBILE', 'ALLUNITS'}
refWeaponPriorityFatboy = {'ARTILLERY EXPERIMENTAL', 'STRUCTURE EXPERIMENTAL, STRUCTURE ARTILLERY TECH3, ARTILLERY EXPERIMENTAL', 'ARTILLERY STRUCTURE, SNIPER', 'SHIELD STRUCTURE', 'EXPERIMENTAL', 'MOBILE SHIELD, MOBILE ARTILLERY TECH3', 'MOBILE NAVAL TECH3, MOBILE NAVAL TECH2', 'MOBILE DIRECTFIRE TECH3', 'MOBILE ANTIAIR TECH3', 'VOLATILE', 'TECH3', 'TECH2', 'ALLUNITS'}
refWeaponPriorityMegalith = {'ARTILLERY EXPERIMENTAL', 'STRUCTURE EXPERIMENTAL, STRUCTURE ARTILLERY TECH3, ARTILLERY EXPERIMENTAL', 'ARTILLERY STRUCTURE, SNIPER', 'SHIELD STRUCTURE', 'EXPERIMENTAL', 'TECH3 STRUCTURE DEFENSE DIRECTFIRE', 'MOBILE SHIELD', 'MOBILE DIRECTFIRE TECH3', 'MOBILE ANTIAIR TECH3', 'VOLATILE', 'TECH3', 'TECH2', 'ALLUNITS'}
refbUsingDefaultWeaponPriority = 'M28UDfW' --true if using default weapon priroity (for unit with multiple options - e.g. gunships)

refbPaused = 'M28UnitPaused' --true if unit is paused
reftoUnitsAssistingThis = 'M28UnitsAssisting' --table of units given an order to guard this unit

--Categories:
--Buildings - eco
refCategoryMex = categories.STRUCTURE * categories.MASSEXTRACTION - categories.NAVAL --Some mods add a naval mex which causes issues as we will try and build on land mexes without naval exclusion
refCategoryT1Mex = refCategoryMex * categories.TECH1
refCategoryT2Mex = refCategoryMex * categories.TECH2
refCategoryT3Mex = refCategoryMex * categories.TECH3
refCategoryHydro = categories.HYDROCARBON - categories.NAVAL
refCategoryResourceUnit = categories.MASSPRODUCTION + categories.MASSFABRICATION + categories.ENERGYPRODUCTION --i.e. includes SACU

refCategoryPower = categories.STRUCTURE * categories.ENERGYPRODUCTION - categories.EXPERIMENTAL - categories.HYDROCARBON
refCategoryT1Power = categories.STRUCTURE * categories.ENERGYPRODUCTION * categories.TECH1 - categories.EXPERIMENTAL - categories.HYDROCARBON
refCategoryT2Power = categories.STRUCTURE * categories.ENERGYPRODUCTION * categories.TECH2 - categories.EXPERIMENTAL - categories.HYDROCARBON
refCategoryT3Power = categories.STRUCTURE * categories.ENERGYPRODUCTION * categories.TECH3 - categories.EXPERIMENTAL - categories.HYDROCARBON
refCategoryMassStorage = categories.STRUCTURE * categories.MASSSTORAGE * categories.TECH1

refCategoryEnergyStorage = categories.STRUCTURE * categories.ENERGYSTORAGE
refCategoryParagon = categories.STRUCTURE * categories.EXPERIMENTAL * categories.MASSPRODUCTION * categories.MASSFABRICATION
refCategoryMassFab = categories.MASSFABRICATION * categories.STRUCTURE - categories.MASSEXTRACTION - categories.EXPERIMENTAL

--Building - intel and misc
refCategoryAirStaging = categories.STRUCTURE * categories.AIRSTAGINGPLATFORM
refCategoryRadar = categories.STRUCTURE * categories.RADAR + categories.STRUCTURE * categories.OMNI
refCategoryT1Radar = refCategoryRadar * categories.TECH1
refCategoryT2Radar = refCategoryRadar * categories.TECH2
refCategoryT3Radar = categories.TECH3 * categories.STRUCTURE * categories.OMNI -categories.FACTORY --+ categories.OMNI * categories.TECH3 (dont need this as refcategoryradar already includes omni)
refCategorySonar = categories.STRUCTURE * categories.SONAR + categories.MOBILESONAR
refCategoryT1Sonar = refCategorySonar * categories.TECH1
refCategoryT2Sonar = refCategorySonar * categories.TECH2
refCategoryT3Sonar = refCategorySonar * categories.TECH3
refCategoryStructure = categories.STRUCTURE - categories.WALL - categories.EXTERNALFACTORYUNIT
refCategoryWall = categories.STRUCTURE * categories.WALL --NOTE: Some walls are props; this is for if want a wall that can build
refCategoryUnitsWithOmni = categories.OMNI + categories.COMMAND + categories.OVERLAYOMNI


--Building - factory
refCategoryLandFactory = categories.LAND * categories.FACTORY * categories.STRUCTURE - categories.EXTERNALFACTORYUNIT
refCategoryLandHQ =refCategoryLandFactory - categories.SUPPORTFACTORY
refCategoryAirFactory = categories.AIR * categories.FACTORY * categories.STRUCTURE - categories.ORBITALSYSTEM - categories.EXTERNALFACTORYUNIT --Novax is an air factory, so excluded from being treated as an air factory by my logic
refCategoryAirHQ = refCategoryAirFactory - categories.SUPPORTFACTORY
refCategoryNavalFactory = categories.NAVAL * categories.FACTORY * categories.STRUCTURE - categories.EXTERNALFACTORYUNIT
refCategoryNavalHQ = refCategoryNavalFactory - categories.SUPPORTFACTORY
refCategoryMobileLandFactory = categories.LAND * categories.FACTORY * categories.STRUCTURE * categories.EXTERNALFACTORYUNIT
refCategorySpecialFactory = categories.FACTORY * categories.EXPERIMENTAL * categories.STRUCTURE - categories.EXTERNALFACTORYUNIT --e.g. novax centre (that can build novax)
refCategoryFactory = refCategoryLandFactory + refCategoryAirFactory + refCategoryNavalFactory
refCategoryAllHQFactories = refCategoryFactory - categories.SUPPORTFACTORY
refCategoryQuantumGateway = categories.STRUCTURE * categories.GATE * categories.TECH3 * categories.FACTORY - categories.EXTERNALFACTORYUNIT

--Building - defensive
refCategoryT2PlusPD = categories.STRUCTURE * categories.DIRECTFIRE - categories.STRUCTURE * categories.DIRECTFIRE * categories.TECH1
refCategoryPD = categories.STRUCTURE * categories.DIRECTFIRE
refCategoryT3PD = refCategoryPD * categories.TECH3
refCategoryTMD = categories.STRUCTURE * categories.ANTIMISSILE - categories.SILO * categories.TECH3 --Not perfect but should pick up most TMD without picking up SMD
refCategoryFixedShield = categories.SHIELD * categories.STRUCTURE
refCategoryFixedT2Arti = categories.STRUCTURE * categories.INDIRECTFIRE * categories.ARTILLERY * categories.TECH2
refCategoryFixedT3Arti = categories.STRUCTURE * categories.INDIRECTFIRE * categories.ARTILLERY * categories.TECH3
refCategoryExperimentalArti = categories.EXPERIMENTAL * categories.ARTILLERY - categories.MOBILE * categories.UEF
refCategorySML = categories.NUKE * categories.SILO
refCategorySMD = categories.ANTIMISSILE * categories.SILO * categories.TECH3 * categories.STRUCTURE
refCategoryTML = categories.SILO * categories.STRUCTURE * categories.TECH2 - categories.ANTIMISSILE
refCategoryUnitsWithTMLUpgrade = categories.COMMAND * categories.UEF + categories.COMMAND * categories.SERAPHIM + categories.SUBCOMMANDER * categories.SERAPHIM
refCategoryNovaxCentre = categories.EXPERIMENTAL * categories.STRUCTURE * categories.ORBITALSYSTEM - categories.OPTICS --OPTICS is contained in a 'spy plane novax' building in brewlan
refCategorySatellite = categories.EXPERIMENTAL * categories.SATELLITE + categories.SATELLITE * categories.TECH1 * categories.AEON * categories.STRATEGIC --latter categories are for the blackops artemis satellite unit
--refCategorySAM = categories.ANTIAIR * categories.STRUCTURE * categories.TECH3
refCategoryQuantumOptics = categories.INTELLIGENCE * categories.OPTICS * categories.AEON * categories.STRUCTURE * categories.TECH3 - refCategoryRadar

refCategoryUpgraded = refCategoryT2Radar + refCategoryT3Radar + refCategoryT2Sonar + refCategoryT3Sonar + refCategoryFactory * categories.TECH2 + refCategoryFactory * categories.TECH3 + refCategoryFixedShield * categories.TECH3 + refCategoryT2Mex + refCategoryT3Mex

--Land units
refCategoryScathis = categories.CYBRAN * categories.ARTILLERY * categories.EXPERIMENTAL
refCategoryExperimentalStructure = refCategoryScathis + categories.STRUCTURE * categories.EXPERIMENTAL -categories.OPTICS
refCategoryLandExperimental = categories.EXPERIMENTAL * categories.MOBILE * categories.LAND - categories.CYBRAN * categories.ARTILLERY - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryMonkeylord = refCategoryLandExperimental * categories.BOT * categories.DIRECTFIRE - categories.SNIPER
refCategoryMegalith = refCategoryLandExperimental * categories.BOT * categories.DIRECTFIRE * categories.SNIPER
refCategoryMobileLand = categories.LAND * categories.MOBILE  - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryEngineer = categories.LAND * categories.MOBILE * categories.ENGINEER - categories.COMMAND - categories.FIELDENGINEER -categories.SUBCOMMANDER --Dont include sparkys as they cant build a lot of things, so just treat them as a combat unit that can reclaim
refCategoryRASSACU = categories.SUBCOMMANDER * categories.RASPRESET + categories.SUBCOMMANDER * categories.SERAPHIM
refCategoryRover = categories.POD * categories.ENGINEER * categories.MOBILE - categories.CONSTRUCTION -refCategoryEngineer
refCategoryHive = categories.STRUCTURE * categories.STATIONASSISTPOD * categories.ENGINEERSTATION
refCategoryKennel = categories.STRUCTURE * categories.ENGINEERSTATION * categories.PODSTAGINGPLATFORM
refCategoryEngineerStation = refCategoryRover + refCategoryHive + refCategoryKennel

refCategoryMAA = categories.LAND * categories.MOBILE * categories.ANTIAIR - categories.EXPERIMENTAL
refCategoryAttackBot = categories.LAND * categories.MOBILE * categories.DIRECTFIRE * categories.BOT + categories.LAND * categories.MOBILE * categories.TANK * categories.TECH1 * categories.SERAPHIM - refCategoryMAA -categories.REPAIR --(repair exclusion added as basic way to differentiate between mantis (which has repair category) and LAB; alternative way is to specify the fastest when choosing the blueprint to build
refCategoryDFTank = categories.LAND * categories.MOBILE * categories.DIRECTFIRE - categories.SCOUT - refCategoryMAA - categories.UNSELECTABLE - categories.UNTARGETABLE --NOTE: Need to specify slowest (so dont pick LAB)
refCategoryLandScout = categories.LAND * categories.MOBILE * categories.SCOUT
refCategoryCombatScout = categories.SERAPHIM * categories.SCOUT * categories.DIRECTFIRE
refCategoryIndirect = categories.LAND * categories.MOBILE * categories.INDIRECTFIRE - categories.DIRECTFIRE - refCategoryLandExperimental - refCategoryScathis - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryT3MobileArtillery = categories.ARTILLERY * categories.LAND * categories.MOBILE * categories.TECH3 - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryMML = categories.SILO * categories.MOBILE * categories.LAND - categories.UNSELECTABLE - categories.UNTARGETABLE - categories.NUKE
refCategoryT3MML = categories.SILO * categories.MOBILE * categories.TECH3 * categories.LAND - categories.UNSELECTABLE - categories.UNTARGETABLE - categories.NUKE
refCategoryFatboy = categories.EXPERIMENTAL * categories.UEF * categories.MOBILE * categories.LAND * categories.ARTILLERY - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryLandCombat = categories.MOBILE * categories.LAND * categories.DIRECTFIRE + categories.MOBILE * categories.LAND * categories.INDIRECTFIRE * categories.TECH1 + categories.FIELDENGINEER + refCategoryFatboy + categories.SUBCOMMANDER - refCategoryEngineer -refCategoryLandScout -refCategoryMAA - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryAmphibiousCombat = refCategoryLandCombat * categories.HOVER + refCategoryLandCombat * categories.AMPHIBIOUS - categories.ANTISHIELD * categories.AEON --Dont include aeon T3 anti-shield here as it sucks unless against shields
refCategorySurfaceAmphibiousCombat = refCategoryLandCombat * categories.HOVER + categories.ANTINAVY * categories.LAND * categories.MOBILE - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryGroundAA = refCategoryMAA + categories.NAVAL * categories.ANTIAIR + categories.STRUCTURE * categories.ANTIAIR + categories.NAVALCARRIER * categories.EXPERIMENTAL
refCategoryStructureAA = categories.STRUCTURE * categories.ANTIAIR
refCategoryIndirectT2Plus = categories.MOBILE * categories.LAND * categories.INDIRECTFIRE - categories.MOBILE * categories.LAND * categories.INDIRECTFIRE * categories.TECH1 - categories.DIRECTFIRE
refCategoryIndirectT2Below = categories.MOBILE * categories.INDIRECTFIRE * categories.LAND * categories.TECH1 + categories.MOBILE * categories.INDIRECTFIRE * categories.LAND * categories.TECH2
refCategoryIndirectT3 = categories.MOBILE * categories.LAND * categories.INDIRECTFIRE * categories.TECH3 - categories.DIRECTFIRE
--Obsidian special case with shields due to inconsistent categories:
refCategoryObsidian = categories.AEON * categories.TECH2 * categories.SHIELD * categories.DIRECTFIRE * categories.MOBILE * categories.LAND * categories.TANK --
refCategoryMobileLandShield = categories.LAND * categories.MOBILE * categories.SHIELD - refCategoryObsidian -categories.EXPERIMENTAL  --Miscategorised obsidian tank
refCategoryPersonalShield = categories.PERSONALSHIELD + refCategoryObsidian
refCategoryMobileLandStealth = categories.LAND * categories.MOBILE * categories.STEALTHFIELD - categories.EXPERIMENTAL --dont want monkeylords treated as a mobile stealth unit!
refCategorySniperBot = categories.MOBILE * categories.SNIPER * categories.LAND
refCategorySkirmisher = refCategorySniperBot * categories.TECH3 + refCategoryDFTank * categories.UEF * categories.TECH2 * categories.BOT + refCategoryDFTank * categories.CYBRAN * categories.TECH2 * categories.BOT - categories.BOMB --Mongoose, Hoplite, sniperbot
refCategoryShieldDisruptor = categories.LAND * categories.MOBILE * categories.ANTISHIELD


--Air units
refCategoryAirScout = categories.AIR * categories.SCOUT
refCategoryAirAA = categories.AIR * categories.ANTIAIR - categories.BOMBER - categories.GROUNDATTACK - categories.EXPERIMENTAL
refCategoryBomber = categories.AIR * categories.BOMBER - categories.ANTINAVY - categories.CANNOTUSEAIRSTAGING --excludes mercies
refCategoryFighterBomber = categories.AIR * categories.ANTIAIR * categories.BOMBER - categories.EXPERIMENTAL
refCategoryCzar = categories.AIR * categories.EXPERIMENTAL * categories.ANTIAIR * categories.AEON
refCategoryGunship = categories.AIR * categories.GROUNDATTACK + categories.TARGETCHASER - refCategoryCzar --Targetchaser only used by czar, but some unit mods have it for units that dont have groundattack catgory (e.g. extreme wars)
refCategoryTorpBomber = categories.AIR * categories.BOMBER * categories.ANTINAVY + (categories.AIR * categories.ANTINAVY - categories.EXPERIMENTAL)
refCategoryAllAir = categories.MOBILE * categories.AIR - categories.UNTARGETABLE --Excludes novax
refCategoryAllNonExpAir = categories.MOBILE * categories.AIR * categories.TECH1 + categories.MOBILE * categories.AIR * categories.TECH2 + categories.MOBILE * categories.AIR * categories.TECH3
refCategoryAirNonScout = refCategoryAllAir - categories.SCOUT
refCategoryMercy = categories.HIGHPRIAIR * categories.AEON * categories.BOMBER * categories.TECH2
refCategoryTransport = categories.AIR * categories.TRANSPORTATION - categories.UEF * categories.GROUNDATTACK - refCategoryTorpBomber
refCategoryRestorer = refCategoryGunship * categories.ANTIAIR
refCategoryAirToGround = refCategoryBomber + refCategoryGunship + refCategoryCzar + refCategoryMercy --i.e. excludes torp bombers

--Naval units
refCategoryFrigate = categories.NAVAL * categories.FRIGATE
refCategoryTorpedoLauncher = categories.ANTINAVY * categories.STRUCTURE
refCategoryNavalSurface = categories.NAVAL + refCategoryTorpedoLauncher - categories.SUBMERSIBLE - categories.UNSELECTABLE - categories.UNTARGETABLE --NOTE: This includes structures (e.g. torp launcher and factory)
refCategoryMobileNavalSurface = refCategoryNavalSurface * categories.MOBILE
refCategoryAllNavy = categories.NAVAL + refCategoryTorpedoLauncher - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryNavalAA = refCategoryAllNavy * categories.ANTIAIR
refCategoryCruiser = categories.NAVAL * categories.CRUISER
refCategorySalem = categories.NAVAL * categories.AMPHIBIOUS * categories.DIRECTFIRE
refCategorySeraphimDestroyer = categories.SUBMERSIBLE * categories.DESTROYER
refCategoryDestroyer = categories.DESTROYER
refCategoryCarrier = categories.NAVAL * categories.NAVALCARRIER * categories.EXTERNALFACTORY
refCategoryMobileAircraftFactory = categories.AIR * categories.EXTERNALFACTORYUNIT + categories.NAVALCARRIER * categories.EXTERNALFACTORYUNIT
refCategoryCruiserCarrier = refCategoryCruiser + categories.NAVAL * categories.NAVALCARRIER
refCategorySupportNavy = refCategoryCruiserCarrier + categories.SHIELD * categories.HOVER + categories.SHIELD * categories.NAVAL + categories.STEALTHFIELD * categories.HOVER + categories.STEALTHFIELD * categories.NAVAL --Intended for units we dont want on frontline unless in bombardment mode
refCategoryAllAmphibiousAndNavy = categories.NAVAL + categories.AMPHIBIOUS + categories.HOVER + refCategoryTMD + refCategoryTorpedoLauncher + refCategorySonar + refCategoryStructureAA --NOTE: Structures have no category indicating whether they can be built on sea (instead they have aquatic ability) hence the need to include all structures
refCategoryPondFixedCategory = refCategoryNavalSurface - categories.AMPHIBIOUS * categories.MOBILE + refCategoryTMD + refCategoryTorpedoLauncher + refCategorySonar + refCategoryStructureAA
refCategoryNavyThatCanBeTorpedoed = categories.NAVAL + categories.AMPHIBIOUS + categories.STRUCTURE + categories.COMMAND + refCategoryEngineer - categories.HOVER --NOTE: Structures have no category indicating whether they can be built on sea (instead they have aquatic ability) hence the need to include all structures; Hover units cant be targeted
refCategoryTorpedoLandAndNavy = categories.ANTINAVY * categories.LAND + categories.ANTINAVY * categories.NAVAL + categories.OVERLAYANTINAVY * categories.LAND + categories.ANTINAVY * categories.STRUCTURE --If removing overlayantinavy then think up better solution for fatboy/experimentals so they dont run when in water
refCategoryMissileShip = categories.NAVAL * categories.SILO + categories.BATTLESHIP * categories.INDIRECTFIRE - categories.BATTLESHIP * categories.SERAPHIM + categories.SERAPHIM * categories.CRUISER * categories.INDIRECTFIRE + categories.SERAPHIM * categories.CARRIER * categories.OVERLAYINDIRECTFIRE * categories.TECH3  --i.e. UEF+Sera cruisers, and nukesubs
refCategorySubmarine = categories.NAVAL * categories.SUBMERSIBLE * categories.ANTINAVY
refCategoryCooper = categories.NAVAL * categories.ANTINAVY * categories.TECH2 - categories.SUBMERSIBLE - categories.DESTROYER
refCategoryShieldBoat = categories.NAVAL * categories.SHIELD + categories.HOVER * categories.SHIELD --Includes mobile land shields that can hover
refCategoryStealthBoat = categories.NAVAL * categories.STEALTHFIELD
refCategoryBattlecruiser = categories.BATTLESHIP * categories.PRODUCTFA * categories.UEF
refCategoryBattleship = categories.BATTLESHIP - refCategoryBattlecruiser - refCategoryMissileShip
refCategoryBombardment = refCategoryFrigate + refCategoryMissileShip + refCategoryCruiserCarrier * categories.SILO + refCategoryDestroyer + refCategoryBattlecruiser + refCategoryBattleship


--Multi-category:
--Antinavy mobile units (can include land units - e.g for land factories to build antisub units)
refCategoryAntiNavy = categories.ANTINAVY * categories.STRUCTURE + categories.ANTINAVY * categories.MOBILE - categories.DESTROYER * categories.UEF --for some reason get error message if just use antinavy, so need to be more restrictive
--Dangerous to land units, e.g. engieners look for these when deciding reclaim area
refCategoryDangerousToLand = refCategoryLandCombat + refCategoryIndirect + refCategoryAllNavy + refCategoryBomber + refCategoryGunship + refCategoryPD + refCategoryFixedT2Arti
refCategoryAllNonAirScoutUnits = categories.MOBILE + refCategoryStructure + refCategoryAirNonScout
refCategoryStealthGenerator = categories.STEALTHFIELD
refCategoryStealthAndCloakPersonal = categories.STEALTH
refCategoryProtectFromTML = refCategoryStructure * categories.TECH2 + refCategoryStructure * categories.TECH3 + refCategoryExperimentalStructure - categories.FACTORY --Previously was: refCategoryT2Mex + refCategoryT3Mex + refCategoryT2Power + refCategoryT3Power + refCategoryFixedT2Arti
refCategoryExperimentalLevel = categories.EXPERIMENTAL + refCategoryFixedT3Arti + refCategorySML - categories.OPTICS
refCategoryGameEnder = refCategoryExperimentalArti + categories.EXPERIMENTAL * categories.STRUCTURE * categories.SILO + refCategoryParagon
refCategoryBigThreatCategories = refCategoryExperimentalLevel + refCategoryMissileShip + refCategorySMD + refCategoryNavalSurface * categories.BATTLESHIP --Note - this is different to M27 which only considers land experimentals as big threat categories
refCategoryFirebaseSuitable = refCategoryPD + refCategoryT1Radar + refCategoryT2Radar + refCategorySMD + refCategoryTMD + refCategoryFixedShield + refCategoryFixedT2Arti + refCategoryStructureAA
refCategoryLongRangeDFLand = refCategoryFatboy + refCategorySniperBot + refCategoryShieldDisruptor
refCategoryLongRangeMobile = refCategoryLongRangeDFLand + refCategoryNavalSurface * categories.DIRECTFIRE + refCategoryNavalSurface * categories.INDIRECTFIRE - refCategoryNavalSurface * categories.TECH1 + refCategoryIndirectT2Plus
refCategoryShortRangeMobile = refCategoryLandCombat + refCategoryFrigate - refCategoryLongRangeMobile
refCategoryReclaimable = categories.RECLAIMABLE - refCategoryAllAir

function GetUnitLifetimeCount(oUnit)
--Returns what unique (for the unit's aiBrain) count the unit has, i.e. based on the number of previous units with the same blueprint ID
--NOTE: If want a unique value for a unit (since this value is only unique to a brain) then do oUnit.EntityId instead
    local iCount = oUnit.M28LifetimeUnitCount

    if iCount == nil then
        if oUnit.GetAIBrain and oUnit.GetUnitId then
            local aiBrain = oUnit:GetAIBrain()
            local sUnitId = oUnit.UnitId
            if aiBrain.M28LifetimeUnitCount == nil then aiBrain.M28LifetimeUnitCount = {} end
            if aiBrain.M28LifetimeUnitCount[sUnitId] == nil then
                aiBrain.M28LifetimeUnitCount[sUnitId] = 1
            else aiBrain.M28LifetimeUnitCount[sUnitId] = aiBrain.M28LifetimeUnitCount[sUnitId] + 1 end
            iCount = aiBrain.M28LifetimeUnitCount[sUnitId]
            oUnit.M28LifetimeUnitCount = iCount
        else
            iCount = 'nil'
        end
    end
    return iCount
end

function IsUnitValid(oUnit)
    --Returns true if unit is constructed and not dead
    if oUnit and oUnit.UnitId and not(oUnit.Dead) and oUnit.GetAIBrain then
        return true
    end
    return false
end

function GetUnitPathingType(oUnit)
    --Returns Land, Amphibious, Air or Water or None
    --if oUnit and not(oUnit.Dead) and oUnit.GetBlueprint then
    local mType = __blueprints[oUnit.UnitId].Physics.MotionType
    if (mType == 'RULEUMT_AmphibiousFloating' or mType == 'RULEUMT_Hover' or mType == 'RULEUMT_Amphibious') then
        return M28Map.refPathingTypeHover
    elseif (mType == 'RULEUMT_Water' or mType == 'RULEUMT_SurfacingSub') then
        return M28Map.refPathingTypeNavy
    elseif mType == 'RULEUMT_Air' then
        return M28Map.refPathingTypeAir
    elseif (mType == 'RULEUMT_Biped' or mType == 'RULEUMT_Land') then
        return M28Map.refPathingTypeLand
    else return M28Map.refPathingTypeNone
    end
end

function GetBlueprintFromID(sBlueprintID)
    --returns blueprint based on the blueprintID
    return __blueprints[string.lower(sBlueprintID)]
end

function GetBuildingSizeTable(sBlueprintID)
    --Returns table with X and Z size of sBlueprintID
    local tSizeXZ = {}
    local oBlueprint = GetBlueprintFromID(sBlueprintID)
    tSizeXZ[1] = oBlueprint.Physics.SkirtSizeX
    tSizeXZ[2] = oBlueprint.Physics.SkirtSizeZ
    return tSizeXZ
end

function GetBuildingSize(sBlueprintID)
    --Similar to GetBuildingSizeTable but returns a single value for the highest size
    local oBlueprint = GetBlueprintFromID(sBlueprintID)
    return math.max(oBlueprint.Physics.SkirtSizeX, oBlueprint.Physics.SkirtSizeZ)
end

function GetUnitState(oUnit)
    --Returns a string containing oUnit's unit state. Returns '' if no unit state.
    local sUnitState = ''
    local sAllUnitStates = {'Immobile',
                            'Moving',
                            'Attacking',
                            'Guarding',
                            'Building',
                            'Upgrading',
                            'WaitingForTransport',
                            'TransportLoading',
                            'TransportUnloading',
                            'MovingDown',
                            'MovingUp',
                            'Patrolling',
                            'Busy',
                            'Attached',
                            'BeingReclaimed',
                            'Repairing',
                            'Diving',
                            'Surfacing',
                            'Teleporting',
                            'Ferrying',
                            'WaitForFerry',
                            'AssistMoving',
                            'PathFinding',
                            'ProblemGettingToGoal',
                            'NeedToTerminateTask',
                            'Capturing',
                            'BeingCaptured',
                            'Reclaiming',
                            'AssistingCommander',
                            'Refueling',
                            'GuardBusy',
                            'ForceSpeedThrough',
                            'UnSelectable',
                            'DoNotTarget',
                            'LandingOnPlatform',
                            'CannotFindPlaceToLand',
                            'BeingUpgraded',
                            'Enhancing',
                            'BeingBuilt',
                            'NoReclaim',
                            'NoCost',
                            'BlockCommandQueue',
                            'MakingAttackRun',
                            'HoldingPattern',
                            'SiloBuildingAmmo' }
    for _, sState in sAllUnitStates do
        if oUnit:IsUnitState(sState) == true then
            sUnitState = sState
            break
        end
    end
    return sUnitState
end

function GetUnitTechLevel(oUnit)
    local sUnitId = oUnit.UnitId
    local iTechLevel = 1
    if EntityCategoryContains(categories.TECH1, sUnitId) then iTechLevel = 1
    elseif EntityCategoryContains(categories.TECH2, sUnitId) then iTechLevel = 2
    elseif EntityCategoryContains(categories.TECH3, sUnitId) then iTechLevel = 3
    elseif EntityCategoryContains(categories.EXPERIMENTAL, sUnitId) then iTechLevel = 4
    end
    return iTechLevel
end

function GetBlueprintTechLevel(sUnitId)
    local iTechLevel = 1
    if EntityCategoryContains(categories.TECH1, sUnitId) then iTechLevel = 1
    elseif EntityCategoryContains(categories.TECH2, sUnitId) then iTechLevel = 2
    elseif EntityCategoryContains(categories.TECH3, sUnitId) then iTechLevel = 3
    elseif EntityCategoryContains(categories.EXPERIMENTAL, sUnitId) then iTechLevel = 4
    end
    return iTechLevel
end

function GetUpgradeCombatWeighting(sEnhancementRef)
    --Returns the combat mass mod to apply to an enhancement
    --Obtain using aiBrain:GetFactionIndex()

    local iMinor = 0.4
    local iMajor = 1
    local iDeadly = 2
    local iNone = 0
    local iUnknown = 1

    local tEnhancementsCombatMod = {
            --UEF:
            AdvancedEngineering = iMinor, --T2
            DamageStabilization = iMajor, --Nano
            HeavyAntiMatterCannon = iMajor,
            LeftPod = iNone, --Engi
            ResourceAllocation = iNone, --RAS
            RightPod = iNone, --Engi
            Shield = iMajor, --Shield
            ShieldGeneratorField = iMajor, --Shield aoe
            T3Engineering = iMinor, --T3
            TacticalMissile = iNone, --TML
            TacticalNukeMissile = iNone, --Billy
            Teleporter = iNone, --Teleport
            --Aeon:
            --AdvancedEngineering = iMinor, --T2
            ChronoDampener = iDeadly, --ChronoDampener
            CrysalisBeam = iMajor, --Range
            EnhancedSensors = iNone, --Sensors
            HeatSink = iMajor, --ROF
            --ResourceAllocation = iNone, --RAS
            ResourceAllocationAdvanced = iNone, --RAS lev 2
            --Shield = iMajor, --Shield
            ShieldHeavy = iMajor, --Shield lev2
            --T3Engineering = iMinor, --T3
            --Teleporter = iNone, --Teleport
            --Cybran:
            --AdvancedEngineering = iMinor, --T2
            CloakingGenerator = iMinor, --Cloak
            CoolingUpgrade = iMajor, --Gun
            MicrowaveLaserGenerator = iDeadly, --Laser
            NaniteTorpedoTube = iMinor, --Torpedo
            --ResourceAllocation = iNone, --RAS
            StealthGenerator = iMajor, --Stealth
            --T3Engineering = iMinor, --T3
            --Teleporter = iNone, --Teleport
            --Sera:
            --AdvancedEngineering = iMinor, --T2
            AdvancedRegenAura = iMajor, --Regen aura lev2
            BlastAttack = iDeadly, --AOE and damage
            DamageStabilization = iMajor, --Nano
            DamageStabilizationAdvanced = iMajor, --Nano lev2
            Missile = iNone, --TML
            RateOfFire = iMajor, --Gun
            RegenAura = iDeadly, --Regen aura
            --ResourceAllocation = iNone, --RAS
            ResourceAllocationAdvanced = iNone, --RAS lev 2
            --T3Engineering = iMinor, --T3
            --Teleporter = iNone, --Teleport
    }
    return (tEnhancementsCombatMod[sEnhancementRef] or iUnknown)
end

function UpdateUnitCombatMassRatingForUpgrades(oUnit)
    --Updates oUnit[refiDFMassThreatOverride] to reflect any upgrades on the unit (e.g. for ACU and SACUs)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateUnitCombatMassRatingForUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tPossibleUpgrades = oUnit:GetBlueprint().Enhancements
    if M28Utilities.IsTableEmpty(tPossibleUpgrades) == false then
        local iCurMassValue
        local iCurMassMod
        local iBaseMassValue = 1000 --Approx 20 tanks
        local iTotalMassValue = iBaseMassValue
        if bDebugMessages == true then LOG(sFunctionRef..': tPossibleUpgrades size='..table.getn(tPossibleUpgrades)) end
        if tPossibleUpgrades then
            for sCurUpgrade, tUpgrade in tPossibleUpgrades do
                if oUnit:HasEnhancement(sCurUpgrade) then
                    iCurMassValue = tUpgrade.BuildCostMass
                    iCurMassMod = GetUpgradeCombatWeighting(sCurUpgrade)
                    iTotalMassValue = iTotalMassValue + iCurMassMod * iCurMassValue
                    if bDebugMessages == true then LOG(sFunctionRef..': ACU has enhancement no. '..sCurUpgrade..'; iCurMassValue='..iCurMassValue..'; iCurMassMod='..iCurMassMod) end
                end
            end
        end
        oUnit[refiDFMassThreatOverride] = iTotalMassValue
        if oUnit:HasEnhancement('NaniteTorpedoTube') then
            oUnit[refiAntiNavyMassThreatOverride] = math.max(iTotalMassValue, 2500)
        else
            oUnit[refiAntiNavyMassThreatOverride] = math.min(iTotalMassValue * 0.1, 800)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetCombatThreatRating(tUnits, bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, bBlueprintThreat)
    --Determines threat rating for tUnits, which in most cases will be the mass cost of the unit and adjusted for unit health; by default assumes are referring to main combat threat (e.g. tank), but the flags for indirect and naval threat can be used to adjust this
    --bJustGetMassValue - if thisi s true, will ignore things like health and just return the mass value (so none of the other values should matter if this is true - i.e. assumes tUnits is already filtered to those of interest)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetCombatThreatRating'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if M28Utilities.IsTableEmpty(tUnits) then
        if bDebugMessages == true then LOG(sFunctionRef..': Warning: tUnits is empty, returning 0') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return 0
    else
        local iCurThreat = 0
        local iTotalThreat = 0
        local iHealthPercentage, iMaxHealth
        local iHealthFactor --if unit has 40% health, then threat reduced by (1-40%)*iHealthFactor
        local iCurShield, iMaxShield
        local iOtherAdjustFactor = 1


        local iThreatRef = '1'
        if bIndirectFireThreatOnly then iThreatRef = iThreatRef .. '1' else iThreatRef = iThreatRef .. '0' end
        if bJustGetMassValue then iThreatRef = iThreatRef .. '1' else iThreatRef = iThreatRef .. '0' end
        if bAntiNavyOnly then iThreatRef = iThreatRef .. '1' else iThreatRef = iThreatRef .. '0' end
        if bAddAntiNavy then iThreatRef = iThreatRef .. '1' else iThreatRef = iThreatRef .. '0' end
        if bSubmersibleOnly then iThreatRef = iThreatRef .. '1' else iThreatRef = iThreatRef .. '0' end
        if bLongRangeThreatOnly then iThreatRef = iThreatRef..'1' else iThreatRef = iThreatRef .. '0' end

        if not(tiThreatRefsCalculated[iThreatRef]) then M28Utilities.ErrorHandler('Havent calculated threat values for iThreatRef='..iThreatRef..' refer to CalculateBlueprintThreatsByType') end

        local iBaseThreat = 0

        for iUnit, oUnit in tUnits do
            iCurThreat = 0
            iBaseThreat = 0
            --Get the base threat for the unit
            if IsUnitValid(oUnit) then
                iBaseThreat = (oUnit[refiDFMassThreatOverride] or tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef])
                if oUnit[refiAntiNavyMassThreatOverride] and (bAntiNavyOnly or bAddAntiNavy or bSubmersibleOnly) then
                    iBaseThreat = oUnit[refiAntiNavyMassThreatOverride]
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; iBaseThreat='..(iBaseThreat or 0)..'; DF threat override='..(oUnit[refiDFMassThreatOverride] or 'nil')..'; tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef]='..(tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef] or 'nil')) end
                if not(tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef]) and not(bBlueprintThreat) then
                    iBaseThreat = GetCombatThreatRating({ { ['UnitId'] = oUnit.UnitId } }, bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, true)
                    if not(tUnitThreatByIDAndType[oUnit.UnitId]) then tUnitThreatByIDAndType[oUnit.UnitId] = {} end
                    if bDebugMessages == true then LOG(sFunctionRef..': Will rerun the blueprint logic as it seems to have missed this unit '..oUnit.UnitId..'; iBaseThreat after this='..(iBaseThreat or 'nil')) end
                    if not(tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef]) then tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef] = (iBaseThreat or 0) end

                end
                if iBaseThreat == 0 and bSubmersibleOnly and bEnemyUnits and EntityCategoryContains(categories.AMPHIBIOUS, oUnit.UnitId) and IsUnitUnderwater(oUnit) then
                    iBaseThreat = oUnit:GetBlueprint().Economy.BuildCostMass * 0.35
                end
                if iBaseThreat > 0 then
                    if bJustGetMassValue then iCurThreat = iBaseThreat
                    else
                        --Have got the base threat for this type of unit, now adjust threat for unit health if want to calculate actual threat
                        iCurShield, iMaxShield = GetCurrentAndMaximumShield(oUnit)
                        iMaxHealth = oUnit:GetMaxHealth() + iMaxShield
                        if iMaxHealth and iMaxHealth > 0 then
                            --Increase threat for veterancy level
                            if oUnit.Sync.VeteranLevel > 0 then iBaseThreat = iBaseThreat * (1 + oUnit.Sync.VeteranLevel * 0.1) end

                            --Adjust threat for cur health %
                            iOtherAdjustFactor = 1
                            iHealthPercentage = (oUnit:GetHealth() + iCurShield) / (iMaxHealth + iMaxShield)

                            --Reduce threat by health, with the amount depending on if its an ACU and if its an enemy
                            if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                                iHealthFactor = iHealthPercentage --threat will be mass * iHealthFactor
                                --iMassCost = GetACUCombatMassRating(oUnit) --have already calculated this earlier
                                if bEnemyUnits then
                                    iOtherAdjustFactor = 1.10 --Want to allow for enemy ACU to be 10% higher threat due to potential of veterancy
                                else
                                    if iHealthPercentage < 0.5 then iHealthFactor = iHealthPercentage * iHealthPercentage
                                    elseif iHealthPercentage < 0.9 then iHealthFactor = iHealthPercentage * (iHealthPercentage + 0.1) end
                                end
                            else
                                if bEnemyUnits then
                                    --For enemy damaged units treat them as still ahving high threat, since enemy likely could use them effectively still
                                    if iHealthPercentage >= 1 then iHealthFactor = iHealthPercentage
                                    else
                                        iHealthFactor = math.max(0.25, iHealthPercentage * (1 + (1 - iHealthPercentage)))
                                    end
                                else
                                    iHealthFactor = iHealthPercentage
                                end
                            end
                            if oUnit:GetFractionComplete() <= 0.75 then iOtherAdjustFactor = iOtherAdjustFactor * 0.1 end
                        end
                        iCurThreat = iBaseThreat * iOtherAdjustFactor * iHealthFactor
                        if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' iCurThreat='..iCurThreat..'; iBaseThreat='..iBaseThreat..'; iOtherAdjustFactor='..iOtherAdjustFactor..'; iHealthFactor='..iHealthFactor) end
                    end
                end
            else
                --Are we calculating blueprint threat (per code at start of game)?
                if bBlueprintThreat then
                    local oBP = __blueprints[oUnit.UnitId]
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit with ID='..(oUnit.UnitId or 'nil')) end

                    if bJustGetMassValue == true then iBaseThreat = (oBP.Economy.BuildCostMass or 0)
                    else
                        local iMassMod = 0
                        --T3 and T4 arti - assign 0 combat value
                        if not(EntityCategoryContains(refCategoryFixedT3Arti + refCategoryExperimentalArti, oUnit.UnitId)) then

                            if not(bIndirectFireThreatOnly) then
                                if bAntiNavyOnly or bSubmersibleOnly then
                                    iMassMod = 0
                                    if (bSubmersibleOnly and (EntityCategoryContains(categories.SUBMERSIBLE, oUnit.UnitId) or oBP.Physics.MotionType == 'RULEUMT_Amphibious' or oUnit.UnitId == 'xrb2309')) or (not(bSubmersibleOnly) and bAntiNavyOnly and EntityCategoryContains(categories.ANTINAVY+categories.OVERLAYANTINAVY + refCategoryBattleship, oUnit.UnitId)) then
                                        iMassMod = 0.25 --e.g. for overlayantinavy or submersibles with no attack
                                        if EntityCategoryContains(categories.ANTINAVY, oUnit.UnitId) then
                                            iMassMod = 1
                                        elseif EntityCategoryContains(categories.LAND * categories.ANTINAVY, oUnit.UnitId) then
                                            iMassMod = 0.5 --brick, wagner etc
                                            --UEF units (which are either really bad or good at antinavy)
                                        elseif EntityCategoryContains(categories.UEF * categories.ANTINAVY, oUnit.UnitId) then
                                            --Destroyer and battlecruiser
                                            if EntityCategoryContains(categories.DIRECTFIRE * categories.TECH2, oUnit.UnitId) then iMassMod = 0.25 --valiant
                                            elseif EntityCategoryContains(categories.DIRECTFIRE * categories.TECH3, oUnit.UnitId) then iMassMod = 0.15 --battlecruiser
                                            elseif EntityCategoryContains(categories.TECH2 - categories.DIRECTFIRE, oUnit.UnitId) then iMassMod = 1.2 --Cooper
                                            else
                                                --Unexpected category
                                                iMassMod = 0.5
                                            end
                                        elseif EntityCategoryContains(categories.CYBRAN * categories.ANTINAVY, oUnit.UnitId) then
                                            iMassMod = 0.8
                                        elseif EntityCategoryContains(refCategoryMegalith, oUnit.UnitId) then
                                            iMassMod = 0.5
                                        elseif EntityCategoryContains(refCategoryBattleship, oUnit.UnitId) then
                                            iMassMod = 0.05 --battleships could ground fire, although theyre unlikely to and very inaccurate if the target is moving
                                        end
                                    end
                                elseif bLongRangeThreatOnly then
                                    if EntityCategoryContains(categories.DIRECTFIRE + categories.INDIRECTFIRE, oUnit.UnitId) then
                                        local iUnitRange = GetBlueprintMaxGroundRange(oBP)
                                        if iUnitRange >= 55 then
                                            if EntityCategoryContains(categories.SILO * categories.TECH3 * categories.SUBMERSIBLE, oUnit.UnitId) then
                                                iMassMod = 0.25 --Missile sub
                                            end
                                        end
                                    end
                                else
                                    if EntityCategoryContains(categories.DIRECTFIRE, oUnit.UnitId) then
                                        if EntityCategoryContains(refCategoryLandScout, oUnit.UnitId) then
                                            if EntityCategoryContains(categories.SERAPHIM, oUnit.UnitId) then
                                                iMassMod = 0.55 --Selen costs 20, so Selen ends up with a threat of 12; engineer logic will ignore threats <10 (so all other lands couts)
                                            else iMassMod = 0.25
                                            end
                                        elseif EntityCategoryContains(refCategoryCruiserCarrier, oUnit.UnitId) then
                                            if EntityCategoryContains(categories.CYBRAN * categories.TECH2, oUnit.UnitId) then iMassMod = 0.55
                                            elseif EntityCategoryContains(categories.AEON, oUnit.UnitId) then
                                                iMassMod = 0.2 --Aeon cruiser loses vs 2 UEF frigates in sandbox (it kills 1 just before it dies)
                                            else
                                                iMassMod = 0.15 --e.g. uef cruiser - 1 frigate can almost solo it if it dodges the missiles
                                            end
                                        elseif EntityCategoryContains(refCategoryAttackBot * categories.TECH1, oUnit.UnitId) then
                                            iMassMod = 0.85
                                        elseif EntityCategoryContains(categories.BATTLESHIP - refCategoryBattlecruiser, oUnit.UnitId) then
                                            iMassMod = 0.85
                                        elseif EntityCategoryContains(categories.DESTROYER, oUnit.UnitId) then
                                            iMassMod = 0.95
                                        elseif EntityCategoryContains(refCategoryFrigate * categories.CYBRAN, oUnit.UnitId) then
                                            iMassMod = 1.05
                                        else iMassMod = 1
                                        end
                                    elseif EntityCategoryContains(refCategoryFatboy, oUnit.UnitId) then
                                        iMassMod = 0.55
                                    elseif EntityCategoryContains(categories.SUBCOMMANDER, oUnit.UnitId) then iMassMod = 1 --SACUs dont have directfire category for some reason (they have subcommander and overlaydirectfire)
                                    elseif EntityCategoryContains(categories.INDIRECTFIRE * categories.ARTILLERY * categories.STRUCTURE * categories.TECH2, oUnit.UnitId) then iMassMod = 0.1 --Gets doubled as its a structure
                                    elseif EntityCategoryContains(categories.INDIRECTFIRE * categories.ARTILLERY * categories.MOBILE * categories.TECH1, oUnit.UnitId) then iMassMod = 0.9
                                    elseif EntityCategoryContains(categories.INDIRECTFIRE * categories.ARTILLERY * categories.MOBILE * categories.TECH3, oUnit.UnitId) then iMassMod = 0.5
                                    elseif EntityCategoryContains(refCategoryMobileLand * categories.INDIRECTFIRE * categories.SILO, oUnit.UnitId) then iMassMod = 0.1
                                    elseif EntityCategoryContains(categories.SHIELD, oUnit.UnitId) then iMassMod = 0.75 --will be doubled for structures
                                    elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then iMassMod = 1 --Put in just in case - code was working before this, but dont want it to be affected yb more recenlty added engineer category
                                    elseif EntityCategoryContains(categories.ENGINEER,oUnit.UnitId) then iMassMod = 0.01 --Engis can reclaim and capture so can't just e.g. beat with a scout, but also dont want a combat unit to run from engineers as they could still harm them; alot of logic uses a threshold of 10 for threats, which would be c.3 T3 engineers, so will go with this
                                    end
                                    if bAddAntiNavy and iMassMod < 1 and EntityCategoryContains(categories.ANTINAVY  + categories.OVERLAYANTINAVY, oUnit.UnitId) then
                                        --Increase mass mod for certain units
                                        if iMassMod < 0.25 then iMassMod = 0.25 end
                                        if EntityCategoryContains(categories.SUBMERSIBLE + categories.ANTINAVY, oUnit.UnitId) then
                                            iMassMod = 1 --Subs
                                        elseif EntityCategoryContains(categories.LAND * categories.ANTINAVY, oUnit.UnitId) then
                                            iMassMod = math.max(iMassMod, 0.5) --wagners, bricks etc.
                                        elseif EntityCategoryContains(categories.SUBMERSIBLE * categories.SILO * categories.TECH3, oUnit.UnitId) then
                                            iMassMod = math.max(iMassMod, 0.25) --missile ship
                                        end
                                    end
                                end
                            else
                                if EntityCategoryContains(categories.INDIRECTFIRE, oUnit.UnitId) then
                                    if EntityCategoryContains(categories.SILO * categories.TECH3 * categories.SUBMERSIBLE, oUnit.UnitId) then
                                        iMassMod = 0.25 --Missile sub
                                    else
                                        iMassMod = 1
                                    end
                                    if EntityCategoryContains(categories.DIRECTFIRE, oUnit.UnitId) then iMassMod = 0.5 end
                                elseif EntityCategoryContains(categories.ANTIMISSILE, oUnit.UnitId) then iMassMod = 2 --Doubled for structures ontop of this, i.e. want 4xmass of TMD in indirect fire so can overwhelm it
                                elseif EntityCategoryContains(categories.SHIELD, oUnit.UnitId) then iMassMod = 1
                                elseif EntityCategoryContains(refCategoryLongRangeDFLand, oUnit.UnitId) then iMassMod = 0.5
                                end
                            end
                            if EntityCategoryContains(refCategoryStructure, oUnit.UnitId) then
                                --T2 arti - reduce its value because it sucks
                                if EntityCategoryContains(refCategoryFixedT2Arti, oUnit.UnitId) then
                                    iMassMod = iMassMod * 0.6
                                elseif EntityCategoryContains(refCategoryStructureAA * categories.TECH1, oUnit.UnitId) then
                                    iMassMod = iMassMod * 1.5
                                else
                                    iMassMod = iMassMod * 2
                                    if bAntiNavyOnly then iMassMod = iMassMod * 1.1 end
                                end
                            end
                        end
                        local iMassCost = (oBP.Economy.BuildCostMass or 0)
                        if bDebugMessages == true then LOG(sFunctionRef..': iMassCost='..(iMassCost or 'nil')..'; iMassMod='..(iMassMod or 'nil')) end
                        iBaseThreat = iMassCost * iMassMod
                    end
                elseif bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' is not valid')
                end

                iCurThreat = iBaseThreat
            end

            iTotalThreat = iTotalThreat + iCurThreat
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iTotalThreat='..iTotalThreat) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return iTotalThreat
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetAirThreatLevel(tUnits, bEnemyUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
    --Threat value depends on inputs:
    --bIncludeAntiAir - will include anti-air on ground units
    --bIncludeNonCombatAir - adds threat value for transports and scouts
    --bIncludeAirTorpedo - Adds threat for torpedo bombers
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetAirThreatLevel'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': About to check if table is empty. bIncludeAirToAir='..tostring(bIncludeAirToAir)) end

    if M28Utilities.IsTableEmpty(tUnits) then
        --if tUnits == nil then
        if bDebugMessages == true then LOG(sFunctionRef..': Warning: tUnits is empty, returning 0') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return 0
    else
        if bIncludeAirTorpedo == nil then bIncludeAirTorpedo = bIncludeAirToGround end
        local bUnitFitsDesiredCategory

        --Determine the amount that health impacts on threat
        local iHealthFactor = 1 --if unit has 40% health, then threat reduced by (1-40%)*iHealthFactor
        if bIncludeAirToAir == true then
            if bEnemyUnits and not(bBlueprintThreat) then
                iHealthFactor = 0.5
            else
                iHealthFactor = 0.15
            end
        elseif bIncludeAirToGround == true then iHealthFactor = 0.5
        else iHealthFactor = 0 end

        local iCurThreat = 0
        local iTotalThreat = 0
        local iBaseThreat = 0
        local iHealthPercentage
        local iHealthThreatFactor
        local iGhettoGunshipAdjust = 0


        local iThreatRef = '2'
        if bIncludeAirToAir then iThreatRef = iThreatRef..'1' else iThreatRef = iThreatRef..'0' end
        if bIncludeGroundToAir then iThreatRef = iThreatRef..'1' else iThreatRef = iThreatRef..'0' end
        if bIncludeAirToGround then iThreatRef = iThreatRef..'1' else iThreatRef = iThreatRef..'0' end
        if bIncludeNonCombatAir then iThreatRef = iThreatRef..'1' else iThreatRef = iThreatRef..'0' end
        if bIncludeAirTorpedo then iThreatRef = iThreatRef..'1' else iThreatRef = iThreatRef..'0' end
        if not(tiThreatRefsCalculated[iThreatRef]) then
            M28Utilities.ErrorHandler('Dont have a thraat ref '..iThreatRef..' So CalculateBlueprintThreatsByType threat calculation likely wrong')
        end


        local bAdjustExperimentalAirToGroundThreat = false
        if not(bEnemyUnits) and bIncludeAirToGround and not(bIncludeAirToAir) then bAdjustExperimentalAirToGroundThreat = true end

        for iUnit, oUnit in tUnits do
            iCurThreat = 0
            iBaseThreat = 0
            iGhettoGunshipAdjust = 0
            if bDebugMessages == true then LOG(sFunctionRef..': About to check if unit is dead') end

            if IsUnitValid(oUnit) then
                --Get the base threat for the unit
                iBaseThreat = (tUnitThreatByIDAndType[oUnit.UnitId][iThreatRef] or 0)
                --Adjust threat for health
                if iBaseThreat > 0 then
                    --Increase for cargo of transports
                    if bIncludeAirToGround and EntityCategoryContains(refCategoryTransport, oUnit.UnitId) and oUnit.GetCargo then --Use refcategoryTransport as Brewlan gives torp bombers the transportation category, and checking .GetCargo first doesnt prevent an error
                        if bDebugMessages == true then LOG(sFunctionRef..': Have an enemy transport, will get its cargo and see if it contains LABs') end
                        --Include threat of cargo if cargo are LABs
                        local tCargo = oUnit:GetCargo()
                        --Filter to just LABs (note unfortunately it doesnt distinguish between mantis and LABs so matnis get treated as LABs to be prudent)
                        if tCargo then
                            tCargo = EntityCategoryFilterDown(refCategoryAttackBot, tCargo)
                            if M28Utilities.IsTableEmpty(tCargo) == false then
                                --Get mass value ignoring health:
                                --GetCombatThreatRating(aiBrain, tUnits, bMustBeVisibleToIntelOrSight, iMassValueOfBlipsOverride, iSoloBlipMassOverride, bIndirectFireThreatOnly, bJustGetMassValue)
                                iGhettoGunshipAdjust = GetCombatThreatRating(tCargo, bEnemyUnits)
                                if bDebugMessages == true then LOG(sFunctionRef..': Contains LABs so will increase threat by '..iGhettoGunshipAdjust) end
                            end
                        end
                    end

                    --Adjust threat for health
                    iHealthThreatFactor = 1
                    if iHealthFactor > 0 then
                        --Assume low health experimental is has more health than it does - e.g. might heal, or might be under construction
                        if EntityCategoryContains(categories.EXPERIMENTAL, oUnit) then
                            --Does unit have a shield?
                            if EntityCategoryContains(categories.PERSONALSHIELD + categories.SHIELD, oUnit.UnitId) then
                                local iCurShield, iMaxShield = GetCurrentAndMaximumShield(oUnit, true)
                                iHealthPercentage = (oUnit:GetHealth() + iCurShield) / (oUnit:GetMaxHealth() + iMaxShield)
                            else
                                iHealthPercentage = GetUnitHealthPercent(oUnit)
                                if iHealthPercentage < 1 and oUnit:GetFractionComplete() >= 0.2 then
                                    if bEnemyUnits then iHealthPercentage = math.min(1, math.max(0.4, iHealthPercentage * 1.5))
                                    else
                                        iHealthPercentage = math.min(1, math.max(0.3, iHealthPercentage * 1.4))
                                    end
                                end
                            end
                        else
                            iHealthPercentage = GetUnitHealthPercent(oUnit)
                        end
                        iHealthThreatFactor = (1 - (1-iHealthPercentage) * iHealthFactor) * iHealthThreatFactor
                    end
                    if bAdjustExperimentalAirToGroundThreat and EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then
                        if EntityCategoryContains(refCategoryCzar, oUnit.UnitId) then
                            --Friendly czar
                            iBaseThreat = iBaseThreat * 0.5
                        else
                            --e.g. friendly soulripper
                            iBaseThreat = iBaseThreat * 0.75
                        end
                    end
                    iCurThreat = iBaseThreat * iHealthThreatFactor + iGhettoGunshipAdjust
                    if bDebugMessages == true then LOG(sFunctionRef..': UnitBP='..(oUnit.UnitId or 'nil')..'; iBaseThreat='..(iBaseThreat or 'nil')..'; iHealthThreatFactor='..(iHealthThreatFactor or 'nil')..'iGhettoGunshipAdjust='..(iGhettoGunshipAdjust or 'nil')..'; iCurThreat='..(iCurThreat or 'nil')) end
                end
            else
                --Calculate the base threat for hte blueprint (start of game)
                if bBlueprintThreat then
                    local oBP = __blueprints[oUnit.UnitId]
                    if bDebugMessages == true then LOG(sFunctionRef..': About to calculate threat using actual unit data, iThreatRef='..iThreatRef) end
                    --get actual threat calc
                    local iMassMod = 0 --For non-offensive structures
                    --Does the unit contain any of the categories of interest?
                    bUnitFitsDesiredCategory = false
                    --Exclude based on pathing type initially before considering more precisely:
                    local sCurUnitPathing = GetUnitPathingType(oUnit)
                    if sCurUnitPathing == M28Map.refPathingTypeAir then
                        if bIncludeAirToAir == true then bUnitFitsDesiredCategory = true
                        elseif bIncludeAirToGround == true then bUnitFitsDesiredCategory = true
                        elseif bIncludeAirTorpedo == true then bUnitFitsDesiredCategory = true
                        elseif bIncludeNonCombatAir == true then bUnitFitsDesiredCategory = true
                        end
                    elseif bIncludeGroundToAir == true then bUnitFitsDesiredCategory = true end

                    --Is unit still valid? If so then consider its weapons/categories more precisely:
                    if bDebugMessages == true then LOG(sFunctionRef..': bUnitFitsDesiredCategory='..tostring(bUnitFitsDesiredCategory)..'; bIncludeAirToAir='..tostring(bIncludeAirToAir)..'; bIncludeAirToGround='..tostring(bIncludeAirToGround)..'; iThreatRef='..iThreatRef) end
                    if bUnitFitsDesiredCategory == true then

                        local sCurUnitBP = oBP.BlueprintId

                        --Get values for air units:
                        if sCurUnitPathing == M28Map.refPathingTypeAir then
                            if bIncludeNonCombatAir == true then
                                iMassMod = 1
                                --Reduce to 25% for air scouts, as main concern is transports
                                if EntityCategoryContains(refCategoryAirScout, sCurUnitBP) then iMassMod = 0.25 end

                            else
                                if bIncludeAirToGround == true then
                                    if EntityCategoryContains(categories.BOMBER + categories.GROUNDATTACK + categories.OVERLAYDIRECTFIRE + categories.DIRECTFIRE, sCurUnitBP) == true then iMassMod = 1
                                    elseif EntityCategoryContains(categories.TRANSPORTATION, sCurUnitBP) then iMassMod = 1 --might be a ghetto
                                    end
                                end
                                if bIncludeAirTorpedo == true and EntityCategoryContains(categories.ANTINAVY, sCurUnitBP) == true then iMassMod = 1 end
                                if bDebugMessages == true then LOG(sFunctionRef..': bIncludeAirTorpedo='..tostring(bIncludeAirTorpedo)..'; iMassMod='..iMassMod) end

                                if bIncludeAirToAir == true and iMassMod < 1 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': bIncludeAirToAir='..tostring(bIncludeAirToAir)..'; iMassMod='..iMassMod..'; does BP contain airaa category='..tostring(EntityCategoryContains(categories.ANTIAIR * categories.AIR, sCurUnitBP))) end
                                    if EntityCategoryContains(categories.ANTIAIR * categories.AIR, sCurUnitBP) == true then
                                        iMassMod = 1
                                        if EntityCategoryContains(categories.BOMBER + categories.GROUNDATTACK + categories.DIRECTFIRE, sCurUnitBP) then
                                            iMassMod = 0.75 --e.g. t2 bombers
                                            --Manual adjustments for units with good AA that also have direct fire
                                            if sCurUnitBP == 'xaa0305' then iMassMod = 0.8 --Restorer
                                            elseif sCurUnitBP == 'xea0306' then iMassMod = 0.7 --Continental
                                            elseif sCurUnitBP == 'uaa0310' then iMassMod = 0.55 --Czar
                                            elseif sCurUnitBP == 'xsa0402' then iMassMod = 0.3 --Sera experi bomber
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': sCurUnitBP='..sCurUnitBP..': Mass mod after checking AirAA value='..iMassMod) end
                                    elseif EntityCategoryContains(categories.OVERLAYANTIAIR * categories.AIR, sCurUnitBP) then
                                        iMassMod = 0.05
                                    end
                                end
                            end
                        else
                            --Non-air pathing type
                            if bDebugMessages == true then LOG(sFunctionRef..': Unit doesnt have air pathing. bIncludeGroundToAir='..tostring(bIncludeGroundToAir)) end
                            if bIncludeGroundToAir == true then
                                if EntityCategoryContains(categories.ANTIAIR, sCurUnitBP) == true then
                                    if EntityCategoryContains(categories.SUBMERSIBLE, sCurUnitBP) then
                                        if EntityCategoryContains(categories.EXPERIMENTAL, sCurUnitBP) then
                                            iMassMod = 1 --atlantis (if categorised correctly)
                                        else
                                            iMassMod = 0.5 --sera sub hunter
                                        end
                                    elseif EntityCategoryContains(categories.EXPERIMENTAL + refCategoryFrigate, sCurUnitBP) then
                                        iMassMod = 0.1 --Cybran frigate and land experimentals misclassified as anti-air
                                    else
                                        iMassMod = 1 --Cruisers and T3 aircraft carriers have antiair as well as overlay antiair
                                    end
                                elseif EntityCategoryContains(categories.OVERLAYANTIAIR, sCurUnitBP) == true then
                                    iMassMod = 0.04
                                    if sCurUnitBP == 'ues0401' then iMassMod = 1 --atlantis misclassifiefd as not anti-air
                                    elseif EntityCategoryContains(categories.FRIGATE, sCurUnitBP) then iMassMod = 0.18
                                    elseif sCurUnitBP == 'url0402' then
                                        iMassMod = 0.016 --monkeylord - it has half the dps of a t2 mobile flak with no aoe (although it has better range and health), so its threat will be equivalent to 2 mobile T2 MAA so that gunships are more likely to engage it
                                    end
                                end
                            end
                        end
                        --Increase AA threat for structures
                        if bIncludeGroundToAir == true and sCurUnitPathing == M28Map.refPathingTypeNone then iMassMod = iMassMod * 2 end
                    end

                    local iMassCost = (oBP.Economy.BuildCostMass or 0)
                    if bDebugMessages == true then LOG(sFunctionRef..': iMassCost='..(iMassCost or 'nil')..'; iMassMod='..(iMassMod or 'nil')) end
                    iBaseThreat = iMassCost * iMassMod
                end
                iCurThreat = iBaseThreat
            end

            iTotalThreat = iTotalThreat + iCurThreat
            if bDebugMessages == true then LOG(sFunctionRef..': Unit='..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; iCurThreat='..iCurThreat..'; iTotalThreat='..iTotalThreat) end
        end


        if bDebugMessages == true then LOG(sFunctionRef..': End of code, iTotalThreat='..iTotalThreat) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return iTotalThreat
    end
    M28Profiler.ErrorHandler('Code shouldve returend before now, will return 0')
    return 0
end

function CheckBlueprintSizeSupport(oBP, sUnitId)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckBlueprintSizeSupport'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..sUnitId..'; Can this be built by T3 engi='..tostring(EntityCategoryContains(categories.BUILTBYTIER3ENGINEER, sUnitId))) end
    if EntityCategoryContains(categories.BUILTBYTIER3ENGINEER, sUnitId) then
        local iUnitSize = GetBuildingSize(sUnitId)
        local bBuildOnLand = false
        if tbBuildOnLandLayerCaps[oBP.Physics.BuildOnLayerCaps] then bBuildOnLand = true end
        local bBuildOnSea = false
        if tbBuildOnWaterLayerCaps[oBP.Physics.BuildOnLayerCaps] then bBuildOnSea = true end
        if bDebugMessages == true then LOG(sFunctionRef..': bBuildOnLand='..tostring(bBuildOnLand)..'; bBuildOnSea='..tostring(bBuildOnSea)..'; tsBlueprintsBySize='..repru(M28Engineer.tsBlueprintsBySize)..'; oBP.Physics.BuildOnLayerCaps='..repru(oBP.Physics.BuildOnLayerCaps)..'; tbBuildOnLandLayerCaps[BuildOnLayerCaps]='..tostring(tbBuildOnLandLayerCaps[oBP.Physics.BuildOnLayerCaps] or false)) end
        if bBuildOnLand and not(M28Engineer.tsBlueprintsBySize[iUnitSize]) then
            M28Engineer.tsBlueprintsBySize[iUnitSize] = sUnitId
            M28Engineer.iMaxBuildingSize = math.max(M28Engineer.iMaxBuildingSize, iUnitSize)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..sUnitId..'; iUnitSize='..iUnitSize..'; wasnt recorded in land size table so have added') end
        end
        if bBuildOnSea and not(M28Engineer.tsWZBlueprintsBySize[iUnitSize]) then
            M28Engineer.tsWZBlueprintsBySize[iUnitSize] = sUnitId
            M28Engineer.iMaxBuildingSize = math.max(M28Engineer.iMaxBuildingSize, iUnitSize)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..sUnitId..'; iUnitSize='..iUnitSize..'; wasnt recorded in water size table so have added') end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CalculateBlueprintThreatsByType()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CalculateBlueprintThreatsByType'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(tUnitThreatByIDAndType) then
        local sUnitId
        --{bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly}
        local tiLandAndNavyThreatTypes = {
            ['1000000'] = { false, false, false, false, false, false }, --Normal land threat
            ['1010000'] = { true, false, false, false, false, false, false }, --mass cost
            ['1100000'] = { false, true, false, false, false, false }, --Indirect
            ['1000100'] = { false, false, false, true, false, false }, --Normal land threat plus antinavy threat if higher
            ['1001000'] = { false, false, true, false, false, false }, --Antinavy threat only
            ['1000010'] = { false, false, false, false, true, false }, --Submersible threat only
            ['1000001'] = { false, false, false, false, false, true }, --Long range threat only
        }
        --{bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo}
        local tiAirThreatTypes = {
            ['200001'] = {false, false, false, false, true,}, --Torpedo bombers
            ['200100'] = { false, false, true, false, false }, --Air to ground
            ['200110'] = { false, false, true, true, false }, --Air to gorund and non-combat
            ['200111'] = { false, false, true, true, true }, --Air to ground and non-combat; note: The code will set TorpBombers to equal the airtoground value if it's nil, hence use of code ending 111
            ['201000'] = { false, true, false, false, false }, --Ground AA
            ['210000'] = { true, false, false, false, false }, --Air AA
            ['210110'] = { true, false, true, true, false }, --Air threat (general)
            ['210111'] = { true, false, true, true, true }, --Air threat (general)
            ['200101'] = { true, false, true, true, true }, --Bombers and torpedo bombers
            ['210011'] = { true, false, false, true, true}, --Air excluding air to ground (but including torp bombers) - i.e. 'air excluding dangerous to land tanks on land'
            ['210010'] = { true, false, false, true, false}, --Air excluding air to ground (i.e. excluding torp bombers as well)
            ['200011'] = { false, false, false, true, true}, --Used to get non-AA non-Air to ground (excl torp bomber) air, e.g. intended for land zones to determine 'other'/less important air
            ['200010'] = { false, false, false, true, false}, --Used to get non-AA non-Air to ground air, e.g. intended for water zones to determine 'other'/less important air
            --['211000'] = { true, true, false, false, false} --GroundAA and AirAA combined - was thinking of using this for recording IMAP air version but decided to stick to just airaa
        }

        for iRef, tValue in tiLandAndNavyThreatTypes do
            tiThreatRefsCalculated[iRef] = true
        end
        for iRef, tValue in tiAirThreatTypes do
            tiThreatRefsCalculated[iRef] = true
        end



        function RecordBlueprintThreatValues(oBP, sUnitId)

            tUnitThreatByIDAndType[sUnitId] = {}
            if bDebugMessages == true then LOG(sFunctionRef..': About to consider different land threat values for unit '..sUnitId..' Name='..(oBP.General.UnitName or 'nil')) end
            for iRef, tConditions in tiLandAndNavyThreatTypes do
                --GetCombatThreatRating(tUnits, bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, bBlueprintThreat)
                --{bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly}
                tUnitThreatByIDAndType[sUnitId][iRef] = GetCombatThreatRating( { {['UnitId']=sUnitId }}, false, tConditions[1], tConditions[2], tConditions[3], tConditions[4], tConditions[5], tConditions[6], true)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished calculating land threat values for '..(oBP.General.UnitName or 'nil')..', result='..reprs(tUnitThreatByIDAndType[sUnitId])) end

            for iRef, tConditions in tiAirThreatTypes do
                --GetAirThreatLevel(tUnits, bEnemyUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
                tUnitThreatByIDAndType[sUnitId][iRef] = GetAirThreatLevel({ {['UnitId']=sUnitId }}, false, tConditions[1], tConditions[2], tConditions[3], tConditions[4], tConditions[5], true)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished calculating air threat values, result of land and air for '..(oBP.General.UnitName or 'nil')..'='..reprs(tUnitThreatByIDAndType[sUnitId])) end
        end

        local iCount = 0

        for iBP, oBP in __blueprints do
            --Updates tUnitThreatByIDAndType
            sUnitId = oBP.BlueprintId
            if bDebugMessages == true then LOG('Will shortly (via a forked threat) get the blueprint threat for enemy unit sUnitId '..sUnitId..'; tUnitThreatByIDAndType[sUnitId]='..(tUnitThreatByIDAndType[sUnitId] or 'nil')..'; oBP.Economy.BuildCostMass='..(oBP.Economy.BuildCostMass or 'nil')..'; oBP.General.UnitName='..(oBP.General.UnitName or 'nil')..' if it has a build cost mass of at least 1 and we havent already called it') end

            if not(tUnitThreatByIDAndType[sUnitId]) and (oBP.Economy.BuildCostMass or 0) > 0 then
                --iCount = iCount + 1
                --if iCount >= 10 then break end
                ForkThread(RecordBlueprintThreatValues, oBP, sUnitId)
                ForkThread(CheckBlueprintSizeSupport, oBP, sUnitId)
            end
        end

        --Special eco checks - e.g. for mods that adjust resource mod of all units - will use UEF t3 mass fab as a rough proxy for this, if they both have the same ratio then will use this
        local oBP = __blueprints['ueb1303']

        local iMassRatio = 1
        if oBP then
            local iExpectedMass = 16
            if (oBP.Economy.ProductionPerSecondMass or 0) > iExpectedMass then
                iMassRatio =  (oBP.Economy.ProductionPerSecondMass or 0) / iExpectedMass
            end
        end
        local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
        M28Overseer.iMassFabRatio = iMassRatio


    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetUnitHealthPercent(oUnit)
    return oUnit:GetHealth() / oUnit:GetMaxHealth()
end

function GetCurrentAndMaximumShield(oUnit, bDontTreatLowPowerShieldAsZero)
    --Returns 0, 0 if unit has no shield, or 0, [max shield] if it has a shield but it is depleted
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetCurrentAndMaximumShield'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if oUnit.MyShield then
        local iCurShield = 0
        local iMaxShield = 0
        if oUnit.MyShield then
            iCurShield = oUnit.MyShield:GetHealth()
            iMaxShield = oUnit.MyShield:GetMaxHealth()
        else
            local tShield = oUnit:GetBlueprint().Defense
            if tShield then
                iCurShield = (oUnit:GetShieldRatio(false) or 0) * iMaxShield
            end
        end
        if iCurShield > 0 then
            if not(bDontTreatLowPowerShieldAsZero) then
                --GetHealth doesnt look like it factors in power stall
                if not(oUnit.MyShield.Enabled) or oUnit.MyShield.DepletedByEnergy or (oUnit:GetAIBrain():GetEconomyStored('ENERGY') == 0) then iCurShield = 0 end
            end
            if iCurShield > 0 and not(oUnit.MyShield:IsUp()) then
                --Occasional bug where shield shows as having health via gethealth, not powerstalling, but shield is actually down - below is to try and capture such cases
                if not(bDontTreatLowPowerShieldAsZero) or oUnit.MyShield.DepletedByDamage then
                    iCurShield = 0
                end
            end
        end
        if bDebugMessages == true then
            LOG(sFunctionRef..': iCurShield='..iCurShield..'; iMaxShield='..iMaxShield..'; ShieldRatio False='..oUnit:GetShieldRatio(false)..'; ShieldRatio true='..oUnit:GetShieldRatio(true)..' iCurShield='..iCurShield)
            if oUnit.MyShield then LOG('Unit has MyShield; IsUp='..tostring(oUnit.MyShield:IsUp())..'; shield health='..oUnit.MyShield:GetHealth()) end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return iCurShield, iMaxShield
    else
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return 0, 0
    end
end

function IsUnitShieldEnabled(oUnit)
    return not(oUnit[refbShieldIsDisabled])
end
function DisableUnitShield(oUnit)
    oUnit[refbShieldIsDisabled] = true
    oUnit:DisableShield()
end
function EnableUnitShield(oUnit)
    oUnit:EnableShield()
    oUnit[refbShieldIsDisabled] = false
end

function DisableUnitIntel(oUnit)
    oUnit:OnScriptBitSet(3)
end
function EnableUnitIntel(oUnit)
    oUnit:OnScriptBitClear(3)
end

function DisableUnitJamming(oUnit)
    oUnit:OnScriptBitSet(2)
end
function EnableUnitJamming(oUnit)
    oUnit:OnScriptBitClear(2)
end

function DisableUnitStealth(oUnit)
    oUnit:SetScriptBit('RULEUTC_StealthToggle', true)
    oUnit:SetScriptBit('RULEUTC_CloakToggle', true)
end

function EnableUnitStealth(oUnit)
    oUnit:SetScriptBit('RULEUTC_StealthToggle', false)
    oUnit:SetScriptBit('RULEUTC_CloakToggle', false)
end

function GetBlueprintMaxGroundRange(oBP)
--Simpler version of recordunitrange, intended at start of game to estimate whether a unit is a long range unit for threat calculations
    local iMaxRange = 0
    if oBP.Weapon then
        for iCurWeapon, oCurWeapon in oBP.Weapon do
            if oCurWeapon.MaxRadius > iMaxRange and not(oCurWeapon.EnabledByEnhancement) and oCurWeapon.Damage > 0 then
                if oCurWeapon.FireTargetLayerCapsTable and oCurWeapon.FireTargetLayerCapsTable['Land'] == 'Land|Water|Seabed' and not(oCurWeapon.ManualFire) then
                    iMaxRange = math.max(iMaxRange, oCurWeapon.MaxRadius)
                end
            end
        end
    end
    return iMaxRange
end

function GetBomberAOEAndStrikeDamage(oUnit)
    local oBP = oUnit:GetBlueprint()
    local iAOE = 0
    local iStrikeDamage = 0
    local iFiringRandomness
    for sWeaponRef, tWeapon in oBP.Weapon do
        if tWeapon.WeaponCategory == 'Bomb' or tWeapon.WeaponCategory == 'Direct Fire' then
            if (tWeapon.DamageRadius or 0) > iAOE then
                iAOE = tWeapon.DamageRadius
                iStrikeDamage = tWeapon.Damage * tWeapon.MuzzleSalvoSize
                if tWeapon.MuzzleSalvoSize > 2 then iStrikeDamage = iStrikeDamage * 0.5 end
                iFiringRandomness = (tWeapon.FiringRandomness or 0)
            end
        end
    end
    if iStrikeDamage == 0 then
        M28Utilities.ErrorHandler('Couldnt identify strike damage for bomber with ID '..oUnit.UnitId..'; will refer to predefined value instead')
    end

    --Manual floor for strike damage due to complexity of some bomber calculations
    --Check if manual override is higher, as some weapons will fire lots of shots so above method wont be accurate
    local tiBomberStrikeDamageByFactionAndTech =
    {
        --UEF, Aeon, Cybran, Sera, Nomads (are using default), Default
        { 150, 200, 155, 250, 150, 150 }, --Tech 1
        { 350, 300, 850, 1175, 550, 550 }, --Tech 2
        { 2500, 2500, 2500, 2500, 2500, 2500}, --Tech 3 - the strike damage calculation above should be accurate so this is just as a backup, and set at a low level due to potential for more balance changes affecting this
        { 11000,11000,11000,11000,11000,11000} --Tech 4 - again as a backup
    }
    iStrikeDamage = math.max(iStrikeDamage, tiBomberStrikeDamageByFactionAndTech[GetUnitTechLevel(oUnit)][GetFactionFromBP(oBP)])


    return iAOE, iStrikeDamage, iFiringRandomness
end

function GetUnitStrikeDamage(oUnit)
    --Gets strike damage of the first weapon in oUnit (longer term might want to make better so it considers other weapons)
    --For bombers will be subject to a minimum value as some bombers will have
    local oBP = oUnit:GetBlueprint()
    local sBP = oUnit.UnitId
    local iStrikeDamage = 0


    if EntityCategoryContains(refCategoryBomber, sBP) then
        --Doublecheck strike damage based on if it references a bomb
        local iAOE
        iAOE, iStrikeDamage = GetBomberAOEAndStrikeDamage(oUnit)
    elseif EntityCategoryContains(refCategoryTorpBomber, sBP) then
        for iCurWeapon, oCurWeapon in oBP.Weapon do
            if oCurWeapon.Label == 'Bomb' or oCurWeapon.Label == 'Torpedo' then
                iStrikeDamage = (oCurWeapon.DoTPulses or 1) * (oCurWeapon.MuzzleSalvoSize or 1) * oCurWeapon.Damage
                break
            end
        end
        if iStrikeDamage == 0 then
            iStrikeDamage = 750 --Backup
            M28Utilities.ErrorHandler('Have torp bomber with no bomb weapon so not calculated strike damage')
        end
    elseif EntityCategoryContains(refCategorySniperBot * categories.SERAPHIM, sBP) then
        iStrikeDamage = GetSniperStrikeDamage(oUnit)
    elseif oBP.Weapon and oBP.Weapon[1] then
        iStrikeDamage = oBP.Weapon[1].Damage
    end
        return iStrikeDamage
end

function RecordUnitRange(oUnit)
    --Updates unit range variables - sets to nil if it has nothing with that range, otherwise records it as the highest range it has.  Factors in enhancements. Also records if unit unpacks for T3 mobile arti
    --Also updates if unit can kite
    --Also records unit strike damage for certain air units
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordUnitRange'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local oBP = oUnit:GetBlueprint()
    local bWeaponUnpacks = false
    local bWeaponIsFixed = false
    local bReplaceValues, bIgnoreValues
    if oBP.Weapon then
        for iCurWeapon, oCurWeapon in oBP.Weapon do
            if not(oCurWeapon.EnabledByEnhancement) or (oCurWeapon.EnabledByEnhancement and oUnit.HasEnhancement and oUnit:HasEnhancement(oCurWeapon.EnabledByEnhancement)) then
                if oCurWeapon.ManualFire then
                    oUnit[refiManualRange] = math.max((oUnit[refiManualRange] or 0), oCurWeapon.MaxRadius)
                    oUnit[refiIndirectAOE] = math.max((oUnit[refiIndirectAOE] or 0), oCurWeapon.DamageRadius or 0)
                elseif oCurWeapon.RangeCategory == 'UWRC_Countermeasure' then
                    --Target restriction should catch all cases, have but the most common labels as redundancy as well (doesnt cover mega? and fatboy? torpedo defence which have antitorpedoleft, left1, left2, right, etc. labels)
                    if oCurWeapon.TargetRestrictOnlyAllow == "TORPEDO" or oCurWeapon.Label == 'AntiTorpedo' or oCurWeapon.Label == 'AntiTorpedo01' or oCurWeapon.Label == 'AntiTorpedoF' then
                        oUnit[refbHasTorpedoDefence] = true
                    else
                        oUnit[refiMissileDefenceRange] = math.max((oUnit[refiMissileDefenceRange] or 0), oCurWeapon.MaxRadius)
                    end
                elseif oCurWeapon.RangeCategory == 'UWRC_DirectFire' or (oCurWeapon.RangeCategory == 'UWRC_IndirectFire' and oCurWeapon.WeaponCategory == 'Direct Fire') then --Sera sniper bots have an 'indirectfire' range category that is actually DF
                    bReplaceValues = false
                    bIgnoreValues = false
                    --Monkeylord special - use main laser weapon values only
                    if oUnit.UnitId == 'url0402' and oUnit:GetAIBrain().M28AI then
                        if (not(oUnit[refiDFRange]) or oCurWeapon.Label == 'MainGun') then
                            bReplaceValues = true
                        else
                            bIgnoreValues = true
                        end
                    end
                    if bReplaceValues then
                        oUnit[refiDFRange] = (oCurWeapon.MaxRadius or 0)
                        oUnit[refiDFMinRange] = oCurWeapon.MinRadius
                        if (oCurWeapon.DamageRadius or 0) > 0 then oUnit[refiDFAOE] = oCurWeapon.DamageRadius end
                        if oCurWeapon.RateOfFire then oUnit[refiTimeBetweenDFShots] = 1 / oCurWeapon.RateOfFire end
                    elseif not(bIgnoreValues) then
                        oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius or 0)
                        if oCurWeapon.MinRadius then
                            if oUnit[refiDFMinRange] then oUnit[refiDFMinRange] = math.min(oUnit[refiDFMinRange], oCurWeapon.MinRadius)
                            else oUnit[refiDFMinRange] = oCurWeapon.MinRadius
                            end
                        end
                        if (oCurWeapon.DamageRadius or 0) > 0 then oUnit[refiDFAOE] = math.max((oUnit[refiDFAOE] or 0), oCurWeapon.DamageRadius) end
                        if oCurWeapon.RateOfFire then oUnit[refiTimeBetweenDFShots] = math.max((oUnit[refiTimeBetweenDFShots] or 0), 1 / oCurWeapon.RateOfFire) end
                    end

                elseif oCurWeapon.RangeCategory == 'UWRC_AntiNavy' then
                    oUnit[refiAntiNavyRange] = math.max((oUnit[refiAntiNavyRange] or 0), oCurWeapon.MaxRadius)
                elseif oCurWeapon.RangeCategory == 'UWRC_AntiAir' or oCurWeapon.WeaponCategory == 'Anti Air' then
                    oUnit[refiAARange] = math.max((oUnit[refiAARange] or 0), oCurWeapon.MaxRadius)
                elseif oCurWeapon.RangeCategory == 'UWRC_IndirectFire' then
                    --GC tractor claws - dont want to include as indirect fire weapon since logic is on the assumption indirect fire is good vs structures
                    if (oCurWeapon.Damage or 0) > 0.01 or not(oCurWeapon.WeaponCategory == 'Experimental') then
                        oUnit[refiIndirectRange] = math.max((oUnit[refiIndirectRange] or 0), oCurWeapon.MaxRadius)
                        if oCurWeapon.WeaponUnpacks then oUnit[refbWeaponUnpacks] = true end
                        oUnit[refiIndirectAOE] = math.max((oUnit[refiIndirectAOE] or 0), (oCurWeapon.DamageRadius or 0))
                        if oCurWeapon.RateOfFire then oUnit[refiTimeBetweenIFShots] = math.max((oUnit[refiTimeBetweenIFShots] or 0), 1 / oCurWeapon.RateOfFire) end
                    end
                elseif not(oCurWeapon.RangeCategory) or oCurWeapon.RangeCategory == 'UWRC_Undefined' then
                    if oCurWeapon.Label == 'Bomb' or oCurWeapon.DisplayName == 'Kamikaze' or oCurWeapon.Label == 'Torpedo' then
                        oUnit[refiBomberRange] = math.max((oUnit[refiBomberRange] or 0), oCurWeapon.MaxRadius)
                    elseif oCurWeapon.WeaponCategory == 'Direct Fire' or oCurWeapon.WeaponCategory == 'Direct Fire Experimental' or oCurWeapon.WeaponCategory == 'Kamikaze' then
                        oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                        if oCurWeapon.MinRadius then
                            if oUnit[refiDFMinRange] then oUnit[refiDFMinRange] = math.min(oUnit[refiDFMinRange], oCurWeapon.MinRadius)
                            else oUnit[refiDFMinRange] = oCurWeapon.MinRadius
                            end
                        end
                        if (oCurWeapon.DamageRadius or 0) > 0 then oUnit[refiDFAOE] = math.max((oUnit[refiDFAOE] or 0), oCurWeapon.DamageRadius) end
                        if oCurWeapon.RateOfFire then oUnit[refiTimeBetweenDFShots] = math.max((oUnit[refiTimeBetweenDFShots] or 0), 1 / oCurWeapon.RateOfFire) end
                    elseif oCurWeapon.WeaponCategory == 'Indirect Fire' then
                        oUnit[refiIndirectRange] = math.max((oUnit[refiIndirectRange] or 0), oCurWeapon.MaxRadius)
                    elseif (oCurWeapon.Damage or 0) == 0 or (oCurWeapon.MaxRadius or 0) <= 1 then
                        --Ignore
                    elseif oUnit.UnitId == 'uab4201' then
                        --Aeon TMD - ignore as it has a rangecategory for the weapon that uses the correct range so want to ignore the other waepon anyway
                    elseif oCurWeapon.WeaponCategory == 'Death' then
                        --Do nothing - e.g. units like energy storage
                    elseif oCurWeapon.WeaponCategory == 'Bomb' then
                        --experimental wars - experimental spaceships have a 'bomb' weapon category
                        if oCurWeapon.FireTargetLayerCapsTable and oCurWeapon.FireTargetLayerCapsTable['Land'] == 'Land|Water|Seabed' and not(oCurWeapon.ManualFire) and not(oCurWeapon.NeedToComputeBombDrop) then
                            oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), oCurWeapon.MaxRadius)
                            if oCurWeapon.MinRadius then
                                if oUnit[refiDFMinRange] then oUnit[refiDFMinRange] = math.min(oUnit[refiDFMinRange], oCurWeapon.MinRadius)
                                else oUnit[refiDFMinRange] = oCurWeapon.MinRadius
                                end
                            end
                        elseif EntityCategoryContains(categories.AIR * categories.MOBILE, oUnit.UnitId) then

                        else
                            M28Utilities.ErrorHandler('Unrecognised bomb weapon for unit '..oUnit.UnitId)
                        end
                    elseif oCurWeapon.WeaponCategory == 'Anti Navy' then
                        oUnit[refiAntiNavyRange] = math.max((oUnit[refiAntiNavyRange] or 0), oCurWeapon.MaxRadius)
                    else
                        M28Utilities.ErrorHandler('Unrecognised range category for unit '..oUnit.UnitId..'='..(oCurWeapon.WeaponCategory or 'nil'))
                        --If this triggers do a reprs of the weapon to figure out why (i.e. uncomment out the below)
                        --LOG('reprs of oCurWeapon='..reprs(oCurWeapon))
                    end
                else
                    M28Utilities.ErrorHandler('Unrecognised range category '..oCurWeapon.RangeCategory..' for unit '..oUnit.UnitId)
                end
            end
            if oCurWeapon.WeaponUnpacks and oCurWeapon.WeaponUnpackLocksMotion then bWeaponUnpacks = true
            elseif oCurWeapon.SlavedToBody or oCurWeapon.SlavedToTurret then bWeaponIsFixed = true
            end
            if bDebugMessages == true then
                LOG(sFunctionRef..': just Considered weapon '..oCurWeapon.Label..'; oUnit[refiDFRange]='..(oUnit[refiDFRange] or 'nil')..'; Indirect='..(oUnit[refiIndirectRange] or 'nil')..'; Manual='..(oUnit[refiManualRange] or 'nil')..'; oCurWeapon.EnabledByEnhancement='..(oCurWeapon.EnabledByEnhancement or 'nil'))
                if oCurWeapon.EnabledByEnhancement then
                    LOG('Have enhancement='..tostring(oUnit:HasEnhancement(oCurWeapon.EnabledByEnhancement)))
                end
            end
        end
        if M28Utilities.IsTableEmpty(oBP.Enhancements) == false and (oUnit[refiDFRange] or 0) > 0 then
            --Check if we have a max range in an enhancement
            for sEnhancement, tEnhancement in oBP.Enhancements do
                if tEnhancement.NewMaxRadius and oUnit.HasEnhancement and oUnit:HasEnhancement(sEnhancement) then
                    oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), tEnhancement.NewMaxRadius)
                end
            end
        end
        if not(bWeaponUnpacks or (bWeaponIsFixed and EntityCategoryContains(categories.EXPERIMENTAL - refCategoryFatboy, oUnit.UnitId))) then
            oUnit[refbCanKite] = true
        end

        --Special unit adjustments:
        --Seraphim sniperbot - want to enable long range if we own it
        if oUnit.GetAIBrain and oUnit:GetAIBrain().M28AI and EntityCategoryContains(refCategorySniperBot * categories.SERAPHIM, oUnit.UnitId) then
            EnableLongRangeSniper(oUnit)
            --LOG('Enabled long range on sniper, DFRange='..oUnit[refiDFRange]..'; Strike damage='..GetUnitStrikeDamage(oUnit))
        end
        --Fatboy - treat DF and indirect range as being the higher of its two ranges
        if EntityCategoryContains(refCategoryFatboy, oUnit.UnitId) then
            oUnit[refiDFRange] = math.max((oUnit[refiDFRange] or 0), (oUnit[refiIndirectRange] or 0))
            oUnit[refiIndirectRange] = oUnit[refiDFRange]
        end
        --LOG('Considering unitID '..(oUnit.UnitId or 'nil')..'; is unit valid='..tostring(IsUnitValid(oUnit)))
    end
    --Record unit best range
    oUnit[refiCombatRange] = math.max((oUnit[refiDFRange] or 0), (oUnit[refiIndirectRange] or 0), (oUnit[refiAntiNavyRange] or 0))
    oUnit[refiStrikeDamage] = GetUnitStrikeDamage(oUnit)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConvertTechLevelToCategory(iTechLevel)
    if iTechLevel == 2 then return categories.TECH2
    elseif iTechLevel == 3 then return categories.TECH3
    elseif iTechLevel == 4 then return categories.EXPERIMENTAL
    else return categories.TECH1
    end
end

function ConvertFactionToCategory(iFaction)
    if iFaction == refFactionUEF then return categories.UEF
    elseif iFaction == refFactionCybran then return categories.CYBRAN
    elseif iFaction == refFactionAeon then return categories.AEON
    elseif iFaction == refFactionSeraphim then return categories.SERAPHIM
    else return categories.ALLUNITS -categories.UEF -categories.CYBRAN -categories.AEON -categories.SERAPHIM
    end
end

function GetUnitUpgradeBlueprint(oUnitToUpgrade, bGetSupportFactory)
    --Returns support factory ID if it can be built, otherwise returns normal upgrade unit (works for any unit, not just factory)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnitUpgradeBlueprint'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bGetSupportFactory == nil then bGetSupportFactory = true end
    --Gets the support factory blueprint, and checks if it can be built; if not then returns the normal UpgradesTo blueprint
    local sUpgradeBP
    if not(oUnitToUpgrade.Dead) and oUnitToUpgrade.CanBuild then
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, UnitToUpgrade='..oUnitToUpgrade.UnitId..GetUnitLifetimeCount(oUnitToUpgrade)) end
        if bGetSupportFactory == true and oUnitToUpgrade.CanBuild then
            local tsSupportFactoryBP = {

                -- Aeon
                ['uab0101']  = 'zab9501',
                ['uab0102']  = 'zab9502',
                ['uab0103']  = 'zab9503',
                ['uab0201'] = 'zab9601',
                ['uab0202'] = 'zab9602',
                ['uab0203'] = 'zab9603',

                -- UEF
                ['ueb0101']  = 'zeb9501',
                ['ueb0102']  = 'zeb9502',
                ['ueb0103']  = 'zeb9503',
                ['ueb0201'] = 'zeb9601',
                ['ueb0202'] = 'zeb9602',
                ['ueb0203'] = 'zeb9603',

                -- Cybran
                ['urb0101']  = 'zrb9501',
                ['urb0102']  = 'zrb9502',
                ['urb0103']  = 'zrb9503',
                ['urb0201'] = 'zrb9601',
                ['urb0202'] = 'zrb9602',
                ['urb0203'] = 'zrb9603',

                -- Seraphim
                ['xsb0101']  = 'zsb9501',
                ['xsb0102']  = 'zsb9502',
                ['xsb0103']  = 'zsb9503',
                ['xsb0201'] = 'zsb9601',
                ['xsb0202'] = 'zsb9602',
                ['xsb0203'] = 'zsb9603',

                -- Seraphim
                ['xsb0101']  = 'zsb9501',
                ['xsb0102']  = 'zsb9502',
                ['xsb0103']  = 'zsb9503',
                ['xsb0201'] = 'zsb9601',
                ['xsb0202'] = 'zsb9602',
                ['xsb0203'] = 'zsb9603',
            }

            local sFactoryBP = oUnitToUpgrade.UnitId
            if tsSupportFactoryBP[sFactoryBP] then
                if bDebugMessages == true then LOG(sFunctionRef..': Support factoryBP='..tsSupportFactoryBP[sFactoryBP]) end
                sUpgradeBP = tsSupportFactoryBP[sFactoryBP]
                if bDebugMessages == true then LOG(sFunctionRef..': oUnitToUpgrade='..sFactoryBP..GetUnitLifetimeCount(oUnitToUpgrade)..'; Checking if can upgrade to sUpgradeBP='..sUpgradeBP..'; oUnitToUpgrade:CanBuild(sUpgradeBP)='..tostring(oUnitToUpgrade:CanBuild(sUpgradeBP))) end
                if not(oUnitToUpgrade:CanBuild(sUpgradeBP)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Cant build '..sUpgradeBP) end
                    sUpgradeBP = nil
                end
            end
        end
        if not(sUpgradeBP) then
            local oFactoryBP = oUnitToUpgrade:GetBlueprint()
            sUpgradeBP = oFactoryBP.General.UpgradesTo
            if bDebugMessages == true then LOG(sFunctionRef..': sUpgradeBP='..(sUpgradeBP or 'nil')) end
            if not(sUpgradeBP) or sUpgradeBP == '' or not(oUnitToUpgrade:CanBuild(sUpgradeBP)) then sUpgradeBP = nil end
            if bDebugMessages == true then LOG(sFunctionRef..': Didnt have valid support factory to upgrade to; blueprint UpgradesTo='..(sUpgradeBP or 'nil')) end
        end
        if sUpgradeBP == '' then
            sUpgradeBP = nil
            if bDebugMessages == true then LOG(sFunctionRef..': Have no blueprint to upgrade to') end
        elseif bDebugMessages == true then LOG(sFunctionRef..': Returning sUpgradeBP '..(sUpgradeBP or 'nil')..' subject to final unit restriction check')
        end
    end

    if sUpgradeBP then
        if not(oUnitToUpgrade:CanBuild(sUpgradeBP)) then
            if bDebugMessages == true then LOG(sFunctionRef..': oUnitToUpgrade '..oUnitToUpgrade.UnitId..GetUnitLifetimeCount(oUnitToUpgrade)..' cant build sUpgradeBP='..sUpgradeBP..' e.g. due to unit restrictions') end
            sUpgradeBP = nil
        else
            local Game = import("/lua/game.lua")
            local iArmyIndex = oUnitToUpgrade.Army
            if bDebugMessages == true then LOG(sFunctionRef..': oUnitToUpgrade '..oUnitToUpgrade.UnitId..GetUnitLifetimeCount(oUnitToUpgrade)..' checking if is restricted for sUpgradeBP='..sUpgradeBP..', isrestricted='..tostring(Game.IsRestricted(sUpgradeBP, iArmyIndex))) end
            if Game.IsRestricted(sUpgradeBP, iArmyIndex) then
                sUpgradeBP = nil
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return sUpgradeBP
end

function DoesCategoryContainCategoryUSEM28UTILITIESVERSION()
end

function GetUpgradeBuildTime(oUnit, sUpgradeRef)
    --Returns nil if unit cant get enhancements
    local oBP = oUnit:GetBlueprint()
    local iUpgradeTime
    if oBP.Enhancements then
        for sUpgradeID, tUpgrade in oBP.Enhancements do
            if sUpgradeID == sUpgradeRef then
                iUpgradeTime = tUpgrade.BuildTime
            end

        end
    end
    return iUpgradeTime
end

function GetUpgradeMassCost(oUnit, sUpgradeRef)
    local oBP = oUnit:GetBlueprint()
    local iUpgradeMass
    if oBP.Enhancements then
        for sUpgradeID, tUpgrade in oBP.Enhancements do
            if sUpgradeID == sUpgradeRef then
                iUpgradeMass = tUpgrade.BuildCostMass
            end

        end
    end
    if not(iUpgradeMass) then M28Utilities.ErrorHandler('oUnit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' has no upgrade with reference '..sUpgradeRef) end
    return iUpgradeMass
end

function GetUpgradeEnergyCost(oUnit, sUpgradeRef)
    local oBP = oUnit:GetBlueprint()
    local iUpgradeEnergy
    if oBP.Enhancements then
        for sUpgradeID, tUpgrade in oBP.Enhancements do
            if sUpgradeID == sUpgradeRef then
                iUpgradeEnergy = tUpgrade.BuildCostEnergy
            end

        end
    end
    if not(iUpgradeEnergy) then M28Utilities.ErrorHandler('oUnit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' has no upgrade with reference '..sUpgradeRef) end
    return iUpgradeEnergy
end

function AddOrRemoveUnitFromListOfPausedUnits(oUnit, bPauseNotUnpause)
    local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
    --Remove from list of paused units

    if not(bPauseNotUnpause) then
        if oUnit[refbPaused] then
            local aiBrain = oUnit:GetAIBrain()
            if M28Utilities.IsTableEmpty(aiBrain[M28Economy.reftPausedUnits]) == false then
                for iPausedUnit, oPausedUnit in aiBrain[M28Economy.reftPausedUnits] do
                    if oPausedUnit == oUnit then
                        --LOG('AddOrRemoveUnitFromListOfPausedUnits: Removing unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' from table of paused units')
                        table.remove(aiBrain[M28Economy.reftPausedUnits], iPausedUnit)
                        break
                    end
                end
            end
        end
    else
        --Are pausing unit, make sure it is in the table of paused units
        if not(oUnit[refbPaused]) then
            local aiBrain = oUnit:GetAIBrain()
            local bRecordUnit = true
            if M28Utilities.IsTableEmpty(aiBrain[M28Economy.reftPausedUnits]) == false then
                --Check if already recorded - redundancy due to nasty near-infinite loop in M27 where it could keep adding units to the table resulting in the same unit considered 20+ times
                for iRecordedUnit, oRecordedUnit in aiBrain[M28Economy.reftPausedUnits] do
                    if oRecordedUnit == oUnit then
                        bRecordUnit = false
                        break
                    end
                end
            end
            if bRecordUnit then
                --LOG('AddOrRemoveUnitFromListOfPausedUnits: Adding unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' to table of paused units')
                table.insert(aiBrain[M28Economy.reftPausedUnits], oUnit)
            end
        end
    end
end

function PauseOrUnpauseMassUsage(oUnit, bPauseNotUnpause)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'PauseOrUnpauseMassUsage'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then
        local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
        LOG(sFunctionRef..': Start of code time='..GetGameTimeSeconds()..', oUnit='..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; Unit state='..GetUnitState(oUnit)..'; Engineer action (if have one)='..(oUnit[M28Engineer.refiAssignedAction] or 'nil')..'; oUnit:IsPaused='..tostring(oUnit:IsPaused()))
        if oUnit.GetWorkProgress then LOG(sFunctionRef..': Unit work progress='..oUnit:GetWorkProgress()) end
    end

    if IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 and oUnit.SetPaused then
        AddOrRemoveUnitFromListOfPausedUnits(oUnit, bPauseNotUnpause)

        --Want to pause unit, check for any special logic for pausing
        --Normal logic - just pause unit - exception if are dealing with a factory whose workcomplete is 100% and want to pause it
        if (not(bPauseNotUnpause) or not(oUnit:IsPaused())) and (not(EntityCategoryContains(refCategoryFactory, oUnit.UnitId)) or (oUnit.GetWorkProgress and oUnit:GetWorkProgress() > 0 and oUnit:GetWorkProgress() < 1) or (oUnit:IsPaused() and not(bPauseNotUnpause))) then

            if oUnit.UnitId == 'xsb2401' and bPauseNotUnpause then M28Utilities.ErrorHandler('Pausing Yolona') end
            if bDebugMessages == true then LOG(sFunctionRef..': About to set paused to '..tostring(bPauseNotUnpause)..' for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' Unit state='..GetUnitState(oUnit))
                if oUnit.GetWorkProgress then LOG(sFunctionRef..': Unit work progress='..oUnit:GetWorkProgress()) end
            end
            oUnit:SetPaused(bPauseNotUnpause)
            oUnit[refbPaused] = bPauseNotUnpause
            --If unit isnt actually paused (e.g. due to error with set paused) then clear this flag
            if oUnit[refbPaused] and not(oUnit:IsPaused()) then
                oUnit[refbPaused] = false
                if bDebugMessages == true then LOG(sFunctionRef..': Unit isnt actually paused so wont set this flag') end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Just set paused to '..tostring(bPauseNotUnpause)..' for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)) end
        elseif bDebugMessages == true then
            LOG(sFunctionRef..': Factory with either no workprogress or workprogress that isnt <1')
            if oUnit.GetWorkProgress then LOG(sFunctionRef..': Workprogress='..oUnit:GetWorkProgress()) end
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Unit isnt valid') end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, unit paused flag='..tostring(oUnit[refbPaused] or false)) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function PauseOrUnpauseEnergyUsage(oUnit, bPauseNotUnpause, bExcludeProduction)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'PauseOrUnpauseEnergyUsage'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then
        LOG(sFunctionRef..': Start of code time='..GetGameTimeSeconds()..', oUnit='..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' owned by brain '..oUnit:GetAIBrain().Nickname..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; Unit state='..GetUnitState(oUnit)..'; Unit is paused='..tostring(oUnit:IsPaused())..'; bExcludeProduction='..tostring(bExcludeProduction or false))
        if oUnit.GetFocusUnit and oUnit:GetFocusUnit() then LOG(sFunctionRef..': Focus unit='..oUnit:GetFocusUnit().UnitId..GetUnitLifetimeCount(oUnit:GetFocusUnit())) end
        if oUnit.GetWorkProgress then LOG(sFunctionRef..': Unit work progress='..oUnit:GetWorkProgress()..'; Unit fraction complete='..oUnit:GetFractionComplete()..'; Is arti template nil='..tostring(oUnit[import('/mods/M28AI/lua/AI/M28Building.lua').reftArtiTemplateRefs] == nil)) end
    end
    if IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 and oUnit.SetPaused then
        --Normal logic - just pause unit - exception if are dealing with a factory whose workcomplete is 100%
        --Want this to run before the later stages so can properly track if unit is paused
        if not(bExcludeProduction) or bPauseNotUnpause then
            AddOrRemoveUnitFromListOfPausedUnits(oUnit, bPauseNotUnpause)

            if oUnit.SetPaused and (not(bPauseNotUnpause) or not(oUnit:IsPaused())) and (not(EntityCategoryContains(refCategoryFactory, oUnit.UnitId)) or (oUnit.GetWorkProgress and oUnit:GetWorkProgress() > 0 and oUnit:GetWorkProgress() < 1)) then
                if oUnit.UnitId == 'xsb2401'  and bPauseNotUnpause then M28Utilities.ErrorHandler('Pausing Yolona') end
                if bDebugMessages == true then LOG(sFunctionRef..': About to set paused to '..tostring(bPauseNotUnpause)..' for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; Unit state='..GetUnitState(oUnit))
                    if oUnit.GetWorkProgress then LOG(sFunctionRef..': Unit work progress='..oUnit:GetWorkProgress()) end
                end
                oUnit:SetPaused(bPauseNotUnpause)
                oUnit[refbPaused] = bPauseNotUnpause
                --If unit isnt actually paused (e.g. due to error with set paused) then clear this flag
                if oUnit[refbPaused] and not(oUnit:IsPaused()) then
                    oUnit[refbPaused] = false
                    if bDebugMessages == true then LOG(sFunctionRef..': Unit isnt actually paused so wont set this flag (but will change back to paused later if we pause energy requiring abilities)') end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Just set paused to '..tostring(bPauseNotUnpause)..' for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)) end
            elseif bDebugMessages == true then
                LOG(sFunctionRef..': Factory with either no workprogress or workprogress that isnt <1; is .SetPaused nil='..tostring(oUnit.SetPaused == nil)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; Unit[refbPaused]='..tostring(oUnit[refbPaused])..'; fraction complete='..oUnit:GetFractionComplete()..'; Is unit a factory='..tostring(EntityCategoryContains(refCategoryFactory, oUnit.UnitId)))
                if oUnit.GetWorkProgress then LOG(sFunctionRef..': Workprogress='..oUnit:GetWorkProgress()) end
            end
        end


        --Jamming - check via blueprint since no reliable category
        local oBP = oUnit:GetBlueprint()
        if oBP.Intel.JamRadius then
            if bPauseNotUnpause then DisableUnitJamming(oUnit)
            else EnableUnitJamming(oUnit)
            end
        end

        --Want to pause/unpause unit, check for any special logic for pausing
        --local bWasUnitPaused = (oUnit[refbPaused] or false)
        if oUnit.MyShield and oUnit.MyShield:GetMaxHealth() > 0 then
            if IsUnitShieldEnabled(oUnit) == bPauseNotUnpause then
                if bPauseNotUnpause then DisableUnitShield(oUnit)
                else EnableUnitShield(oUnit) end
                oUnit[refbPaused] = bPauseNotUnpause
            end
        elseif oBP.Intel.ReactivateTime and (oBP.Intel.SonarRadius or oBP.Intel.RadarRadius) then
            if bPauseNotUnpause then DisableUnitIntel(oUnit)
            else EnableUnitIntel(oUnit)
            end
            oUnit[refbPaused] = bPauseNotUnpause
        elseif oBP.Intel.Cloak or oBP.Intel.RadarStealth or oBP.Intel.RadarStealthFieldRadius then
            if bPauseNotUnpause then DisableUnitStealth(oUnit)
            else EnableUnitStealth(oUnit)
            end
            oUnit[refbPaused] = bPauseNotUnpause
        end

    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function GetFactionFromBP(oBlueprint)
    --Returns faction number for oBlueprint
    --1: UEF, 2: Aeon, 3: Cybran, 4: Seraphim, 5: Nomads, 6 = not recognised
    --Note: General.FactionName property uses lowercase for some factions; the categories.x uses upper case
    --Assumed nomads is Nomads

    local tFactionsByName = {[refFactionUEF] = 'UEF', [refFactionAeon] = 'Aeon', [refFactionCybran] = 'Cybran', [refFactionSeraphim] = 'Seraphim', [refFactionNomads] = 'Nomads'}
    local sUnitFactionName = oBlueprint.General.FactionName
    for iName, sName in tFactionsByName do
        if sName == sUnitFactionName then return iName end
    end
    return refFactionUnrecognised
end

function GetFactionNumberFromBlueprint(sBlueprint)
    if EntityCategoryContains(categories.UEF, sBlueprint) then return refFactionUEF
    elseif EntityCategoryContains(categories.AEON, sBlueprint) then return refFactionAeon
    elseif EntityCategoryContains(categories.CYBRAN, sBlueprint) then return refFactionCybran
    elseif EntityCategoryContains(categories.SERAPHIM, sBlueprint) then return refFactionSeraphim
    else return refFactionUnrecognised
    end
end

function GetUnitFaction(oUnit)
    ----1: UEF, 2: Aeon, 3: Cybran, 4: Seraphim, 5: Nomads, 6 = not recognised
    return GetFactionFromBP(oUnit:GetBlueprint())
end

function GetFactoryType(oUnit)
    local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua') --Putting this at the top crashes the game

    if EntityCategoryContains(refCategoryLandFactory, oUnit.UnitId) then
        return M28Factory.refiFactoryTypeLand, refCategoryLandFactory
    elseif EntityCategoryContains(refCategoryAirFactory, oUnit.UnitId) then
        return M28Factory.refiFactoryTypeAir, refCategoryAirFactory
    elseif EntityCategoryContains(refCategoryNavalFactory, oUnit.UnitId) then
        return M28Factory.refiFactoryTypeNaval, refCategoryNavalFactory
    else return M28Factory.refiFactoryTypeOther, categories.FACTORY
    end
end

function GetUnitFacingAngle(oUnit)
    --0/360 = north, 90 = west, 180 = south, 270 = east

    --T3 arti - get the angle of the turret
    if EntityCategoryContains(categories.STRUCTURE * categories.DIRECTFIRE + categories.STRUCTURE * categories.INDIRECTFIRE, oUnit.UnitId) then
        if oUnit.GetWeapon and oUnit:GetWeaponCount() > 0 then
            --LOG('GetFacingAngle: oUnit='..oUnit.UnitId..GetUnitLifetimeCount(oUnit))
            local oWeapon = oUnit:GetWeapon(1)
            if oWeapon and oWeapon.GetAimManipulator and oWeapon:GetAimManipulator().GetHeadingPitch then
                return M28Utilities.ConvertRadiansToAngle(oWeapon:GetAimManipulator():GetHeadingPitch())
            else return 0
            end
        else return 0
        end
        if oUnit:IsValidBone('Turret') then
            --0% = south, 25% = east, 50% = north; want to convert from % into angle where 0 is north
            return M28Utilities.ConvertCounterclockwisePercentageToAngle(oUnit:GetBoneDirection('Turret'))
        else
            return 180 - oUnit:GetHeading() / math.pi * 180 --redundancy - for a building this is likeliy to be the same value every time
        end
    else
        --Other units (would expect to be mobile) - get the unit direction
        return 180 - oUnit:GetHeading() / math.pi * 180
    end

end

function IsUnitUnderwater(oUnit)
    if oUnit.GetPosition and oUnit.GetBlueprint then
        if EntityCategoryContains(categories.SUBMERSIBLE, oUnit.UnitId) then
            --E.g. tempest - sizey is 4, but when it is submerged it is only 2.6 below water level
            return M28Map.IsUnderwater({oUnit:GetPosition()[1], oUnit:GetPosition()[2] + (oUnit:GetBlueprint().SizeY or 0) * 0.5, oUnit:GetPosition()[3]}, false)
        else
            return M28Map.IsUnderwater({oUnit:GetPosition()[1], oUnit:GetPosition()[2] + (oUnit:GetBlueprint().SizeY or 0), oUnit:GetPosition()[3]}, false)
        end
    else return false
    end
end

function GetUnitUniqueRef(oUnit)
    return oUnit:GetAIBrain():GetArmyIndex()..oUnit.UnitId..GetUnitLifetimeCount(oUnit)
end

function GetClampsByType(oTransport)
    --small, medium, large, experimental, and stinger,
    --    refClampSmall = 1
    --    refClampMedium = 2
    --    refClampLarge = 3
    --    refClampExperimental = 4 --Incase ever decide to support nomads experimental transports
    --    refClampStinger = 5
    local tiClampsByType = {
        ['uea0203'] = { [refClampSmall] = 0, [refClampMedium] = 0, [refClampLarge] = 0, [refClampExperimental] = 0, [refClampStinger] = 1 }, --Stinger
        ['uea0107'] = { [refClampSmall] = 2, [refClampMedium] = 0, [refClampLarge] = 1, [refClampExperimental] = 0, [refClampStinger] = 0 }, --UEF T1
        ['ura0107'] = { [refClampSmall] = 2, [refClampMedium] = 0, [refClampLarge] = 1, [refClampExperimental] = 0, [refClampStinger] = 0 }, --Cybran t1
        ['uaa0107'] = { [refClampSmall] = 2, [refClampMedium] = 0, [refClampLarge] = 1, [refClampExperimental] = 0, [refClampStinger] = 0 }, --Aeon T1 (in some cases it can carry more)
        ['xsa0107'] = { [refClampSmall] = 0, [refClampMedium] = 2, [refClampLarge] = 1, [refClampExperimental] = 0, [refClampStinger] = 0 }, --Sera T1
        ['uea0104'] = { [refClampSmall] = 2, [refClampMedium] = 0, [refClampLarge] = 3, [refClampExperimental] = 0, [refClampStinger] = 0 }, --UEF T2
        ['ura0104'] = { [refClampSmall] = 2, [refClampMedium] = 0, [refClampLarge] = 2, [refClampExperimental] = 0, [refClampStinger] = 0 }, --Cybran T2
        ['uaa0104'] = { [refClampSmall] = 4, [refClampMedium] = 0, [refClampLarge] = 2, [refClampExperimental] = 0, [refClampStinger] = 0 }, --Aeon T2 (in some cases it can carry more)
        ['xsa0104'] = { [refClampSmall] = 0, [refClampMedium] = 0, [refClampLarge] = 4, [refClampExperimental] = 0, [refClampStinger] = 0 }, --Sera T2
        ['xea0306'] = { [refClampSmall] = 4, [refClampMedium] = 0, [refClampLarge] = 6, [refClampExperimental] = 0, [refClampStinger] = 0 }, --UEF T3
    }
    local tiUnitClampsByType =  tiClampsByType[oTransport.UnitId]
    if not(tiUnitClampsByType) then
        if EntityCategoryContains(categories.TECH1, oTransport.UnitId) then tiUnitClampsByType =  tiClampsByType['uea0107']
        else tiUnitClampsByType = tiClampsByType['ura0104']
        end
    end
    return tiUnitClampsByType
end

function GetTransportMaxCapacity(oTransport, iTechLevelToLoad)
    --https://forums.faforever.com/viewtopic.php?f=2&t=17511#:~:text=It%20can%20carry%20exactly%201,and%20more%20T2%20than%20T3.
    local iFaction = GetUnitFaction(oTransport)
    local tiCapacityByTechAndFaction --[TransportTechLevel][FactionNumber][UnitTechToHold]
    if EntityCategoryContains(categories.UEF * categories.GROUNDATTACK * categories.TECH2 * categories.AIR, oTransport.UnitId) then
        tiCapacityByTechAndFaction = {[2]={[refFactionUEF]={[1]=1,[2]=1,[3]=0,[4]=0}}}
    else tiCapacityByTechAndFaction =
    {[1]={ --T1 transports
        [refFactionUEF]={[1]=6,[2]=2,[3]=1,[4]=0},
        [refFactionAeon]={[1]=6,[2]=3,[3]=1,[4]=0},
        [refFactionCybran]={[1]=6,[2]=2,[3]=1,[4]=0},
        [refFactionSeraphim]={[1]=8,[2]=4,[3]=1,[4]=0},
        [refFactionNomads]={[1]=4,[2]=2,[3]=0,[4]=0}, --Assumed
        [refFactionUnrecognised]={[1]=2,[2]=1,[3]=0,[4]=0}, --assumed
    },
     [2]={
         [refFactionUEF]={[1]=14,[2]=6,[3]=3,[4]=0},
         [refFactionAeon]={[1]=12,[2]=6,[3]=2,[4]=0},
         [refFactionCybran]={[1]=10,[2]=4,[3]=2,[4]=0},
         [refFactionSeraphim]={[1]=16,[2]=8,[3]=4,[4]=0},
         [refFactionNomads]={[1]=8,[2]=4,[3]=2,[4]=0}, --Assumed
         [refFactionUnrecognised]={[1]=2,[2]=1,[3]=0,[4]=0}, --assumed
     },
     [3]={
         [refFactionUEF]={[1]=28,[2]=12,[3]=6,[4]=0},
         [refFactionAeon]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionCybran]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionSeraphim]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionNomads]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionUnrecognised]={[1]=1,[2]=1,[3]=1,[4]=0},
     },
     [4]={ --dummy values
         [refFactionUEF]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionAeon]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionCybran]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionSeraphim]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionNomads]={[1]=1,[2]=1,[3]=1,[4]=0},
         [refFactionUnrecognised]={[1]=1,[2]=1,[3]=1,[4]=0},
     },
    }
    end

    return tiCapacityByTechAndFaction[GetUnitTechLevel(oTransport)][iFaction][iTechLevelToLoad]
end

function GetACUShieldRegenRate(oUnit)
    --Cycles through every possible enhancement, sees if the unit has it, and if so what its shield regen rate is, and returns the max value
    local iRegenRate = 0
    if oUnit.HasEnhancement then
        local oBP = oUnit:GetBlueprint()
        if M28Utilities.IsTableEmpty(oBP.Enhancements) == false then
            for sEnhancement, tEnhancement in oBP.Enhancements do
                if oUnit:HasEnhancement(sEnhancement) and tEnhancement.ShieldRegenRate then
                    iRegenRate = math.max(iRegenRate, tEnhancement.ShieldRegenRate)
                end
            end
        end
    end
    return iRegenRate
end

function GetUnitHealthRegenRate(oUnit)
    --Cycles through every ACU enhancement and factors it into its health regen, along with veterancy
    local oBP = oUnit:GetBlueprint()
    local iRegenRate = (oBP.Defense.RegenRate or 0)

    --Adjust for veterancy:
    local iVetLevel = (oUnit.VetLevel or oUnit.Sync.VeteranLevel or 0)
    if iVetLevel > 0 and oBP.Buffs.Regen then
        local iCurVet = 0
        for iVet, iRegenMod in oBP.Buffs.Regen do
            iCurVet = iCurVet + 1
            if iCurVet == iVetLevel then
                iRegenRate = iRegenRate + iRegenMod
                break
            end
        end
    end

    --Adjust for enhancements
    if M28Utilities.IsTableEmpty(oBP.Enhancements) == false and oUnit.HasEnhancement then
        for iEnhancement, tEnhancement in oBP.Enhancements do
            if tEnhancement.NewRegenRate and oUnit:HasEnhancement(iEnhancement) then
                iRegenRate = iRegenRate + tEnhancement.NewRegenRate
            end
        end
    end

    return iRegenRate

end

function SetUnitWeaponTargetPriorities(oUnit, tPriorityTable, bCheckIfCanAttackGround)
    if IsUnitValid(oUnit) then
        if EntityCategoryContains(refCategoryMAA, oUnit) then M28Utilities.ErrorHandler('Changing weapon priority for MAA') end
        for i =1, oUnit:GetWeaponCount() do
            local wep = oUnit:GetWeapon(i)
            if not(bCheckIfCanAttackGround) or not(wep.CannotAttackGround) then
                wep:SetWeaponPriorities(tPriorityTable)
            end
        end
    end
end

function GetLauncherAOEStrikeDamageMinAndMaxRange(oUnit)
    local oBP = oUnit:GetBlueprint()
    local iAOE = 0
    local iStrikeDamage = 0
    local iMinRange = 0
    local iMaxRange = 0
    local iSalvoSize = 1
    local iSalvoIndividualDelay
    for sWeaponRef, tWeapon in oBP.Weapon do
        if not(tWeapon.WeaponCategory == 'Death') then
            if (tWeapon.DamageRadius or 0) > iAOE then
                iAOE = tWeapon.DamageRadius
                iStrikeDamage = tWeapon.Damage * tWeapon.MuzzleSalvoSize
                if (tWeapon.FixedSpreadRadius or 0) >= 20 then --e.g. scathis
                    iStrikeDamage = math.min(iStrikeDamage, tWeapon.Damage * math.min(3, tWeapon.MuzzleSalvoSize * 0.5))
                end
                iSalvoSize = (tWeapon.MuzzleSalvoSize or 1)
                iSalvoIndividualDelay = (tWeapon.MuzzleSalvoDelay or 0.1)
            elseif (tWeapon.NukeInnerRingRadius or 0) > 0 and (tWeapon.NukeInnerRingDamage or 0) >= iStrikeDamage then
                iAOE = tWeapon.NukeInnerRingRadius
                iStrikeDamage = tWeapon.NukeInnerRingDamage
                iSalvoSize = (tWeapon.MuzzleSalvoSize or 1)
                iSalvoIndividualDelay = (tWeapon.MuzzleSalvoDelay or 0.1)
            end
            if (tWeapon.MinRadius or 0) > iMinRange then iMinRange = tWeapon.MinRadius end
            if (tWeapon.MaxRadius or 0) > iMaxRange then iMaxRange = tWeapon.MaxRadius end
        end
    end
    return iAOE, iStrikeDamage, iMinRange, iMaxRange, iSalvoSize, iSalvoIndividualDelay
end

function GetSniperStrikeDamage(oUnit)
    local iStrikeDamage
    local oBP = oUnit:GetBlueprint()
    local sWeaponTypeRequired
    if EntityCategoryContains(refCategorySniperBot * categories.SERAPHIM, oUnit.UnitId) then
        if oUnit[refbSniperRifleEnabled] and table.getn(oBP.Weapon) > 1 then sWeaponTypeRequired = 'SniperGun' end
    end

    if oBP.Weapon then
        for iWeapon, tWeapon in oBP.Weapon do
            if tWeapon.WeaponCategory == 'Direct Fire' then
                if not(sWeaponTypeRequired) or tWeapon.Label == sWeaponTypeRequired then
                    if iStrikeDamage then iStrikeDamage = math.min(iStrikeDamage, tWeapon.Damage)
                    else iStrikeDamage = tWeapon.Damage
                    end
                end
            end
        end
    end
    if not(iStrikeDamage) then iStrikeDamage = 100 end
    return iStrikeDamage
end

function EnableLongRangeSniper(oUnit)
    --If unit has a sniper weapon, then toggle it
    if oUnit.SetWeaponEnabledByLabel and not(oUnit[refbSniperRifleEnabled]) then
        local oBP = oUnit:GetBlueprint()
        local bHaveSniperWeapon = false
        if oBP.Weapon then
            for iWeapon, tWeapon in oBP.Weapon do
                if tWeapon.Label == 'SniperGun' then
                    bHaveSniperWeapon = true
                    break
                end
            end
        end

        if bHaveSniperWeapon then
            oUnit:OnScriptBitSet(1)
            oUnit[refbSniperRifleEnabled] = true
            --LOG('Enabled sniperrifle on unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit))
        end
    end
end


function DisableLongRangeSniper(oUnit)
    M28Utilities.ErrorHandler('need to update sniper bot range if disabling long range sniper, for now have a hardcoded fix') --hardcoded value is oUnit[refiDFRange] = 65
    if oUnit.SetWeaponEnabledByLabel and oUnit[refbSniperRifleEnabled] then
        local bHaveSniperWeapon = true
        local oBP = oUnit:GetBlueprint()
        if oBP.Weapon then
            for iWeapon, tWeapon in oBP.Weapon do
                if tWeapon.Label == 'SniperGun' then
                    bHaveSniperWeapon = true
                    break
                end
            end
        end
        if bHaveSniperWeapon then
            oUnit:OnScriptBitClear(1)
            oUnit[refbSniperRifleEnabled] = false
            --LOG('Disabled long range sniper on unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit))
        end
        oUnit[refiDFRange] = 65
    end
end

function GetMissileCount(oUnit)
    local iMissiles = 0 --NOTE: If this is called at the moment a missile is loaded, then this should be set to 1; only use this function for general checks
    if oUnit.GetTacticalSiloAmmoCount then iMissiles = iMissiles + oUnit:GetTacticalSiloAmmoCount() end
    if oUnit.GetNukeSiloAmmoCount then iMissiles = iMissiles + oUnit:GetNukeSiloAmmoCount() end
    return iMissiles
end

function GiveUnitTemporaryVision(oUnit, iVision)
    --LOG('Applying temporary vision buff at time='..GetGameTimeSeconds())
    local Buff = import('/lua/sim/Buff.lua')
    if not Buffs['CrateVisBuff'] then
        BuffBlueprint {
            Name = 'CrateVisBuff',
            DisplayName = 'CrateVisBuff',
            BuffType = 'CrateVisBuff',
            Stacks = 'ALWAYS',
            Duration = 3,
            Affects = {
                VisionRadius = {
                    Add = iVision,
                    Mult = 1,
                },
            },
        }
    end
    Buff.ApplyBuff(oUnit, 'CrateVisBuff')
end

function ToggleUnitDiveOrSurfaceStatus(oUnit)
    --Assumes have already checked that the unit is or isnt underwater
    if not(oUnit[refbSpecialMicroActive]) or GetGameTimeSeconds() > oUnit[refiGameTimeToResetMicroActive] then
        local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
        M28Orders.IssueTrackedClearCommands(oUnit)
        IssueDive({oUnit})
        local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')
        M28Micro.TrackTemporaryUnitMicro(oUnit, 3)
    end
end

function FixUnitResourceCheatModifiers(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'FixUnitResourceCheatModifiers'

    --As of May 2023, AiX resource multipliers dont apply to upgrades such as for RAS SACUs.  The below attempts to fix this.
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if IsUnitValid(oUnit) and oUnit:GetAIBrain().CheatEnabled then
        local FAFBuffs = import('/lua/sim/Buff.lua')
        --local iBuildModifier = tonumber(ScenarioInfo.Options.BuildMult or 1.5)
        local iResourceModifier = tonumber(ScenarioInfo.Options.CheatMult or 1.5)
        if iResourceModifier > 0 then
            local oBP = oUnit:GetBlueprint()
            local iBaseMassPerSec = (oBP.Economy.ProductionPerSecondMass or 0)
            local iBaseEnergyPerSec = (oBP.Economy.ProductionPerSecondEnergy or 0)
            local iUpgradeMassPerSec = 0
            local iUpgradeEnergyPerSec = 0

            local tPossibleUpgrades = oBP.Enhancements
            if M28Utilities.IsTableEmpty(tPossibleUpgrades) == false and oUnit.HasEnhancement then
                local iCurMassValue
                local iCurMassMod
                local iBaseMassValue = 1000 --Approx 20 tanks
                local iTotalMassValue = iBaseMassValue
                if bDebugMessages == true then LOG(sFunctionRef..': tPossibleUpgrades size='..table.getn(tPossibleUpgrades)) end
                if tPossibleUpgrades then
                    for sCurUpgrade, tUpgrade in tPossibleUpgrades do
                        if oUnit:HasEnhancement(sCurUpgrade) then
                            iUpgradeMassPerSec = iUpgradeMassPerSec + (tUpgrade.ProductionPerSecondMass or 0)
                            iUpgradeEnergyPerSec = iUpgradeEnergyPerSec + (tUpgrade.ProductionPerSecondEnergy or 0)
                        end
                    end
                end
            end
            if iUpgradeMassPerSec > 0 or iUpgradeEnergyPerSec > 0 or iBaseMassPerSec > 0 or iBaseEnergyPerSec > 0 then
                --Buffs['CheatBuildRate'].Affects.BuildRate.Mult = iBuildModifier
                Buffs['CheatIncome'].Affects.EnergyProduction.Mult = iResourceModifier
                Buffs['CheatIncome'].Affects.MassProduction.Mult = iResourceModifier
                FAFBuffs.RemoveBuff(oUnit, 'CheatIncome', true)
                FAFBuffs.ApplyBuff(oUnit, 'CheatIncome')
                oUnit:SetProductionPerSecondMass((iBaseMassPerSec + iUpgradeMassPerSec) * iResourceModifier)
                oUnit:SetProductionPerSecondEnergy((iBaseEnergyPerSec + iUpgradeEnergyPerSec) * iResourceModifier)
                --FAFBuffs.RemoveBuff(oUnit, 'CheatBuildRate', true)
                --FAFBuffs.ApplyBuff(oUnit, 'CheatBuildRate')
                if bDebugMessages == true then LOG(sFunctionRef..': Finished setting build and resource cheat modifiers for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..', iBaseMassPerSec='..iBaseMassPerSec..'; iUpgradeMassPerSec='..iUpgradeMassPerSec..'; iResourceModifier='..iResourceModifier) end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function IsUnitVisibleSEEBELOW()  end --To help with finding canseeunit
function CanSeeUnit(aiBrain, oUnit, bRequireVisualNotJustBlipToReturnTrue)
    --returns true if aiBrain can see oUnit
    --bRequireVisualNotJustBlipToReturnTrue - returns true if can see a blip
    if bRequireVisualNotJustBlipToReturnTrue == nil then bRequireVisualNotJustBlipToReturnTrue = false end
    local iUnitBrain = oUnit:GetAIBrain()
    if iUnitBrain == aiBrain then return true
    else
        local bCanSeeUnit = false
        local iArmyIndex = aiBrain:GetArmyIndex()
        if not(oUnit.Dead) then
            if not(oUnit.GetBlip) then
                ErrorHandler('oUnit with UnitID='..(oUnit.UnitId or 'nil')..' has no blip, will assume can see it')
                return true
            else
                local oBlip = oUnit:GetBlip(iArmyIndex)
                if oBlip then
                    if bRequireVisualNotJustBlipToReturnTrue then return true
                    elseif oBlip:IsSeenEver(iArmyIndex) then return true end
                end
            end
        end
    end
    return false
end

function DisableUnitWeapon(oUnit)


    local iHoldFireState = 1
    oUnit:SetFireState(iHoldFireState)
    local bAlreadyRecorded = oUnit[refbWeaponDisabled]
    oUnit[refbWeaponDisabled] = true
    oUnit[refiTimeLastDisabledWeapon] = GetGameTimeSeconds()
    if not(bAlreadyRecorded) then
        local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
        local iTeam = oUnit:GetAIBrain().M28Team
        if not(M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons]) then
            M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons] = {}
        end
        table.insert(M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons], oUnit)
    end
end

function EnableUnitWeapon(oUnit)
    local iReturnFireState = 0
    oUnit:SetFireState(iReturnFireState)
    local bAlreadyRecorded = not(oUnit[refbWeaponDisabled])
    oUnit[refbWeaponDisabled] = false
    oUnit[refiTimeLastDisabledWeapon] = nil
    if not(bAlreadyRecorded) then
        local iTeam = oUnit:GetAIBrain().M28Team
        local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons]) == false then
            for iRecorded, oRecorded in M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons] do
                if oRecorded == oUnit then
                    table.remove(M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons], iRecorded)
                    break
                end
            end
        end
    end
end

function GetDeathWeaponDamageAOEAndTable(oUnit)
    --Returns nothing (i.e. nil) if unit doesnt have a death weapon
    local oBP = oUnit:GetBlueprint()
    if M28Utilities.IsTableEmpty(oBP.Weapon) == false then
        for iWeapon, tWeapon in oBP.Weapon do
            if tWeapon.FireOnDeath or tWeapon.WeaponCategory == 'Death' then --e.g. some will 'fire' a nuke (paragon, yolona), others will just do damage
                local iWeaponDamage = math.max((tWeapon.Damage or 0), (tWeapon.NukeInnerRingDamage or 0))
                local iAOE = math.max((tWeapon.NukeInnerRingRadius or 0), (tWeapon.DamageRadius or 0))
                return iWeaponDamage, iAOE, tWeapon
            end
        end

    end
end

function DischargeShield(oShield)
    import("/lua/sim/commands/discharge-shields.lua").DischargeShields({ oShield }, true)
end