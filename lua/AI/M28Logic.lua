---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 07/12/2022 19:50
---
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')


refiNearestEnemyIndex = 'M28NearestEnemyIndex'

--Against units variables
reftiTimeOfLastShieldCheck = 'M28LLShC' --[x] is the shield check ref, returns gametimeseconds of the last check
reftbLastShieldCheckResult = 'M28LLScB' --[x] is the shield check ref



function GetNearestEnemyIndex(aiBrain)
    --Returns the army index of the nearest enemy brain, or nil if there is none
    local oNearestBrain = M28Overseer.GetNearestEnemyBrain(aiBrain)
    if oNearestBrain then return oNearestBrain:GetArmyIndex() else return nil end
end

function GetDirectFireWeaponPosition(oFiringUnit)
    --Returns position of oFiringUnit's first DF weapon; nil if oFiringUnit doesnt have a DF weapon; Unit position if no weapon bone
    --for ACU, returns this for the overcharge weapon
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetDirectFireWeaponPosition'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local oBPFiringUnit = oFiringUnit:GetBlueprint()
    local tShotStartPosition
    if EntityCategoryContains(categories.DIRECTFIRE + M28UnitInfo.refCategoryFatboy, oBPFiringUnit.BlueprintId) == true then
        local bIsACU = EntityCategoryContains(categories.COMMAND, oBPFiringUnit.BlueprintId)

        local sFiringBone
        if bDebugMessages == true then LOG(sFunctionRef..': Have a DF unit, working out where shot coming from') end
        --Work out where the shot is coming from:
        local bIsFatboy = EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oFiringUnit)
        for iCurWeapon, oWeapon in oBPFiringUnit.Weapon do
            if oWeapon.RangeCategory and (oWeapon.RangeCategory == 'UWRC_DirectFire' or (bIsFatboy and oWeapon.RangeCategory == 'UWRC_IndirectFire')) then
                if bDebugMessages == true then LOG(sFunctionRef..': Have a weapon with range category') end
                if oWeapon.RackBones then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a weapon with RackBones') end
                    for _, oRackBone in oWeapon.RackBones do
                        if bDebugMessages == true then LOG(sFunctionRef..' Cur oRackBone='..repru(oRackBone)) end
                        if oRackBone.MuzzleBones then
                            sFiringBone = oRackBone.MuzzleBones[1]
                            if bDebugMessages == true then LOG(sFunctionRef..': Found muzzlebone='..sFiringBone) end
                            break
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Cant locate muzzle bone') end
                        end
                    end
                    if sFiringBone then
                        if bIsACU == false then break
                        else
                            --ACU - make sure we have an overcharge weapon (to avoid e.g. cybran laser weapon)
                            if oWeapon.OverChargeWeapon then
                                break
                            end
                        end
                    end
                end
            end
        end
        if sFiringBone then
            tShotStartPosition = oFiringUnit:GetPosition(sFiringBone)
        else
            tShotStartPosition = oFiringUnit:GetPosition()
        end
    else
        tShotStartPosition = oFiringUnit:GetPosition()
    end
    if bDebugMessages == true then LOG(sFunctionRef..': end of code, tShotStartPosition='..repru(tShotStartPosition)..'; Surface height at this position='..GetSurfaceHeight(tShotStartPosition[1], tShotStartPosition[3])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tShotStartPosition
end

function IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, iAOE, bReturnDistanceThatBlocked, bAntiNavy)
    --If iAOE is specified then will end once reach the iAOE range
    --(aiBrain included as argument as want to retry CheckBlockingTerrain in the future)
    --bReturnDistanceThatBlocked - if this is true then returns either distance at which shot is blocked, or the distance+1 between the start and end position

    --Angle (looking only at vertical dif) from shot start to shot end, theta: Tan Theta = Opp/Adj, so Theta = tan-1 Opp/Adj
    --Once have this angle, then the height if move vertically to the target is: Sin theta = opp / hyp
    --Opp is the height dif; adj is the distance between start and end (referred to below as iFlatDistance)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsLineBlocked'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local bShotIsBlocked = false
    local iFlatDistance = M28Utilities.GetDistanceBetweenPositions(tShotStartPosition, tShotEndPosition)
    local tTerrainPositionAtPoint = {}
    local bStartHigherThanEnd = false
    if tShotStartPosition[2] > tShotEndPosition[2] then bStartHigherThanEnd = true end
    if iFlatDistance > 1 then
        local iAngleInRadians = math.atan(math.abs((tShotEndPosition[2] - tShotStartPosition[2])) / iFlatDistance)
        local iShotHeightAtPoint
        if bDebugMessages == true then LOG(sFunctionRef..': About to check if at any point on path shot will be lower than terrain; iAngle='..M28Utilities.ConvertAngleToRadians(iAngleInRadians)..'; startshot height='..tShotStartPosition[2]..'; target height='..tShotEndPosition[2]..'; iFlatDistance='..iFlatDistance..'; bAntiNavy='..tostring(bAntiNavy or false)) end
        local iEndPoint = math.max(1, math.floor(iFlatDistance - (iAOE or 0)))
        for iPointToTarget = 1, iEndPoint do
            --math.min(math.floor(iFlatDistance), math.max(math.floor(iStartDistance or 1),1)), math.floor(iFlatDistance) do
            --MoveTowardsTarget(tStartPos, tTargetPos, iDistanceToTravel, iAngle)
                                                --MoveInDirection(tStart,               iAngle,                                                             iDistance,      bKeepInMapBounds, bTravelUnderwater, bKeepInCampaignPlayableArea)
            tTerrainPositionAtPoint = M28Utilities.MoveInDirection(tShotStartPosition, M28Utilities.GetAngleFromAToB(tShotStartPosition, tShotEndPosition), iPointToTarget, false,              bAntiNavy,              false)
            if bDebugMessages == true then LOG(sFunctionRef..': iPointToTarget='..iPointToTarget..'; tTerrainPositionAtPoint='..repru(tTerrainPositionAtPoint)..'; Surface height at point='..GetSurfaceHeight(tTerrainPositionAtPoint[1], tTerrainPositionAtPoint[3])..'; Terrain height at point='..GetTerrainHeight(tTerrainPositionAtPoint[1], tTerrainPositionAtPoint[3])) end
            if bStartHigherThanEnd then iShotHeightAtPoint = tShotStartPosition[2] - math.sin(iAngleInRadians) * iPointToTarget
            else iShotHeightAtPoint = tShotStartPosition[2] + math.sin(iAngleInRadians) * iPointToTarget
            end
            if iShotHeightAtPoint <= tTerrainPositionAtPoint[2] and (iShotHeightAtPoint < tTerrainPositionAtPoint[2] or not(bAntiNavy)) then
                if not(iPointToTarget == iEndPoint and iShotHeightAtPoint == tTerrainPositionAtPoint[2]) then
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Shot blocked at this position; iPointToTarget='..iPointToTarget..'; iShotHeightAtPoint='..iShotHeightAtPoint..'; tTerrainPositionAtPoint='..tTerrainPositionAtPoint[2])
                        M28Utilities.DrawLocation(tTerrainPositionAtPoint, 5, 10)
                    end
                    bShotIsBlocked = true
                    if bReturnDistanceThatBlocked then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return iPointToTarget
                    end

                    break
                elseif bDebugMessages == true then LOG(sFunctionRef..': Are at end point and terrain height is identical, so will assume we will actually reach the target')
                end
            else
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Shot not blocked at this position, will draw in blue; iPointToTarget='..(iPointToTarget or 'nil')..'; iShotHeightAtPoint='..(iShotHeightAtPoint or 'nil')..'; tTerrainPositionAtPoint='..(tTerrainPositionAtPoint[2] or 'nil')..'; iAngle='..M28Utilities.ConvertAngleToRadians(iAngleInRadians)..'; iPointToTarget='..(iPointToTarget or 'nil')..'; tShotStartPosition[2]='..(tShotStartPosition[2] or 'nil'))
                    M28Utilities.DrawLocation(tTerrainPositionAtPoint, 1, 20)
                end
            end
        end
    else bShotIsBlocked = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bReturnDistanceThatBlocked and not(bShotIsBlocked) then return M28Utilities.GetDistanceBetweenPositions(tShotStartPosition, tShotEndPosition) + 1
    else
        return bShotIsBlocked
    end
end

function IsShotBlocked(oFiringUnit, oTargetUnit, bAntiNavyAttack, tAltMoveFirstToFirePosition)
    --Returns true or false depending on if oFiringUnit can hit oTargetUnit in a straight line
    --intended for direct fire units only
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsShotBlocked'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local bShotIsBlocked = false
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
    if oTargetUnit.CanBeKilled == false and oFiringUnit:GetAIBrain().M28AI then bShotIsBlocked = true
    else
        local tShotStartPosition = GetDirectFireWeaponPosition(oFiringUnit)
        if tShotStartPosition then
            if tAltMoveFirstToFirePosition then

                local iHeightDif = tShotStartPosition[2] - GetSurfaceHeight(tShotStartPosition[1], tShotStartPosition[3])
                if iHeightDif > 0 then
                    tShotStartPosition[2] = tAltMoveFirstToFirePosition[2] + iHeightDif
                end
                tShotStartPosition[1] = tAltMoveFirstToFirePosition[1]
                tShotStartPosition[3] = tAltMoveFirstToFirePosition[3]
            end
            if bDebugMessages == true then LOG(sFunctionRef..': tShotStartPosition='..repru(tShotStartPosition)) end
            if tShotStartPosition[2] <= 0 then bShotIsBlocked = true
            else
                local tShotEndPosition = {}
                local oBPTargetUnit = oTargetUnit:GetBlueprint()
                local iLowestHeight = 1000
                local iHighestHeight = -1000
                local sLowestBone, sHighestBone
                local tTargetUnitDefaultPosition = oTargetUnit:GetPosition()
                --Work out where the shot is targetting - not all units will have a bone specified in the AI section, in which case just get the unit position
                if oBPTargetUnit.AI and oBPTargetUnit.AI.TargetBones then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have targetbones in the targetunit blueprint; repr='..repru(oBPTargetUnit.AI.TargetBones)) end
                    --Is the target higher or lower than the shooter? If higher, want the lowest target bone; if lower, want the highest target bone
                    for iBone, sBone in oBPTargetUnit.AI.TargetBones do
                        if oTargetUnit:IsValidBone(sBone) == true then
                            tShotEndPosition = oTargetUnit:GetPosition(sBone)
                            if bDebugMessages == true then LOG(sFunctionRef..' Getting position for sBone='..sBone..'; position='..repru(tShotEndPosition)) end
                            if tShotEndPosition[2] < iLowestHeight then
                                iLowestHeight = tShotEndPosition[2]
                                sLowestBone = sBone
                            end
                            if tShotEndPosition[2] > iHighestHeight then
                                iHighestHeight = tShotEndPosition[2]
                                sHighestBone = sBone
                            end
                        end
                    end
                    --Try alternative approach:
                    if sHighestBone == nil and oTargetUnit.GetBoneCount then
                        local iBoneCount = oTargetUnit:GetBoneCount()
                        local sBone
                        if iBoneCount > 0 then
                            for iCurBone = 0, iBoneCount - 1 do
                                sBone = oTargetUnit:GetBoneName(iCurBone)
                                if sBone then
                                    if oTargetUnit:IsValidBone(sBone) == true then
                                        tShotEndPosition = oTargetUnit:GetPosition(sBone)
                                        if bDebugMessages == true then LOG(sFunctionRef..' Getting position for sBone='..sBone..'; position='..repru(tShotEndPosition)) end
                                        if tShotEndPosition[2] < iLowestHeight then
                                            iLowestHeight = tShotEndPosition[2]
                                            sLowestBone = sBone
                                        end
                                        if tShotEndPosition[2] > iHighestHeight then
                                            iHighestHeight = tShotEndPosition[2]
                                            sHighestBone = sBone
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                if sHighestBone == nil then
                    tShotEndPosition = tTargetUnitDefaultPosition
                    if bDebugMessages == true then LOG(sFunctionRef..': Couldnt find a bone to target for target unit, so using its position instaed='..repru(tShotEndPosition)) end
                else
                    if tTargetUnitDefaultPosition[2] > tShotStartPosition[2] then
                        tShotEndPosition = oTargetUnit:GetPosition(sLowestBone)
                    else
                        tShotEndPosition = oTargetUnit:GetPosition(sHighestBone)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': HighestBone='..sHighestBone..'; lowest bone='..sLowestBone..'; tShotEndPosition='..repru(tShotEndPosition)) end
                end
                --Have the shot end and start positions; Now check that not firing at underwater target
                if tShotEndPosition[2] < GetSurfaceHeight(tShotEndPosition[1], tShotEndPosition[3]) and not(bAntiNavyAttack) then
                    bShotIsBlocked = true
                else
                    --Have the shot end and start positions; now want to move along a line between the two and work out if terrain will block the shot
                    if bDebugMessages == true then LOG(sFunctionRef..': About to see if line is blocked. tShotStartPosition='..repru(tShotStartPosition)..'; tShotEndPosition='..repru(tShotEndPosition)..'; Terrain height at start='..GetTerrainHeight(tShotStartPosition[1], tShotStartPosition[3])..'; Terrain height at end='..GetTerrainHeight(tShotEndPosition[1], tShotEndPosition[3])) end
                    --IsLineBlocked(aiBrain,                 tShotStartPosition, tShotEndPosition, iAOE, bReturnDistanceThatBlocked, bAntiNavy)
                    bShotIsBlocked = IsLineBlocked(oFiringUnit:GetAIBrain(), tShotStartPosition, tShotEndPosition,  nil, nil,                   bAntiNavyAttack)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bShotIsBlocked
end

function IsTargetUnderShield(aiBrain, oTarget, iIgnoreShieldsWithLessThanThisHealth, bReturnShieldHealthInstead, bIgnoreMobileShields, bTreatPartCompleteAsComplete, bCumulativeShieldHealth)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsTargetUnderShield'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Determines if target is under a shield
    --bCumulativeShieldHealth - if this is true, then will treat as being under a shield if all shields combined have health of at least iIgnoreShieldsWithLessThanThisHealth



    if M28UnitInfo.IsUnitValid(oTarget) and oTarget.GetHealth then
        --Optimisation - only refresh shield checks periodically as late game this can soak up a lot of performance
        local iRef

        if not(bReturnShieldHealthInstead) then --If want to return shield health then need to do the full calculation
            iRef = aiBrain.M28Team + iIgnoreShieldsWithLessThanThisHealth
            if bIgnoreMobileShields then iRef = iRef + 7 end
            if bTreatPartCompleteAsComplete then iRef = iRef + 13 end
            if bCumulativeShieldHealth then iRef = iRef + 29 end
            if GetGameTimeSeconds() - (oTarget[reftiTimeOfLastShieldCheck][iRef] or -100) <= 0.9 then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return oTarget[reftbLastShieldCheckResult][iRef]
            end
        end

        if bDebugMessages == true and EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oTarget.UnitId) then
            if oTarget.MyShield.GetHealth then
                LOG(sFunctionRef..': oTarget is a shield='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Shield ratio='..oTarget:GetShieldRatio(false)..'; Shield ratio true='..oTarget:GetShieldRatio(true)..'; Shield health='..oTarget.MyShield:GetHealth()..'; SHield max health='..oTarget.MyShield:GetMaxHealth()..'; Active consumption='..tostring(oTarget.ActiveConsumption)..'; reprs of shield='..reprs(oTarget.MyShield))
            else
                LOG(sFunctionRef..': oTarget is a shield but it doesnt have a .GetHealth property. target='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'reprs of shield='..reprs(oTarget.MyShield))
            end
        end
        if iIgnoreShieldsWithLessThanThisHealth == nil then iIgnoreShieldsWithLessThanThisHealth = 0 end
        local bUnderShield = false
        local iShieldSearchRange = 46 --T3 sera shield is 46; bulwark is 120; will go with sera t3 for now; if changing here then also change reference in getmaxstrikedamage
        --Is the target an enemy?
        local oTBrain = oTarget:GetAIBrain()
        local bEnemy
        if oTBrain == aiBrain then
            bEnemy = false
        else
            local iOurArmyIndex = aiBrain:GetArmyIndex()
            local iTargetArmyIndex = oTBrain:GetArmyIndex()
            if iOurArmyIndex and iTargetArmyIndex then
                bEnemy = IsEnemy(iOurArmyIndex, iTargetArmyIndex)
            else bEnemy = true
            end
        end
        local sSearchType = 'Ally'
        if bEnemy then sSearchType = 'Enemy' end
        local tTargetPos = oTarget:GetPosition()
        local iShieldCategory = M28UnitInfo.refCategoryMobileLandShield + M28UnitInfo.refCategoryFixedShield
        if bIgnoreMobileShields then iShieldCategory = M28UnitInfo.refCategoryFixedShield end

        local tNearbyShields
        local bDontDoDistanceCheck = false

        if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oTarget.UnitId) then
            bDontDoDistanceCheck = true
            if bIgnoreMobileShields then
                --We are tracking fixed shields already
                if bDebugMessages == true then LOG(sFunctionRef..': Will only consider fixed shields, so will rely on reftoShieldsProvidingCoverage, is this empty='..tostring(M28Utilities.IsTableEmpty(oTarget[M28Building.reftoShieldsProvidingCoverage]))) end
                tNearbyShields = oTarget[M28Building.reftoShieldsProvidingCoverage]
            else
                tNearbyShields = {}
                if M28Utilities.IsTableEmpty(oTarget[M28Building.reftoShieldsProvidingCoverage]) == false then
                    for iShield, oShield in oTarget[M28Building.reftoShieldsProvidingCoverage] do
                        table.insert(tNearbyShields, oShield)
                        bDontDoDistanceCheck = true
                    end
                end
                local tNearbyMobileShields = aiBrain:GetUnitsAroundPoint(iShieldCategory - M28UnitInfo.refCategoryStructure, tTargetPos, iShieldSearchRange, sSearchType)
                if M28Utilities.IsTableEmpty(tNearbyMobileShields) == false then
                    bDontDoDistanceCheck = false
                    for iShield, oShield in tNearbyMobileShields do
                        table.insert(tNearbyShields, oShield)
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Are considering a structure target, bDontDoDistanceCheck='..tostring(bDontDoDistanceCheck)..'; Is shields providing coverage empty='..tostring(M28Utilities.IsTableEmpty(oTarget[M28Building.reftoShieldsProvidingCoverage]))..'; Is mobile shield table empty='..tostring(M28Utilities.IsTableEmpty(tNearbyMobileShields))) end
            end
        else
            tNearbyShields = aiBrain:GetUnitsAroundPoint(iShieldCategory, tTargetPos, iShieldSearchRange, sSearchType)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Searching for shields around '..repru(tTargetPos)..'; iShieldSearchRange='..iShieldSearchRange..'; sSearchType='..sSearchType) end
        local iShieldCurHealth, iShieldMaxHealth
        local iTotalShieldCurHealth = 0
        local iTotalShieldMaxHealth = 0
        local iMinFractionComplete = 0.95

        local iShieldSizeAdjust = 2 --i.e. if want to be prudent about whether can hit an enemy should be positive, if prudent about whether an ally is protected want a negative value
        if not(bEnemy) then iShieldSizeAdjust = -1 end

        if bTreatPartCompleteAsComplete then iMinFractionComplete = 0 end
        if M28Utilities.IsTableEmpty(tNearbyShields) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Size of tNearbyShields='..table.getn(tNearbyShields)) end
            local oCurUnitBP, iCurShieldRadius, iCurDistanceFromTarget
            for iUnit, oUnit in tNearbyShields do
                if not(oUnit.Dead) and oUnit:GetFractionComplete() >= iMinFractionComplete then
                    oCurUnitBP = oUnit:GetBlueprint()
                    iCurShieldRadius = 0
                    if oCurUnitBP.Defense and oCurUnitBP.Defense.Shield then
                        if bDebugMessages == true then LOG(sFunctionRef..': Target has a shield, will check its shield size and how close that is to the target') end
                        iCurShieldRadius = oCurUnitBP.Defense.Shield.ShieldSize * 0.5
                        if iCurShieldRadius > 0 then
                            if not(bDontDoDistanceCheck) then iCurDistanceFromTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetPos)
                            else iCurDistanceFromTarget = 0
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurDistance to shield='..iCurDistanceFromTarget..'; iCurShieldRadius='..iCurShieldRadius..'; shield position='..repru(oUnit:GetPosition())..'; target position='..repru(tTargetPos)..'; bDontDoDistanceCheck='..tostring(bDontDoDistanceCheck)) end
                            if iCurDistanceFromTarget <= (iCurShieldRadius + iShieldSizeAdjust) then --if dont increase by anything then half of unit might be under shield which means bombs cant hit it
                                if bDebugMessages == true then LOG(sFunctionRef..': Shield is large enough to cover target, will check its health') end
                                iShieldCurHealth, iShieldMaxHealth = M28UnitInfo.GetCurrentAndMaximumShield(oUnit)
                                iTotalShieldCurHealth = iTotalShieldCurHealth + iShieldCurHealth
                                iTotalShieldMaxHealth = iTotalShieldMaxHealth + iShieldMaxHealth
                                if bTreatPartCompleteAsComplete or (oUnit:GetFractionComplete() >= 0.95 and oUnit:GetFractionComplete() < 1) then iShieldCurHealth = iShieldMaxHealth end
                                if bDebugMessages == true then LOG(sFunctionRef..': iShieldCurHealth='..iShieldCurHealth..'; iIgnoreShieldsWithLessThanThisHealth='..iIgnoreShieldsWithLessThanThisHealth) end
                                if (not(bCumulativeShieldHealth) and iShieldCurHealth >= iIgnoreShieldsWithLessThanThisHealth) or (bCumulativeShieldHealth and iTotalShieldCurHealth >= iIgnoreShieldsWithLessThanThisHealth) then
                                    bUnderShield = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Shield health more than threshold so unit is under a shield') end
                                    if not(bReturnShieldHealthInstead) then break end
                                end
                            end
                        elseif bDebugMessages == true then LOG(sFunctionRef..': Shield radius isnt >0')
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Blueprint doesnt have a shield value; UnitID='..oUnit.UnitId) end
                    end
                elseif bDebugMessages == true then LOG(sFunctionRef..': Unit is dead')
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': tNearbyShields is empty') end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        if bReturnShieldHealthInstead then
            return iTotalShieldCurHealth, iTotalShieldMaxHealth
        else
            if not(oTarget[reftiTimeOfLastShieldCheck]) then oTarget[reftiTimeOfLastShieldCheck] = {} oTarget[reftbLastShieldCheckResult] = {} end
            oTarget[reftiTimeOfLastShieldCheck][iRef] = GetGameTimeSeconds()
            oTarget[reftbLastShieldCheckResult][iRef] = bUnderShield
            if bDebugMessages == true then LOG(sFunctionRef..': Returning '..tostring(bUnderShield)) end
            return bUnderShield
        end
    end
end

function GetDamageFromOvercharge(aiBrain, oTargetUnit, iAOE, iDamage, bTargetWalls)
    --Originally copied from the 'getdamagefrombomb' function, but adjusted since OC doesnt deal full damage to ACU or structures
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetDamageFromOvercharge'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iTotalDamage = 0

    local tEnemiesInRange
    if bTargetWalls then tEnemiesInRange =  aiBrain:GetUnitsAroundPoint(categories.WALL + M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryAllNavy, oTargetUnit:GetPosition(), iAOE, 'Enemy')
    else tEnemiesInRange = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryAllNavy, oTargetUnit:GetPosition(), iAOE, 'Enemy')
    end

    local iMassFactor
    local iCurHealth, iMaxHealth, iCurShield, iMaxShield
    local iActualDamage
    local iKillsExpected = 0
    local iUnitsHit = 0 --E.g. if targeting walls then this means we target the most walls assuming no nearby other units
    if bDebugMessages == true then LOG(sFunctionRef..': About to loop through all enemies in range; iDamage='..iDamage..'; iAOE='..iAOE..'; Base target unit='..oTargetUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTargetUnit)..'; position='..repru(oTargetUnit:GetPosition())) end

    if M28Utilities.IsTableEmpty(tEnemiesInRange) == false then
        for iUnit, oUnit in tEnemiesInRange do
            if oUnit.GetBlueprint then
                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; dist to postiion='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTargetUnit:GetPosition())) end
                --Is the unit within range of the aoe?
                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTargetUnit:GetPosition()) <= iAOE then
                    --Is the unit shielded by a non-mobile shield (mobile shields should take full damage I think)
                    --IsTargetUnderShield(aiBrain, oTarget, iIgnoreShieldsWithLessThanThisHealth, bReturnShieldHealthInstead, bIgnoreMobileShields, bTreatPartCompleteAsComplete)
                    if not(IsTargetUnderShield(aiBrain, oUnit, 800, false, true, false)) then
                        iActualDamage = iDamage
                        if EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                            iActualDamage = 800
                        elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                            iActualDamage = 400
                        end

                        iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit)
                        iCurHealth = iCurShield + oUnit:GetHealth()
                        iMaxHealth = iMaxShield + oUnit:GetMaxHealth()
                        --Set base mass value based on health
                        if iDamage >= iMaxHealth or iDamage >= math.min(iCurHealth * 3, iCurHealth + 1000) then
                            iMassFactor = 1
                            iKillsExpected = iKillsExpected + 1
                            --Was the unit almost dead already?
                            if (iCurShield + iCurHealth) <= iMaxHealth * 0.4 then iMassFactor = math.max(0.25, (iCurShield + iCurHealth) / iMaxHealth) end
                        else
                            --Still some value in damaging a unit (as might get a second strike), but far less than killing it
                            iMassFactor = 0.4
                            if EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then iMassFactor = 0.5 end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iMassFactor after considering if will kill it='..iMassFactor..'; Unit max health='..iMaxHealth..'; CurHealth='..iCurHealth) end
                        --Is the target mobile and within 1 of the AOE edge? If so then reduce to 25% as it might move out of the wayif
                        if oUnit:GetFractionComplete() == 1 and EntityCategoryContains(categories.MOBILE, oUnit.UnitId) and iAOE - 0.5 < M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTargetUnit:GetPosition()) then iMassFactor = iMassFactor * 0.25 end
                        iTotalDamage = iTotalDamage + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * oUnit:GetFractionComplete() * iMassFactor
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished considering the unit; iTotalDamage='..iTotalDamage..';refiUnitMassCost='..oUnit[M28UnitInfo.refiUnitMassCost]..'; oUnit:GetFractionComplete()='..oUnit:GetFractionComplete()..'; iMassFactor after considering if unit is mobile='..iMassFactor) end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished going through units in the aoe, iTotalDamage in mass='..iTotalDamage..'; iAOE='..iAOE..'; iDamage='..iDamage) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iTotalDamage, iKillsExpected
end


function GetDamageFromBomb(aiBrain, tBaseLocation, iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies, iOptionalSpecialCategoryDamageFactor, iOptionalSpecialCategory, iOptionalReclaimFactor, bCheckIfUnderwater)
    --Below is largely a copy of M27 logic
    --iFriendlyUnitDamageReductionFactor - optional, assumed to be 0 if not specified; will reduce the damage from the bomb by any friendly units in the aoe
    --iFriendlyUnitAOEFactor - e.g. if 2, then will search for friendly units in 2x the aoe
    --bCumulativeShieldHealthCheck - if this is true, then will treat a unit as unshielded if its cumulative shield health check is below the damage
    --iOptionalSizeAdjust - Defaults to 1, % of value to assign to a normal (mex sized) target; if this isn't 1 then will adjust values accordingly, with T3 power given a value of 1, larger buildings given a greater value, and T1 PD sized buildings given half of iOptionalSizeAdjust
    --iOptionalModIfNeedMultipleShots - Defaults to 0.1; % of value to assign if we wont kill the target with a single shot (experimentals will always give at least 0.5 value)
    --bT3ArtiShotReduction - if this is true then will reduce value of targets where we have fired lots of shots at them
    --iOptionalShieldReductionFactor - if shields exceed iDamage, then this will be used in place of 0 (the default), i.e. what % of the mass damage should be used if the shield means 0 damage will be dealt
    --iOptionalReclaimFactor - if this isnt nil, then will include the value of reclaim if the location looks like it is available to the enemy and damage is high enough that it's reasonable to assume we will kill the reclaim; requires there to be a friendly unit damage reduction factor (to avoid too much of a CPU load given how oftne this function is called)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetDamageFromBomb'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iTotalDamage = 0
    local bCheckForShields = true
    if iDamage >= 25000 then bCheckForShields = false end
    local iCategoryToSearch
    if iDamage >= 10000 then
        if M28Overseer.refiRoughTotalUnitsInGame >= 800 then
            iCategoryToSearch = M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryAllNavy + M28UnitInfo.refCategoryAllAir * categories.EXPERIMENTAL - categories.TECH1 - M28UnitInfo.refCategoryMobileLand * categories.TECH2 + categories.COMMAND
        else
            iCategoryToSearch = M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryAllNavy + M28UnitInfo.refCategoryAllAir * categories.EXPERIMENTAL - M28UnitInfo.refCategoryMobileLand * categories.TECH1 + categories.COMMAND
        end
    else
        iCategoryToSearch = M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryAllNavy + M28UnitInfo.refCategoryAllAir * categories.EXPERIMENTAL
        if M28Overseer.refiRoughTotalUnitsInGame >= 1000 then iCategoryToSearch = iCategoryToSearch - M28UnitInfo.refCategoryMobileLand * categories.TECH1 + categories.COMMAND end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Near start, Time='..GetGameTimeSeconds()..'; bCheckForShields='..tostring(bCheckForShields)..'; tBaseLocation='..repru(tBaseLocation)..'; iAOE='..iAOE..'; iDamage='..iDamage..'; bCumulativeShieldHealthCheck='..tostring(bCumulativeShieldHealthCheck or false)..'; iOptionalSizeAdjust='..(iOptionalSizeAdjust or 'nil')..'; iOptionalModIfNeedMultipleShots='..(iOptionalModIfNeedMultipleShots or 'nil')..'; iMobileValueOverrideFactorWithin75Percent='..(iMobileValueOverrideFactorWithin75Percent or 'nil')..'; bT3ArtiShotReduction='..tostring(bT3ArtiShotReduction or false)..'; iOptionalShieldReductionFactor='..(iOptionalShieldReductionFactor or 'nil')) end
    local bCheckForCaptureTarget = M28Map.bIsCampaignMap
    local iSearchRangeIncrease = 0
    if bCheckForCaptureTarget then iSearchRangeIncrease = 4 end --incase when tested the campaign this was an issue (as originally used a value of iAOE + 4 prior to changing in v74)
    local tEnemiesInRange = aiBrain:GetUnitsAroundPoint(iCategoryToSearch, tBaseLocation, iAOE + iSearchRangeIncrease, 'Enemy')
    local tLZOrWZData, tLZOrWZTeamData

    --Expand enemies in range with any unseen enemies (e.g. these will be enemies that are firing at us or we have intel of previously but have now lost)
    if bIncludePreviouslySeenEnemies or M28Map.bIsCampaignMap or (iAOE >= 10 and iOptionalReclaimFactor and iFriendlyUnitDamageReductionFactor) then

        local iPlateauOrZero, iLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tBaseLocation)

        if (iLZOrWZ or 0) > 0 then
            if iPlateauOrZero == 0 then
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLZOrWZ]][M28Map.subrefPondWaterZones][iLZOrWZ]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][aiBrain.M28Team]
            else
                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLZOrWZ]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
            end
        end
        local bHaveUnitsInRange = not(M28Utilities.IsTableEmpty(tEnemiesInRange)) --used to decide if we need to do a distance check
        if bDebugMessages == true then LOG(sFunctionRef..': Considering unseen enemies, iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLZOrWZ='..(iLZOrWZ or 'nil')..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]))..'; is table of capture units empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subreftoUnitsToCapture]))..'; Is tLZOrWZTeamData empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData))) end
        if bIncludePreviouslySeenEnemies and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) == false then
            local tRelevantUnits = EntityCategoryFilterDown(iCategoryToSearch, tLZOrWZTeamData[M28Map.subrefTEnemyUnits])
            if M28Utilities.IsTableEmpty(tRelevantUnits) == false then
                for iUnit, oUnit in tRelevantUnits do
                    if bDebugMessages == true then
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Can see unit='..tostring(M28UnitInfo.CanSeeUnit(aiBrain, oUnit))..'; Unit pos='..repru(oUnit:GetPosition())..'; Dist to base location='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBaseLocation))
                        end
                    end
                    if M28UnitInfo.IsUnitValid(oUnit) and not(M28UnitInfo.CanSeeUnit(aiBrain, oUnit)) then
                        if bHaveUnitsInRange then
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding unseen unit to enemies in range, will check its distance later') end
                            table.insert(tEnemiesInRange, oUnit)
                        elseif M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBaseLocation) <= iAOE then
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding unseen unit to enemies in range as it is within range, allowing for AOE') end
                            table.insert(tEnemiesInRange, oUnit)
                            bHaveUnitsInRange = true
                        end
                    end
                end
            end
        end
    end
    local iMassFactor
    local iCurHealth, iMaxHealth
    local iCurShield = 0
    local iMaxShield = 0
    local tFriendlyUnits
    local iSizeAdjustFactor = iOptionalSizeAdjust or 1
    local iDifBetweenSize8And2 = 0

    local tiSizeAdjustFactors
    local iFactorIfWontKill = iOptionalModIfNeedMultipleShots or 0.1
    if not(iSizeAdjustFactor == 1) then
        iDifBetweenSize8And2 = iSizeAdjustFactor - 1
        --Key values are 1, 2 (Mex), 6 (T2 pgen), 8 (T3 PGen), 10 (rapidfire arti); could potentially go up to 20 (czar)
        tiSizeAdjustFactors = {[1] = 2, [2] = 1, [3] = 0.9, [4] = 0.75, [5] = 0.6, [6] = 0.5, [7] = 0.3, [8] = 0, [9] = -0.1, [10] = -0.25}

    end

    function GetBuildingSizeFactor(sBlueprint)
        if iSizeAdjustFactor == 1 then
            return 1
        else

            local oBlueprint = M28UnitInfo.GetBlueprintFromID(sBlueprint)
            local iCurSize = math.min((oBlueprint.Physics.SkirtSizeX or 0), (oBlueprint.Physics.SkirtSizeZ or 0))
            local iCurSize = math.floor(iCurSize)
            if bDebugMessages == true then LOG(sFunctionRef..': iCurSize='..iCurSize..'; tiSizeAdjustFactors[iCurSize]='..(tiSizeAdjustFactors[iCurSize] or 'nil')..'; expected factor='..1 + (tiSizeAdjustFactors[iCurSize] or -0.35) * iDifBetweenSize8And2) end

            return 1 + (tiSizeAdjustFactors[iCurSize] or -0.35) * iDifBetweenSize8And2
        end
    end

    if iFriendlyUnitDamageReductionFactor then
        --Reduce damage dealt based on nearby friendly units

        tFriendlyUnits = aiBrain:GetUnitsAroundPoint(categories.ALLUNITS - categories.BENIGN - M28UnitInfo.refCategorySatellite, tBaseLocation, iAOE * (iFriendlyUnitAOEFactor or 1), 'Ally')
        if M28Utilities.IsTableEmpty(tFriendlyUnits) == false then
            for iUnit, oUnit in tFriendlyUnits do
                if oUnit.GetBlueprint and not(oUnit.Dead) then
                    if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                        if M28Team.tTeamData[aiBrain.M28Team][M28Team.refbAssassinationOrSimilar] then
                            iTotalDamage = iTotalDamage - 100000
                        else
                            iTotalDamage = iTotalDamage - 15000 * iFriendlyUnitDamageReductionFactor
                        end
                    else
                        iTotalDamage = iTotalDamage - (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * oUnit:GetFractionComplete() * iFriendlyUnitDamageReductionFactor
                    end
                end
            end
        else
            if iOptionalReclaimFactor and tLZOrWZData and (tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim] or 0) >= 1000 and iDamage >= 10000 and tLZOrWZTeamData[M28Map.refiModDistancePercent] > 0.6 then --If changing from 0.6 then also update threshold in building for high value reeclaim segments
                --This zone is on enemy side of the map by a bit, does the enemy have units in this zone (such that they can likely access this reclaim)?
                if M28Utilities.IsTableEmpty(tEnemiesInRange) == false or tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] or tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                    local iTotalReclaim = 0
                    local iReclaimSegmentSearchRange = math.floor(math.min(iAOE / M28Map.iReclaimSegmentSizeX, iAOE / M28Map.iReclaimSegmentSizeZ))
                    local iBaseReclaimSegX, iBaseReclaimSegZ = M28Map.GetReclaimSegmentsFromLocation(tBaseLocation)
                    for iCurReclaimSegX = iBaseReclaimSegX - iReclaimSegmentSearchRange, iBaseReclaimSegX + iReclaimSegmentSearchRange, 1 do
                        for iCurReclaimSegZ = iBaseReclaimSegZ - iReclaimSegmentSearchRange, iBaseReclaimSegZ + iReclaimSegmentSearchRange, 1 do
                            --Exclude corners
                            if not(iCurReclaimSegX == iCurReclaimSegZ) or iCurReclaimSegX == 0 then
                                if M28Map.tReclaimAreas[iCurReclaimSegX] and M28Map.tReclaimAreas[iCurReclaimSegX][iCurReclaimSegZ] then
                                    iTotalReclaim = iTotalReclaim + (M28Map.tReclaimAreas[iCurReclaimSegX][iCurReclaimSegZ][M28Map.refReclaimTotalSignificantMass] or 0)
                                end
                            end
                        end
                    end
                    iTotalDamage = iTotalDamage + iTotalReclaim * iOptionalReclaimFactor
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemies in range empty='..tostring(M28Utilities.IsTableEmpty(tEnemiesInRange))..'; tBaselocation='..repru(tBaseLocation)) end
    if M28Utilities.IsTableEmpty(tEnemiesInRange) == false then
        local iShieldThreshold = math.max(iDamage * 0.9, iDamage - 500)
        local iCurDist
        local iMobileDamageDistThreshold = iAOE * 0.75
        local iMobileDamageFactorWithinThreshold
        local iMobileDamageFactorOutsideThreshold = 0.2
        local iMobileDamageNotMovingWithinThreshold
        local iMobileDamageFactorOutsideThresholdMoving
        if iMobileValueOverrideFactorWithin75Percent then
            iMobileDamageFactorWithinThreshold = math.max(iMobileDamageFactorOutsideThreshold, iMobileValueOverrideFactorWithin75Percent)
        else
            if iAOE >= 3.5 then
                if iAOE >= 10 then
                    iMobileDamageFactorWithinThreshold = iMobileDamageFactorOutsideThreshold * 1.75
                else
                    iMobileDamageFactorWithinThreshold = iMobileDamageFactorOutsideThreshold * 1.25
                end
            else
                iMobileDamageFactorWithinThreshold = iMobileDamageFactorOutsideThreshold
            end
        end
        iMobileDamageNotMovingWithinThreshold = math.min(iMobileDamageFactorWithinThreshold + 0.1, iMobileDamageFactorWithinThreshold * 1.5, 1)
        iMobileDamageFactorWithinThreshold = math.max(iMobileDamageFactorWithinThreshold - 0.1, iMobileDamageFactorWithinThreshold * 0.5) --value for if we are moving
        iMobileDamageFactorOutsideThresholdMoving = math.max(iMobileDamageFactorOutsideThreshold - 0.1, iMobileDamageFactorOutsideThreshold * 0.5)

        local iPlateauOrZero, iLandOrWaterZone
        local tLZOrWZTeamData
        local iT3ArtiMissedShotFactor

        if bT3ArtiShotReduction then
            iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tBaseLocation)
            if iPlateauOrZero > 0 then
                tLZOrWZTeamData  = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][aiBrain.M28Team]
            else
                --Water zone
                tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][aiBrain.M28Team]
            end
            iT3ArtiMissedShotFactor = M28Building.GetArtiValueFactorForShotFailures((tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 0))
        end

        local iACUExtraFactor = 1
        if M28Map.bIsCampaignMap or ScenarioInfo.Options.Victory == "demoralization" or M28Team.tTeamData[aiBrain.M28Team][M28Team.refbAssassinationOrSimilar] then

            if M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftEnemyACUs]) == false and table.getn(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftEnemyACUs]) > 1 and ScenarioInfo.Options.Share == 'FullShare' then
                iACUExtraFactor = 2
            else
                iACUExtraFactor = 5
            end
        end
        -- not(aiBrain[M27Overseer.refiActiveEnemyBrains] > 1 and ScenarioInfo.Options.Share == 'FullShare')
        for iUnit, oUnit in tEnemiesInRange do
            if bDebugMessages == true then
                if M28UnitInfo.IsUnitValid(oUnit) then
                    LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Is unit mobile air='..tostring(EntityCategoryContains(categories.AIR * categories.MOBILE, oUnit.UnitId))..'; Distance to tBaseLocation='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBaseLocation))
                end
            end
            if oUnit.GetBlueprint and not(oUnit.Dead) and (oUnit:GetFractionComplete() < 1 or not(EntityCategoryContains(categories.AIR * categories.MOBILE, oUnit.UnitId))) then
                iMassFactor = 1
                --Is the unit within range of the aoe?
                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBaseLocation)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Distance to base location='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBaseLocation)..'; iAOE='..iAOE) end
                --Special logic for campaign
                if bCheckForCaptureTarget and oUnit[M28UnitInfo.refbIsCaptureTarget] and oUnit.CanTakeDamage then
                    if iCurDist <= iAOE + 3 then
                        iTotalDamage = iTotalDamage - 10000
                        if oUnit.UnitId == 'uec1902' then iTotalDamage = iTotalDamage - 50000 end --Black sun control centre
                    else
                        if oUnit.UnitId == 'uec1902' then iTotalDamage = iTotalDamage - 10000 end --Black sun control centre
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': oUnit is a capture target='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; reducing damage from bomb, iCurDist='..iCurDist..'; Damage after reduction (but may still have other units)='..iTotalDamage) end
                end
                if iCurDist <= iAOE then
                    --Is the unit shielded by more than 90% of our damage?
                    --IsTargetUnderShield(aiBrain, oTarget, iIgnoreShieldsWithLessThanThisHealth, bReturnShieldHealthInstead, bIgnoreMobileShields, bTreatPartCompleteAsComplete, bCumulativeShieldHealth)
                    if bCheckForShields and IsTargetUnderShield(aiBrain, oUnit, iShieldThreshold, false, false, nil, bCumulativeShieldHealthCheck) then iMassFactor = (iOptionalShieldReductionFactor or 0) end
                    if bDebugMessages == true then LOG(sFunctionRef..': Mass factor after considering if under shield='..iMassFactor..'; iOptionalShieldReductionFactor='..(iOptionalShieldReductionFactor or 'nil')..'; Is target under shield='..tostring(IsTargetUnderShield(aiBrain, oUnit, iShieldThreshold, false, false, nil, bCumulativeShieldHealthCheck))) end
                    if iMassFactor > 0 then
                        if bCheckForShields then
                            iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit)
                        end
                        iCurHealth = iCurShield + oUnit:GetHealth()
                        iMaxHealth = iMaxShield + oUnit:GetMaxHealth()
                        --Set base mass value based on health
                        if not(iFactorIfWontKill == 1) then
                            if iDamage >= iMaxHealth or iDamage >= math.min(iCurHealth * 3, iCurHealth + 1000) then
                                --Do nothing - stick with default mass factor of 1
                            else
                                --Still some value in damaging a unit (as might get a second strike), but far less than killing it
                                if EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then

                                    iMassFactor = iMassFactor * math.min(math.max(0.5, iFactorIfWontKill), iDamage / math.max(iCurHealth * 1.5, iMaxHealth))
                                else
                                    iMassFactor = iMassFactor * math.min(iDamage / iMaxHealth, iFactorIfWontKill)
                                end
                            end
                        end
                        --Adjust for building size if specified (e.g. useful for if firing from unit with randomness factor)
                        iMassFactor = iMassFactor * GetBuildingSizeFactor(oUnit.UnitId)
                        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iMassFactor after considering if will kill it and how large it is='..iMassFactor..'; iFactorIfWontKill='..iFactorIfWontKill..'; Building size factor='..GetBuildingSizeFactor(oUnit.UnitId)) end
                        --Is the target mobile and not under construction? Then reduce to 20% as unit might dodge or not be there when bomb lands
                        if oUnit:GetFractionComplete() == 1 then
                            if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then
                                if iCurDist <= iMobileDamageDistThreshold then
                                    if oUnit:IsUnitState('Moving') then
                                        iMassFactor = iMassFactor * iMobileDamageFactorWithinThreshold
                                    else
                                        iMassFactor = iMassFactor * iMobileDamageNotMovingWithinThreshold
                                    end
                                else
                                    if oUnit:IsUnitState('Moving') then
                                        iMassFactor = iMassFactor * iMobileDamageFactorOutsideThresholdMoving
                                    else
                                        iMassFactor = iMassFactor * iMobileDamageFactorOutsideThreshold
                                    end
                                end
                                --Is it a mex that will be killed outright and/or a volatile structure? Then increase the value of killing it
                            elseif iMassFactor >= 1 and EntityCategoryContains(categories.MASSEXTRACTION + M28UnitInfo.refCategoryVolatile, oUnit.UnitId) then iMassFactor = iMassFactor * 1.75
                            end
                        end
                        if bT3ArtiShotReduction then
                            iMassFactor = iMassFactor * iT3ArtiMissedShotFactor
                        end
                        --Increase mass factor for ACUs if we are in assassination or campaign
                        if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                            iMassFactor = iMassFactor * iACUExtraFactor
                        end

                        --Increase mass factor for special category specified
                        if iOptionalSpecialCategoryDamageFactor and EntityCategoryContains(iOptionalSpecialCategory, oUnit.UnitId) then iMassFactor = iMassFactor * iOptionalSpecialCategoryDamageFactor end

                        iTotalDamage = iTotalDamage + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * oUnit:GetFractionComplete() * iMassFactor
                        --Increase further for SML and SMD that might have a missile
                        if EntityCategoryContains(M28UnitInfo.refCategorySML - M28UnitInfo.refCategoryBattleship, oUnit.UnitId) then
                            if oUnit:GetFractionComplete() == 1 then
                                iTotalDamage = iTotalDamage + 12000 * math.min(iMassFactor, 1)
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySMD, oUnit.UnitId) then
                            if oUnit:GetFractionComplete() == 1 then
                                iTotalDamage = iTotalDamage + 3600 * math.min(iMassFactor, 1)
                                --Also increase if we have a nuke launcher more than 35% complete

                                function HaveSML(oBrain)
                                    local tFriendlyNukes = aiBrain:GetListOfUnits(M28UnitInfo.refCategorySML, false, true)
                                    if M28Utilities.IsTableEmpty(tFriendlyNukes) == false then
                                        for iUnit, oUnit in tFriendlyNukes do
                                            if oUnit:GetFractionComplete() == 1 then
                                                if oUnit:GetWorkProgress() >= 0.35 then
                                                    return true
                                                elseif oUnit.GetNukeSiloAmmoCount and oUnit:GetNukeSiloAmmoCount() >= 1 then
                                                    return true
                                                end
                                            end
                                        end
                                    end
                                    return false
                                end
                                local bHaveFriendlySMLNearlyLoaded = false
                                if not(bHaveFriendlySMLNearlyLoaded) then
                                    for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyActiveM28Brains] do
                                        if not(oBrain == aiBrain) then
                                            if HaveSML(oBrain) then
                                                bHaveFriendlySMLNearlyLoaded = true
                                                break
                                            end
                                        end
                                    end
                                end
                                if bHaveFriendlySMLNearlyLoaded then
                                    iTotalDamage = iTotalDamage + 10000
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished considering the unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTotalDamage='..iTotalDamage..';refiUnitMassCost='..oUnit[M28UnitInfo.refiUnitMassCost]..'; oUnit:GetFractionComplete()='..oUnit:GetFractionComplete()..'; iMassFactor after considering if unit is mobile='..iMassFactor..'; distance between unit and target='..M28Utilities.GetDistanceBetweenPositions(tBaseLocation, oUnit:GetPosition())) end
                    end
                end

            end
        end
        if bCheckForCaptureTarget and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subreftoUnitsToCapture]) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Have capture targets for this zone') end
            for iCaptureTarget, oCaptureTarget in tLZOrWZData[M28Map.subreftoUnitsToCapture] do
                iCurDist = M28Utilities.GetDistanceBetweenPositions(oCaptureTarget:GetPosition(), tBaseLocation)
                if M28UnitInfo.IsUnitValid(oCaptureTarget) and iCurDist <= iAOE + 3 then
                    iTotalDamage = iTotalDamage - 10000
                    if oCaptureTarget.UnitId == 'uec1902' then iTotalDamage = iTotalDamage - 60000 end --Black sun control centre
                elseif iCurDist <= iAOE + 45 then
                    iTotalDamage = iTotalDamage - 5000
                    if oCaptureTarget.UnitId == 'uec1902' then iTotalDamage = iTotalDamage - 30000 end --Black sun control centre
                end
                if bDebugMessages == true then LOG(sFunctionRef..': oCaptureTarget='..(oCaptureTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oCaptureTarget) or 'nil')..'; damage after update='..iTotalDamage) end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished going through units in the aoe, iTotalDamage in mass='..iTotalDamage..'; tBaseLocation='..repru(tBaseLocation)..'; iAOE='..iAOE..'; iDamage='..iDamage) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iTotalDamage
end

function GetBestAOETarget(aiBrain, tBaseLocation, iAOE, iDamage, bOptionalCheckForSMD, tSMLLocationForSMDCheck, iOptionalTimeSMDNeedsToHaveBeenBuiltFor, iSMDRangeAdjust, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, iOptionalMaxDistanceCheckOptions, iMobileValueOverrideFactorWithin75Percent, iOptionalShieldReductionFactor, iOptionalReclaimFactor)
    --Calcualtes the most damaging location for an aoe target; also returns the damage dealt
    --if bOptionalCheckForSMD is true then will ignore targest that are near an SMD
    --iOptionalMaxDistanceCheckOptions - can use to limit hte nubmer of distance options that will choose
    --iFriendlyUnitAOEFactor - e.g. if 2, then will search for friendly units in 2x the aoe
    --iOptionalShieldReductionFactor - instead of igivng shielded targets 0 value this assigns this % of value
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBestAOETarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': About to find the best target for bomb, tBaseLocation='..repru(tBaseLocation)..'; iAOE='..(iAOE or 'nil')..'; iDamage='..(iDamage or 'nil')) end

    local tBestTarget = {tBaseLocation[1], tBaseLocation[2], tBaseLocation[3]}
    local iMaxTargetDamage
    if aiBrain.M28Easy then
        iMaxTargetDamage = GetDamageFromBomb(aiBrain, tBaseLocation, iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, nil, nil, nil, iMobileValueOverrideFactorWithin75Percent, nil, iOptionalShieldReductionFactor, nil, nil, nil, iOptionalReclaimFactor)
    else
        --GetDamageFromBomb(aiBrain, tBaseLocation, iAOE, iDamage)
        --GetDamageFromBomb(aiBrain, tBaseLocation, iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor)
        local iCurTargetDamage = GetDamageFromBomb(aiBrain, tBaseLocation, iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, nil, nil, nil, iMobileValueOverrideFactorWithin75Percent, nil, iOptionalShieldReductionFactor, nil, nil, nil, iOptionalReclaimFactor)
        iMaxTargetDamage = iCurTargetDamage
        local iMaxDistanceChecks = math.min(4, math.ceil(iAOE / 2))
        if iOptionalMaxDistanceCheckOptions then iMaxDistanceChecks = math.min(iOptionalMaxDistanceCheckOptions, iMaxDistanceChecks) end
        local iDistanceFromBase = 0
        local tPossibleTarget
        if bOptionalCheckForSMD and M28Building.IsSMDBlockingTarget(aiBrain, tBaseLocation, tSMLLocationForSMDCheck, (iOptionalTimeSMDNeedsToHaveBeenBuiltFor or 200), iSMDRangeAdjust) then iMaxTargetDamage = math.min(4000, iMaxTargetDamage) end

        for iCurDistanceCheck = iMaxDistanceChecks, 1, -1 do
            iDistanceFromBase = iAOE / iCurDistanceCheck
            for iAngle = 0, 360, 45 do
                tPossibleTarget = M28Utilities.MoveInDirection(tBaseLocation, iAngle, iDistanceFromBase)
                --GetDamageFromBomb(aiBrain, tBaseLocation, iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor)
                iCurTargetDamage = GetDamageFromBomb(aiBrain, tPossibleTarget, iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, nil, nil, nil, iMobileValueOverrideFactorWithin75Percent, nil, iOptionalShieldReductionFactor, nil, nil, nil, iOptionalReclaimFactor)
                if iCurTargetDamage > iMaxTargetDamage then
                    if bOptionalCheckForSMD and M28Building.IsSMDBlockingTarget(aiBrain, tPossibleTarget, tSMLLocationForSMDCheck, (iOptionalTimeSMDNeedsToHaveBeenBuiltFor or 200), iSMDRangeAdjust) then iCurTargetDamage = math.min(4000, iCurTargetDamage) end
                    if iCurTargetDamage > iMaxTargetDamage then
                        tBestTarget = tPossibleTarget
                        iMaxTargetDamage = iCurTargetDamage
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking every angle for iDistanceFromBase='..iDistanceFromBase..'; iMaxTargetDamage='..iMaxTargetDamage..'; tBestTarget='..repru(tBestTarget)) end
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef..': Best target for bomb='..repru(tBestTarget)..'; iMaxTargetDamage='..iMaxTargetDamage)
        M28Utilities.DrawLocation(tBestTarget)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tBestTarget, iMaxTargetDamage
end