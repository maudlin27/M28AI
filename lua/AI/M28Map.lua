---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 16/11/2022 07:22
---

local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Chat = import('/mods/M28AI/lua/AI/M28Chat.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Config = import('/mods/M28AI/lua/M28Config.lua')

bMapLandSetupComplete = false --set to true once have finished setting up map (used to decide how long to wait before starting main aibrain logic)
bWaterZoneInitialCreation = false --set to true once have finished code for recording water zones (note WZ setup wont be fully complete yet)
bWaterZoneFirstTeamInitialisation = false --set to true when the first team runs logic for creating team related variables for a water zone
bIsCampaignMap = false --set at start of game
bFirstM28TeamHasBeenInitialised = false --set to true once we have run the teaminitialisation function

--Pathing types
--NavLayers 'Land' | 'Water' | 'Amphibious' | 'Hover' | 'Air'
refPathingTypeHover = 'Hover' --Amphibious is more restrictive so more likely to run into errors if base pathing on hover if enemy units then hover over it
refPathingTypeAmphibious = 'Amphibious' --Use sparingly - most logic uses hover instead of amphibious
refPathingTypeNavy = 'Water'
refPathingTypeAir = 'Air'
refPathingTypeLand = 'Land'
refPathingTypeNone = 'None'
refPathingTypeAll = {refPathingTypeHover, refPathingTypeNavy, refPathingTypeAir, refPathingTypeLand}

--Map size
rMapPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2} - Set at start of the game, use instead of the scenarioinfo method; note that x0 z0 is the top-left corner of the map
rMapPotentialPlayableArea = {0,0,256,256} --as above but is for campaigns where it will return the totla map size as the map may expand later
iMapSize = 256 -- Currently playable area only - average of the rmap playable area difs, e.g. 256 for a 5kmx5km, but smaller than this if its 2.5kmx5km
iMaxLandSegmentX = 1
iMaxLandSegmentZ = 1

iMapWaterHeight = 0 --Surface height of water on the map

--Resource information
tMassPoints = {} --[x] is an integer count, returns the location of a mass point; stores all mexes on the map
tHydroPoints = {} --[x] is an integer count, returns the location of a hydro point; stores all hydro points on the map
tMexByPathingAndGrouping = {} --Stores position of each mex based on the pathing group that it's part of; [a][b][c]: [a] = pathing type ('Land' etc.); [b] = Segment grouping; [c] = Mex position
tHydroByPathingAndGrouping = {} --as above but for hydros

--Player start points
PlayerStartPoints = {} --[x] is aiBrain army index, returns the start position {x,y,z}; Will be updated whenever a brain is created, index is the army index, i.e. do PlayerStartPoints[aiBrain:GetArmyIndex()] to get a table {x,y,z} that is the army's start position; more convenient than aiBrain:GetArmyStartPos() which returns x and z values but not as a table


--Reclaim info (non-LZ/plateau specific):
bReclaimManagerActive = false --used to spread updates of reclaim areas over each second
tReclaimSegmentsToUpdate = {} --[n] where n is the count, returns {segmentX,segmentZ} as value; i.e. update by using table.insert
tReclaimAreas = {} --Stores reclaim info for each segment: tReclaimAreas[iSegmentX][iSegmentZ][x]; if x=1 returns total mass in area; if x=2 then returns position of largest reclaim in the area, if x=3 returns how many platoons have been sent here since the game started
    refReclaimTotalMass = 1
    refReclaimSegmentMidpoint = 2
    --refReclaimHighestIndividualReclaim = 3
    --reftReclaimTimeOfLastEngineerDeathByArmyIndex = 4 --Table: [a] where a is the army index, and it returns the time the last engineer died
    --refReclaimTimeLastEnemySightedByArmyIndex = 5
    --refsSegmentMidpointLocationRef = 6
    --refiReclaimTotalPrev = 7 --Previous total reclaim mass in a segment
    refSegmentReclaimTotalEnergy = 8
--tLastReclaimRefreshByGroup = {} --time that last refreshed reclaim positions for [x] group
--iLastReclaimRefresh = 0 --stores time that last refreshed reclaim positions
--refiLastRefreshOfReclaimAreasOfInterest = 'M28MapLastRefreshOfReclaim'
--refiTotalReclaimAreasOfInterestByPriority = 'M28MapReclaimAreasOfInterestCount' --[1] = total for priority 1, etc.; up to 4 priority
--reftReclaimAreasOfInterest = 'M28MapReclaimAreasOfInterest' --assigned to aiBrain, [1] = priority (1, 2, 3); [2] = {segmentx, segmentz}
--reftReclaimAreaPriorityByLocationRef = 'M28MapReclaimAreaPriorityByLocationRef' --key is location ref
iReclaimSegmentSizeX = 0 --Updated separately
iReclaimSegmentSizeZ = 0 --Updated separately
--iReclaimAreaOfInterestTickCount = 0 --Updated as part of may reclaim update loop, used to avoid excessive load on an individual tick
--bReclaimRefreshActive = false --Used to avoid duplciating reclaim update logic



--Plateaus - core (NOTE: Some of these variables wont work for a plateau that has no mexes)
tPathingPlateauAndLZOverride = {} --Global, Pathing override where no plateau recognised; key is [math.floor(x)][math.floor(z)] and returns {iPlateau, iLandZone}
tbTempConsideredLandPathingForLZ = {} --Global, used to track if we have considered land pathing for this LZ as part of the initial LZ setup
tNearestPlateauOrZeroAndZoneSegmentOverride = {} --Global, [x] is segmentx, [y] is segmenty, returns the Plateau (0 if water zone) and land/water zone reference to use; closest is based on straight line dist

tAllPlateaus = {} --[x] = AmphibiousPathingGroup, [y]: subrefs, e.g. subrefPlateauMexes;
--aibrain variables for plateaus (not currently incorporated):
reftPlateausOfInterest = 'M28PlateausOfInterest' --[x] = Amphibious pathing group; will record a table of the pathing groups we're interested in expanding to, returns the location of then earest mex
--refiLastPlateausUpdate = 'M28LastTimeUpdatedPlateau' --gametime that we last updated the plateaus
--reftOurPlateauInformation = 'M28OurPlateauInformation' --[x] = AmphibiousPathingGroup; [y] = subref, e.g. subrefPlateauLandFactories; Used to store details such as factories on the plateau
--refiOurBasePlateauGroup = 'M28PlateausOurBaseGroup' --Segment group of our base (so can easily check somewhere is in a dif plateau)

--subrefs for tables
--tAllPlateaus[iPlateau] subrefs
    subrefPlateauMexes = 'M28PlateauMex' --[x] = mex count, returns mex position
    subrefPlateauMinXZ = 'M28PlateauMinXZ' --{x,z} min values
    subrefPlateauMaxXZ = 'M28PlateauMaxXZ' --{x,z} max values - i.e. can create a rectangle covering entire plateau using min and max xz values
    subrefPlateauTotalMexCount = 'M28PlateauMexCount' --Number of mexes on the plateau
    subrefPlateauReclaimSegments = 'M28PlateauReclaimSegments' --[x] = reclaim segment x, [z] = reclaim segment z, returns true if part of plateau
    subrefPlateauMidpoint = 'M28PlateauMidpoint' --Location of the midpoint of the plateau
    subrefPlateauMaxRadius = 'M28PlateauMaxRadius' --Radius to use to ensure the circle coveres the square of the plateau

    subrefPlateauEngineers = 'M28PlateauEngineers' --[x] is engineer unique ref (per m28engineer), returns engineer object
    --Plateaus: Island variables (against tAllPlateaus[iPlateau])
    subrefPlateauIslandLandZones = 'M28PlateauIslands' --[x] is the island, returns a table of land zones in that island for this plateau; the table returned has a key 1....x, and returns the land zone reference number
    subrefPlateauIslandMexCount = 'M28IslandMexCount' --[x] is the island, returns the number of mexes in the island

--Plateaus - Land zone variables (still against tAllPlateaus[iPlateau]
    subrefLandZoneCount = 'M28PlateauZoneCount' --against the main plateau table, records how many land zones there are (alternative to table.getn on the land zones)
    subrefPlateauLandZones = 'M28PlateauLandZones' --against the main plateau table, stores info on land zones for that plateau

iLandZoneSegmentSize = 5 --Gets updated by the SetupLandZones - the size of one side of the square that is the lowest resolution land zones go to; each segment that is land pathable gets assigned to a land zone
    --Land zone subrefs (against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]):
        subrefLZMexCount = 'MexCount' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns number of mexes in the LZ
        subrefLZMexLocations = 'MexLoc' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns table of mex locations in the LZ, e.g. get with tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefLZMexLocations]
        subrefMexUnbuiltLocations = 'MexAvailLoc' --used by water and land zones; e.g. for LZ is against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns table of mex locations in the LZ, e.g. get with tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefLZMexLocations]
        refiTimeOfLastMexDeath = 'MexLstDth' --Gametimeseconds that a mex died in this land zone - used to avoid sending an error message if it is rebuilt immediately (due to the mex deaht logic having a delay)
        subrefMidpoint = 'Midpoint' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns the midpoint of the land zone, e.g. get with tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefMidpoint]
        subrefLZMinSegX = 'LZMinSegX'
        subrefLZMinSegZ = 'LZMinSegZ'
        subrefLZMaxSegX = 'LZMaxSegX'
        subrefLZMaxSegZ = 'LZMaxSegZ'
        subrefHydroLocations = 'HydroLoc' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns table of hydro locations in the LZ
        subrefHydroUnbuiltLocations = 'HydroAvailLoc' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns table of hydro locations in the LZ that dont have buildings on them
        subrefBuildLocationsBySizeAndSegment = 'BuildLoc' --contains a table, [buildingsize][SegX][SegZ], returns true if can build on the location
        subrefBuildableSizeBySegment = 'BuildSizSeg' --Table, [x] segment, [z] segment, returns highest size of building that can be built from the segment midpoint
        subrefSegmentsConsideredThisTick = 'BuildSTisT' --Number of segments that have been through to analyse the largest build size available
        subrefBuildLocationSegmentCountBySize = 'BuildSegment' --[x] is the building size considered, returns Number of segments that we have considered when identifying segment build locations for the land zone for that particular size
        subrefiLastSegmentEntryConsideredForBuilding = 'BuildLastSeg' --returns the segment ref in the LZ valid segment listings (i.e. subrefLZSegments) that we last considered
        subrefQueuedLocationsByPosition = 'BuildQu' --[x] is floor(x), y is floor(z), returns true if queued
        subrefBuildLocationBlacklistByPosition = 'Blacklst' --[x] is floor(x), [y] is floor(z), returns true if blacklisted
        --subrefBuildLocationBlacklist = 'Blacklst' --[x] is the entry, returns the location
            --subrefBlacklistLocation = 1
            --subrefBlacklistSize = 2 --radius of the square, i.e. if do a square around the location where eaech side is this * 2 in length, then will cover the blacklist location
            --subrefBlacklistType = 3
                --BlacklistTimeout = 1 --i.e. we have tried building something for ages and have failed
                --BlacklistReserved = 2 --i.e. we dont want to build anything here because it's being saved for something--]]
        subrefLZMassStorageLocationsAvailable = 'MassStorageLocations' --Against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], Returns table of locations which should be valid to build on for mass storage
        subrefLZSegments = 'Segments' --Contains a table which returns the X and Z segment values for every segment assigned to this land zone
        subrefLZTotalSegmentCount = 'SegCount' --Number of segments in a land zone, against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
        subrefLZAdjacentLandZones = 'AdjLZ' --table containing all adjacent land zone references for the plateau in question, against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], i.e. ordered 1,2,3,...; and returns the LZ ref (based on the order it was added)
        subrefLZPathingToOtherLandZones = 'PathLZ' --table containing the land zone ref of some (but not all) other LZs where have recorded the paths and time taken, sorted by closest LZ first
            subrefLZNumber = 1 --Land zone reference number
            subrefLZPath = 2 --against subrefLZPathingToOtherLandZones subtable, returns a table [x]=1,2,3...; which returns the land zone reference for each land zone that will go through on a path from these
            subrefLZTravelDist = 3 --against subrefLZPathingToOtherLandZones subtable
        subrefLZPathingToOtherLZEntryRef = 'PathRfLZ' --[x] is the target LZ reference; will return the entry in subrefLZPathingToOtherLandZones containing this path, if there is one
        subrefLZTravelDistToOtherLandZones = 'TravelLZ' --table used to store all land travel distance calculations to get from one LZ to another LZ; similar to subrefLZPathingToOtherLandZones, but intended to allow for all land zones to be recorded
        subrefLZPathingToOtherIslands = 'PathIsl' --array, [x] = (1, 2...); Ordered based on shortest travel distance; ONLY DONE FOR ZONES WITH MEXES
            subrefIslandNumber = 1 --Island reference number
            subrefIslandClosestLZRef = 2 --LZ ref of the LZ closest to us in this island
            subrefIslandTravelDist = 3 --Amphibious travel distance from the land zone to the closestLZRef in the IslandNumber
            subrefIslandLZPath = 4 --table of the land zones that an amphibious unit would go through to get from this LZ to the ClosestLZRef
        subrefAdjacentWaterZones = 'LZAdjWZ' --table of details for water zones adjacent to the land zone
            subrefAWZRef = 1 --The water zone reference
            subrefAWZDistance = 2 --Distance between midpoint from LZ to the WZ
        subrefLZFurthestAdjacentLandZoneTravelDist = 'FurthestAdjLZ' --Returns the travel distance (rounded up) of the furthest immediately adjacent land zone - can combine with subrefLZPathingToOtherLandZones so can stop cycling through the prerecorded LZs once get further away than the immediately adjacent ones
        subrefOtherLandAndWaterZonesByDistance = 'AirAdjLZWZ' --orders land and air zones by distance, contains subtable with the following info:
            subrefiPlateauOrPond = 1
            subrefiLandOrWaterZoneRef = 2
            subrefbIsWaterZone = 3
            subrefiDistance = 4 --straight line distance
        subrefLZPlayerWallSegments = 'PlWalls' --Table of wall units that aren't owned by M28AI
        --Reclaim related (same values used for water zone)
        subrefReclaimSegments = 'ReclSeg' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], table, orderd 1,2,3...; returns {iReclaimSegmentX, iReclaimSegmentZ}
        subrefTotalMassReclaim = 'RecMass' --total mass reclaim in the land zone
        subrefLZTotalEnergyReclaim = 'RecEn' --Total energy reclaim in the land zone
        subrefLastReclaimRefresh = 'RecTime' --Time that we last refreshed the reclaim in the land zone, against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
        subrefiTimeFailedToGetReclaim = 'RecTmFl' --Gametimeseconds that engineers failed to be given an order to reclaim something when on reclaimorder duty for this land or water zone (same ref for both types of zone)

        --Land scout/intel related
        subreftPatrolPath = 'PatrPth' --table of locations intended for a land scout to patrol the perimeter of the land zone / water zone

        --Island related
        subrefLZIslandRef = 'Island' --the island ref of the land zone (can also get by using NavUtils.GetLabel(refPathingTypeHover) for the midpoint

        --Capture and repair (done on zone rather than team basis, since intended for civilian targets and/or objectives so want to consider for all M28 teams; same ref used for water zones
        subreftoUnitsToCapture = 'UnitsToCap'
        subreftoUnitsToRepair = 'UnitsToRep'

        --Land zone subteam data (update M28Teams.TeamInitialisation function to include varaibles here so dont have to check if they exist each time)
        subrefLZTeamData = 'Subteam' --tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData] - Table for all the data by team for a plateau's land zone
            --Variables that are against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData]:
            subrefLZTValue = 'ZVal' --Value of the zone factoring in mass, reclaim, and allied units
            subrefLZSValue = 'ZBVal' --Value of friendly buildings in the land zone
            subrefLZbCoreBase = 'ZCore' --true if this is considered a 'core base' land zone
            subrefLZCoreExpansion = 'ZExp' --true if considered the main land zone for an expansion (e.g. on an island); nil if we havent considered yet if it is a core expansion, and false if we have considered and it isnt
            subrefbCoreBaseOverride = 'ZCreO' --true if we want to make this locatio na core zone even if it doesnt meet the normal criteria (e.g. to be used when we run out of places to build in our actual core LZ)
            subrefLZExpansionOverride = 'ZExpO' --true if want to make this location a core expansion even if doesnt meet normal criteria (e.g. if we use transport to drop somewhere on same island but far away, then building land facs there may be of use)
            subrefAlliedACU = 'AACU' --table of ACU units for the land zone (so can factor into decisions on support and attack)
            subrefLZTAlliedUnits = 'Allies' --USE SAME REF AS FOR WATER ZONES - table of all allied units in the land zone, tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam][subrefLZTAlliedUnits]
            subrefLZTAlliedCombatUnits = 'AllComb' --table of allied units that are to be considered for combat orders
            subrefiTimeOfLastEnemyUnitPosUpdate = 'EnPosTim' --Gametimeseconds that we updated the last known position of enemy units in this zone
            subrefTEnemyUnits = 'Enemies' --table of all enemy units in the land zone or water zone (same ref used for WZ)
            reftoNearestDFEnemies = 'NearestDF' --Table of enemy DF units in this LZ, plus the nearest DF unit in each adjacnet LZ, with proximity based on unit distance and unit range (i.e. the dist until the unit is in range)
            --Ground threat values for land zones (also against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam])
            subrefTThreatEnemyCombatTotal = 'ECTotal'
            subrefLZTThreatAllyCombatTotal = 'ACTotal'
            subrefLZDFThreatWanted = 'DFWanted'
            subrefLZMAAThreatWanted = 'MAAThreatWanted'
            subrefiNearbyEnemyLongRangeThreat = 'NrEnLRT' --Number equalling the threat value; intended for fatboys who can outrange adjacent land zones - for enemies that arent in this zone but have a long range and are close to being in range of this zone
            subrefoNearbyEnemyLongRangeThreats = 'NrEnLRU' --As above, but a table of the units (likely a table of fatboys)
            subrefLZThreatEnemyMobileDFByRange = 'EMDFByRange'
            subrefLZThreatEnemyMobileDFTotal = 'EMDFTo'
            subrefLZThreatAllyMobileDFByRange = 'AMDFByRange'
            subrefLZThreatAllyMobileDFTotal = 'ATDFT'
            subrefLZThreatEnemyMobileIndirectByRange = 'EMIFByRange'
            subrefLZThreatEnemyMobileIndirectTotal = 'EMIFTo'
            subrefLZThreatAllyMobileIndirectByRange = 'AMIFByRange'
            subrefLZThreatAllyMobileIndirectTotal = 'ATIFT'
            subrefLZThreatEnemyBestMobileDFRange = 'EBDFR'
            subrefLZThreatEnemyBestStructureDFRange = 'EBSDFR'
            subrefLZThreatEnemyBestMobileIndirectRange = 'EBIR'
            subrefThreatEnemyStructureTotalMass = 'ESTM' --Used for LZ and WZ, returns total mass in buildings


            subrefLZThreatEnemyStructureDFByRange = 'ESDFByRange'
            subrefLZIndirectThreatWanted = 'IFWanted'
            subrefLZThreatAllyStructureDFByRange = 'ASDFByRange'
            subrefLZThreatEnemyStructureIndirect = 'ESITotal'
            subrefLZThreatAllyStructureIndirect = 'ASITotal'
            subrefLZThreatEnemyGroundAA = 'EAATotal'
            subrefLZThreatAllyGroundAA = 'AAATotal'
            subrefLZThreatAllyMAA = 'MAATotal' --only MAA, excludes structure
            subrefbEnemiesInThisOrAdjacentLZ = 'NearbyEnemies' --true if this LZ or adjacent LZ have nearby enemies
            subrefbDangerousEnemiesInThisLZ = 'HasDangEnemy' --true if combat units in this LZ
            subrefbDangerousEnemiesInAdjacentWZ = 'WZNearEnemies' --true if there is an adjacent water zone that has dangerous enemies
            subrefbLZWantsSupport = 'LZWantsSupport' --true if want DF or indirect units for the LZ
            subrefbLZWantsDFSupport = 'LZWantsDFSupport' --true if want DF units for the LZ
            subrefbLZWantsIndirectSupport = 'LZWantsIndirectSupport' --true if want indirect units for the LZ
            subrefiTimeOfMMLFiringNearTMD = 'LZTimMMLFNrTMD' --Gametimeseconds that had MML firing in the zone who were near TMD

            subreftEnemyFirebasesInRange = 'LZEnemyFirebasesInRange' --[x] is just a count (1,2,3), returns {iPlateau, iLandZone} of the firebase
            subreftoEnemyTMD = 'LZEnemyTMD' --TMD owned by the enemy in the LZ
            subreftoEnemyPotentialTMLTargets = 'LZPotentialTMLTargets' --potential targets for TML in the LZ (ignoring TMD)

            --Engineer related values
            subreftoPartBuiltMexes = 'PBMex' --If we are building a mex and the builder gets its orders cleared or dies, and it was building a mex, then the mex should be recorded in a table so it can be rebuilt
            subrefTbWantBP = 'WantBP' --true if we want BP at any tech level
            subrefTBuildPowerByTechWanted = 'BPByTechW' --{[1]=a, [2]=b, [3]=c} where a,b,c are the build power wanted wanted
            subreftbBPByFactionWanted = 'BPByFaction' --[x] = faction ref, returns true if we want engineers of that faction
            subrefTEngineersTravelingHere = 'EUnitsTrav' --Table of any engineer units in another LZ/WZ that have been told to move to this LZ/WZ
            subrefTScoutsTravelingHere = 'SUnitsTrav' --Table of any land scout units in another LZ/WZ that have been told to move to this LZ/WZ
            subrefSpareBPByTech = 'SpareBPByTech' --{[1]=a, [2]=b, [3]=c} where a,b,c are the build power of that tech level that we have spare
            subrefReclaimAreaAssignmentsBySegment = 'RecSegAss' --[ReclaimSegX][ReclaimZegY], returns count of how many engineers have been assigned
            subrefQueuedBuildings = 'QBByBP' --Queued buildings for a land zone
                subrefQueueRef = 1 --Unique queue reference number
                subrefBuildingID = 2 --Blueprint/UnitId of the building queued
                subrefBuildingLocation = 3 --Location the building is to be built at
                subrefBuildingRadius = 4 --Size (radius) of the building
                subrefPrimaryBuilder = 5 --Engineer given the build order
            subreftiPotentialNukeTargetZones = 'NkTrgtZ' --contains subtables, ordered 1,2,...x returning {iPlateauOrZero, iLandOrWaterZone} for each zone that can probably be hit by a nuke from this zone
            --subrefLZTAdjacentBPByTechWanted = 'AdjBPByTechW' --{[1]=a, [2]=b, [3]=c} where a,b,c are the build power wanted wanted
            --Economy related values
            subrefActiveUpgrades = 'ActiveUpgrades' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam]
            subrefMexCountByTech = 'MexByTech' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam], returns {[1]=x,[2]=y,[3]=z} where xyz are counts of mexes
            subreftoUnitsToReclaim = 'UnitToRec' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam], table of units that we should reclaim
            --Intel related values
            refbWantLandScout = 'LandScout' --True/false, used by water and land zones
            refiRadarCoverage = 'RadCov' --Radar coverage of the centre of the land zone midpoint
            refiOmniCoverage = 'OmnCov' --Omni coverage of the centre of the land or water zone midpoint
            refiSonarCoverage = 'SonCov' --Sonar coverage of the centre of the land or water zone midpoint (intended for water zones)
            refoBestRadar = 'BestRad' --Radar providing the best Radar Coverage for the land zone midpoint
            refoBestSonar = 'BestSon' --Sonar providing the best sonar coverage for the water zone midpoint
            refiTimeLastHadVisual = 'LstVis' --Gametimeseconds that last had an intel unit (e.g. land or air scout) in the land or water zone
            refiScoutingPriority = 'SctPrio' --will return the scouting priority (i.e. 1, 2 or 3 per below subrefs)
                subrefiScoutingHighPriority = 1
                subrefiScoutingMediumPriority = 2
                subrefiScoutingLowPriority = 3
            refiRecentlyFailedScoutAttempts = 'SctFail' --if a scout dies trying to reach here, this should increase the failure count
            --Enemy air
            reftLZEnemyAirUnits = 'EnAir' --All enemy air units that are currently in the land zone
            refiEnemyAirToGroundThreat = 'EnA2GT' --Air to ground threat of enemy air units in the LZ / WZ
            refiEnemyAirAAThreat = 'EnAAT' --AirAA threat in the LZ/WZ
            refiEnemyAirOtherThreat = 'EnAirOT' --mass value of AirAA, air scouts and transports in the LZ / WZ
            refiTimeOfLastAirUpdate = 'EnAirTim' --Gametimeseconds that last refreshed the positiosn of air units (done given high mobility of air to approximate a human player realising the air force is no longer there)
            --Shield, stealth and tmd
            refbLZWantsMobileShield = 'MobSh' --true if LZ wants mobile shields
            reftoLZUnitsWantingMobileShield = 'UMobSh' --table of units in the LZ that want mobile shield
            reftoLZUnitWantingFixedShield = 'UFixSh' --table of untis in the LZ taht want a fixed shield
            reftPriorityShieldsToAssist = 'FShAss' --Table of fixed shields that want to assist
            refiTimeOfLastShieldPriorityRefresh = 'FSTimC' --Time that we last updated the list of priority shields to be assisted
            refbLZWantsMobileStealth = 'MobSt' --true if LZ wants mobile stealth
            reftoLZUnitsWantingMobileStealth = 'UMobSt' --table of units in the LZ that want mobile stealth
            reftUnitsWantingTMD = 'TMDW' --table of units in the LZ that want TMD coverage
            reftoUnitsForSpecialShieldProtection = 'GmEnd' --I.e. gameenders (and possibly T3 arti) that we want to protect with special shield covering logic
            reftFactoriesWantedForEngineers = 'FEng' --table of factory units that are assigend against a unit (e.g. a gameender) as providing engineers of a particular faction (e.g. for shields)
            --Misc
            reftClosestFriendlyBase = 'ClosestFB' --Position of the closest friendly start position
            reftClosestEnemyBase = 'ClosestEB' --Closest enemy start position to water zone or land zone (i.e. same variable used by both)
            refiModDistancePercent = 'ModDPC' --For LZ and WZ; e.g. LZ is against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam], mod dist based on closest friendly start position to closest enemy start position
            refbIslandBeachhead = 'IslBeachd' --true if we are sending units to a closest island LZ to try and attack enemy - means will check for nearby untis vs enemy nearby units when deciding whether to attack or not
            refiTimeOfLastTorpAttack = 'TLstTorp' --Gametimeseconds that last sent torpedo bombers to attack units in this location
            reftoTransportsWaitingForEngineers = 'TWntEng' --Table of any transports in this LZ wanting engineers
            refiTimeLastBuiltAtFactory = 'TLstBFac' --Gametimeseconds that a factory last tried ot build (used to make sure we spread things out by several ticks)
            reftoGroundFireFriendlyTarget = 'TGFTrg' --Location of a ground fire target that we wont be trying to target via normal means, e..g intended for Cybran mission 2 where need to ground fire temples that dont show as enemies and cant be reclaimed

--Pond and naval variables
    --General
iMinPondSize = 1000 --1000 is a small pond that probably barely fits a couple of naval factories
iMinWaterDepth = 1.5 --Ships cant move right up to shore, this is a guess at how much clearance is needed (testing on Africa, depth of 2 leads to some pathable areas being considered unpathable)
bHaveConsideredPreferredPondForM28AI = false --Used to make sure we dont try and create water zones until we have setup the factory build locations for each M28AI
bHaveRecordedPonds = false --set to true once finished the RecordPonds logic
    --Ponds:
tPondDetails = {}
    subreftiWaterSegmentXZ = 'WatSegXZ' --returns table, index is sequentially from 1, returns {segmentX, SegmentZ}
    subrefiSegmentCount = 'WatSegCnt' --Number of segments for a particular pond (means can quickly tell the size of the pond)
    subrefiRecordedSegmentsInWaterZones = 'WatSegRCnt' --Number of segments recorded against a specific water zone for this pond
    --subrefPondSize - use subrefiSegmentCount instead
    subrefPondMinX = 'PondMinX'
    subrefPondMinZ = 'PondMinZ'
    subrefPondMaxX = 'PondMaxX'
    subrefPondMaxZ = 'PondMaxZ'
    subrefPondMidpoint = 'PondMidpoint'
--subrefPondNearbyBrains = 'PondNearbyBrains'
    subrefPondMexInfo = 'PondMexInfo'
        subrefMexLocation = 'PondMexLocation'
        subrefMexDistance = 'PondMexDistance'
        subrefMexDFDistance = 'PondMexDFDistance'
        subrefMexDFUnblockedLocation = 'PondMexDFLocation' --i.e. the closest location we found where a DF unit should be able to hit the mex
        subrefMexIndirectDistance = 'PondMexIndirectDistance'
        subrefMexIndirectUnblockedLocation = 'PondMexIndirectLocation' --i.e. the closest location we found where an indirect unit should be able to hit the mex
    subrefBuildLocationByStartPosition = 'PondBuildLocationByStart' --Subtable, key is start position number, which stores the build location for that start position (will only record for M28 brain start positions)

    --Water zones (against tPondDetails)
    subrefPondWaterZones = 'PondWZ' --e.g. access the water zone data tables via M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone], where iWaterZone is the NavUtils refPathingTypeNavy pathing result
        subrefWZMexCount = 'MexCount' --(same ref as for land zones; reason for repating is to avoid confusion with the pond variables which track different information)
        subrefWZMexLocations = 'MexLoc' --(same ref as for land zones)
        --subrefMexUnbuiltLocations Uses same ref as LZ

        --subrefMidpoint = 'Midpoint' --Uses same ref as land zone
        refiMidpointAmphibiousLabel = 'MPAmphbL' --Navutils label for the midpoint of the water zone; same ref is used for land zones
        subrefWZSegments = 'PWZSeg' --e.g. tPondDetails[iPond][subrefPondWaterZones][iWaterZone][subrefWZSegments]
        subrefWZMinSegX = 'PWZMinSX'
        subrefWZMinSegZ = 'PWZMinSZ'
        subrefWZMaxSegX = 'PWZMaxSX'
        subrefWZMaxSegZ = 'PWZMaxSZ'
        subrefAdjacentLandZones = 'WZAdjLZ' --table of details for land zones adjacent to the land zone
            subrefWPlatAndLZNumber = 1 --returns {Plateau, LandZone}
            subrefALZDistance = 2 --Distance between midpoint from LZ to the WZ
        subrefWZAdjacentWaterZones = 'WZAdjWZ' --table of water zones that are adjacent, i.e. returns {x,y,z,...} where x y z are the water zone references for adjacent water zones
        subrefWZOtherWaterZones = 'WZOthWZ' --table of details for water zones adjacent and further away, ordered by distance
            subrefWZAWZRef = 1 --the water zone reference
            subrefWZAWZDistance = 2 --Travel distance between the midpoints of the water zones
        --Reclaim related - uses same values as water zone
        --subrefReclaimSegments
        --subrefTotalMassReclaim
        --subrefLZTotalEnergyReclaim
        --subrefLastReclaimRefresh

        subrefWZTeamData = 'PWZTeam' --Used to house team related data for a particular water zone
            subrefWZbCoreBase = 'LZCoreB' --true if is a 'core' base (i.e. has a naval factory in); uses same ref as LZbCoreBase
            subrefWZbContainsUnderwaterStart = 'WZUndwSt' --true if an M28brain start position is in this water zone and is underwater
            subrefWZbContainsNavalBuildLocation = 'WZNavBL' --true if contains a naval build location for a friendly M28AI
            subrefWZTValue = 'WZVal' --Value of the WZ, used to prioritise sending untis to different water zones; likely to be based on distance to core base water zone
            --refiRadarCoverage - use same ref as for land zone
            --refiOmniCoverage - use same ref as land zone
            --refoBestRadar - use same ref as for land zone
            --refiTimeLastHadVisual -use same ref as for land zone
            --reftClosestFriendlyBase - use same ref as for land zone
            --reftClosestEnemyBase - use same ref as for land zone
            --refiModDistancePercent - use same ref as for land zone
            --refbWantLandScout - use same ref as for land zone
            --subreftPatrolPath - use same ref as for land zone
            --subrefOtherLandAndWaterZonesByDistance - use same ref as for land zone

            subrefWZTAlliedUnits = 'Allies' --USE SAME REF AS FOR LAND ZONE - table of all allied units in the water zone
            subrefWZTAlliedCombatUnits = 'AllComb' --table of allied units that are to be considered for combat orders
            --subrefTEnemyUnits = 'Enemies' --table of all enemy units in the water zone - uses same ref as for land zone
            reftWZEnemyAirUnits = 'EnAir' --All enemy air units that are currently in the water zone
            --Threat values
            subrefbEnemiesInThisOrAdjacentWZ = 'EnInAdjWZ' --true if enemy in this or adjacent WZ; for land zones this will return true if any adjacent WZ has enemies

            --subrefThreatEnemyStructureTotalMass - uses same ref as for LZ
            --subrefTThreatEnemyCombatTotal = 'ECTotal' --Uses same ref as for LZ
            subrefWZThreatEnemyAntiNavy = 'EnANav'
            subrefWZThreatEnemySubmersible = 'EnSub'
            subrefWZThreatEnemySurface = 'EnSurf'
            subrefWZThreatEnemyAA = 'EnEAA' --Think this is just the ground based AA not airaa
            subrefWZBestEnemyDFRange = 'EnDFRnge'
            subrefWZBestEnemyAntiNavyRange = 'EnANavRng'

            reftoNearestCombatEnemies = 'WNrSufE'

            subrefWZTThreatAllyCombatTotal = 'AlCom'
            subrefWZThreatAlliedAntiNavy = 'AlANav'
            subrefWZThreatAlliedSubmersible = 'AlSub'
            subrefWZThreatAlliedSurface = 'AlSurf'
            subrefWZThreatAlliedAA = 'AlAA'
            subrefWZBestAlliedDFRange = 'AlDFRnge'
            subrefWZBestAlliedSubmersibleRange = 'AlANavRng'
            refiLastBombardmentSearchRange = 'WZBmbRng' --Last range used for searching for bmobardment targets
            refbLastBombardmentSearchRangeSuccess = 'WZBmbSuc' --true if last time searched for enemies aroudn a location it found results

            subrefWZCombatThreatWanted = 'CombWant'
            subrefWZMAAThreatWanted = 'MAAWant'
            subrefbWZWantsSupport = 'WZWntSup'
            subrefbWZOnlyHoverEnemies = 'WZHvEn' --true if only hover units (so we dont want to send subs to support)
            subrefbWZOnlySubmersibleEnemies = 'WZSubEn' --true if only submersible enemies (so we dont want to send units without antinavy to support)

            reftoWZUnitsWantingMobileShield = 'MShUnit'
            refbWZWantsMobileShield = 'bWntMSh'
            reftoWZUnitsWantingMobileStealth = 'MStUnit'
            refbWZWantsMobileStealth = 'bWntMSt'

            --T3 arti (same ref used for LZ and WZ):
            subrefiIneffectiveArtiShotCount = 'T3ArtC' --Every time t3 arti fires a shot at a zone this increases, when it does notable damage this decreases

            --subrefTScoutsTravelingHere - uses same variable as land zone
            --subrefAlliedACU --Uses same variable as land zone
            --refiEnemyAirToGroundThreat --Uses same variable as land zone
            --refiEnemyAirOtherThreat --Uses same variable as land zone
            --subrefTotalMassReclaim --Uses same variable as land zone
            --Various engineer related variables - use the same references as for land zones



tPondBySegment = {} --[x][z] are the x and z segments based on iLandZoneSegmentSize, shoudl return the pond number (which is also the same as doing NavUtils.GetLabel(refPathingTypeNavy, tPosition)
tiPondByWaterZone = {} --[x] is the water zone ref, returns the pond that it belongs to
tWaterZoneBySegment = {} --[x][z] should be the x and z segments baed on iLandZoneSegmentSize, and should return the water zone number, or nil if there is none
iTotalWaterZoneCount = 0 --Unique value for waterzones so if know the waterzone reference then can identify the pond and other information just from this
iTotalWaterZoneRecordedSegmentCount = 0 --total number of segments regorded against water zones
iTotalSegmentsInPonds = 0 --Total number of segments which appear to be on water

--Land pathing segment data
tLandZoneBySegment = {} --[x][z] should be the x and z segments baed on iLandZoneSegmentSize, and should return the land zone number, or 0 if there is none
tTempZoneTravelDistanceBySegment = {} --[x][z][LZ] should be the x and z segments, used to temporarily store the distance values for segments at start of the game when setting up land zones
tTempZonePlateauBySegment = {} --[x][z][LZ] shoudl be the plateau; used as a backup where we could find a LZ nearby but not a plateau


--General aiBrain variables
reftPrimaryEnemyBaseLocation = 'M28PrimaryEnemyBase' --against aiBrain, returns location of the nearest enemy base
refiLastTimeCheckedEnemyBaseLocation = 'M28MapLastTimeCheckedEnemyBase' --against aiBrain, gametimeseconds that last checked the enemy base location
reftMidpointToPrimaryEnemyBase = 'M28MapMidpointToPrimaryEnemy' --against aiBrain, midpoint between the start position and the nearest enemy start position
refbCanPathToEnemyBaseWithLand = 'M28MapCanPathToEnemyWithLand'
refbCanPathToEnemyBaseWithAmphibious = 'M28MapCanPathToEnemyWithAmphibious'

---@param tPosition table
---@return number, number
function GetPathingSegmentFromPosition(tPosition)
    --The map is divided into equal sized square segments with each segment allocated to a land zone; this can be used to get the segment X and Z references
    --tPosition shoudl be {x,y,z} format, although y value is ignored)
    return math.floor( (tPosition[1] - rMapPotentialPlayableArea[1]) / iLandZoneSegmentSize) + 1, math.floor((tPosition[3] - rMapPotentialPlayableArea[2]) / iLandZoneSegmentSize) + 1
end

---@param iSegmentX number
---@param iSegmentZ number
---@return table
function GetPositionFromPathingSegments(iSegmentX, iSegmentZ)
    --Returns the position/location of land segment X and Z references iSegmentX and iSegmentZ (i.e. the map is divided into equal sized square segments, with each segment allocated to a land zone)
    local x = iSegmentX * iLandZoneSegmentSize - iLandZoneSegmentSize * 0.5 + rMapPotentialPlayableArea[1]
    local z = iSegmentZ * iLandZoneSegmentSize - iLandZoneSegmentSize * 0.5 + rMapPotentialPlayableArea[2] --If changing this, then also update AssignRemainingSegmentsToLandZone which manually does this for performance
    return {x, GetTerrainHeight(x, z), z}
end

function GetPathingOverridePlateauAndLandZone(tPosition, bOptionalShouldBePathable, oOptionalPathingUnit)
    local iX = math.floor(tPosition[1])
    --if (oOptionalPathingUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oOptionalPathingUnit) or 'nil') == 'uel02031' then LOG('GetPathingOverridePlateauAndLandZone: iPlateau is nil or 0, tPosition='..repru(tPosition)..'; tPathingPlateauAndLZOverride[ix]='..repru(tPathingPlateauAndLZOverride[iX])..'; bOptionalShouldBePathable='..tostring(bOptionalShouldBePathable or false)..'; Is oOptionalPathingUnit valid='..tostring(M28UnitInfo.IsUnitValid(oOptionalPathingUnit))) end
    --LOG('GetPathingOverridePlateauAndLandZone: iPlateau is nil or 0, tPosition='..repru(tPosition)..'; tPathingPlateauAndLZOverride[ix]='..repru(tPathingPlateauAndLZOverride[iX])..'; bOptionalShouldBePathable='..tostring(bOptionalShouldBePathable or false)..'; Is oOptionalPathingUnit valid='..tostring(M28UnitInfo.IsUnitValid(oOptionalPathingUnit)))
    if tPathingPlateauAndLZOverride[iX] then
        local iZ = math.floor(tPosition[3])
        if tPathingPlateauAndLZOverride[iX][iZ] then
            --if (oOptionalPathingUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oOptionalPathingUnit) or 'nil') == 'uel02031' then LOG('GetPathingOverridePlateauAndLandZone: Have a valid override so will return this, override='..repru(tPathingPlateauAndLZOverride[iX][iZ])) end
            --LOG('GetPathingOverridePlateauAndLandZone: Have a valid override so will return this, override='..repru(tPathingPlateauAndLZOverride[iX][iZ]))
            return tPathingPlateauAndLZOverride[iX][iZ][1], tPathingPlateauAndLZOverride[iX][iZ][2]
        end
    end
    --Dont have an override for here - if we think it shoudl be pathable then create an override
    if bOptionalShouldBePathable and oOptionalPathingUnit then
        --if (oOptionalPathingUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oOptionalPathingUnit) or 'nil') == 'uel02031' then LOG('GetPathingOverridePlateauAndLandZone: No plateau for a unit that should be pathable, tPosition='..repru(tPosition)..'; bOptionalShouldBePathable='..tostring(bOptionalShouldBePathable)..'; oOptionalPathingUnit='..oOptionalPathingUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOptionalPathingUnit)..'; oOptionalPathingUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]='..repru(oOptionalPathingUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam])..'; Unit state='..M28UnitInfo.GetUnitState(oOptionalPathingUnit)..'; iMapWaterHeight='..iMapWaterHeight..'; about to run ConsiderAddingPlateauOverrideForUnit') end
        --LOG('GetPathingOverridePlateauAndLandZone: No plateau for a unit that should be pathable, tPosition='..repru(tPosition)..'; bOptionalShouldBePathable='..tostring(bOptionalShouldBePathable)..'; oOptionalPathingUnit='..oOptionalPathingUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOptionalPathingUnit)..'; oOptionalPathingUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]='..repru(oOptionalPathingUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam])..'; Unit state='..M28UnitInfo.GetUnitState(oOptionalPathingUnit)..'; iMapWaterHeight='..iMapWaterHeight..'; about to run ConsiderAddingPlateauOverrideForUnit')
        if M28Land.ConsiderAddingPlateauOverrideForUnit(oOptionalPathingUnit) then
            if tPathingPlateauAndLZOverride[iX] then
                local iZ = math.floor(tPosition[3])
                if tPathingPlateauAndLZOverride[iX][iZ] then
                    --if (oOptionalPathingUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oOptionalPathingUnit) or 'nil') == 'uel02031' then LOG('GetPathingOverridePlateauAndLandZone: Have a valid override after considering plateau override for unit, override='..repru(tPathingPlateauAndLZOverride[iX][iZ])) end
                    --LOG('GetPathingOverridePlateauAndLandZone: Have a valid override after considering plateau override for unit, override='..repru(tPathingPlateauAndLZOverride[iX][iZ]))
                    return tPathingPlateauAndLZOverride[iX][iZ][1], tPathingPlateauAndLZOverride[iX][iZ][2]
                end
            end
        end
    end
    return nil, nil
end

function GetWaterZoneFromPosition(tPosition)
    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tPosition)
    return tWaterZoneBySegment[iSegmentX][iSegmentZ]
end

---@param tPosition table
---@param bOptionalShouldBePathable boolean
---@return number, number
function GetPlateauAndLandZoneReferenceFromPosition(tPosition, bOptionalShouldBePathable, oOptionalPathingUnit)
    --Returns the plateau reference of tPosition (where tPosition is {x,y,z}), and the Land zone reference for that position
    --returns nil if cant find valid plateau or land zone
    --bOptionalShouldBePathable - if e.g. have a unit at tPosition, then set this to true as it means somehow a unit could path in this area, and the code will then try backup options and give error messages

    --Get the plateau reference and the land segment X and Z references:
    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tPosition)
    local iPlateau = NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iSegmentX, iSegmentZ))
    local iLandZone

    if (iPlateau or 0) <= 0 or not(tAllPlateaus[iPlateau]) then
        --Check if we have previously recorded this location with a pathing override
        --LOG('GetPlateauAndLandZoneReferenceFromPosition iPlateau='..(iPlateau or 'nil'))
        iPlateau, iLandZone = GetPathingOverridePlateauAndLandZone(tPosition, bOptionalShouldBePathable, oOptionalPathingUnit)
        --LOG('GetPlateauAndLandZoneReferenceFromPosition iPlateau after getting override='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil'))
        if not(tAllPlateaus[iPlateau]) then
            --Potential error - see if there is a plateau for the preicse position if it shoudl be pathable

            --LOG('GetPlateauAndLandZoneReferenceFromPosition: tAllPlateaus is nil for iPlateau='..(iPlateau or 'nil')..'; if should be pathable will check the segment we are in/ bOptionalShouldBePathable='..tostring(bOptionalShouldBePathable or false))
            if bOptionalShouldBePathable then
                iPlateau = NavUtils.GetLabel(refPathingTypeHover, tPosition)

                if not(tAllPlateaus[iPlateau]) then
                    if bOptionalShouldBePathable then
                        --If get this error, then refer to GetUnitPlateauAndLandZoneOverride
                        M28Utilities.ErrorHandler('No plateau group for iSegmentX='..iSegmentX..'; iSegmentZ='..iSegmentZ..'; Plateau group of segment midpoint='..(NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iSegmentX, iSegmentZ)) or 'nil')..'; Plateau Group of tPosition='..(NavUtils.GetLabel(refPathingTypeHover, tPosition) or 'nil')..'; This can happen on larger maps with long cliffs with narrow paths that small units can travel partially along. Enable logs in the function GetUnitPlateauAndLandZoneOverride for more details', true)
                    end
                    return nil
                else
                    if tAllPlateaus[iPlateau][subrefPlateauTotalMexCount] == 0 then
                        iLandZone = 1
                    else
                        --more than 1 land zone so return nil
                        iLandZone = nil
                    end
                end
            else
                return nil
            end
        end
        return iPlateau, iLandZone
    else
        --Have a valid plateau, get the land zone reference:
        --local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tPosition)
        iLandZone = tLandZoneBySegment[iSegmentX][iSegmentZ]
        --LOG('GetPlateauAndLandZoneReferenceFromPosition - iLandZOne based on segment='..(iLandZone or 'nil'))
        if not(iLandZone) then
            --Are we above water in height? If so check for override
            if tPosition[2] > iMapWaterHeight then
                local iAltPlateau
                iAltPlateau, iLandZone = GetPathingOverridePlateauAndLandZone(tPosition, bOptionalShouldBePathable, oOptionalPathingUnit)
                --LOG('GetPlateauAndLandZoneReferenceFromPosition: iLandZone after checking for override='..(iLandZone or 'nil'))
                if not(iLandZone) and bOptionalShouldBePathable then
                    --Possible explanation - engineer has traveled across water and reached a cliff
                    if EntityCategoryContains(categories.HOVER + categories.AMPHIBIOUS, oOptionalPathingUnit.UnitId) then
                        --Do nothing - hopefully unit has orders that it will follow that will resolve this on its own; however update the plateau
                    else
                        M28Utilities.ErrorHandler('Unable to find valid land zone, iSegmentX='..(iSegmentX or 'nil')..'; iSegmentZ='..(iSegmentZ or 'nil')..'; Optional pathing unit ID='..(oOptionalPathingUnit.UnitId or 'nil'))
                        --M28Utilities.DrawLocation(tPosition)
                    end
                else
                    if iAltPlateau then
                        iPlateau = iAltPlateau
                    end
                end
            end
        end
    end
    --LOG('GetPlateauAndLandZoneReferenceFromPosition - end of code, iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil'))


    return iPlateau, iLandZone
end

function GetNearestPlateauOrLandOrWaterZoneToLocationFORLOOKUP(tLocation)  --Only to help with lookup - use below function
    return GetClosestPlateauOrZeroAndZoneToPosition(tPosition)
end --Only to help with lookup - use below function
function GetClosestPlateauOrZeroAndZoneToPosition(tPosition)

    --e.g.:
    --                                  iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tEnemyStartPosition)
    --                             if iPlateauOrZero > 0 then
    --                                    tLZOrWZTeamData  = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][aiBrain.M28Team]
    --                                else
    --                                    --Water zone
    --                                tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][aiBrain.M28Team]
    --                            end


    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetClosestPlateauOrZeroAndZoneToPosition'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)




    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tPosition)

    if bDebugMessages == true then LOG(sFunctionRef..': tPosition='..repru(tPosition)..'; iSegmentX='..(iSegmentX or 'nil')..' iSegmentZ='..(iSegmentZ or 'nil')..'; Is override for this nil='..tostring(tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ] == nil)..'; GetPositionFromPathingSegments(iSegmentX, iSegmentZ)='..repru(GetPositionFromPathingSegments(iSegmentX, iSegmentZ))..'; Hover nav utils for segment midpoint='..(NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iSegmentX, iSegmentZ)) or 'nil')..'; Hover nav utils for tPosition='..(NavUtils.GetLabel(refPathingTypeHover, tPosition) or 'nil')..'; tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ]='..repru(tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ])..'; tLandZoneBySegment[iSegmentX][iSegmentZ]='..(tLandZoneBySegment[iSegmentX][iSegmentZ] or 'nil')..'; tWaterZoneBySegment[iSegmentX][iSegmentZ]='..(tWaterZoneBySegment[iSegmentX][iSegmentZ] or 'nil')) end

    if tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ] then
        if bDebugMessages == true then LOG(sFunctionRef..': Returning override, which is:'..repru(tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ])) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ][1], tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ][2]
    else
        local iPlateau = NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iSegmentX, iSegmentZ))
        if bDebugMessages == true then LOG(sFunctionRef..': Position from segments='..repru(GetPositionFromPathingSegments(iSegmentX, iSegmentZ))..'; iPlateau for this='..(iPlateau or 'nil')) end
        if (iPlateau or 0) <= 0 or (tLandZoneBySegment[iSegmentX][iSegmentZ] == nil and tWaterZoneBySegment[iSegmentX][iSegmentZ] == nil) then
            --Need to get an override if dont already have one
            local iAltPlateau, iAltLZOrWZ
            local iFailureCount = 0
            if not(tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX]) then tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX] = {} end
            for iAdjust = 1, math.min(iMaxLandSegmentX, iMaxLandSegmentZ) do
                for iXAdjust = -iAdjust, iAdjust, 1 do
                    for iZAdjust = -iAdjust, iAdjust, 1 do
                        if not(iXAdjust == 0 and iZAdjust == 0) then
                            if tLandZoneBySegment[iSegmentX+ iXAdjust][iSegmentZ+ iZAdjust] or tWaterZoneBySegment[iSegmentX+ iXAdjust][iSegmentZ+ iZAdjust] then
                                local tMidpoint = GetPositionFromPathingSegments(iSegmentX + iXAdjust, iSegmentZ + iZAdjust)
                                tMidpoint = {math.floor(tMidpoint[1]), tMidpoint[2], math.floor(tMidpoint[3])}
                                if tPathingPlateauAndLZOverride[tMidpoint[1]][tMidpoint[3]][2] then
                                    if bDebugMessages == true then LOG(sFunctionRef..': We already recorded an override for this position') end
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                    return tPathingPlateauAndLZOverride[tMidpoint[1]][tMidpoint[3]][1], tPathingPlateauAndLZOverride[tMidpoint[1]][tMidpoint[3]][2]
                                else
                                    iAltPlateau = NavUtils.GetLabel(refPathingTypeHover, tMidpoint)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjust='..iAdjust..'; iXAdjust='..iXAdjust..'; iZAdjust='..iZAdjust..'; iAltPlateau='..(iAltPlateau or 'nil')..'; LandZoneBySegment='..(tLandZoneBySegment[iSegmentX+ iXAdjust][iSegmentZ+ iZAdjust] or 'nil')..'; Water zone by segment='..(tWaterZoneBySegment[iSegmentX+ iXAdjust][iSegmentZ+ iZAdjust] or 'nil')) end
                                    if (iAltPlateau or 0) > 0 then
                                        iAltLZOrWZ = tLandZoneBySegment[iSegmentX+ iXAdjust][iSegmentZ+ iZAdjust]
                                        if (iAltLZOrWZ or 0) == 0 then
                                            iAltLZOrWZ = tWaterZoneBySegment[iSegmentX+ iXAdjust][iSegmentZ+ iZAdjust]
                                            iAltPlateau = 0
                                        end
                                        if (iAltLZOrWZ or 0) > 0 then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Have adjusted segments which have valid values, iAltLZOrWZ='..iAltLZOrWZ..'; iXAdjust='..iXAdjust..'; iZAdjust='..iZAdjust) end
                                            tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ] = {[1] = iAltPlateau, [2] = iAltLZOrWZ}
                                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                            return iAltPlateau, iAltLZOrWZ
                                        else
                                            --Redundancy
                                            iFailureCount = iFailureCount + 1
                                            if iFailureCount >= 20 then
                                                M28Utilities.ErrorHandler('Have a valid plateau for SegmentX-Z='..(iSegmentX + iXAdjust)..'-'..(iSegmentZ + iZAdjust)..' but not a valid land or water zone, and have failed '..iFailureCount..' times now (will reset count after this)')
                                                iFailureCount = 0
                                            end
                                        end
                                    else
                                        if iFailureCount >= 20 then
                                            M28Utilities.ErrorHandler('Have a valid land or WZ for SegmentX-Z='..(iSegmentX + iXAdjust)..'-'..(iSegmentZ + iZAdjust)..' but not a valid plateau, and have failed '..iFailureCount..' times now (will reset count after this)')
                                            iFailureCount = 0
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                if iAdjust >= 100 then M28Utilities.ErrorHandler('Likely error locating valid segment for iSegmentX-Z='..iSegmentX..'-'..iSegmentZ) end
            end
        else
            --Have a valid plateau and land or water zone
            if bDebugMessages == true then LOG(sFunctionRef..': Have a valid plateau, tLandZoneBySegment='..(tLandZoneBySegment[iSegmentX][iSegmentZ] or 'nil')..'; tWaterZoneBySegment='..(tWaterZoneBySegment[iSegmentX][iSegmentZ] or 'nil')) end
            if (tLandZoneBySegment[iSegmentX][iSegmentZ] or 0) == 0 then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return 0, tWaterZoneBySegment[iSegmentX][iSegmentZ]
            else
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return iPlateau, tLandZoneBySegment[iSegmentX][iSegmentZ]
            end
        end
    end
end

---@param tLocation table
---@return number, number
function GetReclaimSegmentsFromLocation(tLocation)
    --Returns the reclaim segment X and Z values for a given location on the map (i.e. map is divided into reclaim segment squares which are a different size to land zone segments)
    --tLocation should be in the {x,y,z} format, although y value is ignored
    return math.ceil(tLocation[1] / iReclaimSegmentSizeX), math.ceil(tLocation[3] / iReclaimSegmentSizeZ)
end

---@param iReclaimSegmentX number
---@param iReclaimSegmentZ number
---@return table
function GetReclaimLocationFromSegment(iReclaimSegmentX, iReclaimSegmentZ)
    --If given the reclaim segment X and Z values, then will convert this into an {x,y,z} position
    --e.g. segment (1,1) will be 0 to ReclaimSegmentSizeX and 0 to ReclaimSegmentSizeZ in size
    --This will return the midpoint of the reclaim segment
    if tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint] then return tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint]
    else
        local iX = math.max(rMapPotentialPlayableArea[1], math.min(rMapPotentialPlayableArea[3], (iReclaimSegmentX - 0.5) * iReclaimSegmentSizeX))
        local iZ = math.max(rMapPotentialPlayableArea[2], math.min(rMapPotentialPlayableArea[4], (iReclaimSegmentZ - 0.5) * iReclaimSegmentSizeZ))
        return {iX, GetSurfaceHeight(iX, iZ), iZ}
    end
end

function SetupPlayableAreaAndSegmentSizes(rCampaignPlayableAreaOverride)
    --Sets up key values needed to divide the map up into segments (small squares) for both land zone segments and reclaim segments - should be called as one of the first pieces of code
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupPlayableAreaAndSegmentSizes'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': About to set playable area at time='..GetGameTimeSeconds()..'; ScenarioInfo.MapData.PlayableRect='..repru(ScenarioInfo.MapData.PlayableRect)..'; bMapLandSetupComplete='..tostring(bMapLandSetupComplete or false)..'; bIsCampaignMap='..tostring(bIsCampaignMap or false)..'; rCampaignPlayableAreaOverride='..repru(rCampaignPlayableAreaOverride)..'; Sync.NewPlayableArea='..repru(Sync.NewPlayableArea)) end
    if ScenarioInfo.MapData.PlayableRect then --and (bMapLandSetupComplete or not(bIsCampaignMap)) then
        rMapPlayableArea = ScenarioInfo.MapData.PlayableRect
    else
        rMapPlayableArea = {0, 0, ScenarioInfo.size[1], ScenarioInfo.size[2]}
    end
    if bIsCampaignMap then --Want to setup segments etc. based on total map size as the map is likely to expand later on
        rMapPotentialPlayableArea = {0, 0, ScenarioInfo.size[1], ScenarioInfo.size[2]}
    else
        rMapPotentialPlayableArea = rMapPlayableArea
    end
    if rCampaignPlayableAreaOverride and M28Utilities.IsTableEmpty(rCampaignPlayableAreaOverride) == false then
        local rNewRect = {}
        if rCampaignPlayableAreaOverride['x0'] then
            rNewRect = {rCampaignPlayableAreaOverride['x0'], rCampaignPlayableAreaOverride['y0'], rCampaignPlayableAreaOverride['x1'], rCampaignPlayableAreaOverride['y1']}
        else
            for iEntry, tPosition in rCampaignPlayableAreaOverride do
                table.insert(rNewRect, tPosition)
            end
        end
        if ScenarioInfo.MapData.PlayableRect then --limit playable area to scenarioinfo playable area
            local rScenarioPlayableRect = ScenarioInfo.MapData.PlayableRect
            rNewRect[1] = math.max(rNewRect[1], rScenarioPlayableRect[1])
            rNewRect[2] = math.max(rNewRect[2], rScenarioPlayableRect[2])
            rNewRect[3] = math.min(rNewRect[3], rScenarioPlayableRect[3])
            rNewRect[4] = math.min(rNewRect[4], rScenarioPlayableRect[4])
        end
        if bDebugMessages == true then
            LOG(sFunctionRef..': Updating playable rect for override, rCampaignPlayableAreaOverride='..repru(rCampaignPlayableAreaOverride)..'; ScenarioInfo.MapData.PlayableRect='..repru(ScenarioInfo.MapData.PlayableRect)..'; rNewRect='..repru(rNewRect))
            M28Utilities.DrawRectangle(rCampaignPlayableAreaOverride, 2, 1000, 0)
        end
        rMapPlayableArea = rNewRect
    end

    iMapSize = (rMapPlayableArea[3] - rMapPlayableArea[1] + rMapPlayableArea[4] - rMapPlayableArea[2]) * 0.5


    --Decide on land zone segment sizes
    local iHighestSize = math.max(rMapPlayableArea[3] - rMapPlayableArea[1], rMapPlayableArea[4] - rMapPlayableArea[2])
    local iTableSizeCap = 125000 --e.g. 1x1 resolution on a 10km, 3x3 resolution on a 20km (athough changed to 2x2 resolution on 10km per the below)
    if not(bMapLandSetupComplete) then --e.g. if this is a campaign we may want to change playable area size
        --iTableSizeCap = SegmentCount^2; SegmentCount = iTotalSize / SegmentSize; (TotalSize/SegmentSize)^2 = iTableSizeCap; SemgentSize = TotalSize/Sqrt(iTableSizeCap)
        iLandZoneSegmentSize = math.ceil(iHighestSize / math.sqrt(iTableSizeCap))
        if iMapSize > 256 then ilandZoneSegmentSize = math.max(iLandZoneSegmentSize, 2) end --otherwise get too many building locations

        --Record the max values
        iMaxLandSegmentX, iMaxLandSegmentZ = GetPathingSegmentFromPosition({rMapPotentialPlayableArea[3], 0, rMapPotentialPlayableArea[4]})

        if bDebugMessages == true then LOG(sFunctionRef..': iHighestSize='..iHighestSize..'; iTableSizeCap='..iTableSizeCap..'; iLandZoneSegmentSize='..iLandZoneSegmentSize..'; Max Segment X-Z='..iMaxLandSegmentX..'-'..iMaxLandSegmentZ) end


        local iMinReclaimSegmentSize = 8.5 --Engineer build range is 6; means that a square of about 4.2 will fit inside this circle; If have 2 separate engineers assigned to adjacent reclaim segments, and want their build range to cover the two areas, then would want a gap twice this, so 8.4; will therefore go with min size of 8
        local iMapSizeX = rMapPotentialPlayableArea[3] - rMapPotentialPlayableArea[1]
        local iMapSizeZ = rMapPotentialPlayableArea[4] - rMapPotentialPlayableArea[2]
        iReclaimSegmentSizeX = math.max(iMinReclaimSegmentSize, iLandZoneSegmentSize)
        iReclaimSegmentSizeZ = math.max(iMinReclaimSegmentSize, iLandZoneSegmentSize)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, rMapPotentialPlayableArea='..repru(rMapPotentialPlayableArea)..'; actual playable area='..repru(rMapPlayableArea)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end



---@param sPathing string
---@param tLocation table
---@return number
function GetSegmentGroupOfLocation(sPathing, tLocation)
    --Included for backwards compatibility with M27 logic; better to use the below line directly
    --Returns a reference number based on sPathing that groups areas based on whether they can path to each other (so if two locations have the same reference, they can path to each other)
    --sPathing should be one of the refPathingType variables defined at the top of this file; tLocation is {x,y,z} format
    return NavUtils.GetLabel(sPathing, tLocation)
end

local function RecordMexForPathingGroup()
    --Cycles through every mex on the map, and includes it in a table of mexes that is grouped by pathing type, so in future we can easily cycle through mexes for a particular pathing type
    --e.g. after running this, can use tMexByPathingAndGrouping[sPathing][iPathingGroup] where sPathing is the refPathingType variable, and ipathingGroup is the NavUtils.GetLabel(sPathing, tLocation) reference
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordMexForPathingGroup'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': About to record mexes for each pathing group. MassPoints='..repru(tMassPoints)) end
    local tsPathingTypes = {refPathingTypeHover, refPathingTypeNavy, refPathingTypeLand}
    local iCurResourceGroup
    local iValidCount = 0
    tMexByPathingAndGrouping = {}
    if bDebugMessages == true then
        LOG(sFunctionRef..': NavUtils test - will cycle through each mex and get land label')
        for iMex, tMex in tMassPoints do
            LOG(sFunctionRef..': tMex='..repru(tMex)..'; Label='..(NavUtils.GetTerrainLabel('Land', tMex) or 'nil'))
            if not(NavUtils.GetTerrainLabel('Land', tMex)) then
                LOG(sFunctionRef..': WARNING - dont have a land label for mex '..repru(tMex))
            else
                LOG(sFunctionRef..': Have a land label for mex '..repru(tMex)..' so will stop with warning messages as pathing apepars generated')
                break
            end
        end
    end
    for iPathingType, sPathing in tsPathingTypes do
        tMexByPathingAndGrouping[sPathing] = {}
        iValidCount = 0

        if bDebugMessages == true then LOG(sFunctionRef..': About to record all mexes for pathing type sPathing='..sPathing) end

        for iCurMex, tMexLocation in tMassPoints do
            iValidCount = iValidCount + 1
            iCurResourceGroup = NavUtils.GetTerrainLabel(sPathing, tMexLocation)
            if not(iCurResourceGroup) then
                if bDebugMessages == true then LOG('Dont have a resource group for mex location '..repru(tMexLocation)..'; This is expected if mexes are located outside the playable area or are testing water pathing for land mexes and vice versa') end
            else
                if bDebugMessages == true then
                    LOG(sFunctionRef..': iCurMex='..iCurMex..'; About to get segment group for pathing='..sPathing..'; location='..repru((tMexLocation or {'nil'}))..'; iCurResourceGroup='..(iCurResourceGroup or 'nil'))
                    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tMexLocation)
                    LOG(sFunctionRef..': Pathing segments='..(iSegmentX or 'nil')..'; iSegmentZ='..(iSegmentZ or 'nil')..'; rMapPotentialPlayableArea='..repru(rMapPotentialPlayableArea)..'; iLandZoneSegmentSize='..(iLandZoneSegmentSize or 'nil'))
                end
                if tMexByPathingAndGrouping[sPathing][iCurResourceGroup] == nil then
                    tMexByPathingAndGrouping[sPathing][iCurResourceGroup] = {}
                    iValidCount = 1
                else iValidCount = table.getn(tMexByPathingAndGrouping[sPathing][iCurResourceGroup]) + 1
                end
                tMexByPathingAndGrouping[sPathing][iCurResourceGroup][iValidCount] = tMexLocation
                if bDebugMessages == true then LOG(sFunctionRef..': iValidCount='..iValidCount..'; sPathing='..sPathing..'; iCurResourceGroup='..iCurResourceGroup..'; just added tMexLocation='..repru(tMexLocation)..' to this group') end
            end
        end
        if sPathing == refPathingTypeLand and iValidCount == 0 then M28Utilities.ErrorHandler('Dont have any mexes recording for land pathing type') end
    end
    if bDebugMessages == true then LOG(sFunctionRef..'; tMexByPathingAndGrouping='..repru(tMexByPathingAndGrouping)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordMexlessPlateau(iPlateau)
    tAllPlateaus[iPlateau] = {}
    tAllPlateaus[iPlateau][subrefPlateauTotalMexCount] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones] = {}
    tAllPlateaus[iPlateau][subrefLandZoneCount] = 0
end

local function RecordAllPlateaus()
    --Records any plateaus that contain mexes, along with info on the plateau
    --tAllPlateaus[iSegmentGroup] can be used to then reference subtables with further information on the plateau, where iSegmentGroup is the result of NavUtils.GetLabel(refPathingTypeHover, {x,y,z})

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAllPlateaus'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCurPlateauMex
    local iMinSegmentX, iMinSegmentZ, iMaxSegmentX, iMaxSegmentZ, iCurSegmentGroup

    if bDebugMessages == true then LOG(sFunctionRef..': About to get max map segment X and Z based on rMapPotentialPlayableArea='..repru(rMapPotentialPlayableArea)) end
    local iMapMaxSegmentX, iMapMaxSegmentZ = GetPathingSegmentFromPosition({rMapPotentialPlayableArea[3], 0, rMapPotentialPlayableArea[4]})
    local iStartSegmentX, iStartSegmentZ
    local bSearchingForBoundary
    local iCurCount
    local tSegmentPosition
    local iReclaimSegmentStartX, iReclaimSegmentStartZ, iReclaimSegmentEndX, iReclaimSegmentEndZ
    local sPathing = refPathingTypeHover


    --Cycle through every amphibious pathing group that has mexes in it:
    for iSegmentGroup, tSubtable in tMexByPathingAndGrouping[sPathing] do
        --If we dont already have a plateau setup then create one:
        if not(tAllPlateaus[iSegmentGroup]) then
            --Have a plateau with mexes that havent already recorded
            tAllPlateaus[iSegmentGroup] = {}
            tAllPlateaus[iSegmentGroup][subrefPlateauMexes] = {}
            iCurPlateauMex = 0
            --Record every mex against the PlateausWithMexes table:
            for iMex, tMex in tMexByPathingAndGrouping[sPathing][iSegmentGroup] do
                iCurPlateauMex = iCurPlateauMex + 1
                tAllPlateaus[iSegmentGroup][subrefPlateauMexes][iCurPlateauMex] = tMex
            end
            tAllPlateaus[iSegmentGroup][subrefPlateauTotalMexCount] = iCurPlateauMex
            --Record additional information if the plateau has mexes:
            if iCurPlateauMex > 0 then
                --Record information on the size of the plateau:
                --Start from mex, and move up on map to determine top point; then move left to determine left point, and right to determine right point etc.
                --i.e. dont want to go through every segment on map since could take ages if lots of plateaus and may only be dealing with small area
                iStartSegmentX, iStartSegmentZ = GetPathingSegmentFromPosition(tAllPlateaus[iSegmentGroup][subrefPlateauMexes][1])

                --First find the smallest z (so go up)
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount > iStartSegmentZ then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetTerrainLabel(sPathing, GetPositionFromPathingSegments(iStartSegmentX, iStartSegmentZ - iCurCount))  --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX][iStartSegmentZ - iCurCount]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartX = 1, iMapMaxSegmentX do
                            iCurSegmentGroup = NavUtils.GetTerrainLabel(sPathing, GetPositionFromPathingSegments(iAltStartX, iStartSegmentZ - iCurCount)) --tPathingSegmentGroupBySegment[sPathing][iAltStartX][iStartSegmentZ - iCurCount]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentX = iAltStartX
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                --Will have the min Z value now
                iMinSegmentZ = iStartSegmentZ - iCurCount + 1


                --Now check for the min X value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount > iStartSegmentX then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetTerrainLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX - iCurCount), iStartSegmentZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX - iCurCount][iStartSegmentZ]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same X value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartZ = iMinSegmentZ, iMapMaxSegmentZ do
                            iCurSegmentGroup = NavUtils.GetTerrainLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX - iCurCount), iAltStartZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX - iCurCount][iAltStartZ]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentZ = iAltStartZ
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end

                --Will now have the min X value
                iMinSegmentX = iStartSegmentX - iCurCount + 1

                --Now get max Z value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount + iStartSegmentZ > iMapMaxSegmentZ then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetTerrainLabel(sPathing, GetPositionFromPathingSegments(iStartSegmentX, (iStartSegmentZ + iCurCount))) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX][iStartSegmentZ + iCurCount]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartX = iMinSegmentX, iMapMaxSegmentX do
                            iCurSegmentGroup = NavUtils.GetTerrainLabel(sPathing, GetPositionFromPathingSegments(iAltStartX, (iStartSegmentZ + iCurCount))) --tPathingSegmentGroupBySegment[sPathing][iAltStartX][iStartSegmentZ + iCurCount]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentX = iAltStartX
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                iMaxSegmentZ = iStartSegmentZ + iCurCount - 1

                --Now get the max X value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount + iStartSegmentX > iMapMaxSegmentX then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetTerrainLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX + iCurCount), iStartSegmentZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX + iCurCount][iStartSegmentZ]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartZ = iMinSegmentZ, iMaxSegmentZ do
                            iCurSegmentGroup = NavUtils.GetTerrainLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX + iCurCount), iAltStartZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX + iCurCount][iAltStartZ]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentZ = iAltStartZ
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                iMaxSegmentX = iStartSegmentX + iCurCount - 1

                --Have now got the min and max land segment X and Z values for the plateau
                tSegmentPosition = GetPositionFromPathingSegments(iMinSegmentX, iMinSegmentZ)
                tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ] = {tSegmentPosition[1], tSegmentPosition[3]}
                iReclaimSegmentStartX, iReclaimSegmentStartZ = GetReclaimSegmentsFromLocation(tSegmentPosition)

                tSegmentPosition = GetPositionFromPathingSegments(iMaxSegmentX, iMaxSegmentZ)
                tAllPlateaus[iSegmentGroup][subrefPlateauMaxXZ] = {tSegmentPosition[1], tSegmentPosition[3]}
                iReclaimSegmentEndX, iReclaimSegmentEndZ = GetReclaimSegmentsFromLocation(tSegmentPosition)


                --Record all reclaim segments that are part of the plateau
                tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments] = {}
                for iCurReclaimSegmentX = iReclaimSegmentStartX, iReclaimSegmentEndX do
                    tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX] = {}
                    for iCurReclaimSegmentZ = iReclaimSegmentStartZ, iReclaimSegmentEndZ do
                        if iSegmentGroup == NavUtils.GetTerrainLabel(sPathing,GetReclaimLocationFromSegment(iCurReclaimSegmentX, iCurReclaimSegmentZ)) then
                            tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX][iCurReclaimSegmentZ] = true
                        end
                    end
                end
                --Clear any empty values
                for iCurReclaimSegmentX = iReclaimSegmentStartX, iReclaimSegmentEndX do
                    if tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX] and M28Utilities.IsTableEmpty(tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX]) then tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX] = nil end
                end

                --Record midpoint of the plateau
                local iXRadius = (tAllPlateaus[iSegmentGroup][subrefPlateauMaxXZ][1] - tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ][1])*0.5
                local iZRadius = (tAllPlateaus[iSegmentGroup][subrefPlateauMaxXZ][2] - tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ][2])*0.5
                tAllPlateaus[iSegmentGroup][subrefPlateauMidpoint] = {tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ][1] + iXRadius, 0, tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ][2] + iZRadius}
                tAllPlateaus[iSegmentGroup][subrefPlateauMidpoint][2] = GetTerrainHeight(tAllPlateaus[iSegmentGroup][subrefPlateauMidpoint][1], tAllPlateaus[iSegmentGroup][subrefPlateauMidpoint][3])
                --CIrcle radius will be the square/rectangle diagonal, so (square radius^2*2)^0.5 for a square, or (x^2+z^2)^0.5

                tAllPlateaus[iSegmentGroup][subrefPlateauMaxRadius] = (iXRadius^2+iZRadius^2)^0.5
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, listing tAllPlateaus='..repru(tAllPlateaus)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param iPlateau number
local function AddNewLandZoneReferenceToPlateau(iPlateau)
    --Adds a new land zone reference number to iPlateau, assumes that information about the zone will be added later
    --Intended to be called as part of wider code for recording a land zone, e.g. from CreateNewLandZoneAtSegment and similar functions
    --iPlateau is the result of NavUtils.GetLabel(refPathingTypeHover, tLocation)
    --To get the land zone created by this immediately after it is created, use iLandZone = tAllPlateaus[iPlateau][subrefLandZoneCount]
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddNewLandZoneReferenceToPlateau'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if not(tAllPlateaus[iPlateau]) then
        --Presumably we have a plateau with no mexes so add this plateau to the table of plateaus
        tAllPlateaus[iPlateau] = {}
        tAllPlateaus[iPlateau][subrefPlateauTotalMexCount] = 0
    end
    if not(tAllPlateaus[iPlateau][subrefLandZoneCount]) then
        tAllPlateaus[iPlateau][subrefLandZoneCount] = 0
        tAllPlateaus[iPlateau][subrefPlateauLandZones] = {}
    end
    tAllPlateaus[iPlateau][subrefLandZoneCount] = (tAllPlateaus[iPlateau][subrefLandZoneCount] or 0) + 1
    local iLandZone = tAllPlateaus[iPlateau][subrefLandZoneCount]
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexCount] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexLocations] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefMexUnbuiltLocations] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefHydroLocations] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefHydroUnbuiltLocations] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefTotalMassReclaim] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefBuildLocationsBySizeAndSegment] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefBuildLocationBlacklistByPosition] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefQueuedLocationsByPosition] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefBuildLocationSegmentCountBySize] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTotalSegmentCount] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefTotalMassReclaim] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTotalEnergyReclaim] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTravelDistToOtherLandZones] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZPlayerWallSegments] = {}

    if bDebugMessages == true then LOG('Time='..GetGameTimeSeconds()..'; Finished setting up variables for iPlateau='..iPlateau..'; iLandZone='..iLandZone) end


    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end



function RecordSegmentLandZone(iSegmentX, iSegmentZ, iPlateau, iLandZone)
    if not(tLandZoneBySegment[iSegmentX]) then tLandZoneBySegment[iSegmentX] = {} end
    tLandZoneBySegment[iSegmentX][iSegmentZ] = iLandZone
    if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments]) then
        if not(tAllPlateaus[iPlateau]) then RecordMexlessPlateau(iPlateau) end
        if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]) then
            AddNewLandZoneReferenceToPlateau(iPlateau)
            iLandZone = tAllPlateaus[iPlateau][subrefLandZoneCount]
        end

    end
    if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments]) then
        LOG('ERROR - RecordSegmentLandZoneTempLog: iSegmentX='..(iSegmentX or 'nil')..'; iSegmentZ='..(iSegmentZ or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iPlateau='..(iPlateau or 'nil')..'; tAllPlateaus[iPlateau][subrefPlateauLandZones]='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones]))
        M28Utilities.DrawLocation(GetPositionFromPathingSegments(iSegmentX, iSegmentZ), 1, 200, 3)
    else
        table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments], {iSegmentX, iSegmentZ})
        tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTotalSegmentCount] = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTotalSegmentCount] + 1
    end
    if not(NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iSegmentX, iSegmentZ)) == iPlateau) then
        --Record an override to avoid issues later on when using getlabel
        local tMidpoint = GetPositionFromPathingSegments(iSegmentX, iSegmentZ)
        AddLocationToPlateauExceptions(tMidpoint, iPlateau, iLandZone)
        if not(tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX]) then tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX] = {} end
        tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ] = {[1] = iPlateau, [2] = iLandZone}

        --LOG('Warning - navutils hover label='..(NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iSegmentX, iSegmentZ)) or 'nil')..'; iSegmentXZ='..iSegmentX..'Z'..iSegmentZ..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil'))
    end
end

local function ReorderLandZoneSegmentsForEachPlateau()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReorderLandZoneSegmentsForEachPlateau'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Updates tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments] so it is sorted based on the distance to the middle of the zone
    local iMidSegmentX, iMidSegmentZ
    local tiSegmentsByDistance
    local tiSortedSegmentsByDistance
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLZSubtable in tPlateauSubtable[subrefPlateauLandZones] do
            tiSegmentsByDistance = {}
            tiSortedSegmentsByDistance = {}
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Midpoint='..repru(tLZSubtable[subrefMidpoint])) end
            iMidSegmentX, iMidSegmentZ = GetPathingSegmentFromPosition(tLZSubtable[subrefMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': About to reorder the segments in iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Segments before sorting='..repru(tLZSubtable[subrefLZSegments])) end
            for iSegmentRef, tSegmentXZ in tLZSubtable[subrefLZSegments] do
                table.insert(tiSegmentsByDistance, {['Segments']={tSegmentXZ[1], tSegmentXZ[2]}, ['Distance']=(math.abs(tSegmentXZ[1] - iMidSegmentX) + math.abs(tSegmentXZ[2] - iMidSegmentZ))})
            end
            --Now sort by distance
            tLZSubtable[subrefLZSegments] = {}
            if bDebugMessages == true then LOG(sFunctionRef..': tiSegmentsByDistance='..repru(tiSegmentsByDistance)) end
            for iEntry, tValue in M28Utilities.SortTableBySubtable(tiSegmentsByDistance, 'Distance', true) do
                if bDebugMessages == true then LOG(sFunctionRef..': iEntry='..iEntry..';tValue='..repru(tValue)..'; Inserting value '..repru(tValue['Segments'])..' into the main LZSubtable') end
                table.insert(tLZSubtable[subrefLZSegments], tValue['Segments'])
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished sorting for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Segments after sorting='..repru(tLZSubtable[subrefLZSegments])) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


---@param iBaseSegmentX number
---@param iBaseSegmentZ number
local function CreateNewLandZoneAtSegment(iBaseSegmentX, iBaseSegmentZ, iOptionalPlateauBackup)
    --Creates a new land zone reference at the land segment given by iBaseSegmentX-iBaseSegmentZ (includes adding new land zone reference to the plateau group that these segments are part of)
    --iBaseSegmentX and Z are the land segment X and Z references
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateNewLandZoneAtSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --First check we dont have a zone assigned already (redundancy)
    if not(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
        --PlateauGroup ref will be the amphibious pathing ref from navutils.getlabel (since that's what is used to define mexes by amphibious pathing group, and plateau recognition then uses the same reference)
        local tMidpoint = GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
        local iPlateau = (NavUtils.GetLabel(refPathingTypeHover, tMidpoint) or NavUtils.GetLabel('Amphibious', tMidpoint) or iOptionalPlateauBackup)
        if (iPlateau or 0) > 0 then
            AddNewLandZoneReferenceToPlateau(iPlateau)
            --LOG('Have just created a new land zone reference for base segment XZ='..iBaseSegmentX..'-'..iBaseSegmentZ..' in the iPlateau='..iPlateau)
            RecordSegmentLandZone(iBaseSegmentX, iBaseSegmentZ, iPlateau, tAllPlateaus[iPlateau][subrefLandZoneCount])
        else
            M28Utilities.ErrorHandler('Tried creating new zone for '..iBaseSegmentX..'-'..iBaseSegmentZ..' but dont have valid plateau iPlateau='..(iPlateau or 'nil'))
        end

    else
        M28Utilities.ErrorHandler('Trying to create a new zone for base segment '..iBaseSegmentX..'-'..iBaseSegmentZ..' when it already has a land zone assigned '..tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ])
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param iPlateau number
---@param iOptionalLandZone number
---@param iPlateauMexRef number
---@param tTempPlateauLandZoneByMexRef table
local function AddMexToLandZone(iPlateau, iOptionalLandZone, iPlateauMexRef, tTempPlateauLandZoneByMexRef, tOptionalMexLocationIfAddingDuringGame)
    --Determine the land zone if it isnt specified
    --iPlateau is the result of NavUtils.GetLabel(refPathingTypeHover, tLocation)
    --iOptionalLandZone - if not specified, then this will create a new land zone for iPlateau and use htis reference
    --iPlateauMexRef - the reference key in the table tAllPlateaus[iPlateau][subrefPlateauMexes], which should return the location of the mex; if nill then will create a new ref
    --tTempPlateauLandZoneByMexRef - temporary table used to store information for purposes of creating the land zones

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddMexToLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Get the land zone that we are using (/create a new land zone if we haven't had one specified to be used):
    local iLandZone
    if iOptionalLandZone then iLandZone = iOptionalLandZone
    else
        AddNewLandZoneReferenceToPlateau(iPlateau)
        iLandZone = tAllPlateaus[iPlateau][subrefLandZoneCount]
    end

    --Add mex to the plateau if no iPlateauMexRef, and also to locations to build - i.e. assume if this triggers taht we are adding the mex part-way through
    if not(iPlateauMexRef) or not(tAllPlateaus[iPlateau][subrefPlateauMexes][iPlateauMexRef]) then
        if M28Utilities.IsTableEmpty(tAllPlateaus[iPlateau][subrefPlateauMexes]) or not(tOptionalMexLocationIfAddingDuringGame) then
            M28Utilities.ErrorHandler('Dont have any mexes recorded for iPlateau '..(iPlateau or 'nil')..'; or havent specified a value for tOptionalMexLocationIfAddingDuringGame')
        else
            local iExistingCount = table.getn(tAllPlateaus[iPlateau][subrefPlateauMexes])
            table.insert(tAllPlateaus[iPlateau][subrefPlateauMexes], {tOptionalMexLocationIfAddingDuringGame[1], tOptionalMexLocationIfAddingDuringGame[2], tOptionalMexLocationIfAddingDuringGame[3]})
            iPlateauMexRef = iExistingCount + 1
            if M28Conditions.CanBuildOnMexLocation(tOptionalMexLocationIfAddingDuringGame) then
                local tLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
                if not(tLZData[subrefMexUnbuiltLocations]) then tLZData[subrefMexUnbuiltLocations] = {} end
                table.insert(tLZData[subrefMexUnbuiltLocations], { tOptionalMexLocationIfAddingDuringGame[1], tOptionalMexLocationIfAddingDuringGame[2], tOptionalMexLocationIfAddingDuringGame[3] })
                if bDebugMessages == true then LOG(sFunctionRef..': Added mex to table of unbuilt mex locations, iExistingCount='..iExistingCount..'; iPlateauMexRef='..iPlateauMexRef) end
            end
        end

    end

    --Add the mex to this land zone
    if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexCount]) then
        M28Utilities.ErrorHandler('No mex count for iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil'))
        tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexCount] = 0
    end
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexCount] = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexCount] + 1
    table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexLocations], tAllPlateaus[iPlateau][subrefPlateauMexes][iPlateauMexRef])
    if tTempPlateauLandZoneByMexRef[iPlateau] then tTempPlateauLandZoneByMexRef[iPlateau][iPlateauMexRef] = iLandZone end
    if bDebugMessages == true then LOG(sFunctionRef..': iPlateauMexRef='..(iPlateauMexRef or 'nil')..'; tAllPlateaus[iPlateau][subrefPlateauMexes][iPlateauMexRef] repru='..repru(tAllPlateaus[iPlateau][subrefPlateauMexes][iPlateauMexRef])) end
    local iCurSegmentX, iCurSegmentZ = GetPathingSegmentFromPosition(tAllPlateaus[iPlateau][subrefPlateauMexes][iPlateauMexRef])
    if not(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] == iLandZone) then
        RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iPlateau, iLandZone)
        if bDebugMessages == true then LOG(sFunctionRef..': Hvae recorded a new land zone for segment '..iCurSegmentX..'-'..iCurSegmentZ..' for iPlateau '..iPlateau..'; iLandZone='..iLandZone) end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function AddMexToWaterZone(iPond, iWaterZone, tMex)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddMexToWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Add the mex to this water zone
    local bAlreadyRecorded = false --(expect to be the case every time, but were getting issues with the same location appearing multiple itmes in unbuilt locations so adding as redundancy)
    local tWZData = tPondDetails[iPond][subrefPondWaterZones][iWaterZone]
    if not(tWZData[subrefWZMexLocations]) then
        tWZData[subrefWZMexLocations] = {}
        tWZData[subrefWZMexCount] = 0
    else
        --Check not already recorded
        for iEntry, tLocation in tWZData[subrefWZMexLocations] do
            if math.abs(tLocation[1] - tMex[1]) <= 0.9 and math.abs(tLocation[3] - tMex[3]) <= 0.9 then
                bAlreadyRecorded = true
                break
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Considering recording mex at position '..repru(tMex)..' for iWaterZone'..iWaterZone..'; bAlreadyRecorded='..tostring(bAlreadyRecorded)..'; Can build on mex='..tostring(M28Conditions.CanBuildOnMexLocation(tMex))) end
    if not(bAlreadyRecorded) then
        tWZData[subrefWZMexCount] = tWZData[subrefWZMexCount] + 1
        table.insert(tWZData[subrefWZMexLocations], tMex)

        if M28Conditions.CanBuildOnMexLocation(tMex) then
            if not(tWZData[subrefMexUnbuiltLocations]) then tWZData[subrefMexUnbuiltLocations] = {} end
            table.insert(tWZData[subrefMexUnbuiltLocations], tMex)
            if bDebugMessages == true then LOG(sFunctionRef..': Added mex to table of unbuilt mex locations') end
        else
            --DOuble-check - if there are no buildings in a rectangle around the mex then treat it as buildable (note - havent tested the below as added when thought were failing to record mexes on a map but it turned out to be another unrelated issue)
            local rRect = M28Utilities.GetRectAroundLocation(tMex, 0.9)
            local tUnitsByMex = GetUnitsInRect(rRect)
            local bNearbyMex = false
            if M28Utilities.IsTableEmpty(tUnitsByMex) == false then
                local tBuildingsNearby = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tUnitsByMex)
                if M28Utilities.IsTableEmpty(tBuildingsNearby) == false then
                    bNearbyMex = true
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Backup logic, is tUnitsByMex empty='..tostring(M28Utilities.IsTableEmpty(tUnitsByMex))..'; bNearbyMex ='..tostring(bNearbyMex)) end
            if not(bNearbyMex) then
                if not(tWZData[subrefMexUnbuiltLocations]) then tWZData[subrefMexUnbuiltLocations] = {} end
                table.insert(tWZData[subrefMexUnbuiltLocations], tMex)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param sResourceType string
---@param x number
---@param y number
---@param z number
function RecordResourcePoint(sResourceType,x,y,z,size)
    --called by hook into simInit, more reliable method of figuring out if have adaptive map than using markers, as not all mass markers may have mexes generated on an adaptive map
    --Whenever a resource location is created in the map, this is called, and will record the resource location into a table of mex points (tMassPoints) and hydro points (tHydroPoints) for referencing in later code
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordResourcePoint'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': sResourceType='..sResourceType..'; x='..x..'; y='..y..'; z='..z..'; size='..repru(size)..'; Mass count pre update='..table.getn(tMassPoints)..'; Hydro points pre update='..table.getn(tHydroPoints)) end

    if sResourceType == 'Mass' then
        table.insert(tMassPoints, {x,y,z})
    elseif sResourceType == 'Hydrocarbon' then
        table.insert(tHydroPoints, {x,y,z})
    end
    if bMapLandSetupComplete and GetGameTimeSeconds() >= 3 then
        --E.g. crazyrush type map
        local iPlateauOrZero, iLandOrWaterZone = GetClosestPlateauOrZeroAndZoneToPosition({ x,y,z })
        if bDebugMessages == true then LOG(sFunctionRef..': Map setup is already complete, assumed crazyrsuh scenario, iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; xyz='..x..'-'..y..'-'..z) end
        if iLandOrWaterZone > 0 then
            if iPlateauOrZero == 0 then
                AddMexToWaterZone(tiPondByWaterZone[iLandOrWaterZone], iLandOrWaterZone, { x,y,z})
            else
                AddMexToLandZone(iPlateauOrZero, iLandOrWaterZone, nil, nil, {x,y,z})
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of hook; Mass points post update='..table.getn(tMassPoints)..'; Hydro poitns post update='..table.getn(tHydroPoints)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function AssignTempSegmentsWithDistance()
    --Used to go through the temporary table tTempZoneTravelDistanceBySegment and assign any segments within here to the nearest land zone
    --i.e. Assumes tTempZoneTravelDistanceBySegment has been setup and is a table that has [SegmentX][SegmentZ] values that returns a table with [zone] as the key, which in turn returns the pathing distance from SegmentX-SegmentZ for each zone
    --Goes through all the distance values in tTempZoneTravelDistanceBySegment and picks the lowest distance, and then assigns the X+Z segment to land zone that corresponds to that distance, then clears the table tTempZoneTravelDistanceBySegment


    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignTempSegmentsWithDistance'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iLowestDistance
    local iLowestZone
    local iCurPlateau
    --Cycle through every entry
    if M28Utilities.IsTableEmpty(tTempZoneTravelDistanceBySegment) == false then
        for iCurSegmentX, tSubtable in tTempZoneTravelDistanceBySegment do
            if not(tLandZoneBySegment[iCurSegmentX]) then tLandZoneBySegment[iCurSegmentX] = {} end
            for iCurSegmentZ, tDistanceByZone in tSubtable do
                --Have we not recorded a zone for this segment?
                if not(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]) then
                    iLowestDistance = 10000
                    iLowestZone = nil
                    --Cycle through every distance that has been recorded for this segment, and record the lowest distance and the zone that corresponds to this distance
                    if M28Utilities.IsTableEmpty(tDistanceByZone) == false then
                        for iZone, iDistance in tDistanceByZone do
                            if iDistance < iLowestDistance then
                                iLowestDistance = iDistance
                                iLowestZone = iZone
                            end
                        end
                        --if bDebugMessages == true then LOG(sFunctionRef..': iCurSegmentX='..iCurSegmentX..'; iCurSegmentZ='..iCurSegmentZ..'; Position from pathing segments='..repru(GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ))..'; iLowestZone='..(iLowestZone or 'nil')..'; plateau group='..(NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)) or 'nil')) end
                        iCurPlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ))
                        if not(iCurPlateau) then
                            --We have a land zone, so presumably this segment in isolation isn't in somewhere we recognise, but it is near somewhere suitable; keep searching nearby segments to try and find this land zone
                            iCurPlateau = tTempZonePlateauBySegment[iCurSegmentX][iCurSegmentZ][iLowestZone]

                        end
                        RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iCurPlateau, iLowestZone)
                    end
                end
                tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ] = nil --Clear the value so when we cycle through in the future we dont reconsider this
                tTempZonePlateauBySegment[iCurSegmentX][iCurSegmentZ] = nil
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AssignSegmentsNearMexesToLandZones()
    --With thanks to Jip for providing the core idea for this and some example code

    --The below works on a segment by segment basis, so has issues where our segments are larger than the segments used by navmesh (since unpathable locations appear pathable), so uses a workaround of requiring the two segments to be pathable in a straight line between each other at a more granular level of detail
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignSegmentsNearMexesToLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Polar depression for debugging

    --[[if bDebugMessages == true then
        local tLocations = {{366, 0, 470}, {366, 0, 478}}
        --info: AssignSegmentsNearMexesToLandZones: Segment XZ=X92Z118; iEntry=4; tPosition={ table: 21FAFA50  366, 0, 470 }; Land label=8; tiSegmentXZAndZone[4] label=8
        --info: AssignSegmentsNearMexesToLandZones: Segment XZ=X92Z120; iEntry=4; tPosition={ table: 20998460  366, 0, 478 }; Land label=8; tiSegmentXZAndZone[4] label=8
        tLocations[1][2] = GetSurfaceHeight(tLocations[1][1], tLocations[1][3])
        tLocations[2][2] = GetSurfaceHeight(tLocations[2][1], tLocations[2][3])
        M28Utilities.DrawLocation(tLocations[1], 2) --red
        M28Utilities.DrawLocation(tLocations[2], 4) --gold
        LOG('Label for location '..repru(tLocations[2])..'='..(NavUtils.GetTerrainLabel('Land', tLocations[2]) or 'nil')..'; Label for location '..repru(tLocations[1])..'='..(NavUtils.GetTerrainLabel('Land', tLocations[1]) or 'nil')..'; Terrain label of loc1='..(NavUtils.GetTerrainLabel('Land', tLocations[1]) or 'nil')..'Terrain label of loc2='..(NavUtils.GetTerrainLabel('Land', tLocations[2]) or 'nil'))
        LOG('Travel time between location 1 and 2='..(M28Utilities.GetTravelDistanceBetweenPositions(tLocations[1], tLocations[2], 'Land') or 'nil'))
    end--]]


    function GetNeighbours(iSegmentX, iSegmentZ, tBasePosition)
    --Get the adjacent segments to iSegmentX and Z, and the position of these adjacent segments (ntoe this is slightly different from the segment midpoint as it is based on tBasePosition for simplicity)
        local tTableBeforePositions = {{iSegmentX - 1, iSegmentZ, {{tBasePosition[1] - 1, 0, tBasePosition[3]}}}, {iSegmentX, iSegmentZ - 1, {{tBasePosition[1], 0, tBasePosition[3] - 1}}}, {iSegmentX, iSegmentZ + 1, {{tBasePosition[1], 0, tBasePosition[3] + 1}}}, {iSegmentX + 1, iSegmentZ, {{tBasePosition[1] + 1, 0, tBasePosition[3]}}}}
        if iLandZoneSegmentSize > 1 then
            for iEntry, tSubtable in tTableBeforePositions do
                if bDebugMessages == true then LOG(sFunctionRef..': tSubtable='..repru(tSubtable)..'; tSubtable[3]='..repru(tSubtable[3])) end
                for iPositionAdjust = 2, iLandZoneSegmentSize, 1 do
                    if iEntry == 1 then
                        table.insert(tSubtable[3], {tBasePosition[1] - iPositionAdjust, 0, tBasePosition[3]})
                    elseif iEntry == 2 then
                        table.insert(tSubtable[3], {tBasePosition[1], 0, tBasePosition[3] - iPositionAdjust})
                    elseif iEntry == 3 then
                        table.insert(tSubtable[3], {tBasePosition[1], 0, tBasePosition[3] + iPositionAdjust})
                    elseif iEntry == 4 then
                        table.insert(tSubtable[3], {tBasePosition[1] + iPositionAdjust, 0, tBasePosition[3]})
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': tTableBeforePositions='..repru(tTableBeforePositions)) end
        return tTableBeforePositions
    end

    local iMaxSegmentSearchDistance = math.max(10, math.ceil(85 / iLandZoneSegmentSize)) --NOTE: If changing this consider if also want to change the value for AssignRemainingSegmentsToLandZones
    --iMaxSegmentSearchDistance = 5 --Temp for testing
    local iBaseSegmentX, iBaseSegmentZ
    local bHadSomeEntries = false
    local iMexLandZone, iMexLandLabel, bSameLandLabel
    if bDebugMessages == true then LOG(sFunctionRef..': About to start cycling through plateaus and mexes, iLandZoneSegmentSize='..iLandZoneSegmentSize..'; iMaxSegmentSearchDistance='..iMaxSegmentSearchDistance) end
    --Cycle through every plateau
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        local tbSegmentHasDifferentZone = {}
        if M28Utilities.IsTableEmpty(tPlateauSubtable[subrefPlateauMexes]) == false then
            local iBaseQueueCount = 0
            local tiAdjacentSegmentsForSearchCountByMex = {}
            tiAdjacentSegmentsForSearchCountByMex[0] = {}
            --Cycle through every mex in the current plateau and record as the 'base' position to start searching from
            for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do
                iBaseSegmentX, iBaseSegmentZ = GetPathingSegmentFromPosition(tMex)
                iMexLandZone = tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]
                iMexLandLabel = NavUtils.GetTerrainLabel('Land', tMex)

                if (iMexLandZone or 0) > 0 and (iMexLandLabel or 0) > 0 then
                    iBaseQueueCount = iBaseQueueCount + 1
                    iBaseSegmentX, iBaseSegmentZ = GetPathingSegmentFromPosition(tMex)
                    tiAdjacentSegmentsForSearchCountByMex[0][iBaseQueueCount] = {{iBaseSegmentX, iBaseSegmentZ, iMexLandZone, iMexLandLabel, tMex}}
                else
                    if not(tbSegmentHasDifferentZone[iBaseSegmentX]) then tbSegmentHasDifferentZone[iBaseSegmentX] = {} end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iMex='..iMex..'; iBaseSegmentXZ='..iBaseSegmentX..'-'..iBaseSegmentZ..'; tMex='..repru(tMex)..'; iMexLandZone='..(iMexLandZone or 0)..'; iBaseQueueCount='..iBaseQueueCount..'; tiAdjacentSegmentsForSearchCountByMex[0][iBaseQueueCount]='..repru(tiAdjacentSegmentsForSearchCountByMex[0][iBaseQueueCount])..'; iMexLandLabel='..(iMexLandLabel or 'nil')..'; iMaxSegmentSearchDistance='..iMaxSegmentSearchDistance) end
                --tiBaseQueueSegments[iBaseQueueCount] = {iBaseSegmentX, iBaseSegmentZ}
            end
            --Cycle through each base position and consider adjcent pathable segments for inclusion in the base position's zone.  Record any such segments as the base points for the next search count (so the process repeats up to iMaxSegmentSearchDistance times)
            for iSearchCount = 1, iMaxSegmentSearchDistance + 1 do --+1 since we only consider iSearchCount-1 values
                tiAdjacentSegmentsForSearchCountByMex[iSearchCount] = {}
                bHadSomeEntries = false
                for iBaseQueueCount, tiQueueEntries in tiAdjacentSegmentsForSearchCountByMex[iSearchCount-1] do --i.e. at count-1 = 0 this is each mex; each search count after that is all adjacent locations ot the previous search count entry?
                    tiAdjacentSegmentsForSearchCountByMex[iSearchCount][iBaseQueueCount] = {}
                    for iEntry, tiSegmentXZAndZone in tiQueueEntries do
                        for iNeighbourEntry, tiNeighbourXZ in GetNeighbours(tiSegmentXZAndZone[1], tiSegmentXZAndZone[2], tiSegmentXZAndZone[5]) do
                            --Check we dont already have this segment assigned to another land zone
                            if not(tLandZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]]) then
                                --Check we can path to this neighbouring segment from the base segment
                                if not(tLandZoneBySegment[tiNeighbourXZ[1]]) then tLandZoneBySegment[tiNeighbourXZ[1]] = {} end
                                bSameLandLabel = true
                                for iEntry, tPosition in tiNeighbourXZ[3] do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Segment XZ=X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iEntry='..iEntry..'; tPosition='..repru(tPosition)..'; Land label='..(NavUtils.GetTerrainLabel('Land', tPosition) or 'nil')..'; tiSegmentXZAndZone[4] label='..(tiSegmentXZAndZone[4] or 'nil')) end
                                    if not(NavUtils.GetTerrainLabel('Land', tPosition) == tiSegmentXZAndZone[4]) then
                                        bSameLandLabel = false
                                        break
                                    end
                                end

                                if bSameLandLabel then
                                    --We can path here, so update the land zone to group it with the base segment, and then record it so we consider the neighbours of this segment in the next iSearchCount
                                    RecordSegmentLandZone(tiNeighbourXZ[1], tiNeighbourXZ[2], iPlateau, tiSegmentXZAndZone[3])
                                    --tLandZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]] = tiSegmentXZAndZone[3]
                                    table.insert(tiAdjacentSegmentsForSearchCountByMex[iSearchCount][iBaseQueueCount], {tiNeighbourXZ[1], tiNeighbourXZ[2],  tiSegmentXZAndZone[3], tiSegmentXZAndZone[4], GetPositionFromPathingSegments(tiNeighbourXZ[1], tiNeighbourXZ[2])})
                                    bHadSomeEntries = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering segment X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iCurLandLabel='..(tiSegmentXZAndZone[4] or 'nil')..'; adding to table of valid locations, iBaseQueueCount='..iBaseQueueCount) end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have unpathable segment X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iCurLandLabel='..(tiSegmentXZAndZone[4] or 'nil')..'; adding to table of segments that cant path to, iBaseQueueCount='..iBaseQueueCount) end
                                end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Already have land zone recorded for segment X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..' or '..(tLandZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]] or 'nil')..'; iCurLandLabel='..(tiSegmentXZAndZone[4] or 'nil')..'; adding to table of valid locations, iBaseQueueCount='..iBaseQueueCount) end
                            end
                        end
                    end
                end
                if not(bHadSomeEntries) then
                    --Didnt find any valid entries this cycle so abort
                    if bDebugMessages == true then LOG(sFunctionRef..': No entries for iSearchCount='..iSearchCount..' so will abort further entries') end
                    break
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished for iSearchCount='..iSearchCount..' and have some more entries to consider, Size of entries to go through next='..table.getn(tiAdjacentSegmentsForSearchCountByMex[iSearchCount])) end
                end
            end
        end
    end
    if bDebugMessages == true then LOG('End of code') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param iBaseSegmentX number
---@param iBaseSegmentZ number
---@param iLandPathingGroupWanted number
---@param tBasePosition table
---@param iMaxSegmentSearchDistance number
---@param iDistanceCap number
---@param bUseRoughPathingDistance boolean
local function RecordTemporaryTravelDistanceForBaseSegment(iBaseSegmentX, iBaseSegmentZ, iLandPathingGroupWanted, tBasePosition, iMaxSegmentSearchDistance, iDistanceCap, bUseRoughPathingDistance)
    --Cycle through segments adjacent to the base segment to see if they have a land zone assigned; if they do, check how far it takes to path to the base segment, and record in the tTempZoneTravelDistanceBySegment any zones that are within the distance cap
    --iMaxSegmentSearchDistance - number of segments to search (will do +/- this)
    --iDistanceCap - will ignore any segment zones further away than this
    --bUseRoughPathingDistance - will rely on the default FAF pathfinding distance rather than manually recalculating all the distance values (runs quicker, but less accurate)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordTemporaryTravelDistanceForBaseSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tCurPosition
    local iCurZone, iCurTravelDist
    local bAbort = false --if we find a really close location then will stop looking for better ones

    if bDebugMessages == true then LOG(sFunctionRef..': About to look for segments near base segment '..iBaseSegmentX..'-'..iBaseSegmentZ..'; iMaxSegmentSearchDistance='..iMaxSegmentSearchDistance..'; iDistanceCap='..iDistanceCap..'; iLandPathingGroupWanted='..(iLandPathingGroupWanted or 'nil')) end

    local iAbortThreshold --This is used so we can stop looking through nearby segments if we find one that is likely to be the closest we will find

    --Below sub-function will consider the segment iCurSegmentX-iCurSegmentZ, if it has a land zone assigned then will check how far it is to the base segment and if it satisfies the requirements then will record in the temporary table of distances
    function CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
        --Does the segment have a land zone assigned, and we haven't just assigned it in this loop?
        if bDebugMessages == true then
            LOG(sFunctionRef..': Considering curSegmentX-z='..iCurSegmentX..'-'..iCurSegmentZ..'; Will note if we have a landzone for this')
            if tLandZoneBySegment[iCurSegmentX] then LOG('tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]='..repru(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]))
            else
                LOG('Dont have any land zone for anything with semgnet X='..iCurSegmentX)
            end
        end
        if tLandZoneBySegment[iCurSegmentX] and tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] then --and (not(tTempZoneTravelDistanceBySegment[iCurSegmentX]) or not(tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ])) then
            tCurPosition = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
            if bDebugMessages == true then LOG(sFunctionRef..': Have a land zone for CurSegmentX-Z'..iCurSegmentX..'-'..iCurSegmentZ..'; Pathing label of this segment='..NavUtils.GetTerrainLabel(refPathingTypeLand, tCurPosition)..'; iLandPathingGroupWanted='..iLandPathingGroupWanted) end
            if NavUtils.GetTerrainLabel(refPathingTypeLand, tCurPosition) == iLandPathingGroupWanted then

                if bUseRoughPathingDistance then
                    iCurTravelDist = M28Utilities.GetApproxTravelDistanceBetweenPositions(tBasePosition, tCurPosition)
                else
                    iCurTravelDist = M28Utilities.GetTravelDistanceBetweenPositions(tBasePosition, tCurPosition)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iCurTravelDist='..iCurTravelDist) end
                if (iCurTravelDist or 100000) < iDistanceCap then

                    --Update the distance between the bsae segment and a segment in iCurZone to the lower of the current distance and any previously recorded distance
                    iCurZone = tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
                    if bDebugMessages == true then LOG(sFunctionRef..': We have a segment nearby with a land zone, iCurZone='..iCurZone..'; will record iCurTravelDist of '..iCurTravelDist..'; against the base segment') end
                    if not(tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ]) then
                        if not(tTempZoneTravelDistanceBySegment[iBaseSegmentX]) then tTempZoneTravelDistanceBySegment[iBaseSegmentX] = {} end
                        tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ] = {}
                    end
                    tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone] = math.min(iCurTravelDist, (tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone] or 100000))
                    if not(tTempZonePlateauBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone]) then tTempZonePlateauBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone] = NavUtils.GetTerrainLabel(refPathingTypeHover, tCurPosition) end
                    if iCurTravelDist <= iAbortThreshold then
                        if bDebugMessages == true then LOG(sFunctionRef..': Found a really close segment so will stop looking for more') end
                        bAbort = true
                    end
                end
            end
        end
    end

    local iMaxAdjustedX, iMaxAdjustedZ, iMinAdjustedX, iMinAdjustedZ, iZInterval

    --Cycle through each segment, starting with those closest to the base position
    for iAdjustmentSize = 1, iMaxSegmentSearchDistance do
        iAbortThreshold = iLandZoneSegmentSize * (iAdjustmentSize * 1.3 + 1)
        iMaxAdjustedX = math.min(iAdjustmentSize + iBaseSegmentX, iMaxLandSegmentX)
        iMaxAdjustedZ = math.min(iAdjustmentSize + iBaseSegmentZ, iMaxLandSegmentZ)
        iMinAdjustedX = math.max(1, iBaseSegmentX-iAdjustmentSize)
        iMinAdjustedZ = math.max(1, iBaseSegmentZ-iAdjustmentSize)
        iZInterval = math.max(1, iMaxAdjustedZ - iMinAdjustedZ)



        for iCurSegmentX = iMinAdjustedX, iMaxAdjustedX, 1 do
            --Since we are starting from the closest segments and moving out, we effectively want to cycle through a hollow square of segments with each change in iAdjustmentSize:
            if iCurSegmentX == iMinAdjustedX or iCurSegmentX == iMaxAdjustedX then
                for iCurSegmentZ = iMinAdjustedZ, iMaxAdjustedZ, 1 do
                    CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
                    if bAbort then break end
                end
            else
                for iCurSegmentZ = iMinAdjustedZ, iMaxAdjustedZ, iZInterval do
                    CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
                    if bAbort then break end
                end
            end
            if bAbort then break end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed recording if we have any nearby zones that can path here, tTempZoneTravelDistanceBySegment for base segment '..iBaseSegmentX..'-'..iBaseSegmentZ..'='..repru(tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ])..'; bAbort='..tostring(bAbort)) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param iBaseSegmentX number
---@param iBaseSegmentZ number
---@param iLandZone number
---@param iSegmentSearchRange number
---@param iDistanceCap number
local function AssignNearbySegmentsToSameLandZone(iBaseSegmentX, iBaseSegmentZ, iSegmentSearchRange, iDistanceCap)
    --Cycles through every segment within iSegmentSearchRange of the base segment X-Z value, and if the pathing distance is within the distance cap iDistanceCap then will assign it to the same land zone as the base segment X and Z
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignNearbySegmentsToSameLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iLandZone = tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]
    local iCurTravelDist
    local tBaseMidpoint = GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
    local iPlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, tBaseMidpoint)
    for iCurSegmentX = math.max(1, iBaseSegmentX - iSegmentSearchRange), math.min(iBaseSegmentX + iSegmentSearchRange, iMaxLandSegmentX), 1 do
        for iCurSegmentZ = math.max(1, iBaseSegmentZ - iSegmentSearchRange), math.min(iBaseSegmentZ + iSegmentSearchRange, iMaxLandSegmentZ), 1 do
            if not(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]) then
                iCurTravelDist = M28Utilities.GetTravelDistanceBetweenPositions(GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ), tBaseMidpoint)
                if (iCurTravelDist or 100000) <= iDistanceCap then
                    if not(tLandZoneBySegment[iCurSegmentX]) then tLandZoneBySegment[iCurSegmentX] = {} end
                    RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iPlateau, iLandZone)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function AssignRemainingSegmentsToLandZones()
    --Cycles through key points on the map and if they ahve no nearby land zone then creates a new land zone and assigns nearby segments to it
    --then cycles through every segment on the map and if it has no land zone assigns it to the nearest existing land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignRemainingSegmentsToLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --rMapPotentialPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2}
    local iLandPathingGroupWanted
    local iPlateauGroup

    local iMaxSegmentZoneCopyThreshold
    if iMapSize > 512 then iMaxSegmentZoneCopyThreshold = math.max(3, math.ceil(50 / iLandZoneSegmentSize)) --NOTE: If changing this consider if also want to change the value for AssignSegmentsNearMexesToLandZones; for first draft have this as slightly lower
    else iMaxSegmentZoneCopyThreshold = math.max(3, math.ceil(30 / iLandZoneSegmentSize))
    end

    local iMaxSegmentSearchDistance = iMaxSegmentZoneCopyThreshold * 2
    --Reduce the actual copy segment range by 1 for non-campaign, reduce further for campaign
    if bIsCampaignMap then
        iMaxSegmentZoneCopyThreshold = math.max(math.floor(iMaxSegmentZoneCopyThreshold * 0.5), math.min(iMaxSegmentZoneCopyThreshold - 1, 3))
    else
        iMaxSegmentZoneCopyThreshold = math.max(math.floor(iMaxSegmentZoneCopyThreshold * 0.9), math.min(iMaxSegmentZoneCopyThreshold - 1, 3))
    end


    if bDebugMessages == true then LOG(sFunctionRef..': iMaxSegmentZoneCopyThreshold='..iMaxSegmentZoneCopyThreshold) end

    local iDistanceCap = math.max(40, iMaxSegmentSearchDistance * iLandZoneSegmentSize) --used from old appraoch kept in for the redundancy approach; in theory should never acutally be needed

    local tBasePosition

    --Create a new zone for any locations with no nearby pathable zones
    local iBasePositionX = - iLandZoneSegmentSize * 0.5 + rMapPotentialPlayableArea[1]
    local iBasePositionZ
    local iNearbyAssignmentSegmentRange = math.min(iMaxSegmentSearchDistance, math.ceil(iMaxSegmentSearchDistance * 0.5) + 1)
    local tiLZEntryByNavUtilsRef = {}

    function GetNeighbours(iSegmentX, iSegmentZ, tBasePosition)
        local tTableBeforePositions = {{iSegmentX - 1, iSegmentZ, {{tBasePosition[1] - 1, 0, tBasePosition[3]}}}, {iSegmentX, iSegmentZ - 1, {{tBasePosition[1], 0, tBasePosition[3] - 1}}}, {iSegmentX, iSegmentZ + 1, {{tBasePosition[1], 0, tBasePosition[3] + 1}}}, {iSegmentX + 1, iSegmentZ, {{tBasePosition[1] + 1, 0, tBasePosition[3]}}}}
        if iLandZoneSegmentSize > 1 then
            for iEntry, tSubtable in tTableBeforePositions do
                if bDebugMessages == true then LOG(sFunctionRef..': tSubtable='..repru(tSubtable)..'; tSubtable[3]='..repru(tSubtable[3])) end
                for iPositionAdjust = 2, iLandZoneSegmentSize, 1 do
                    if iEntry == 1 then
                        table.insert(tSubtable[3], {tBasePosition[1] - iPositionAdjust, 0, tBasePosition[3]})
                    elseif iEntry == 2 then
                        table.insert(tSubtable[3], {tBasePosition[1], 0, tBasePosition[3] - iPositionAdjust})
                    elseif iEntry == 3 then
                        table.insert(tSubtable[3], {tBasePosition[1], 0, tBasePosition[3] + iPositionAdjust})
                    elseif iEntry == 4 then
                        table.insert(tSubtable[3], {tBasePosition[1] + iPositionAdjust, 0, tBasePosition[3]})
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': tTableBeforePositions='..repru(tTableBeforePositions)) end
        return tTableBeforePositions
    end

    --Subfunction that checks nearby segments that we can path to with a land zone already assigned, and if there are none then creates a new land zone for the base position and assigns segments near it to the same land zone
    function CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ, iMaxSearchCycle, iCopyZoneThreshold)
        --iCopyZoneThreshold - if come across segments with valid existing zone before this threshold is reached in the iSearchCount loop then will set everything to that zone
        if not(tLandZoneBySegment[iBaseSegmentX]) or not(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
            local bHadSomeEntries, bSameLandLabel
            tBasePosition = {iBasePositionX, 0, iBasePositionZ} --GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
            local iRevisedBaseSegmentX = iBaseSegmentX
            local iRevisedBaseSegmentZ = iBaseSegmentZ
            --tBasePosition[2] = GetSurfaceHeight(tBasePosition[1], tBasePosition[3]) --Dont think this is needed
            iLandPathingGroupWanted = NavUtils.GetTerrainLabel(refPathingTypeLand, tBasePosition)
            if (iLandPathingGroupWanted or 0) == 0 then
                --We shouldnt have got here unless plateau returned a valid pathing value; however can have cases where is pathable by one measure but not another due to imprecisions in the FAF pathfinding approach
                --Therefore, want to check if we are on land (rather htan water which is handled separately) and if so then include still
                iPlateauGroup = NavUtils.GetTerrainLabel(refPathingTypeHover, tBasePosition)
                if bDebugMessages == true then LOG(sFunctionRef..': iPlateauGroup of the target location='..(iPlateauGroup or 'nil')..'; Surface height='..GetSurfaceHeight(iBasePositionX, iBasePositionZ)..'; Terrain height='..GetTerrainHeight(iBasePositionX, iBasePositionZ)..'; tBasePosition='..repru(tBasePosition)..'; iBasePositionX-Z='..iBasePositionX..'-'..iBasePositionZ) end
                if (iPlateauGroup or 0) > 0 then
                    --Check we arent on water
                    if GetSurfaceHeight(iBasePositionX, iBasePositionZ) <= GetTerrainHeight(iBasePositionX, iBasePositionZ) then
                        local tiAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}, {-3,0}, {-3, -3}, {-3, 3}, {0, -3}, {0, 3}, {3, -3}, {3, 0}, {3,3}}
                        local iPotentialLandGroup
                        for iEntry, tXZAdjust in tiAdjust do

                            iPotentialLandGroup = NavUtils.GetTerrainLabel(refPathingTypeLand, { tBasePosition[1] + tXZAdjust[1], tBasePosition[2], tBasePosition[3] + tXZAdjust[2] })
                            if (iPotentialLandGroup or 0) > 0 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have al ocation with a plateau ref but no land ref, but adjusting for tXZAdjust='..repru(tXZAdjust)..' gives us a valid land group, iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ) end
                                iLandPathingGroupWanted = iPotentialLandGroup
                                tBasePosition = { tBasePosition[1] + tXZAdjust[1], tBasePosition[2], tBasePosition[3] + tXZAdjust[2] }
                                iRevisedBaseSegmentX, iRevisedBaseSegmentZ = GetPathingSegmentFromPosition({tBasePosition[1] + tXZAdjust[1], tBasePosition[2], tBasePosition[3] + tXZAdjust[2]})
                                break
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Unable to find any nearby locations with land pathing') end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ..'; iLandPathingGroupWanted='..(iLandPathingGroupWanted or 'nil')) end
            if (iLandPathingGroupWanted or 0) > 0 then
                --Are we from a plateau that has mexes?
                iPlateauGroup = (NavUtils.GetTerrainLabel(refPathingTypeHover, tBasePosition) or NavUtils.GetTerrainLabel('Amphibious', tBasePosition))
                if not(iPlateauGroup) then
                    local tiAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}, {-3,0}, {-3, -3}, {-3, 3}, {0, -3}, {0, 3}, {3, -3}, {3, 0}, {3,3}}
                    for iEntry, tXZAdjust in tiAdjust do
                        iPlateauGroup = NavUtils.GetTerrainLabel(refPathingTypeHover, { tBasePosition[1] + tXZAdjust[1], tBasePosition[2], tBasePosition[3] + tXZAdjust[2] })
                        if iPlateauGroup then break end
                    end
                end

                --Cycle through adjacent segments to see if find a land zone, and if so then assign this
                local tiSegmentsForAssignment = {}
                local iLandZoneToUse
                local tiAdjacentSegmentsForSearchBySearchCount = {}
                tiAdjacentSegmentsForSearchBySearchCount[0] = {{iRevisedBaseSegmentX, iRevisedBaseSegmentZ, iLandPathingGroupWanted, iLandPathingGroupWanted, tBasePosition}}
                if bDebugMessages == true then LOG(sFunctionRef..': About to cycle thorugh adjacent segments to try and find a land zone that should assign this to, in same pathing group as iRevisedBaseSegmentX and Z, X'..iRevisedBaseSegmentX..'Z'..iRevisedBaseSegmentZ..'; iLandPathingGroupWanted='..iLandPathingGroupWanted..'; tBasePosition='..repru(tBasePosition)..'; iMaxSegmentSearchDistance='..iMaxSegmentSearchDistance..'; iMaxSearchCycle='..iMaxSearchCycle) end
                for iSearchCount = 1, iMaxSearchCycle + 1 do
                    tiAdjacentSegmentsForSearchBySearchCount[iSearchCount] = {}
                    bHadSomeEntries = false
                    for iEntry, tiSegmentXZAndZone in tiAdjacentSegmentsForSearchBySearchCount[iSearchCount-1] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iSearchCount-1='..(iSearchCount - 1)..'; tiSegmentXZAndZone='..repru(tiSegmentXZAndZone)) end
                        for iNeighbourEntry, tiNeighbourXZ in GetNeighbours(tiSegmentXZAndZone[1], tiSegmentXZAndZone[2], tiSegmentXZAndZone[5]) do
                            if bDebugMessages == true then LOG(sFunctionRef..': Cycling through each neighbour for iSearchCount='..iSearchCount..' and iEntry='..iEntry..', neighbour Segment XZ=X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iNeighbourEntry='..iNeighbourEntry..'; tLandZoneBySegment for this='..(tLandZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]] or 'nil')..'; tiSegmentsForAssignment[tiNeighbourXZ[1]][tiNeighbourXZ[2]]='..tostring(tiSegmentsForAssignment[tiNeighbourXZ[1]][tiNeighbourXZ[2]] or false)) end
                            if not(tLandZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]]) then
                                --The neighbour doesnt have an assignment either, if we haven't recorded it already as a segment for assignment, then receord it if it is in the same land terrain label as the base position
                                if not(tiSegmentsForAssignment[tiNeighbourXZ[1]][tiNeighbourXZ[2]]) then
                                    if not(tLandZoneBySegment[tiNeighbourXZ[1]]) then tLandZoneBySegment[tiNeighbourXZ[1]] = {} end
                                    bSameLandLabel = true
                                    for iEntry, tPosition in tiNeighbourXZ[3] do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Segment XZ=X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iEntry='..iEntry..'; tPosition='..repru(tPosition)..'; Land label='..(NavUtils.GetTerrainLabel('Land', tPosition) or 'nil')..'; tiSegmentXZAndZone[4] label='..(tiSegmentXZAndZone[4] or 'nil')) end
                                        if not(NavUtils.GetTerrainLabel('Land', tPosition) == tiSegmentXZAndZone[4]) then
                                            bSameLandLabel = false
                                            break
                                        end
                                    end

                                    if bSameLandLabel then
                                        if not(tiSegmentsForAssignment[tiNeighbourXZ[1]]) then tiSegmentsForAssignment[tiNeighbourXZ[1]] = {} end
                                        tiSegmentsForAssignment[tiNeighbourXZ[1]][tiNeighbourXZ[2]] = true
                                        table.insert(tiAdjacentSegmentsForSearchBySearchCount[iSearchCount], {tiNeighbourXZ[1], tiNeighbourXZ[2], iLandPathingGroupWanted, iLandPathingGroupWanted, GetPositionFromPathingSegments(tiNeighbourXZ[1], tiNeighbourXZ[2])})
                                        bHadSomeEntries = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering segment X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iCurLandLabel='..(tiSegmentXZAndZone[4] or 'nil')..'; adding to table of valid locations') end
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have unpathable segment X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iCurLandLabel='..(tiSegmentXZAndZone[4] or 'nil')..'; adding to table of segments that cant path to') end
                                    end
                                end
                            else
                                --Have a valid segment so use this as the land zone unless have reached iCopyZoneThreshold
                                if bDebugMessages == true then LOG(sFunctionRef..': Already considered or recorded this zone will check if it is within copy zone threshold, iLandZoneToUse='..(iLandZoneToUse or 'nil')..'; iSearchCount='..iSearchCount..'; iCopyZoneThreshold='..(iCopyZoneThreshold or 'nil')..'; Neighbour land zone='..(tLandZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]] or 'nil')..'; Neighbour segment=X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]) end
                                if not(iLandZoneToUse) and iSearchCount < (iCopyZoneThreshold or 10000) then
                                    iLandZoneToUse = tLandZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]]
                                    if bDebugMessages == true then LOG(sFunctionRef..': Are within copy zone threshold so will assign to this zone '..iLandZoneToUse) end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG('Finished for iSearchCount='..iSearchCount..'; Size of tiAdjacentSegmentsForSearchBySearchCount='..table.getn(tiAdjacentSegmentsForSearchBySearchCount[iSearchCount])..'; iLandZoneToUse='..(iLandZoneToUse or 'nil')..'; bHadSomeEntries='..tostring(bHadSomeEntries)) end
                    if not(bHadSomeEntries) or (iLandZoneToUse and iSearchCount >= iCopyZoneThreshold) then break end
                end
                --If we didnt come across an existing nearby land zone we can path to then create a new zone:
                if bDebugMessages == true then LOG(sFunctionRef..': FInished cycling through all nearby pathable segments for base segments X'..iRevisedBaseSegmentX..'Z'..iRevisedBaseSegmentZ..'; iLandZoneToUse='..(iLandZoneToUse or 'nil')) end
                if not(iLandZoneToUse) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Plateau mex count='..(tAllPlateaus[iPlateauGroup][subrefPlateauTotalMexCount] or 0)..'; iPlateauGroup='..(iPlateauGroup or 'nil')) end
                    if (tAllPlateaus[iPlateauGroup][subrefPlateauTotalMexCount] or 0) > 0 then
                        CreateNewLandZoneAtSegment(iRevisedBaseSegmentX, iRevisedBaseSegmentZ, iPlateauGroup)
                        iLandZoneToUse = tAllPlateaus[iPlateauGroup][subrefLandZoneCount]
                        if bDebugMessages == true then LOG(sFunctionRef..': Created new zone for this plateau, iLandZoneToUse='..iLandZoneToUse..'; will use this as the land zone') end
                    else
                        if iPlateauGroup > 0 then
                            --We haven't created this LZ yet; have we created the plateau?
                            if bDebugMessages == true then LOG(sFunctionRef..': Will create a new land zone but first checking if we have this plateau recorded, is all plateaus nil for iPlateauGroup='..iPlateauGroup..'='..tostring(tAllPlateaus[iPlateauGroup] == nil)) end
                            if not(tAllPlateaus[iPlateauGroup]) then
                                RecordMexlessPlateau(iPlateauGroup)
                            end

                            if not(tiLZEntryByNavUtilsRef[iPlateauGroup]) then
                                tiLZEntryByNavUtilsRef[iPlateauGroup] = {}
                            end

                            --Need to add land zone reference to this plateau
                            AddNewLandZoneReferenceToPlateau(iPlateauGroup)
                            tiLZEntryByNavUtilsRef[iPlateauGroup][iLandPathingGroupWanted] = tAllPlateaus[iPlateauGroup][subrefLandZoneCount]
                            RecordSegmentLandZone(iBaseSegmentX, iBaseSegmentZ, iPlateauGroup, tAllPlateaus[iPlateauGroup][subrefLandZoneCount])
                            iLandZoneToUse = tAllPlateaus[iPlateauGroup][subrefLandZoneCount]
                            if bDebugMessages == true then LOG(sFunctionRef..': Created new land zone, iLandZoneToUse='..iLandZoneToUse) end
                        else
                            M28Utilities.ErrorHandler('somehow have a land zone but not a plateau group; Refer to log for base position and other details if logs are enabled')
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Base position='..repru(tBasePosition)..'; Land nav='..(NavUtils.GetTerrainLabel(refPathingTypeLand, tBasePosition) or 'nil')..'; Plateau nav='..(NavUtils.GetTerrainLabel(refPathingTypeHover, tBasePosition) or 'nil')..'; Amphibious plateau='..(NavUtils.GetTerrainLabel('Amphibious', tBasePosition) or 'nil'))
                                M28Utilities.DrawLocation(tBasePosition, 2)
                            end

                        end
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Finished creating land zone if we didnt have one, iLandZoneTOUse='..(iLandZoneToUse or 'nil')..'; iPlateauGroup='..(iPlateauGroup or 'nil')..'; iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ..'; iCopyZoneThreshold='..iCopyZoneThreshold..'; tiSegmentsForAssignment='..repru(tiSegmentsForAssignment)..'; tiAdjacentSegmentsForSearchBySearchCount='..repru(tiAdjacentSegmentsForSearchBySearchCount)) end
                if iLandZoneToUse then
                    RecordSegmentLandZone(iBaseSegmentX, iBaseSegmentZ, iPlateauGroup, iLandZoneToUse)
                    if M28Utilities.IsTableEmpty(tiSegmentsForAssignment) == false then
                        for iCurSegmentX, tSubtable in tiSegmentsForAssignment do
                            for iCurSegmentZ, bIncluded in tSubtable do
                                RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iPlateauGroup, iLandZoneToUse)
                            end
                        end
                    end
                end
            elseif bDebugMessages == true then
                LOG(sFunctionRef..': No land pathing group for base position '..repru(tBasePosition)..'; iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ..'; will draw base position')
                M28Utilities.DrawLocation(tBasePosition)
            end
            end

    end
    --Cycle through every nth segment on the map - only consider every iMaxSegmentSearchDistance 'th segment (for performance reasons), and check if it has nearby land zones, and if not then create a new land zone at this position
    local iXTotalIntervals = math.floor(iMaxLandSegmentX / iMaxSegmentSearchDistance)
    local iXDifToSegmentSize = iMaxLandSegmentX - iMaxSegmentSearchDistance * iXTotalIntervals
    local iXStartSegmentAdjust =  math.floor((-iXDifToSegmentSize + iMaxSegmentSearchDistance) * -0.5)
    local iXStartSegment = iXStartSegmentAdjust + iMaxSegmentSearchDistance
    local iXEndSegment = iXStartSegmentAdjust + iMaxSegmentSearchDistance * iXTotalIntervals
    local iDistanceBetweenSquares = iMaxSegmentSearchDistance * iLandZoneSegmentSize
    local iStartPositionX = iXStartSegment * iLandZoneSegmentSize - iLandZoneSegmentSize * 0.5 + rMapPotentialPlayableArea[1] - iDistanceBetweenSquares

    local iZTotalIntervals = math.floor(iMaxLandSegmentZ / iMaxSegmentSearchDistance)
    local iZDifToSegmentSize = iMaxLandSegmentZ - iMaxSegmentSearchDistance * iZTotalIntervals
    local iZStartSegmentAdjust =  math.floor((-iZDifToSegmentSize + iMaxSegmentSearchDistance) * -0.5)
    local iZStartSegment = iZStartSegmentAdjust + iMaxSegmentSearchDistance
    local iZEndSegment = iZStartSegmentAdjust + iMaxSegmentSearchDistance * iZTotalIntervals

    iBasePositionX = iStartPositionX
    if bDebugMessages == true then LOG(sFunctionRef..': iMaxLandSegmentX='..iMaxLandSegmentX..'; iMaxSegmentSearchDistance='..iMaxSegmentSearchDistance..'; iXTotalIntervals='..iXTotalIntervals..'; iXDifToSegmentSize='..iXDifToSegmentSize..'; iXStartSegmentAdjust='..iXStartSegmentAdjust..'; iXStartSegment='..iXStartSegment..'; iXEndSegment='..iXEndSegment..'; iStartPositionX='..iStartPositionX..'; rMapPotentialPlayableArea='..repru(rMapPotentialPlayableArea)..'; iDistanceBetweenSquares='..iDistanceBetweenSquares) end

    for iBaseSegmentX = iXStartSegment, iXEndSegment, iMaxSegmentSearchDistance do
        iBasePositionX = iBasePositionX + iDistanceBetweenSquares --Manually done instead of GetPositionFromPathingSegments for performance
        iBasePositionZ = iZStartSegment * iLandZoneSegmentSize - iLandZoneSegmentSize * 0.5 + rMapPotentialPlayableArea[2] - iDistanceBetweenSquares

        if not(tLandZoneBySegment[iBaseSegmentX]) then tLandZoneBySegment[iBaseSegmentX] = {} end
        if not(tTempZoneTravelDistanceBySegment[iBaseSegmentX]) then
            tTempZoneTravelDistanceBySegment[iBaseSegmentX] = {}
            tTempZonePlateauBySegment[iBaseSegmentX] = {}
        end
        for iBaseSegmentZ = iZStartSegment, iZEndSegment, iMaxSegmentSearchDistance do
            iBasePositionZ = iBasePositionZ + iDistanceBetweenSquares
            --Check we dont already have a zone assigned
            CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ, iMaxSegmentSearchDistance, iMaxSegmentZoneCopyThreshold)
            if bDebugMessages == true then
                LOG('iBaseSegmentX = '..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ..'; iBasePositionX='..iBasePositionX..'; iBasePositionZ='..iBasePositionZ)
                M28Utilities.DrawLocation({iBasePositionX, GetSurfaceHeight(iBasePositionX, iBasePositionZ), iBasePositionZ}, 3, 200, iLandZoneSegmentSize)
            end
        end
        --WaitTicks(1)
        if bDebugMessages == true then LOG(sFunctionRef..': Finished all iBaseSegmentX='..iBaseSegmentX..'; moving to next X segments, systemtime='..GetSystemTimeSecondsOnlyForProfileUse()) end
    end
    --Now go through each segment considered and pick the lowest value distance as the assigned land zone
    --AssignTempSegmentsWithDistance()
    if bDebugMessages == true then
        LOG(sFunctionRef..': Finished assigning land zones for locations with no nearby zones, systemtime='..GetSystemTimeSecondsOnlyForProfileUse())
        WaitTicks(10)
    end

    --Now cycle through every segment on the map, and assign to a land zone (or create a new land zone if none nearby, but hopefully after the above code this will be rare)

    iBasePositionX = - iLandZoneSegmentSize * 0.5 + rMapPotentialPlayableArea[1] --Calculate the position manually (instead of using the function GetPositionFromPathingSegments) for performance
    for iBaseSegmentX = 1, iMaxLandSegmentX do
        iBasePositionX = iBasePositionX + iLandZoneSegmentSize --(i.e. as per GetPositionFromPathingSegments)
        iBasePositionZ = - iLandZoneSegmentSize * 0.5 + rMapPotentialPlayableArea[2]
        for iBaseSegmentZ = 1, iMaxLandSegmentZ do
            iBasePositionZ = iBasePositionZ + iLandZoneSegmentSize
            if bDebugMessages == true then LOG(sFunctionRef..': Cycling through all segments, just about to check iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ..'; tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]='..(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ] or 'nil')) end
            CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ, iMaxSegmentSearchDistance, iMaxSegmentZoneCopyThreshold)
            if bDebugMessages == true then LOG(sFunctionRef..': Land zone after checking='..(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ] or 'nil')) end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed creating land zones for any remaining locations with no nearby land zone, system time='..GetSystemTimeSecondsOnlyForProfileUse()..'; Land zone for base segment1-1='..(tLandZoneBySegment[1][1] or 'nil')) end

    --The above will have updated the temporary table with details of how long to path to each zone; now go through and assign each segment to the closest zone to it
    --AssignTempSegmentsWithDistance()

    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed assigning zones for any temporary distances for the zones created in the previous step, system time='..GetSystemTimeSecondsOnlyForProfileUse()..'; about to run logic to check for any rmeaining segment') end


    --Redundancy - cycle through any zones that dont have a segment and create new zones for them - hopefully this shouldnt be possible provided we have setup the segment search ranges correctly above
    --Also setup initial details on water segments

    for iBaseSegmentX = 1, iMaxLandSegmentX do
        for iBaseSegmentZ = 1, iMaxLandSegmentZ do
            if bDebugMessages == true then LOG(sFunctionRef..': iBaseSegmentX-Z='..iBaseSegmentX..'-'..iBaseSegmentZ..'; Is the land zone for htis segment nil='..tostring(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]==nil)..'; Hover label='..(NavUtils.GetTerrainLabel(refPathingTypeHover, tBasePosition) or 0)..'; Land label='..(NavUtils.GetTerrainLabel(refPathingTypeLand, tBasePosition) or 'nil')..'; NavUtils.GetTerrainLabel(refPathingTypeNavy, tBasePosition)='..(NavUtils.GetTerrainLabel(refPathingTypeNavy, tBasePosition) or 'nil')..'; tLandZoneBySegment='..(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ] or 'nil')) end
            if not(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
                tBasePosition = GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
                if (NavUtils.GetTerrainLabel(refPathingTypeHover, tBasePosition) or 0) > 0 then
                    iLandPathingGroupWanted = NavUtils.GetTerrainLabel(refPathingTypeLand, tBasePosition)
                    if (iLandPathingGroupWanted or 0) >= 1 then
                        M28Utilities.ErrorHandler('Have a location that is land pathable which has an unassigned land zone for base segments XZ='..iBaseSegmentX..'-'..iBaseSegmentZ..'; tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]='..(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ] or 'nil'))
                        CreateNewLandZoneAtSegment(iBaseSegmentX, iBaseSegmentZ)
                        RecordTemporaryTravelDistanceForBaseSegment(iBaseSegmentX, iBaseSegmentZ, iLandPathingGroupWanted, tBasePosition, iMaxSegmentSearchDistance, iDistanceCap)
                        AssignTempSegmentsWithDistance()
                    else
                        --Do we have a water segment?
                        local iPond = NavUtils.GetTerrainLabel(refPathingTypeNavy, tBasePosition)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iBaseSegmentX-Z='..iBaseSegmentX..'-'..iBaseSegmentZ..'; we have hover pathing but not water;tBasePosition='..repru(tBasePosition)..'; Surface height='..GetSurfaceHeight(tBasePosition[1], tBasePosition[3])..'; Terrain height='..GetTerrainHeight(tBasePosition[1], tBasePosition[3])..'; iPond='..(iPond or 'nil')) end
                        if (iPond or 0) == 0 and GetSurfaceHeight(tBasePosition[1], tBasePosition[3]) > GetTerrainHeight(tBasePosition[1], tBasePosition[3]) then
                            --We are on water, so check nearby as FAF pathfinding not 100% accurate on larger maps
                            local tiAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}, {-3,0}, {-3, -3}, {-3, 3}, {0, -3}, {0, 3}, {3, -3}, {3, 0}, {3,3}}
                            local iPotentialPond
                            for iEntry, tXZAdjust in tiAdjust do
                                iPotentialPond = NavUtils.GetTerrainLabel(refPathingTypeNavy, { tBasePosition[1] + tXZAdjust[1], tBasePosition[2], tBasePosition[3] + tXZAdjust[2] })
                                if (iPotentialPond or 0) > 0 then
                                    iPond = iPotentialPond
                                    if bDebugMessages == true then LOG(sFunctionRef..': Foudn a nearby pond '..iPotentialPond..', tXZAdjust='..repru(tXZAdjust)) end
                                    break
                                end
                            end
                        end
                        if (iPond or 0) > 0 then
                            if bDebugMessages == true then LOG(sFunctionRef..': About to record a pond for iBaseSegmentX-Z='..iBaseSegmentX..'-'..iBaseSegmentZ..' for pond '..iPond..'; tBasePosition='..repru(tBasePosition)) end
                            RecordNavalSegment(iPond, iBaseSegmentX, iBaseSegmentZ, tBasePosition)
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished redundancy of checking every segment has a land zone if it is land pathable, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


local function AssignMexesALandZone()
    --Cycles through every mex and assigns it to a new land zone, unless it is near another mex in which case they should both use the same land zone

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignMexesALandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Key config values
    local iNearbyMexRange --Initially mexes will be grouped together based on this, i.e. will assign mexes within this distance of each other to the same land zone
    local iRecursiveFactor
    --rMapPotentialPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2}
    local iMaxMapSize = math.max(rMapPotentialPlayableArea[3] - rMapPotentialPlayableArea[1], rMapPotentialPlayableArea[4] - rMapPotentialPlayableArea[2])
    if iMaxMapSize > 1024 then --1024 is 20k, so this is 40k or 80k
        iNearbyMexRange = 54
        iRecursiveFactor = 4
    elseif iMaxMapSize > 512 then --i.e. 20k
        iNearbyMexRange = 46
        iRecursiveFactor = 3.5
    elseif iMaxMapSize > 256 then
        iNearbyMexRange = 42
        iRecursiveFactor = 3
    else
        iNearbyMexRange = 35
        iRecursiveFactor = 2
    end


    if bDebugMessages == true then LOG('About to setup land zones') end

    local tiPlateauLandZoneByMexRef = {} --[x] is plateau ref, [y] is mex number, returns the LZ
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        tiPlateauLandZoneByMexRef[iPlateau] = {}
    end

    --Subfunction - if we have a mex to assign to a land zone then this subfunction should be called to check for any nearby mexes without a zone and assign these to the same zone
    function AddNearbyMexesToLandZone(iPlateau, iCurLandZone, tMex, iRecursiveCount)
        local iLandGroupWanted = NavUtils.GetTerrainLabel(refPathingTypeLand, tMex)
        local iMaxRange
        if iRecursiveCount <= 1 then iMaxRange = math.max(15, iNearbyMexRange)
        else iMaxRange = math.max(15, iNearbyMexRange - iRecursiveCount * iRecursiveFactor)
        end
        for iAltMex, tAltMex in tAllPlateaus[iPlateau][subrefPlateauMexes] do
            if not(tiPlateauLandZoneByMexRef[iPlateau][iAltMex]) then
                if NavUtils.GetTerrainLabel(refPathingTypeLand, tAltMex) == iLandGroupWanted and not(IsUnderwater(tAltMex, false, 0.1)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAltMex='..iAltMex..' for zone '..iCurLandZone..'; Distance straight line='..M28Utilities.GetDistanceBetweenPositions(tAltMex, tMex)..'; Travel distance='..M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex)) end
                    if M28Utilities.GetDistanceBetweenPositions(tAltMex, tMex) <= iMaxRange and M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex) <= iMaxRange then
                        AddMexToLandZone(iPlateau, iCurLandZone, iAltMex, tiPlateauLandZoneByMexRef)
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Added mex '..iAltMex..' with position '..repru(tAltMex)..' to land zone, tiPlateauLandZoneByMexRef='..(tiPlateauLandZoneByMexRef[iAltMex] or 'nil')..'; Distance in straight line='..M28Utilities.GetDistanceBetweenPositions(tAltMex, tMex)..'; Travel distance='..M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex)..'; tMex='..repru(tMex)..'; tAltMex='..repru(tAltMex)..'; Land label for tMex='..(NavUtils.GetLabel(refPathingTypeLand, tMex) or 'nil')..'; land label for tAltMex='..(NavUtils.GetLabel(refPathingTypeLand, tAltMex) or 'nil'))
                            M28Utilities.DrawLocation(tAltMex, 2)
                            M28Utilities.DrawLocation(tMex, 1)
                        end
                        AddNearbyMexesToLandZone(iPlateau, iCurLandZone, tAltMex, iRecursiveCount + 1) --Needs to be recursive or else can end up with 2 mees that are really close to each other not being in the same group depending on the order in which the original mexes are called
                    end
                end
            end
        end
    end

    --First setup core base land zones, including merging core bases if they are close to each other into a single land zone - have the size of the core base impacted by if there is a hydro nearby

    --Get the start points to actually consider
    local tRelevantStartPointsByIndex = {}
    for iBrain, oBrain in ArmyBrains do
        if not(M28Conditions.IsCivilianBrain(oBrain)) then
            local iStartPositionX, iStartPositionZ = oBrain:GetArmyStartPos()
            tRelevantStartPointsByIndex[oBrain:GetArmyIndex()] = {iStartPositionX, GetSurfaceHeight(iStartPositionX, iStartPositionZ), iStartPositionZ}
        end
    end



    local tiStartIndexPlateauAndLZ = {} --[x] is the player index, returns the land zone to use
    local iLZToUse
    local iCurPlateau
    --Create a table of the start locations that have their own unique land zone (as we want to combine those that are close together):
    for iIndex, tStartPosition in tRelevantStartPointsByIndex do
        iLZToUse = nil
        iCurPlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, tStartPosition)
        --Are we close to an existing start position such that we should use the same LZ for both positions?
        if M28Utilities.IsTableEmpty(tiStartIndexPlateauAndLZ) == false then
            for iExistingIndex, tExistingPlateauAndLZ in tiStartIndexPlateauAndLZ do
                if tExistingPlateauAndLZ[1] == iCurPlateau and M28Utilities.GetDistanceBetweenPositions(tStartPosition, tRelevantStartPointsByIndex[iExistingIndex]) <= 40 then
                    iLZToUse = tExistingPlateauAndLZ[2]
                    break
                end
            end
        end
        if not(iLZToUse) then
            --Check the start position is on land
            if (NavUtils.GetTerrainLabel(refPathingTypeLand, tStartPosition) or 0) > 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': About to add a new LZ reference to iCurPlateau '..(iCurPlateau or 'nil')..' for start position '..repru(tStartPosition)) end
                AddNewLandZoneReferenceToPlateau(iCurPlateau)
                iLZToUse = tAllPlateaus[iCurPlateau][subrefLandZoneCount]
                if bDebugMessages == true then LOG(sFunctionRef..': Just added iLZToUse='..iLZToUse..'; tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]='..reprs(tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iLZToUse])) end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Start position isnt on valid land pathable location, so assuming it is on water and wont create a lnad zone here') end
            end
        end
        if iLZToUse then
            tiStartIndexPlateauAndLZ[iIndex] = {iCurPlateau, iLZToUse}
            local iCurSegmentX, iCurSegmentZ = GetPathingSegmentFromPosition(tStartPosition)
            RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iCurPlateau, iLZToUse)
            if bDebugMessages == true then LOG(sFunctionRef..': Have just recorded iLZToUse='..iLZToUse..' for iCurPlateau='..iCurPlateau..'; iCurSegmentX-Z='..iCurSegmentX..'-'..iCurSegmentZ..'; Start position='..repru(tStartPosition)..'; Brain index='..iIndex) end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished creating land zone by each start position, tiStartIndexPlateauAndLZ='..repru(tiStartIndexPlateauAndLZ)) end

    --Now find any mexes within the desired travel distance and assign them to the nearest start position - first exclude based on distance, and if they meet the straight line distance check then consider travel distance
    local iCurDistStraightLine
    local iCurDistTravel
    local iClosestDistTravel
    local iClosestBrainIndex

    local tiStartResourcesByBrainIndex = {}

    local iStraightLineThreshold = 70 --Ignore locations that are more than this distance away
    local iTravelDistThreshold = 75 --Ignore locations that are more than this land travel distance away
    if bIsCampaignMap then
        iStraightLineThreshold = 40
        iTravelDistThreshold = 45
    end
    local iClosestStraightLineDist
    local iClosestStraightLineIndex
    local iClosestStraightLineTravelDist

    for iPlateau, tPlateauSubtable in tAllPlateaus do
        if M28Utilities.IsTableEmpty(tPlateauSubtable[subrefPlateauMexes]) == false then
            for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do
                --Only consider if mex isnt underwater
                if tMex[2] >= iMapWaterHeight then
                    --Find the closest start point
                    iClosestDistTravel = iTravelDistThreshold --Ignore points whose travel distance is further away than this
                    iClosestBrainIndex = nil
                    iClosestStraightLineDist = 100000
                    iClosestStraightLineIndex = nil
                    iClosestStraightLineTravelDist = 100000
                    local tiBrainsWithinThreshold = {}
                    --Get the start position closest to this mex (if there are any close enough that we might want the mex to be part of the start zone)
                    for iBrainIndex, tStartPoint in tRelevantStartPointsByIndex do
                        if tiStartIndexPlateauAndLZ[iBrainIndex][1] == iPlateau then
                            iCurDistStraightLine = M28Utilities.GetDistanceBetweenPositions(tMex, tStartPoint)
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurDistStraightLine='..iCurDistStraightLine..'; iStraightLineThreshold='..iStraightLineThreshold..'; iClosestStraightLineTravelDist='..iClosestStraightLineTravelDist) end
                            if iCurDistStraightLine <= iStraightLineThreshold then
                                table.insert(tiBrainsWithinThreshold, {iBrainIndex, iCurDistStraightLine})
                                if iCurDistStraightLine < iClosestStraightLineTravelDist then
                                    iClosestStraightLineTravelDist = iCurDistStraightLine
                                    iClosestStraightLineIndex = iBrainIndex
                                end
                                --[[
                                --Get the land pathing distance
                                iCurDistTravel = M28Utilities.GetTravelDistanceBetweenPositions(tMex, tStartPoint, refPathingTypeLand)
                                if iCurDistTravel < iClosestDistTravel then
                                    iClosestDistTravel = iCurDistTravel
                                    iClosestBrainIndex = iBrainIndex
                                end--]]
                            end
                        end
                    end
                    if iClosestStraightLineIndex then
                        iClosestDistTravel = M28Utilities.GetTravelDistanceBetweenPositions(tMex, tRelevantStartPointsByIndex[iClosestStraightLineIndex], refPathingTypeLand)
                        iClosestBrainIndex = iClosestStraightLineIndex
                        for iEntry, tiIndexAndDist in tiBrainsWithinThreshold do
                            if bDebugMessages == true then LOG(sFunctionRef..': iClosestStraightLineIndex='..iClosestStraightLineIndex..'; tiIndexAndDist='..repru(tiIndexAndDist)..'; tRelevantStartPointsByIndex[tiIndexAndDist[1]]='..repru(tRelevantStartPointsByIndex[tiIndexAndDist[1]])..'; tMex='..repru(tMex)) end
                            if tiIndexAndDist[2] < iClosestDistTravel and not(tiIndexAndDist[1] == iClosestStraightLineIndex) then
                                iCurDistTravel = M28Utilities.GetTravelDistanceBetweenPositions(tMex, tRelevantStartPointsByIndex[tiIndexAndDist[1]], refPathingTypeLand)
                                if bDebugMessages == true then LOG(sFunctionRef..': iCurDistTravel='..(iCurDistTravel or 'nil')..'; iClosestDistTravel='..iClosestDistTravel) end
                                if iCurDistTravel < iClosestDistTravel then
                                    iClosestDistTravel = iCurDistTravel
                                    iClosestBrainIndex = tiIndexAndDist[1]
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Searching for closest brain index to tMex '..repru(tMex)..' that is close enough, iClosestBrainIndex='..(iClosestBrainIndex or 'nil')) end
                    if iClosestBrainIndex then
                        if not(tiStartResourcesByBrainIndex[iClosestBrainIndex]) then tiStartResourcesByBrainIndex[iClosestBrainIndex] = {} end
                        table.insert(tiStartResourcesByBrainIndex[iClosestBrainIndex], tMex)
                        AddMexToLandZone(iPlateau, tiStartIndexPlateauAndLZ[iClosestBrainIndex][2], iMex, tiPlateauLandZoneByMexRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..(tiStartIndexPlateauAndLZ[iClosestBrainIndex][2] or 'nil')..'; Adding iMex='..iMex..'; at position '..repru(tMex)..'; to the start position for aiBrain index='..(iClosestBrainIndex or 'nil')..' which is at '..repru(tRelevantStartPointsByIndex[iClosestBrainIndex])) end
                    end
                end
            end
        end
    end

    --Debug - draw the groupings of mexes with black rectangles around them to show how they've been grouped
    if bDebugMessages == true then
        local iColour = 0
        for iPlateau, tPlateauSubtable in tAllPlateaus do
            LOG(sFunctionRef..': About to draw results of land zones for iPlateau='..iPlateau..'; tiPlateauLandZoneByMexRef[iPlateau]='..repru(tiPlateauLandZoneByMexRef[iPlateau])..'; tAllPlateaus[iPlateau][subrefPlateauLandZones]='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones]))
            iColour = 3
            --Draw the mex groupings
            if M28Utilities.IsTableEmpty(tAllPlateaus[iPlateau][subrefPlateauLandZones]) == false then
                for iZone, tZone in tAllPlateaus[iPlateau][subrefPlateauLandZones] do
                    local iMinX = 100000
                    local iMaxX = 0
                    local iMinZ = 100000
                    local iMaxZ = 0

                    for iMex, tMex in tZone[subrefLZMexLocations] do
                        iMinX = math.min(tMex[1], iMinX)
                        iMaxX = math.max(tMex[1], iMaxX)
                        iMinZ = math.min(tMex[3], iMinZ)
                        iMaxZ = math.max(tMex[3], iMaxZ)
                    end
                    M28Utilities.DrawRectangle(Rect(iMinX, iMinZ, iMaxX, iMaxZ), iColour, 1000, 10)
                end
            end
        end
    end

    --Now add any mexes near these resource locations to the same land zone
    if bDebugMessages == true then LOG(sFunctionRef..': Will now add mexes near the start position resources to the same land zone, tiStartResourcesByBrainIndex='..repru(tiStartResourcesByBrainIndex)) end
    local iStartRecursiveCountToUse
    for iBrainIndex, tResources in tiStartResourcesByBrainIndex do
        iStartRecursiveCountToUse = 1
        if table.getn(tResources) >= 3 then iStartRecursiveCountToUse = table.getn(tResources) - 2 end
        for iResource, tResourceLocation in tResources do
            if (tiStartIndexPlateauAndLZ[iBrainIndex][2] or 0) > 0 then
                AddNearbyMexesToLandZone(tiStartIndexPlateauAndLZ[iBrainIndex][1], tiStartIndexPlateauAndLZ[iBrainIndex][2], tResourceLocation, iStartRecursiveCountToUse)
            end
        end
    end


    --Debug - draw the groupings of mexes with gold rectangles around them to show how they've been grouped following the above
    if bDebugMessages == true then
        local iColour = 0
        for iPlateau, tPlateauSubtable in tAllPlateaus do
            LOG(sFunctionRef..': About to draw results of land zones for iPlateau='..iPlateau..'; tiPlateauLandZoneByMexRef[iPlateau]='..repru(tiPlateauLandZoneByMexRef[iPlateau])..'; tAllPlateaus[iPlateau][subrefPlateauLandZones]='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones]))
            iColour = 4
            --Draw the mex groupings
            if M28Utilities.IsTableEmpty(tAllPlateaus[iPlateau][subrefPlateauLandZones]) == false then
                for iZone, tZone in tAllPlateaus[iPlateau][subrefPlateauLandZones] do
                    local iMinX = 100000
                    local iMaxX = 0
                    local iMinZ = 100000
                    local iMaxZ = 0

                    for iMex, tMex in tZone[subrefLZMexLocations] do
                        iMinX = math.min(tMex[1], iMinX)
                        iMaxX = math.max(tMex[1], iMaxX)
                        iMinZ = math.min(tMex[3], iMinZ)
                        iMaxZ = math.max(tMex[3], iMaxZ)
                    end
                    M28Utilities.DrawRectangle(Rect(iMinX - 0.1, iMinZ - 0.1, iMaxX + 0.1, iMaxZ + 0.1), iColour, 1000, 10)
                end
            end
        end
    end

    --Assign zones to mex locations - group mexes that are near each other in the same zone
    local iCurLandZone
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        if not(tAllPlateaus[iPlateau][subrefPlateauLandZones]) then tAllPlateaus[iPlateau][subrefPlateauLandZones] = {} end
        if bDebugMessages == true then LOG(sFunctionRef..': tPlateauSubtable[subrefPlateauMexes]='..repru(tPlateauSubtable[subrefPlateauMexes])) end
        if M28Utilities.IsTableEmpty(tPlateauSubtable[subrefPlateauMexes]) == false then
            for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do
                if bDebugMessages == true then LOG(sFunctionRef..': iMex='..iMex..'; tMex='..repru(tMex)) end
                if not(IsUnderwater(tMex, false, 0.1)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Plateau='..iPlateau..': Considering mex with plateau mex ref='..iMex..'; position='..repru(tMex)..'; tiPlateauLandZoneByMexRef for this ref='..(tiPlateauLandZoneByMexRef[iPlateau][iMex] or 'nil')) end
                    if not(tiPlateauLandZoneByMexRef[iPlateau][iMex]) then
                        AddMexToLandZone(iPlateau, nil, iMex, tiPlateauLandZoneByMexRef)
                        iCurLandZone = tiPlateauLandZoneByMexRef[iPlateau][iMex]
                        if bDebugMessages == true then LOG(sFunctionRef..': Added mex '..iMex..' with position '..repru(tMex)..' to land zone, tiPlateauLandZoneByMexRef='..(tiPlateauLandZoneByMexRef[iPlateau][iMex] or 'nil')) end

                        --Cycle through each other mex in the plateau and if it is within iNearbyMexRange then assign it to the same group if it hasnt had a group assigned already
                        AddNearbyMexesToLandZone(iPlateau, iCurLandZone, tMex, 0)
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording land zone mexes for iPlateau='..iPlateau..'; Size of land zones table='..table.getn(tAllPlateaus[iPlateau][subrefPlateauLandZones])) end
    end

    --Debug - draw the groupings of mexes with rectangles around them to show how they've been grouped, with a different colour for each plateau group:
    if bDebugMessages == true then
        local iColour = 0
        for iPlateau, tPlateauSubtable in tAllPlateaus do
            LOG(sFunctionRef..': About to draw results of land zones for iPlateau='..iPlateau..'; tiPlateauLandZoneByMexRef[iPlateau]='..repru(tiPlateauLandZoneByMexRef[iPlateau])..'; tAllPlateaus[iPlateau][subrefPlateauLandZones]='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones]))
            iColour = iColour + 1
            if iColour > 7 then iColour = 1 end
            --Draw the mex groupings
            for iZone, tZone in tAllPlateaus[iPlateau][subrefPlateauLandZones] do
                local iMinX = 100000
                local iMaxX = 0
                local iMinZ = 100000
                local iMaxZ = 0

                for iMex, tMex in tZone[subrefLZMexLocations] do
                    iMinX = math.min(tMex[1], iMinX)
                    iMaxX = math.max(tMex[1], iMaxX)
                    iMinZ = math.min(tMex[3], iMinZ)
                    iMaxZ = math.max(tMex[3], iMaxZ)
                end
                M28Utilities.DrawRectangle(Rect(iMinX, iMinZ, iMaxX, iMaxZ), iColour, 1000, 10)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DrawSpecificLandZone(iPlateau, iLandZone, iColour)
    local tLocation
    for iSegmentRef, tSegmentXZ in tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments] do
        tLocation = GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
        M28Utilities.DrawLocation(tLocation, iColour, nil, iLandZoneSegmentSize - 0.1)
    end
end

function DrawSpecificWaterZone(iWaterZone, iOptionalColour, iOptionalTime)
    local tLocation
    local iPond = tiPondByWaterZone[iWaterZone]
    local tWZData = tPondDetails[iPond][subrefPondWaterZones][iWaterZone]
    if iOptionalColour == nil then
        iOptionalColour = iWaterZone
        while iOptionalColour > 8 do
            iOptionalColour = iOptionalColour - 8
        end
        if iOptionalColour == 2 then iOptionalColour = iOptionalColour + 1 end
    end

    for iSegmentRef, tSegmentXZ in tWZData[subrefWZSegments] do
        tLocation = GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
        M28Utilities.DrawLocation(tLocation, iOptionalColour, iOptionalTime, iLandZoneSegmentSize - 0.1)
    end
    --Draw midpoint in red
    M28Utilities.DrawLocation(tWZData[subrefMidpoint], 2, iOptionalTime, iLandZoneSegmentSize - 0.05)
end

local function DrawLandZones()
    --For debug use - will draw each land zone in a plateau in a different colour to allow a visual check of how land zones have been created.  Can be called part-way through the process (e.g. to show land zones after the initial mex creation and nearby areas)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DrawLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Create fixed colours per ref
    local iUniqueColourCount = 30
    local tColourTable = M28Utilities.GenerateUniqueColourTable(iUniqueColourCount)

    --Subfunction which assigns a unique colour to each land zone
    function GetColourFromLandZoneNumber(iLandZoneRef)
        local iColour = iLandZoneRef
        while iColour >= iUniqueColourCount do
            iColour = iColour - iUniqueColourCount
        end

        return tColourTable[iColour]
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Will now draw every land zone in every plateau, cycling the colour used') end
    local tLocation, iLandZoneRef
    --Cycle through every segment on the map and draw a colour for it based on the land zone that it's part of
    for iCurSegmentX = 1, iMaxLandSegmentX do
        for iCurSegmentZ = 1, iMaxLandSegmentZ do
            iLandZoneRef = tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
            if (iLandZoneRef or 0) > 0 then
                tLocation = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                if bDebugMessages == true then LOG(sFunctionRef..': Land zone ref for segments X-Z='..iCurSegmentX..'-'..iCurSegmentZ..' = '..iLandZoneRef..'; Plataeu ref based on navutils='..NavUtils.GetTerrainLabel(refPathingTypeHover, tLocation)) end
                --M28Utilities.DrawLocation(tLocation, GetColourFromLandZoneNumber(iLandZoneRef), nil, iLandZoneSegmentSize - 0.1)
                M28Utilities.DrawLocation(tLocation, GetColourFromLandZoneNumber(iLandZoneRef), nil, iLandZoneSegmentSize - 0.1)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordMidpointAndOtherDataForZone(iPlateau, iZone, tLZData)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordMidpointAndOtherDataForZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tAverage, iAveragePlateau, iAverageLandZone

    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Considering iPlateau='..iPlateau..'; iZone='..iZone..'; Is table of mex locations empty='..tostring(M28Utilities.IsTableEmpty(tLZData[subrefLZMexLocations]))) end
    local iMinX = 100000
    local iMaxX = 0
    local iMinZ = 100000
    local iMaxZ = 0
    local iBaseIslandWanted

    local iMinSegX = 100000
    local iMaxSegX = 0
    local iMinSegZ = 100000
    local iMaxSegZ = 0
    --First record min and max segX values for the LZ
    for iSegment, tSegmentXZ in tLZData[subrefLZSegments] do
        iMinSegX = math.min(iMinSegX, tSegmentXZ[1])
        iMinSegZ = math.min(iMinSegZ, tSegmentXZ[2])
        iMaxSegX = math.max(iMaxSegX, tSegmentXZ[1])
        iMaxSegZ = math.max(iMaxSegZ, tSegmentXZ[2])
    end
    tLZData[subrefLZMinSegX] = iMinSegX
    tLZData[subrefLZMinSegZ] = iMinSegZ
    tLZData[subrefLZMaxSegX] = iMaxSegX
    tLZData[subrefLZMaxSegZ] = iMaxSegZ
    if bDebugMessages == true then LOG(sFunctionRef..': Finished recording min and max segments for Plateau '..iPlateau..' with LZ='..iZone..'; tLZData[subrefLZMinSegX]='..(tLZData[subrefLZMinSegX] or 'nil')..'; tLZData[subrefLZMinSegZ]='..(tLZData[subrefLZMinSegZ] or 'nil')..'; tLZData[subrefLZMaxSegX]='..(tLZData[subrefLZMaxSegX] or 'nil')..'; tLZData[subrefLZMaxSegZ]='..(tLZData[subrefLZMaxSegZ] or 'nil')) end


    if M28Utilities.IsTableEmpty(tLZData[subrefLZMexLocations]) == false then
        for iMex, tMex in tLZData[subrefLZMexLocations] do
            --Get min and max values for midpoint:
            iMinX = math.min(tMex[1], iMinX)
            iMaxX = math.max(tMex[1], iMaxX)
            iMinZ = math.min(tMex[3], iMinZ)
            iMaxZ = math.max(tMex[3], iMaxZ)
            if not(iBaseIslandWanted) then iBaseIslandWanted = NavUtils.GetTerrainLabel(refPathingTypeLand, tMex) end
            --Record if can build on it:
            if bDebugMessages == true then LOG(sFunctionRef..': About to check if can build on iMex='..iMex..'; tMex='..repru(tMex)..'; can we build on it='..tostring(M28Conditions.CanBuildOnMexLocation(tMex))..'; aiBrain check whether can build using brain '..(M28Overseer.tAllActiveM28Brains[1].Nickname or 'nil')..'='..tostring(M28Overseer.tAllActiveM28Brains[1]:CanBuildStructureAt('urb1103', tMex))..'; Result of is resource blocked='..tostring(M28Conditions.IsResourceBlockedByResourceBuilding(M28UnitInfo.refCategoryMex, 'urb1103', tMex))) end
            if M28Conditions.CanBuildOnMexLocation(tMex) then
                table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefMexUnbuiltLocations], tMex)
            else
                --DOuble-check - if there are no buildings in a rectangle around the mex then treat it as buildable (note - havent tested the below as added when thought were failing to record mexes on a map but it turned out to be another unrelated issue)
                local rRect = M28Utilities.GetRectAroundLocation(tMex, 0.9)
                local tUnitsByMex = GetUnitsInRect(rRect)
                local bNearbyMex = false
                if M28Utilities.IsTableEmpty(tUnitsByMex) == false then
                    local tBuildingsNearby = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tUnitsByMex)
                    if M28Utilities.IsTableEmpty(tBuildingsNearby) == false then
                        bNearbyMex = true
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Backup logic, is tUnitsByMex empty='..tostring(M28Utilities.IsTableEmpty(tUnitsByMex))..'; bNearbyMex ='..tostring(bNearbyMex)) end
                if not(bNearbyMex) then
                    table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefMexUnbuiltLocations], tMex)
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Size of mex locations for LZ='..table.getn(tLZData[subrefLZMexLocations])..'; Size of unbuilt locations='..table.getn(tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefMexUnbuiltLocations])) end
    else
        --No mexes for the plateau, so cycle through every zone and record the lowest and largest X and Z values

        --for iSegment, tSegmentXZ in tLZData[subrefLZSegments] do
        --tCurPosition = GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
        local tMinPosition = GetPositionFromPathingSegments(tLZData[subrefLZMinSegX], tLZData[subrefLZMinSegZ])
        local tMaxPosition = GetPositionFromPathingSegments(tLZData[subrefLZMaxSegX], tLZData[subrefLZMaxSegZ])
        iMinX = tMinPosition[1]
        iMinZ = tMinPosition[3]
        iMaxX = tMaxPosition[1]
        iMaxZ = tMaxPosition[3]
        for iSegment, tSegmentXZ in tLZData[subrefLZSegments] do
            if not(iBaseIslandWanted) then iBaseIslandWanted = NavUtils.GetTerrainLabel(refPathingTypeLand, GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])) end
            break
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Min and max position: iMinX='..iMinX..'; iMaxX='..iMaxX..'; iMinZ='..iMinZ..'; iMaxZ='..iMaxZ) end
    end
    tAverage = {(iMinX + iMaxX)*0.5, 0, (iMinZ + iMaxZ) * 0.5}
    iAveragePlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, tAverage)
    local iAverageIsland
    iAverageIsland = NavUtils.GetTerrainLabel(refPathingTypeLand, tAverage)


    --Move the midpoint if nav utils doesnt work for this position (to reduce the amount of grief we might have later)
    if not(iAveragePlateau == iPlateau) or not(iAverageIsland == iBaseIslandWanted) then
        local iStartSegmentX, iStartSegmentZ = GetPathingSegmentFromPosition(tAverage)
        local tAltMidpoint
        local iAdjustedSegmentX, iAdjustedSegmentZ
        local bHaveValidAltMidpoint = false
        for iAdjust = 1, 50 do
            for iXAdjust = -1, 1, 1 do
                for iZAdjust = -1, 1, 1 do
                    if not(iXAdjust == 0 and iZAdjust == 0) then
                        iAdjustedSegmentX = iStartSegmentX + iAdjust * iXAdjust
                        iAdjustedSegmentZ = iStartSegmentZ + iAdjust * iZAdjust
                        iAverageLandZone = tLandZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ]
                        if iAverageLandZone == iZone then
                            tAltMidpoint = GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering adjusted segment X-Z='..iAdjustedSegmentX..'-'..iAdjustedSegmentZ..'; with land zone '..tLandZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ]..'; tAltMidpoint='..repru(tAltMidpoint)..'; Plateau from navutils='..(NavUtils.GetTerrainLabel(refPathingTypeHover, tAltMidpoint) or 'nil')..'; Island from navutils='..(NavUtils.GetTerrainLabel(refPathingTypeLand, tAltMidpoint) or 'nil')) end
                            if NavUtils.GetTerrainLabel(refPathingTypeHover, tAltMidpoint) == iPlateau and NavUtils.GetTerrainLabel(refPathingTypeLand, tAltMidpoint) == iBaseIslandWanted then
                                bHaveValidAltMidpoint = true
                                iAveragePlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, tAltMidpoint)
                                iAverageIsland = NavUtils.GetTerrainLabel(refPathingTypeLand, tAltMidpoint)
                                tAverage = {tAltMidpoint[1], GetSurfaceHeight(tAltMidpoint[1], tAltMidpoint[3]), tAltMidpoint[3]}
                                if bDebugMessages == true then LOG(sFunctionRef..': Have valid alternative midpoint which will now record and use, tAverage after update='..repru(tAverage)) end
                                break
                            end
                        elseif bDebugMessages == true then
                            LOG(sFunctionRef..': Adjusted semgnet X-Z='..iAdjustedSegmentX..'-'..iAdjustedSegmentZ..'; didnt have the right land zone, was '..(tLandZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ] or 'nil')..'; will draw segment midpoint in red if its in playaable area')
                            local tAltLocation = GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)
                            if tAltLocation and tAltLocation[1] > rMapPotentialPlayableArea[1] and tAltLocation[1] < rMapPotentialPlayableArea[3] and tAltLocation[3] > rMapPotentialPlayableArea[2] and tAltLocation[3] < rMapPotentialPlayableArea[4] then
                                M28Utilities.DrawLocation(tAltLocation, 2)
                            end
                        end
                    end
                end
                if bHaveValidAltMidpoint then break end
            end
            if bHaveValidAltMidpoint then break end
        end

        --If still dont have a valid location, then just try any segment recorded in the land zone (this wont be in the middle of the land zone, but is better than having an unpathable midpoint)
        if not(bHaveValidAltMidpoint) then
            for iSegment, tSegmentXZ in tLZData[subrefLZSegments] do
                if tLandZoneBySegment[tSegmentXZ[1]][tSegmentXZ[2]] == iZone then
                    tAltMidpoint = GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
                    if bDebugMessages == true then LOG(sFunctionRef..': Cycling through recorded segments for this LZ, and considering segment X-Z='..tSegmentXZ[1]..'-'..tSegmentXZ[2]..'; with land zone '..tLandZoneBySegment[tSegmentXZ[1]][tSegmentXZ[2]]..'; tAltMidpoint='..repru(tAltMidpoint)..'; Plateau from navutils='..(NavUtils.GetTerrainLabel(refPathingTypeHover, tAltMidpoint) or 'nil')..'; Island from navutils='..(NavUtils.GetTerrainLabel(refPathingTypeLand, tAltMidpoint) or 'nil')) end
                    if NavUtils.GetTerrainLabel(refPathingTypeHover, tAltMidpoint) == iPlateau and NavUtils.GetTerrainLabel(refPathingTypeLand, tAltMidpoint) == iBaseIslandWanted then
                        bHaveValidAltMidpoint = true
                        iAveragePlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, tAltMidpoint)
                        iAverageIsland = NavUtils.GetTerrainLabel(refPathingTypeLand, tAltMidpoint)
                        tAverage = {tAltMidpoint[1], tAltMidpoint[2], tAltMidpoint[3]}
                        if bDebugMessages == true then LOG(sFunctionRef..': Have valid alternative midpoint which will now record and use, tAverage after update='..repru(tAverage)) end
                        break
                    end
                end
            end
        end
    end

    --Further alternative/backup (hopefully will never need to use this - this was the old backup which didnt work very well)
    if not(iAveragePlateau == iPlateau and iAverageLandZone == iZone) then
        iAveragePlateau, iAverageLandZone = GetPlateauAndLandZoneReferenceFromPosition(tAverage, false)
    end
    if (iAveragePlateau == iPlateau and iAverageLandZone == iZone) or M28Utilities.IsTableEmpty(tLZData[subrefLZMexLocations]) then
        --Either we have a valid location (in which case fine), or we have no mexes to use as a backup so will just use the midpoint (will cause some issues down the line though e.g. with the LZ not registering as being pathable to other land zones)
        tLZData[subrefMidpoint] = {tAverage[1], GetSurfaceHeight(tAverage[1], tAverage[3]), tAverage[3]}
    else
        --We have mexes so will just use one of these as the midpoint as a basic backup
        tLZData[subrefMidpoint] = {tLZData[subrefLZMexLocations][1][1], tLZData[subrefLZMexLocations][1][2], tLZData[subrefLZMexLocations][1][3]}
    end
    tLZData[refiMidpointAmphibiousLabel] = (NavUtils.GetTerrainLabel(refPathingTypeAmphibious, tLZData[subrefMidpoint]) or 0)
    if bDebugMessages == true then LOG(sFunctionRef..': Checking the midpoint is pathable by amphibious, tLZData[refiMidpointAmphibiousLabel]='..(tLZData[refiMidpointAmphibiousLabel] or 'nil')..'; Midpoint='..repru(tLZData[subrefMidpoint])) end
    if tLZData[refiMidpointAmphibiousLabel] == 0 then
        --Further redundancy - try and move the midpoint to a nearby segment to get a valid point - do by moving outwards in hollow boxes based on iAdjustBase
        local iBaseSegmentX, iBaseSegmentZ = GetPathingSegmentFromPosition(tLZData[subrefMidpoint])
        local iAdjustedSegmentX, iAdjustedSegmentZ
        local bHaveValidMidpoint
        for iAdjustBase = 1, 25 do
            for iAdjustedSegmentX = iBaseSegmentX - iAdjustBase, iBaseSegmentX + iAdjustBase, 1 do
                for iAdjustedSegmentZ = iBaseSegmentZ - iAdjustBase, iBaseSegmentZ + iAdjustBase, iAdjustBase * 2 do
                    if tLandZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ] == iZone and (NavUtils.GetTerrainLabel(refPathingTypeAmphibious, GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)) or 0) > 0 then
                        bHaveValidMidpoint = true
                        local tNewMidpoint = GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)
                        tLZData[subrefMidpoint] = {tNewMidpoint[1], tNewMidpoint[2], tNewMidpoint[3]}
                        break
                    end
                end
                if  bHaveValidMidpoint then break end
            end
            if bHaveValidMidpoint then break end
            --Then do the left and right row (excl corners which ahve already done per the above)
            for iAdjustedSegmentX = iBaseSegmentX - iAdjustBase, iBaseSegmentX + iAdjustBase, iAdjustBase * 2 do
                for iAdjustedSegmentZ = iBaseSegmentZ - iAdjustBase + 1, iBaseSegmentZ + iAdjustBase - 1, 1 do
                    if tLandZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ] == iZone and (NavUtils.GetTerrainLabel(refPathingTypeAmphibious, GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)) or 0) > 0 then
                        bHaveValidMidpoint = true
                        local tNewMidpoint = GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)
                        tLZData[subrefMidpoint] = {tNewMidpoint[1], tNewMidpoint[2], tNewMidpoint[3]}
                        break
                    end
                end
                if bHaveValidMidpoint then break end
            end
            if bHaveValidMidpoint then break end
        end
        if not(bHaveValidMidpoint) then
            --Try the first segment
            local iAdjustedSegmentX, iAdjustedSegmentZ
            for iEntry, tSegmentsXZ in tLZData[subrefLZSegments] do
                iAdjustedSegmentX = tSegmentsXZ[1]
                iAdjustedSegmentZ = tSegmentsXZ[2]
                if (NavUtils.GetTerrainLabel(refPathingTypeAmphibious, GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)) or 0) > 0 then
                    bHaveValidMidpoint = true
                    local tNewMidpoint = GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)
                    tLZData[subrefMidpoint] = {tNewMidpoint[1], tNewMidpoint[2], tNewMidpoint[3]}
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished trying to adjust midpoint to amphibious pathable location, bHaveValidMidpoint='..tostring(bHaveValidMidpoint or false)..'; tLZData[subrefMidpoint]='..repru(tLZData[subrefMidpoint])) end
    end

    if bDebugMessages == true then
        local iColour = iPlateau
        while iColour > 8 do
            iColour = iColour - 8
        end
        M28Utilities.DrawRectangle(Rect(iMinX, iMinZ, iMaxX, iMaxZ), iColour, 1000, 10)
        if iColour <= 1 then iColour = 8 end
        M28Utilities.DrawLocation(tLZData[subrefMidpoint], iColour, 1000)
        if bDebugMessages == true then LOG(sFunctionRef..': Midpoint after adjustment for iPlateau='..iPlateau..' and zone='..iZone..' = '..repru(tLZData[subrefMidpoint])..'; iBaseIslandWanted='..(iBaseIslandWanted or 'nil')..'; NavUtils result for label='..(NavUtils.GetLabel(refPathingTypeAmphibious, tLZData[subrefMidpoint]) or 'nil')) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function RecordLandZoneMidpointAndUnbuiltMexes()
    --Run at the start of the game - Cycles through each land zone, and calculates the average positio nof the mexes.  If this is in the asme land zone then records this as the midpoint, toehrwise records the first mex as the midpoint
    --Also records which mexes can be built on initially
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordLandZoneMidpointAndUnbuiltMexes'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iZone, tLZData in tAllPlateaus[iPlateau][subrefPlateauLandZones] do
            RecordMidpointAndOtherDataForZone(iPlateau, iZone, tLZData)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end



local function RecordHydroInLandZones()
    --Updates land zone data to include details of any hydro locations in the land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordHydroInLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(tHydroPoints) == false then
        local iPlateau, iLandZone

        for iHydro, tHydro in tHydroPoints do
            iPlateau, iLandZone = GetPlateauAndLandZoneReferenceFromPosition(tHydro)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iHydro='..iHydro..'; tHydro='..repru(tHydro)..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
            if iLandZone > 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Have a hydro location, CanBuildOnHydro='..tostring(M28Conditions.CanBuildOnHydroLocation(tHydro))) end
                table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefHydroLocations], tHydro)
                if M28Conditions.CanBuildOnHydroLocation(tHydro) then
                    table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefHydroUnbuiltLocations], tHydro)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function RecordHydroInWaterZones()
    --Updates land zone data to include details of any hydro locations in the land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordHydroInWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(tHydroPoints) == false then
        local iWaterZone

        for iHydro, tHydro in tHydroPoints do
            iWaterZone = GetWaterZoneFromPosition(tHydro)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iHydro='..iHydro..'; tHydro='..repru(tHydro)..'; iWaterZone='..(iWaterZone or 'nil')) end
            if iWaterZone > 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Have a hydro location, CanBuildOnHydro='..tostring(M28Conditions.CanBuildOnHydroLocation(tHydro))) end
                if not(tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone][subrefHydroLocations]) then tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone][subrefHydroLocations] = {} end
                table.insert(tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone][subrefHydroLocations], tHydro)
                if M28Conditions.CanBuildOnHydroLocation(tHydro) then
                    if not(tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone][subrefHydroUnbuiltLocations]) then tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone][subrefHydroUnbuiltLocations] = {} end
                    table.insert(tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone][subrefHydroUnbuiltLocations], tHydro)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordAdjacentLandZones()
    --Cycles through each land zone and identifies adjacent land zones
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAdjacentLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tiSegmentAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}}
    local iAltLandZone
    local iAltSegX, iAltSegZ
    local tRecordedAdjacentZones
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            tLandZoneInfo[subrefLZAdjacentLandZones] = {}
            tRecordedAdjacentZones = {}
            if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through every segment in land zone '..iLandZone..' to look for adjacent land zones, segment count='..( tLandZoneInfo[subrefLZTotalSegmentCount] or 'nil')) end
            for iSegmentRef, tSegmentXZ in tLandZoneInfo[subrefLZSegments] do
                for iSegAdjust, tSegAdjXZ in tiSegmentAdjust do
                    iAltSegX = tSegmentXZ[1] + tSegAdjXZ[1]
                    iAltSegZ = tSegmentXZ[2] + tSegAdjXZ[2]
                    iAltLandZone = tLandZoneBySegment[iAltSegX][iAltSegZ]
                    if iAltLandZone and not(iAltLandZone == iLandZone) and not(tRecordedAdjacentZones[iAltLandZone]) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Consideing tSegmentXZ='..repru(tSegmentXZ)..'; iAltSegX'..iAltSegX..'Z'..iAltSegZ..'; iAltLandZone='..iAltLandZone..'; Hover terrain label='..(NavUtils.GetTerrainLabel(refPathingTypeHover, GetPositionFromPathingSegments(iAltSegX, iAltSegZ)) or 'nil')..'; iPlateau for base seg='..iPlateau) end
                        if NavUtils.GetTerrainLabel(refPathingTypeHover, GetPositionFromPathingSegments(iAltSegX, iAltSegZ)) == iPlateau then
                            --We should have the same plateau, but double-check - do we have a land zone recorded?
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iAltLandZone='..iAltLandZone..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Is alt land zone for this plateau nil='..tostring(tAllPlateaus[iPlateau][subrefPlateauLandZones][iAltLandZone] == nil)) end
                            if tAllPlateaus[iPlateau][subrefPlateauLandZones][iAltLandZone] then
                                tRecordedAdjacentZones[iAltLandZone] = true
                                table.insert(tLandZoneInfo[subrefLZAdjacentLandZones], iAltLandZone)
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering base segment '..tSegmentXZ[1]..'-'..tSegmentXZ[2]..' at position '..repru(GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2]))..'; the adjacent segment to this, X'..iAltSegX..'Z'..iAltSegZ..' is in another land zone '..iAltLandZone..'; will record as being adjacent and draw the adjcent segment in blue')
                                    M28Utilities.DrawLocation(GetPositionFromPathingSegments(iAltSegX, iAltSegZ))
                                end
                            end
                        end
                    end
                end
            end


            if bDebugMessages == true then
                LOG(sFunctionRef..': Finished considering Plateau '..iPlateau..' LZ '..iLandZone..': subrefLZAdjacentLandZones='..repru(tLandZoneInfo[subrefLZAdjacentLandZones]))
                local iColour = 1
                DrawSpecificLandZone(iPlateau, iLandZone, iColour)
                if M28Utilities.IsTableEmpty(tLandZoneInfo[subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLandZoneInfo[subrefLZAdjacentLandZones] do
                        iColour = iColour + 1
                        if iColour > 8 then iColour = 2 end
                        DrawSpecificLandZone(iPlateau, iAdjLZ, iColour)
                    end
                end

            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordAdjacentWaterZones()
    --Cycles through each water zone and identifies adjacent water zones
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAdjacentLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tiSegmentAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}}
    local iAltWaterZone
    local iAltSegX, iAltSegZ
    local tRecordedAdjacentZones
    for iPond, tPondSubtable in tPondDetails do
        for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do

            tWZData[subrefWZAdjacentWaterZones] = {}
            tRecordedAdjacentZones = {}
            for iSegmentRef, tSegmentXZ in tWZData[subrefWZSegments] do
                for iSegAdjust, tSegAdjXZ in tiSegmentAdjust do
                    iAltSegX = tSegmentXZ[1] + tSegAdjXZ[1]
                    iAltSegZ = tSegmentXZ[2] + tSegAdjXZ[2]
                    iAltWaterZone = tWaterZoneBySegment[iAltSegX][iAltSegZ]
                    if iAltWaterZone and not(iAltWaterZone == iWaterZone) and not(tRecordedAdjacentZones[iAltWaterZone]) then
                        if tiPondByWaterZone[iAltWaterZone] == iPond then
                            tRecordedAdjacentZones[iAltWaterZone] = true
                            table.insert(tWZData[subrefWZAdjacentWaterZones], iAltWaterZone)
                        end
                    end
                end
            end

            if bDebugMessages == true then
                LOG(sFunctionRef..': Finished considering Pond '..iPond..' WZ '..iWaterZone..': subrefWZAdjacentLandZones='..repru(tWZData[subrefWZAdjacentWaterZones]))
                local iColour = 1
                DrawSpecificWaterZone(iWaterZone, iColour)
                if M28Utilities.IsTableEmpty(tWZData[subrefWZAdjacentWaterZones]) == false then
                    for _, iAdjWZ in tWZData[subrefWZAdjacentWaterZones] do
                        iColour = iColour + 1
                        if iColour > 8 then iColour = 2 end
                        DrawSpecificWaterZone(iAdjWZ, iColour)
                    end
                end

            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iPlateau, iStartLandZone, iTargetLandZone, tStart, bWillUpdateLZEntryRefLater)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderAddingTargetLandZoneToDistanceFromBaseTable'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Have we not already considered this?
    if not(tbTempConsideredLandPathingForLZ[iPlateau][iStartLandZone][iTargetLandZone]) then

        local tEnd = tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefMidpoint]
        local tFullPath, iPathSize, iDistance = NavUtils.PathTo(refPathingTypeLand, tStart, tEnd, nil)
        if bDebugMessages == true then LOG(sFunctionRef..': Have just tried to get land path from tStart='..repru(tStart)..' to tEnd='..repru(tEnd)..'; iStartLandZone='..iStartLandZone..'; iTargetLandZone='..iTargetLandZone..'; tFullPath='..repru(tFullPath)..'; iPathSize='..iPathSize..'; will draw midpoint of the target LZ, and draw the start point, in blue')
            M28Utilities.DrawLocation(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefMidpoint])
            M28Utilities.DrawLocation(tStart)
        end

        if tFullPath then
            local iPathingPlateau, iPathingLandZone
            local tPathingLZConsidered = {}
            local tPathingLZFromStartToTarget = {}


            local iTravelDistance = 0
            tFullPath[0] = tStart
            tFullPath[iPathSize + 1] = tEnd
            for iPath = 1, iPathSize + 1 do
                iTravelDistance = iTravelDistance + VDist2(tFullPath[iPath - 1][1], tFullPath[iPath - 1][3], tFullPath[iPath][1], tFullPath[iPath][3])
                iPathingPlateau, iPathingLandZone = GetPlateauAndLandZoneReferenceFromPosition(tFullPath[iPath])
                if iPathingLandZone > 0 then
                    if not(tPathingLZConsidered[iPathingLandZone]) and not(iStartLandZone == iPathingLandZone) then
                        tPathingLZConsidered[iPathingLandZone] = true
                        table.insert(tPathingLZFromStartToTarget, iPathingLandZone)
                    end
                end
            end
            if not(tPathingLZConsidered[iTargetLandZone]) then
                table.insert(tPathingLZFromStartToTarget, iPathingLandZone)
                tPathingLZConsidered[iTargetLandZone] = true
            end
            --Record the travel distance
            if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZTravelDistToOtherLandZones][iPlateau]) then tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZTravelDistToOtherLandZones][iPlateau] = {} end
            tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZTravelDistToOtherLandZones][iPlateau][iStartLandZone] = iTravelDistance
            if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZTravelDistToOtherLandZones][iPlateau]) then tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZTravelDistToOtherLandZones][iPlateau] = {} end
            tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZTravelDistToOtherLandZones][iPlateau][iTargetLandZone] = iTravelDistance

            if bDebugMessages == true then
                LOG(sFunctionRef..': Travel distance to iTargetLandZone '..iTargetLandZone..' from '..iStartLandZone..' = '..iTravelDistance..'; tPathingLZConsidered='..repru(tPathingLZConsidered)..'; will draw path between LZs')
                M28Utilities.DrawPath(tFullPath, 1)
            end

            --Get position in new table
            local iPosition = 1
            if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones]) then
                tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones] = {}
                tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLZEntryRef] = {}
                iPosition = 1
            else
                for iExistingLandZone, tExistingSubtable in tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones] do
                    if tExistingSubtable[subrefLZTravelDist] <  iTravelDistance then
                        iPosition = iPosition + 1
                    else
                        break
                    end
                end
            end

            local iOppositePosition = 1
            if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones]) then
                tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones] = {}
                tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLZEntryRef] = {}
                iOppositePosition = 1
            else
                for iExistingLandZone, tExistingSubtable in tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones] do
                    if tExistingSubtable[subrefLZTravelDist] <  iTravelDistance then
                        iOppositePosition = iOppositePosition + 1
                    else
                        break
                    end
                end
            end

            table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones], iPosition, {[subrefLZNumber] = iTargetLandZone, [subrefLZPath] = {}, [subrefLZTravelDist] = iTravelDistance})
            table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones], iOppositePosition, {[subrefLZNumber] = iStartLandZone, [subrefLZPath] = {}, [subrefLZTravelDist] = iTravelDistance})

            --Will update subrefLZPathingToOtherLZEntryRef in UpdateLZPathingEntryReferences, as we need to do this for iOppositePositon once we have finished adding all oppositepositions or it will end up out of order

            --Record the land zone path from start to target
            for iEntry, iLZ in tPathingLZFromStartToTarget do
                table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones][iPosition][subrefLZPath], iLZ)
            end
            --Record the land zone path from target to start (adding in the start as the final point)
            local iTotalEntries = table.getn(tPathingLZFromStartToTarget)
            for iEntry = iTotalEntries, 1, -1 do
                if not(tPathingLZFromStartToTarget[iEntry] == iTargetLandZone) then
                    table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones][iOppositePosition][subrefLZPath], tPathingLZFromStartToTarget[iEntry])
                end
            end
            if not(tPathingLZFromStartToTarget[1] == iStartLandZone) then
                table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones][iOppositePosition][subrefLZPath], iStartLandZone)
            end

            --Record that we have considered the pathing between these two points
            if not(tbTempConsideredLandPathingForLZ[iPlateau]) then tbTempConsideredLandPathingForLZ[iPlateau] = {} end
            if not(tbTempConsideredLandPathingForLZ[iPlateau][iStartLandZone]) then tbTempConsideredLandPathingForLZ[iPlateau][iStartLandZone] = {} end
            if not(tbTempConsideredLandPathingForLZ[iPlateau][iTargetLandZone]) then tbTempConsideredLandPathingForLZ[iPlateau][iTargetLandZone] = {} end
            tbTempConsideredLandPathingForLZ[iPlateau][iStartLandZone][iTargetLandZone] = true
            tbTempConsideredLandPathingForLZ[iPlateau][iTargetLandZone][iStartLandZone] = true

            if bDebugMessages == true then LOG(sFunctionRef..': Path for goign the opposite direction='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones][iOppositePosition][subrefLZPath])..'; path for going the normal direction='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones][iPosition][subrefLZPath])..'; iPosition='..iPosition..'; iOppositePosition='..iOppositePosition) end

        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finsihed recording for iPlateau='..iPlateau..'; iStartLandZone='..iStartLandZone..'; subrefLZPathingToOtherLandZones='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones])..'; will now do repru of the target land zone pathing to other land zones='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones])) end
        if not(bWillUpdateLZEntryRefLater) then
            UpdateLZPathingEntryReferences(iPlateau, iStartLandZone)
            UpdateLZPathingEntryReferences(iPlateau, iTargetLandZone)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function RecordMaxAdjacencyTravelDistance()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordMaxAdjacencyTravelDistance'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iMaxAdjacentDistance
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            if M28Utilities.IsTableEmpty(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZAdjacentLandZones]) == false then
                iMaxAdjacentDistance = 0
                for _, iAdjLZ in tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZAdjacentLandZones] do
                    iMaxAdjacentDistance = math.max(iMaxAdjacentDistance, (tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTravelDistToOtherLandZones][iPlateau][iAdjLZ] or 0))
                end

                tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZFurthestAdjacentLandZoneTravelDist] = iMaxAdjacentDistance
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateLZPathingEntryReferences(iPlateau, iLandZone)
    local tLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
    if M28Utilities.IsTableEmpty(tLZData[subrefLZPathingToOtherLandZones]) == false then
        local iCurCount = 0
        for iEntry, tPathData in tLZData[subrefLZPathingToOtherLandZones] do
            iCurCount = iCurCount + 1
            tLZData[subrefLZPathingToOtherLZEntryRef][tPathData[subrefLZNumber]] = iCurCount
        end
    end
end

local function RecordPathingBetweenZones()
    --For each zone that is where a player starts, record pathing to every other zone; for other zones, record pathing to up to 3 layers of adjacency
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordPathingBetweenZones'

    WaitTicks(1) --To ensure all brains will be setup
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    for iCurPlateau, tPlateauSubtable in tAllPlateaus do
        for iCurLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iCurLandZone='..iCurLandZone..' for plateau '..iCurPlateau..'; will go through every other LZ in the plateau and consider adding to the table of other land zones near this') end
            local tStartPoint = tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iCurLandZone][subrefMidpoint]
            for iTargetLandZone, tTargetLZInfo in tPlateauSubtable[subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Will consider iTargetLandZone='..iTargetLandZone..' for starting LZ '..iCurLandZone) end
                if not(iTargetLandZone == iCurLandZone) then
                    ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iCurPlateau, iCurLandZone, iTargetLandZone, tStartPoint, true)
                end
            end
        end
        --Now record the entry refs
        local iCurCount
        for iCurLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            UpdateLZPathingEntryReferences(iCurPlateau, iCurLandZone)
        end
    end
    --Record max adjacency distance
    RecordMaxAdjacencyTravelDistance()


    --[[
local tiPlateauLandZoneStartPoints = {}
local iCurPlateau, iCurLandZone
for iStart, tPlayerStart in PlayerStartPoints do
    iCurPlateau, iCurLandZone = GetPlateauAndLandZoneReferenceFromPosition(tPlayerStart)
    if (iCurLandZone or 0) > 0 then
        if not(tiPlateauLandZoneStartPoints[iCurPlateau]) then tiPlateauLandZoneStartPoints[iCurPlateau] = {} end
        tiPlateauLandZoneStartPoints[iCurPlateau][iCurLandZone] = true
        local tStartPoint = tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iCurLandZone][subrefMidpoint]

        --Consider all land zones in this plateau for start positions
        for iTargetLandZone, tTargetLandZoneInfo in tAllPlateaus[iCurPlateau][subrefPlateauLandZones] do
            if not(iTargetLandZone == iCurLandZone) then
                ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iCurPlateau, iCurLandZone, iTargetLandZone, tStartPoint)
            end
        end
    end
end

--Consider adjacent locations for non-core
for iCurPlateau, tPlateauSubtable in tAllPlateaus do
    for iCurLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
        if not(tiPlateauLandZoneStartPoints[iCurPlateau][iCurLandZone]) then
            local tiAdjacentLandZonesToConsider = {}
            if M28Utilities.IsTableEmpty(tLandZoneInfo[subrefLZAdjacentLandZones]) == false then
                for _, iAdjLZ1 in tLandZoneInfo[subrefLZAdjacentLandZones] do
                    if M28Utilities.IsTableEmpty(tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iAdjLZ1][subrefLZAdjacentLandZones]) == false then
                        for _, iAdjLZ2 in tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iAdjLZ1][subrefLZAdjacentLandZones] do
                            if M28Utilities.IsTableEmpty(tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iAdjLZ2][subrefLZAdjacentLandZones]) == false then
                                for _, iAdjLZ3 in tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iAdjLZ2][subrefLZAdjacentLandZones] do
                                    if not(tiAdjacentLandZonesToConsider[iAdjLZ3]) then tiAdjacentLandZonesToConsider[iAdjLZ3] = true end
                                end
                            end
                            if not(tiAdjacentLandZonesToConsider[iAdjLZ2]) then tiAdjacentLandZonesToConsider[iAdjLZ2] = true end
                        end
                    end
                    if not(tiAdjacentLandZonesToConsider[iAdjLZ1]) then tiAdjacentLandZonesToConsider[iAdjLZ1] = true end
                end
                local tStartPoint = tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iCurLandZone][subrefMidpoint]
                for iAdjLandZone, _ in tiAdjacentLandZonesToConsider do
                    if not(iAdjLandZone == iCurLandZone) then
                        ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iCurPlateau, iCurLandZone, iAdjLandZone, tStartPoint)
                    end
                end
            end
        end
    end
end--]]
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function RecordTravelDistBetweenZonesOverTime()
    --Record how  long it would take to travel between each other land zone upfront so dont have to calculate on the fly
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordTravelDistBetweenZonesOverTime'
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iCurCount = 0
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iStartLZ, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            if bDebugMessages == true then LOG(sFunctionRef..': About to consider all other land zones in plateau '..iPlateau..' for iStartLZ='..iStartLZ) end
            for iEndLZ,  tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iEndLZ='..iEndLZ) end
                if not(iStartLZ == iEndLZ) then
                    iCurCount = iCurCount + 1
                    if iCurCount >= 10 then
                        iCurCount = 0
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    end

                    GetTravelDistanceBetweenLandZones(iPlateau, iStartLZ, iEndLZ)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordClosestAllyAndEnemyBaseForEachLandZone(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordClosestAllyAndEnemyBaseForEachLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    while not(bMapLandSetupComplete) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    local tEnemyBases = {}
    local tAllyBases = {}
    local tBrainsByIndex = {}

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains]) == false then
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
            tEnemyBases[oBrain:GetArmyIndex()] = PlayerStartPoints[oBrain:GetArmyIndex()]
            tBrainsByIndex[oBrain:GetArmyIndex()] = oBrain
        end
    end
    function IsInPlayableArea(tLocation)
        if tLocation[1] >= rMapPlayableArea[1] and tLocation[1] <= rMapPlayableArea[3] and tLocation[2] >= rMapPlayableArea[2] and tLocation[4] <= rMapPlayableArea[4] then
            return true
        end
        return false
    end
    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveBrains] do
        if bDebugMessages == true then LOG(sFunctionRef..': Cycling through friedly active brains in iTeam='..iTeam..'; oBrain.Nickname='..(oBrain.Nickname or 'nil')..' with start position '..repru(PlayerStartPoints[oBrain:GetArmyIndex()])..'; bIsCampaignMap='..tostring(bIsCampaignMap)..'; Land result for brain start='..(NavUtils.GetTerrainLabel(refPathingTypeLand, PlayerStartPoints[oBrain:GetArmyIndex()]) or 'nil')..'; Brain type='..(oBrain.BrainType or 'nil')..'; Playable area='..repru(rMapPlayableArea)) end
        --Campaign specific - check this is on a valid land zone
        if not(bIsCampaignMap) or not(oBrain.BrainType == "AI") or oBrain.M28AI or ((NavUtils.GetTerrainLabel(refPathingTypeLand, PlayerStartPoints[oBrain:GetArmyIndex()]) or 0) > 0 and IsInPlayableArea(PlayerStartPoints[oBrain:GetArmyIndex()])) then
            tAllyBases[oBrain:GetArmyIndex()] = PlayerStartPoints[oBrain:GetArmyIndex()]
            tBrainsByIndex[oBrain:GetArmyIndex()] = oBrain
        end
    end

    if M28Utilities.IsTableEmpty(tEnemyBases) then
        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        if aiBrain then
            table.insert(tEnemyBases, GetPrimaryEnemyBaseLocation(aiBrain))
        end
    end

    local iCurBrainDist
    local iClosestBrainDist
    local iClosestBrainRef
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLZData in tPlateauSubtable[subrefPlateauLandZones] do
            iClosestBrainDist = 100000
            for iBrain, tStartPoint in tAllyBases do
                iCurBrainDist = M28Utilities.GetDistanceBetweenPositions(tLZData[subrefMidpoint], tStartPoint)
                if iCurBrainDist < iClosestBrainDist then
                    iClosestBrainRef = iBrain
                    iClosestBrainDist = iCurBrainDist
                end
            end
            local tLZTeamData = tLZData[subrefLZTeamData][iTeam]
            tLZTeamData[reftClosestFriendlyBase] = {PlayerStartPoints[iClosestBrainRef][1], PlayerStartPoints[iClosestBrainRef][2], PlayerStartPoints[iClosestBrainRef][3]}
            tLZTeamData[reftClosestEnemyBase] = GetPrimaryEnemyBaseLocation(tBrainsByIndex[iClosestBrainRef])
            tLZTeamData[refiModDistancePercent] = GetModDistanceFromStart(tBrainsByIndex[iClosestBrainRef], tLZData[subrefMidpoint], false) /  math.max(1, GetModDistanceFromStart(tBrainsByIndex[iClosestBrainRef], tLZTeamData[reftClosestEnemyBase]))
            if bDebugMessages == true then LOG(sFunctionRef..': Have recorded closest enemy base for iPlateau '..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; tLZTeamData[reftClosestFriendlyBase]='..repru(tLZTeamData[reftClosestFriendlyBase])..'; repru(tLZTeamData[reftClosestEnemyBase])='..repru(tLZTeamData[reftClosestEnemyBase])..'; iClosestBrainRef='..iClosestBrainRef..'; tBrainsByIndex[iClosestBrainRef].Nickname='..tBrainsByIndex[iClosestBrainRef].Nickname..'; aiBrain[reftPrimaryEnemyBaseLocation] for this brain='..repru(tBrainsByIndex[iClosestBrainRef][reftPrimaryEnemyBaseLocation])) end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordClosestAllyAndEnemyBaseForEachWaterZone(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordClosestAllyAndEnemyBaseForEachWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then

        while not(bWaterZoneInitialCreation) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if GetGameTimeSeconds() >= 5 then break end
        end

        local tEnemyBases = {}
        local tAllyBases = {}
        local tBrainsByIndex = {}

        local iCurBrainDist
        local iClosestBrainDist
        local iClosestBrainRef

        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains]) == false then
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
                tEnemyBases[oBrain:GetArmyIndex()] = PlayerStartPoints[oBrain:GetArmyIndex()]
                tBrainsByIndex[oBrain:GetArmyIndex()] = oBrain
            end
        end
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveBrains] do
            if bDebugMessages == true then LOG(sFunctionRef..': Cycling through friedly active brains in iTeam='..iTeam..'; oBrain.Nickname='..(oBrain.Nickname or 'nil')..' with start position '..repru(PlayerStartPoints[oBrain:GetArmyIndex()])..'; bIsCampaignMap='..tostring(bIsCampaignMap)..'; Navy result for brain start='..(NavUtils.GetTerrainLabel(refPathingTypeNavy, PlayerStartPoints[oBrain:GetArmyIndex()]) or 'nil')..'; Brain type='..(oBrain.BrainType or 'nil')..'; Playable area='..repru(rMapPlayableArea)) end
            --Campaign specific - check this is on a valid land zone
            if not(bIsCampaignMap) or not(oBrain.BrainType == "AI") or oBrain.M28AI or ((NavUtils.GetTerrainLabel(refPathingTypeNavy, PlayerStartPoints[oBrain:GetArmyIndex()]) or 0) > 0 and IsInPlayableArea(PlayerStartPoints[oBrain:GetArmyIndex()])) then
                tAllyBases[oBrain:GetArmyIndex()] = PlayerStartPoints[oBrain:GetArmyIndex()]
                tBrainsByIndex[oBrain:GetArmyIndex()] = oBrain
            end
        end

        if M28Utilities.IsTableEmpty(tEnemyBases) then
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            if aiBrain then

                table.insert(tEnemyBases, GetPrimaryEnemyBaseLocation(aiBrain))
            end
        end

        --Update water zones
        if bDebugMessages == true then LOG(sFunctionRef..': About to start with updating water zone information, GameTime='..GetGameTimeSeconds()..'; bMapLandSetupComplete='..tostring(bMapLandSetupComplete or false)..'; bHaveConsideredPreferredPondForM28AI='..tostring(bHaveConsideredPreferredPondForM28AI or false)) end
        for iPond, tPondSubtable in tPondDetails do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iPond='..iPond) end
            for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
                if not(tWZData[subrefWZTeamData]) then tWZData[subrefWZTeamData] = {} end
                if not(tWZData[subrefWZTeamData][iTeam]) then tWZData[subrefWZTeamData][iTeam] = {} end
                local tWZTeamData = tWZData[subrefWZTeamData][iTeam]

                iClosestBrainDist = 100000
                for iBrain, tStartPoint in tAllyBases do
                    iCurBrainDist = M28Utilities.GetDistanceBetweenPositions(tWZData[subrefMidpoint], tStartPoint)
                    if iCurBrainDist < iClosestBrainDist then
                        iClosestBrainRef = iBrain
                        iClosestBrainDist = iCurBrainDist
                    end
                end

                tWZTeamData[reftClosestFriendlyBase] = {PlayerStartPoints[iClosestBrainRef][1], PlayerStartPoints[iClosestBrainRef][2], PlayerStartPoints[iClosestBrainRef][3]}
                if bDebugMessages == true then LOG(sFunctionRef..': Recorded closest friendly base '..repru(tWZTeamData[reftClosestFriendlyBase])..' for iWaterZone='..iWaterZone..'; iPond='..iPond) end
                tWZTeamData[reftClosestEnemyBase] = GetPrimaryEnemyBaseLocation(tBrainsByIndex[iClosestBrainRef])
                tWZTeamData[refiModDistancePercent] = GetModDistanceFromStart(tBrainsByIndex[iClosestBrainRef], tWZData[subrefMidpoint], false) / math.max(1, GetModDistanceFromStart(tBrainsByIndex[iClosestBrainRef], tWZTeamData[reftClosestEnemyBase]))

            end
        end
        ForkThread(M28Team.WaterZoneTeamInitialisation, iTeam)
    else
        M28Utilities.ErrorHandler('No M28 active brain')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ReturnNthValidLocationInSameLandZoneClosestToTarget(iPlateau, iLandZoneWanted, tStartLZData, tTargetDestination, iDistanceInterval, iNthEntryWanted, iMaxDistance)
    local iSearchDistance = 0
    local tValidLocations = {}
    local iValidLocationCount = 0
    local iAngleToTarget = M28Utilities.GetAngleFromAToB(tStartLZData[subrefMidpoint], tTargetDestination)
    local iFailureCount = 0 --After 5 failures in a row will abort
    local iCurPlateau, iCurLandZone
    if iDistanceInterval < 0 then M28Utilities.ErrorHandler('Likely infinite loop as have negative distance interval') end

    while iSearchDistance <= (iMaxDistance or 150) do
        iSearchDistance = iSearchDistance + iDistanceInterval
        local tPotentialLocation = M28Utilities.MoveInDirection(tStartLZData[subrefMidpoint], iAngleToTarget, iSearchDistance, true, false, false)
        iCurPlateau, iCurLandZone = GetPlateauAndLandZoneReferenceFromPosition(tPotentialLocation)
        if iCurPlateau == iPlateau and iCurLandZone == iLandZoneWanted then
            iValidLocationCount = iValidLocationCount + 1
            tValidLocations[iValidLocationCount] = {tPotentialLocation[1], tPotentialLocation[2], tPotentialLocation[3]}
            iFailureCount = 0
        else
            iFailureCount = iFailureCount + 1
            if iFailureCount >= 5 then break end
        end
    end
    if iValidLocationCount > 0 then
        if iValidLocationCount <= iNthEntryWanted then return tValidLocations[iValidLocationCount]
        else return tValidLocations[iValidLocationCount - iNthEntryWanted]
        end
    else
        return nil
    end
end

function ReturnNthValidLocationInSameWaterZoneClosestToTarget(iPond, iWaterZoneWanted, tStartWZData, tTargetDestination, iDistanceInterval, iNthEntryWanted, iMaxDistance)
    local iSearchDistance = 0
    local tValidLocations = {}
    local iValidLocationCount = 0
    local iAngleToTarget = M28Utilities.GetAngleFromAToB(tStartWZData[subrefMidpoint], tTargetDestination)
    local iFailureCount = 0 --After 5 failures in a row will abort
    local iCurPond, iCurWaterZone
    if iDistanceInterval < 0 then M28Utilities.ErrorHandler('Likely infinite loop as have negative distance interval') end

    while iSearchDistance <= (iMaxDistance or 150) do
        iSearchDistance = iSearchDistance + iDistanceInterval
        local tPotentialLocation = M28Utilities.MoveInDirection(tStartWZData[subrefMidpoint], iAngleToTarget, iSearchDistance, true, false, false)
        iCurWaterZone = GetWaterZoneFromPosition(tPotentialLocation)
        iCurPond = tiPondByWaterZone[iCurWaterZone]
        if iCurPond == iPond and iCurWaterZone == iWaterZoneWanted then
            iValidLocationCount = iValidLocationCount + 1
            tValidLocations[iValidLocationCount] = {tPotentialLocation[1], tPotentialLocation[2], tPotentialLocation[3]}
            iFailureCount = 0
        else
            iFailureCount = iFailureCount + 1
            if iFailureCount >= 5 then break end
        end
    end
    if iValidLocationCount > 0 then
        if iValidLocationCount <= iNthEntryWanted then return tValidLocations[iValidLocationCount]
        else return tValidLocations[iValidLocationCount - iNthEntryWanted]
        end
    else
        return nil
    end
end

function ReorderPathBasedOnAngleToFirstEntry(tUnorderedPatrolPaths, tFirstPointInPath, bAddFirstPoint)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReorderPathBasedOnDistanceToFirstEntry'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tReorderedPositions = {}
    if bAddFirstPoint then
        table.insert(tReorderedPositions, {tFirstPointInPath[1], tFirstPointInPath[2], tFirstPointInPath[3]})
    end
    if M28Utilities.IsTableEmpty(tUnorderedPatrolPaths) == false then

        local iCurAngleFromFirstPosition
        local iClosestAngleDifFromLast
        local iClosestDistRef
        local tCurStartPoint = {tFirstPointInPath[1], tFirstPointInPath[2], tFirstPointInPath[3]}
        local iLoopCount = 0

        local iMaxLoop = table.getn(tUnorderedPatrolPaths) + 2
        if bDebugMessages == true then LOG(sFunctionRef..': About to order paths, tUnorderedPatrolPaths='..repru(tUnorderedPatrolPaths)..'; tFirstPointInPath='..repru(tFirstPointInPath)..'; bAddFirstPoint='..tostring(bAddFirstPoint or false)) end

        --First get closest point to the start
        local iClosestDistToStart = 10000
        local iCurDistToStart
        local iCurAngleDif
        for iEntry, tPosition in tUnorderedPatrolPaths do
            iCurDistToStart = M28Utilities.GetDistanceBetweenPositions(tCurStartPoint, tPosition)
            if iCurDistToStart < iClosestDistToStart then
                iClosestDistToStart = iCurDistToStart
                iClosestDistRef = iEntry
            end
        end
        local iLastAngleUsed = M28Utilities.GetAngleFromAToB(tCurStartPoint, tUnorderedPatrolPaths[iClosestDistRef])
        table.insert(tReorderedPositions, {tUnorderedPatrolPaths[iClosestDistRef][1], tUnorderedPatrolPaths[iClosestDistRef][2], tUnorderedPatrolPaths[iClosestDistRef][3]})
        if bDebugMessages == true then LOG(sFunctionRef..': Angle from tCurStartPoint '..repru(tCurStartPoint)..' to first point after this, '..repru(tUnorderedPatrolPaths[iClosestDistRef])..' is '..iLastAngleUsed) end
        table.remove(tUnorderedPatrolPaths, iClosestDistRef)


        while M28Utilities.IsTableEmpty(tUnorderedPatrolPaths) == false do
            iLoopCount = 1
            iClosestAngleDifFromLast = 10000
            for iEntry, tPosition in tUnorderedPatrolPaths do
                iCurAngleFromFirstPosition = M28Utilities.GetAngleFromAToB(tCurStartPoint, tPosition)
                iCurAngleDif = M28Utilities.GetAngleDifference(iCurAngleFromFirstPosition, iLastAngleUsed)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering tPosition='..repru(tPosition)..'; Angle from start to here='..iCurAngleFromFirstPosition..'; Angle dif to last angle='..M28Utilities.GetAngleDifference(iCurAngleFromFirstPosition, iLastAngleUsed)) end
                if iCurAngleDif < iClosestAngleDifFromLast then
                    iClosestAngleDifFromLast = iCurAngleDif
                    iClosestDistRef = iEntry
                end
            end
            iLastAngleUsed = M28Utilities.GetAngleFromAToB(tCurStartPoint, tUnorderedPatrolPaths[iClosestDistRef])
            table.insert(tReorderedPositions, {tUnorderedPatrolPaths[iClosestDistRef][1], tUnorderedPatrolPaths[iClosestDistRef][2], tUnorderedPatrolPaths[iClosestDistRef][3]})
            if bDebugMessages == true then LOG(sFunctionRef..': Best location='..repru(tUnorderedPatrolPaths[iClosestDistRef])..'; iLastAngleUsed='..iLastAngleUsed) end
            table.remove(tUnorderedPatrolPaths, iClosestDistRef)
            if iLoopCount > iMaxLoop then M28Utilities.ErrorHandler('Infinite loop') break end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished reordering path, tReorderedPositions='..repru(tReorderedPositions)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tReorderedPositions
end

function ReorderPathBasedOnDistanceToFirstEntry(tUnorderedPatrolPaths, tFirstPointInPath, bAddFirstPoint)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReorderPathBasedOnDistanceToFirstEntry'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tReorderedPositions = {}
    if bAddFirstPoint then
        table.insert(tReorderedPositions, {tFirstPointInPath[1], tFirstPointInPath[2], tFirstPointInPath[3]})
    end

    local iCurDistToStart
    local iClosestDistToStart
    local iClosestDistRef
    local tCurStartPoint = {tFirstPointInPath[1], tFirstPointInPath[2], tFirstPointInPath[3]}
    local iLoopCount = 0
    local iMaxLoop = table.getn(tUnorderedPatrolPaths) + 2
    if bDebugMessages == true then LOG(sFunctionRef..': About to order paths, tUnorderedPatrolPaths='..repru(tUnorderedPatrolPaths)..'; tFirstPointInPath='..repru(tFirstPointInPath)..'; bAddFirstPoint='..tostring(bAddFirstPoint or false)) end

    while M28Utilities.IsTableEmpty(tUnorderedPatrolPaths) == false do
        iLoopCount = 1
        iClosestDistToStart = 10000
        for iEntry, tPosition in tUnorderedPatrolPaths do
            iCurDistToStart = M28Utilities.GetDistanceBetweenPositions(tCurStartPoint, tPosition)
            if iCurDistToStart < iClosestDistToStart then
                iClosestDistToStart = iCurDistToStart
                iClosestDistRef = iEntry
            end
        end
        table.insert(tReorderedPositions, {tUnorderedPatrolPaths[iClosestDistRef][1], tUnorderedPatrolPaths[iClosestDistRef][2], tUnorderedPatrolPaths[iClosestDistRef][3]})
        tCurStartPoint = {tUnorderedPatrolPaths[iClosestDistRef][1], tUnorderedPatrolPaths[iClosestDistRef][2], tUnorderedPatrolPaths[iClosestDistRef][3]}
        table.remove(tUnorderedPatrolPaths, iClosestDistRef)
        if iLoopCount > iMaxLoop then M28Utilities.ErrorHandler('Infinite loop') break end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished reordering path, tReorderedPositions='..repru(tReorderedPositions)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tReorderedPositions
end

function RecordLandZonePatrolPaths()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordLandZonePatrolPaths'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLZSubtable in tPlateauSubtable[subrefPlateauLandZones] do
            --Are we interested in patrolling this land zone? Want to ignore very small land zones
            if bDebugMessages == true then LOG(sFunctionRef..': Start of loop, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; tLZSubtable[subrefLZMexCount]='..(tLZSubtable[subrefLZMexCount] or 'nil')..'; tLZSubtable[subrefLZTotalSegmentCount]='..(tLZSubtable[subrefLZTotalSegmentCount] or 'nil')) end
            if tLZSubtable[subrefLZMexCount] > 0 or tLZSubtable[subrefLZTotalSegmentCount] >= 40 then

                --First travel towards adjacent locations an add these
                local tUnorderedPatrolPaths = {}
                local tAnglesCovered = {}

                if M28Utilities.IsTableEmpty(tLZSubtable[subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZSubtable[subrefLZAdjacentLandZones] do
                        if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iAdjLZ='..iAdjLZ..'; LZ midpoint='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iAdjLZ][subrefMidpoint])) end
                        local tPotentialLocation = ReturnNthValidLocationInSameLandZoneClosestToTarget(iPlateau, iLandZone, tLZSubtable, tAllPlateaus[iPlateau][subrefPlateauLandZones][iAdjLZ][subrefMidpoint], 4, 3, 100)
                        if tPotentialLocation then
                            table.insert(tUnorderedPatrolPaths, tPotentialLocation)
                            table.insert(tAnglesCovered, M28Utilities.GetAngleFromAToB(tLZSubtable[subrefMidpoint], tPotentialLocation))
                        end
                    end
                end
                --Identify any gaps in the path if we arent near the edge of the map
                local tbBaseAngleCovered = {}
                local iDistThreshold = 90
                if tLZSubtable[subrefMidpoint][3] >= rMapPotentialPlayableArea[2] + iDistThreshold then
                    --Arent close to the top of the map so can look north
                    tbBaseAngleCovered[0] = false
                end
                if tLZSubtable[subrefMidpoint][1] <= rMapPotentialPlayableArea[3] - iDistThreshold then
                    --Arent close to the rh of the map so can look east
                    tbBaseAngleCovered[90] = false
                end
                if tLZSubtable[subrefMidpoint][3] <= rMapPotentialPlayableArea[4] - iDistThreshold then
                    --Arent close to the bottom of the map so can look south
                    tbBaseAngleCovered[180] = false
                end
                if tLZSubtable[subrefMidpoint][1] >= rMapPotentialPlayableArea[1] + iDistThreshold then
                    --Aren't close to left hand part of map so can look west
                    tbBaseAngleCovered[270] = false
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLZ='..iLandZone..'; tAnglesCovered='..repru(tAnglesCovered)..'; Midpoint='..repru(tLZSubtable[subrefMidpoint])..'; playable area='..repru(rMapPotentialPlayableArea)..'; iDistThreshold='..iDistThreshold..'; tbBaseAngleCovered before factoring in angles covered='..repru(tbBaseAngleCovered)) end

                if M28Utilities.IsTableEmpty(tAnglesCovered) == false then

                    for _, iAngle in tAnglesCovered do
                        for iBaseAngle, bCovered in tbBaseAngleCovered do
                            if not(bCovered) then
                                if M28Utilities.GetAngleDifference(iBaseAngle, iAngle) <= 45 then
                                    tbBaseAngleCovered[iBaseAngle] = true
                                end
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': tbBaseAngleCovered='..repru(tbBaseAngleCovered)) end
                for iBaseAngle, bCovered in tbBaseAngleCovered do
                    if not(bCovered) then
                        local tPotentialLocation = ReturnNthValidLocationInSameLandZoneClosestToTarget(iPlateau, iLandZone, tLZSubtable, M28Utilities.MoveInDirection(tLZSubtable[subrefMidpoint], iBaseAngle, iDistThreshold, false, false, false), 4, 3, 70)
                        if tPotentialLocation then
                            table.insert(tUnorderedPatrolPaths, tPotentialLocation)
                        end
                    end
                end


                --Order the path based on distance, and add the midpoint of the land zone
                --Originally did based on distance, but based on angle looks slightly better
                --tLZSubtable[subreftPatrolPath] = ReorderPathBasedOnDistanceToFirstEntry(tUnorderedPatrolPaths, {tLZSubtable[subrefMidpoint][1] + 3, tLZSubtable[subrefMidpoint][2], tLZSubtable[subrefMidpoint][3] + 3}, true)
                tLZSubtable[subreftPatrolPath] = ReorderPathBasedOnAngleToFirstEntry(tUnorderedPatrolPaths, {tLZSubtable[subrefMidpoint][1] + 3, tLZSubtable[subrefMidpoint][2], tLZSubtable[subrefMidpoint][3] + 3}, true)

                if bDebugMessages == true then
                    LOG(sFunctionRef..': Finished recording patrol path for plateau '..iPlateau..'; Land zone ='..iLandZone..'; Patrol path='..repru(tLZSubtable[subreftPatrolPath]))
                    M28Utilities.DrawLocation(tLZSubtable[subrefMidpoint])
                    if M28Utilities.IsTableEmpty(tLZSubtable[subreftPatrolPath]) == false then
                        M28Utilities.DrawPath(tLZSubtable[subreftPatrolPath], 5, nil)
                    end

                end
            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordWaterZonePatrolPaths()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordWaterZonePatrolPaths'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    for iPond, tPondSubtable in tPondDetails do
        for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
            --Are we interested in patrolling this water zone? Want to ignore very small water zones
            if table.getn(tWZData[subrefWZSegments]) >= 40 then

                --First travel towards adjacent locations an add these
                local tUnorderedPatrolPaths = {}
                local tAnglesCovered = {}

                if M28Utilities.IsTableEmpty(tWZData[subrefWZOtherWaterZones]) == false then
                    for iEntry, iAltWZ in tWZData[subrefWZAdjacentWaterZones] do
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Will draw midpoint of the current water zone in gold and the target in light blue; this waterzone midpoint='..repru(tWZData[subrefMidpoint])..'; Target WZ iAltWZ '..iAltWZ..'='..repru(tPondDetails[iPond][subrefPondWaterZones][iAltWZ][subrefMidpoint]))
                            M28Utilities.DrawLocation(tWZData[subrefMidpoint], 4)
                            M28Utilities.DrawLocation(tPondDetails[iPond][subrefPondWaterZones][iAltWZ][subrefMidpoint], 5)
                        end
                        local tPotentialLocation = ReturnNthValidLocationInSameWaterZoneClosestToTarget(iPond, iWaterZone, tWZData, tPondDetails[iPond][subrefPondWaterZones][iAltWZ][subrefMidpoint], 4, 3, 150)
                        if bDebugMessages == true then LOG(sFunctionRef..': Start WZ='..iWaterZone..'; iAltWZ='..iAltWZ..'; tPotentialLocation='..repru(tPotentialLocation)) end
                        if tPotentialLocation then
                            table.insert(tUnorderedPatrolPaths, tPotentialLocation)
                            table.insert(tAnglesCovered, M28Utilities.GetAngleFromAToB(tWZData[subrefMidpoint], tPotentialLocation))
                        end
                    end
                end
                --Identify any gaps in the path if we arent near the edge of the map
                local tbBaseAngleCovered = {}
                local iDistThreshold = 90
                if tWZData[subrefMidpoint][3] >= rMapPotentialPlayableArea[2] + iDistThreshold then
                    --Arent close to the top of the map so can look north
                    tbBaseAngleCovered[0] = false
                end
                if tWZData[subrefMidpoint][1] <= rMapPotentialPlayableArea[3] - iDistThreshold then
                    --Arent close to the rh of the map so can look east
                    tbBaseAngleCovered[90] = false
                end
                if tWZData[subrefMidpoint][3] <= rMapPotentialPlayableArea[4] - iDistThreshold then
                    --Arent close to the bottom of the map so can look south
                    tbBaseAngleCovered[180] = false
                end
                if tWZData[subrefMidpoint][1] >= rMapPotentialPlayableArea[1] + iDistThreshold then
                    --Aren't close to left hand part of map so can look west
                    tbBaseAngleCovered[270] = false
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iPond='..iPond..'; iWZ='..iWaterZone..'; tAnglesCovered='..repru(tAnglesCovered)..'; Midpoint='..repru(tWZData[subrefMidpoint])..'; playable area='..repru(rMapPotentialPlayableArea)..'; iDistThreshold='..iDistThreshold..'; tbBaseAngleCovered before factoring in angles covered='..repru(tbBaseAngleCovered)) end

                if M28Utilities.IsTableEmpty(tAnglesCovered) == false then

                    for _, iAngle in tAnglesCovered do
                        for iBaseAngle, bCovered in tbBaseAngleCovered do
                            if not(bCovered) then
                                if M28Utilities.GetAngleDifference(iBaseAngle, iAngle) <= 45 then
                                    tbBaseAngleCovered[iBaseAngle] = true
                                end
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iWaterZone='..iWaterZone..'; tbBaseAngleCovered='..repru(tbBaseAngleCovered)) end
                for iBaseAngle, bCovered in tbBaseAngleCovered do
                    if not(bCovered) then
                        local tPotentialLocation = ReturnNthValidLocationInSameWaterZoneClosestToTarget(iPond, iWaterZone, tWZData, M28Utilities.MoveInDirection(tWZData[subrefMidpoint], iBaseAngle, iDistThreshold, false, false, false), 4, 3, 100)
                        if bDebugMessages == true then LOG(sFunctionRef..': tPotentialLocation for iBaseAngle='..iBaseAngle..'='..repru(tPotentialLocation)) end
                        if tPotentialLocation then
                            table.insert(tUnorderedPatrolPaths, tPotentialLocation)
                        end
                    end
                end


                --Order the path based on distance, and add the midpoint of the land zone
                --Originally did based on distance, but based on angle looks slightly better
                --tWZData[subreftPatrolPath] = ReorderPathBasedOnDistanceToFirstEntry(tUnorderedPatrolPaths, {tWZData[subrefMidpoint][1] + 3, tWZData[subrefMidpoint][2], tWZData[subrefMidpoint][3] + 3}, true)
                tWZData[subreftPatrolPath] = ReorderPathBasedOnAngleToFirstEntry(tUnorderedPatrolPaths, {tWZData[subrefMidpoint][1] + 3, tWZData[subrefMidpoint][2], tWZData[subrefMidpoint][3] + 3}, true)

                if bDebugMessages == true then
                    LOG(sFunctionRef..': Finished recording patrol path for pond '..iPond..'; Water zone ='..iWaterZone..'; Patrol path='..repru(tWZData[subreftPatrolPath]))
                    M28Utilities.DrawLocation(tWZData[subrefMidpoint])
                    if M28Utilities.IsTableEmpty(tWZData[subreftPatrolPath]) == false then
                        M28Utilities.DrawPath(tWZData[subreftPatrolPath], 5, nil)
                    end

                end
            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function SetupLandZones()
    --Divides the map into 'land zones' based on mex placement and plateau groups, which is to form the basis for managing land units.  Land zones are areas that can be pathed by land units and are intended to group the map based on how long it takes to travel
    --Intended to be called at start of game when AI is created (so after siminit and recordresourcepoints has run), and after plateaus have been generated
    --Broadly, will group nearby mexes together in the same land zone, along with the nearby area; then will look for any places on the map with no nearby land zone and create a zone for these, and then go through the whole map and ensure every land pathable area has an assigned land zone
    --To avoid too much of a CPU load, the map is first divided into small 'segment' squares, the size of which varies based on the size of a map (1x1 for a 5km map, 2x2 for a 10km map, etc.), with it assumed that any location within a segment square has the same pathing as the midpoint of that segment
    --i.e. there will inevitably be cases where units go near a cliff where the land pathing zone is inconsistent with where the unit can path to

    --Using land zones:
    --To return both the plateau reference, and the land zone reference, of a position tPosiiton, use the function GetPlateauAndLandZoneReferenceFromPosition(tPosition) (which will return nil if it doesnt have a value)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of land zone generation, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end

    --First go through every mex on the map, and assign it a land zone (grouping mexes near each other together):
    AssignMexesALandZone()
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Now add any areas that can easily be pathed to each mex to the same land zone as that mex:
    if bDebugMessages == true then LOG(sFunctionRef..': Finished assining mexes to a land zone, will now assign the area near mexes') end

    AssignSegmentsNearMexesToLandZones()
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then
        LOG(sFunctionRef..': Finished assining area aound mexes, will now draw resulting land zones, system time='..GetSystemTimeSecondsOnlyForProfileUse())
        DrawLandZones()
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(5)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end


    --Now look for empty spots on the map without land zones and assign them a land zone, creating new ones (that have no mexes in them) where they are far from any existing land zone:
    AssignRemainingSegmentsToLandZones()
    if bDebugMessages == true then LOG(sFunctionRef..': Added remaining segments to land zones') end

    --Clear variables that we no longer need:
    tTempZoneTravelDistanceBySegment =  nil
    tTempZonePlateauBySegment = nil

    RecordLandZoneMidpointAndUnbuiltMexes()
    if bDebugMessages == true then LOG(sFunctionRef..': Finished recording land zone midpoint and unbuilt mexes system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    RecordHydroInLandZones()
    ReorderLandZoneSegmentsForEachPlateau()
    RecordAdjacentLandZones()
    RecordMassStorageLocationsForEachLandZone()
    RecordLandZonePatrolPaths()

    if bDebugMessages == true then LOG(sFunctionRef..': Finished LZ patrol paths, sys time='..GetSystemTimeSecondsOnlyForProfileUse()) end

    RecordPathingBetweenZones() --Includes a waitticks(1)

    --Map out how long it will take each LZ to path to each other LZ
    ForkThread(RecordTravelDistBetweenZonesOverTime)

    --If debug is enabled, draw land zones (different colour for each land zone on a plateau)
    if bDebugMessages == true then
        LOG(sFunctionRef..': Finished generating all land zones, will now draw them. System time='..GetSystemTimeSecondsOnlyForProfileUse())
        DrawLandZones()
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordIslands()
    --Assumes have already setup every land zone on the map - will now record details of islands
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordIslands'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Decide how detailed pathing to do when identifying the nearest land zone - on large maps we want to use straight line distance due to how long the map can take to load
    local bUseDistanceForNearestIslandLZ = false
    if iMapSize >= 512 then --10km+
        local iTotalLandZoneCount = 0
        for iPlateau, tPlateauSubtable in tAllPlateaus do
            iTotalLandZoneCount = iTotalLandZoneCount + tPlateauSubtable[subrefLandZoneCount]
        end
        if iTotalLandZoneCount >= 45 or (iTotalLandZoneCount >= 30 and iMapSize >= 512) then
            bUseDistanceForNearestIslandLZ = true
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iTotalLandZoneCount='..iTotalLandZoneCount..'; bUseDistanceForNearestIslandLZ='..tostring(bUseDistanceForNearestIslandLZ)) end
    end

    --First record every island where there are mexes in the plateau
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; About to record any islands for plateau '..iPlateau..'; if it has mexes, tPlateauSubtable[subrefPlateauTotalMexCount]='..tPlateauSubtable[subrefPlateauTotalMexCount]) end
        if tPlateauSubtable[subrefPlateauTotalMexCount] > 0 then
            tPlateauSubtable[subrefPlateauIslandLandZones] = {}
            tPlateauSubtable[subrefPlateauIslandMexCount] = { }
            local tLandZonesWithoutIslands = {}
            for iLandZone, tLZData in tPlateauSubtable[subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iLandZone='..iLandZone..'; in Plateau '..iPlateau..'; Amphibious label='..(NavUtils.GetTerrainLabel(refPathingTypeLand, tLZData[subrefMidpoint]) or 'nil')) end
                tLZData[subrefLZIslandRef] = NavUtils.GetTerrainLabel(refPathingTypeLand, tLZData[subrefMidpoint])
                if tLZData[subrefLZIslandRef] > 0 then
                    if not(tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]]) then tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]] = {} end
                    table.insert(tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]], iLandZone)
                    tPlateauSubtable[subrefPlateauIslandMexCount][tLZData[subrefLZIslandRef]] = (tPlateauSubtable[subrefPlateauIslandMexCount][tLZData[subrefLZIslandRef]] or 0) + tLZData[subrefLZMexCount]
                else
                    table.insert(tLandZonesWithoutIslands, iLandZone)
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have an island ref for iLandZone='..iLandZone..'; so will record in tLandZonesWithoutIslands') end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking all land zones for plateau '..iPlateau..' for first pass; is table of tLandZonesWithoutIslands empty='..tostring(M28Utilities.IsTableEmpty(tLandZonesWithoutIslands))) end
            if M28Utilities.IsTableEmpty(tLandZonesWithoutIslands) == false then
                for iEntry, iLandZone in tLandZonesWithoutIslands do
                    local tLZData = tPlateauSubtable[subrefPlateauLandZones][iLandZone]
                    --Cycle through adjacent LZs to see if any of them have an island recorded
                    M28Profiler.FunctionProfiler(sFunctionRef..': AjdLZ', M28Profiler.refProfilerStart)
                    if M28Utilities.IsTableEmpty(tLZData[subrefLZPathingToOtherLandZones]) == false then
                        for iEntry, tSubtable in tLZData[subrefLZPathingToOtherLandZones] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent LZs for iLandZone='..iLandZone..'; Adjacent LZ='..tSubtable[subrefLZNumber]..'; Island ref for this='..(tPlateauSubtable[subrefPlateauLandZones][tSubtable[subrefLZNumber]][subrefLZIslandRef] or 'nil')) end
                            if (tPlateauSubtable[subrefPlateauLandZones][tSubtable[subrefLZNumber]][subrefLZIslandRef] or 0) > 0 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will use htis island ref') end
                                tLZData[subrefLZIslandRef] = tPlateauSubtable[subrefPlateauLandZones][tSubtable[subrefLZNumber]][subrefLZIslandRef]
                                if not(tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]]) then tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]] = {} end
                                table.insert(tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]], iLandZone)
                                tPlateauSubtable[subrefPlateauIslandMexCount][tLZData[subrefLZIslandRef]] = (tPlateauSubtable[subrefPlateauIslandMexCount][tLZData[subrefLZIslandRef]] or 0) + tLZData[subrefLZMexCount]
                                break
                            end
                        end
                    end
                    M28Profiler.FunctionProfiler(sFunctionRef..': AjdLZ', M28Profiler.refProfilerEnd)
                    M28Profiler.FunctionProfiler(sFunctionRef..': MidpointSearch', M28Profiler.refProfilerStart)
                    --If still dont have an island ref then try searching around the midpoint until come across an island
                    if (tLZData[subrefLZIslandRef] or 0) == 0 then
                        local tAltMidpoint
                        for iAdjust = 1, 50 do
                            for iXMod = -1, 1, 1 do
                                for iZMod = -1, 1, 1 do
                                    tAltMidpoint = {tLZData[subrefMidpoint][1] + iAdjust * iXMod, 0, tLZData[subrefMidpoint][3] + iAdjust * iZMod}
                                    tAltMidpoint[2] = GetTerrainHeight(tAltMidpoint[1], tAltMidpoint[3])
                                    tLZData[subrefLZIslandRef] = NavUtils.GetTerrainLabel(refPathingTypeLand, tAltMidpoint)
                                    if (tLZData[subrefLZIslandRef] or 0) > 0 then
                                        break
                                    end
                                end
                                if (tLZData[subrefLZIslandRef] or 0) > 0 then break end
                            end
                            if (tLZData[subrefLZIslandRef] or 0) > 0 then break end
                        end
                        if (tLZData[subrefLZIslandRef] or 0) == 0 then tLZData[subrefLZIslandRef] = 0 end
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished searching nearby, tLZData[subrefLZIslandRef]='..(tLZData[subrefLZIslandRef] or 'nil')) end
                    end
                    M28Profiler.FunctionProfiler(sFunctionRef..': MidpointSearch', M28Profiler.refProfilerEnd)
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished recording all islands in plateau '..iPlateau..'; Mex count by island='..repru(tPlateauSubtable[subrefPlateauIslandMexCount])..'; LZs by island='..repru(tPlateauSubtable[subrefPlateauIslandLandZones])) end




            M28Profiler.FunctionProfiler(sFunctionRef..': Pathing', M28Profiler.refProfilerStart)
            for iLandZone, tLZData in tPlateauSubtable[subrefPlateauLandZones] do
                --For performance reasons only record pathing for zones with mexes
                if tLZData[subrefLZMexCount] > 0 then

                    --Cycle through each island in this plateau and consider pathing for it
                    if bDebugMessages == true then LOG(sFunctionRef..': Will record the pathing to every island from iLandZone='..iLandZone..'; ') end
                    for iIsland, tLandZonesInIsland in tPlateauSubtable[subrefPlateauIslandLandZones] do
                        --Only consider islands with mexes (for performance reasons)
                        if tPlateauSubtable[subrefPlateauIslandMexCount][iIsland] > 0 and not(iIsland == tLZData[subrefLZIslandRef]) then
                            --Get the land zone in this island that is closest to our current land zone
                            M28Profiler.FunctionProfiler(sFunctionRef..': Excl land path', M28Profiler.refProfilerStart)
                            local iClosestLZRef
                            local iClosestTravelDist = 100000
                            local iCurTravelDistance

                            if bUseDistanceForNearestIslandLZ then
                                local tiTopThreeZonesByDistance = {}
                                local tiDistanceOfTopThreeZones = {[1]=100000, [2]=100000,[3]=100000}
                                local iCurDistance, iCurPosition
                                for iEntry, iIslandLZ in tLandZonesInIsland do
                                    iCurDistance = M28Utilities.GetDistanceBetweenPositions(tLZData[subrefMidpoint], tPlateauSubtable[subrefPlateauLandZones][iIslandLZ][subrefMidpoint])

                                    if iCurDistance < tiDistanceOfTopThreeZones[3] then
                                        if iCurDistance <     tiDistanceOfTopThreeZones[2] then
                                            if iCurDistance < tiDistanceOfTopThreeZones[1] then
                                                iCurPosition = 1
                                            else
                                                iCurPosition = 2
                                            end
                                        else
                                            iCurPosition = 3
                                        end
                                        if iCurPosition == 1 then
                                            tiTopThreeZonesByDistance[3] = tiTopThreeZonesByDistance[2]
                                            tiDistanceOfTopThreeZones[3] = tiDistanceOfTopThreeZones[2]
                                            tiTopThreeZonesByDistance[2] = tiTopThreeZonesByDistance[1]
                                            tiDistanceOfTopThreeZones[3] = tiDistanceOfTopThreeZones[2]
                                        elseif iCurPosition == 2 then
                                            tiTopThreeZonesByDistance[3] = tiTopThreeZonesByDistance[2]
                                            tiDistanceOfTopThreeZones[3] = tiDistanceOfTopThreeZones[2]
                                        end
                                        tiTopThreeZonesByDistance[iCurPosition] = iIslandLZ
                                        tiDistanceOfTopThreeZones[iCurPosition] = iCurDistance
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': iCurTravelDistance='..repru(iCurTravelDistance)..'; iClosestTravelDist='..repru(iClosestTravelDist)) end
                                end
                                --Get the closest of these
                                local iClosestTravelDist = 100000

                                for iEntry, iIslandLZ in tiTopThreeZonesByDistance do
                                    iCurTravelDistance = M28Utilities.GetTravelDistanceBetweenPositions(tLZData[subrefMidpoint], tPlateauSubtable[subrefPlateauLandZones][iIslandLZ][subrefMidpoint], refPathingTypeHover)
                                    if bDebugMessages == true then LOG(sFunctionRef..': iCurTravelDistance='..repru(iCurTravelDistance)..'; iClosestTravelDist='..repru(iClosestTravelDist)) end
                                    if iCurTravelDistance and iCurTravelDistance < iClosestTravelDist then
                                        iClosestTravelDist = iCurTravelDistance
                                        iClosestLZRef = iIslandLZ
                                    end
                                end
                            else
                                for iEntry, iIslandLZ in tLandZonesInIsland do

                                    iCurTravelDistance = M28Utilities.GetTravelDistanceBetweenPositions(tLZData[subrefMidpoint], tPlateauSubtable[subrefPlateauLandZones][iIslandLZ][subrefMidpoint], refPathingTypeHover)
                                    if bDebugMessages == true then LOG(sFunctionRef..': iCurTravelDistance='..repru(iCurTravelDistance)..'; iClosestTravelDist='..repru(iClosestTravelDist)) end
                                    if iCurTravelDistance and iCurTravelDistance < iClosestTravelDist then
                                        iClosestTravelDist = iCurTravelDistance
                                        iClosestLZRef = iIslandLZ
                                    end
                                end
                            end

                            --Get the position in the current table
                            local iPosition = 1
                            if not(tLZData[subrefLZPathingToOtherIslands]) then
                                tLZData[subrefLZPathingToOtherIslands] = {}
                                iPosition = 1
                            else
                                for iExistingIsland, tExistingSubtable in tLZData[subrefLZPathingToOtherIslands] do
                                    if tExistingSubtable[subrefIslandTravelDist] < iClosestTravelDist then
                                        iPosition = iPosition + 1
                                    else
                                        break
                                    end
                                end
                            end
                            M28Profiler.FunctionProfiler(sFunctionRef..': Excl land path', M28Profiler.refProfilerEnd)
                            M28Profiler.FunctionProfiler(sFunctionRef..': land path', M28Profiler.refProfilerStart)
                            local tFullPath, iPathSize, iDistance = NavUtils.PathTo(refPathingTypeHover, tLZData[subrefMidpoint], tPlateauSubtable[subrefPlateauLandZones][iClosestLZRef][subrefMidpoint], nil)

                            --Reduce tFullPath to a table of land zones
                            if tFullPath then
                                local iPathingPlateau, iPathingLandZone
                                local tPathingLZConsidered = {}
                                local tPathingLZFromStartToTarget = {}


                                local iTravelDistance = 0
                                local tStart = {tLZData[subrefMidpoint][1], tLZData[subrefMidpoint][2], tLZData[subrefMidpoint][3]}
                                local tEnd = {tPlateauSubtable[subrefPlateauLandZones][iClosestLZRef][subrefMidpoint][1], tPlateauSubtable[subrefPlateauLandZones][iClosestLZRef][subrefMidpoint][2], tPlateauSubtable[subrefPlateauLandZones][iClosestLZRef][subrefMidpoint][3]}
                                tFullPath[0] = tStart
                                tFullPath[iPathSize + 1] = tEnd
                                for iPath = 1, iPathSize + 1 do
                                    iTravelDistance = iTravelDistance + VDist2(tFullPath[iPath - 1][1], tFullPath[iPath - 1][3], tFullPath[iPath][1], tFullPath[iPath][3])
                                    iPathingPlateau, iPathingLandZone = GetPlateauAndLandZoneReferenceFromPosition(tFullPath[iPath])
                                    if iPathingLandZone > 0 then
                                        if not(tPathingLZConsidered[iPathingLandZone]) and not(iLandZone == iPathingLandZone) then
                                            tPathingLZConsidered[iPathingLandZone] = true
                                            table.insert(tPathingLZFromStartToTarget, iPathingLandZone)
                                        end
                                    end
                                end
                                if not(tPathingLZConsidered[iClosestLZRef]) then
                                    table.insert(tPathingLZFromStartToTarget, iPathingLandZone)
                                    tPathingLZConsidered[iClosestLZRef] = true
                                end
                                table.insert(tLZData[subrefLZPathingToOtherIslands], iPosition, {[subrefIslandNumber] = iIsland, [subrefIslandClosestLZRef] = iClosestLZRef, [subrefLZTravelDist] = iClosestTravelDist, [subrefIslandLZPath] = { } })
                                --Add in the LZ path
                                for iEntry, iLZ in tPathingLZFromStartToTarget do
                                    table.insert(tLZData[subrefLZPathingToOtherIslands][iPosition][subrefIslandLZPath], iLZ)
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Plateau '..iPlateau..': Finished recording pathing to get from iLandZone='..iLandZone..' to iClosestLZRef='..(iClosestLZRef or 'nil')..' in island '..iIsland..'; tLZData[subrefLZPathingToOtherIslands]='..repru(tLZData[subrefLZPathingToOtherIslands])) end
                        end
                        M28Profiler.FunctionProfiler(sFunctionRef..': land path', M28Profiler.refProfilerEnd)
                    end
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef..': Pathing', M28Profiler.refProfilerEnd)
            if bDebugMessages == true then LOG(sFunctionRef..': Finished recording for iPlateau='..iPlateau) end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param tPosition table
---@param bReturnSufaceHeightInstead boolean
---@param iOptionalAmountToBeUnderwatner number
---@return boolean
function IsUnderwater(tPosition, bReturnSurfaceHeightInstead, iOptionalAmountToBeUnderwater)
    --Returns true if tPosition underwater, otherwise returns false
    --bReturnSurfaceHeightInstead:: Return the actual height at which underwater, instead of true/false
    if bReturnSurfaceHeightInstead then return iMapWaterHeight
    else
        --LOG('IsUnderwater: tPosition='..repru(tPosition))
        if M28Utilities.IsTableEmpty(tPosition) then
            M28Utilities.ErrorHandler('tPosition is empty')
        else
            if iMapWaterHeight > tPosition[2] + (iOptionalAmountToBeUnderwater or 0) then
                --Check we're not just under an arch but are actually underwater
                if not(GetTerrainHeight(tPosition[1], tPosition[3]) == iMapWaterHeight) then
                    return true
                end
            end
        end
        return false
    end
end

local function GetMapWaterHeight()
    --Updates iMapWaterHeight to the water height on the map (if the map has water)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetMapWaterHeight'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --rMapPotentialPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2} - Set at start of the game, use instead of the scenarioinfo method
    local iWaterCount = 0
    local iWaterLevel = 10000
    local iCurTerrainHeight = 10000
    local iInterval = 1

    --Cycle through the map in iInterval sizes, until we come to a point where the surface height exceeds the terrain height, which suggests it is water:
    for iX = rMapPotentialPlayableArea[1] + iInterval, rMapPotentialPlayableArea[3], iInterval do
        for iZ = rMapPotentialPlayableArea[2] + iInterval, rMapPotentialPlayableArea[4], iInterval do
            iCurTerrainHeight =  GetTerrainHeight(iX, iZ)
            if GetSurfaceHeight(iX, iZ) > GetTerrainHeight(iX, iZ) then
                iWaterCount = iWaterCount + 1
                iWaterLevel = math.min(iWaterLevel, GetSurfaceHeight(iX, iZ))
                if bDebugMessages == true then LOG(sFunctionRef..': Found water at position X-Z='..iX..'-'..iZ..'; Surface height='..GetSurfaceHeight(iX, iZ)..'; Terrain height='..GetTerrainHeight(iX, iZ)) end
                if iWaterCount >= 3 then
                    break
                end
            else
                --Backup for maps like theta passage arch - have commented out as running on theta passage with interval of 1 it never triggers a water count in the first place, but could remove comments if do come across this issue
                --if bDebugMessages == true and iWaterCount > 0 and GetTerrainHeight(iX, iZ) < iWaterLevel and iWaterLevel < 10000 then LOG(sFunctionRef..': Have suspected arch previously so will adjust water level to terrain height='..GetTerrainHeight(iX, iZ)..'; for iX-Z='..iX..'-'..iZ..'; prev iWaterLevel='..iWaterLevel) end
                --iWaterLevel = math.min(iWaterLevel, GetTerrainHeight(iX, iZ))
            end
        end
        if iWaterCount >= 3 then break end
    end
    if iWaterCount == 0 then iMapWaterHeight = 0
    else
        iMapWaterHeight = iWaterLevel
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iWaterCount='..iWaterCount..'; iMapWaterHeight='..iMapWaterHeight) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetReclaimablesResourceValue(tReclaimables, bAlsoReturnLargestReclaimPosition, iIgnoreReclaimIfNotMoreThanThis, bAlsoReturnAmountOfHighestIndividualReclaim, bEnergyNotMass)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetReclaimablesResourceValue'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bAlsoReturnLargestReclaimPosition == nil then bAlsoReturnLargestReclaimPosition = false end
    if iIgnoreReclaimIfNotMoreThanThis == nil then iIgnoreReclaimIfNotMoreThanThis = 0 end
    if iIgnoreReclaimIfNotMoreThanThis < 0 then iIgnoreReclaimIfNotMoreThanThis = 0 end

    local sResourceRef = 'MaxMassReclaim'
    if bEnergyNotMass then sResourceRef = 'MaxEnergyReclaim' end

    local tWreckPos = {}
    local iTotalResourceValue = 0
    local iLargestCurReclaim = 0
    local tReclaimPos = {}
    if tReclaimables and table.getn( tReclaimables ) > 0 then
        for _, v in tReclaimables do
            tWreckPos = v.CachePosition
            if tWreckPos[1] then
                if v[sResourceRef] > iIgnoreReclaimIfNotMoreThanThis then
                    if not(v:BeenDestroyed()) then
                        iTotalResourceValue = iTotalResourceValue + v[sResourceRef]
                        if bAlsoReturnLargestReclaimPosition and v.MaxMassReclaim > iLargestCurReclaim then
                            iLargestCurReclaim = v.MaxMassReclaim
                            tReclaimPos = {tWreckPos[1], tWreckPos[2], tWreckPos[3]}
                        end
                    end
                end
            else
                if not(v.MaxMassReclaim == nil) then
                    if v.MaxMassReclaim > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Warning - have ignored wreck location despite it having a mass reclaim value') end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bAlsoReturnLargestReclaimPosition then
        if bAlsoReturnAmountOfHighestIndividualReclaim then return iTotalResourceValue, tReclaimPos, iLargestCurReclaim
        else return iTotalResourceValue, tReclaimPos end
    else
        if bAlsoReturnAmountOfHighestIndividualReclaim then return iTotalResourceValue, iLargestCurReclaim
        else return iTotalResourceValue end
    end
end

function GetReclaimInRectangle(iReturnType, rRectangleToSearch, bForceDebug)
    --iReturnType: 1 = true/false; 2 = number of wrecks; 3 = total mass, 4 = valid wrecks, 5 = energy
    local sFunctionRef = 'GetReclaimInRectangle'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local bDebugMessages = bForceDebug if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    --NOTE: Best to try and debug via forcedebug, as dont want to run for everything due to how intensive the log of reclaim is
    --Have also commented out one of the logs to help with performance

    local tReclaimables = GetReclaimablesInRect(rRectangleToSearch)
    local iWreckCount = 0
    local iTotalResourceValue
    local bHaveReclaim = false
    local tValidWrecks = {}
    if M28Utilities.IsTableEmpty(tReclaimables) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': iReturnType='..iReturnType..'; rRectangleToSearch='..repru(rRectangleToSearch)) end
        if iReturnType == 3 or iReturnType == 5 then
            if iReturnType == 3 then iTotalResourceValue = GetReclaimablesResourceValue(tReclaimables, false, 0, false, false)
            else iTotalResourceValue = GetReclaimablesResourceValue(tReclaimables, false, 0, false, true)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iTotalResourceValue='..iTotalResourceValue) end
        else
            for _, v in tReclaimables do
                --if bDebugMessages == true then LOG(sFunctionRef..': _='.._..'; repr of reclaimable='..repru(tReclaimables)) end
                local WreckPos = v.CachePosition
                if not(WreckPos[1]==nil) then
                    if bDebugMessages == true then LOG(sFunctionRef..': _='.._..'; Cur mass value='..(v.MaxMassReclaim or 0)..'; Energy value='..(v.MaxEnergyReclaim or 0)) end
                    if (v.MaxMassReclaim or 0) > 0 or (v.MaxEnergyReclaim or 0) > 0 then
                        if bDebugMessages == true then LOG('Been destroyed='..tostring(v:BeenDestroyed())) end
                        if not(v:BeenDestroyed()) then
                            iWreckCount = iWreckCount + 1
                            bHaveReclaim = true
                            if iReturnType == 1 then break
                            elseif iReturnType == 4 then tValidWrecks[iWreckCount] = v end
                        end
                    end
                end
            end
        end
    elseif bDebugMessages == true then LOG(sFunctionRef..': tReclaimables is empty')
    end
    if bDebugMessages == true then LOG(sFunctionRef..': rRectangleToSearch='..repru(rRectangleToSearch)..'; bHaveReclaim='..tostring(bHaveReclaim)..'; iWreckCount='..iWreckCount) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if iReturnType == 1 then return bHaveReclaim
    elseif iReturnType == 2 then return iWreckCount
    elseif iReturnType == 3 or iReturnType == 5 then return iTotalResourceValue
    elseif iReturnType == 4 then return tValidWrecks
    else M28Utilities.ErrorHandler('Invalid return type')
    end
end

function SetWhetherCanPathToEnemy(aiBrain)
    --Set flag for whether AI can path to enemy base
    --Also updates other values that are based on the nearest enemy

    local sFunctionRef = 'SetWhetherCanPathToEnemy'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if not(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated]) then
        local tEnemyStartPosition = GetPrimaryEnemyBaseLocation(aiBrain)
        local tOurBase = PlayerStartPoints[aiBrain:GetArmyIndex()]

        if NavUtils.GetTerrainLabel(refPathingTypeLand, tOurBase) == NavUtils.GetTerrainLabel(refPathingTypeLand, tEnemyStartPosition) and not(IsUnderwater({tOurBase[1], GetTerrainHeight(tOurBase[1], tOurBase[3]), tOurBase[3]})) then
            aiBrain[refbCanPathToEnemyBaseWithLand] = true
        else aiBrain[refbCanPathToEnemyBaseWithLand] = false
        end

        if NavUtils.GetTerrainLabel(refPathingTypeHover, tOurBase) == NavUtils.GetTerrainLabel(refPathingTypeHover, tEnemyStartPosition) then
            aiBrain[refbCanPathToEnemyBaseWithAmphibious] = true
        else aiBrain[refbCanPathToEnemyBaseWithAmphibious] = false end

        aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] = M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[aiBrain:GetArmyIndex()], tEnemyStartPosition)
        M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiMaxScoutRadius] = math.max(1500, (M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiMaxScoutRadius] or 1500), aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 1.5)

        --Record mitpoint between base (makes it easier to calc mod distance
        aiBrain[reftMidpointToPrimaryEnemyBase] = M28Utilities.MoveInDirection(PlayerStartPoints[aiBrain:GetArmyIndex()], M28Utilities.GetAngleFromAToB(PlayerStartPoints[aiBrain:GetArmyIndex()], tEnemyStartPosition), aiBrain[M28Overseer.refiDistanceToNearestEnemyBase], false, false, false)
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetOppositeLocation(tLocation)
    --Returns a point on the opposite side of the map to tLocation
    local tOpposite = {rMapPotentialPlayableArea[3] - tLocation[1] + rMapPotentialPlayableArea[1], 0, rMapPotentialPlayableArea[4] - tLocation[3] + rMapPotentialPlayableArea[2]}
    tOpposite[2] = GetSurfaceHeight(tOpposite[1], tOpposite[3])
    return tOpposite
end

function UpdateNewPrimaryBaseLocation(aiBrain)
    --Updates reftPrimaryEnemyBaseLocation to the nearest enemy start position (unless there are no structures there in which case it searches for a better start position)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateNewPrimaryBaseLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --LOG(sFunctionRef..': aiBrain='..aiBrain:GetArmyIndex()..'; Start position='..(aiBrain:GetArmyIndex() or 'nil'))
    if bDebugMessages == true then
        LOG(sFunctionRef..': About to get new primary base location for brain '..(aiBrain.Nickname or 'nil')..' unless it is civilian or defeated')
        LOG(sFunctionRef..': IsCivilian='..tostring(M28Conditions.IsCivilianBrain(aiBrain))..'; .M28IsDefeated='..tostring((aiBrain.M28IsDefeated or false)))
    end
    if not(M28Conditions.IsCivilianBrain(aiBrain)) and not(aiBrain.M28IsDefeated) and not(aiBrain:IsDefeated()) then
        local tPrevPosition
        if aiBrain[reftPrimaryEnemyBaseLocation] then tPrevPosition = {aiBrain[reftPrimaryEnemyBaseLocation][1], aiBrain[reftPrimaryEnemyBaseLocation][2], aiBrain[reftPrimaryEnemyBaseLocation][3]} end
        if bDebugMessages == true then LOG(sFunctionRef..': Team='..(aiBrain.M28Team or 'nil')..'; Are all enemies defated for this team='..tostring(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated] or false)) end
        if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated] then
            local tFriendlyBrainStartPoints = {}
            local iFriendlyBrainCount = 0
            tFriendlyBrainStartPoints[iFriendlyBrainCount] = {PlayerStartPoints[aiBrain:GetArmyIndex()][1], PlayerStartPoints[aiBrain:GetArmyIndex()][2], PlayerStartPoints[aiBrain:GetArmyIndex()][3]}
            if bDebugMessages == true then LOG(sFunctionRef..': Have no enemies, so will get average of friendly brain start points provided not the centre of the map. Is table of friendly ally active brains empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyActiveBrains]))) end

            for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyActiveBrains] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering ally brain index='..oBrain:GetArmyIndex()..'; Nickname='..(oBrain.Nickname or 'nil')..'; Start point='..repru((PlayerStartPoints[oBrain:GetArmyIndex()] or {'nil'}))) end
                --if not(oBrain == aiBrain) then
                iFriendlyBrainCount = iFriendlyBrainCount + 1
                tFriendlyBrainStartPoints[iFriendlyBrainCount] = {PlayerStartPoints[oBrain:GetArmyIndex()][1], PlayerStartPoints[oBrain:GetArmyIndex()][2], PlayerStartPoints[oBrain:GetArmyIndex()][3]}
                --end
            end
            local tAverageTeamPosition
            if iFriendlyBrainCount == 1 then tAverageTeamPosition = tFriendlyBrainStartPoints[iFriendlyBrainCount]
            else tAverageTeamPosition = M28Utilities.GetAverageOfLocations(tFriendlyBrainStartPoints)
            end

            if bDebugMessages == true then LOG(sFunctionRef..': iFriendlyBrainCount='..iFriendlyBrainCount..'; Friendly brain start points='..repru((tFriendlyBrainStartPoints or {'nil'}))..'; tAverageTeamPosition='..repru(tAverageTeamPosition)..'; rMapPotentialPlayableArea='..repru(rMapPotentialPlayableArea)) end

            if M28Utilities.GetDistanceBetweenPositions(tAverageTeamPosition, {rMapPotentialPlayableArea[1] + (rMapPotentialPlayableArea[3] - rMapPotentialPlayableArea[1])*0.5, 0, rMapPotentialPlayableArea[2] + (rMapPotentialPlayableArea[4] - rMapPotentialPlayableArea[2])*0.5}) <= 50 then
                --Average is really close to middle of the map, so just  assume enemy base is in the opposite direction to us
                aiBrain[reftPrimaryEnemyBaseLocation] = GetOppositeLocation(PlayerStartPoints[aiBrain:GetArmyIndex()])
                if bDebugMessages == true then LOG(sFunctionRef..': Average close to middle of map so assuming enemy base is opposite direction to us') end
            else
                --Average isnt really close to mid of map, so assume enemy base is in opposite directino to average
                aiBrain[reftPrimaryEnemyBaseLocation] = GetOppositeLocation(tAverageTeamPosition)
                if bDebugMessages == true then LOG(sFunctionRef..': Assuming enemy base is opposite direction to average allied position') end
            end
        else --Still have enemies that are alive
            local tEnemyBase = PlayerStartPoints[M28Logic.GetNearestEnemyIndex(aiBrain)]
            if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy index='..(M28Logic.GetNearestEnemyIndex(aiBrain) or 'nil')..'; tEnemyBase='..repru(tEnemyBase)) end
            --Is this different from the current location we are using?
            if not(tEnemyBase[1] == aiBrain[reftPrimaryEnemyBaseLocation][1]) or not(tEnemyBase[3] == aiBrain[reftPrimaryEnemyBaseLocation][3]) then
                aiBrain[refiLastTimeCheckedEnemyBaseLocation] = GetGameTimeSeconds()
                aiBrain[reftPrimaryEnemyBaseLocation] = {tEnemyBase[1], tEnemyBase[2], tEnemyBase[3]}
            end

            --If this is on the same island as this brain, then check for overrides if we dont have a land zone for this location
            local iEnemyLandLabel = NavUtils.GetLabel(refPathingTypeLand, tEnemyBase)
            local iOurLandLabel = NavUtils.GetLabel(refPathingTypeLand, PlayerStartPoints[aiBrain:GetArmyIndex()])
            if bDebugMessages == true then LOG(sFunctionRef..': Checking if enemy base on same island as aiBrain '..aiBrain.Nickname..' base, iEnemyLandLabel='..(iEnemyLandLabel or 'nil')..'; iOurLandLabel='..(iOurLandLabel or 'nil')) end
            if iEnemyLandLabel == iOurLandLabel then
                local iEnemyPlateau, iEnemyLandZone = GetPlateauAndLandZoneReferenceFromPosition(tEnemyBase)
                local iOurPlateau, iOurLandZone = GetPlateauAndLandZoneReferenceFromPosition(PlayerStartPoints[aiBrain:GetArmyIndex()])
                if bDebugMessages == true then LOG(sFunctionRef..': We are on same island so should have a valid land zone, iEnemyLandZone='..(iEnemyLandZone or 'nil')..'; iOurPlateau='..(iOurPlateau or 'nil')..'; iEnemyPlateau='..(iEnemyPlateau or 'nil')) end
                if iEnemyLandZone == nil and iOurPlateau == iEnemyPlateau then
                    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tEnemyBase)
                    --Search in a hollow box
                    local iNewLandZone
                    local iNewLandLabel
                    local iNewPlateau
                    --Search nearby but not that far
                    local iMaxAdjust = math.max(1, math.floor(10 / iLandZoneSegmentSize))

                    for iAdjustBase = 1, iMaxAdjust do
                        for iCurSegmentX = iSegmentX - iAdjustBase, iSegmentX + iAdjustBase, 1 do
                            for iCurSegmentZ = iSegmentZ - iAdjustBase, iSegmentZ + iAdjustBase, iAdjustBase * 2 do
                                if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                                    if tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] then
                                        iNewLandLabel = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ))
                                        if iNewLandLabel == iOurLandLabel then
                                            iNewLandZone = tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
                                            AddLocationToPlateauExceptions(tEnemyBase, iOurPlateau, iNewLandZone)
                                            break
                                        end
                                    end
                                end
                            end
                            if iNewLandZone then break end
                        end
                        if iNewLandZone then break end
                        --Then do the left and right row (excl corners which ahve already done per the above)
                        for iCurSegmentX = iSegmentX - iAdjustBase, iSegmentX + iAdjustBase, iAdjustBase * 2 do
                            for iCurSegmentZ = iSegmentZ - iAdjustBase + 1, iSegmentZ + iAdjustBase - 1, 1 do
                                if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                                    if tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] then
                                        iNewLandLabel = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ))
                                        if iNewLandLabel == iOurLandLabel then
                                            iNewLandZone = tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
                                            AddLocationToPlateauExceptions(tEnemyBase, iOurPlateau, iNewLandZone)
                                            break
                                        end
                                    end
                                end
                            end
                            if iNewLandZone then break end
                        end
                        if iNewLandZone then break end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for overrides, iNewLandZone='..(iNewLandZone or 'nil')) end
                end
            end

            --Below is from M27 - not sure if still need it; it is also based in part on how long since we last scouted the location with an air scout and whether there were any enemy buildings there, but land zone logic should give an alternative way of checking if any buildings there
            --[[if aiBrain.M28AI then
            --Consider if we want to check for alternative locations to the actual enemy start:
            --Have we recently checked for a base location; --Do we have at least T2 (as a basic guide that this isn't the start of the game), has at least 3m of gametime elapsed, and have scouted the enemy base location recently, and have built at least 1 air scout this game?
            if GetGameTimeSeconds() - (aiBrain[refiLastTimeCheckedEnemyBaseLocation] or -1000) >= 10 and GetGameTimeSeconds() >= 180 then
                --(below includes alternative condition just in case there are strange unit restrictions)
                if M28Utilities.IsTableEmpty(ScenarioInfo.Options.RestrictedCategories) or (GetGameTimeSeconds() >= 600 or (aiBrain[M28Economy.refiOurHighestFactoryTechLevel] >= 2 and not(M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryAirScout) < 2))) then
                    if not(IsEnemyStartPositionValid(aiBrain, tEnemyBase)) then
                        aiBrain[reftPrimaryEnemyBaseLocation] = nil
                        local iNearestEnemyBase = 10000
                        local tNearestEnemyBase
                        --Cycle through every valid enemy brain and pick the nearest one, if there is one
                        if bDebugMessages == true then LOG(sFunctionRef..': Will cycle through each brain to identify nearest enemy base') end
                        for iCurBrain, brain in ArmyBrains do
                            if not(brain == aiBrain) and not(M28Logic.IsCivilianBrain(brain)) and IsEnemy(brain:GetArmyIndex(), aiBrain:GetArmyIndex()) and (not(brain:IsDefeated() and not(brain.M28IsDefeated)) or not(ScenarioInfo.Options.Victory == "demoralization")) then
                                if M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[brain:GetArmyIndex()], PlayerStartPoints[aiBrain:GetArmyIndex()]) < iNearestEnemyBase then
                                    if IsEnemyStartPositionValid(aiBrain, PlayerStartPoints[brain:GetArmyIndex()]) then
                                        iNearestEnemyBase = M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[brain:GetArmyIndex()], PlayerStartPoints[aiBrain:GetArmyIndex()])
                                        tNearestEnemyBase = {PlayerStartPoints[brain:GetArmyIndex()][1], PlayerStartPoints[brain:GetArmyIndex()][2], PlayerStartPoints[brain:GetArmyIndex()][3]}
                                    end
                                end
                            end
                        end
                        aiBrain[reftPrimaryEnemyBaseLocation] = tNearestEnemyBase
                        if not(aiBrain[reftPrimaryEnemyBaseLocation]) then
                            local tiCategoriesToConsider = {M28UnitInfo.refCategoryExperimentalStructure + M28UnitInfo.refCategorySML + M28UnitInfo.refCategoryFixedT3Arti, M28UnitInfo.refCategoryT3Mex, M28UnitInfo.refCategoryT2Mex, M28UnitInfo.refCategoryAirFactory + M28UnitInfo.refCategoryLandFactory}
                            local tEnemyUnits
                            tNearestEnemyBase = nil
                            for iRef, iCategory in tiCategoriesToConsider do
                                tEnemyUnits = aiBrain:GetUnitsAroundPoint(iCategory, PlayerStartPoints[aiBrain:GetArmyIndex()], 10000, 'Enemy')
                                if M28Utilities.IsTableEmpty(tEnemyUnits) == false then
                                    tNearestEnemyBase = M28Utilities.GetNearestUnit(tEnemyUnits, PlayerStartPoints[aiBrain:GetArmyIndex()], aiBrain, nil, nil):GetPosition()
                                    break
                                end
                            end
                            if tNearestEnemyBase then aiBrain[reftPrimaryEnemyBaseLocation] = tNearestEnemyBase
                            else
                                --Cant find anywhere so just pick the furthest away enemy start location
                                iNearestEnemyBase = 10000
                                for iCurBrain, brain in ArmyBrains do
                                    if not(brain == aiBrain) and not(M28Logic.IsCivilianBrain(brain)) and IsEnemy(brain:GetArmyIndex(), aiBrain:GetArmyIndex()) then
                                        if M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[brain:GetArmyIndex()], PlayerStartPoints[aiBrain:GetArmyIndex()]) < iNearestEnemyBase then
                                            iNearestEnemyBase = M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[brain:GetArmyIndex()], PlayerStartPoints[aiBrain:GetArmyIndex()])
                                            tNearestEnemyBase = {PlayerStartPoints[brain:GetArmyIndex()][1], PlayerStartPoints[brain:GetArmyIndex()][2], PlayerStartPoints[brain:GetArmyIndex()][3]}
                                        end
                                    end
                                end
                                aiBrain[reftPrimaryEnemyBaseLocation] = tNearestEnemyBase
                            end
                        end
                    end
                end
            end
        end--]]
        end
        --Have we changed position and are dealing with an M28 brain?
        if aiBrain.M28AI and not(tPrevPosition[1] == aiBrain[reftPrimaryEnemyBaseLocation][1] and tPrevPosition[3] == aiBrain[reftPrimaryEnemyBaseLocation][3]) then
            --We have changed position so update any global variables that reference this
            if bDebugMessages == true then LOG(sFunctionRef..': Will update whether we can path to enemy') end
            ForkThread(SetWhetherCanPathToEnemy, aiBrain)
        end

        aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] = M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[aiBrain:GetArmyIndex()], aiBrain[reftPrimaryEnemyBaseLocation])

    elseif bDebugMessages == true then LOG(sFunctionRef..': Dealing with a civilian brain')
    end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, primary enemy base location='..repru(aiBrain[reftPrimaryEnemyBaseLocation])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetPrimaryEnemyBaseLocation(aiBrain)
    --Returns a table {x,y,z} - usually this is the start position of the nearest enemy base.  However in certain cases it will be different
    --Used as the main location for the AI to evaluate things such as threats and make decisions; by default will be the nearest enemy start position

    --Done as a function so easier to adjust in the future if decide we want to
    if not(aiBrain[reftPrimaryEnemyBaseLocation]) then UpdateNewPrimaryBaseLocation(aiBrain) end
    return aiBrain[reftPrimaryEnemyBaseLocation]
end

function AddLocationToPlateauExceptions(tLocation, iPlateau, iLandZone)
    local iX = math.floor(tLocation[1])
    local iZ = math.floor(tLocation[3])
    if not(tPathingPlateauAndLZOverride[iX]) then tPathingPlateauAndLZOverride[iX] = {} end
    if not(math.floor(iLandZone) == iLandZone) then M28Utilities.ErrorHandler('Land zone isnt rounded', false, true) end
    tPathingPlateauAndLZOverride[iX][iZ] = {iPlateau, iLandZone}
end

function ClearTemporarySetupVariables()
    --Free up memory by clearing global variables used for map setup
    WaitTicks(10) --As basicp rotection in case any functions are still running
    tbTempConsideredLandPathingForLZ = {}
end

function CreateNewPond(iPond)
    tPondDetails[iPond] = {}
    tPondDetails[iPond][subreftiWaterSegmentXZ] = {}
    tPondDetails[iPond][subrefiSegmentCount] = 0

    tPondDetails[iPond][subrefPondMinX] = 100000
    tPondDetails[iPond][subrefPondMinZ] = 100000
    tPondDetails[iPond][subrefPondMaxX] = 0
    tPondDetails[iPond][subrefPondMaxZ] = 0
    tPondDetails[iPond][subrefiSegmentCount] = 0
    --tPondDetails[iPond][subrefPondNearbyBrains] = {}
    tPondDetails[iPond][subrefPondMidpoint] = {}
    tPondDetails[iPond][subrefPondMexInfo] = {}
end

function RecordNavalSegment(iPond, iBaseSegmentX, iBaseSegmentZ, tSegmentPosition)
    --Called from logic for land creation that cycles through every segment on the map
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RecordNavalSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if not(tPondDetails[iPond]) then
        CreateNewPond(iPond)
    end
    table.insert(tPondDetails[iPond][subreftiWaterSegmentXZ], {iBaseSegmentX, iBaseSegmentZ})
    if not(tPondBySegment[iBaseSegmentX]) then tPondBySegment[iBaseSegmentX] = {} end
    tPondBySegment[iBaseSegmentX][iBaseSegmentZ] = iPond
    iTotalSegmentsInPonds = iTotalSegmentsInPonds + 1
    tPondDetails[iPond][subrefiSegmentCount] = tPondDetails[iPond][subrefiSegmentCount] + 1

    tPondDetails[iPond][subrefPondMinX] = math.min(tPondDetails[iPond][subrefPondMinX], tSegmentPosition[1])
    tPondDetails[iPond][subrefPondMinZ] = math.min(tPondDetails[iPond][subrefPondMinZ], tSegmentPosition[3])
    tPondDetails[iPond][subrefPondMaxX] = math.max(tPondDetails[iPond][subrefPondMaxX], tSegmentPosition[1])
    tPondDetails[iPond][subrefPondMaxZ] = math.max(tPondDetails[iPond][subrefPondMaxZ], tSegmentPosition[3])
    if bDebugMessages == true then LOG(sFunctionRef..': Finished recording naval segment for pond '..iPond..'; Segment count for this point='..tPondDetails[iPond][subrefiSegmentCount]..'; Size of tPondDetails[iPond][subreftiWaterSegmentXZ]='..table.getn(tPondDetails[iPond][subreftiWaterSegmentXZ])..'; iBaseSegmentX='..(iBaseSegmentX or 'nil')..'; iBaseSegmentZ='..(iBaseSegmentZ or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordPondDetails()
    --Call after recording all pathfinding for the map, so after we have recorded all naval segments against ponds
    --intended to record key information on any ponds of interest, in particular mexes that can be hit from the pond (and the range required)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RecordPondDetails'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tbUnderwaterGroup = {}
    local tSegmentPosition

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code. Does map have water? Water height(0 means no water)='..iMapWaterHeight) end

    if iMapWaterHeight > 0 then
        --Record the size and dimensions of every pond
        local iMaxMexDist = 200 --range of aeon missile ship
        local iPondMexCount
        local iCurMexDist
        local tiDistToTry = { 24, 40, 56, 88, 120, 145, iMaxMexDist }
        local bInRange
        local iAngleInterval = 45
        local tPossibleWaterPosition
        local iPrevDist
        local tShotStartPosition
        local tShotEndPosition
        local iAOE
        local iPotentialSegmentX, iPotentialSegmentZ, iPotentialWaterZone

        --Want a brain in case we end up using the alternative 'line is blocked' built in functionality
        local aiBrain
        for iBrain, oBrain in ArmyBrains do
            if oBrain.M28AI then
                aiBrain = oBrain
                break
            end
        end
        if not (aiBrain) then
            for iBrain, oBrain in ArmyBrains do
                aiBrain = oBrain
                break
            end
        end

        for iPond, tPondSubtable in tPondDetails do
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Considering pond group ' .. iPond .. '; Pond size=' .. (tPondSubtable[subrefiSegmentCount] or 'nil'))
            end
            if (tPondSubtable[subrefiSegmentCount] or 0) >= iMinPondSize then
                --Pond is large enough for us to consider tracking; record information of interest for the pond:
                iPondMexCount = 0
                tPondSubtable[subrefPondMidpoint] = { (tPondDetails[iPond][subrefPondMinX] + tPondDetails[iPond][subrefPondMaxX]) * 0.5, iMapWaterHeight, (tPondDetails[iPond][subrefPondMinZ] + tPondDetails[iPond][subrefPondMaxZ]) * 0.5 }
                if bDebugMessages == true then LOG(sFunctionRef .. ': Recording pond, will check how many mexes are nearby. Pond midpoint=' .. repru(tPondSubtable[subrefPondMidpoint]) .. '; Pond min X-Z=' .. tPondDetails[iPond][subrefPondMinX] .. '-' .. tPondDetails[iPond][subrefPondMinZ] .. '; Max X-Z=' .. tPondDetails[iPond][subrefPondMaxX] .. '-' .. tPondDetails[iPond][subrefPondMaxZ]) end

                --Details of all mexes near enough to the pond to be of interest
                for iMex, tMex in tMassPoints do
                    bInRange = false

                    if tMex[1] >= tPondSubtable[subrefPondMinX] - iMaxMexDist and tMex[1] <= tPondSubtable[subrefPondMaxX] + iMaxMexDist and tMex[3] >= tPondSubtable[subrefPondMinZ] - iMaxMexDist and tMex[3] <= tPondSubtable[subrefPondMaxZ] + iMaxMexDist then
                        --See how far away the water is
                        for iEntry, iDist in tiDistToTry do
                            for iAngleAdjust = iAngleInterval, 360, iAngleInterval do
                                tPossibleWaterPosition = M28Utilities.MoveInDirection(tMex, iAngleAdjust, iDist, true, true, false) --Gets terrainheight rather than surface height
                                if IsUnderwater(tPossibleWaterPosition, false, iMinWaterDepth) then
                                    iPotentialSegmentX, iPotentialSegmentZ = GetPathingSegmentFromPosition(tPossibleWaterPosition)
                                    iPotentialWaterZone = tWaterZoneBySegment[iPotentialSegmentX][iPotentialSegmentZ]
                                    if iPotentialWaterZone and tiPondByWaterZone[iPotentialWaterZone] == iPond then
                                        --Have a match, record the mex details:
                                        bInRange = true
                                        iCurMexDist = iDist

                                        --Record initial mex details:
                                        iPondMexCount = iPondMexCount + 1
                                        tPondSubtable[subrefPondMexInfo][iPondMexCount] = {}
                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexLocation] = { tMex[1], tMex[2], tMex[3] }

                                        --Do we expect to be able to hit the mex from here? a UEF Frigate y height is 1.1, while a t1 mex is 1.4; cant be bothered to check height of weapon and mex bone, and will vary based on how far away we are as well
                                        tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                                        tShotEndPosition = { tMex[1], tMex[2] + 1.1, tMex[3] }

                                        iAOE = 0
                                        if iCurMexDist >= 30 then
                                            iAOE = 1
                                        end --most destroyers have an aoe attack (except sera)

                                        if M28Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, iAOE) then
                                            tShotStartPosition[2] = tShotStartPosition[2] + 8
                                            tShotEndPosition[2] = tShotEndPosition[2] + 8
                                            if M28Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, 1) then
                                                --cant hit with df or indirect
                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] = 10000
                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = 10000
                                            else
                                                --Can hit with indirect but not DF, so consider whether if we move further back we can then hit
                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] = iCurMexDist
                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}

                                                --Find the point at which DF can hit, if any, in intervals of 5, assuming at max range we can hit
                                                local iMaxDistAdjust = math.max(5, math.min(100, math.floor((150 - iCurMexDist) / 5) * 5))
                                                tPossibleWaterPosition = M28Utilities.MoveInDirection(tMex, iAngleAdjust, iDist + iMaxDistAdjust, true, true, false)
                                                if IsUnderwater(tPossibleWaterPosition, false, iMinWaterDepth) then
                                                    tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                                                    if M28Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, 1) then
                                                        --Assume wont find any match
                                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = 10000
                                                    else
                                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = iDist + iMaxDistAdjust
                                                        --Refine the distance by moving closer
                                                        for iDFDistAdjust = 5, math.max(5, math.min(100, math.floor((150 - iCurMexDist) / 5) * 5)), 5 do
                                                            tPossibleWaterPosition = M28Utilities.MoveInDirection(tMex, iAngleAdjust, iDist + iDFDistAdjust, true, true, false)
                                                            tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                                                            if not (M28Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, 1)) then
                                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = iDist + iDFDistAdjust
                                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}
                                                                break
                                                            end
                                                        end
                                                    end
                                                else
                                                    --Assume wont find any match as if move really far back we are not on water
                                                    tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = 10000
                                                end
                                            end

                                            if bDebugMessages == true and tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] then
                                                LOG(sFunctionRef .. ' Drawing start in white and end in orangy pink')
                                                M28Utilities.DrawLocation({ tShotStartPosition[1], tShotStartPosition[2] - 8, tShotStartPosition[3] }, 7, 100, nil)
                                                M28Utilities.DrawLocation({ tShotEndPosition[1], tShotEndPosition[2] - 8, tShotEndPosition[3] }, 8, 100, nil)
                                            end
                                        else
                                            --DF can hit from cur position so assume indirect can as well
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = iCurMexDist
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] = iCurMexDist
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}
                                        end

                                        --Refine the distance - see if can get any closer
                                        if iEntry == 1 then
                                            iPrevDist = 0
                                        else
                                            iPrevDist = tiDistToTry[iEntry - 1]
                                        end
                                        for iShortDist = iPrevDist + 1, iDist - 1, 1 do
                                            tPossibleWaterPosition = M28Utilities.MoveInDirection(tMex, iAngleAdjust, iDist, true, false, false)
                                            if IsUnderwater(tPossibleWaterPosition, false, iMinWaterDepth) then
                                                iCurMexDist = iShortDist
                                                break
                                            end
                                        end

                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDistance] = iCurMexDist

                                        if bDebugMessages == true then LOG(sFunctionRef .. ': Finished recording mex in range for pond ' .. iPond .. '; iPondMexCount=' .. iPondMexCount .. '; full mex table of info=' .. repru(tPondSubtable[subrefPondMexInfo][iPondMexCount])) end
                                        break
                                    end
                                end
                            end
                            if bInRange then
                                break
                            end
                        end
                    end
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Considered Mex ' .. repru(tMex) .. '; bInRange=' .. tostring(bInRange))
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording all ponds, repr='..reprs(tPondDetails)) end
    end
    bHaveRecordedPonds = true
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordPondToExpandTo(aiBrain)
    --Calculates which pond we think is most important to hold; assumes we have already recorded all segments and ponds (but havent yet setup water zones)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RecordPondToExpandTo'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    bHaveConsideredPreferredPondForM28AI = true
    if bDebugMessages == true then LOG(sFunctionRef..': Starting RecordPondToExpandTo at '..GetGameTimeSeconds()..' for brain '..aiBrain.Nickname..', Is table of pond details empty='..tostring(M28Utilities.IsTableEmpty(tPondDetails))..'; bHaveRecordedPonds='..tostring(bHaveRecordedPonds)) end
    local iWaitCount = 0
    while not(bHaveRecordedPonds) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        iWaitCount = iWaitCount + 1
        if iWaitCount >= 20 then break end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting, time='..GetGameTimeSeconds()..'; Is table of pond details empty='..tostring(M28Utilities.IsTableEmpty(tPondDetails))..'; bHaveRecordedPonds='..tostring(bHaveRecordedPonds)) end
    if M28Utilities.IsTableEmpty(tPondDetails) == false then
        local bStartLocationIsUnderwater = false
        local tStartPos = PlayerStartPoints[aiBrain:GetArmyIndex()]
        if GetTerrainHeight(tStartPos[1], tStartPos[3]) < GetSurfaceHeight(tStartPos[1], tStartPos[3]) then bStartLocationIsUnderwater = true end
        if bDebugMessages == true then LOG(sFunctionRef..': Considering aiBrain '..aiBrain.Nickname..' location for naval fac, bStartLocationIsUnderwater='..tostring(bStartLocationIsUnderwater)..'; tStartPos='..repru(tStartPos)..'; Terrain height='..GetTerrainHeight(tStartPos[1], tStartPos[3])..'; Surface height='..GetSurfaceHeight(tStartPos[1], tStartPos[3])) end
        local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
        aiBrain[M28Navy.reftiPondThreatToUs] = {}
        aiBrain[M28Navy.reftiPondValueToUs] = {}
        local iCurPondValue
        local iCurPondDefensiveValue --Value of mexes that are threatened by enemy if they get navy
        local iBestPondValue = 0
        local iBestPondRef

        local iDistanceThreshold = math.max(138, math.min(180, aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.35))
        if not(aiBrain[refbCanPathToEnemyBaseWithLand]) then iDistanceThreshold = iDistanceThreshold + 50 end

        local iFrigateRange = 28
        local iDestroyerRange = 60
        local iBattleshipRange = 128
        local iMissileShipRange = 150
        local iFrigateValue = 1
        local iDestroyerValue = 0.8
        local iBattleshipValue = 0.45
        local iMissileShipValue = 0.6

        local iEnemyDestroyerRange = 60
        local iEnemyBattleshipRange = 128
        local iEnemyMissileShipRange = 150


        if aiBrain:GetFactionIndex() == M28UnitInfo.refFactionUEF then
            iBattleshipRange = 150
        elseif aiBrain:GetFactionIndex() == M28UnitInfo.refFactionCybran then
            iDestroyerRange = 80
            iMissileShipRange = 0
        elseif aiBrain:GetFactionIndex() == M28UnitInfo.refFactionAeon then
            iMissileShipRange = 200
            iMissileShipValue = iBattleshipValue
            --Seraphim - no change to default
        end

        local iEnemyBrainIndex = M28Logic.GetNearestEnemyIndex(aiBrain)
        if iEnemyBrainIndex == M28UnitInfo.refFactionUEF then
            iEnemyBattleshipRange = 150
        elseif iEnemyBrainIndex == M28UnitInfo.refFactionCybran then
            iEnemyDestroyerRange = 80
            iEnemyMissileShipRange = 0
        elseif iEnemyBrainIndex == M28UnitInfo.refFactionAeon then
            iEnemyMissileShipRange = 200
        end

        local iMinModDistanceWanted = math.max(155, aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.4)
        if bDebugMessages == true then LOG(sFunctionRef..': aiBrain='..aiBrain.Nickname..'; Start of logic to consider the best pond. iMinModDistanceWanted='..iMinModDistanceWanted..'; Dist to enemy base='..(aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] or 'nil')) end
        local iMidModDistance = aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.5
        local iBelowMidFactor = 0.3 --Reudces value of mex that is closer to our base than enemy base to this %, assuming it is above the iMinModDistanceWanted
        local iCurMexValue
        local iCurMexDefensiveValue
        local iCurModDistance
        local iDefensiveModDistanceMaxValue = math.max(120, math.min(300, aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.4))

        local iPathingGroupWanted = NavUtils.GetTerrainLabel(refPathingTypeHover, PlayerStartPoints[aiBrain:GetArmyIndex()])

        for iCurPondRef, tPondSubtable in tPondDetails do
            aiBrain[M28Navy.reftiPondValueToUs][iCurPondRef] = 0
            aiBrain[M28Navy.reftiPondThreatToUs][iCurPondRef] = 0
            if M28Utilities.IsTableEmpty(tPondSubtable) == false then
                iCurPondValue = 0
                iCurPondDefensiveValue = 0
                if bDebugMessages == true then LOG(sFunctionRef..': iCurPondRef='..iCurPondRef..'; Repru of subtable='..repru(tPondSubtable)..'; ai brain start point='..repru(PlayerStartPoints[aiBrain:GetArmyIndex()])) end

                --Is the pond within 175 of our start position?  First see if X is within distance threshold:
                if math.abs(tPondSubtable[subrefPondMinX] - PlayerStartPoints[aiBrain:GetArmyIndex()][1]) <= iDistanceThreshold or math.abs(PlayerStartPoints[aiBrain:GetArmyIndex()][1] - tPondSubtable[subrefPondMaxX]) <= iDistanceThreshold or (PlayerStartPoints[aiBrain:GetArmyIndex()][1] >= tPondSubtable[subrefPondMinX] and PlayerStartPoints[aiBrain:GetArmyIndex()][1] <= tPondSubtable[subrefPondMaxX]) then
                    --X is in range, is Z?
                    if math.abs(tPondSubtable[subrefPondMinZ] - PlayerStartPoints[aiBrain:GetArmyIndex()][3]) <= iDistanceThreshold or math.abs(PlayerStartPoints[aiBrain:GetArmyIndex()][3] - tPondSubtable[subrefPondMaxZ]) <= iDistanceThreshold or (PlayerStartPoints[aiBrain:GetArmyIndex()][3] >= tPondSubtable[subrefPondMinZ] and PlayerStartPoints[aiBrain:GetArmyIndex()][3] <= tPondSubtable[subrefPondMaxZ]) then
                        --X and Z are in range


                        for iMex, tMexInfo in tPondSubtable[subrefPondMexInfo] do
                            iCurMexValue = 0
                            iCurMexDefensiveValue = 0
                            if tMexInfo[subrefMexDFDistance] <= iBattleshipRange or tMexInfo[subrefMexIndirectDistance] <= iMissileShipRange then
                                --Can reach this mex with a ship, so it will have at least some value
                                if tMexInfo[subrefMexDFDistance] <= iFrigateRange then iCurMexValue = iFrigateValue
                                elseif tMexInfo[subrefMexDFDistance] <= iDestroyerRange then iCurMexValue = iDestroyerValue
                                elseif tMexInfo[subrefMexIndirectDistance] <= iMissileShipRange then iCurMexValue = iMissileShipValue
                                else iCurMexValue = iBattleshipValue
                                end
                            end

                            --Adjust mex value based on distance
                            iCurModDistance = GetModDistanceFromStart(aiBrain, tMexInfo[subrefMexLocation])
                            if iCurMexValue > 0 then
                                if iCurModDistance <  iMinModDistanceWanted then iCurMexValue = 0
                                else
                                    if iCurModDistance < iMidModDistance then
                                        iCurMexValue = iCurMexValue * iBelowMidFactor
                                    end
                                end
                                iCurPondValue = iCurPondValue + iCurMexValue
                            end


                            --Get defensive value
                            if iCurModDistance <= iDefensiveModDistanceMaxValue then
                                if tMexInfo[subrefMexDFDistance] <= iEnemyBattleshipRange or tMexInfo[subrefMexIndirectDistance] <= iEnemyMissileShipRange then
                                    --Can reach this mex with a ship, so it will have at least some value
                                    if tMexInfo[subrefMexDFDistance] <= iFrigateRange then iCurMexDefensiveValue = iFrigateValue
                                    elseif tMexInfo[subrefMexDFDistance] <= iEnemyDestroyerRange then iCurMexDefensiveValue = iDestroyerValue
                                    elseif tMexInfo[subrefMexIndirectDistance] <= iEnemyMissileShipRange then iCurMexDefensiveValue = iMissileShipValue
                                    else iCurMexDefensiveValue = iBattleshipValue
                                    end
                                end
                                iCurPondDefensiveValue = iCurPondDefensiveValue + iCurMexDefensiveValue
                            end

                        end

                        --Increase vlaue if in part of pond likely to be near enemy base
                        local tEnemyBase = GetPrimaryEnemyBaseLocation(aiBrain)
                        local iEnemyBaseThreshold = math.max(iBattleshipRange, iMissileShipRange - 10)
                        if math.abs(tPondSubtable[subrefPondMinX] - tEnemyBase[1]) <= iEnemyBaseThreshold or math.abs(tEnemyBase[1] - tPondSubtable[subrefPondMaxX]) <= iEnemyBaseThreshold or (tEnemyBase[1] >= tPondSubtable[subrefPondMinX] and tEnemyBase[1] <= tPondSubtable[subrefPondMaxX]) then
                            --X is in range, is Z?
                            if math.abs(tPondSubtable[subrefPondMinZ] - tEnemyBase[3]) <= iEnemyBaseThreshold or math.abs(tEnemyBase[3] - tPondSubtable[subrefPondMaxZ]) <= iEnemyBaseThreshold or (tEnemyBase[3] >= tPondSubtable[subrefPondMinZ] and tEnemyBase[3] <= tPondSubtable[subrefPondMaxZ]) then
                                iCurPondValue = math.max(iCurPondValue * 1.2, iCurPondValue + 2)
                                if bDebugMessages == true then LOG(sFunctionRef..': Can probably hit enemy base with navy so increasing pond value by 20%') end
                            end
                        end


                        if bDebugMessages == true then LOG(sFunctionRef..': Have a pond that is in range of our start position, value based on mexes in range pre adjust='..iCurPondValue) end
                        --Do we have sufficient value to consider?
                        if iCurPondValue >= 4 or iCurPondDefensiveValue >= 4 or bStartLocationIsUnderwater then
                            if iCurPondValue <= 0 then iCurPondValue = 0.1 end --Pond has defensive value so greater than 0
                            --Adjust value based on how close the naval build location would be for this pond
                            if not(tPondSubtable[subrefBuildLocationByStartPosition]) then
                                tPondSubtable[subrefBuildLocationByStartPosition] = {}
                            end
                            local tNavalBuildArea = {}
                            if not(bStartLocationIsUnderwater) then
                                local iAngleToCentre = M28Utilities.GetAngleFromAToB(PlayerStartPoints[aiBrain:GetArmyIndex()], tPondSubtable[subrefPondMidpoint])
                                local iDistInterval = 8
                                local iBuildingInterval = 4
                                local tPossibleLocationBase
                                local tPossibleBuildLocation
                                local bHaveValidLocation = false
                                if bDebugMessages == true then LOG(sFunctionRef..': About to search for location to build naval factory for iCurPondRef='..iCurPondRef..'; iDistInterval='..iDistInterval..'; Angle='..iAngleToCentre..'; Midpoint='..repru(tPondSubtable[subrefPondMidpoint])..'; Start position='..repru(PlayerStartPoints[aiBrain:GetArmyIndex()])) end
                                for iDistToTravel = iDistInterval, math.max(iDistInterval, math.floor(M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[aiBrain:GetArmyIndex()], tPondSubtable[subrefPondMidpoint]) / iDistInterval) * iDistInterval), iDistInterval do
                                    for iAngleAdjust = 0, 170, 10 do
                                        for iAngleFactor = -1, 1, 2 do
                                            tPossibleLocationBase = M28Utilities.MoveInDirection(PlayerStartPoints[aiBrain:GetArmyIndex()], iAngleToCentre + iAngleAdjust * iAngleFactor, iDistToTravel, true, true, false)
                                            if NavUtils.GetTerrainLabel(refPathingTypeNavy, tPossibleLocationBase) == iCurPondRef then
                                                --Try and find somewhere around here to build a naval factory
                                                for iBuildingAdjustX = 0, iBuildingInterval, 1 do
                                                    for iBuildingAdjustZ = 0, iBuildingInterval, 1 do
                                                        for iXFactor = -1, 1, 2 do
                                                            for iZFactor = -1, 1, 2 do
                                                                tPossibleBuildLocation = {tPossibleLocationBase[1] + iBuildingAdjustX * iXFactor, 0, tPossibleLocationBase[3] + iBuildingAdjustZ * iZFactor}
                                                                tPossibleBuildLocation[2] = GetSurfaceHeight(tPossibleBuildLocation[1], tPossibleBuildLocation[3])
                                                                if aiBrain:CanBuildStructureAt('ueb0103', tPossibleBuildLocation) then
                                                                    bHaveValidLocation = true
                                                                    tNavalBuildArea = {tPossibleBuildLocation[1], tPossibleBuildLocation[2], tPossibleBuildLocation[3]}
                                                                    if bDebugMessages == true then
                                                                        LOG(sFunctionRef..': Have valid location='..repru(tPossibleBuildLocation)..'; will draw in white')
                                                                        M28Utilities.DrawLocation(tPossibleBuildLocation, 1, 100, 2)
                                                                    end
                                                                    break
                                                                else
                                                                    if bDebugMessages == true then
                                                                        LOG(sFunctionRef..': Have invalid location='..repru(tPossibleBuildLocation)..'; will draw in red')
                                                                        M28Utilities.DrawLocation(tPossibleBuildLocation, 2, 100, 2)
                                                                    end
                                                                end
                                                            end
                                                            if bHaveValidLocation then break end
                                                        end
                                                        if bHaveValidLocation then break end

                                                    end
                                                    if bHaveValidLocation then break end
                                                end
                                                if iAngleAdjust == 0 or bHaveValidLocation then break end
                                            elseif bDebugMessages == true then
                                                LOG(sFunctionRef..': Failed tPossibleLocationBase pathing group, tPossibleLocationBase='..repru(tPossibleLocationBase)..'; naval label='..(NavUtils.GetTerrainLabel(refPathingTypeNavy, tPossibleLocationBase) or 'nil')..'; iCurPondRef='..iCurPondRef..'; iPathingGroupWanted='..iPathingGroupWanted..'; will draw in gold')
                                                M28Utilities.DrawLocation(tPossibleLocationBase, 4, 100, 2)
                                            end
                                            if bHaveValidLocation then break end
                                        end
                                        if bHaveValidLocation then break end
                                    end
                                    if bHaveValidLocation then break end
                                end
                            else
                                local iIndex = aiBrain:GetArmyIndex()
                                tNavalBuildArea = {PlayerStartPoints[iIndex][1], PlayerStartPoints[iIndex][2], PlayerStartPoints[iIndex][3]}
                            end

                            if bDebugMessages == true then LOG(sFunctionRef..': Finsihed searching for naval build area, is table empty='..tostring(M28Utilities.IsTableEmpty(tNavalBuildArea))) end


                            if M28Utilities.IsTableEmpty(tNavalBuildArea) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': tNavalBuildArea pre adjust='..repru(tNavalBuildArea)) end
                                --Move towards base to help with cliff building if we have cliffs
                                local bHaveNearbyCliff = false
                                local iDistToMoveTarget = M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[aiBrain:GetArmyIndex()], tNavalBuildArea)
                                local iAngleFromTarget = M28Utilities.GetAngleFromAToB(tNavalBuildArea, PlayerStartPoints[aiBrain:GetArmyIndex()])
                                local tCliffPositionCheck
                                local sPathing = refPathingTypeHover
                                local iStartPathingGroup = NavUtils.GetTerrainLabel(sPathing,PlayerStartPoints[aiBrain:GetArmyIndex()])

                                if iDistToMoveTarget > 1 then
                                    for iDistAdjust = 1, math.min(13, math.floor(iDistToMoveTarget)) do
                                        tCliffPositionCheck = M28Utilities.MoveInDirection(tNavalBuildArea, iAngleFromTarget, iDistAdjust, true, false, false)
                                        if not(NavUtils.GetTerrainLabel(sPathing, tCliffPositionCheck) == iStartPathingGroup) then
                                            bHaveNearbyCliff = true
                                            break
                                        end

                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': bHaveNearbyCliff='..tostring(bHaveNearbyCliff)) end
                                if bHaveNearbyCliff then
                                    --Try to move closer to base
                                    local tLastValidPosition = {tNavalBuildArea[1], tNavalBuildArea[2], tNavalBuildArea[3]}
                                    local tAlternativePosition

                                    for iDistAdjust = 1, math.min(13, math.floor(iDistToMoveTarget)) do
                                        tAlternativePosition = M28Utilities.MoveInDirection(tNavalBuildArea, iAngleFromTarget, iDistAdjust, true, false, false)
                                        if not(NavUtils.GetTerrainLabel(refPathingTypeNavy, tAlternativePosition) == iCurPondRef) then
                                            break
                                        else
                                            --Can we build here?
                                            if aiBrain:CanBuildStructureAt('ueb0103', tAlternativePosition) then
                                                tLastValidPosition = {tAlternativePosition[1], tAlternativePosition[2], tAlternativePosition[3]}
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have an alternative position that is closer to our base, iDistAdjust='..iDistAdjust) end
                                            else
                                                break
                                            end
                                        end
                                    end
                                    tNavalBuildArea = tLastValidPosition


                                end



                                if bDebugMessages == true then
                                    LOG(sFunctionRef..': Have a naval build area='..repru(tNavalBuildArea)..'; will draw large square around it in blue, and will set this as the build area for brain '..aiBrain.Nickname)
                                    M28Utilities.DrawLocation(tNavalBuildArea, nil, 200, 10)
                                end
                                tPondSubtable[subrefBuildLocationByStartPosition][aiBrain:GetArmyIndex()] = tNavalBuildArea

                                --Record pond value before distance adjustments - i.e. if we already have navy somewhere, this is how much the pond is worth to us
                                aiBrain[M28Navy.reftiPondValueToUs][iCurPondRef] = iCurPondValue
                                --Adjust pond value based on distance to us - used only for decision on whether to choose as a pond we want


                                --Can we path here amphibiously?
                                if not(NavUtils.GetTerrainLabel(refPathingTypeHover, tNavalBuildArea) == iPathingGroupWanted) then
                                    iCurPondValue = 0
                                    if bDebugMessages == true then LOG(sFunctionRef..': We cant path here amphibiously') end
                                else
                                    --Adjust value based on distance
                                    local iDistToBuildArea = M28Utilities.GetDistanceBetweenPositions(tNavalBuildArea, PlayerStartPoints[aiBrain:GetArmyIndex()])
                                    if iDistToBuildArea <= 50 then iCurPondValue = iCurPondValue * 1.1
                                    else
                                        iCurPondValue = iCurPondValue * math.max(0.1, 1 - 0.4 * iDistToBuildArea / iDistanceThreshold)
                                    end

                                    --Are we close enough to enemy base to be in danger and we can land path to enemy base?
                                    if bDebugMessages == true then LOG(sFunctionRef..': Dist to nearest enemy base='..aiBrain[M28Overseer.refiDistanceToNearestEnemyBase]..'; Can path with land='..tostring(aiBrain[refbCanPathToEnemyBaseWithLand])..'; Dist from naval build location to enemy base='..M28Utilities.GetDistanceBetweenPositions(tNavalBuildArea, GetPrimaryEnemyBaseLocation(aiBrain))) end
                                    if aiBrain[refbCanPathToEnemyBaseWithLand] and not(bIsCampaignMap) then
                                        --Reduce value of pond if enemy base is close for land anyway
                                        if aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] <= 300 then
                                            iCurPondValue = iCurPondValue * 0.5
                                        end
                                        if M28Utilities.GetDistanceBetweenPositions(tNavalBuildArea, GetPrimaryEnemyBaseLocation(aiBrain)) <= 200 then
                                            iCurPondValue = 0
                                        end
                                    end
                                end
                            else
                                iCurPondValue = 0
                            end
                            aiBrain[M28Navy.reftiPondThreatToUs][iCurPondRef] = iCurPondDefensiveValue
                            if bDebugMessages == true then LOG(sFunctionRef..': Pond value after getting naval build area='..iCurPondValue..'; Defensive value='..(aiBrain[M28Navy.reftiPondThreatToUs][iCurPondRef] or 'nil')) end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Pond value is too low to be worth considering') end
                            iCurPondValue = 0
                        end
                    end
                end
                if iCurPondValue > iBestPondValue then
                    if bDebugMessages == true then LOG(sFunctionRef..': Updating the best pond ref to be '..iCurPondRef..'; as the cur pond value '..iCurPondValue..' is more than the prev best of '..iBestPondValue) end
                    iBestPondRef = iCurPondRef
                    iBestPondValue = iCurPondValue

                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Near end of code, iBestPondRef='..(iBestPondRef or 'nil')..'; iBestPondValue='..(iBestPondValue or 'nil')) end
        if iBestPondRef and (iBestPondValue >= 4 or (iBestPondValue >= 2 and bIsCampaignMap)) then
            aiBrain[M28Navy.refiPriorityPondRef] = iBestPondRef
            if bDebugMessages == true then
                local iBuildSegmentX, iBuildSegmentZ = GetPathingSegmentFromPosition(tPondDetails[aiBrain[M28Navy.refiPriorityPondRef]][subrefBuildLocationByStartPosition][aiBrain:GetArmyIndex()])
                local iWaterZone = tWaterZoneBySegment[iBuildSegmentX][iBuildSegmentZ]
                LOG(sFunctionRef..': Have a priority pond ref='..aiBrain[M28Navy.refiPriorityPondRef]..' at water zone '..(iWaterZone or 'nil')..'; will draw a square in orangy pink for the build position='..repru(tPondDetails[aiBrain[M28Navy.refiPriorityPondRef]][subrefBuildLocationByStartPosition][aiBrain:GetArmyIndex()]))
                M28Utilities.DrawLocation(tPondDetails[aiBrain[M28Navy.refiPriorityPondRef]][subrefBuildLocationByStartPosition][aiBrain:GetArmyIndex()], 8, 200, 10)
            end
            local bInTeamList = false
            local iTeam = aiBrain.M28Team
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues]) == false then
                for iEntry, iPond in M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues] do
                    if iBestPondRef == iPond then
                        bInTeamList = true
                        break
                    end
                end
            end
            if not(bInTeamList) then
                if not(M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues]) then M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues] = {} end
                M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][iBestPondRef] = math.max((M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][iBestPondRef] or 0), iBestPondValue)
            end
        elseif bDebugMessages == true then LOG(sFunctionRef..'; Etiher dont have a pond to expand to, or the value is too low to want to expand')
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AddSegmentToWaterZone(iPond, iWaterZone, iSegmentX, iSegmentZ)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddSegmentToWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': About to add Segment X-Z'..iSegmentX..'-'..iSegmentZ..' to iPond='..iPond..' and water zone='..iWaterZone..'; iTotalWaterZoneRecordedSegmentCount prior to this='..iTotalWaterZoneRecordedSegmentCount) end
    table.insert(tPondDetails[iPond][subrefPondWaterZones][iWaterZone][subrefWZSegments], {iSegmentX, iSegmentZ})
    if not(tWaterZoneBySegment[iSegmentX]) then tWaterZoneBySegment[iSegmentX] = {} end
    tWaterZoneBySegment[iSegmentX][iSegmentZ] = iWaterZone
    iTotalWaterZoneRecordedSegmentCount = iTotalWaterZoneRecordedSegmentCount + 1
    tPondDetails[iPond][subrefiRecordedSegmentsInWaterZones] = (tPondDetails[iPond][subrefiRecordedSegmentsInWaterZones] or 0) + 1
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordWaterZoneAtPosition(tSegmentPosition)
    iTotalWaterZoneCount = iTotalWaterZoneCount + 1
    local iPond = NavUtils.GetTerrainLabel(refPathingTypeNavy, tSegmentPosition)
    if not(iPond) then
        local tAlternative
        local tiAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}, {-3,0}, {-3, -3}, {-3, 3}, {0, -3}, {0, 3}, {3, -3}, {3, 0}, {3,3}, {-5,0}, {-5, -5}, {-5, 5}, {0, -5}, {0, 5}, {5, -5}, {5, 0}, {5,5}}
        for iEntry, tXZAdjust in tiAdjust do
            iPond = NavUtils.GetTerrainLabel(refPathingTypeNavy, { tSegmentPosition[1] + tXZAdjust[1], tSegmentPosition[2], tSegmentPosition[3] + tXZAdjust[2] })
            if iPond then break end
        end
    end
    if not(iPond) then M28Utilities.ErrorHandler('Dont have a valid pond even after searching nearby')
    else
        if not(tPondDetails[iPond][subrefPondWaterZones]) then tPondDetails[iPond][subrefPondWaterZones] = {} end
        tPondDetails[iPond][subrefPondWaterZones][iTotalWaterZoneCount] = {}
        tPondDetails[iPond][subrefPondWaterZones][iTotalWaterZoneCount][subrefWZSegments] = {}
        tiPondByWaterZone[iTotalWaterZoneCount] = iPond
        local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tSegmentPosition)
        AddSegmentToWaterZone(iPond, iTotalWaterZoneCount, iSegmentX, iSegmentZ)
    end
end

local function DrawWaterZones()
    --For debug use - will draw each land zone in a plateau in a different colour to allow a visual check of how land zones have been created.  Can be called part-way through the process (e.g. to show land zones after the initial mex creation and nearby areas)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DrawWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Create fixed colours per ref
    local iUniqueColourCount = 30
    local tColourTable = M28Utilities.GenerateUniqueColourTable(iUniqueColourCount)

    --Subfunction which assigns a unique colour to each land zone
    function GetColourFromWaterZoneNumber(iWaterZoneRef)
        local iColour = iWaterZoneRef
        while iColour >= iUniqueColourCount do
            iColour = iColour - iUniqueColourCount
        end

        return tColourTable[iColour]
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Will now draw every land zone in every plateau, cycling the colour used') end
    local tLocation, iWaterZoneRef
    --Cycle through every segment on the map and draw a colour for it based on the land zone that it's part of
    for iCurSegmentX = 1, iMaxLandSegmentX do
        for iCurSegmentZ = 1, iMaxLandSegmentZ do
            iWaterZoneRef = tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ]
            if (iWaterZoneRef or 0) > 0 then
                tLocation = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                if bDebugMessages == true then LOG(sFunctionRef..': Water zone ref for segments X-Z='..iCurSegmentX..'-'..iCurSegmentZ..' = '..iWaterZoneRef..'; Plataeu ref based on navutils='..NavUtils.GetTerrainLabel(refPathingTypeHover, tLocation)) end
                --M28Utilities.DrawLocation(tLocation, GetColourFromWaterZoneNumber(iWaterZoneRef), nil, iLandZoneSegmentSize - 0.1)
                M28Utilities.DrawLocation(tLocation, GetColourFromWaterZoneNumber(iWaterZoneRef), nil, iLandZoneSegmentSize - 0.1)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CreateWaterZones()
    --Creates each separate water zones and assign segments to each water zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)




    local iSystemTimeStart = GetSystemTimeSecondsOnlyForProfileUse()
    --local iMapSize = math.max(rMapPotentialPlayableArea[3] - rMapPotentialPlayableArea[1], rMapPotentialPlayableArea[4] - rMapPotentialPlayableArea[2])
    local iWaterZoneInterval = math.min(200, 115 + 20 * math.floor(iMapSize / 512)) --i.e. 125 for 5km, 135 for 10km, 155 for 20km, 200 for 80km (previously tried 130 + 30 * floor(size/512) but WZ were too big and caused unexpected results with air logic


    --local iMinDistanceFromFactoryBuildPosition = 100
    local iSegmentInterval = iWaterZoneInterval / iLandZoneSegmentSize
    local iStartSegment = iSegmentInterval * 0.5
    --local iEndSegmentX =
    local iMaxXIntervals = math.floor((iMaxLandSegmentX * iLandZoneSegmentSize - iStartSegment * iLandZoneSegmentSize) / iWaterZoneInterval) + 1
    local iMaxZIntervals = math.floor((iMaxLandSegmentZ * iLandZoneSegmentSize - iStartSegment * iLandZoneSegmentSize) / iWaterZoneInterval) + 1
    local iBaseSegmentX, iBaseSegmentZ
    local iPotentialZoneStartSegmentX, iPotentialZoneStartSegmentZ
    local iMaxSegmentAdjust = math.max(1, math.floor(iSegmentInterval * 0.5))
    local iCurSegmentX, iCurSegmentZ, iPotentialPond
    local bFoundForThisInterval
    --local bRecordAsWaterZone

    function GetNeighbours(iSegmentX, iSegmentZ, tBasePosition)
        --Get the adjacent segments to iSegmentX and Z, and the position of these adjacent segments (ntoe this is slightly different from the segment midpoint as it is based on tBasePosition for simplicity)
        local tTableBeforePositions = {{iSegmentX - 1, iSegmentZ, {{tBasePosition[1] - 1, 0, tBasePosition[3]}}}, {iSegmentX, iSegmentZ - 1, {{tBasePosition[1], 0, tBasePosition[3] - 1}}}, {iSegmentX, iSegmentZ + 1, {{tBasePosition[1], 0, tBasePosition[3] + 1}}}, {iSegmentX + 1, iSegmentZ, {{tBasePosition[1] + 1, 0, tBasePosition[3]}}}}
        if iLandZoneSegmentSize > 1 then --land and water zones use same segment size; if size is >1 then risk we are less detailed than navmesh so need to do more detailed calculation to ensure c orrect pathability results
            for iEntry, tSubtable in tTableBeforePositions do
                if bDebugMessages == true then LOG(sFunctionRef..': tSubtable='..repru(tSubtable)..'; tSubtable[3]='..repru(tSubtable[3])) end
                for iPositionAdjust = 2, iLandZoneSegmentSize, 1 do
                    if iEntry == 1 then
                        table.insert(tSubtable[3], {tBasePosition[1] - iPositionAdjust, 0, tBasePosition[3]})
                    elseif iEntry == 2 then
                        table.insert(tSubtable[3], {tBasePosition[1], 0, tBasePosition[3] - iPositionAdjust})
                    elseif iEntry == 3 then
                        table.insert(tSubtable[3], {tBasePosition[1], 0, tBasePosition[3] + iPositionAdjust})
                    elseif iEntry == 4 then
                        table.insert(tSubtable[3], {tBasePosition[1] + iPositionAdjust, 0, tBasePosition[3]})
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': tTableBeforePositions='..repru(tTableBeforePositions)) end
        return tTableBeforePositions
    end

    local iMaxSegmentSearchDistance = math.max(10, iWaterZoneInterval / iLandZoneSegmentSize) --NOTE: If changing this consider if also want to change the value for AssignRemainingSegmentsToLandZones
    --iMaxSegmentSearchDistance = 5 --Temp for testing
    local iBaseSegmentX, iBaseSegmentZ, iBaseLabelWanted
    local bHadSomeEntries = false
    local iMexLandZone, iMexLandLabel, bSameWaterLabel
    if bDebugMessages == true then LOG(sFunctionRef..': About to start cycling through plateaus and mexes, iLandZoneSegmentSize='..iLandZoneSegmentSize..'; iMaxSegmentSearchDistance='..iMaxSegmentSearchDistance) end
    --Cycle through every plateau
    function CycleThroughBaseTableAndRecordNearbyAreaAsSameWaterZone(tBaseTable, iMaxSearchCycle)
        --tBaseTable should contain each entry to be considered simultaneously, and be in the format {[1]={iBaseSegmentX, iBaseSegmentZ, tBasePosition, iWaterZone}, [2]={....} etc.}
        local tiAdjacentSegmentsForSearchCountByMex = {}
        local tiSegmentsByBaseTableKey = {}
        local iWaterZoneByBaseTableKey = {}
        local tbWaterZoneAlreadyConsidered = {}
        tiAdjacentSegmentsForSearchCountByMex[0] = {}
        for iEntry, tSubtable in tBaseTable do
            tiAdjacentSegmentsForSearchCountByMex[0][iEntry] = {{tSubtable[1], tSubtable[2], tSubtable[3], tSubtable[4]}}
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iStart of subfunction, iMaxSearchCycle='..iMaxSearchCycle..'; tiAdjacentSegmentsForSearchCountByMex='..repru(tiAdjacentSegmentsForSearchCountByMex)) end
        --Cycle through each base position and consider adjcent pathable segments for inclusion in the base position's zone.  Record any such segments as the base points for the next search count (so the process repeats up to iMaxSegmentSearchDistance times)
        for iSearchCount = 1, iMaxSearchCycle + 1 do --+1 since we only consider iSearchCount-1 values
            tiAdjacentSegmentsForSearchCountByMex[iSearchCount] = {}
            bHadSomeEntries = false
            for iBaseQueueCount, tiQueueEntries in tiAdjacentSegmentsForSearchCountByMex[iSearchCount-1] do --i.e. at count-1 = 0 this is each mex; each search count after that is all adjacent locations ot the previous search count entry?
                tiAdjacentSegmentsForSearchCountByMex[iSearchCount][iBaseQueueCount] = {}
                if bDebugMessages == true then LOG(sFunctionRef..': iSearchCount='..iSearchCount..'; iBaseQueueCount='..iBaseQueueCount..'; tiQueueEntries='..repru(tiQueueEntries)) end
                for iSegmentEntry, tiSegmentXZAndZone in tiQueueEntries do
                    iBaseLabelWanted = NavUtils.GetTerrainLabel('Water', tiSegmentXZAndZone[3])
                    if bDebugMessages == true then LOG(sFunctionRef..': iSegmentEntry='..iSegmentEntry..'; tiSegmentXZAndZone='..repru(tiSegmentXZAndZone)..'; iBaseLabelWanted='..(iBaseLabelWanted or 'nil')) end
                    if (iBaseLabelWanted or 0) > 0 then
                        for iNeighbourEntry, tiNeighbourXZ in GetNeighbours(tiSegmentXZAndZone[1], tiSegmentXZAndZone[2], tiSegmentXZAndZone[3]) do
                            --Check we dont already have this segment assigned to another water zone
                            if not(tbWaterZoneAlreadyConsidered[tiNeighbourXZ[1]][tiNeighbourXZ[2]]) and not(tWaterZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]]) then
                                --Check we can path to this neighbouring segment from the base segment
                                if not(tWaterZoneBySegment[tiNeighbourXZ[1]]) then tWaterZoneBySegment[tiNeighbourXZ[1]] = {} end
                                bSameWaterLabel = true
                                for iEntry, tPosition in tiNeighbourXZ[3] do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Segment XZ=X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iEntry='..iEntry..'; tPosition='..repru(tPosition)..'; Water label='..(NavUtils.GetTerrainLabel('Water', tPosition) or 'nil')..'; tiSegmentXZAndZone[4] label='..(tiSegmentXZAndZone[4] or 'nil')) end
                                    if not(NavUtils.GetTerrainLabel('Water', tPosition) == iBaseLabelWanted) then
                                        bSameWaterLabel = false
                                        break
                                    end
                                end

                                if bSameWaterLabel then
                                    --We can path here, so update the Water zone to group it with the base segment, and then record it so we consider the neighbours of this segment in the next iSearchCount
                                    --tWaterZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]] = tiSegmentXZAndZone[4]
                                    AddSegmentToWaterZone(iBaseLabelWanted, tiSegmentXZAndZone[4], tiNeighbourXZ[1], tiNeighbourXZ[2])
                                    table.insert(tiAdjacentSegmentsForSearchCountByMex[iSearchCount][iBaseQueueCount], {tiNeighbourXZ[1], tiNeighbourXZ[2],  GetPositionFromPathingSegments(tiNeighbourXZ[1], tiNeighbourXZ[2]), tiSegmentXZAndZone[4]})
                                    bHadSomeEntries = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering segment X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iCurWaterLabel='..(tiSegmentXZAndZone[4] or 'nil')..'; adding to table of valid locations, iBaseQueueCount='..iBaseQueueCount) end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have unpathable segment X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iCurWaterLabel='..(tiSegmentXZAndZone[4] or 'nil')..'; adding to table of segments that cant path to, iBaseQueueCount='..iBaseQueueCount) end
                                end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Already have water zone recorded for segment X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..' or '..(tWaterZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]] or 'nil')..'; iCurWaterLabel='..(tiSegmentXZAndZone[4] or 'nil')..'; adding to table of valid locations, iBaseQueueCount='..iBaseQueueCount) end
                            end
                        end
                    end
                end
                if bDebugMessages == true then
                    if not(bHadSomeEntries) then
                        --Didnt find any valid entries this cycle so abort
                        LOG(sFunctionRef..': No entries for iSearchCount='..iSearchCount..' so will abort further entries')
                    else
                        LOG(sFunctionRef..': Finished for iBaseQueueCount and have some more entries to consider, iSearchCount='..iSearchCount..'; iBaseQueueCount='..iBaseQueueCount..'; Size of entries to go through next='..table.getn(tiAdjacentSegmentsForSearchCountByMex[iSearchCount][iBaseQueueCount]))
                    end
                end
            end
            if not(bHadSomeEntries) then
                --Didnt find any valid entries this cycle so abort
                if bDebugMessages == true then LOG(sFunctionRef..': No entries for iSearchCount='..iSearchCount..' so will abort further entries') end
                break
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Finished for iSearchCount='..iSearchCount..' and have some more entries to consider, Size of entries to go through next='..table.getn(tiAdjacentSegmentsForSearchCountByMex[iSearchCount])) end
            end
        end
    end




    --First create a waterzone for any start positions that are underwater
    local iStartInterval = math.ceil(iSegmentInterval * 0.75)
    local tWaterZonePondAndStartSegmentsByZone = {}
    local tBaseWaterStartPositionTable = {}
    for iCurBrain, oBrain in ArmyBrains do
        if not(M28Conditions.IsCivilianBrain(oBrain)) then
            local iStartPositionX, iStartPositionZ = oBrain:GetArmyStartPos()
            local tStartPosition = {iStartPositionX, GetSurfaceHeight(iStartPositionX, iStartPositionZ), iStartPositionZ}
            if GetTerrainHeight(iStartPositionX, iStartPositionZ) < tStartPosition[2] then
                --COnfirm it is pathable by water
                if (NavUtils.GetTerrainLabel(refPathingTypeNavy, tStartPosition) or 0) > 0 then
                    RecordWaterZoneAtPosition(tStartPosition)

                    --Get the segments and include an area around this in the same water zone; area needs to be more than half of the interval for the grid based approach for water zones used later
                    iBaseSegmentX, iBaseSegmentZ = GetPathingSegmentFromPosition(tStartPosition)
                    local iPond = NavUtils.GetTerrainLabel(refPathingTypeNavy, GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ))
                    if (iPond or 0) > 0 then
                        tWaterZonePondAndStartSegmentsByZone[iTotalWaterZoneCount] = {iPond, iBaseSegmentX, iBaseSegmentZ}
                    end
                    table.insert(tBaseWaterStartPositionTable, {iBaseSegmentX, iBaseSegmentZ, tStartPosition, iTotalWaterZoneCount})
                end
            end
        end
    end
    if M28Utilities.IsTableEmpty(tBaseWaterStartPositionTable) == false then
        CycleThroughBaseTableAndRecordNearbyAreaAsSameWaterZone(tBaseWaterStartPositionTable, iMaxSegmentSearchDistance * 1.2) --want start position zone to be larger than a normal water zone
        tBaseWaterStartPositionTable = {}
    end

    --pick equally spaced apart points on the map and if are near water then create a water zone, then cycle through each of htese simultaneously assigning adjacent points to water zones
    --local tiAbortedWZSegments = {}
    for iIntervalCountX = 1, iMaxXIntervals do
        iBaseSegmentX = math.ceil(iSegmentInterval * (iIntervalCountX - 0.5))
        for iIntervalCountZ = 1, iMaxZIntervals do
            iPotentialZoneStartSegmentX = nil
            iPotentialZoneStartSegmentZ = nil
            bFoundForThisInterval = false

            iBaseSegmentZ = math.ceil(iSegmentInterval * (iIntervalCountZ - 0.5))
            if bDebugMessages == true then LOG(sFunctionRef..': iIntervalCountX='..iIntervalCountX..'; iIntervalCountZ='..iIntervalCountZ..'; iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ..' tWaterZoneBySegment[iBaseSegmentX][iBaseSegmentZ]='..(tWaterZoneBySegment[iBaseSegmentX][iBaseSegmentZ] or 'nil')) end
            if tWaterZoneBySegment[iBaseSegmentX][iBaseSegmentZ] then --redundancy
                bFoundForThisInterval = true
                iPotentialZoneStartSegmentX = nil
                iPotentialZoneStartSegmentZ = nil
                --tiAbortedWZSegments[tWaterZoneBySegment[iBaseSegmentX][iBaseSegmentZ]] = {iBaseSegmentX, iBaseSegmentZ}
                if bDebugMessages == true then LOG(sFunctionRef..': Added aborted WZ Segment for water zone '..tWaterZoneBySegment[iBaseSegmentX][iBaseSegmentZ]..'; iBaseSegmentX-Z='..iBaseSegmentX..'-'..iBaseSegmentZ) end
            else
                --See if there is anywhere near the base segment that is in a pond, and if so use this as the waterzone start point
                iPotentialPond = NavUtils.GetTerrainLabel(refPathingTypeNavy, GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ))
                if (iPotentialPond or 0) > 0 then
                    iPotentialZoneStartSegmentX = iBaseSegmentX
                    iPotentialZoneStartSegmentZ = iBaseSegmentZ
                else
                    --Search nearby in intervals of 20, up to 80 (adjusted for segment size)
                    for iAdjustBase = 1, iMaxSegmentAdjust do
                        for iCurSegmentX = math.max(1, iBaseSegmentX - iAdjustBase), math.min(iMaxLandSegmentX, iBaseSegmentX + iAdjustBase) do
                            for iCurSegmentZ = math.max(1, iBaseSegmentZ - iAdjustBase), math.min(iMaxLandSegmentZ, iBaseSegmentZ + iAdjustBase) do
                                if tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] then --redundancy
                                    bFoundForThisInterval = true
                                    iPotentialZoneStartSegmentX = nil
                                    iPotentialZoneStartSegmentZ = nil
                                    break
                                else
                                    iPotentialPond = NavUtils.GetTerrainLabel(refPathingTypeNavy, GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ))
                                    if (iPotentialPond or 0) > 0 then
                                        bFoundForThisInterval = true
                                        iPotentialZoneStartSegmentX = iCurSegmentX
                                        iPotentialZoneStartSegmentZ = iCurSegmentZ
                                        break
                                    end
                                end
                            end
                            if bFoundForThisInterval then break end
                        end
                        if bFoundForThisInterval then break end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for potential point for water zone for iIntervalCountX='..iIntervalCountX..'; iIntervalCountZ='..iIntervalCountZ..'; iPotentialZoneStartSegmentX='..(iPotentialZoneStartSegmentX or 'nil')..'; iPotentialZoneStartSegmentZ='..(iPotentialZoneStartSegmentZ or 'nil')) end

            if iPotentialZoneStartSegmentX then
                --Below was to not record near a start position, but on reflection will just let start positiosn be on the edge of a water zone, to keep things simple for now
                local tSegmentPosition = GetPositionFromPathingSegments(iPotentialZoneStartSegmentX, iPotentialZoneStartSegmentZ)

                --Have found a segment that is on water, record this as a waterzone unless it is close to a factory
                --bRecordAsWaterZone = true

                --[[if M28Utilities.IsTableEmpty(tPondDetails[iPotentialPond][subrefBuildLocationByStartPosition]) == false then
                for iArmyIndex, tBuildPosition in tPondDetails[iPotentialPond][subrefBuildLocationByStartPosition] do
                    if M28Utilities.GetDistanceBetweenPositions(tSegmentPosition, tBuildPosition) <= iMinDistanceFromFactoryBuildPosition then
                        bRecordAsWaterZone = false
                        break
                    end
                end
            end--]]
                --if bRecordAsWaterZone then
                RecordWaterZoneAtPosition(tSegmentPosition)
                table.insert(tBaseWaterStartPositionTable, {iPotentialZoneStartSegmentX, iPotentialZoneStartSegmentZ, tSegmentPosition, iTotalWaterZoneCount})
                --end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished recording the first segment for each water zone, will now check for any ponds that lack a water zone') end

    --Now go through any ponds that dont have a water zone and create one
    for iPond, tPondSubtable in tPondDetails do
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if pond '..iPond..' has any water zones, is table of water zones empty='..tostring(M28Utilities.IsTableEmpty(tPondSubtable[subrefPondWaterZones]))..'; tPondSubtable[subrefiSegmentCount]='..(tPondSubtable[subrefiSegmentCount] or 'nil')) end
        if M28Utilities.IsTableEmpty(tPondSubtable[subrefPondWaterZones]) and tPondSubtable[subrefiSegmentCount] > 0 then
            iPotentialZoneStartSegmentX = tPondSubtable[subreftiWaterSegmentXZ][1][1]
            iPotentialZoneStartSegmentZ = tPondSubtable[subreftiWaterSegmentXZ][1][2]
            if not(tWaterZoneBySegment[iPotentialZoneStartSegmentX][iPotentialZoneStartSegmentZ]) then
                if bDebugMessages == true then LOG(sFunctionRef..': About to record a water zone using iPotentialZoneStartSegmentX-Z='..(iPotentialZoneStartSegmentX or 'nil')..'-'..(iPotentialZoneStartSegmentZ or 'nil')..'; water zone for this (hopefully shoudl be nil)='..(tWaterZoneBySegment[iPotentialZoneStartSegmentX][iPotentialZoneStartSegmentZ] or 'nil')) end
                local tPosition = GetPositionFromPathingSegments(iPotentialZoneStartSegmentX, iPotentialZoneStartSegmentZ)
                RecordWaterZoneAtPosition(tPosition)
                table.insert(tBaseWaterStartPositionTable, {iPotentialZoneStartSegmentX, iPotentialZoneStartSegmentZ, tPosition, iTotalWaterZoneCount})
            end
        end
    end
    if M28Utilities.IsTableEmpty(tBaseWaterStartPositionTable) == false then
        CycleThroughBaseTableAndRecordNearbyAreaAsSameWaterZone(tBaseWaterStartPositionTable, iMaxSegmentSearchDistance * 2) --done x2 so we keep searching (e.g. for narrow water paths where we didnt have an interval Water nearby) - in most cases would expect to stop much sooner than this
        tBaseWaterStartPositionTable = {}
    end

    --Go through all segments on map and ensure any water ones are assigned
    for iCurSegmentX = 1, iMaxLandSegmentX do
        for iCurSegmentZ = 1, iMaxLandSegmentZ do
            if not(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]) and not(tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ]) then
                local tSegmentPosition = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                if (NavUtils.GetTerrainLabel('Water', tSegmentPosition) or 0) > 0 then
                    RecordWaterZoneAtPosition(tSegmentPosition)
                    table.insert(tBaseWaterStartPositionTable, {iCurSegmentX, iCurSegmentZ, tSegmentPosition, iTotalWaterZoneCount})
                    CycleThroughBaseTableAndRecordNearbyAreaAsSameWaterZone(tBaseWaterStartPositionTable, iMaxSegmentSearchDistance) --done x2 so we keep searching (e.g. for narrow water paths where we didnt have an interval Water nearby) - in most cases would expect to stop much sooner than this
                    tBaseWaterStartPositionTable = {}
                end
            end
        end
    end



    if bDebugMessages == true then LOG(sFunctionRef..': End of code, finished recording segments in water zone, iTotalWaterZoneRecordedSegmentCount='..iTotalWaterZoneRecordedSegmentCount..'; iTotalSegmentsInPonds='..iTotalSegmentsInPonds..'; iTotalWaterZoneCount='..iTotalWaterZoneCount..'; will draw all water zones. Time taken to run water zone logic='..GetSystemTimeSecondsOnlyForProfileUse() - iSystemTimeStart) end
    if iTotalWaterZoneRecordedSegmentCount < iTotalSegmentsInPonds then
        M28Utilities.ErrorHandler('May not have assigned every water segment a water zone - consider adding code to go through every pond water segment as backup')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SetupWaterZones()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTotalWaitTime = 0
    --Allow up to 1s to setup preferred pond location, otherwise iwll just create water zones ignoring preferred factory build locations
    while not(bHaveConsideredPreferredPondForM28AI) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        iTotalWaitTime = iTotalWaitTime + 1
        if iTotalWaitTime >= 50 then M28Utilities.ErrorHandler('Havent setup preferred factory locations yet, will proceed with water zone creation anyway') break end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': About to start with creating water zones, is tPondDetails empty='..tostring(M28Utilities.IsTableEmpty(tPondDetails))..'; GameTime='..GetGameTimeSeconds()..'; System time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    if M28Utilities.IsTableEmpty(tPondDetails) == false then
        CreateWaterZones()
        if bDebugMessages == true then
            LOG(sFunctionRef..': Finished running CreateWaterZones, Systemtime='..GetSystemTimeSecondsOnlyForProfileUse()..'; will draw water zones now')
            DrawWaterZones()
        end



        RecordWaterZoneMidpointAndMinMaxPositions()
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording water zone midpoint etc., system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
        RecordHydroInWaterZones()
        RecordWaterZoneAdjacentLandZones()
        RecordAdjacentWaterZones()
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording adjacency for land zones vs water zones, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
        RecordWaterZonePathingToOtherWaterZones()
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording water zone pathing to other water zones, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
        RecordWaterZonePatrolPaths()
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording water zone patrol paths for land scouts, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    end
    bWaterZoneInitialCreation = true
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end



function RecordWaterZoneMidpointAndMinMaxPositions()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordWaterZoneMidpointAndMinMaxPositions'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iMinX, iMaxX, iMinZ, iMaxZ, iAveragePond, iAverageWaterZone
    local iMinSegmentX, iMinSegmentZ, iMaxSegmentX, iMaxSegmentZ
    local iAverageSegmentX, iAverageSegmentZ
    local iAveragePlateau
    for iPond, tPondSubtable in tPondDetails do
        --Go through any mexes near a pond, and record against a waterzone if they're in water
        if M28Utilities.IsTableEmpty(tPondSubtable[subrefPondMexInfo]) == false then
            local iMexWaterZone, iMexPond
            for iMex, tSubtable in  tPondSubtable[subrefPondMexInfo] do
                local tMex = tSubtable[subrefMexLocation]
                iMexWaterZone = GetWaterZoneFromPosition(tMex)
                if (iMexWaterZone or 0) > 0 then
                    iMexPond = tiPondByWaterZone[iMexWaterZone]
                    AddMexToWaterZone(iMexPond, iMexWaterZone, tMex)
                    if bDebugMessages == true then LOG(sFunctionRef..': Just added mex at position '..repru(tMex)..' to iMexWaterZone='..iMexWaterZone) end
                end
            end
        end

        for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
            --Record min and max values
            iMinX = 100000
            iMinZ = 100000
            iMaxX = 0
            iMaxZ = 0
            iMinSegmentX = 100000
            iMinSegmentZ = 100000
            iMaxSegmentX = 0
            iMaxSegmentZ = 0

            for iEntry, tiSegmentXZ in tWZData[subrefWZSegments] do
                iMinSegmentX = math.min(tiSegmentXZ[1], iMinSegmentX)
                iMinSegmentZ = math.min(tiSegmentXZ[2], iMinSegmentZ)
                iMaxSegmentX = math.max(tiSegmentXZ[1], iMaxSegmentX)
                iMaxSegmentZ = math.max(tiSegmentXZ[2], iMaxSegmentZ)
            end
            local tMinPos = GetPositionFromPathingSegments(iMinSegmentX, iMinSegmentZ)
            local tMaxPos = GetPositionFromPathingSegments(iMaxSegmentX, iMaxSegmentZ)
            iMinX = tMinPos[1]
            iMinZ = tMinPos[3]
            iMaxX = tMaxPos[1]
            iMaxZ = tMaxPos[3]
            tWZData[subrefWZMinSegX] = iMinSegmentX
            tWZData[subrefWZMinSegZ] = iMinSegmentZ
            tWZData[subrefWZMaxSegX] = iMaxSegmentX
            tWZData[subrefWZMaxSegZ] = iMaxSegmentZ

            --Record midpoint
            local tAverage = {(iMinX + iMaxX)*0.5, 0, (iMinZ + iMaxZ) * 0.5}
            iAveragePond = NavUtils.GetTerrainLabel(refPathingTypeNavy, tAverage)

            iAverageSegmentX, iAverageSegmentZ = GetPathingSegmentFromPosition(tAverage)
            iAverageWaterZone = tWaterZoneBySegment[iAverageSegmentX][iAverageSegmentZ]
            iAveragePlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, tAverage)


            --Move the midpoint if nav utils doesnt work for this position (to reduce the amount of grief we might have later)
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Considering iWaterZone=' .. iWaterZone .. '; MinX=' .. iMinX .. 'Z' .. iMinZ .. '; iMaxX' .. iMaxX .. 'Z' .. iMaxZ .. '; iMinSegmentX=' .. iMinSegmentX .. 'Z' .. iMinSegmentZ .. '; iMaxSegmentX=' .. iMaxSegmentX .. iMaxSegmentZ..'; iAveragePlateau='..(iAveragePlateau or 'nil'))
            end

            if not (iPond == iAveragePond) or not (iAverageWaterZone == iWaterZone) or not(iAveragePlateau) then
                local tAltMidpoint
                local iAdjustedSegmentX, iAdjustedSegmentZ
                local bHaveValidAltMidpoint = false
                for iAdjust = 1, 50 do
                    for iXAdjust = -iAdjust, iAdjust, 1 do
                        for iZAdjust = -iAdjust, iAdjust, 1 do
                            if not (iXAdjust == 0 and iZAdjust == 0) then
                                iAdjustedSegmentX = iAverageSegmentX + iAdjust * iXAdjust
                                iAdjustedSegmentZ = iAverageSegmentZ + iAdjust * iZAdjust
                                if iAdjustedSegmentX > 0 and iAdjustedSegmentZ > 0 then
                                    iAverageWaterZone = tWaterZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ]
                                    if iAverageWaterZone == iWaterZone then
                                        tAltMidpoint = GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Considering adjusted segment X-Z=' .. iAdjustedSegmentX .. '-' .. iAdjustedSegmentZ .. '; with water zone ' .. tWaterZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ] .. '; tAltMidpoint=' .. repru(tAltMidpoint) .. '; Pond from navutils=' .. (NavUtils.GetTerrainLabel(refPathingTypeNavy, tAltMidpoint) or 'nil')..'; Plateau='..(NavUtils.GetTerrainLabel(refPathingTypeHover, tAltMidpoint)))
                                        end
                                        if NavUtils.GetTerrainLabel(refPathingTypeNavy, tAltMidpoint) == iPond and (NavUtils.GetTerrainLabel(refPathingTypeHover, tAltMidpoint) or 0) > 0 then

                                            --Have a valid midpoint; as this is water, see whether if we move further in the adjust direction we can still have a vlid point (so we arent as likely to be on the shore/by a cliff):
                                            local iXNewAdjust = 0
                                            local iZNewAdjust = 0
                                            local iXSizeAdjust = math.ceil(10 / iLandZoneSegmentSize)
                                            local iZSizeAdjust = math.ceil(10 / iLandZoneSegmentSize)
                                            if math.abs(iXAdjust) >= 10 then
                                                iXSizeAdjust = iXSizeAdjust * 2
                                            end
                                            if math.abs(iZAdjust) >= 10 then
                                                iZSizeAdjust = iZSizeAdjust * 2
                                            end
                                            if iXAdjust < 0 then
                                                iXNewAdjust = -iXSizeAdjust
                                            elseif iXAdjust > 0 then
                                                iXNewAdjust = iXSizeAdjust
                                            end
                                            if iZNewAdjust < 0 then
                                                iZNewAdjust = -iZSizeAdjust
                                            elseif iZNewAdjust > 0 then
                                                iZNewAdjust = iZSizeAdjust
                                            end
                                            local tAdjustedPosition = GetPositionFromPathingSegments(iAdjustedSegmentX + iXNewAdjust, iAdjustedSegmentZ + iZNewAdjust)
                                            if tWaterZoneBySegment[iAdjustedSegmentX + iXNewAdjust][iAdjustedSegmentZ + iZNewAdjust] == iAverageWaterZone and NavUtils.GetTerrainLabel(refPathingTypeNavy, tAdjustedPosition) == iPond and (NavUtils.GetTerrainLabel(refPathingTypeHover, tAdjustedPosition) or 0) > 0 then
                                                if bDebugMessages == true then
                                                    LOG(sFunctionRef .. ': Will go with adjusted segment value, tAltMidpoint before adjust=' .. repru(tAltMidpoint) .. '; tAltMidpoint after adjust=' .. repru(GetPositionFromPathingSegments(iAdjustedSegmentX + iXNewAdjust, iAdjustedSegmentZ + iZNewAdjust)) .. '; iXNewAdjust=' .. iXNewAdjust .. '; iZNewAdjust=' .. iZNewAdjust)
                                                end
                                                tAltMidpoint = GetPositionFromPathingSegments(iAdjustedSegmentX + iXNewAdjust, iAdjustedSegmentZ + iZNewAdjust)
                                            end

                                            bHaveValidAltMidpoint = true
                                            iAveragePond = iPond
                                            tAverage = { tAltMidpoint[1], tAltMidpoint[2], tAltMidpoint[3] }
                                            if bDebugMessages == true then
                                                LOG(sFunctionRef .. ': Have valid alternative midpoint which will now record and use, tAverage after update=' .. repru(tAverage) .. '; will see if can adjust slightly to be more in the water')
                                            end
                                            break
                                        end
                                    elseif bDebugMessages == true then
                                        LOG(sFunctionRef .. ': Adjusted semgnet X-Z=' .. iAdjustedSegmentX .. '-' .. iAdjustedSegmentZ .. '; didnt have the right Water zone, was ' .. (tWaterZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ] or 'nil') .. '; will draw segment midpoint in red if its in playaable area')
                                        local tAltLocation = GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)
                                        if tAltLocation and tAltLocation[1] > rMapPotentialPlayableArea[1] and tAltLocation[1] < rMapPotentialPlayableArea[3] and tAltLocation[3] > rMapPotentialPlayableArea[2] and tAltLocation[3] < rMapPotentialPlayableArea[4] then
                                            M28Utilities.DrawLocation(tAltLocation, 2)
                                        end
                                    end
                                end
                            end
                        end
                        if bHaveValidAltMidpoint then
                            break
                        end
                    end
                    if bHaveValidAltMidpoint then
                        break
                    end
                end

                --If still dont have a valid location, then just try any segment recorded in the land zone (this wont be in the middle of the land zone, but is better than having an unpathable midpoint)
                if not (bHaveValidAltMidpoint) then
                    for iSegment, tSegmentXZ in tWZData[subrefWZSegments] do
                        if tWaterZoneBySegment[tSegmentXZ[1]][tSegmentXZ[2]] == iWaterZone then
                            tAltMidpoint = GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Cycling through recorded segments for this LZ, and considering segment X-Z=' .. tSegmentXZ[1] .. '-' .. tSegmentXZ[2] .. '; with land zone ' .. tLandZoneBySegment[tSegmentXZ[1]][tSegmentXZ[2]] .. '; tAltMidpoint=' .. repru(tAltMidpoint) .. '; Plateau from navutils=' .. (NavUtils.GetTerrainLabel(refPathingTypeHover, tAltMidpoint) or 'nil') .. '; Island from navutils=' .. (NavUtils.GetTerrainLabel(refPathingTypeLand, tAltMidpoint) or 'nil'))
                            end
                            if NavUtils.GetTerrainLabel(refPathingTypeNavy, tAltMidpoint) == iPond then
                                bHaveValidAltMidpoint = true
                                iAveragePond = NavUtils.GetTerrainLabel(refPathingTypeNavy, tAltMidpoint)
                                tAverage = { tAltMidpoint[1], tAltMidpoint[2], tAltMidpoint[3] }
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': Have valid alternative midpoint which will now record and use, tAverage after update=' .. repru(tAverage))
                                end
                                break
                            end
                        end
                    end
                    if not (bHaveValidAltMidpoint) then
                        M28Utilities.ErrorHandler(' dont have valid midpoint even after checking every water zone segment for iPond=' .. iPond .. '; will just use the first WZSegment')
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': iWaterZone=' .. iWaterZone .. '; tWZData[subrefWZSegments]=' .. repru(tWZData[subrefWZSegments] or 'nil') .. '; First segment position=' .. repru(GetPositionFromPathingSegments(tWZData[subrefWZSegments][1][1], tWZData[subrefWZSegments][1][2])) .. '; playable area=' .. repru(rMapPotentialPlayableArea) .. '; GetTerrainLabel navy pathing result for the first segment position=' .. (NavUtils.GetTerrainLabel(refPathingTypeNavy, GetPositionFromPathingSegments(tWZData[subrefWZSegments][1][1], tWZData[subrefWZSegments][1][2])) or 'nil') .. '; water zone of this segment position=' .. (tWaterZoneBySegment[tWZData[subrefWZSegments][1][1]][tWZData[subrefWZSegments][1][2]] or 'nil') .. '; will draw the water zone')
                            DrawSpecificWaterZone(iWaterZone, math.random(1, 8))
                        end
                    end
                end
            end

            --Campaign override - change midpoint if outside playable area but zone itself isnt
            if bDebugMessages == true then LOG(sFunctionRef..': Is this a campaign map='..tostring(bIsCampaignMap or false)..'; Playable area='..repru(rMapPlayableArea)..'; tverage='..repru(tAverage)..'; is this in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAverage))) end
            if bIsCampaignMap and not(M28Conditions.IsLocationInPlayableArea(tAverage)) then
                --Are we likely in the playable area?
                if ((iMinX >= rMapPlayableArea[1] and iMinX <= rMapPlayableArea[3]) or (iMaxX >= rMapPlayableArea[1] and iMaxX <= rMapPlayableArea[3])) and ((iMinZ >= rMapPlayableArea[2] and iMinZ <= rMapPlayableArea[4]) or (iMaxZ >= rMapPlayableArea[2] and iMaxZ <= rMapPlayableArea[4])) then
                    --Cycle through each segment in water zone and record the one closest to the current average
                    local iMinPlayableSegmentX, iMinPlayableSegmentZ = GetPathingSegmentFromPosition({rMapPlayableArea[1], 0, rMapPlayableArea[2]})
                    iMinPlayableSegmentX = iMinPlayableSegmentX  +1
                    iMinPlayableSegmentZ = iMinPlayableSegmentZ + 1
                    local iMaxPlayableSegmentX, iMaxPlayableSegmentZ = GetPathingSegmentFromPosition({rMapPlayableArea[3], 0, rMapPlayableArea[4]})
                    iMaxPlayableSegmentX = iMaxPlayableSegmentX - 1
                    iMaxPlayableSegmentZ = iMaxPlayableSegmentZ - 1
                    local iOriginalMidpointSegmentX, iOriginalMidpointSegmentZ = GetPathingSegmentFromPosition(tAverage)
                    local iLowestDif = 100000
                    local iCurDif
                    local iClosestSegmentX, iClosestSegmentZ
                    for iEntry, tSegmentXZ in tWZData[subrefWZSegments] do
                        if tSegmentXZ[1] >= iMinPlayableSegmentX and tSegmentXZ[1] <= iMaxPlayableSegmentX and tSegmentXZ[2] >= iMinPlayableSegmentZ and tSegmentXZ[2] <= iMaxPlayableSegmentZ then
                            iCurDif = math.abs(tSegmentXZ[1] - iOriginalMidpointSegmentX) + math.abs(tSegmentXZ[2] - iOriginalMidpointSegmentZ)
                            if iCurDif < iLowestDif then
                                iLowestDif = iCurDif
                                iClosestSegmentX = tSegmentXZ[1]
                                iClosestSegmentZ = tSegmentXZ[2]
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iLowestDif='..iLowestDif..'; iClosestSegmentXZ='..(iClosestSegmentX or 'nil')..'Z'..(iClosestSegmentZ or 'nil')) end
                    if iClosestSegmentX then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will move the midpoint for the water zone to reflect the playable area, previous location='..repru(tAverage)..'; New location='..repru(GetPositionFromPathingSegments(iClosestSegmentX, iClosestSegmentZ))..'; Playable area='..repru(rMapPlayableArea)) end
                        local tNewLocation = GetPositionFromPathingSegments(iClosestSegmentX, iClosestSegmentZ)
                        tAverage = {tNewLocation[1], tNewLocation[2], tNewLocation[3]}
                    end
                end
            end

            if bDebugMessages == true then
                LOG(sFunctionRef .. ': iAveragePond=' .. (iAveragePond or 'nil') .. '; iPond=' .. (iPond or 'nil') .. '; iAverageWaterZone=' .. (iAverageWaterZone or 'nil') .. '; iWaterZone=' .. (iWaterZone or 'nil') .. '; tAverage=' .. repru(tAverage))
            end
            if (iAveragePond == iPond and iAverageWaterZone == iWaterZone) then
                tWZData[subrefMidpoint] = { tAverage[1], tAverage[2], tAverage[3] }
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Will use the average position as the midpoint, tWZData[subrefMidpoint] for iWaterZone '..iWaterZone..'='..repru(tWZData[subrefMidpoint])..'; iPond='..iPond..'; Pond by water zone='..(tiPondByWaterZone[iWaterZone] or 'nil'))
                end
            else
                --Just use the first recorded segment of the water zone as the midpoint
                tWZData[subrefMidpoint] = GetPositionFromPathingSegments(tWZData[subrefWZSegments][1][1], tWZData[subrefWZSegments][1][2])
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': WIll use the first recorded segment as the midpoint, tWZData[subrefMidpoint]=' .. repru(tWZData[subrefMidpoint]))
                end
            end
            tWZData[refiMidpointAmphibiousLabel] = (NavUtils.GetTerrainLabel(refPathingTypeAmphibious, tWZData[subrefMidpoint]) or 0)
            if bDebugMessages == true then
                DrawSpecificWaterZone(iWaterZone, nil, 60)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordWaterZoneAdjacentLandZones()
    --Update land zones with details of adjacent water zones, and update water zones wit hdetails of adjacent land zones
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordWaterZoneAdjacentLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iPlateau
    local iSegmentGapAllowed = math.max(3, math.ceil(24 / iLandZoneSegmentSize))
    local iDistBetweenMidpoints, iMaxLineInterval, iLineAngle, iCurLineSegmentX, iCurLineSegmentZ
    local iLineInterval = iLandZoneSegmentSize
    local tLinePosition
    local bIsAdjacent
    local iAdjacencyTablePosition
    local iBaseIntervalIgnoreThreshold = 3
    local iCloseIntervalIgnoreThreshold = 6
    local iActualIntervalIgnoreThreshold
    local iCurIntervalIgnoreCount --i.e. if we are moving from one midpoint to another, and come across a different land or water zone, it increases the ignorecount by 1 if the midpoints aren't too far apart

    for iPond, tPondSubtable in tPondDetails do
        for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do

            iPlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, tWZData[subrefMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iWaterZone='..iWaterZone..'; iPlateau='..(iPlateau or 'nil')..'; Is plateau data empty='..tostring(M28Utilities.IsTableEmpty(tAllPlateaus[(iPlateau or -1)]))) end
            if (iPlateau or 0) > 0 and M28Utilities.IsTableEmpty(tAllPlateaus[iPlateau]) == false then
                --Cycle through every land zone on the map, and check if it is near this
                for iLandZone, tLZData in tAllPlateaus[iPlateau][subrefPlateauLandZones] do
                    --Is this land zone adjacent? Might be adjacent the following are both the case:
                    --LZMinX is >= WZMinX and <=WZMaxX; or LZMaxX is >= WZMinX and <=WZMaxX
                    --As above but for Z
                    --Hover want to have a small tolerance for cliffs etc
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if land zone '..iLandZone..' is near the water zone; iSegmentGapAllowed='..iSegmentGapAllowed..'; tLZData[subrefLZMinSegX]='..tLZData[subrefLZMinSegX]..'; tWZData[subrefWZMinSegX]='..tWZData[subrefWZMinSegX]..'; tWZData[subrefWZMaxSegX]='..tWZData[subrefWZMaxSegX]..'; tLZData[subrefLZMaxSegX]='..tLZData[subrefLZMaxSegX]..'; tLZData[subrefLZMinSegZ]='..tLZData[subrefLZMinSegZ]..'; tWZData[subrefWZMinSegZ]='..tWZData[subrefWZMinSegZ]..'; tWZData[subrefWZMaxSegZ]='..tWZData[subrefWZMaxSegZ]..'; tLZData[subrefLZMaxSegZ]='..tLZData[subrefLZMaxSegZ]) end
                    if (tLZData[subrefLZMinSegX] + iSegmentGapAllowed >= tWZData[subrefWZMinSegX] and tLZData[subrefLZMinSegX] - iSegmentGapAllowed <= tWZData[subrefWZMaxSegX]) or (tLZData[subrefLZMaxSegX] + iSegmentGapAllowed >= tWZData[subrefWZMinSegX] and tLZData[subrefLZMaxSegX] - iSegmentGapAllowed <= tWZData[subrefWZMaxSegX])
                            and (tLZData[subrefLZMinSegZ] + iSegmentGapAllowed >= tWZData[subrefWZMinSegZ] and tLZData[subrefLZMinSegZ] - iSegmentGapAllowed <= tWZData[subrefWZMaxSegZ]) or (tLZData[subrefLZMaxSegZ] + iSegmentGapAllowed >= tWZData[subrefWZMinSegZ] and tLZData[subrefLZMaxSegZ] - iSegmentGapAllowed <= tWZData[subrefWZMaxSegZ]) then
                        --It looks like we might overlap, do a more precise calculation drawing a line from the two midpoints to see if we come across other land zones
                        bIsAdjacent = false
                        iDistBetweenMidpoints = M28Utilities.GetDistanceBetweenPositions(tWZData[subrefMidpoint], tLZData[subrefMidpoint])
                        iMaxLineInterval = math.floor(iDistBetweenMidpoints / iLineInterval) * iLineInterval
                        iLineAngle = M28Utilities.GetAngleFromAToB(tWZData[subrefMidpoint], tLZData[subrefMidpoint])
                        if iDistBetweenMidpoints <= 150 then
                            if iDistBetweenMidpoints <= 75 then iActualIntervalIgnoreThreshold = iCloseIntervalIgnoreThreshold
                            else iActualIntervalIgnoreThreshold = iBaseIntervalIgnoreThreshold
                            end
                        else
                            iActualIntervalIgnoreThreshold = 0
                        end
                        iCurIntervalIgnoreCount = 0
                        if bDebugMessages == true then LOG(sFunctionRef..': Have land zone that is close to a ater zone, checking if we cross other land zones when going from one to the other, iDistBetweenMidpoints='..iDistBetweenMidpoints..'; iMaxLineInterval='..iMaxLineInterval..'; iLineAngle='..iLineAngle) end
                        for iDistAlongLine = iLineInterval, iMaxLineInterval, iLineInterval do
                            tLinePosition = M28Utilities.MoveInDirection(tWZData[subrefMidpoint], iLineAngle, iDistAlongLine, false, false, false)
                            iCurLineSegmentX, iCurLineSegmentZ = GetPathingSegmentFromPosition(tLinePosition)
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': tLinePosition='..repru(tLinePosition)..'; iCurLineSegmentX='..(iCurLineSegmentX or 'nil')..'; iCurLineSegmentZ='..(iCurLineSegmentZ or 'nil')..'; tLandZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ]='..(tLandZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ] or 'nil')..'; tWaterZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ]='..(tWaterZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ] or 'nil')..'; iCurIntervalIgnoreCount='..iCurIntervalIgnoreCount..'; iActualIntervalIgnoreThreshold='..iActualIntervalIgnoreThreshold..'; Will draw this location')
                                M28Utilities.DrawLocation(tLinePosition, nil, 200)
                            end
                            if tLandZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ] then
                                if tLandZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ] == iLandZone then
                                    bIsAdjacent = true
                                    break
                                else
                                    --Not adjacent as is another land zone inbetween
                                    iCurIntervalIgnoreCount = iCurIntervalIgnoreCount + 1
                                    if iCurIntervalIgnoreCount > iActualIntervalIgnoreThreshold then
                                        break
                                    end
                                end
                            elseif tWaterZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ] then
                                if not(tWaterZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ] == iWaterZone) then
                                    --not adjacent as is another water zone inbetween
                                    iCurIntervalIgnoreCount = iCurIntervalIgnoreCount + 1
                                    if iCurIntervalIgnoreCount > iActualIntervalIgnoreThreshold then
                                        break
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': bIsAdjacent='..tostring(bIsAdjacent)) end
                        if bIsAdjacent then
                            --Record water zone as adjacent to land zone
                            iAdjacencyTablePosition = 1
                            if M28Utilities.IsTableEmpty(tLZData[subrefAdjacentWaterZones]) then
                                tLZData[subrefAdjacentWaterZones] = {}
                            else
                                for iEntry, tAdjacencySubtable in tLZData[subrefAdjacentWaterZones] do
                                    if tAdjacencySubtable[subrefAWZDistance] < iDistBetweenMidpoints then
                                        iAdjacencyTablePosition = iEntry + 1
                                    else
                                        --Since table is ordered by distance later entries should be furhter away
                                        break
                                    end
                                end
                            end
                            table.insert(tLZData[subrefAdjacentWaterZones], iAdjacencyTablePosition, {[subrefAWZRef] = iWaterZone, [subrefAWZDistance] = iDistBetweenMidpoints})
                            if bDebugMessages == true then LOG(sFunctionRef..': Added iWaterZone='..iWaterZone..' as being adjacent to iLandZone='..iLandZone..'; tLZData[subrefAdjacentWaterZones]='..repru(tLZData[subrefAdjacentWaterZones])) end

                            --Record land zone as adjacent to water zone
                            iAdjacencyTablePosition = 1
                            if M28Utilities.IsTableEmpty(tWZData[subrefAdjacentLandZones]) then
                                tWZData[subrefAdjacentLandZones] = {}
                            else
                                for iEntry, tAdjacencySubtable in tWZData[subrefAdjacentLandZones] do
                                    if tAdjacencySubtable[subrefALZDistance] < iDistBetweenMidpoints then
                                        iAdjacencyTablePosition = iEntry + 1
                                    else
                                        --Since table is ordered by distance later entries should be furhter away
                                        break
                                    end
                                end
                            end
                            if not(iPlateau) then M28Utilities.ErrorHandler('Have a nil plateau for iLandZone='..(iLandZone or 'nil')) end
                            table.insert(tWZData[subrefAdjacentLandZones], iAdjacencyTablePosition, {[subrefWPlatAndLZNumber] = {iPlateau, iLandZone}, [subrefALZDistance] = iDistBetweenMidpoints})
                        end
                    end

                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished recording adjacent water zones for iWaterZone='..iWaterZone..'; tWZData[subrefAdjacentLandZones]='..repru(tWZData[subrefAdjacentLandZones])) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordWaterZonePathingToOtherWaterZones()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordWaterZonePathingToOtherWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tiWaterZonePairsConsideredByLowestWZ = {}
    local iLowestWZ, iHighestWZ
    local iNavalTravelDistance
    local iStartWZAdjacencyTablePosition
    local iEndWZAdjacencyTablePosition
    for iPond, tPondSubtable in tPondDetails do
        for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
            --Cycle through each other water zone in this pond and determine pathing
            for iOtherWaterZone, tOtherWZData in tPondSubtable[subrefPondWaterZones] do
                if not(iWaterZone == iOtherWaterZone) then
                    if iWaterZone < iOtherWaterZone then
                        iLowestWZ = iWaterZone
                        iHighestWZ = iOtherWaterZone
                    else
                        iLowestWZ = iOtherWaterZone
                        iHighestWZ = iWaterZone
                    end
                    if not(tiWaterZonePairsConsideredByLowestWZ[iLowestWZ][iHighestWZ]) then
                        if not(tiWaterZonePairsConsideredByLowestWZ[iLowestWZ]) then tiWaterZonePairsConsideredByLowestWZ[iLowestWZ] = {} end
                        iNavalTravelDistance = M28Utilities.GetTravelDistanceBetweenPositions(tWZData[subrefMidpoint], tOtherWZData[subrefMidpoint], refPathingTypeNavy)
                        if iNavalTravelDistance then
                            iStartWZAdjacencyTablePosition = 1
                            if M28Utilities.IsTableEmpty(tWZData[subrefWZOtherWaterZones]) then
                                tWZData[subrefWZOtherWaterZones] = {}
                            else
                                for iEntry, tAdjacencySubtable in tWZData[subrefWZOtherWaterZones] do
                                    if tAdjacencySubtable[subrefWZAWZDistance] < iNavalTravelDistance then
                                        iStartWZAdjacencyTablePosition = iEntry + 1
                                    else
                                        --Since table is ordered by distance later entries should be furhter away
                                        break
                                    end
                                end
                            end
                            table.insert(tWZData[subrefWZOtherWaterZones], iStartWZAdjacencyTablePosition, {[subrefWZAWZRef] = iOtherWaterZone, [subrefWZAWZDistance] = iNavalTravelDistance})

                            iEndWZAdjacencyTablePosition = 1
                            if M28Utilities.IsTableEmpty(tOtherWZData[subrefWZOtherWaterZones]) then
                                tOtherWZData[subrefWZOtherWaterZones] = {}
                            else
                                for iEntry, tAdjacencySubtable in tOtherWZData[subrefWZOtherWaterZones] do
                                    if tAdjacencySubtable[subrefWZAWZDistance] < iNavalTravelDistance then
                                        iEndWZAdjacencyTablePosition = iEntry + 1
                                    else
                                        --Since table is ordered by distance later entries should be furhter away
                                        break
                                    end
                                end
                            end
                            table.insert(tOtherWZData[subrefWZOtherWaterZones], iEndWZAdjacencyTablePosition, {[subrefWZAWZRef] = iWaterZone, [subrefWZAWZDistance] = iNavalTravelDistance})

                            tiWaterZonePairsConsideredByLowestWZ[iLowestWZ][iHighestWZ] = true
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished considering all pathing for iWaterZone='..iWaterZone..'; tiWaterZonePairsConsideredByLowestWZ='..repru(tiWaterZonePairsConsideredByLowestWZ)..'; tWZData[subrefWZOtherWaterZones]='..repru(tWZData[subrefWZOtherWaterZones])) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SetupMap()
    --Sets up non-brain specific info on the map
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupMap'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Send a message warning players this could take a while - moved to M28Overseer
    --[[for iBrain, oBrain in ArmyBrains do
        if oBrain.M28AI then
            M28Chat.SendForkedMessage(oBrain, 'LoadingMap', 'Analysing map, this usually takes 1-2 minutes...', 0, 10000, false)
        end
    end--]]

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(4) --So chat message displays
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Decide how accurate map related functions are to be based on the map size:
    SetupPlayableAreaAndSegmentSizes()

    --Generate pathing
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; system time='..GetSystemTimeSecondsOnlyForProfileUse()..'; will generate navmesh if it isnt already generated, NavUtils.IsGenerated()='..tostring(NavUtils.IsGenerated())) end
    if not(NavUtils.IsGenerated()) then
        --local NavGen = import("/lua/sim/navgenerator.lua")
        --NavGen.Generate()
        NavUtils.Generate()
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1) --Redundancy so chat message displays
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    GetMapWaterHeight()

    --Create table that stores details for each pathing group (e.g. land, amphibious) each mex in that group for easy reference later
    RecordMexForPathingGroup()

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1) --want to make sure our chat message displays (redundancy as moved to earlier now)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Create table with details on all plateaus (initially just those with mexes, although the land zone logic may add to this)
    RecordAllPlateaus() --Needed first since will organise land zones by plateau

    --Setup land zones
    SetupLandZones()

    RecordIslands()
    RecordPondDetails()

    bMapLandSetupComplete = true
    if bDebugMessages == true then LOG(sFunctionRef..': Finished setting up land aspects of the map, will move on to water zones, time='..GetGameTimeSeconds()..'; system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    SetupWaterZones() --Includes a wait to make sure we have M28 brains
    if bDebugMessages == true then LOG(sFunctionRef..': Finished setting up water zones, will also now clal forked threads for other aspects, time='..GetGameTimeSeconds()..'; system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    ForkThread(ClearTemporarySetupVariables)
    ForkThread(ReclaimManager)

    --Campaign specific - reduce playable area to the current playable area (once have setup all zones based on full map size)
    if bIsCampaignMap then
        SetupPlayableAreaAndSegmentSizes()
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

--function GetDistanceFromStartAdjustedForDistanceFromMid()  end -- have replaced with GetModDistanceFromStart
function GetModDistanceFromStart(aiBrain, tTarget, bUseEnemyStartInstead)
    local sFunctionRef = 'GetModDistanceFromStart'
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Start of code, GameTime=' .. GetGameTimeSeconds() .. '; aiBrain army index=' .. aiBrain:GetArmyIndex() .. '; tTarget=' .. repru(tTarget) .. '; bUseEnemyStartInstead=' .. tostring((bUseEnemyStartInstead or false)) .. '; will draw the location in white')
        M28Utilities.DrawLocation(tTarget, false, 7, 20, nil)
    end

    local iEmergencyRangeToUse = 50

    local tStartPos
    local tEnemyBase
    if bUseEnemyStartInstead then
        tStartPos = GetPrimaryEnemyBaseLocation(aiBrain)
        tEnemyBase = PlayerStartPoints[aiBrain:GetArmyIndex()]
    else
        tStartPos = PlayerStartPoints[aiBrain:GetArmyIndex()]
        tEnemyBase = GetPrimaryEnemyBaseLocation(aiBrain)
    end

    local iDistStartToTarget = M28Utilities.GetDistanceBetweenPositions(tStartPos, tTarget)
    if bDebugMessages == true then LOG(sFunctionRef .. ': tStartPos=' .. repru(tStartPos) .. '; iDistStartToTarget=' .. iDistStartToTarget .. '; iEmergencyRangeToUse=' .. iEmergencyRangeToUse) end

    if iDistStartToTarget <= iEmergencyRangeToUse then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        if bDebugMessages == true then LOG(sFunctionRef .. ': Are within emergency range so will just return actual dist, iDistStartToTarget=' .. iDistStartToTarget .. '; if instead we only had 1 enemy and got mod dist for this the result would be ' .. math.cos(math.abs(M28Utilities.ConvertAngleToRadians(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, GetPrimaryEnemyBaseLocation(aiBrain))))) * iDistStartToTarget) end

        return iDistStartToTarget
    else
        --If only 1 enemy group then treat anywhere behind us as the emergency range
        if bUseEnemyStartInstead then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            if bDebugMessages == true then LOG(sFunctionRef .. ': will ignore multiple enemies since have flagged to use enemy start instead, will return ' .. math.cos(M28Utilities.ConvertAngleToRadians(math.abs(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, PlayerStartPoints[aiBrain:GetArmyIndex()])))) * iDistStartToTarget) end

            return iEmergencyRangeToUse, math.cos(math.abs(M28Utilities.ConvertAngleToRadians(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, tEnemyBase)))) * iDistStartToTarget
        else
            local bIsBehindUs = true
            if bDebugMessages == true then LOG(sFunctionRef .. ': Is table of enemy brains empty=' .. tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains]))) end

            if M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains]) then
                if M28Utilities.GetDistanceBetweenPositions(tTarget, tEnemyBase) < M28Utilities.GetDistanceBetweenPositions(tStartPos, tEnemyBase) or M28Utilities.GetDistanceBetweenPositions(tTarget, tStartPos) > M28Utilities.GetDistanceBetweenPositions(tStartPos, tEnemyBase) then
                    bIsBehindUs = false
                end
            else
                for iEnemyGroup, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains] do
                    if bDebugMessages == true then LOG(sFunctionRef .. ': Distance from target to start=' .. M28Utilities.GetDistanceBetweenPositions(tTarget, tStartPos) .. '; Distance from start to enemy base=' .. M28Utilities.GetDistanceBetweenPositions(tStartPos, PlayerStartPoints[oBrain:GetArmyIndex()])) end

                    if M28Utilities.GetDistanceBetweenPositions(tTarget, PlayerStartPoints[oBrain:GetArmyIndex()]) < M28Utilities.GetDistanceBetweenPositions(tStartPos, PlayerStartPoints[oBrain:GetArmyIndex()]) or M28Utilities.GetDistanceBetweenPositions(tTarget, tStartPos) > M28Utilities.GetDistanceBetweenPositions(tStartPos, PlayerStartPoints[oBrain:GetArmyIndex()]) then
                        bIsBehindUs = false
                        break
                    end
                end
            end

            if bIsBehindUs then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                if bDebugMessages == true then LOG(sFunctionRef .. ': Will return emergency range as enemy is behind us, so returning ' .. iEmergencyRangeToUse) end

                return iEmergencyRangeToUse
            else
                --Cycle through each enemy group and get lowest value, but stop if <= emergency range
                local iCurDist
                local iLowestDist = 10000
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains]) then
                    iLowestDist = math.cos(M28Utilities.ConvertAngleToRadians(math.abs(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, tEnemyBase)))) * iDistStartToTarget
                else
                    for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains] do
                        iCurDist = math.cos(M28Utilities.ConvertAngleToRadians(math.abs(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, PlayerStartPoints[oBrain:GetArmyIndex()])))) * iDistStartToTarget
                        if bDebugMessages == true then LOG(sFunctionRef .. ': iCurDist for enemy oBrain index ' .. oBrain:GetArmyIndex() .. ' = ' .. iCurDist .. '; Enemy base=' .. repru(PlayerStartPoints[oBrain:GetArmyIndex()]) .. '; tEnemyBase=' .. repru(tEnemyBase) .. '; Angle from start to target=' .. M28Utilities.GetAngleFromAToB(tStartPos, tTarget) .. '; Angle from Start to enemy base=' .. M28Utilities.GetAngleFromAToB(tStartPos, PlayerStartPoints[oBrain:GetArmyIndex()]) .. '; iDistStartToTarget=' .. iDistStartToTarget) end

                        if iCurDist < iLowestDist then
                            iLowestDist = iCurDist
                            if iLowestDist < iEmergencyRangeToUse then
                                iLowestDist = iEmergencyRangeToUse
                                break
                            end
                        end
                    end
                end

                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                if bDebugMessages == true then LOG(sFunctionRef .. ': iLowestDist=' .. iLowestDist) end

                return iLowestDist
            end
        end
    end
end

function RecordAvailableMassStorageLocationsForLandZone(iPlateau, iLandZone)
    local tLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
    tLZData[subrefLZMassStorageLocationsAvailable] = {}
    if M28Utilities.IsTableEmpty(tLZData[subrefLZMexLocations]) == false then
        local tiXZOffset = {{-2,0}, {0, -2}, {0, 2}, {2, 0}}
        local tCurPos
        for iMex, tMex in tLZData[subrefLZMexLocations] do
            for iOffset, tXZOffset in tiXZOffset do
                tCurPos = {tMex[1] + tXZOffset[1], 0, tMex[3] + tXZOffset[2]}
                tCurPos[2] = GetSurfaceHeight(tCurPos[1], tCurPos[3])
                if M28Conditions.CanBuildStorageAtLocation(tCurPos) then
                    table.insert(tLZData[subrefLZMassStorageLocationsAvailable], tCurPos)
                end
            end
        end
    end
end

function RecordMassStorageLocationsForEachLandZone()
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLZSubtable in tPlateauSubtable[subrefPlateauLandZones] do
            RecordAvailableMassStorageLocationsForLandZone(iPlateau, iLandZone)
        end
    end
end


function GetReclaimLocationFromSegment(iReclaimSegmentX, iReclaimSegmentZ)
    --e.g. segment (1,1) will be 0 to ReclaimSegmentSizeX and 0 to ReclaimSegmentSizeZ in size
    --This will return the midpoint
    local iX = math.max(rMapPotentialPlayableArea[1], math.min(rMapPotentialPlayableArea[3], (iReclaimSegmentX - 0.5) * iReclaimSegmentSizeX))
    local iZ = math.max(rMapPotentialPlayableArea[2], math.min(rMapPotentialPlayableArea[4], (iReclaimSegmentZ - 0.5) * iReclaimSegmentSizeZ))
    return {iX, GetSurfaceHeight(iX, iZ), iZ}
end

function GetReclaimSegmentsFromLocation(tLocation)
    return math.ceil(tLocation[1] / iReclaimSegmentSizeX), math.ceil(tLocation[3] / iReclaimSegmentSizeZ)
end

function ReclaimManager()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'ReclaimManager'

    local tAreasToUpdateThisCycle
    local iUpdateCount = 0
    local iMaxUpdatesPerTick
    local iWaitCount
    local iLoopCount
    if not(bReclaimManagerActive) then
        bReclaimManagerActive = true
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart) --Want the profile coutn to reflect the number of times actually running the core code

        while bReclaimManagerActive do
            if bDebugMessages == true then LOG(sFunctionRef..': Start of main active loop') end

            tAreasToUpdateThisCycle = {}
            iUpdateCount = 0
            iWaitCount = 0
            if M28Utilities.IsTableEmpty(tReclaimSegmentsToUpdate) then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(10)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            else
                --Copy table into tAreasToUpdateThisCycle
                if bDebugMessages == true then
                    LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..'; Will list out all entries in tReclaimSegmentsToUpdate if it isnt nil')
                    if tReclaimSegmentsToUpdate then LOG(repru(tReclaimSegmentsToUpdate)) end
                end
                for iEntry, tSubtable in tReclaimSegmentsToUpdate do
                    if (tSubtable[2] or 0) > 0 and (tSubtable[1] or 0) > 0 then --Dont bother updating places right on map edge in case pathfinding issue
                        if not(tAreasToUpdateThisCycle[tSubtable[1]]) then tAreasToUpdateThisCycle[tSubtable[1]] = {} end
                        if not(tAreasToUpdateThisCycle[tSubtable[1]][tSubtable[2]]) then
                            iUpdateCount = iUpdateCount + 1
                            tAreasToUpdateThisCycle[tSubtable[1]][tSubtable[2]] = true
                        end
                    end
                end
                --Clear the table for the next cycle
                tReclaimSegmentsToUpdate = {}
                if iUpdateCount == 0 then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(10)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                else
                    iMaxUpdatesPerTick = math.max(5, math.min(20, math.ceil(iUpdateCount / 10)))
                    iLoopCount = 0
                    if bDebugMessages == true then LOG(sFunctionRef..': About to update for iUpdateCount='..iUpdateCount..' entries; max updates per tick='..iMaxUpdatesPerTick..'; tAreasToUpdateThisCycle='..repru(tAreasToUpdateThisCycle)) end
                    for iSegmentX, tSubtable1 in tAreasToUpdateThisCycle do
                        for iSegmentZ, tSubtable2 in tAreasToUpdateThisCycle[iSegmentX] do
                            iLoopCount = iLoopCount + 1
                            if iLoopCount > iMaxUpdatesPerTick then
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                WaitTicks(1)
                                iWaitCount = iWaitCount + 1
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                                iLoopCount = 1
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': About to update reclaim data for segments '..iSegmentX..'-'..iSegmentZ) end
                            UpdateReclaimDataNearSegments(iSegmentX, iSegmentZ, 0, nil)
                        end
                    end
                    if iWaitCount < 10 then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(10 - iWaitCount)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function CreateReclaimSegment(iReclaimSegmentX, iReclaimSegmentZ)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'CreateReclaimSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ] = {}
    tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint] = GetReclaimLocationFromSegment(iReclaimSegmentX, iReclaimSegmentZ)
    --tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refsSegmentMidpointLocationRef] = M28Utilities.ConvertLocationToReference(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint])
    local iPlateau, iLandZone = GetPlateauAndLandZoneReferenceFromPosition(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint])
    if (iPlateau or 0) == 0 then
        --If we get the reclaim location, is it in a pathable area, or within 2 of a pathable area?
        local rRect = M28Utilities.GetRectAroundLocation(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint], iReclaimSegmentSizeX * 0.5)
        local tReclaimables = GetReclaimInRectangle(4, rRect)
        if M28Utilities.IsTableEmpty(tReclaimables) == false then
            local iCurPlateau, iCurLandZone
            local tiXZOffset = {{-2,-2}, {-2, 2}, {2, -2}, {2, 2}}
            for iReclaim, oReclaim in tReclaimables do
                iCurPlateau, iCurLandZone = GetPlateauAndLandZoneReferenceFromPosition(oReclaim.CachePosition)
                if (iCurPlateau or 0) == 0 then
                    --Search nearby
                    for _, tiXZAdjust in tiXZOffset do
                        iCurPlateau, iCurLandZone = GetPlateauAndLandZoneReferenceFromPosition({oReclaim.CachePosition[1] + tiXZAdjust[1], oReclaim.CachePosition[2], oReclaim.CachePosition[3] + tiXZAdjust[2]})
                        if (iCurPlateau or 0) > 0 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Reclaim location '..repru(oReclaim.CachePosition)..' isnt pathable but if we adjust by '..repru(tiXZAdjust)..' then it becomes pathable, adjusted position='..repru({oReclaim.CachePosition[1] + tiXZAdjust[1], oReclaim.CachePosition[2], oReclaim.CachePosition[3] + tiXZAdjust[2]})..'; iCurPlateau='..iCurPlateau..'; iCurLandZone='..(iCurLandZone or 'nil')) end
                            break
                        end
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Reclaim midpoint '..repru(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint])..' isnt pathable but the reclaim position itself, '..repru(oReclaim.CachePosition)..' is pathable, iCurPlateau='..iCurPlateau..'; iCurLandZone='..(iCurLandZone or 'nil')) end
                end
                if (iCurPlateau or 0) > 0 then
                    iPlateau = iCurPlateau
                    iLandZone = iCurLandZone
                    break
                end
            end
        end

    end
    if bDebugMessages == true then LOG(sFunctionRef..': Adding iReclaimSegmentX-Z'..iReclaimSegmentX..'-'..iReclaimSegmentZ..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
    if (iLandZone or 0) > 0 then
        --Record in the land zone
        if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefReclaimSegments]) then tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefReclaimSegments] = {} end
        table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefReclaimSegments], {iReclaimSegmentX, iReclaimSegmentZ})
        if bDebugMessages == true then
            LOG(sFunctionRef..': Finished adding reclaim segment to LZ, all reclaim segments for this LZ='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefReclaimSegments]))
            local rCurRect = M28Utilities.GetRectAroundLocation(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint], iReclaimSegmentSizeX * 0.5)
            M28Utilities.DrawRectangle(rCurRect, 4)
        end
    elseif (iPlateau or 0) > 0 then
        --Record in the water zone
        local iWaterZone = GetWaterZoneFromPosition(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint])
        if (iWaterZone or 0) > 0 then
            local iPond = tiPondByWaterZone[iWaterZone]
            local tWZData = tPondDetails[iPond][subrefPondWaterZones][iWaterZone]
            if not(tWZData[subrefReclaimSegments]) then tWZData[subrefReclaimSegments] = {} end
            table.insert(tWZData[subrefReclaimSegments], {iReclaimSegmentX, iReclaimSegmentZ})
            if bDebugMessages == true then
                LOG(sFunctionRef..': Finished adding reclaim segment to WZ, all reclaim segments for this WZ='..repru(tWZData[subrefReclaimSegments]))
                local rCurRect = M28Utilities.GetRectAroundLocation(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint], iReclaimSegmentSizeX * 0.5)
                M28Utilities.DrawRectangle(rCurRect, 4)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshLandOrWaterZoneReclaimValue(iPlateauOrPond, iLandOrWaterZone, bIsWaterZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RefreshLandOrWaterZoneReclaimValue'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tLZOrWZData
    if bIsWaterZone then tLZOrWZData = tPondDetails[iPlateauOrPond][subrefPondWaterZones][iLandOrWaterZone]
    else
        tLZOrWZData = tAllPlateaus[iPlateauOrPond][subrefPlateauLandZones][iLandOrWaterZone]
    end
    tLZOrWZData[subrefLastReclaimRefresh] = GetGameTimeSeconds()
    local iMassReclaim = 0
    local iEnergyReclaim = 0
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; bIsWaterZone='..tostring(bIsWaterZone or false)..'; Considering PlateauOrPond='..iPlateauOrPond..'; iLandOrWaterZone='..iLandOrWaterZone..'; Is table of LZ or WZ reclaim segments empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[subrefReclaimSegments]))) end
    if M28Utilities.IsTableEmpty(tLZOrWZData[subrefReclaimSegments]) == false then
        for iSegmentCount, tSegmentXZ in tLZOrWZData[subrefReclaimSegments] do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering tSegmentXZ='..tSegmentXZ[1]..'-'..tSegmentXZ[2]..'; total mass in this segment='..tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][refReclaimTotalMass]) end
            iMassReclaim = iMassReclaim + tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][refReclaimTotalMass]
            iEnergyReclaim = iEnergyReclaim + tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][refSegmentReclaimTotalEnergy]
        end
    end
    tLZOrWZData[subrefTotalMassReclaim] = iMassReclaim
    tLZOrWZData[subrefLZTotalEnergyReclaim] = iEnergyReclaim
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iMassReclaim='..iMassReclaim..'; LZ reclaim='..tLZOrWZData[subrefTotalMassReclaim]) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetReclaimablesMassAndEnergy(tReclaimables, iMinMass, iMinEnergy)
    --Largely a copy of GetReclaimablesResourceValue, but focused specificaly on the reclaim segment update logic
    --Must have at least iMinMass or iMinEnergy to be recorded
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetReclaimablesMassAndEnergy'
    --V14 and earlier would modify total mass value to reduce it by 25% if its small, and 50% if its medium; v15 removed this
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local sMassRef = 'MaxMassReclaim'
    local sEnergyRef = 'MaxEnergyReclaim'

    local tWreckPos = {}
    local iTotalMass = 0
    local iTotalEnergy = 0

    local iLargestCurReclaim = 0
    local iLargestReclaimRef = 0

    if tReclaimables and table.getn( tReclaimables ) > 0 then
        for iReclaimRef, v in tReclaimables do
            tWreckPos = v.CachePosition
            if tWreckPos[1] then
                --if v.MaxMassReclaim > iIgnoreReclaimIfNotMoreThanThis then
                if v[sMassRef] > iMinMass or v[sEnergyRef] > iMinEnergy then
                    if not(v:BeenDestroyed()) then
                        iTotalMass = iTotalMass + v[sMassRef]
                        iTotalEnergy = iTotalEnergy + v[sEnergyRef]
                        if v[sMassRef] > iLargestCurReclaim then
                            iLargestCurReclaim = v[sMassRef]
                            iLargestReclaimRef = iReclaimRef
                        end
                    end
                end
            else
                if not(v.MaxMassReclaim == nil) then
                    if v.MaxMassReclaim > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Warning - have ignored wreck location despite it having a mass reclaim value') end
                    end
                end
            end
        end
    end
    local tReclaimPos
    if iLargestReclaimRef then tReclaimPos = {tReclaimables[iLargestReclaimRef][1], tReclaimables[iLargestReclaimRef][2], tReclaimables[iLargestReclaimRef][3]} end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iTotalMass, tReclaimPos, iLargestCurReclaim, iTotalEnergy
end

function UpdateReclaimDataNearSegments(iBaseSegmentX, iBaseSegmentZ, iSegmentRange)
    --Updates reclaim data for all segments within iSegmentRange of tLocation

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'UpdateReclaimDataNearSegments'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart) --Want the profile coutn to reflect the number of times actually running the core code

    local iMinValueOfIndividualReclaim = 2.5
    local iMinEnergyValue = 15

    local iTotalMassValue, tReclaimables, iLargestCurReclaim, tReclaimPos, iTotalEnergyValue
    local iCumulativeMassValue = 0

    if bDebugMessages == true then
        LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; About to update for iBaseSegmentX='..(iBaseSegmentX or 'nil')..'; iSegmentRange='..(iSegmentRange or 'nil')..'; iBaseSegmentZ='..(iBaseSegmentZ or 'nil'))
    end

    local iPlateau, iLandZone

    for iCurX = iBaseSegmentX - iSegmentRange, iBaseSegmentX + iSegmentRange do
        for iCurZ = iBaseSegmentZ - iSegmentRange, iBaseSegmentZ + iSegmentRange do
            iTotalMassValue = 0
            tReclaimables = GetReclaimablesInRect(Rect((iCurX - 1) * iReclaimSegmentSizeX, (iCurZ - 1) * iReclaimSegmentSizeZ, iCurX * iReclaimSegmentSizeX, iCurZ * iReclaimSegmentSizeZ))
            iLargestCurReclaim = 0

            if bDebugMessages == true then LOG(sFunctionRef..': iCurX='..iCurX..'; iCurZ='..iCurZ..'; iReclaimSegmentSizeX='..iReclaimSegmentSizeX..'; iReclaimSegmentSizeZ='..iReclaimSegmentSizeZ..'; Reclaim search rect='..repru(Rect((iCurX - 1) * iReclaimSegmentSizeX, (iCurZ - 1) * iReclaimSegmentSizeZ, iCurX * iReclaimSegmentSizeX, iCurZ * iReclaimSegmentSizeZ))..'; Is tReclaimables empty='..tostring(M28Utilities.IsTableEmpty(tReclaimables))) end

            if tReclaimables and table.getn( tReclaimables ) > 0 then
                -- local iWreckCount = 0
                --local bIsProp = nil  --only used for log/testing
                if bDebugMessages == true then LOG('Have wrecks within the segment iCurXZ='..iCurX..'-'..iCurZ) end
                iTotalMassValue, tReclaimPos, iLargestCurReclaim, iTotalEnergyValue = GetReclaimablesMassAndEnergy(tReclaimables, iMinValueOfIndividualReclaim, iMinEnergyValue)
                --Record this table:
                if tReclaimAreas[iCurX] == nil then
                    tReclaimAreas[iCurX] = {}
                    if bDebugMessages == true then LOG('Setting table to nothing as is currently nil; iCurX='..iCurX) end
                end
                if tReclaimAreas[iCurX][iCurZ] == nil then
                    CreateReclaimSegment(iCurX, iCurZ)
                end
                --tReclaimAreas[iCurX][iCurZ][refiReclaimTotalPrev] = (tReclaimAreas[iCurX][iCurZ][refReclaimTotalMass] or 0)
                tReclaimAreas[iCurX][iCurZ][refReclaimTotalMass] = iTotalMassValue
                --tReclaimAreas[iCurX][iCurZ][refReclaimHighestIndividualReclaim] = iLargestCurReclaim
                --iHighestReclaimInASegment = math.max(iHighestReclaimInASegment, iTotalMassValue)
                tReclaimAreas[iCurX][iCurZ][refSegmentReclaimTotalEnergy] = iTotalEnergyValue
                iPlateau, iLandZone = GetPlateauAndLandZoneReferenceFromPosition(tReclaimAreas[iCurX][iCurZ][refReclaimSegmentMidpoint])
                if bDebugMessages == true then LOG(sFunctionRef..': Reclaim segment midpoint='..repru(tReclaimAreas[iCurX][iCurZ][refReclaimSegmentMidpoint])..'; iPlateau for this='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
                if iLandZone > 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Time of last refresh for land zone '..iLandZone..'='.. (tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLastReclaimRefresh] or 0)) end
                    if GetGameTimeSeconds() - (tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLastReclaimRefresh] or 0) >= 1 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will refresh the reclaim value for land zone '..iLandZone) end
                        RefreshLandOrWaterZoneReclaimValue(iPlateau, iLandZone)
                    end
                else
                    local iWaterZone = GetWaterZoneFromPosition(tReclaimAreas[iCurX][iCurZ][refReclaimSegmentMidpoint])
                    if (iWaterZone or 0) > 0 then
                        local iPond = tiPondByWaterZone[iWaterZone]
                        if bDebugMessages == true then LOG(sFunctionRef..': Time of last refresh for water zone '..iWaterZone..'='.. (tPondDetails[iPond][subrefPondWaterZones][iWaterZone][subrefLastReclaimRefresh] or 0)) end
                        if GetGameTimeSeconds() - (tPondDetails[iPond][subrefPondWaterZones][iWaterZone][subrefLastReclaimRefresh] or 0) >= 1 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will refresh the reclaim value for land zone '..iLandZone) end
                            RefreshLandOrWaterZoneReclaimValue(iPond, iWaterZone, true)
                        end
                    end
                end


            end
            iCumulativeMassValue = iCumulativeMassValue + iTotalMassValue
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iCumulativeMassValue='..iCumulativeMassValue..'; SystemTime='..GetSystemTimeSecondsOnlyForProfileUse()) end

    --M28Profiler.tiProfilerEndCountByFunction[sFunctionRef] = (M28Profiler.tiProfilerStartCountByFunction[sFunctionRef] or 0) + 1 LOG(sFunctionRef..': M28Profiler.tiProfilerEndCountByFunction[sFunctionRef]='..M28Profiler.tiProfilerEndCountByFunction[sFunctionRef])
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iCumulativeMassValue
end

function RecordThatWeWantToUpdateReclaimAtLocation(tLocation, iNearbySegmentsToUpdate)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RecordThatWeWantToUpdateReclaimAtLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if iReclaimSegmentSizeX == 0 then
        M28Utilities.ErrorHandler('Dont have a reclaim segment size specified, will set it to 8.5, but something else has likely gone wrong')
        iReclaimSegmentSizeX = 8.5
        iReclaimSegmentSizeZ = 8.5
    end
    local iReclaimSegmentX, iReclaimSegmentZ = GetReclaimSegmentsFromLocation(tLocation)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time='..GetGameTimeSeconds()..'; tLocation='..repru(tLocation)..'; iReclaimSegmentX-Z='..iReclaimSegmentX..'-'..iReclaimSegmentZ) end
    if iReclaimSegmentX >= 10000 or iNearbySegmentsToUpdate >= 10000 or iReclaimSegmentZ >= 10000 then M28Utilities.ErrorHandler('Likely infinite loop about to start. iReclaimSegmentX='..(iReclaimSegmentX or 'nil')..'; iNearbySegmentsToUpdate='..(iNearbySegmentsToUpdate or 'nil')..'; iReclaimSegmentSizeX='..(iReclaimSegmentSizeX or 'nil')..'; iReclaimSegmentSizeZ='..(iReclaimSegmentSizeX or 'nil')..'; rMapPotentialPlayableArea='..repru(rMapPotentialPlayableArea or {'nil'})..'; iMaxSegmentInterval='..(iMaxSegmentInterval or 'nil'))
    else

        if iNearbySegmentsToUpdate then
            for iSegmentX = iReclaimSegmentX - iNearbySegmentsToUpdate, iReclaimSegmentX + iNearbySegmentsToUpdate do
                for iSegmentZ = iReclaimSegmentZ - iNearbySegmentsToUpdate, iReclaimSegmentZ + iNearbySegmentsToUpdate do
                    if bDebugMessages == true then LOG(sFunctionRef..': Will record that we want to update the reclaim segment XZ='..iSegmentX..'-'..iSegmentZ) end
                    RecordThatWeWantToUpdateReclaimSegment(iSegmentX, iSegmentZ)
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Will record that we want to update the base reclaim segment XZ='..iReclaimSegmentX..'-'..iReclaimSegmentZ) end
            RecordThatWeWantToUpdateReclaimSegment(iReclaimSegmentX, iReclaimSegmentZ)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordThatWeWantToUpdateReclaimSegment(iReclaimSegmentX, iReclaimSegmentZ)
    if iReclaimSegmentX >= 0 and iReclaimSegmentZ >= 0 then table.insert(tReclaimSegmentsToUpdate, {iReclaimSegmentX, iReclaimSegmentZ}) end
end


function GetTravelDistanceBetweenLandZones(iPlateau, iStartLZ, iEndLZ)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetTravelDistanceBetweenLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tStartLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLZ]
    if not(tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau][iEndLZ]) then
        if not(tStartLZData[subrefLZTravelDistToOtherLandZones]) then tStartLZData[subrefLZTravelDistToOtherLandZones] = {} end
        if not(tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau]) then tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau] = {} end
        if not(tStartLZData[subrefMidpoint]) then RecordMidpointAndOtherDataForZone(iPlateau, iStartLZ, tStartLZData) end --redundancy
        if bDebugMessages == true then LOG(sFunctionRef..': About to record travel distance for iPlateau '..(iPlateau or 'nil')..'; iStartLZ '..(iStartLZ or 'nil')..'; iEndLZ='..(iEndLZ or 'nil')..'; start midpoint='..repru(tStartLZData[subrefMidpoint])..'; End LZ midpoint='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iEndLZ][subrefMidpoint])) end
        tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau][iEndLZ] = M28Utilities.GetTravelDistanceBetweenPositions(tStartLZData[subrefMidpoint], tAllPlateaus[iPlateau][subrefPlateauLandZones][iEndLZ][subrefMidpoint], refPathingTypeLand)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Travel distance from iStartLZ='..iStartLZ..' to iEndLZ='..iEndLZ..' is '..(tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau][iEndLZ] or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau][iEndLZ]
end


function GetPositionAtOrNearTargetInPathingGroup(tStartPos, tTargetPos, iDistanceFromTargetToStart, iAngleAdjust, oPathingUnit, bMoveCloserBeforeFurtherIfBlocked, bCheckIfExistingTargetIsBetter, iMinDistanceFromExistingCommandTarget)
    --Intended as a rewriting of GetPositionNearTargetInSamePathingGroup due to some inconsistencies arising with the below, to make use of new logic that allows any angle; introduced from v15
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPositionAtOrNearTargetInPathingGroup'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Get angle from target to start
    local iAngleFromTargetToStart = M28Utilities.GetAngleFromAToB(tTargetPos, tStartPos) + (iAngleAdjust or 0)
    --Get initial desired position
    local tPossibleTarget = M28Utilities.MoveInDirection(tTargetPos, iAngleFromTargetToStart, iDistanceFromTargetToStart, true, false, false)
    local sPathing = M28UnitInfo.GetUnitPathingType(oPathingUnit)
    local iPathingGroupWanted = NavUtils.GetTerrainLabel(sPathing, tTargetPos)
    local iPathingGroupOfPossibleTarget = NavUtils.GetTerrainLabel(sPathing, tPossibleTarget)
    local bCanPathToTarget = false

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code; oPathingUnit='..oPathingUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPathingUnit)..'; tTargetPos='..repru(tTargetPos)..'; iAngleAdjust ='..iAngleAdjust..'; iDistanceFromTargetToStart='..iDistanceFromTargetToStart..'; tStartPos='..repru(tStartPos)..'; iPathingGroupOfPossibleTarget='..iPathingGroupOfPossibleTarget..'; iPathingGroupWanted='..iPathingGroupWanted..'; Angle from start to target='..M28Utilities.GetAngleFromAToB(tStartPos, tTargetPos)..'; iAngleFromTargetToStart='..iAngleFromTargetToStart..'; Amphibious group of target position='..NavUtils.GetTerrainLabel(refPathingTypeHover, tTargetPos)..'; Amphib group of our base='..NavUtils.GetTerrainLabel(refPathingTypeHover, PlayerStartPoints[oPathingUnit:GetAIBrain():GetArmyIndex()])..'; tPossibleTarget before adjust='..repru(tPossibleTarget)..'; Distance between possible target and tTargetPos='..M28Utilities.GetDistanceBetweenPositions(tPossibleTarget, tTargetPos)) end
    --Find a target we can path to
    if iPathingGroupOfPossibleTarget == iPathingGroupWanted then
        bCanPathToTarget = true
    else
        --Dif pathing group, need to try alternatives; first try the target itself
        if not(bMoveCloserBeforeFurtherIfBlocked == false) then
            tPossibleTarget = {tTargetPos[1], tTargetPos[2], tTargetPos[3]}
            iPathingGroupOfPossibleTarget = NavUtils.GetTerrainLabel(sPathing, tPossibleTarget)
            if bDebugMessages == true then LOG(sFunctionRef..': Pathing group if just try target position='..iPathingGroupOfPossibleTarget) end
            if iPathingGroupOfPossibleTarget == iPathingGroupWanted then
                bCanPathToTarget = true
            end
        end

        if bCanPathToTarget == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Cant path to the initial expected point so will try nearby points') end
            local tDistanceFactors
            if bMoveCloserBeforeFurtherIfBlocked then
                tDistanceFactors = {0.5, 1.5, 3}
            else tDistanceFactors = {1.25, 3}
            end
            local tAngleVariations = {-45, 0, 45}
            --Make sure we have at least some distance we're moving away from
            if iDistanceFromTargetToStart == 0 then iDistanceFromTargetToStart = 1 end

            if math.abs(iDistanceFromTargetToStart) < 4 then
                local iFactorIncrease = 4 / iDistanceFromTargetToStart
                for iDistanceFactor = 1, table.getn(tDistanceFactors) do
                    tDistanceFactors[iDistanceFactor] = tDistanceFactors[iDistanceFactor] * iFactorIncrease
                end
            end
            for iDistanceFactor = 1, table.getn(tDistanceFactors) do
                for iAngleAlternative = 1, table.getn(tAngleVariations) do
                    tPossibleTarget = M28Utilities.MoveInDirection(tTargetPos, iAngleFromTargetToStart + tAngleVariations[iAngleAlternative], iDistanceFromTargetToStart * tDistanceFactors[iDistanceFactor], true, false, false)
                    if NavUtils.GetTerrainLabel(sPathing, tPossibleTarget) == iPathingGroupWanted then
                        bCanPathToTarget = true
                        break
                    end
                end
                if bCanPathToTarget then break end
                if bDebugMessages == true then LOG(sFunctionRef..': iDistanceFactor='..iDistanceFactor..'; tPossibleTarget based on the last of the angle variations='..repru(tPossibleTarget)..'; still cant path to the target so will keep looking') end
            end
        end

    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if can path to target, bCanPathToTarget='..tostring(bCanPathToTarget)..'; tPossibleTarget='..repru(tPossibleTarget)) end

    if bCanPathToTarget then
        --Consider if the target meets any other values specified (e.g. if must be certain distance away from current target or unit)
        if bCheckIfExistingTargetIsBetter == true or iMinDistanceFromExistingCommandTarget then
            if bDebugMessages == true then LOG(sFunctionRef..': Checking against existing target to see if thats better') end
            if oPathingUnit.GetNavigator then
                local oNavigator = oPathingUnit:GetNavigator()
                if oNavigator.GetCurrentTargetPos then
                    local tExistingTargetPos = oNavigator:GetCurrentTargetPos()
                    if M28Utilities.IsTableEmpty(tExistingTargetPos) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': tExistingTargetPos='..repru(tExistingTargetPos)..'; Distance to possible target='..M28Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tPossibleTarget)..'; iMinDistanceFromExistingCommandTarget='..(iMinDistanceFromExistingCommandTarget or 'nil')..'; Pathing group of this='..NavUtils.GetTerrainLabel(sPathing, tExistingTargetPos)..'; Pathing group wanted='..iPathingGroupWanted..'; sPathing='..sPathing..'; Distance of existing position toa ctual target='..M28Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tTargetPos)) end
                        if NavUtils.GetTerrainLabel(sPathing, tExistingTargetPos) == iPathingGroupWanted then

                            --Do we have a minimum distance away from current target required?
                            if iMinDistanceFromExistingCommandTarget and M28Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tPossibleTarget) < iMinDistanceFromExistingCommandTarget then
                                if bDebugMessages == true then LOG(sFunctionRef..': Distance between existing target position and possible target position is less than the min distance; tExistingTargetPos='..repru(tExistingTargetPos)..'; tPossibleTarget='..repru(tPossibleTarget)) end
                                tPossibleTarget = tExistingTargetPos
                            else
                                --Is the existing target position closer to the distance required than the new position, factoring in if we want a negative position or not?
                                local iDistanceFromQueuedMoveLocationToTarget = M28Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tTargetPos)
                                local iDistanceFromPossibleTargetToTarget = M28Utilities.GetDistanceBetweenPositions(tPossibleTarget, tTargetPos)
                                --Are these further away from the start position than the actual target?
                                if math.abs(iDistanceFromQueuedMoveLocationToTarget - iDistanceFromTargetToStart) < math.abs(iDistanceFromPossibleTargetToTarget - iDistanceFromTargetToStart) then
                                    --Have we said we want to move closer if the initial point is blocked?
                                    if not(bMoveCloserBeforeFurtherIfBlocked) or iDistanceFromQueuedMoveLocationToTarget <= iDistanceFromTargetToStart then
                                        --Factor in we might be infront of the target and actually want to be behind
                                        local iDistanceFromStartToTarget = M28Utilities.GetDistanceBetweenPositions(tStartPos, tTargetPos)
                                        local iDistanceFromQueuedToStart = M28Utilities.GetDistanceBetweenPositions(tStartPos, tExistingTargetPos)
                                        if bDebugMessages == true then LOG(sFunctionRef..': iDistanceFromQueuedMoveLocationToTarget='..iDistanceFromQueuedMoveLocationToTarget..'; iDistanceFromPossibleTargetToTarget='..iDistanceFromPossibleTargetToTarget..'; iDistanceFromQueuedToStart='..iDistanceFromQueuedToStart..'; iDistanceFromStartToTarget='..iDistanceFromStartToTarget..'; iDistanceFromTargetToStart='..iDistanceFromTargetToStart) end
                                        if iDistanceFromQueuedToStart > 1 and ((iDistanceFromQueuedToStart < iDistanceFromStartToTarget and iDistanceFromTargetToStart > 0) or (iDistanceFromQueuedToStart > iDistanceFromStartToTarget and iDistanceFromTargetToStart < 0)) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Existing location is closer than the new possible location so go with this') end
                                            --Existing location is closer than the new location so go with this
                                            tPossibleTarget = tExistingTargetPos
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    else
        --This could be due to a pathfinding error, will just use the potential target
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code; tPossibleTarget='..repru(tPossibleTarget or {'nil'})..'; bCanPathToTarget='..tostring(bCanPathToTarget)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tPossibleTarget
end

function InPlayableArea(tLocation) --NOTE - also have the same function in M28Conditions
    if tLocation[1] >= rMapPlayableArea[1] and tLocation[1] <= rMapPlayableArea[3] and tLocation[3] >= rMapPlayableArea[2] and tLocation[3] <= rMapPlayableArea[4] then
        return true
    else
        return false
    end
end

function GetLandOrWaterZoneTeamData(tLocation, bReturnTeamDataAsWell, iOptionalTeam)
    local iPlateauOrZero, iLandOrWaterZone = GetClosestPlateauOrZeroAndZoneToPosition(tLocation)
    if (iLandOrWaterZone or 0) > 0 then
        if iPlateauOrZero == 0 then
            --Water zone
            if bReturnTeamDataAsWell then
                return tPondDetails[tiPondByWaterZone[iLandOrWaterZone]][subrefPondWaterZones][iLandOrWaterZone], tPondDetails[tiPondByWaterZone[iLandOrWaterZone]][subrefPondWaterZones][iLandOrWaterZone][subrefWZTeamData][iOptionalTeam]
            else
                return tPondDetails[tiPondByWaterZone[iLandOrWaterZone]][subrefPondWaterZones][iLandOrWaterZone]
            end
        else
            if bReturnTeamDataAsWell then
                return tAllPlateaus[iPlateauOrZero][subrefPlateauLandZones][iLandOrWaterZone], tAllPlateaus[iPlateauOrZero][subrefPlateauLandZones][iLandOrWaterZone][subrefLZTeamData][iOptionalTeam]
            else
                return tAllPlateaus[iPlateauOrZero][subrefPlateauLandZones][iLandOrWaterZone]
            end
        end
    end
end