---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 16/11/2022 07:22
---

local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Chat = import('/mods/M28AI/lua/AI/M28Chat.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Config = import('/mods/M28AI/lua/M28Config.lua')

bMapLandSetupComplete = false --set to true once have finished setting up map (used to decide how long to wait before starting main aibrain logic)
bWaterZoneInitialCreation = false --set to true once have finished code for recording water zones (note WZ setup wont be fully complete yet)

--Pathing types
--NavLayers 'Land' | 'Water' | 'Amphibious' | 'Hover' | 'Air'
refPathingTypeHover = 'Hover' --Amphibious is more restrictive so more likely to run into errors if base pathing on hover if enemy units then hover over it
refPathingTypeAmphibious = 'Amphibious' --Use sparingly - most logic uses hover instead of amphibious
refPathingTypeNavy = 'Water'
refPathingTypeAir = 'Air'
refPathingTypeLand = 'Land'
refPathingTypeNone = 'None'
refPathingTypeAll = {refPathingTypeHover, refPathingTypeNavy, refPathingTypeAir, refPathingTypeLand}

--Map size
rMapPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2} - Set at start of the game, use instead of the scenarioinfo method; note that x0 z0 is the top-left corner of the map
iMaxLandSegmentX = 1
iMaxLandSegmentZ = 1

iMapWaterHeight = 0 --Surface height of water on the map

--Resource information
tMassPoints = {} --[x] is an integer count, returns the location of a mass point; stores all mexes on the map
tHydroPoints = {} --[x] is an integer count, returns the location of a hydro point; stores all hydro points on the map
tMexByPathingAndGrouping = {} --Stores position of each mex based on the pathing group that it's part of; [a][b][c]: [a] = pathing type ('Land' etc.); [b] = Segment grouping; [c] = Mex position
tHydroByPathingAndGrouping = {} --as above but for hydros

--Player start points
PlayerStartPoints = {} --[x] is aiBrain army index, returns the start position {x,y,z}; Will be updated whenever a brain is created, index is the army index, i.e. do PlayerStartPoints[aiBrain:GetArmyIndex()] to get a table {x,y,z} that is the army's start position; more convenient than aiBrain:GetArmyStartPos() which returns x and z values but not as a table


--Reclaim info (non-LZ/plateau specific):
bReclaimManagerActive = false --used to spread updates of reclaim areas over each second
tReclaimSegmentsToUpdate = {} --[n] where n is the count, returns {segmentX,segmentZ} as value; i.e. update by using table.insert
tReclaimAreas = {} --Stores reclaim info for each segment: tReclaimAreas[iSegmentX][iSegmentZ][x]; if x=1 returns total mass in area; if x=2 then returns position of largest reclaim in the area, if x=3 returns how many platoons have been sent here since the game started
    refReclaimTotalMass = 1
    refReclaimSegmentMidpoint = 2
    --refReclaimHighestIndividualReclaim = 3
    --reftReclaimTimeOfLastEngineerDeathByArmyIndex = 4 --Table: [a] where a is the army index, and it returns the time the last engineer died
    --refReclaimTimeLastEnemySightedByArmyIndex = 5
    --refsSegmentMidpointLocationRef = 6
    --refiReclaimTotalPrev = 7 --Previous total reclaim mass in a segment
    refReclaimTotalEnergy = 8
--tLastReclaimRefreshByGroup = {} --time that last refreshed reclaim positions for [x] group
--iLastReclaimRefresh = 0 --stores time that last refreshed reclaim positions
--refiLastRefreshOfReclaimAreasOfInterest = 'M28MapLastRefreshOfReclaim'
--refiTotalReclaimAreasOfInterestByPriority = 'M28MapReclaimAreasOfInterestCount' --[1] = total for priority 1, etc.; up to 4 priority
--reftReclaimAreasOfInterest = 'M28MapReclaimAreasOfInterest' --assigned to aiBrain, [1] = priority (1, 2, 3); [2] = {segmentx, segmentz}
--reftReclaimAreaPriorityByLocationRef = 'M28MapReclaimAreaPriorityByLocationRef' --key is location ref
iReclaimSegmentSizeX = 0 --Updated separately
iReclaimSegmentSizeZ = 0 --Updated separately
--iReclaimAreaOfInterestTickCount = 0 --Updated as part of may reclaim update loop, used to avoid excessive load on an individual tick
--bReclaimRefreshActive = false --Used to avoid duplciating reclaim update logic



--Plateaus - core (NOTE: Some of these variables wont work for a plateau that has no mexes)
tPathingPlateauAndLZOverride = {} --Global, Pathing override where no plateau recognised; key is [math.floor(x)][math.floor(z)] and returns {iPlateau, iLandZone}
tbTempConsideredLandPathingForLZ = {} --Global, used to track if we have considered land pathing for this LZ as part of the initial LZ setup
tNearestPlateauOrZeroAndZoneSegmentOverride = {} --Global, [x] is segmentx, [y] is segmenty, returns the Plateau (0 if water zone) and land/water zone reference to use; closest is based on straight line dist

tAllPlateaus = {} --[x] = AmphibiousPathingGroup, [y]: subrefs, e.g. subrefPlateauMexes;
--aibrain variables for plateaus (not currently incorporated):
reftPlateausOfInterest = 'M28PlateausOfInterest' --[x] = Amphibious pathing group; will record a table of the pathing groups we're interested in expanding to, returns the location of then earest mex
--refiLastPlateausUpdate = 'M28LastTimeUpdatedPlateau' --gametime that we last updated the plateaus
--reftOurPlateauInformation = 'M28OurPlateauInformation' --[x] = AmphibiousPathingGroup; [y] = subref, e.g. subrefPlateauLandFactories; Used to store details such as factories on the plateau
--refiOurBasePlateauGroup = 'M28PlateausOurBaseGroup' --Segment group of our base (so can easily check somewhere is in a dif plateau)

--subrefs for tables
--tAllPlateaus[iPlateau] subrefs
    subrefPlateauMexes = 'M28PlateauMex' --[x] = mex count, returns mex position
    subrefPlateauMinXZ = 'M28PlateauMinXZ' --{x,z} min values
    subrefPlateauMaxXZ = 'M28PlateauMaxXZ' --{x,z} max values - i.e. can create a rectangle covering entire plateau using min and max xz values
    subrefPlateauTotalMexCount = 'M28PlateauMexCount' --Number of mexes on the plateau
    subrefPlateauReclaimSegments = 'M28PlateauReclaimSegments' --[x] = reclaim segment x, [z] = reclaim segment z, returns true if part of plateau
    subrefPlateauMidpoint = 'M28PlateauMidpoint' --Location of the midpoint of the plateau
    subrefPlateauMaxRadius = 'M28PlateauMaxRadius' --Radius to use to ensure the circle coveres the square of the plateau

    subrefPlateauEngineers = 'M28PlateauEngineers' --[x] is engineer unique ref (per m28engineer), returns engineer object
    --Plateaus: Island variables (against tAllPlateaus[iPlateau])
    subrefPlateauIslandLandZones = 'M28PlateauIslands' --[x] is the island, returns a table of land zones in that island for this plateau; the table returned has a key 1....x, and returns the land zone reference number
    subrefPlateauIslandMexCount = 'M28IslandMexCount' --[x] is the island, returns the number of mexes in the island

--Plateaus - Land zone variables (still against tAllPlateaus[iPlateau]
    subrefLandZoneCount = 'M28PlateauZoneCount' --against the main plateau table, records how many land zones there are (alternative to table.getn on the land zones)
    subrefPlateauLandZones = 'M28PlateauLandZones' --against the main plateau table, stores info on land zones for that plateau

iLandZoneSegmentSize = 5 --Gets updated by the SetupLandZones - the size of one side of the square that is the lowest resolution land zones go to; each segment that is land pathable gets assigned to a land zone
    --Land zone subrefs (against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]):
        subrefLZMexCount = 'MexCount' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns number of mexes in the LZ
        subrefLZMexLocations = 'MexLoc' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns table of mex locations in the LZ, e.g. get with tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefLZMexLocations]
        subrefMexUnbuiltLocations = 'MexAvailLoc' --used by water and land zones; e.g. for LZ is against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns table of mex locations in the LZ, e.g. get with tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefLZMexLocations]
        refiTimeOfLastMexDeath = 'MexLstDth' --Gametimeseconds that a mex died in this land zone - used to avoid sending an error message if it is rebuilt immediately (due to the mex deaht logic having a delay)
        subrefLZMidpoint = 'Midpoint' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns the midpoint of the land zone, e.g. get with tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefLZMidpoint]
        subrefLZMinSegX = 'LZMinSegX'
        subrefLZMinSegZ = 'LZMinSegZ'
        subrefLZMaxSegX = 'LZMaxSegX'
        subrefLZMaxSegZ = 'LZMaxSegZ'
        subrefHydroLocations = 'HydroLoc' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns table of hydro locations in the LZ
        subrefHydroUnbuiltLocations = 'HydroAvailLoc' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns table of hydro locations in the LZ that dont have buildings on them
        subrefBuildLocationsBySize = 'BuildLoc' --contains a table, with the index being the unit's highest footprint size, which returns a location that should be buildable in this zone;  only populated on demand (i.e. if we want to try and build something there by references to the predefined location), e.g. tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefBuildLocationsBySize][iSize]
        subrefBuildLocationSegmentCountBySize = 'BuildSegment' --[x] is the building size considered, returns Number of segments that we have considered when identifying segment build locations for the land zone for that particular size
        subrefBuildLocationBlacklist = 'Blacklst' --[x] is the entry, returns a subtable
            subrefBlacklistLocation = 1
            subrefBlacklistSize = 2 --radius of the square, i.e. if do a square around the location where eaech side is this * 2 in length, then will cover the blacklist location
            subrefBlacklistType = 3
                BlacklistTimeout = 1 --i.e. we have tried building something for ages and have failed
                BlacklistReserved = 2 --i.e. we dont want to build anything here because it's being saved for something
        subrefLZMassStorageLocationsAvailable = 'MassStorageLocations' --Against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], Returns table of locations which should be valid to build on for mass storage
        subrefLZSegments = 'Segments' --Contains a table which returns the X and Z segment values for every segment assigned to this land zone
        subrefLZTotalSegmentCount = 'SegCount' --Number of segments in a land zone, against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
        subrefLZAdjacentLandZones = 'AdjLZ' --table containing all adjacent land zone references for the plateau in question, against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], i.e. ordered 1,2,3,...; and returns the LZ ref (based on the order it was added)
        subrefLZPathingToOtherLandZones = 'PathLZ' --table containing the land zone ref of some (but not all) other LZs where have recorded the paths and time taken, sorted by closest LZ first
            subrefLZNumber = 1 --Land zone reference number
            subrefLZPath = 2 --against subrefLZPathingToOtherLandZones subtable
            subrefLZTravelDist = 3 --against subrefLZPathingToOtherLandZones subtable
        subrefLZPathingToOtherLZEntryRef = 'PathRfLZ' --[x] is the target LZ reference; will return the entry in subrefLZPathingToOtherLandZones containing this path, if there is one
        subrefLZTravelDistToOtherLandZones = 'TravelLZ' --table used to store all land travel distance calculations to get from one LZ to another LZ; similar to subrefLZPathingToOtherLandZones, but intended to allow for all land zones to be recorded
        subrefLZPathingToOtherIslands = 'PathIsl' --array, [x] = (1, 2...); Ordered based on shortest travel distance
            subrefIslandNumber = 1 --Island reference number
            subrefIslandClosestLZRef = 2 --LZ ref of the LZ closest to us in this island
            subrefIslandTravelDist = 3 --Amphibious travel distance from the land zone to the closestLZRef in the IslandNumber
            subrefIslandLZPath = 4 --table of the land zones that an amphibious unit would go through to get from this LZ to the ClosestLZRef
        subrefAdjacentWaterZones = 'LZAdjWZ' --table of details for water zones adjacent to the land zone
            subrefAWZRef = 1 --The water zone reference
            subrefAWZDistance = 2 --Distance between midpoint from LZ to the WZ
        subrefLZFurthestAdjacentLandZoneTravelDist = 'FurthestAdjLZ' --Returns the travel distance (rounded up) of the furthest immediately adjacent land zone - can combine with subrefLZPathingToOtherLandZones so can stop cycling through the prerecorded LZs once get further away than the immediately adjacent ones
        subrefOtherLandAndWaterZonesByDistance = 'AirAdjLZWZ' --orders land and air zones by distance, contains subtable with the following info:
            subrefiPlateauOrPond = 1
            subrefiLandOrWaterZoneRef = 2
            subrefbIsWaterZone = 3
            subrefiDistance = 4 --straight line distance
        subrefLZPlayerWallSegments = 'PlWalls' --Table of wall units that aren't owned by M28AI
        --Reclaim related (same values used for water zone)
        subrefReclaimSegments = 'ReclSeg' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], table, orderd 1,2,3...; returns {iReclaimSegmentX, iReclaimSegmentZ}
        subrefTotalMassReclaim = 'RecMass' --total mass reclaim in the land zone
        subrefTotalEnergyReclaim = 'RecEn' --Total energy reclaim in the land zone
        subrefLastReclaimRefresh = 'RecTime' --Time that we last refreshed the reclaim in the land zone, against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]

        --Land scout/intel related
        subreftPatrolPath = 'PatrPth' --table of locations intended for a land scout to patrol the perimeter of the land zone / water zone

        --Island related
        subrefLZIslandRef = 'Island' --the island ref of the land zone (can also get by using NavUtils.GetLabel(refPathingTypeHover) for the midpoint

        --Land zone subteam data (update M28Teams.TeamInitialisation function to include varaibles here so dont have to check if they exist each time)
        subrefLZTeamData = 'Subteam' --tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData] - Table for all the data by team for a plateau's land zone
            --Variables that are against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData]:
            subrefLZTValue = 'ZVal' --Value of the zone factoring in mass, reclaim, and allied units
            subrefLZSValue = 'ZBVal' --Value of friendly buildings in the land zone
            subrefLZbCoreBase = 'ZCore' --true if this is considered a 'core base' land zone
            subrefLZCoreExpansion = 'ZExp' --true if considered the main land zone for an expansion (e.g. on an island); nil if we havent considered yet if it is a core expansion, and false if we have considered and it isnt
            subrefbCoreBaseOverride = 'ZCreO' --true if we want to make this locatio na core zone even if it doesnt meet the normal criteria (e.g. to be used when we run out of places to build in our actual core LZ)
            subrefAlliedACU = 'AACU' --table of ACU units for the land zone (so can factor into decisions on support and attack)
            subrefLZTAlliedUnits = 'Allies' --USE SAME REF AS FOR WATER ZONES - table of all allied units in the land zone, tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam][subrefLZTAlliedUnits]
            subrefLZTAlliedCombatUnits = 'AllComb' --table of allied units that are to be considered for combat orders
            subrefTEnemyUnits = 'Enemies' --table of all enemy units in the land zone or water zone (same ref used for WZ)
            reftoNearestDFEnemies = 'NearestDF' --Table of enemy DF units in this LZ, plus the nearest DF unit in each adjacnet LZ, with proximity based on unit distance and unit range (i.e. the dist until the unit is in range)
            --Ground threat values for land zones (also against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam])
            subrefLZTThreatEnemyCombatTotal = 'ECTotal'
            subrefLZTThreatAllyCombatTotal = 'ACTotal'
            subrefLZDFThreatWanted = 'DFWanted'
            subrefLZMAAThreatWanted = 'MAAThreatWanted'
            subrefLZThreatEnemyMobileDFByRange = 'EMDFByRange'
            subrefLZThreatEnemyMobileDFTotal = 'EMDFTo'
            subrefLZThreatAllyMobileDFByRange = 'AMDFByRange'
            subrefLZThreatAllyMobileDFTotal = 'ATDFT'
            subrefLZThreatEnemyMobileIndirectByRange = 'EMIFByRange'
            subrefLZThreatEnemyMobileIndirectTotal = 'EMIFTo'
            subrefLZThreatAllyMobileIndirectByRange = 'AMIFByRange'
            subrefLZThreatAllyMobileIndirectTotal = 'ATIFT'
            subrefLZThreatEnemyBestMobileDFRange = 'EBDFR'
            subrefLZThreatEnemyBestStructureDFRange = 'EBSDFR'
            subrefLZThreatEnemyBestMobileIndirectRange = 'EBIR'


            subrefLZThreatEnemyStructureDFByRange = 'ESDFByRange'
            subrefLZIndirectThreatWanted = 'IFWanted'
            subrefLZThreatAllyStructureDFByRange = 'ASDFByRange'
            subrefLZThreatEnemyStructureIndirect = 'ESITotal'
            subrefLZThreatAllyStructureIndirect = 'ASITotal'
            subrefLZThreatEnemyGroundAA = 'EAATotal'
            subrefLZThreatAllyGroundAA = 'AAATotal'
            subrefbEnemiesInThisOrAdjacentLZ = 'NearbyEnemies' --true if this LZ or adjacent LZ have nearby enemies
            subrefbDangerousEnemiesInThisLZ = 'HasDangEnemy' --true if combat units in this LZ
            subrefbDangerousEnemiesInAdjacentWZ = 'WZNearEnemies' --true if there is an adjacent water zone that has dangerous enemies
            subrefbLZWantsSupport = 'LZWantsSupport' --true if want DF or indirect units for the LZ
            subrefbLZWantsDFSupport = 'LZWantsDFSupport' --true if want DF units for the LZ
            subrefbLZWantsIndirectSupport = 'LZWantsIndirectSupport' --true if want indirect units for the LZ

            subreftEnemyFirebasesInRange = 'LZEnemyFirebasesInRange' --[x] is just a count (1,2,3), returns {iPlateau, iLandZone} of the firebase

            --Engineer related values
            subreftoPartBuiltMexes = 'PBMex' --If we are building a mex and the builder gets its orders cleared or dies, and it was building a mex, then the mex should be recorded in a table so it can be rebuilt
            subrefTbWantBP = 'WantBP' --true if we want BP at any tech level
            subrefTBuildPowerByTechWanted = 'BPByTechW' --{[1]=a, [2]=b, [3]=c} where a,b,c are the build power wanted wanted
            subrefTEngineersTravelingHere = 'EUnitsTrav' --Table of any engineer units in another LZ/WZ that have been told to move to this LZ/WZ
            subrefTScoutsTravelingHere = 'SUnitsTrav' --Table of any land scout units in another LZ/WZ that have been told to move to this LZ/WZ
            subrefSpareBPByTech = 'SpareBPByTech' --{[1]=a, [2]=b, [3]=c} where a,b,c are the build power of that tech level that we have spare
            subrefReclaimAreaAssignmentsBySegment = 'RecSegAss' --[ReclaimSegX][ReclaimZegY], returns count of how many engineers have been assigned
            subrefQueuedBuildings = 'QBByBP' --Queued buildings for a land zone
                subrefQueueRef = 1 --Unique queue reference number
                subrefBuildingID = 2 --Blueprint/UnitId of the building queued
                subrefBuildingLocation = 3 --Location the building is to be built at
                subrefBuildingRadius = 4 --Size (radius) of the building
                subrefPrimaryBuilder = 5 --Engineer given the build order
            --subrefLZTAdjacentBPByTechWanted = 'AdjBPByTechW' --{[1]=a, [2]=b, [3]=c} where a,b,c are the build power wanted wanted
            --Economy related values
            subrefActiveUpgrades = 'ActiveUpgrades' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam]
            subrefMexCountByTech = 'MexByTech' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam]
            subreftoUnitsToReclaim = 'UnitToRec' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam], table of units that we should reclaim
            --Intel related values
            refbWantLandScout = 'LandScout' --True/false, used by water and land zones
            refiRadarCoverage = 'RadCov' --Radar coverage of the centre of the land zone midpoint
            refiOmniCoverage = 'OmnCov' --Omni coverage of the centre of the land or water zone midpoint
            refiSonarCoverage = 'SonCov' --Sonar coverage of the centre of the land or water zone midpoint (intended for water zones)
            refoBestRadar = 'BestRad' --Radar providing the best Radar Coverage for the land zone midpoint
            refoBestSonar = 'BestSon' --Sonar providing the best sonar coverage for the water zone midpoint
            refiTimeLastHadVisual = 'LstVis' --Gametimeseconds that last had an intel unit (e.g. land or air scout) in the land or water zone
            refiScoutingPriority = 'SctPrio' --will return the scouting priority (i.e. 1, 2 or 3 per below subrefs)
                subrefiScoutingHighPriority = 1
                subrefiScoutingMediumPriority = 2
                subrefiScoutingLowPriority = 3
            refiRecentlyFailedScoutAttempts = 'SctFail' --if a scout dies trying to reach here, this should increase the failure count
            --Enemy air
            reftLZEnemyAirUnits = 'EnAir' --All enemy air units that are currently in the land zone
            refiEnemyAirToGroundThreat = 'EnA2GT' --Air to ground threat of enemy air units in the LZ / WZ
            refiEnemyAirAAThreat = 'EnAAT' --AirAA threat in the LZ/WZ
            refiEnemyAirOtherThreat = 'EnAirOT' --mass value of AirAA, air scouts and transports in the LZ / WZ
            --Shield, stealth and tmd
            refbLZWantsMobileShield = 'MobSh' --true if LZ wants mobile shields
            reftoLZUnitsWantingMobileShield = 'UMobSh' --table of units in the LZ that want mobile shield
            reftoLZUnitWantingFixedShield = 'UFixSh' --table of untis in the LZ taht want a fixed shield
            reftPriorityShieldsToAssist = 'FShAss' --Table of fixed shields that want to assist
            refiTimeOfLastShieldPriorityRefresh = 'FSTimC' --Time that we last updated the list of priority shields to be assisted
            refbLZWantsMobileStealth = 'MobSt' --true if LZ wants mobile stealth
            reftoLZUnitsWantingMobileStealth = 'UMobSt' --table of units in the LZ that want mobile stealth
            reftUnitsWantingTMD = 'TMDW' --table of units in the LZ that want TMD coverage
            --Misc
            reftClosestFriendlyBase = 'ClosestFB' --Position of the closest friendly start position
            reftClosestEnemyBase = 'ClosestEB' --Closest enemy start position to water zone or land zone (i.e. same variable used by both)
            refiModDistancePercent = 'ModDPC' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam], mod dist based on closest friendly start position to closest enemy start position
            refbIslandBeachhead = 'IslBeachd' --true if we are sending units to a closest island LZ to try and attack enemy - means will check for nearby untis vs enemy nearby units when deciding whether to attack or not
            refiTimeOfLastTorpAttack = 'TLstTorp' --Gametimeseconds that last sent torpedo bombers to attack units in this location
            reftoTransportsWaitingForEngineers = 'TWntEng' --Table of any transports in this LZ wanting engineers

--Pond and naval variables
    --General
iMinPondSize = 1000 --1000 is a small pond that probably barely fits a couple of naval factories
iMinWaterDepth = 1.5 --Ships cant move right up to shore, this is a guess at how much clearance is needed (testing on Africa, depth of 2 leads to some pathable areas being considered unpathable)
bHaveConsideredPreferredPondForM28AI = false --Used to make sure we dont try and create water zones until we have setup the factory build locations for each M28AI
bHaveRecordedPonds = false --set to true once finished the RecordPonds logic
    --Ponds:
tPondDetails = {}
    subreftiWaterSegmentXZ = 'WatSegXZ' --returns table, index is sequentially from 1, returns {segmentX, SegmentZ}
    subrefiSegmentCount = 'WatSegCnt' --Number of segments for a particular pond (means can quickly tell the size of the pond)
    subrefiRecordedSegmentsInWaterZones = 'WatSegRCnt' --Number of segments recorded against a specific water zone for this pond
    --subrefPondSize - use subrefiSegmentCount instead
    subrefPondMinX = 'PondMinX'
    subrefPondMinZ = 'PondMinZ'
    subrefPondMaxX = 'PondMaxX'
    subrefPondMaxZ = 'PondMaxZ'
    subrefPondMidpoint = 'PondMidpoint'
--subrefPondNearbyBrains = 'PondNearbyBrains'
    subrefPondMexInfo = 'PondMexInfo'
    subrefMexLocation = 'PondMexLocation'
    subrefMexDistance = 'PondMexDistance'
    subrefMexDFDistance = 'PondMexDFDistance'
    subrefMexDFUnblockedLocation = 'PondMexDFLocation' --i.e. the closest location we found where a DF unit should be able to hit the mex
    subrefMexIndirectDistance = 'PondMexIndirectDistance'
    subrefMexIndirectUnblockedLocation = 'PondMexIndirectLocation' --i.e. the closest location we found where an indirect unit should be able to hit the mex
    subrefBuildLocationByStartPosition = 'PondBuildLocationByStart' --Subtable, key is start position number, which stores the build location for that start position (will only record for M28 brain start positions)

    --Water zones (against tPondDetails)
    subrefPondWaterZones = 'PondWZ' --e.g. access the water zone data tables via M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone], where iWaterZone is the NavUtils refPathingTypeNavy pathing result
        subrefWZMexCount = 'MexCount' --(same ref as for land zones; reason for repating is to avoid confusion with the pond variables which track different information)
        subrefWZMexLocations = 'MexLoc' --(same ref as for land zones)
        --subrefMexUnbuiltLocations Uses same ref as LZ

        subrefWZMidpoint = 'Midpoint' --Uses same ref as land zone incase we mistyped/forgot to update copy of the code
        subrefWZSegments = 'PWZSeg' --e.g. tPondDetails[iPond][subrefPondWaterZones][iWaterZone][subrefWZSegments]
        subrefWZMinSegX = 'PWZMinSX'
        subrefWZMinSegZ = 'PWZMinSZ'
        subrefWZMaxSegX = 'PWZMaxSX'
        subrefWZMaxSegZ = 'PWZMaxSZ'
        subrefAdjacentLandZones = 'WZAdjLZ' --table of details for land zones adjacent to the land zone
            subrefWPlatAndLZNumber = 1 --returns {Plateau, LandZone}
            subrefALZDistance = 2 --Distance between midpoint from LZ to the WZ
        subrefWZAdjacentWaterZones = 'WZAdjWZ' --table of water zones that are adjacent, i.e. returns {x,y,z,...} where x y z are the water zone references for adjacent water zones
        subrefWZOtherWaterZones = 'WZOthWZ' --table of details for water zones adjacent and further away, ordered by distance
            subrefWZAWZRef = 1 --the water zone reference
            subrefWZAWZDistance = 2 --Travel distance between the midpoints of the water zones
        --Reclaim related - uses same values as water zone
        --subrefReclaimSegments
        --subrefTotalMassReclaim
        --subrefTotalEnergyReclaim
        --subrefLastReclaimRefresh

        subrefWZTeamData = 'PWZTeam' --Used to house team related data for a particular water zone
            subrefWZbCoreBase = 'WZCoreB' --true if is a 'core' base (i.e. has a naval factory in)
            subrefWZbContainsNavalBuildLocation = 'WZNavBL' --true if contains a naval build location for a friendly M28AI
            subrefWZTValue = 'WZVal' --Value of the WZ, used to prioritise sending untis to different water zones; likely to be based on distance to core base water zone
            --refiRadarCoverage - use same ref as for land zone
            --refiOmniCoverage - use same ref as land zone
            --refoBestRadar - use same ref as for land zone
            --refiTimeLastHadVisual -use same ref as for land zone
            --reftClosestFriendlyBase - use same ref as for land zone
            --reftClosestEnemyBase - use same ref as for land zone
            --refiModDistancePercent - use same ref as for land zone
            --refbWantLandScout - use same ref as for land zone
            --subreftPatrolPath - use same ref as for land zone
            --subrefOtherLandAndWaterZonesByDistance - use same ref as for land zone

            subrefWZTAlliedUnits = 'Allies' --USE SAME REF AS FOR LAND ZONE - table of all allied units in the water zone
            subrefWZTAlliedCombatUnits = 'AllComb' --table of allied units that are to be considered for combat orders
            --subrefTEnemyUnits = 'Enemies' --table of all enemy units in the water zone - uses same ref as for land zone
            reftWZEnemyAirUnits = 'EnAir' --All enemy air units that are currently in the water zone
            --Threat values
            subrefbEnemiesInThisOrAdjacentWZ = 'EnInAdjWZ' --true if enemy in this or adjacent WZ

            subrefWZTThreatEnemyCombatTotal = 'EnCom'
            subrefWZThreatEnemyAntiNavy = 'EnANav'
            subrefWZThreatEnemySubmersible = 'EnSub'
            subrefWZThreatEnemySurface = 'EnSurf'
            subrefWZThreatEnemyAA = 'EnEAA'
            subrefWZBestEnemyDFRange = 'EnDFRnge'
            subrefWZBestEnemyAntiNavyRange = 'EnANavRng'

            reftoNearestCombatEnemies = 'WNrSufE'

            subrefWZTThreatAllyCombatTotal = 'AlCom'
            subrefWZThreatAlliedAntiNavy = 'AlANav'
            subrefWZThreatAlliedSubmersible = 'AlSub'
            subrefWZThreatAlliedSurface = 'AlSurf'
            subrefWZThreatAlliedAA = 'AlAA'
            subrefWZBestAlliedDFRange = 'AlDFRnge'
            subrefWZBestAlliedSubmersibleRange = 'AlANavRng'
            refiLastBombardmentSearchRange = 'WZBmbRng' --Last range used for searching for bmobardment targets
            refbLastBombardmentSearchRangeSuccess = 'WZBmbSuc' --true if last time searched for enemies aroudn a location it found results

            subrefWZCombatThreatWanted = 'CombWant'
            subrefWZMAAThreatWanted = 'MAAWant'
            subrefbWZWantsSupport = 'WZWntSup'
            subrefbWZOnlyHoverEnemies = 'WZHvEn' --true if only hover units (so we dont want to send subs to support)
            subrefbWZOnlySubmersibleEnemies = 'WZSubEn' --true if only submersible enemies (so we dont want to send units without antinavy to support)

            reftoWZUnitsWantingMobileShield = 'MShUnit'
            refbWZWantsMobileShield = 'bWntMSh'
            reftoWZUnitsWantingMobileStealth = 'MStUnit'
            refbWZWantsMobileStealth = 'bWntMSt'

            --subrefTScoutsTravelingHere - uses same variable as land zone
            --subrefAlliedACU --Uses same variable as land zone
            --refiEnemyAirToGroundThreat --Uses same variable as land zone
            --refiEnemyAirOtherThreat --Uses same variable as land zone
            --subrefTotalMassReclaim --Uses same variable as land zone
            --Various engineer related variables - use the same references as for land zones



tPondBySegment = {} --[x][z] are the x and z segments based on iLandZoneSegmentSize, shoudl return the pond number (which is also the same as doing NavUtils.GetLabel(refPathingTypeNavy, tPosition)
tiPondByWaterZone = {} --[x] is the water zone ref, returns the pond that it belongs to
tWaterZoneBySegment = {} --[x][z] should be the x and z segments baed on iLandZoneSegmentSize, and should return the water zone number, or nil if there is none
iTotalWaterZoneCount = 0 --Unique value for waterzones so if know the waterzone reference then can identify the pond and other information just from this
iTotalWaterZoneRecordedSegmentCount = 0 --total number of segments regorded against water zones
iTotalSegmentsInPonds = 0 --Total number of segments which appear to be on water

--Land pathing segment data
tLandZoneBySegment = {} --[x][z] should be the x and z segments baed on iLandZoneSegmentSize, and should return the land zone number, or nil if there is none
tTempZoneTravelDistanceBySegment = {} --[x][z][LZ] should be the x and z segments, used to temporarily store the distance values for segments at start of the game when setting up land zones
tTempZonePlateauBySegment = {} --[x][z][LZ] shoudl be the plateau; used as a backup where we could find a LZ nearby but not a plateau


--General aiBrain variables
reftPrimaryEnemyBaseLocation = 'M28PrimaryEnemyBase' --against aiBrain, returns location of the nearest enemy base
refiLastTimeCheckedEnemyBaseLocation = 'M28MapLastTimeCheckedEnemyBase' --against aiBrain, gametimeseconds that last checked the enemy base location
reftMidpointToPrimaryEnemyBase = 'M28MapMidpointToPrimaryEnemy' --against aiBrain, midpoint between the start position and the nearest enemy start position
refbCanPathToEnemyBaseWithLand = 'M28MapCanPathToEnemyWithLand'
refbCanPathToEnemyBaseWithAmphibious = 'M28MapCanPathToEnemyWithAmphibious'

---@param tPosition table
---@return number, number
function GetPathingSegmentFromPosition(tPosition)
    --The map is divided into equal sized square segments with each segment allocated to a land zone; this can be used to get the segment X and Z references
    --tPosition shoudl be {x,y,z} format, although y value is ignored)
    return math.floor( (tPosition[1] - rMapPlayableArea[1]) / iLandZoneSegmentSize) + 1, math.floor((tPosition[3] - rMapPlayableArea[2]) / iLandZoneSegmentSize) + 1
end

---@param iSegmentX number
---@param iSegmentZ number
---@return table
function GetPositionFromPathingSegments(iSegmentX, iSegmentZ)
    --Returns the position/location of land segment X and Z references iSegmentX and iSegmentZ (i.e. the map is divided into equal sized square segments, with each segment allocated to a land zone)
    local x = iSegmentX * iLandZoneSegmentSize - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[1]
    local z = iSegmentZ * iLandZoneSegmentSize - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[2] --If changing this, then also update AssignRemainingSegmentsToLandZone which manually does this for performance
    return {x, GetTerrainHeight(x, z), z}
end

function GetPathingOverridePlateauAndLandZone(tPosition, bOptionalShouldBePathable, oOptionalPathingUnit)
    local iX = math.floor(tPosition[1])
    --if (oOptionalPathingUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oOptionalPathingUnit) or 'nil') == 'uel02031' then LOG('GetPathingOverridePlateauAndLandZone: iPlateau is nil or 0, tPosition='..repru(tPosition)..'; tPathingPlateauAndLZOverride[ix]='..repru(tPathingPlateauAndLZOverride[iX])..'; bOptionalShouldBePathable='..tostring(bOptionalShouldBePathable or false)..'; Is oOptionalPathingUnit valid='..tostring(M28UnitInfo.IsUnitValid(oOptionalPathingUnit))) end
    if tPathingPlateauAndLZOverride[iX] then
        local iZ = math.floor(tPosition[3])
        if tPathingPlateauAndLZOverride[iX][iZ] then
            --if (oOptionalPathingUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oOptionalPathingUnit) or 'nil') == 'uel02031' then LOG('GetPathingOverridePlateauAndLandZone: Have a valid override so will return this, override='..repru(tPathingPlateauAndLZOverride[iX][iZ])) end
            return tPathingPlateauAndLZOverride[iX][iZ][1], tPathingPlateauAndLZOverride[iX][iZ][2]
        end
    end
    --Dont have an override for here - if we think it shoudl be pathable then create an override
    if bOptionalShouldBePathable and oOptionalPathingUnit then
        --if (oOptionalPathingUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oOptionalPathingUnit) or 'nil') == 'uel02031' then LOG('GetPathingOverridePlateauAndLandZone: No plateau for a unit that should be pathable, tPosition='..repru(tPosition)..'; bOptionalShouldBePathable='..tostring(bOptionalShouldBePathable)..'; oOptionalPathingUnit='..oOptionalPathingUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOptionalPathingUnit)..'; oOptionalPathingUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]='..repru(oOptionalPathingUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam])..'; Unit state='..M28UnitInfo.GetUnitState(oOptionalPathingUnit)..'; iMapWaterHeight='..iMapWaterHeight..'; about to run ConsiderAddingPlateauOverrideForUnit') end
        if M28Land.ConsiderAddingPlateauOverrideForUnit(oOptionalPathingUnit) then
            if tPathingPlateauAndLZOverride[iX] then
                local iZ = math.floor(tPosition[3])
                if tPathingPlateauAndLZOverride[iX][iZ] then
                    --if (oOptionalPathingUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oOptionalPathingUnit) or 'nil') == 'uel02031' then LOG('GetPathingOverridePlateauAndLandZone: Have a valid override after considering plateau override for unit, override='..repru(tPathingPlateauAndLZOverride[iX][iZ])) end
                    return tPathingPlateauAndLZOverride[iX][iZ][1], tPathingPlateauAndLZOverride[iX][iZ][2]
                end
            end
        end
    end
    return nil, nil
end

function GetWaterZoneFromPosition(tPosition)
    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tPosition)
    return tWaterZoneBySegment[iSegmentX][iSegmentZ]
end

---@param tPosition table
---@param bOptionalShouldBePathable boolean
---@return number, number
function GetPlateauAndLandZoneReferenceFromPosition(tPosition, bOptionalShouldBePathable, oOptionalPathingUnit)
    --Returns the plateau reference of tPosition (where tPosition is {x,y,z}), and the Land zone reference for that position
    --returns nil if cant find valid plateau or land zone
    --bOptionalShouldBePathable - if e.g. have a unit at tPosition, then set this to true as it means somehow a unit could path in this area, and the code will then try backup options and give error messages

    --Get the plateau reference and the land segment X and Z references:
    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tPosition)
    local iPlateau = NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iSegmentX, iSegmentZ))
    local iLandZone

    if (iPlateau or 0) <= 0 or not(tAllPlateaus[iPlateau]) then
        --Check if we have previously recorded this location with a pathing override
        --LOG('GetPlateauAndLandZoneReferenceFromPosition iPlateau='..(iPlateau or 'nil'))
        iPlateau, iLandZone = GetPathingOverridePlateauAndLandZone(tPosition, bOptionalShouldBePathable, oOptionalPathingUnit)
        --LOG('GetPlateauAndLandZoneReferenceFromPosition iPlateau after getting override='..(iPlateau or 'nil'))
        if not(tAllPlateaus[iPlateau]) then
            --Potential error - see if there is a plateau for the preicse position if it shoudl be pathable

            --LOG('GetPlateauAndLandZoneReferenceFromPosition: tAllPlateaus is nil for iPlateau='..(iPlateau or 'nil')..'; if should be pathable will check the segment we are in/ bOptionalShouldBePathable='..tostring(bOptionalShouldBePathable or false))
            if bOptionalShouldBePathable then
                iPlateau = NavUtils.GetLabel(refPathingTypeHover, tPosition)

                if not(tAllPlateaus[iPlateau]) then
                    if bOptionalShouldBePathable then
                        --If get this error, then refer to GetUnitPlateauAndLandZoneOverride
                        M28Utilities.ErrorHandler('No plateau group for iSegmentX='..iSegmentX..'; iSegmentZ='..iSegmentZ..'; Plateau group of segment midpoint='..(NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iSegmentX, iSegmentZ)) or 'nil')..'; Plateau Group of tPosition='..(NavUtils.GetLabel(refPathingTypeHover, tPosition) or 'nil')..'; Pathing unit='..(oOptionalPathingUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oOptionalPathingUnit) or 'nil')..'; Enable logs in the function GetUnitPlateauAndLandZoneOverride for more details')
                    end
                    return nil
                else
                    if tAllPlateaus[iPlateau][subrefPlateauTotalMexCount] == 0 then
                        iLandZone = 1
                    else
                        --more than 1 land zone so return nil
                        iLandZone = nil
                    end
                end
            else
                return nil
            end
        end
        return iPlateau, iLandZone
    else
        --Have a valid plateau, get the land zone reference:
        --local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tPosition)
        iLandZone = tLandZoneBySegment[iSegmentX][iSegmentZ]
        --LOG('GetPlateauAndLandZoneReferenceFromPosition - iLandZOne='..(iLandZone or 'nil'))
        if not(iLandZone) then
            --Are we above water in height? If so check for override
            if tPosition[2] > iMapWaterHeight then
                local iAltPlateau
                iAltPlateau, iLandZone = GetPathingOverridePlateauAndLandZone(tPosition, bOptionalShouldBePathable, oOptionalPathingUnit)
                if not(iLandZone) and bOptionalShouldBePathable then
                    --Possible explanation - engineer has traveled across water and reached a cliff
                    if EntityCategoryContains(categories.HOVER + categories.AMPHIBIOUS, oOptionalPathingUnit.UnitId) then
                        --Do nothing - hopefully unit has orders that it will follow that will resolve this on its own; however update the plateau
                    else
                        M28Utilities.ErrorHandler('Unable to find valid land zone, tPosition[1-3]='..tPosition[1]..'-'..tPosition[2]..'-'..tPosition[3]..'; oOptionalPathingUnit='..(oOptionalPathingUnit.UnitId or 'nil')..' with LC='.. M28UnitInfo.GetUnitLifetimeCount(oOptionalPathingUnit))
                        --M28Utilities.DrawLocation(tPosition)
                    end
                else
                    if iAltPlateau then
                        iPlateau = iAltPlateau
                    end
                end
            end
        end
    end
    --LOG('GetPlateauAndLandZoneReferenceFromPosition - end of code, iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil'))


    return iPlateau, iLandZone
end

function GetNearestPlateauOrLandOrWaterZoneToLocationFORLOOKUP(tLocation)  --Only to help with lookup - use below function
    return GetClosestPlateauOrZeroAndZoneToPosition(tPosition)
end --Only to help with lookup - use below function
function GetClosestPlateauOrZeroAndZoneToPosition(tPosition)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetClosestPlateauOrZeroAndZoneToPosition'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tPosition)

    if bDebugMessages == true then LOG(sFunctionRef..': tPosition='..repru(tPosition)..'; iSegmentX='..iSegmentX..' iSegmentZ='..iSegmentZ..'; Is override for this nil='..tostring(tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ] == nil)) end

    if tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ] then
        if bDebugMessages == true then LOG(sFunctionRef..': Returning override, which is:'..repru(tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ])) end
        return tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ][1], tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ][2]
    else
        local iPlateau = NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iSegmentX, iSegmentZ))
        if bDebugMessages == true then LOG(sFunctionRef..': Position from segments='..repru(GetPositionFromPathingSegments(iSegmentX, iSegmentZ))..'; iPlateau for this='..(iPlateau or 'nil')) end
        if (iPlateau or 0) <= 0 or (tLandZoneBySegment[iSegmentX][iSegmentZ] == nil and tWaterZoneBySegment[iSegmentX][iSegmentZ] == nil) then
            --Need to get an override if dont already have one
            local iAltPlateau, iAltLZOrWZ
            local iFailureCount = 0
            if not(tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX]) then tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX] = {} end
            for iAdjust = 1, math.min(iMaxLandSegmentX, iMaxLandSegmentZ) do
                for iXAdjust = -iAdjust, iAdjust, 1 do
                    for iZAdjust = -iAdjust, iAdjust, 1 do
                        if not(iXAdjust == 0 and iZAdjust == 0) then
                            if tLandZoneBySegment[iSegmentX+ iXAdjust][iSegmentZ+ iZAdjust] or tWaterZoneBySegment[iSegmentX+ iXAdjust][iSegmentZ+ iZAdjust] then
                                iAltPlateau = NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iSegmentX + iXAdjust, iSegmentZ + iZAdjust))
                                if (iAltPlateau or 0) > 0 then
                                    iAltLZOrWZ = tLandZoneBySegment[iSegmentX+ iXAdjust][iSegmentZ+ iZAdjust]
                                    if (iAltLZOrWZ or 0) == 0 then
                                        iAltLZOrWZ = tWaterZoneBySegment[iSegmentX+ iXAdjust][iSegmentZ+ iZAdjust]
                                        iAltPlateau = 0
                                    end
                                    if (iAltLZOrWZ or 0) > 0 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have adjusted segments which have valid values, iAltLZOrWZ='..iAltLZOrWZ..'; iXAdjust='..iXAdjust..'; iZAdjust='..iZAdjust) end
                                        tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ] = {[1] = iAltPlateau, [2] = iAltLZOrWZ}
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        return iAltPlateau, iAltLZOrWZ
                                    else
                                        --Redundancy
                                        iFailureCount = iFailureCount + 1
                                        if iFailureCount >= 20 then
                                            M28Utilities.ErrorHandler('Have a valid plateau for SegmentX-Z='..(iSegmentX + iXAdjust)..'-'..(iSegmentZ + iZAdjust)..' but not a valid land or water zone, and have failed '..iFailureCount..' times now (will reset count after this)')
                                            iFailureCount = 0
                                        end
                                    end
                                else
                                    if iFailureCount >= 20 then
                                        M28Utilities.ErrorHandler('Have a valid land or WZ for SegmentX-Z='..(iSegmentX + iXAdjust)..'-'..(iSegmentZ + iZAdjust)..' but not a valid plateau, and have failed '..iFailureCount..' times now (will reset count after this)')
                                        iFailureCount = 0
                                    end
                                end
                            end
                        end
                    end
                end
                if iAdjust >= 100 then M28Utilities.ErrorHandler('Likely error locating valid segment for iSegmentX-Z='..iSegmentX..'-'..iSegmentZ) end
            end
        else
            --Have a valid plateau and land or water zone
            if bDebugMessages == true then LOG(sFunctionRef..': Have a valid plateau, tLandZoneBySegment='..(tLandZoneBySegment[iSegmentX][iSegmentZ] or 'nil')..'; tWaterZoneBySegment='..(tWaterZoneBySegment[iSegmentX][iSegmentZ] or 'nil')) end
            if (tLandZoneBySegment[iSegmentX][iSegmentZ] or 0) == 0 then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return 0, tWaterZoneBySegment[iSegmentX][iSegmentZ]
            else
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return iPlateau, tLandZoneBySegment[iSegmentX][iSegmentZ]
            end
            end
    end
end

---@param tLocation table
---@return number, number
function GetReclaimSegmentsFromLocation(tLocation)
    --Returns the reclaim segment X and Z values for a given location on the map (i.e. map is divided into reclaim segment squares which are a different size to land zone segments)
    --tLocation should be in the {x,y,z} format, although y value is ignored
    return math.ceil(tLocation[1] / iReclaimSegmentSizeX), math.ceil(tLocation[3] / iReclaimSegmentSizeZ)
end

---@param iReclaimSegmentX number
---@param iReclaimSegmentZ number
---@return table
function GetReclaimLocationFromSegment(iReclaimSegmentX, iReclaimSegmentZ)
    --If given the reclaim segment X and Z values, then will convert this into an {x,y,z} position
    --e.g. segment (1,1) will be 0 to ReclaimSegmentSizeX and 0 to ReclaimSegmentSizeZ in size
    --This will return the midpoint of the reclaim segment
    if tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint] then return tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint]
    else
        local iX = math.max(rMapPlayableArea[1], math.min(rMapPlayableArea[3], (iReclaimSegmentX - 0.5) * iReclaimSegmentSizeX))
        local iZ = math.max(rMapPlayableArea[2], math.min(rMapPlayableArea[4], (iReclaimSegmentZ - 0.5) * iReclaimSegmentSizeZ))
        return {iX, GetSurfaceHeight(iX, iZ), iZ}
    end
end

local function SetupPlayableAreaAndSegmentSizes()
    --Sets up key values needed to divide the map up into segments (small squares) for both land zone segments and reclaim segments - should be called as one of the first pieces of code
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DetermineReclaimAndLandSegmentSizes'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if ScenarioInfo.MapData.PlayableRect then
        rMapPlayableArea = ScenarioInfo.MapData.PlayableRect
    else
        rMapPlayableArea = {0, 0, ScenarioInfo.size[1], ScenarioInfo.size[2]}
    end


    --Decide on land zone segment sizes
    local iHighestSize = math.max(rMapPlayableArea[3] - rMapPlayableArea[1], rMapPlayableArea[4] - rMapPlayableArea[2])
    local iTableSizeCap = 25000 --tried with 50k but on a 10km map it took too long to do the initial setup

    --iTableSizeCap = SegmentCount^2; SegmentCount = iTotalSize / SegmentSize; (TotalSize/SegmentSize)^2 = iTableSizeCap; SemgentSize = TotalSize/Sqrt(iTableSizeCap)
    iLandZoneSegmentSize = math.ceil(iHighestSize / math.sqrt(iTableSizeCap))

    --Record the max values
    iMaxLandSegmentX, iMaxLandSegmentZ = GetPathingSegmentFromPosition({rMapPlayableArea[3], 0, rMapPlayableArea[4]})

    if bDebugMessages == true then LOG(sFunctionRef..': iHighestSize='..iHighestSize..'; iTableSizeCap='..iTableSizeCap..'; iLandZoneSegmentSize='..iLandZoneSegmentSize..'; Max Segment X-Z='..iMaxLandSegmentX..'-'..iMaxLandSegmentZ) end


    local iMinReclaimSegmentSize = 8.5 --Engineer build range is 6; means that a square of about 4.2 will fit inside this circle; If have 2 separate engineers assigned to adjacent reclaim segments, and want their build range to cover the two areas, then would want a gap twice this, so 8.4; will therefore go with min size of 8
    local iMapSizeX = rMapPlayableArea[3] - rMapPlayableArea[1]
    local iMapSizeZ = rMapPlayableArea[4] - rMapPlayableArea[2]
    iReclaimSegmentSizeX = math.max(iMinReclaimSegmentSize, iLandZoneSegmentSize)
    iReclaimSegmentSizeZ = math.max(iMinReclaimSegmentSize, iLandZoneSegmentSize)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param sResourceType string
---@param x number
---@param y number
---@param z number
function RecordResourcePoint(sResourceType,x,y,z,size)
    --called by hook into simInit, more reliable method of figuring out if have adaptive map than using markers, as not all mass markers may have mexes generated on an adaptive map
    --Whenever a resource location is created in the map, this is called, and will record the resource location into a table of mex points (tMassPoints) and hydro points (tHydroPoints) for referencing in later code
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordResourcePoint'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': sResourceType='..sResourceType..'; x='..x..'; y='..y..'; z='..z..'; size='..repru(size)..'; Mass count pre update='..table.getn(tMassPoints)..'; Hydro points pre update='..table.getn(tHydroPoints)) end

    if sResourceType == 'Mass' then
        table.insert(tMassPoints, {x,y,z})
    elseif sResourceType == 'Hydrocarbon' then
        table.insert(tHydroPoints, {x,y,z})
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of hook; Mass points post update='..table.getn(tMassPoints)..'; Hydro poitns post update='..table.getn(tHydroPoints)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param sPathing string
---@param tLocation table
---@return number
function GetSegmentGroupOfLocation(sPathing, tLocation)
    --Included for backwards compatibility with M27 logic; better to use the below line directly
    --Returns a reference number based on sPathing that groups areas based on whether they can path to each other (so if two locations have the same reference, they can path to each other)
    --sPathing should be one of the refPathingType variables defined at the top of this file; tLocation is {x,y,z} format
    return NavUtils.GetLabel(sPathing, tLocation)
end

local function RecordMexForPathingGroup()
    --Cycles through every mex on the map, and includes it in a table of mexes that is grouped by pathing type, so in future we can easily cycle through mexes for a particular pathing type
    --e.g. after running this, can use tMexByPathingAndGrouping[sPathing][iPathingGroup] where sPathing is the refPathingType variable, and ipathingGroup is the NavUtils.GetLabel(sPathing, tLocation) reference
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordMexForPathingGroup'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': About to record mexes for each pathing group. MassPoints='..repru(tMassPoints)) end
    local tsPathingTypes = {refPathingTypeHover, refPathingTypeNavy, refPathingTypeLand}
    local iCurResourceGroup
    local iValidCount = 0
    tMexByPathingAndGrouping = {}
    if bDebugMessages == true then
        LOG(sFunctionRef..': NavUtils test - will cycle through each mex and get land label')
        for iMex, tMex in tMassPoints do
            LOG(sFunctionRef..': tMex='..repru(tMex)..'; Label='..(NavUtils.GetLabel('Land', tMex) or 'nil'))
            if not(NavUtils.GetLabel('Land', tMex)) then
                LOG(sFunctionRef..': WARNING - dont have a land label for mex '..repru(tMex))
            else
                LOG(sFunctionRef..': Have a land label for mex '..repru(tMex)..' so will stop with warning messages as pathing apepars generated')
                break
            end
        end
    end
    for iPathingType, sPathing in tsPathingTypes do
        tMexByPathingAndGrouping[sPathing] = {}
        iValidCount = 0

        if bDebugMessages == true then LOG(sFunctionRef..': About to record all mexes for pathing type sPathing='..sPathing) end

        for iCurMex, tMexLocation in tMassPoints do
            iValidCount = iValidCount + 1
            iCurResourceGroup = NavUtils.GetLabel(sPathing, tMexLocation)
            if not(iCurResourceGroup) then
                if bDebugMessages == true then LOG('Dont have a resource group for mex location '..repru(tMexLocation)..'; This is expected if mexes are located outside the playable area or are testing water pathing for land mexes and vice versa') end
            else
                if bDebugMessages == true then
                    LOG(sFunctionRef..': iCurMex='..iCurMex..'; About to get segment group for pathing='..sPathing..'; location='..repru((tMexLocation or {'nil'}))..'; iCurResourceGroup='..(iCurResourceGroup or 'nil'))
                    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tMexLocation)
                    LOG(sFunctionRef..': Pathing segments='..(iSegmentX or 'nil')..'; iSegmentZ='..(iSegmentZ or 'nil')..'; rMapPlayableArea='..repru(rMapPlayableArea)..'; iLandZoneSegmentSize='..(iLandZoneSegmentSize or 'nil'))
                end
                if tMexByPathingAndGrouping[sPathing][iCurResourceGroup] == nil then
                    tMexByPathingAndGrouping[sPathing][iCurResourceGroup] = {}
                    iValidCount = 1
                else iValidCount = table.getn(tMexByPathingAndGrouping[sPathing][iCurResourceGroup]) + 1
                end
                tMexByPathingAndGrouping[sPathing][iCurResourceGroup][iValidCount] = tMexLocation
                if bDebugMessages == true then LOG(sFunctionRef..': iValidCount='..iValidCount..'; sPathing='..sPathing..'; iCurResourceGroup='..iCurResourceGroup..'; just added tMexLocation='..repru(tMexLocation)..' to this group') end
            end
        end
        if sPathing == refPathingTypeLand and iValidCount == 0 then M28Utilities.ErrorHandler('Dont have any mexes recording for land pathing type') end
    end
    if bDebugMessages == true then LOG(sFunctionRef..'; tMexByPathingAndGrouping='..repru(tMexByPathingAndGrouping)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordMexlessPlateau(iPlateau)
    tAllPlateaus[iPlateau] = {}
    tAllPlateaus[iPlateau][subrefPlateauTotalMexCount] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones] = {}
    tAllPlateaus[iPlateau][subrefLandZoneCount] = 0
end

local function RecordAllPlateaus()
    --Records any plateaus that contain mexes, along with info on the plateau
    --tAllPlateaus[iSegmentGroup] can be used to then reference subtables with further information on the plateau, where iSegmentGroup is the result of NavUtils.GetLabel(refPathingTypeHover, {x,y,z})

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAllPlateaus'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCurPlateauMex
    local iMinSegmentX, iMinSegmentZ, iMaxSegmentX, iMaxSegmentZ, iCurSegmentGroup

    if bDebugMessages == true then LOG(sFunctionRef..': About to get max map segment X and Z based on rMapPlayableArea='..repru(rMapPlayableArea)) end
    local iMapMaxSegmentX, iMapMaxSegmentZ = GetPathingSegmentFromPosition({rMapPlayableArea[3], 0, rMapPlayableArea[4]})
    local iStartSegmentX, iStartSegmentZ
    local bSearchingForBoundary
    local iCurCount
    local tSegmentPosition
    local iReclaimSegmentStartX, iReclaimSegmentStartZ, iReclaimSegmentEndX, iReclaimSegmentEndZ
    local sPathing = refPathingTypeHover


    --Cycle through every amphibious pathing group that has mexes in it:
    for iSegmentGroup, tSubtable in tMexByPathingAndGrouping[sPathing] do
        --If we dont already have a plateau setup then create one:
        if not(tAllPlateaus[iSegmentGroup]) then
            --Have a plateau with mexes that havent already recorded
            tAllPlateaus[iSegmentGroup] = {}
            tAllPlateaus[iSegmentGroup][subrefPlateauMexes] = {}
            iCurPlateauMex = 0
            --Record every mex against the PlateausWithMexes table:
            for iMex, tMex in tMexByPathingAndGrouping[sPathing][iSegmentGroup] do
                iCurPlateauMex = iCurPlateauMex + 1
                tAllPlateaus[iSegmentGroup][subrefPlateauMexes][iCurPlateauMex] = tMex
            end
            tAllPlateaus[iSegmentGroup][subrefPlateauTotalMexCount] = iCurPlateauMex
            --Record additional information if the plateau has mexes:
            if iCurPlateauMex > 0 then
                --Record information on the size of the plateau:
                --Start from mex, and move up on map to determine top point; then move left to determine left point, and right to determine right point etc.
                --i.e. dont want to go through every segment on map since could take ages if lots of plateaus and may only be dealing with small area
                iStartSegmentX, iStartSegmentZ = GetPathingSegmentFromPosition(tAllPlateaus[iSegmentGroup][subrefPlateauMexes][1])

                --First find the smallest z (so go up)
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount > iStartSegmentZ then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments(iStartSegmentX, iStartSegmentZ - iCurCount))  --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX][iStartSegmentZ - iCurCount]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartX = 1, iMapMaxSegmentX do
                            iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments(iAltStartX, iStartSegmentZ - iCurCount)) --tPathingSegmentGroupBySegment[sPathing][iAltStartX][iStartSegmentZ - iCurCount]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentX = iAltStartX
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                --Will have the min Z value now
                iMinSegmentZ = iStartSegmentZ - iCurCount + 1


                --Now check for the min X value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount > iStartSegmentX then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX - iCurCount), iStartSegmentZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX - iCurCount][iStartSegmentZ]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same X value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartZ = iMinSegmentZ, iMapMaxSegmentZ do
                            iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX - iCurCount), iAltStartZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX - iCurCount][iAltStartZ]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentZ = iAltStartZ
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end

                --Will now have the min X value
                iMinSegmentX = iStartSegmentX - iCurCount + 1

                --Now get max Z value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount + iStartSegmentZ > iMapMaxSegmentZ then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments(iStartSegmentX, (iStartSegmentZ + iCurCount))) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX][iStartSegmentZ + iCurCount]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartX = iMinSegmentX, iMapMaxSegmentX do
                            iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments(iAltStartX, (iStartSegmentZ + iCurCount))) --tPathingSegmentGroupBySegment[sPathing][iAltStartX][iStartSegmentZ + iCurCount]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentX = iAltStartX
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                iMaxSegmentZ = iStartSegmentZ + iCurCount - 1

                --Now get the max X value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount + iStartSegmentX > iMapMaxSegmentX then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX + iCurCount), iStartSegmentZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX + iCurCount][iStartSegmentZ]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartZ = iMinSegmentZ, iMaxSegmentZ do
                            iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX + iCurCount), iAltStartZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX + iCurCount][iAltStartZ]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentZ = iAltStartZ
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                iMaxSegmentX = iStartSegmentX + iCurCount - 1

                --Have now got the min and max land segment X and Z values for the plateau
                tSegmentPosition = GetPositionFromPathingSegments(iMinSegmentX, iMinSegmentZ)
                tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ] = {tSegmentPosition[1], tSegmentPosition[3]}
                iReclaimSegmentStartX, iReclaimSegmentStartZ = GetReclaimSegmentsFromLocation(tSegmentPosition)

                tSegmentPosition = GetPositionFromPathingSegments(iMaxSegmentX, iMaxSegmentZ)
                tAllPlateaus[iSegmentGroup][subrefPlateauMaxXZ] = {tSegmentPosition[1], tSegmentPosition[3]}
                iReclaimSegmentEndX, iReclaimSegmentEndZ = GetReclaimSegmentsFromLocation(tSegmentPosition)


                --Record all reclaim segments that are part of the plateau
                tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments] = {}
                for iCurReclaimSegmentX = iReclaimSegmentStartX, iReclaimSegmentEndX do
                    tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX] = {}
                    for iCurReclaimSegmentZ = iReclaimSegmentStartZ, iReclaimSegmentEndZ do
                        if iSegmentGroup == NavUtils.GetLabel(sPathing,GetReclaimLocationFromSegment(iCurReclaimSegmentX, iCurReclaimSegmentZ)) then
                            tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX][iCurReclaimSegmentZ] = true
                        end
                    end
                end
                --Clear any empty values
                for iCurReclaimSegmentX = iReclaimSegmentStartX, iReclaimSegmentEndX do
                    if tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX] and M28Utilities.IsTableEmpty(tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX]) then tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX] = nil end
                end

                --Record midpoint of the plateau
                local iXRadius = (tAllPlateaus[iSegmentGroup][subrefPlateauMaxXZ][1] - tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ][1])*0.5
                local iZRadius = (tAllPlateaus[iSegmentGroup][subrefPlateauMaxXZ][2] - tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ][2])*0.5
                tAllPlateaus[iSegmentGroup][subrefPlateauMidpoint] = {tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ][1] + iXRadius, 0, tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ][2] + iZRadius}
                tAllPlateaus[iSegmentGroup][subrefPlateauMidpoint][2] = GetTerrainHeight(tAllPlateaus[iSegmentGroup][subrefPlateauMidpoint][1], tAllPlateaus[iSegmentGroup][subrefPlateauMidpoint][3])
                --CIrcle radius will be the square/rectangle diagonal, so (square radius^2*2)^0.5 for a square, or (x^2+z^2)^0.5

                tAllPlateaus[iSegmentGroup][subrefPlateauMaxRadius] = (iXRadius^2+iZRadius^2)^0.5
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, listing tAllPlateaus='..repru(tAllPlateaus)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param iPlateau number
local function AddNewLandZoneReferenceToPlateau(iPlateau)
    --Adds a new land zone reference number to iPlateau, assumes that information about the zone will be added later
    --Intended to be called as part of wider code for recording a land zone, e.g. from CreateNewLandZoneAtSegment and similar functions
    --iPlateau is the result of NavUtils.GetLabel(refPathingTypeHover, tLocation)
    --To get the land zone created by this immediately after it is created, use iLandZone = tAllPlateaus[iPlateau][subrefLandZoneCount]
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddNewLandZoneReferenceToPlateau'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if not(tAllPlateaus[iPlateau]) then
        --Presumably we have a plateau with no mexes so add this plateau to the table of plateaus
        tAllPlateaus[iPlateau] = {}
        tAllPlateaus[iPlateau][subrefPlateauTotalMexCount] = 0
    end
    if not(tAllPlateaus[iPlateau][subrefLandZoneCount]) then
        tAllPlateaus[iPlateau][subrefLandZoneCount] = 0
        tAllPlateaus[iPlateau][subrefPlateauLandZones] = {}
    end
    tAllPlateaus[iPlateau][subrefLandZoneCount] = (tAllPlateaus[iPlateau][subrefLandZoneCount] or 0) + 1
    local iLandZone = tAllPlateaus[iPlateau][subrefLandZoneCount]
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexCount] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexLocations] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefMexUnbuiltLocations] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefHydroLocations] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefHydroUnbuiltLocations] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefTotalMassReclaim] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefBuildLocationsBySize] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefBuildLocationBlacklist] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefBuildLocationSegmentCountBySize] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTotalSegmentCount] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefTotalMassReclaim] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefTotalEnergyReclaim] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTravelDistToOtherLandZones] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZPlayerWallSegments] = {}

    if bDebugMessages == true then
        LOG('Time='..GetGameTimeSeconds()..'; Finished setting up variables for iPlateau='..iPlateau..'; iLandZone='..iLandZone)
        M28Utilities.ErrorHandler('Audit trail')
    end


    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end



function RecordSegmentLandZone(iSegmentX, iSegmentZ, iPlateau, iLandZone)
    if not(tLandZoneBySegment[iSegmentX]) then tLandZoneBySegment[iSegmentX] = {} end
    tLandZoneBySegment[iSegmentX][iSegmentZ] = iLandZone
    if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments]) then
        if not(tAllPlateaus[iPlateau]) then RecordMexlessPlateau(iPlateau) end
        if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]) then
            AddNewLandZoneReferenceToPlateau(iPlateau)
            iLandZone = tAllPlateaus[iPlateau][subrefLandZoneCount]
        end

    end
    if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments]) then
        LOG('ERROR - RecordSegmentLandZoneTempLog: iSegmentX='..(iSegmentX or 'nil')..'; iSegmentZ='..(iSegmentZ or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iPlateau='..(iPlateau or 'nil')..'; tAllPlateaus[iPlateau][subrefPlateauLandZones]='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones]))
        M28Utilities.DrawLocation(GetPositionFromPathingSegments(iSegmentX, iSegmentZ), 1, 200, 3)
    else
        table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments], {iSegmentX, iSegmentZ})
        tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTotalSegmentCount] = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTotalSegmentCount] + 1
    end
end

local function ReorderLandZoneSegmentsForEachPlateau()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReorderLandZoneSegmentsForEachPlateau'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Updates tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments] so it is sorted based on the distance to the middle of the zone
    local iMidSegmentX, iMidSegmentZ
    local tiSegmentsByDistance
    local tiSortedSegmentsByDistance
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLZSubtable in tPlateauSubtable[subrefPlateauLandZones] do
            tiSegmentsByDistance = {}
            tiSortedSegmentsByDistance = {}
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Midpoint='..repru(tLZSubtable[subrefLZMidpoint])) end
            iMidSegmentX, iMidSegmentZ = GetPathingSegmentFromPosition(tLZSubtable[subrefLZMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': About to reorder the segments in iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Segments before sorting='..repru(tLZSubtable[subrefLZSegments])) end
            for iSegmentRef, tSegmentXZ in tLZSubtable[subrefLZSegments] do
                table.insert(tiSegmentsByDistance, {['Segments']={tSegmentXZ[1], tSegmentXZ[2]}, ['Distance']=(math.abs(tSegmentXZ[1] - iMidSegmentX) + math.abs(tSegmentXZ[2] - iMidSegmentZ))})
            end
            --Now sort by distance
            tLZSubtable[subrefLZSegments] = {}
            if bDebugMessages == true then LOG(sFunctionRef..': tiSegmentsByDistance='..repru(tiSegmentsByDistance)) end
            for iEntry, tValue in M28Utilities.SortTableBySubtable(tiSegmentsByDistance, 'Distance', true) do
                if bDebugMessages == true then LOG(sFunctionRef..': iEntry='..iEntry..';tValue='..repru(tValue)..'; Inserting value '..repru(tValue['Segments'])..' into the main LZSubtable') end
                table.insert(tLZSubtable[subrefLZSegments], tValue['Segments'])
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished sorting for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Segments after sorting='..repru(tLZSubtable[subrefLZSegments])) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


---@param iBaseSegmentX number
---@param iBaseSegmentZ number
local function CreateNewLandZoneAtSegment(iBaseSegmentX, iBaseSegmentZ)
    --Creates a new land zone reference at the land segment given by iBaseSegmentX-iBaseSegmentZ (includes adding new land zone reference to the plateau group that these segments are part of)
    --iBaseSegmentX and Z are the land segment X and Z references
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateNewLandZoneAtSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --First check we dont have a zone assigned already (redundancy)
    if not(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
        --PlateauGroup ref will be the amphibious pathing ref from navutils.getlabel (since that's what is used to define mexes by amphibious pathing group, and plateau recognition then uses the same reference)
        local tMidpoint = GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
        local iPlateau = NavUtils.GetLabel(refPathingTypeHover, tMidpoint)
        AddNewLandZoneReferenceToPlateau(iPlateau)
        --LOG('Have just created a new land zone reference for base segment XZ='..iBaseSegmentX..'-'..iBaseSegmentZ..' in the iPlateau='..iPlateau)
        RecordSegmentLandZone(iBaseSegmentX, iBaseSegmentZ, iPlateau, tAllPlateaus[iPlateau][subrefLandZoneCount])

    else
        M28Utilities.ErrorHandler('Trying to create a new zone for base segment '..iBaseSegmentX..'-'..iBaseSegmentZ..' when it already has a land zone assigned '..tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ])
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param iPlateau number
---@param iOptionalLandZone number
---@param iPlateauMexRef number
---@param tTempPlateauLandZoneByMexRef table
local function AddMexToLandZone(iPlateau, iOptionalLandZone, iPlateauMexRef, tTempPlateauLandZoneByMexRef)
    --Determine the land zone if it isnt specified
    --iPlateau is the result of NavUtils.GetLabel(refPathingTypeHover, tLocation)
    --iOptionalLandZone - if not specified, then this will create a new land zone for iPlateau and use htis reference
    --iPlateauMexRef - the reference key in the table tAllPlateaus[iPlateau][subrefPlateauMexes], which should return the location of the mex
    --tTempPlateauLandZoneByMexRef - temporary table used to store information for purposes of creating the land zones

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddMexToLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Get the land zone that we are using (/create a new land zone if we haven't had one specified to be used):
    local iLandZone
    if iOptionalLandZone then iLandZone = iOptionalLandZone
    else
        AddNewLandZoneReferenceToPlateau(iPlateau)
        iLandZone = tAllPlateaus[iPlateau][subrefLandZoneCount]
    end

    --Add the mex to this land zone
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexCount] = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexCount] + 1
    table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexLocations], tAllPlateaus[iPlateau][subrefPlateauMexes][iPlateauMexRef])
    tTempPlateauLandZoneByMexRef[iPlateau][iPlateauMexRef] = iLandZone
    local iCurSegmentX, iCurSegmentZ = GetPathingSegmentFromPosition(tAllPlateaus[iPlateau][subrefPlateauMexes][iPlateauMexRef])
    RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iPlateau, iLandZone)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function AddMexToWaterZone(iPond, iWaterZone, tMex)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddMexToWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Add the mex to this water zone
    local bAlreadyRecorded = false --(expect to be the case every time, but were getting issues with the same location appearing multiple itmes in unbuilt locations so adding as redundancy)
    local tWZData = tPondDetails[iPond][subrefPondWaterZones][iWaterZone]
    if not(tWZData[subrefWZMexLocations]) then
        tWZData[subrefWZMexLocations] = {}
        tWZData[subrefWZMexCount] = 0
    else
        --Check not already recorded
        for iEntry, tLocation in tWZData[subrefWZMexLocations] do
            if math.abs(tLocation[1] - tMex[1]) <= 0.9 and math.abs(tLocation[3] - tMex[3]) <= 0.9 then
                bAlreadyRecorded = true
                break
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Considering recording mex at position '..repru(tMex)..' for iWaterZone'..iWaterZone..'; bAlreadyRecorded='..tostring(bAlreadyRecorded)) end
    if not(bAlreadyRecorded) then
        tWZData[subrefWZMexCount] = tWZData[subrefWZMexCount] + 1
        table.insert(tWZData[subrefWZMexLocations], tMex)

        if M28Conditions.CanBuildOnMexLocation(tMex) then
            if not(tWZData[subrefMexUnbuiltLocations]) then tWZData[subrefMexUnbuiltLocations] = {} end
            table.insert(tWZData[subrefMexUnbuiltLocations], tMex)
        else
            --DOuble-check - if there are no buildings in a rectangle around the mex then treat it as buildable (note - havent tested the below as added when thought were failing to record mexes on a map but it turned out to be another unrelated issue)
            local rRect = M28Utilities.GetRectAroundLocation(tMex, 0.9)
            local tUnitsByMex = GetUnitsInRect(rRect)
            local bNearbyMex = false
            if M28Utilities.IsTableEmpty(tUnitsByMex) == false then
                local tBuildingsNearby = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tUnitsByMex)
                if M28Utilities.IsTableEmpty(tBuildingsNearby) == false then
                    bNearbyMex = true
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Backup logic, is tUnitsByMex empty='..tostring(M28Utilities.IsTableEmpty(tUnitsByMex))..'; bNearbyMex ='..tostring(bNearbyMex)) end
            if not(bNearbyMex) then
                if not(tWZData[subrefMexUnbuiltLocations]) then tWZData[subrefMexUnbuiltLocations] = {} end
                table.insert(tWZData[subrefMexUnbuiltLocations], tMex)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function AssignTempSegmentsWithDistance()
    --Used to go through the temporary table tTempZoneTravelDistanceBySegment and assign any segments within here to the nearest land zone
    --i.e. Assumes tTempZoneTravelDistanceBySegment has been setup and is a table that has [SegmentX][SegmentZ] values that returns a table with [zone] as the key, which in turn returns the pathing distance from SegmentX-SegmentZ for each zone
    --Goes through all the distance values in tTempZoneTravelDistanceBySegment and picks the lowest distance, and then assigns the X+Z segment to land zone that corresponds to that distance, then clears the table tTempZoneTravelDistanceBySegment


    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignTempSegmentsWithDistance'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iLowestDistance
    local iLowestZone
    local iCurPlateau
    --Cycle through every entry
    if M28Utilities.IsTableEmpty(tTempZoneTravelDistanceBySegment) == false then
        for iCurSegmentX, tSubtable in tTempZoneTravelDistanceBySegment do
            if not(tLandZoneBySegment[iCurSegmentX]) then tLandZoneBySegment[iCurSegmentX] = {} end
            for iCurSegmentZ, tDistanceByZone in tSubtable do
                --Have we not recorded a zone for this segment?
                if not(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]) then
                    iLowestDistance = 10000
                    iLowestZone = nil
                    --Cycle through every distance that has been recorded for this segment, and record the lowest distance and the zone that corresponds to this distance
                    if M28Utilities.IsTableEmpty(tDistanceByZone) == false then
                        for iZone, iDistance in tDistanceByZone do
                            if iDistance < iLowestDistance then
                                iLowestDistance = iDistance
                                iLowestZone = iZone
                            end
                        end
                        --if bDebugMessages == true then LOG(sFunctionRef..': iCurSegmentX='..iCurSegmentX..'; iCurSegmentZ='..iCurSegmentZ..'; Position from pathing segments='..repru(GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ))..'; iLowestZone='..(iLowestZone or 'nil')..'; plateau group='..(NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)) or 'nil')) end
                        iCurPlateau = NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ))
                        if not(iCurPlateau) then
                            --We have a land zone, so presumably this segment in isolation isn't in somewhere we recognise, but it is near somewhere suitable; keep searching nearby segments to try and find this land zone
                            iCurPlateau = tTempZonePlateauBySegment[iCurSegmentX][iCurSegmentZ][iLowestZone]

                        end
                        RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iCurPlateau, iLowestZone)
                    end
                end
                tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ] = nil --Clear the value so when we cycle through in the future we dont reconsider this
                tTempZonePlateauBySegment[iCurSegmentX][iCurSegmentZ] = nil
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function AssignSegmentsNearMexesToLandZones()
    --Assigns every land pathable segment near a mex to that mex's land zone (where mexes from multiple zones are nearby then it picks the closest one)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignSegmentsNearMexesToLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iMaxSegmentSearchDistance = math.max(10, math.ceil(85 / iLandZoneSegmentSize)) --NOTE: If changing this consider if also want to change the value for AssignRemainingSegmentsToLandZones
    local iDistanceCap = math.max(100, iMaxSegmentSearchDistance * iLandZoneSegmentSize + 15)

    local iBaseSegmentX, iBaseSegmentZ
    local iPathingGroupWanted
    local tCurPosition
    local iCurZone
    local iCurTravelDist
    tTempZoneTravelDistanceBySegment = {} --[x][z] are the segment x and z values, returns a table with a key which is the zone ID, which returns the travel distance for that zone
    tTempZonePlateauBySegment = {}
    local iCurSegmentX, iCurSegmentZ
    local iMaxAdjustedX,iMaxAdjustedZ, iMinAdjustedX, iMinAdjustedZ
    if bDebugMessages == true then LOG(sFunctionRef..': Will record areas around mexes, iMaxSegmentSearchDistance='..iMaxSegmentSearchDistance..'; iDistanceCap='..iDistanceCap..'; iLandZoneSegmentSize='..iLandZoneSegmentSize) end

    --Cycle through every plateau, and then every mex within every plateau
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do
            iBaseSegmentX, iBaseSegmentZ = GetPathingSegmentFromPosition(tMex)
            iPathingGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tMex)
            iCurZone = tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]
            iMaxAdjustedX = math.min(iMaxSegmentSearchDistance + iBaseSegmentX, iMaxLandSegmentX)
            iMaxAdjustedZ = math.min(iMaxSegmentSearchDistance + iBaseSegmentZ, iMaxLandSegmentZ)
            iMinAdjustedX = math.max(1, iBaseSegmentX-iMaxSegmentSearchDistance)
            iMinAdjustedZ = math.max(1, iBaseSegmentZ-iMaxSegmentSearchDistance)

            --Cycle through the segments around this mex:
            for iCurSegmentX = iMinAdjustedX, iMaxAdjustedX, 1 do
                --iCurSegmentX = iBaseSegmentX + iSegmentXAdjust
                if not(tLandZoneBySegment[iCurSegmentX]) then
                    tLandZoneBySegment[iCurSegmentX] = {}
                    tTempZoneTravelDistanceBySegment[iCurSegmentX] = {}
                    tTempZonePlateauBySegment[iCurSegmentX] = {}
                end
                for iCurSegmentZ = iMinAdjustedZ, iMaxAdjustedZ, 1 do

                    --Check we can path to this segment from the mex with land units:
                    tCurPosition = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                    if NavUtils.GetLabel(refPathingTypeLand, tCurPosition) == iPathingGroupWanted then
                        if not(tTempZoneTravelDistanceBySegment[iCurSegmentX]) then
                            tTempZoneTravelDistanceBySegment[iCurSegmentX] = {}
                            tTempZonePlateauBySegment[iCurSegmentX] = {}
                        end
                        if not(tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ]) then
                            tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ] = {}
                            tTempZonePlateauBySegment[iCurSegmentX][iCurSegmentZ] = {}
                        end
                        --Record how long it will take to travel from this position to the mex in a temporary table (that we will then consider later after recording all such values, so we can pick the closest mex zone)
                        iCurTravelDist = M28Utilities.GetTravelDistanceBetweenPositions(tMex, tCurPosition)
                        if (iCurTravelDist or 100000) < iDistanceCap then
                            tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ][iCurZone] = math.min(iCurTravelDist, (tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ][iCurZone] or 100000))
                            tTempZonePlateauBySegment[iCurSegmentX][iCurSegmentZ][iCurZone] = iPlateau
                        end
                    end
                end
            end

        end
    end
    --Now go through each segment in tTempZoneTravelDistanceBySegment and pick the lowest value
    AssignTempSegmentsWithDistance()

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param iBaseSegmentX number
---@param iBaseSegmentZ number
---@param iLandPathingGroupWanted number
---@param tBasePosition table
---@param iMaxSegmentSearchDistance number
---@param iDistanceCap number
---@param bUseRoughPathingDistance boolean
local function RecordTemporaryTravelDistanceForBaseSegment(iBaseSegmentX, iBaseSegmentZ, iLandPathingGroupWanted, tBasePosition, iMaxSegmentSearchDistance, iDistanceCap, bUseRoughPathingDistance)
    --Cycle through segments adjacent to the base segment to see if they have a land zone assigned; if they do, check how far it takes to path to the base segment, and record in the tTempZoneTravelDistanceBySegment any zones that are within the distance cap
    --iMaxSegmentSearchDistance - number of segments to search (will do +/- this)
    --iDistanceCap - will ignore any segment zones further away than this
    --bUseRoughPathingDistance - will rely on the default FAF pathfinding distance rather than manually recalculating all the distance values (runs quicker, but less accurate)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordTemporaryTravelDistanceForBaseSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tCurPosition
    local iCurZone, iCurTravelDist
    local bAbort = false --if we find a really close location then will stop looking for better ones

    if bDebugMessages == true then LOG(sFunctionRef..': About to look for segments near base segment '..iBaseSegmentX..'-'..iBaseSegmentZ..'; iMaxSegmentSearchDistance='..iMaxSegmentSearchDistance..'; iDistanceCap='..iDistanceCap..'; iLandPathingGroupWanted='..(iLandPathingGroupWanted or 'nil')) end

    local iAbortThreshold --This is used so we can stop looking through nearby segments if we find one that is likely to be the closest we will find

    --Below sub-function will consider the segment iCurSegmentX-iCurSegmentZ, if it has a land zone assigned then will check how far it is to the base segment and if it satisfies the requirements then will record in the temporary table of distances
    function CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
        --Does the segment have a land zone assigned, and we haven't just assigned it in this loop?
        if bDebugMessages == true then
            LOG(sFunctionRef..': Considering curSegmentX-z='..iCurSegmentX..'-'..iCurSegmentZ..'; Will note if we have a landzone for this')
            if tLandZoneBySegment[iCurSegmentX] then LOG('tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]='..repru(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]))
            else
                LOG('Dont have any land zone for anything with semgnet X='..iCurSegmentX)
            end
        end
        if tLandZoneBySegment[iCurSegmentX] and tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] then --and (not(tTempZoneTravelDistanceBySegment[iCurSegmentX]) or not(tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ])) then
            tCurPosition = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
            if bDebugMessages == true then LOG(sFunctionRef..': Have a land zone for CurSegmentX-Z'..iCurSegmentX..'-'..iCurSegmentZ..'; Pathing label of this segment='..NavUtils.GetLabel(refPathingTypeLand, tCurPosition)..'; iLandPathingGroupWanted='..iLandPathingGroupWanted) end
            if NavUtils.GetLabel(refPathingTypeLand, tCurPosition) == iLandPathingGroupWanted then

                if bUseRoughPathingDistance then
                    iCurTravelDist = M28Utilities.GetApproxTravelDistanceBetweenPositions(tBasePosition, tCurPosition)
                else
                    iCurTravelDist = M28Utilities.GetTravelDistanceBetweenPositions(tBasePosition, tCurPosition)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iCurTravelDist='..iCurTravelDist) end
                if (iCurTravelDist or 100000) < iDistanceCap then

                    --Update the distance between the bsae segment and a segment in iCurZone to the lower of the current distance and any previously recorded distance
                    iCurZone = tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
                    if bDebugMessages == true then LOG(sFunctionRef..': We have a segment nearby with a land zone, iCurZone='..iCurZone..'; will record iCurTravelDist of '..iCurTravelDist..'; against the base segment') end
                    tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone] = math.min(iCurTravelDist, (tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone] or 100000))
                    if not(tTempZonePlateauBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone]) then tTempZonePlateauBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone] = NavUtils.GetLabel(refPathingTypeHover, tCurPosition) end
                    if iCurTravelDist <= iAbortThreshold then
                        if bDebugMessages == true then LOG(sFunctionRef..': Found a really close segment so will stop looking for more') end
                        bAbort = true
                    end
                end
            end
        end
    end

    local iMaxAdjustedX, iMaxAdjustedZ, iMinAdjustedX, iMinAdjustedZ, iZInterval

    --Cycle through each segment, starting with those closest to the base position
    for iAdjustmentSize = 1, iMaxSegmentSearchDistance do
        iAbortThreshold = iLandZoneSegmentSize * (iAdjustmentSize * 1.3 + 1)
        iMaxAdjustedX = math.min(iAdjustmentSize + iBaseSegmentX, iMaxLandSegmentX)
        iMaxAdjustedZ = math.min(iAdjustmentSize + iBaseSegmentZ, iMaxLandSegmentZ)
        iMinAdjustedX = math.max(1, iBaseSegmentX-iAdjustmentSize)
        iMinAdjustedZ = math.max(1, iBaseSegmentZ-iAdjustmentSize)
        iZInterval = math.max(1, iMaxAdjustedZ - iMinAdjustedZ)



        for iCurSegmentX = iMinAdjustedX, iMaxAdjustedX, 1 do
            --Since we are starting from the closest segments and moving out, we effectively want to cycle through a hollow square of segments with each change in iAdjustmentSize:
            if iCurSegmentX == iMinAdjustedX or iCurSegmentX == iMaxAdjustedX then
                for iCurSegmentZ = iMinAdjustedZ, iMaxAdjustedZ, 1 do
                    CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
                    if bAbort then break end
                end
            else
                for iCurSegmentZ = iMinAdjustedZ, iMaxAdjustedZ, iZInterval do
                    CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
                    if bAbort then break end
                end
            end
            if bAbort then break end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed recording if we have any nearby zones that can path here, tTempZoneTravelDistanceBySegment for base segment '..iBaseSegmentX..'-'..iBaseSegmentZ..'='..repru(tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ])..'; bAbort='..tostring(bAbort)) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param iBaseSegmentX number
---@param iBaseSegmentZ number
---@param iLandZone number
---@param iSegmentSearchRange number
---@param iDistanceCap number
local function AssignNearbySegmentsToSameLandZone(iBaseSegmentX, iBaseSegmentZ, iSegmentSearchRange, iDistanceCap)
    --Cycles through every segment within iSegmentSearchRange of the base segment X-Z value, and if the pathing distance is within the distance cap iDistanceCap then will assign it to the same land zone as the base segment X and Z
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignNearbySegmentsToSameLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iLandZone = tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]
    local iCurTravelDist
    local tBaseMidpoint = GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
    local iPlateau = NavUtils.GetLabel(refPathingTypeHover, tBaseMidpoint)
    for iCurSegmentX = math.max(1, iBaseSegmentX - iSegmentSearchRange), math.min(iBaseSegmentX + iSegmentSearchRange, iMaxLandSegmentX), 1 do
        for iCurSegmentZ = math.max(1, iBaseSegmentZ - iSegmentSearchRange), math.min(iBaseSegmentZ + iSegmentSearchRange, iMaxLandSegmentZ), 1 do
            if not(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]) then
                iCurTravelDist = M28Utilities.GetTravelDistanceBetweenPositions(GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ), tBaseMidpoint)
                if (iCurTravelDist or 100000) <= iDistanceCap then
                    if not(tLandZoneBySegment[iCurSegmentX]) then tLandZoneBySegment[iCurSegmentX] = {} end
                    RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iPlateau, iLandZone)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


local function AssignRemainingSegmentsToLandZones()
    --Cycles through key points on the map and if they ahve no nearby land zone then creates a new land zone
    --then cycles through every segment on the map and if it has no land zone assigns it to the nearest existing land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignRemainingSegmentsToLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --rMapPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2}
    local iLandPathingGroupWanted
    local iPlateauGroup

    local iMaxSegmentSearchDistance = math.max(3, math.ceil(40 / iLandZoneSegmentSize)) --NOTE: If changing this consider if also want to change the value for AssignSegmentsNearMexesToLandZones; for first draft have this as slightly lower
    local iDistanceCap = math.max(40, iMaxSegmentSearchDistance * iLandZoneSegmentSize)

    local tBasePosition

    --Create a new zone for any locations with no nearby pathable zones
    local iNewZoneCount = 0
    local iBasePositionX = - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[1]
    local iBasePositionZ
    local iNearbyAssignmentSegmentRange = math.min(iMaxSegmentSearchDistance, math.ceil(iMaxSegmentSearchDistance * 0.5) + 1)
    local tiLZEntryByNavUtilsRef = {}

    --Subfunction that checks nearby segments that we can path to with a land zone already assigned, and if there are none then creates a new land zone for the base position and assigns segments near it to the same land zone
    function CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ, bUseRoughPathingDistance)

        if not(tLandZoneBySegment[iBaseSegmentX] and tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
            tBasePosition = {iBasePositionX, 0, iBasePositionZ} --GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
            --tBasePosition[2] = GetSurfaceHeight(tBasePosition[1], tBasePosition[3]) --Dont think this is needed
            iLandPathingGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tBasePosition)
            if (iLandPathingGroupWanted or 0) == 0 then
                --We shouldnt have got here unless plateau returned a valid pathing value; however can have cases where is pathable by one measure but not another due to imprecisions in the FAF pathfinding approach
                --Therefore, want to check if we are on land (rather htan water which is handled separately) and if so then include still
                iPlateauGroup = NavUtils.GetLabel(refPathingTypeHover, tBasePosition)
                if bDebugMessages == true then LOG(sFunctionRef..': iPlateauGroup of the target location='..(iPlateauGroup or 'nil')..'; Surface height='..GetSurfaceHeight(iBasePositionX, iBasePositionZ)..'; Terrain height='..GetTerrainHeight(iBasePositionX, iBasePositionZ)..'; tBasePosition='..repru(tBasePosition)..'; iBasePositionX-Z='..iBasePositionX..'-'..iBasePositionZ) end
                if (iPlateauGroup or 0) > 0 then
                    --Check we arent on water
                    if GetSurfaceHeight(iBasePositionX, iBasePositionZ) <= GetTerrainHeight(iBasePositionX, iBasePositionZ) then
                        local tiAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}, {-3,0}, {-3, -3}, {-3, 3}, {0, -3}, {0, 3}, {3, -3}, {3, 0}, {3,3}}
                        local iPotentialLandGroup
                        for iEntry, tXZAdjust in tiAdjust do

                            iPotentialLandGroup = NavUtils.GetLabel(refPathingTypeLand, { tBasePosition[1] + tXZAdjust[1], tBasePosition[2], tBasePosition[3] + tXZAdjust[2] })
                            if (iPotentialLandGroup or 0) > 0 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have al ocation with a plateau ref but no land ref, but adjusting for tXZAdjust='..repru(tXZAdjust)..' gives us a valid land group, iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ) end
                                iLandPathingGroupWanted = iPotentialLandGroup
                                break
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Unable to find any nearby locations with land pathing') end
                        end
                    end
                end
            end
            if (iLandPathingGroupWanted or 0) > 0 then
                --Are we from a plateau that has mexes?
                iPlateauGroup = (NavUtils.GetLabel(refPathingTypeHover, tBasePosition) or NavUtils.GetLabel('Amphibious', tBasePosition))
                if not(iPlateauGroup) then
                    local tiAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}, {-3,0}, {-3, -3}, {-3, 3}, {0, -3}, {0, 3}, {3, -3}, {3, 0}, {3,3}}
                    for iEntry, tXZAdjust in tiAdjust do
                        iPlateauGroup = NavUtils.GetLabel(refPathingTypeHover, { tBasePosition[1] + tXZAdjust[1], tBasePosition[2], tBasePosition[3] + tXZAdjust[2] })
                        if iPlateauGroup then break end
                    end
                end
                if tAllPlateaus[iPlateauGroup][subrefPlateauTotalMexCount] > 0 then


                    --Dont create a new zone if we have a nearby zone
                    if not(tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ]) then
                        if not(tTempZoneTravelDistanceBySegment[iBaseSegmentX]) then
                            tTempZoneTravelDistanceBySegment[iBaseSegmentX] = {}
                            tTempZonePlateauBySegment[iBaseSegmentX] = {}
                        end
                        tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ] = {}
                        tTempZonePlateauBySegment[iBaseSegmentX][iBaseSegmentZ] = {}
                    end

                    --Cycle through adjacent segments to see if they have a zone, and if so check how far away the segment is from the base segment
                    RecordTemporaryTravelDistanceForBaseSegment(iBaseSegmentX, iBaseSegmentZ, iLandPathingGroupWanted, tBasePosition, iMaxSegmentSearchDistance, iDistanceCap, bUseRoughPathingDistance)

                    --Create a new zone if no segments nearby that already have a land zone that we can path to
                    if M28Utilities.IsTableEmpty(tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ]) then
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Have no temp travel distance recorded so have created a new land zone for segmentX-Z='..iBaseSegmentX..'-'..iBaseSegmentZ..'; Position from segments='..repru(GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ))..'; tBasePosition (should be the same)='..repru(tBasePosition)..'; will draw midpoint in red.  iNewZoneCount before increasing by 1='..iNewZoneCount..'; Plateau group of the segment midpoint='..(NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)) or 'nil'))
                            M28Utilities.DrawLocation(GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ))
                        end
                        CreateNewLandZoneAtSegment(iBaseSegmentX, iBaseSegmentZ)
                        iNewZoneCount = iNewZoneCount + 1

                        --Assign very nearby segments to this
                        AssignNearbySegmentsToSameLandZone(iBaseSegmentX, iBaseSegmentZ, iNewZoneCount, iNearbyAssignmentSegmentRange, iDistanceCap)
                    end
                elseif iPlateauGroup > 0 then
                    --Plateau has no mexes so just create one large group based on the land pathing, if we havent already
                    if not(tiLZEntryByNavUtilsRef[iPlateauGroup][iLandPathingGroupWanted]) then
                        --We haven't created this LZ yet; have we created the plateau?
                        if not(tAllPlateaus[iPlateauGroup]) then
                            RecordMexlessPlateau(iPlateauGroup)
                        end

                        if not(tiLZEntryByNavUtilsRef[iPlateauGroup]) then
                            tiLZEntryByNavUtilsRef[iPlateauGroup] = {}
                        end

                        --Need to add land zone reference to this plateau
                        AddNewLandZoneReferenceToPlateau(iPlateauGroup)
                        tiLZEntryByNavUtilsRef[iPlateauGroup][iLandPathingGroupWanted] = tAllPlateaus[iPlateauGroup][subrefLandZoneCount]
                        RecordSegmentLandZone(iBaseSegmentX, iBaseSegmentZ, iPlateauGroup, tAllPlateaus[iPlateauGroup][subrefLandZoneCount])
                    else
                        RecordSegmentLandZone(iBaseSegmentX, iBaseSegmentZ, iPlateauGroup, tiLZEntryByNavUtilsRef[iPlateauGroup][iLandPathingGroupWanted])
                    end
                else
                    M28Utilities.ErrorHandler('somehow have a land zone but not a plateau group; Refer to log for base position and other details if logs are enabled')
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Base position='..repru(tBasePosition)..'; Land nav='..(NavUtils.GetLabel(refPathingTypeLand, tBasePosition) or 'nil')..'; Plateau nav='..(NavUtils.GetLabel(refPathingTypeHover, tBasePosition) or 'nil')..'; Amphibious plateau='..(NavUtils.GetLabel('Amphibious', tBasePosition) or 'nil'))
                        M28Utilities.DrawLocation(tBasePosition, 2)
                    end

                end
            elseif bDebugMessages == true then
                LOG(sFunctionRef..': No land pathing group for base position '..repru(tBasePosition)..'; iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ..'; will draw base position')
                M28Utilities.DrawLocation(tBasePosition)
            end
        end
    end

    --Cycle through every segment on the map, but only consider every iMaxSegmentSearchDistance 'th segment (for performance reasons), and check if it has nearby land zones, and if not then create a new land zone at this position
    for iBaseSegmentX = iMaxSegmentSearchDistance, iMaxLandSegmentX, iMaxSegmentSearchDistance do
        iBasePositionX = iBasePositionX + iLandZoneSegmentSize * iMaxSegmentSearchDistance --Manually done instead of GetPositionFromPathingSegments for performance
        iBasePositionZ = - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[2]

        if not(tLandZoneBySegment[iBaseSegmentX]) then tLandZoneBySegment[iBaseSegmentX] = {} end
        if not(tTempZoneTravelDistanceBySegment[iBaseSegmentX]) then
            tTempZoneTravelDistanceBySegment[iBaseSegmentX] = {}
            tTempZonePlateauBySegment[iBaseSegmentX] = {}
        end
        for iBaseSegmentZ = iMaxSegmentSearchDistance, iMaxLandSegmentZ, iMaxSegmentSearchDistance do
            iBasePositionZ = iBasePositionZ + iLandZoneSegmentSize * iMaxSegmentSearchDistance
            --Check we dont already have a zone assigned
            CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ)
        end
        --WaitTicks(1)
        if bDebugMessages == true then LOG(sFunctionRef..': Finished all iBaseSegmentX='..iBaseSegmentX..'; moving to next X segments, systemtime='..GetSystemTimeSecondsOnlyForProfileUse()) end
    end
    --Now go through each segment considered and pick the lowest value distance as the assigned land zone
    AssignTempSegmentsWithDistance()
    if bDebugMessages == true then LOG(sFunctionRef..': Finished assigning land zones for locations with no nearby zones, systemtime='..GetSystemTimeSecondsOnlyForProfileUse()) end

    --Now cycle through every segment on the map, and assign to a land zone (or create a new land zone if none nearby, but hopefully after the above code this will be rare)
    iBasePositionX = - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[1] --Calculate the position manually (instead of using the function GetPositionFromPathingSegments) for performance
    for iBaseSegmentX = 1, iMaxLandSegmentX do
        iBasePositionX = iBasePositionX + iLandZoneSegmentSize --(i.e. as per GetPositionFromPathingSegments)
        iBasePositionZ = - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[2]
        for iBaseSegmentZ = 1, iMaxLandSegmentZ do
            iBasePositionZ = iBasePositionZ + iLandZoneSegmentSize
            CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ, true)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed creating land zones for any remaining locations with no nearby land zone, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    --The above will have updated the temporary table with details of how long to path to each zone; now go through and assign each segment to the closest zone to it
    AssignTempSegmentsWithDistance()

    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed assigning zones for any temporary distances for the zones created in the previous step, system time='..GetSystemTimeSecondsOnlyForProfileUse()..'; about to run logic to check for any rmeaining segment') end


    --Redundancy - cycle through any zones that dont have a segment and create new zones for them - hopefully this shouldnt be possible provided we have setup the segment search ranges correctly above
    --Also setup initial details on water segments

    for iBaseSegmentX = 1, iMaxLandSegmentX do
        for iBaseSegmentZ = 1, iMaxLandSegmentZ do
            if bDebugMessages == true then LOG(sFunctionRef..': iBaseSegmentX-Z='..iBaseSegmentX..'-'..iBaseSegmentZ..'; Is the land zone for htis segment nil='..tostring(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]==nil)..'; Hover label='..(NavUtils.GetLabel(refPathingTypeHover, tBasePosition) or 0)..'; Land label='..(NavUtils.GetLabel(refPathingTypeLand, tBasePosition) or 'nil')..'; NavUtils.GetLabel(refPathingTypeNavy, tBasePosition)='..(NavUtils.GetLabel(refPathingTypeNavy, tBasePosition) or 'nil')) end
            if not(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
                tBasePosition = GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
                if (NavUtils.GetLabel(refPathingTypeHover, tBasePosition) or 0) > 0 then
                    iLandPathingGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tBasePosition)
                    if (iLandPathingGroupWanted or 0) >= 1 then
                        M28Utilities.ErrorHandler('Have an unassigned land zone='..iBaseSegmentX..'-'..iBaseSegmentZ)
                        CreateNewLandZoneAtSegment(iBaseSegmentX, iBaseSegmentZ)
                        RecordTemporaryTravelDistanceForBaseSegment(iBaseSegmentX, iBaseSegmentZ, iLandPathingGroupWanted, tBasePosition, iMaxSegmentSearchDistance, iDistanceCap)
                        AssignTempSegmentsWithDistance()
                    else
                        --Do we have a water segment?
                        local iPond = NavUtils.GetLabel(refPathingTypeNavy, tBasePosition)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iBaseSegmentX-Z='..iBaseSegmentX..'-'..iBaseSegmentZ..'; we have hover pathing but not water;tBasePosition='..repru(tBasePosition)..'; Surface height='..GetSurfaceHeight(tBasePosition[1], tBasePosition[3])..'; Terrain height='..GetTerrainHeight(tBasePosition[1], tBasePosition[3])..'; iPond='..(iPond or 'nil')) end
                        if (iPond or 0) == 0 and GetSurfaceHeight(tBasePosition[1], tBasePosition[3]) > GetTerrainHeight(tBasePosition[1], tBasePosition[3]) then
                            --We are on water, so check nearby as FAF pathfinding not 100% accurate on larger maps
                            local tiAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}, {-3,0}, {-3, -3}, {-3, 3}, {0, -3}, {0, 3}, {3, -3}, {3, 0}, {3,3}}
                            local iPotentialPond
                            for iEntry, tXZAdjust in tiAdjust do
                                iPotentialPond = NavUtils.GetLabel(refPathingTypeNavy, { tBasePosition[1] + tXZAdjust[1], tBasePosition[2], tBasePosition[3] + tXZAdjust[2] })
                                if (iPotentialPond or 0) > 0 then
                                    iPond = iPotentialPond
                                    if bDebugMessages == true then LOG(sFunctionRef..': Foudn a nearby pond '..iPotentialPond..', tXZAdjust='..repru(tXZAdjust)) end
                                    break
                                end
                            end
                        end
                        if (iPond or 0) > 0 then
                            if bDebugMessages == true then LOG(sFunctionRef..': About to record a pond for iBaseSegmentX-Z='..iBaseSegmentX..'-'..iBaseSegmentZ..' for pond '..iPond..'; tBasePosition='..repru(tBasePosition)) end
                            RecordNavalSegment(iPond, iBaseSegmentX, iBaseSegmentZ, tBasePosition)
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished redundancy of checking every segment has a land zone if it is land pathable, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function AssignMexesALandZone()
    --Cycles through every mex and assigns it to a new land zone, unless it is near another mex in which case they should both use the same land zone

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignMexesALandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Key config values
    local iNearbyMexRange --Initially mexes will be grouped together based on this, i.e. will assign mexes within this distance of each other to the same land zone
    local iRecursiveFactor
    --rMapPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2}
    local iMaxMapSize = math.max(rMapPlayableArea[3] - rMapPlayableArea[1], rMapPlayableArea[4] - rMapPlayableArea[2])
    if iMaxMapSize > 1024 then --1024 is 20k, so this is 40k or 80k
        iNearbyMexRange = 54
        iRecursiveFactor = 4
    elseif iMaxMapSize > 512 then --i.e. 20k
        iNearbyMexRange = 46
        iRecursiveFactor = 3.5
    elseif iMaxMapSize > 256 then
        iNearbyMexRange = 42
        iRecursiveFactor = 3
    else
        iNearbyMexRange = 35
        iRecursiveFactor = 2
    end


    if bDebugMessages == true then LOG('About to setup land zones') end

    local tiPlateauLandZoneByMexRef = {} --[x] is plateau ref, [y] is mex number, returns the LZ
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        tiPlateauLandZoneByMexRef[iPlateau] = {}
    end

    --Subfunction - if we have a mex to assign to a land zone then this subfunction should be called to check for any nearby mexes without a zone and assign these to the same zone
    function AddNearbyMexesToLandZone(iPlateau, iCurLandZone, tMex, iRecursiveCount)
        local iLandGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tMex)
        local iMaxRange
        if iRecursiveCount <= 1 then iMaxRange = math.max(15, iNearbyMexRange)
        else iMaxRange = math.max(15, iNearbyMexRange - iRecursiveCount * iRecursiveFactor)
        end
        for iAltMex, tAltMex in tAllPlateaus[iPlateau][subrefPlateauMexes] do
            if not(tiPlateauLandZoneByMexRef[iPlateau][iAltMex]) then
                if NavUtils.GetLabel(refPathingTypeLand, tAltMex) == iLandGroupWanted and not(IsUnderwater(tAltMex, false, 0.1)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAltMex='..iAltMex..'; Distance straight line='..M28Utilities.GetDistanceBetweenPositions(tAltMex, tMex)..'; Travel distance='..M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex)) end
                    if M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex) <= iMaxRange then
                        AddMexToLandZone(iPlateau, iCurLandZone, iAltMex, tiPlateauLandZoneByMexRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Added mex '..iAltMex..' with position '..repru(tAltMex)..' to land zone, tiPlateauLandZoneByMexRef='..(tiPlateauLandZoneByMexRef[iAltMex] or 'nil')..'; Distance in straight line='..M28Utilities.GetDistanceBetweenPositions(tAltMex, tMex)..'; Travel distance='..M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex)) end
                        AddNearbyMexesToLandZone(iPlateau, iCurLandZone, tAltMex, iRecursiveCount + 1) --Needs to be recursive or else can end up with 2 mees that are really close to each other not being in the same group depending on the order in which the original mexes are called
                    end
                end
            end
        end
    end

    --First setup core base land zones, including merging core bases if they are close to each other into a single land zone - have the size of the core base impacted by if there is a hydro nearby

    --Get the start points to actually consider
    local tRelevantStartPointsByIndex = {}
    for iBrain, oBrain in ArmyBrains do
        if not(M28Conditions.IsCivilianBrain(oBrain)) then
            local iStartPositionX, iStartPositionZ = oBrain:GetArmyStartPos()
            tRelevantStartPointsByIndex[oBrain:GetArmyIndex()] = {iStartPositionX, GetSurfaceHeight(iStartPositionX, iStartPositionZ), iStartPositionZ}
        end
    end

    local tiStartIndexPlateauAndLZ = {} --[x] is the player index, returns the land zone to use
    local iLZToUse
    local iCurPlateau
    --Create a table of the start locations that have their own unique land zone (as we want to combine those that are close together):
    for iIndex, tStartPosition in tRelevantStartPointsByIndex do
        iLZToUse = nil
        iCurPlateau = NavUtils.GetLabel(refPathingTypeHover, tStartPosition)
        --Are we close to an existing start position such that we should use the same LZ for both positions?
        if M28Utilities.IsTableEmpty(tiStartIndexPlateauAndLZ) == false then
            for iExistingIndex, tExistingPlateauAndLZ in tiStartIndexPlateauAndLZ do
                if tExistingPlateauAndLZ[1] == iCurPlateau and M28Utilities.GetDistanceBetweenPositions(tStartPosition, tRelevantStartPointsByIndex[iExistingIndex]) <= 40 then
                    iLZToUse = tExistingPlateauAndLZ[2]
                    break
                end
            end
        end
        if not(iLZToUse) then
            if bDebugMessages == true then LOG(sFunctionRef..': About to add a new LZ reference to iCurPlateau '..(iCurPlateau or 'nil')..' for start position '..repru(tStartPosition)) end
            AddNewLandZoneReferenceToPlateau(iCurPlateau)
            iLZToUse = tAllPlateaus[iCurPlateau][subrefLandZoneCount]
            if bDebugMessages == true then LOG(sFunctionRef..': Just added iLZToUse='..iLZToUse..'; tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]='..reprs(tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iLZToUse])) end
        end
        tiStartIndexPlateauAndLZ[iIndex] = {iCurPlateau, iLZToUse}
        local iCurSegmentX, iCurSegmentZ = GetPathingSegmentFromPosition(tStartPosition)
        RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iCurPlateau, iLZToUse)
        if bDebugMessages == true then LOG(sFunctionRef..': Have just recorded iLZToUse='..iLZToUse..' for iCurPlateau='..iCurPlateau..'; iCurSegmentX-Z='..iCurSegmentX..'-'..iCurSegmentZ..'; Start position='..repru(tStartPosition)..'; Brain index='..iIndex) end
    end

    --Now find any mexes within the desired travel distance and assign them to the nearest start position - first exclude based on distance, and if they meet the straight line distance check then consider travel distance
    local iCurDistStraightLine
    local iCurDistTravel
    local iClosestDistTravel
    local iClosestBrainIndex

    local tiStartResourcesByBrainIndex = {}

    local iStraightLineThreshold = 70 --Ignore locations that are more than this distance away
    local iTravelDistThreshold = 75 --Ignore locations that are more than this land travel distance away


    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do
            --Find the closest start point
            iClosestDistTravel = iTravelDistThreshold --Ignore points whose travel distance is further away than this
            iClosestBrainIndex = nil
            for iBrainIndex, tStartPoint in tRelevantStartPointsByIndex do
                iCurDistStraightLine = M28Utilities.GetDistanceBetweenPositions(tMex, tStartPoint)
                if iCurDistStraightLine <= iStraightLineThreshold then
                    --Get the land pathing distance
                    iCurDistTravel = M28Utilities.GetTravelDistanceBetweenPositions(tMex, tStartPoint, refPathingTypeLand)
                    if iCurDistTravel < iClosestDistTravel then
                        iClosestDistTravel = iCurDistTravel
                        iClosestBrainIndex = iBrainIndex
                    end
                end
            end
            if iClosestBrainIndex then
                if not(tiStartResourcesByBrainIndex[iClosestBrainIndex]) then tiStartResourcesByBrainIndex[iClosestBrainIndex] = {} end
                table.insert(tiStartResourcesByBrainIndex[iClosestBrainIndex], tMex)
                AddMexToLandZone(iPlateau, tiStartIndexPlateauAndLZ[iClosestBrainIndex][2], iMex, tiPlateauLandZoneByMexRef)
                if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..tiStartIndexPlateauAndLZ[iClosestBrainIndex][2]..'; Adding iMex='..iMex..'; at position '..repru(tMex)..'; to the start position for aiBrain index='..iClosestBrainIndex..' which is at '..repru(tRelevantStartPointsByIndex[iClosestBrainIndex])) end
            end
        end
    end

    --Debug - draw the groupings of mexes with rectangles around them to show how they've been grouped, with a different colour for each plateau group:
    if bDebugMessages == true then
        local iColour = 0
        for iPlateau, tPlateauSubtable in tAllPlateaus do
            LOG(sFunctionRef..': About to draw results of land zones for iPlateau='..iPlateau..'; tiPlateauLandZoneByMexRef[iPlateau]='..repru(tiPlateauLandZoneByMexRef[iPlateau])..'; tAllPlateaus[iPlateau][subrefPlateauLandZones]='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones]))
            iColour = 3
            --Draw the mex groupings
            for iZone, tZone in tAllPlateaus[iPlateau][subrefPlateauLandZones] do
                local iMinX = 100000
                local iMaxX = 0
                local iMinZ = 100000
                local iMaxZ = 0

                for iMex, tMex in tZone[subrefLZMexLocations] do
                    iMinX = math.min(tMex[1], iMinX)
                    iMaxX = math.max(tMex[1], iMaxX)
                    iMinZ = math.min(tMex[3], iMinZ)
                    iMaxZ = math.max(tMex[3], iMaxZ)
                end
                M28Utilities.DrawRectangle(Rect(iMinX, iMinZ, iMaxX, iMaxZ), iColour, 1000, 10)
            end
        end
    end

    --Now add any mexes near these resource locations to the same land zone
    if bDebugMessages == true then LOG(sFunctionRef..': Will now add mexes near the start position resources to the same land zone, tiStartResourcesByBrainIndex='..repru(tiStartResourcesByBrainIndex)) end
    for iBrainIndex, tResources in tiStartResourcesByBrainIndex do
        for iResource, tResourceLocation in tResources do
            AddNearbyMexesToLandZone(tiStartIndexPlateauAndLZ[iBrainIndex][1], tiStartIndexPlateauAndLZ[iBrainIndex][2], tResourceLocation, 1)
        end
    end



    --Assign assign zones to mex locations - group mexes that are near each other in the same zone
    local iCurLandZone
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        if not(tAllPlateaus[iPlateau][subrefPlateauLandZones]) then tAllPlateaus[iPlateau][subrefPlateauLandZones] = {} end
        if bDebugMessages == true then LOG(sFunctionRef..': tPlateauSubtable[subrefPlateauMexes]='..repru(tPlateauSubtable[subrefPlateauMexes])) end
        for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do
            if bDebugMessages == true then LOG(sFunctionRef..': iMex='..iMex..'; tMex='..repru(tMex)) end
            if not(IsUnderwater(tMex, false, 0.1)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Plateau='..iPlateau..': Considering mex with plateau mex ref='..iMex..'; position='..repru(tMex)..'; tiPlateauLandZoneByMexRef for this ref='..(tiPlateauLandZoneByMexRef[iPlateau][iMex] or 'nil')) end
                if not(tiPlateauLandZoneByMexRef[iPlateau][iMex]) then
                    AddMexToLandZone(iPlateau, nil, iMex, tiPlateauLandZoneByMexRef)
                    iCurLandZone = tiPlateauLandZoneByMexRef[iPlateau][iMex]
                    if bDebugMessages == true then LOG(sFunctionRef..': Added mex '..iMex..' with position '..repru(tMex)..' to land zone, tiPlateauLandZoneByMexRef='..(tiPlateauLandZoneByMexRef[iPlateau][iMex] or 'nil')) end

                    --Cycle through each other mex in the plateau and if it is within iNearbyMexRange then assign it to the same group if it hasnt had a group assigned already
                    AddNearbyMexesToLandZone(iPlateau, iCurLandZone, tMex, 0)
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording land zone mexes for iPlateau='..iPlateau..'; Size of land zones table='..table.getn(tAllPlateaus[iPlateau][subrefPlateauLandZones])) end
    end

    --Debug - draw the groupings of mexes with rectangles around them to show how they've been grouped, with a different colour for each plateau group:
    if bDebugMessages == true then
        local iColour = 0
        for iPlateau, tPlateauSubtable in tAllPlateaus do
            LOG(sFunctionRef..': About to draw results of land zones for iPlateau='..iPlateau..'; tiPlateauLandZoneByMexRef[iPlateau]='..repru(tiPlateauLandZoneByMexRef[iPlateau])..'; tAllPlateaus[iPlateau][subrefPlateauLandZones]='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones]))
            iColour = iColour + 1
            if iColour > 7 then iColour = 1 end
            --Draw the mex groupings
            for iZone, tZone in tAllPlateaus[iPlateau][subrefPlateauLandZones] do
                local iMinX = 100000
                local iMaxX = 0
                local iMinZ = 100000
                local iMaxZ = 0

                for iMex, tMex in tZone[subrefLZMexLocations] do
                    iMinX = math.min(tMex[1], iMinX)
                    iMaxX = math.max(tMex[1], iMaxX)
                    iMinZ = math.min(tMex[3], iMinZ)
                    iMaxZ = math.max(tMex[3], iMaxZ)
                end
                M28Utilities.DrawRectangle(Rect(iMinX, iMinZ, iMaxX, iMaxZ), iColour, 1000, 10)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DrawSpecificLandZone(iPlateau, iLandZone, iColour)
    local tLocation
    for iSegmentRef, tSegmentXZ in tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments] do
        tLocation = GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
        M28Utilities.DrawLocation(tLocation, iColour, nil, iLandZoneSegmentSize - 0.1)
    end
end

function DrawSpecificWaterZone(iWaterZone, iColour)
    local tLocation
    local iPond = tiPondByWaterZone[iWaterZone]
    local tWZData = tPondDetails[iPond][subrefPondWaterZones][iWaterZone]
    for iSegmentRef, tSegmentXZ in tWZData[subrefWZSegments] do
        tLocation = GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
        M28Utilities.DrawLocation(tLocation, iColour, nil, iLandZoneSegmentSize - 0.1)
    end
end

local function DrawLandZones()
    --For debug use - will draw each land zone in a plateau in a different colour to allow a visual check of how land zones have been created.  Can be called part-way through the process (e.g. to show land zones after the initial mex creation and nearby areas)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DrawLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Create fixed colours per ref
    local iUniqueColourCount = 30
    local tColourTable = M28Utilities.GenerateUniqueColourTable(iUniqueColourCount)

    --Subfunction which assigns a unique colour to each land zone
    function GetColourFromLandZoneNumber(iLandZoneRef)
        local iColour = iLandZoneRef
        while iColour >= iUniqueColourCount do
            iColour = iColour - iUniqueColourCount
        end

        return tColourTable[iColour]
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Will now draw every land zone in every plateau, cycling the colour used') end
    local tLocation, iLandZoneRef
    --Cycle through every segment on the map and draw a colour for it based on the land zone that it's part of
    for iCurSegmentX = 1, iMaxLandSegmentX do
        for iCurSegmentZ = 1, iMaxLandSegmentZ do
            iLandZoneRef = tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
            if (iLandZoneRef or 0) > 0 then
                tLocation = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                if bDebugMessages == true then LOG(sFunctionRef..': Land zone ref for segments X-Z='..iCurSegmentX..'-'..iCurSegmentZ..' = '..iLandZoneRef..'; Plataeu ref based on navutils='..NavUtils.GetLabel(refPathingTypeHover, tLocation)) end
                --M28Utilities.DrawLocation(tLocation, GetColourFromLandZoneNumber(iLandZoneRef), nil, iLandZoneSegmentSize - 0.1)
                M28Utilities.DrawLocation(tLocation, GetColourFromLandZoneNumber(iLandZoneRef), nil, iLandZoneSegmentSize - 0.1)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function RecordLandZoneMidpointAndUnbuiltMexes()
    --Run at the start of the game - Cycles through each land zone, and calculates the average positio nof the mexes.  If this is in the asme land zone then records this as the midpoint, toehrwise records the first mex as the midpoint
    --Also records which mexes can be built on initially
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordLandZoneMidpointAndUnbuiltMexes'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tAverage, iAveragePlateau, iAverageLandZone
    local tCurPosition

    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iZone, tLZData in tAllPlateaus[iPlateau][subrefPlateauLandZones] do

            if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Considering iPlateau='..iPlateau..'; iZone='..iZone..'; Is table of mex locations empty='..tostring(M28Utilities.IsTableEmpty(tLZData[subrefLZMexLocations]))) end
            local iMinX = 100000
            local iMaxX = 0
            local iMinZ = 100000
            local iMaxZ = 0
            local iBaseIslandWanted

            local iMinSegX = 100000
            local iMaxSegX = 0
            local iMinSegZ = 100000
            local iMaxSegZ = 0
            --First record min and max segX values for the LZ
            for iSegment, tSegmentXZ in tLZData[subrefLZSegments] do
                iMinSegX = math.min(iMinSegX, tSegmentXZ[1])
                iMinSegZ = math.min(iMinSegZ, tSegmentXZ[2])
                iMaxSegX = math.max(iMaxSegX, tSegmentXZ[1])
                iMaxSegZ = math.max(iMaxSegZ, tSegmentXZ[2])
            end
            tLZData[subrefLZMinSegX] = iMinSegX
            tLZData[subrefLZMinSegZ] = iMinSegZ
            tLZData[subrefLZMaxSegX] = iMaxSegX
            tLZData[subrefLZMaxSegZ] = iMaxSegZ
            if bDebugMessages == true then LOG(sFunctionRef..': Finished recording min and max segments for Plateau '..iPlateau..' with LZ='..iZone..'; tLZData[subrefLZMinSegX]='..(tLZData[subrefLZMinSegX] or 'nil')..'; tLZData[subrefLZMinSegZ]='..(tLZData[subrefLZMinSegZ] or 'nil')..'; tLZData[subrefLZMaxSegX]='..(tLZData[subrefLZMaxSegX] or 'nil')..'; tLZData[subrefLZMaxSegZ]='..(tLZData[subrefLZMaxSegZ] or 'nil')) end


            if M28Utilities.IsTableEmpty(tLZData[subrefLZMexLocations]) == false then
                for iMex, tMex in tLZData[subrefLZMexLocations] do
                    --Get min and max values for midpoint:
                    iMinX = math.min(tMex[1], iMinX)
                    iMaxX = math.max(tMex[1], iMaxX)
                    iMinZ = math.min(tMex[3], iMinZ)
                    iMaxZ = math.max(tMex[3], iMaxZ)
                    if not(iBaseIslandWanted) then iBaseIslandWanted = NavUtils.GetLabel(refPathingTypeLand, tMex) end
                    --Record if can build on it:
                    if bDebugMessages == true then LOG(sFunctionRef..': About to check if can build on iMex='..iMex..'; tMex='..repru(tMex)..'; can we build on it='..tostring(M28Conditions.CanBuildOnMexLocation(tMex))..'; aiBrain check whether can build using brain '..(M28Overseer.tAllActiveM28Brains[1].Nickname or 'nil')..'='..tostring(M28Overseer.tAllActiveM28Brains[1]:CanBuildStructureAt('urb1103', tMex))..'; Result of is resource blocked='..tostring(M28Conditions.IsResourceBlockedByResourceBuilding(M28UnitInfo.refCategoryMex, 'urb1103', tMex))) end
                    if M28Conditions.CanBuildOnMexLocation(tMex) then
                        table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefMexUnbuiltLocations], tMex)
                    else
                        --DOuble-check - if there are no buildings in a rectangle around the mex then treat it as buildable (note - havent tested the below as added when thought were failing to record mexes on a map but it turned out to be another unrelated issue)
                        local rRect = M28Utilities.GetRectAroundLocation(tMex, 0.9)
                        local tUnitsByMex = GetUnitsInRect(rRect)
                        local bNearbyMex = false
                        if M28Utilities.IsTableEmpty(tUnitsByMex) == false then
                            local tBuildingsNearby = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tUnitsByMex)
                            if M28Utilities.IsTableEmpty(tBuildingsNearby) == false then
                                bNearbyMex = true
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Backup logic, is tUnitsByMex empty='..tostring(M28Utilities.IsTableEmpty(tUnitsByMex))..'; bNearbyMex ='..tostring(bNearbyMex)) end
                        if not(bNearbyMex) then
                            table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefMexUnbuiltLocations], tMex)
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Size of mex locations for LZ='..table.getn(tLZData[subrefLZMexLocations])..'; Size of unbuilt locations='..table.getn(tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefMexUnbuiltLocations])) end
            else
                --No mexes for the plateau, so cycle through every zone and record the lowest and largest X and Z values

                --for iSegment, tSegmentXZ in tLZData[subrefLZSegments] do
                --tCurPosition = GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
                local tMinPosition = GetPositionFromPathingSegments(tLZData[subrefLZMinSegX], tLZData[subrefLZMinSegZ])
                local tMaxPosition = GetPositionFromPathingSegments(tLZData[subrefLZMaxSegX], tLZData[subrefLZMaxSegZ])
                iMinX = tMinPosition[1]
                iMinZ = tMinPosition[3]
                iMaxX = tMaxPosition[1]
                iMaxZ = tMaxPosition[3]
                for iSegment, tSegmentXZ in tLZData[subrefLZSegments] do
                    if not(iBaseIslandWanted) then iBaseIslandWanted = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])) end
                    break
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Min and max position: iMinX='..iMinX..'; iMaxX='..iMaxX..'; iMinZ='..iMinZ..'; iMaxZ='..iMaxZ) end
            end
            tAverage = {(iMinX + iMaxX)*0.5, 0, (iMinZ + iMaxZ) * 0.5}
            iAveragePlateau = NavUtils.GetLabel(refPathingTypeHover, tAverage)
            local iAverageIsland
            iAverageIsland = NavUtils.GetLabel(refPathingTypeLand, tAverage)


            --Move the midpoint if nav utils doesnt work for this position (to reduce the amount of grief we might have later)
            if not(iAveragePlateau == iPlateau) or not(iAverageIsland == iBaseIslandWanted) then
                local iStartSegmentX, iStartSegmentZ = GetPathingSegmentFromPosition(tAverage)
                local tAltMidpoint
                local iAdjustedSegmentX, iAdjustedSegmentZ
                local bHaveValidAltMidpoint = false
                for iAdjust = 1, 50 do
                    for iXAdjust = -1, 1, 1 do
                        for iZAdjust = -1, 1, 1 do
                            if not(iXAdjust == 0 and iZAdjust == 0) then
                                iAdjustedSegmentX = iStartSegmentX + iAdjust * iXAdjust
                                iAdjustedSegmentZ = iStartSegmentZ + iAdjust * iZAdjust
                                iAverageLandZone = tLandZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ]
                                if iAverageLandZone == iZone then
                                    tAltMidpoint = GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering adjusted segment X-Z='..iAdjustedSegmentX..'-'..iAdjustedSegmentZ..'; with land zone '..tLandZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ]..'; tAltMidpoint='..repru(tAltMidpoint)..'; Plateau from navutils='..(NavUtils.GetLabel(refPathingTypeHover, tAltMidpoint) or 'nil')..'; Island from navutils='..(NavUtils.GetLabel(refPathingTypeLand, tAltMidpoint) or 'nil')) end
                                    if NavUtils.GetLabel(refPathingTypeHover, tAltMidpoint) == iPlateau and NavUtils.GetLabel(refPathingTypeLand, tAltMidpoint) == iBaseIslandWanted then
                                        bHaveValidAltMidpoint = true
                                        iAveragePlateau = NavUtils.GetLabel(refPathingTypeHover, tAltMidpoint)
                                        iAverageIsland = NavUtils.GetLabel(refPathingTypeLand, tAltMidpoint)
                                        tAverage = {tAltMidpoint[1], GetSurfaceHeight(tAltMidpoint[1], tAltMidpoint[3]), tAltMidpoint[3]}
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have valid alternative midpoint which will now record and use, tAverage after update='..repru(tAverage)) end
                                        break
                                    end
                                elseif bDebugMessages == true then
                                    LOG(sFunctionRef..': Adjusted semgnet X-Z='..iAdjustedSegmentX..'-'..iAdjustedSegmentZ..'; didnt have the right land zone, was '..(tLandZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ] or 'nil')..'; will draw segment midpoint in red if its in playaable area')
                                    local tAltLocation = GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)
                                    if tAltLocation and tAltLocation[1] > rMapPlayableArea[1] and tAltLocation[1] < rMapPlayableArea[3] and tAltLocation[3] > rMapPlayableArea[2] and tAltLocation[3] < rMapPlayableArea[4] then
                                        M28Utilities.DrawLocation(tAltLocation, 2)
                                    end
                                end
                            end
                        end
                        if bHaveValidAltMidpoint then break end
                    end
                    if bHaveValidAltMidpoint then break end
                end

                --If still dont have a valid location, then just try any segment recorded in the land zone (this wont be in the middle of the land zone, but is better than having an unpathable midpoint)
                if not(bHaveValidAltMidpoint) then
                    for iSegment, tSegmentXZ in tLZData[subrefLZSegments] do
                        if tLandZoneBySegment[tSegmentXZ[1]][tSegmentXZ[2]] == iZone then
                            tAltMidpoint = GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
                            if bDebugMessages == true then LOG(sFunctionRef..': Cycling through recorded segments for this LZ, and considering segment X-Z='..tSegmentXZ[1]..'-'..tSegmentXZ[2]..'; with land zone '..tLandZoneBySegment[tSegmentXZ[1]][tSegmentXZ[2]]..'; tAltMidpoint='..repru(tAltMidpoint)..'; Plateau from navutils='..(NavUtils.GetLabel(refPathingTypeHover, tAltMidpoint) or 'nil')..'; Island from navutils='..(NavUtils.GetLabel(refPathingTypeLand, tAltMidpoint) or 'nil')) end
                            if NavUtils.GetLabel(refPathingTypeHover, tAltMidpoint) == iPlateau and NavUtils.GetLabel(refPathingTypeLand, tAltMidpoint) == iBaseIslandWanted then
                                bHaveValidAltMidpoint = true
                                iAveragePlateau = NavUtils.GetLabel(refPathingTypeHover, tAltMidpoint)
                                iAverageIsland = NavUtils.GetLabel(refPathingTypeLand, tAltMidpoint)
                                tAverage = {tAltMidpoint[1], tAltMidpoint[2], tAltMidpoint[3]}
                                if bDebugMessages == true then LOG(sFunctionRef..': Have valid alternative midpoint which will now record and use, tAverage after update='..repru(tAverage)) end
                                break
                            end
                        end
                    end
                end
            end

            --Further alternative/backup (hopefully will never need to use this - this was the old backup which didnt work very well)
            if not(iAveragePlateau == iPlateau and iAverageLandZone == iZone) then
                iAveragePlateau, iAverageLandZone = GetPlateauAndLandZoneReferenceFromPosition(tAverage, false)
            end
            if (iAveragePlateau == iPlateau and iAverageLandZone == iZone) or M28Utilities.IsTableEmpty(tLZData[subrefLZMexLocations]) then
                --Either we have a valid location (in which case fine), or we have no mexes to use as a backup so will just use the midpoint (will cause some issues down the line though e.g. with the LZ not registering as being pathable to other land zones)
                tLZData[subrefLZMidpoint] = {tAverage[1], GetSurfaceHeight(tAverage[1], tAverage[3]), tAverage[3]}
            else
                --We have mexes so will just use one of these as the midpoint as a basic backup
                tLZData[subrefLZMidpoint] = {tLZData[subrefLZMexLocations][1][1], tLZData[subrefLZMexLocations][1][2], tLZData[subrefLZMexLocations][1][3]}
            end

            if bDebugMessages == true then
                local iColour = iPlateau
                while iColour > 8 do
                    iColour = iColour - 8
                end
                M28Utilities.DrawRectangle(Rect(iMinX, iMinZ, iMaxX, iMaxZ), iColour, 1000, 10)
                if iColour <= 1 then iColour = 8 end
                M28Utilities.DrawLocation(tLZData[subrefLZMidpoint], iColour, 1000)
                if bDebugMessages == true then LOG(sFunctionRef..': Midpoint after adjustment for iPlateau='..iPlateau..' and zone='..iZone..' = '..repru(tLZData[subrefLZMidpoint])..'; iBaseIslandWanted='..(iBaseIslandWanted or 'nil')) end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end



local function RecordHydroInLandZones()
    --Updates land zone data to include details of any hydro locations in the land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordHydroInLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(tHydroPoints) == false then
        local iPlateau, iLandZone

        for iHydro, tHydro in tHydroPoints do
            iPlateau, iLandZone = GetPlateauAndLandZoneReferenceFromPosition(tHydro)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iHydro='..iHydro..'; tHydro='..repru(tHydro)..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
            if iLandZone > 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Have a hydro location, CanBuildOnHydro='..tostring(M28Conditions.CanBuildOnHydroLocation(tHydro))) end
                table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefHydroLocations], tHydro)
                if M28Conditions.CanBuildOnHydroLocation(tHydro) then
                    table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefHydroUnbuiltLocations], tHydro)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function RecordHydroInWaterZones()
    --Updates land zone data to include details of any hydro locations in the land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordHydroInWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(tHydroPoints) == false then
        local iWaterZone

        for iHydro, tHydro in tHydroPoints do
            iWaterZone = GetWaterZoneFromPosition(tHydro)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iHydro='..iHydro..'; tHydro='..repru(tHydro)..'; iWaterZone='..(iWaterZone or 'nil')) end
            if iWaterZone > 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Have a hydro location, CanBuildOnHydro='..tostring(M28Conditions.CanBuildOnHydroLocation(tHydro))) end
                if not(tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone][subrefHydroLocations]) then tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone][subrefHydroLocations] = {} end
                table.insert(tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone][subrefHydroLocations], tHydro)
                if M28Conditions.CanBuildOnHydroLocation(tHydro) then
                    if not(tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone][subrefHydroUnbuiltLocations]) then tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone][subrefHydroUnbuiltLocations] = {} end
                    table.insert(tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone][subrefHydroUnbuiltLocations], tHydro)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordAdjacentLandZones()
    --Cycles through each land zone and identifies adjacent land zones
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAdjacentLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tiSegmentAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}}
    local iAltLandZone
    local iAltSegX, iAltSegZ
    local tRecordedAdjacentZones
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            tLandZoneInfo[subrefLZAdjacentLandZones] = {}
            tRecordedAdjacentZones = {}
            for iSegmentRef, tSegmentXZ in tLandZoneInfo[subrefLZSegments] do
                for iSegAdjust, tSegAdjXZ in tiSegmentAdjust do
                    iAltSegX = tSegmentXZ[1] + tSegAdjXZ[1]
                    iAltSegZ = tSegmentXZ[2] + tSegAdjXZ[2]
                    iAltLandZone = tLandZoneBySegment[iAltSegX][iAltSegZ]
                    if iAltLandZone and not(iAltLandZone == iLandZone) and not(tRecordedAdjacentZones[iAltLandZone]) then
                        if NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iAltSegX, iAltSegZ)) == iPlateau then
                            tRecordedAdjacentZones[iAltLandZone] = true
                            table.insert(tLandZoneInfo[subrefLZAdjacentLandZones], iAltLandZone)
                        end
                    end
                end
            end

            if bDebugMessages == true then
                LOG(sFunctionRef..': Finished considering Plateau '..iPlateau..' LZ '..iLandZone..': subrefLZAdjacentLandZones='..repru(tLandZoneInfo[subrefLZAdjacentLandZones]))
                local iColour = 1
                DrawSpecificLandZone(iPlateau, iLandZone, iColour)
                if M28Utilities.IsTableEmpty(tLandZoneInfo[subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLandZoneInfo[subrefLZAdjacentLandZones] do
                        iColour = iColour + 1
                        if iColour > 8 then iColour = 2 end
                        DrawSpecificLandZone(iPlateau, iAdjLZ, iColour)
                    end
                end

            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordAdjacentWaterZones()
    --Cycles through each water zone and identifies adjacent water zones
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAdjacentLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tiSegmentAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}}
    local iAltWaterZone
    local iAltSegX, iAltSegZ
    local tRecordedAdjacentZones
    for iPond, tPondSubtable in tPondDetails do
        for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do

            tWZData[subrefWZAdjacentWaterZones] = {}
            tRecordedAdjacentZones = {}
            for iSegmentRef, tSegmentXZ in tWZData[subrefWZSegments] do
                for iSegAdjust, tSegAdjXZ in tiSegmentAdjust do
                    iAltSegX = tSegmentXZ[1] + tSegAdjXZ[1]
                    iAltSegZ = tSegmentXZ[2] + tSegAdjXZ[2]
                    iAltWaterZone = tWaterZoneBySegment[iAltSegX][iAltSegZ]
                    if iAltWaterZone and not(iAltWaterZone == iWaterZone) and not(tRecordedAdjacentZones[iAltWaterZone]) then
                        if tiPondByWaterZone[iAltWaterZone] == iPond then
                            tRecordedAdjacentZones[iAltWaterZone] = true
                            table.insert(tWZData[subrefWZAdjacentWaterZones], iAltWaterZone)
                        end
                    end
                end
            end

            if bDebugMessages == true then
                LOG(sFunctionRef..': Finished considering Pond '..iPond..' WZ '..iWaterZone..': subrefWZAdjacentLandZones='..repru(tWZData[subrefWZAdjacentWaterZones]))
                local iColour = 1
                DrawSpecificWaterZone(iWaterZone, iColour)
                if M28Utilities.IsTableEmpty(tWZData[subrefWZAdjacentWaterZones]) == false then
                    for _, iAdjWZ in tWZData[subrefWZAdjacentWaterZones] do
                        iColour = iColour + 1
                        if iColour > 8 then iColour = 2 end
                        DrawSpecificWaterZone(iAdjWZ, iColour)
                    end
                end

            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iPlateau, iStartLandZone, iTargetLandZone, tStart, bWillUpdateLZEntryRefLater)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderAddingTargetLandZoneToDistanceFromBaseTable'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Have we not already considered this?
    if not(tbTempConsideredLandPathingForLZ[iPlateau][iStartLandZone][iTargetLandZone]) then

        local tEnd = tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZMidpoint]
        local tFullPath, iPathSize, iDistance = NavUtils.PathTo(refPathingTypeLand, tStart, tEnd, nil)
        if bDebugMessages == true then LOG(sFunctionRef..': Have just tried to get land path from tStart='..repru(tStart)..' to tEnd='..repru(tEnd)..'; iStartLandZone='..iStartLandZone..'; iTargetLandZone='..iTargetLandZone..'; tFullPath='..repru(tFullPath)..'; iPathSize='..iPathSize..'; will draw midpoint of the target LZ, and draw the start point, in blue')
            M28Utilities.DrawLocation(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZMidpoint])
            M28Utilities.DrawLocation(tStart)
        end

        if tFullPath then
            local iPathingPlateau, iPathingLandZone
            local tPathingLZConsidered = {}
            local tPathingLZFromStartToTarget = {}


            local iTravelDistance = 0
            tFullPath[0] = tStart
            tFullPath[iPathSize + 1] = tEnd
            for iPath = 1, iPathSize + 1 do
                iTravelDistance = iTravelDistance + VDist2(tFullPath[iPath - 1][1], tFullPath[iPath - 1][3], tFullPath[iPath][1], tFullPath[iPath][3])
                iPathingPlateau, iPathingLandZone = GetPlateauAndLandZoneReferenceFromPosition(tFullPath[iPath])
                if iPathingLandZone > 0 then
                    if not(tPathingLZConsidered[iPathingLandZone]) and not(iStartLandZone == iPathingLandZone) then
                        tPathingLZConsidered[iPathingLandZone] = true
                        table.insert(tPathingLZFromStartToTarget, iPathingLandZone)
                    end
                end
            end
            if not(tPathingLZConsidered[iTargetLandZone]) then
                table.insert(tPathingLZFromStartToTarget, iPathingLandZone)
                tPathingLZConsidered[iTargetLandZone] = true
            end
            --Record the travel distance
            if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZTravelDistToOtherLandZones][iPlateau]) then tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZTravelDistToOtherLandZones][iPlateau] = {} end
            tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZTravelDistToOtherLandZones][iPlateau][iStartLandZone] = iTravelDistance
            if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZTravelDistToOtherLandZones][iPlateau]) then tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZTravelDistToOtherLandZones][iPlateau] = {} end
            tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZTravelDistToOtherLandZones][iPlateau][iTargetLandZone] = iTravelDistance

            if bDebugMessages == true then
                LOG(sFunctionRef..': Travel distance to iTargetLandZone '..iTargetLandZone..' from '..iStartLandZone..' = '..iTravelDistance..'; tPathingLZConsidered='..repru(tPathingLZConsidered)..'; will draw path between LZs')
                M28Utilities.DrawPath(tFullPath, 1)
            end

            --Get position in new table
            local iPosition = 1
            if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones]) then
                tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones] = {}
                tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLZEntryRef] = {}
                iPosition = 1
            else
                for iExistingLandZone, tExistingSubtable in tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones] do
                    if tExistingSubtable[subrefLZTravelDist] <  iTravelDistance then
                        iPosition = iPosition + 1
                    else
                        break
                    end
                end
            end

            local iOppositePosition = 1
            if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones]) then
                tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones] = {}
                tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLZEntryRef] = {}
                iOppositePosition = 1
            else
                for iExistingLandZone, tExistingSubtable in tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones] do
                    if tExistingSubtable[subrefLZTravelDist] <  iTravelDistance then
                        iOppositePosition = iOppositePosition + 1
                    else
                        break
                    end
                end
            end

            table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones], iPosition, {[subrefLZNumber] = iTargetLandZone, [subrefLZPath] = {}, [subrefLZTravelDist] = iTravelDistance})
            table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones], iOppositePosition, {[subrefLZNumber] = iStartLandZone, [subrefLZPath] = {}, [subrefLZTravelDist] = iTravelDistance})

            --Will update subrefLZPathingToOtherLZEntryRef in UpdateLZPathingEntryReferences, as we need to do this for iOppositePositon once we have finished adding all oppositepositions or it will end up out of order

            --Record the land zone path from start to target
            for iEntry, iLZ in tPathingLZFromStartToTarget do
                table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones][iPosition][subrefLZPath], iLZ)
            end
            --Record the land zone path from target to start (adding in the start as the final point)
            local iTotalEntries = table.getn(tPathingLZFromStartToTarget)
            for iEntry = iTotalEntries, 1, -1 do
                if not(tPathingLZFromStartToTarget[iEntry] == iTargetLandZone) then
                    table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones][iOppositePosition][subrefLZPath], tPathingLZFromStartToTarget[iEntry])
                end
            end
            if not(tPathingLZFromStartToTarget[1] == iStartLandZone) then
                table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones][iOppositePosition][subrefLZPath], iStartLandZone)
            end

            --Record that we have considered the pathing between these two points
            if not(tbTempConsideredLandPathingForLZ[iPlateau]) then tbTempConsideredLandPathingForLZ[iPlateau] = {} end
            if not(tbTempConsideredLandPathingForLZ[iPlateau][iStartLandZone]) then tbTempConsideredLandPathingForLZ[iPlateau][iStartLandZone] = {} end
            if not(tbTempConsideredLandPathingForLZ[iPlateau][iTargetLandZone]) then tbTempConsideredLandPathingForLZ[iPlateau][iTargetLandZone] = {} end
            tbTempConsideredLandPathingForLZ[iPlateau][iStartLandZone][iTargetLandZone] = true
            tbTempConsideredLandPathingForLZ[iPlateau][iTargetLandZone][iStartLandZone] = true

            if bDebugMessages == true then LOG(sFunctionRef..': Path for goign the opposite direction='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones][iOppositePosition][subrefLZPath])..'; path for going the normal direction='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones][iPosition][subrefLZPath])..'; iPosition='..iPosition..'; iOppositePosition='..iOppositePosition) end

        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finsihed recording for iPlateau='..iPlateau..'; iStartLandZone='..iStartLandZone..'; subrefLZPathingToOtherLandZones='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones])..'; will now do repru of the target land zone pathing to other land zones='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones])) end
        if not(bWillUpdateLZEntryRefLater) then
            UpdateLZPathingEntryReferences(iPlateau, iStartLandZone)
            UpdateLZPathingEntryReferences(iPlateau, iTargetLandZone)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function RecordMaxAdjacencyTravelDistance()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordMaxAdjacencyTravelDistance'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iMaxAdjacentDistance
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            if M28Utilities.IsTableEmpty(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZAdjacentLandZones]) == false then
                iMaxAdjacentDistance = 0
                for _, iAdjLZ in tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZAdjacentLandZones] do
                    iMaxAdjacentDistance = math.max(iMaxAdjacentDistance, (tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTravelDistToOtherLandZones][iPlateau][iAdjLZ] or 0))
                end

                tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZFurthestAdjacentLandZoneTravelDist] = iMaxAdjacentDistance
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateLZPathingEntryReferences(iPlateau, iLandZone)
    local tLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
    if M28Utilities.IsTableEmpty(tLZData[subrefLZPathingToOtherLandZones]) == false then
        local iCurCount = 0
        for iEntry, tPathData in tLZData[subrefLZPathingToOtherLandZones] do
            iCurCount = iCurCount + 1
            tLZData[subrefLZPathingToOtherLZEntryRef][tPathData[subrefLZNumber]] = iCurCount
        end
    end
end

local function RecordPathingBetweenZones()
    --For each zone that is where a player starts, record pathing to every other zone; for other zones, record pathing to up to 3 layers of adjacency
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordPathingBetweenZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    WaitTicks(1) --To ensure all brains will be setup
    for iCurPlateau, tPlateauSubtable in tAllPlateaus do
        for iCurLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iCurLandZone='..iCurLandZone..' for plateau '..iCurPlateau..'; will go through every other LZ in the plateau and consider adding to the table of other land zones near this') end
            local tStartPoint = tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iCurLandZone][subrefLZMidpoint]
            for iTargetLandZone, tTargetLZInfo in tPlateauSubtable[subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Will consider iTargetLandZone='..iTargetLandZone..' for starting LZ '..iCurLandZone) end
                if not(iTargetLandZone == iCurLandZone) then
                    ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iCurPlateau, iCurLandZone, iTargetLandZone, tStartPoint, true)
                end
            end
        end
        --Now record the entry refs
        local iCurCount
        for iCurLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            UpdateLZPathingEntryReferences(iCurPlateau, iCurLandZone)
        end
    end
    --Record max adjacency distance
    RecordMaxAdjacencyTravelDistance()


    --[[
local tiPlateauLandZoneStartPoints = {}
local iCurPlateau, iCurLandZone
for iStart, tPlayerStart in PlayerStartPoints do
    iCurPlateau, iCurLandZone = GetPlateauAndLandZoneReferenceFromPosition(tPlayerStart)
    if (iCurLandZone or 0) > 0 then
        if not(tiPlateauLandZoneStartPoints[iCurPlateau]) then tiPlateauLandZoneStartPoints[iCurPlateau] = {} end
        tiPlateauLandZoneStartPoints[iCurPlateau][iCurLandZone] = true
        local tStartPoint = tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iCurLandZone][subrefLZMidpoint]

        --Consider all land zones in this plateau for start positions
        for iTargetLandZone, tTargetLandZoneInfo in tAllPlateaus[iCurPlateau][subrefPlateauLandZones] do
            if not(iTargetLandZone == iCurLandZone) then
                ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iCurPlateau, iCurLandZone, iTargetLandZone, tStartPoint)
            end
        end
    end
end

--Consider adjacent locations for non-core
for iCurPlateau, tPlateauSubtable in tAllPlateaus do
    for iCurLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
        if not(tiPlateauLandZoneStartPoints[iCurPlateau][iCurLandZone]) then
            local tiAdjacentLandZonesToConsider = {}
            if M28Utilities.IsTableEmpty(tLandZoneInfo[subrefLZAdjacentLandZones]) == false then
                for _, iAdjLZ1 in tLandZoneInfo[subrefLZAdjacentLandZones] do
                    if M28Utilities.IsTableEmpty(tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iAdjLZ1][subrefLZAdjacentLandZones]) == false then
                        for _, iAdjLZ2 in tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iAdjLZ1][subrefLZAdjacentLandZones] do
                            if M28Utilities.IsTableEmpty(tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iAdjLZ2][subrefLZAdjacentLandZones]) == false then
                                for _, iAdjLZ3 in tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iAdjLZ2][subrefLZAdjacentLandZones] do
                                    if not(tiAdjacentLandZonesToConsider[iAdjLZ3]) then tiAdjacentLandZonesToConsider[iAdjLZ3] = true end
                                end
                            end
                            if not(tiAdjacentLandZonesToConsider[iAdjLZ2]) then tiAdjacentLandZonesToConsider[iAdjLZ2] = true end
                        end
                    end
                    if not(tiAdjacentLandZonesToConsider[iAdjLZ1]) then tiAdjacentLandZonesToConsider[iAdjLZ1] = true end
                end
                local tStartPoint = tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iCurLandZone][subrefLZMidpoint]
                for iAdjLandZone, _ in tiAdjacentLandZonesToConsider do
                    if not(iAdjLandZone == iCurLandZone) then
                        ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iCurPlateau, iCurLandZone, iAdjLandZone, tStartPoint)
                    end
                end
            end
        end
    end
end--]]
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function RecordTravelDistBetweenZonesOverTime()
    --Record how  long it would take to travel between each other land zone upfront so dont have to calculate on the fly
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordTravelDistBetweenZonesOverTime'
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iCurCount = 0
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iStartLZ, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            if bDebugMessages == true then LOG(sFunctionRef..': About to consider all other land zones in plateau '..iPlateau..' for iStartLZ='..iStartLZ) end
            for iEndLZ,  tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iEndLZ='..iEndLZ) end
                if not(iStartLZ == iEndLZ) then
                    iCurCount = iCurCount + 1
                    if iCurCount >= 10 then
                        iCurCount = 0
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    end

                    GetTravelDistanceBetweenLandZones(iPlateau, iStartLZ, iEndLZ)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordClosestAllyAndEnemyBaseForEachLandZone(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordClosestAllyAndEnemyBaseForEachLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    while not(bMapLandSetupComplete) do
        WaitTicks(1)
    end

    local tEnemyBases = {}
    local tAllyBases = {}
    local tBrainsByIndex = {}

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains]) == false then
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
            tEnemyBases[oBrain:GetArmyIndex()] = PlayerStartPoints[oBrain:GetArmyIndex()]
            tBrainsByIndex[oBrain:GetArmyIndex()] = oBrain
        end
    end
    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveBrains] do
        if bDebugMessages == true then LOG(sFunctionRef..': Cycling through friedly active brains in iTeam='..iTeam..'; oBrain.Nickname='..oBrain.Nickname) end
        tAllyBases[oBrain:GetArmyIndex()] = PlayerStartPoints[oBrain:GetArmyIndex()]
        tBrainsByIndex[oBrain:GetArmyIndex()] = oBrain
    end

    if M28Utilities.IsTableEmpty(tEnemyBases) then
        local aiBrain
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            aiBrain = oBrain
            break
        end
        table.insert(tEnemyBases, GetPrimaryEnemyBaseLocation(aiBrain))
    end

    local iCurBrainDist
    local iClosestBrainDist
    local iClosestBrainRef
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLZData in tPlateauSubtable[subrefPlateauLandZones] do
            iClosestBrainDist = 100000
            for iBrain, tStartPoint in tAllyBases do
                iCurBrainDist = M28Utilities.GetDistanceBetweenPositions(tLZData[subrefLZMidpoint], tStartPoint)
                if iCurBrainDist < iClosestBrainDist then
                    iClosestBrainRef = iBrain
                    iClosestBrainDist = iCurBrainDist
                end
            end
            local tLZTeamData = tLZData[subrefLZTeamData][iTeam]
            tLZTeamData[reftClosestFriendlyBase] = {PlayerStartPoints[iClosestBrainRef][1], PlayerStartPoints[iClosestBrainRef][2], PlayerStartPoints[iClosestBrainRef][3]}
            tLZTeamData[reftClosestEnemyBase] = GetPrimaryEnemyBaseLocation(tBrainsByIndex[iClosestBrainRef])
            tLZTeamData[refiModDistancePercent] = GetModDistanceFromStart(tBrainsByIndex[iClosestBrainRef], tLZData[subrefLZMidpoint], false)
            if bDebugMessages == true then LOG(sFunctionRef..': Have recorded closest enemy base for iPlateau '..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; tLZTeamData[reftClosestFriendlyBase]='..repru(tLZTeamData[reftClosestFriendlyBase])..'; repru(tLZTeamData[reftClosestEnemyBase])='..repru(tLZTeamData[reftClosestEnemyBase])..'; iClosestBrainRef='..iClosestBrainRef..'; tBrainsByIndex[iClosestBrainRef].Nickname='..tBrainsByIndex[iClosestBrainRef].Nickname..'; aiBrain[reftPrimaryEnemyBaseLocation] for this brain='..repru(tBrainsByIndex[iClosestBrainRef][reftPrimaryEnemyBaseLocation])) end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordClosestAllyAndEnemyBaseForEachWaterZone(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordClosestAllyAndEnemyBaseForEachWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    while not(bWaterZoneInitialCreation) do
        WaitTicks(1)
        if GetGameTimeSeconds() >= 5 then break end
    end

    local tEnemyBases = {}
    local tAllyBases = {}
    local tBrainsByIndex = {}

    local iCurBrainDist
    local iClosestBrainDist
    local iClosestBrainRef

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains]) == false then
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
            tEnemyBases[oBrain:GetArmyIndex()] = PlayerStartPoints[oBrain:GetArmyIndex()]
            tBrainsByIndex[oBrain:GetArmyIndex()] = oBrain
        end
    end
    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveBrains] do
        tAllyBases[oBrain:GetArmyIndex()] = PlayerStartPoints[oBrain:GetArmyIndex()]
        tBrainsByIndex[oBrain:GetArmyIndex()] = oBrain
    end

    if M28Utilities.IsTableEmpty(tEnemyBases) then
        local aiBrain
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            aiBrain = oBrain
            break
        end
        table.insert(tEnemyBases, GetPrimaryEnemyBaseLocation(aiBrain))
    end

    --Update water zones
    if bDebugMessages == true then LOG(sFunctionRef..': About to start with updating water zone information, GameTime='..GetGameTimeSeconds()..'; bMapLandSetupComplete='..tostring(bMapLandSetupComplete or false)..'; bHaveConsideredPreferredPondForM28AI='..tostring(bHaveConsideredPreferredPondForM28AI or false)) end
    for iPond, tPondSubtable in tPondDetails do
        if bDebugMessages == true then LOG(sFunctionRef..': Considering iPond='..iPond..'; reprs of tPondSubtable='..reprs(tPondSubtable)) end
        for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
            if not(tWZData[subrefWZTeamData]) then tWZData[subrefWZTeamData] = {} end
            if not(tWZData[subrefWZTeamData][iTeam]) then tWZData[subrefWZTeamData][iTeam] = {} end
            local tWZTeamData = tWZData[subrefWZTeamData][iTeam]

            iClosestBrainDist = 100000
            for iBrain, tStartPoint in tAllyBases do
                iCurBrainDist = M28Utilities.GetDistanceBetweenPositions(tWZData[subrefWZMidpoint], tStartPoint)
                if iCurBrainDist < iClosestBrainDist then
                    iClosestBrainRef = iBrain
                    iClosestBrainDist = iCurBrainDist
                end
            end

            tWZTeamData[reftClosestFriendlyBase] = {PlayerStartPoints[iClosestBrainRef][1], PlayerStartPoints[iClosestBrainRef][2], PlayerStartPoints[iClosestBrainRef][3]}
            tWZTeamData[reftClosestEnemyBase] = GetPrimaryEnemyBaseLocation(tBrainsByIndex[iClosestBrainRef])
            tWZTeamData[refiModDistancePercent] = GetModDistanceFromStart(tBrainsByIndex[iClosestBrainRef], tWZData[subrefWZMidpoint], false)

        end
    end
    ForkThread(M28Team.WaterZoneTeamInitialisation, iTeam)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ReturnNthValidLocationInSameLandZoneClosestToTarget(iPlateau, iLandZoneWanted, tStartLZData, tTargetDestination, iDistanceInterval, iNthEntryWanted, iMaxDistance)
    local iSearchDistance = 0
    local tValidLocations = {}
    local iValidLocationCount = 0
    local iAngleToTarget = M28Utilities.GetAngleFromAToB(tStartLZData[subrefLZMidpoint], tTargetDestination)
    local iFailureCount = 0 --After 5 failures in a row will abort
    local iCurPlateau, iCurLandZone
    if iDistanceInterval < 0 then M28Utilities.ErrorHandler('Likely infinite loop as have negative distance interval') end

    while iSearchDistance <= (iMaxDistance or 150) do
        iSearchDistance = iSearchDistance + iDistanceInterval
        local tPotentialLocation = M28Utilities.MoveInDirection(tStartLZData[subrefLZMidpoint], iAngleToTarget, iSearchDistance, true, false)
        iCurPlateau, iCurLandZone = GetPlateauAndLandZoneReferenceFromPosition(tPotentialLocation)
        if iCurPlateau == iPlateau and iCurLandZone == iLandZoneWanted then
            iValidLocationCount = iValidLocationCount + 1
            tValidLocations[iValidLocationCount] = {tPotentialLocation[1], tPotentialLocation[2], tPotentialLocation[3]}
            iFailureCount = 0
        else
            iFailureCount = iFailureCount + 1
            if iFailureCount >= 5 then break end
        end
    end
    if iValidLocationCount > 0 then
        if iValidLocationCount <= iNthEntryWanted then return tValidLocations[iValidLocationCount]
        else return tValidLocations[iValidLocationCount - iNthEntryWanted]
        end
    else
        return nil
    end
end

function ReturnNthValidLocationInSameWaterZoneClosestToTarget(iPond, iWaterZoneWanted, tStartWZData, tTargetDestination, iDistanceInterval, iNthEntryWanted, iMaxDistance)
    local iSearchDistance = 0
    local tValidLocations = {}
    local iValidLocationCount = 0
    local iAngleToTarget = M28Utilities.GetAngleFromAToB(tStartWZData[subrefWZMidpoint], tTargetDestination)
    local iFailureCount = 0 --After 5 failures in a row will abort
    local iCurPond, iCurWaterZone
    if iDistanceInterval < 0 then M28Utilities.ErrorHandler('Likely infinite loop as have negative distance interval') end

    while iSearchDistance <= (iMaxDistance or 150) do
        iSearchDistance = iSearchDistance + iDistanceInterval
        local tPotentialLocation = M28Utilities.MoveInDirection(tStartWZData[subrefWZMidpoint], iAngleToTarget, iSearchDistance, true, false)
        iCurWaterZone = GetWaterZoneFromPosition(tPotentialLocation)
        iCurPond = tiPondByWaterZone[iCurWaterZone]
        if iCurPond == iPond and iCurWaterZone == iWaterZoneWanted then
            iValidLocationCount = iValidLocationCount + 1
            tValidLocations[iValidLocationCount] = {tPotentialLocation[1], tPotentialLocation[2], tPotentialLocation[3]}
            iFailureCount = 0
        else
            iFailureCount = iFailureCount + 1
            if iFailureCount >= 5 then break end
        end
    end
    if iValidLocationCount > 0 then
        if iValidLocationCount <= iNthEntryWanted then return tValidLocations[iValidLocationCount]
        else return tValidLocations[iValidLocationCount - iNthEntryWanted]
        end
    else
        return nil
    end
end

function ReorderPathBasedOnAngleToFirstEntry(tUnorderedPatrolPaths, tFirstPointInPath, bAddFirstPoint)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReorderPathBasedOnDistanceToFirstEntry'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tReorderedPositions = {}
    if bAddFirstPoint then
        table.insert(tReorderedPositions, {tFirstPointInPath[1], tFirstPointInPath[2], tFirstPointInPath[3]})
    end
    if M28Utilities.IsTableEmpty(tUnorderedPatrolPaths) == false then

        local iCurAngleFromFirstPosition
        local iClosestAngleDifFromLast
        local iClosestDistRef
        local tCurStartPoint = {tFirstPointInPath[1], tFirstPointInPath[2], tFirstPointInPath[3]}
        local iLoopCount = 0

        local iMaxLoop = table.getn(tUnorderedPatrolPaths) + 2
        if bDebugMessages == true then LOG(sFunctionRef..': About to order paths, tUnorderedPatrolPaths='..repru(tUnorderedPatrolPaths)..'; tFirstPointInPath='..repru(tFirstPointInPath)..'; bAddFirstPoint='..tostring(bAddFirstPoint or false)) end

        --First get closest point to the start
        local iClosestDistToStart = 10000
        local iCurDistToStart
        local iCurAngleDif
        for iEntry, tPosition in tUnorderedPatrolPaths do
            iCurDistToStart = M28Utilities.GetDistanceBetweenPositions(tCurStartPoint, tPosition)
            if iCurDistToStart < iClosestDistToStart then
                iClosestDistToStart = iCurDistToStart
                iClosestDistRef = iEntry
            end
        end
        local iLastAngleUsed = M28Utilities.GetAngleFromAToB(tCurStartPoint, tUnorderedPatrolPaths[iClosestDistRef])
        table.insert(tReorderedPositions, {tUnorderedPatrolPaths[iClosestDistRef][1], tUnorderedPatrolPaths[iClosestDistRef][2], tUnorderedPatrolPaths[iClosestDistRef][3]})
        if bDebugMessages == true then LOG(sFunctionRef..': Angle from tCurStartPoint '..repru(tCurStartPoint)..' to first point after this, '..repru(tUnorderedPatrolPaths[iClosestDistRef])..' is '..iLastAngleUsed) end
        table.remove(tUnorderedPatrolPaths, iClosestDistRef)


        while M28Utilities.IsTableEmpty(tUnorderedPatrolPaths) == false do
            iLoopCount = 1
            iClosestAngleDifFromLast = 10000
            for iEntry, tPosition in tUnorderedPatrolPaths do
                iCurAngleFromFirstPosition = M28Utilities.GetAngleFromAToB(tCurStartPoint, tPosition)
                iCurAngleDif = M28Utilities.GetAngleDifference(iCurAngleFromFirstPosition, iLastAngleUsed)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering tPosition='..repru(tPosition)..'; Angle from start to here='..iCurAngleFromFirstPosition..'; Angle dif to last angle='..M28Utilities.GetAngleDifference(iCurAngleFromFirstPosition, iLastAngleUsed)) end
                if iCurAngleDif < iClosestAngleDifFromLast then
                    iClosestAngleDifFromLast = iCurAngleDif
                    iClosestDistRef = iEntry
                end
            end
            iLastAngleUsed = M28Utilities.GetAngleFromAToB(tCurStartPoint, tUnorderedPatrolPaths[iClosestDistRef])
            table.insert(tReorderedPositions, {tUnorderedPatrolPaths[iClosestDistRef][1], tUnorderedPatrolPaths[iClosestDistRef][2], tUnorderedPatrolPaths[iClosestDistRef][3]})
            if bDebugMessages == true then LOG(sFunctionRef..': Best location='..repru(tUnorderedPatrolPaths[iClosestDistRef])..'; iLastAngleUsed='..iLastAngleUsed) end
            table.remove(tUnorderedPatrolPaths, iClosestDistRef)
            if iLoopCount > iMaxLoop then M28Utilities.ErrorHandler('Infinite loop') break end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished reordering path, tReorderedPositions='..repru(tReorderedPositions)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tReorderedPositions
end

function ReorderPathBasedOnDistanceToFirstEntry(tUnorderedPatrolPaths, tFirstPointInPath, bAddFirstPoint)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReorderPathBasedOnDistanceToFirstEntry'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tReorderedPositions = {}
    if bAddFirstPoint then
        table.insert(tReorderedPositions, {tFirstPointInPath[1], tFirstPointInPath[2], tFirstPointInPath[3]})
    end

    local iCurDistToStart
    local iClosestDistToStart
    local iClosestDistRef
    local tCurStartPoint = {tFirstPointInPath[1], tFirstPointInPath[2], tFirstPointInPath[3]}
    local iLoopCount = 0
    local iMaxLoop = table.getn(tUnorderedPatrolPaths) + 2
    if bDebugMessages == true then LOG(sFunctionRef..': About to order paths, tUnorderedPatrolPaths='..repru(tUnorderedPatrolPaths)..'; tFirstPointInPath='..repru(tFirstPointInPath)..'; bAddFirstPoint='..tostring(bAddFirstPoint or false)) end

    while M28Utilities.IsTableEmpty(tUnorderedPatrolPaths) == false do
        iLoopCount = 1
        iClosestDistToStart = 10000
        for iEntry, tPosition in tUnorderedPatrolPaths do
            iCurDistToStart = M28Utilities.GetDistanceBetweenPositions(tCurStartPoint, tPosition)
            if iCurDistToStart < iClosestDistToStart then
                iClosestDistToStart = iCurDistToStart
                iClosestDistRef = iEntry
            end
        end
        table.insert(tReorderedPositions, {tUnorderedPatrolPaths[iClosestDistRef][1], tUnorderedPatrolPaths[iClosestDistRef][2], tUnorderedPatrolPaths[iClosestDistRef][3]})
        tCurStartPoint = {tUnorderedPatrolPaths[iClosestDistRef][1], tUnorderedPatrolPaths[iClosestDistRef][2], tUnorderedPatrolPaths[iClosestDistRef][3]}
        table.remove(tUnorderedPatrolPaths, iClosestDistRef)
        if iLoopCount > iMaxLoop then M28Utilities.ErrorHandler('Infinite loop') break end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished reordering path, tReorderedPositions='..repru(tReorderedPositions)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tReorderedPositions
end

function RecordLandZonePatrolPaths()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordLandZonePatrolPaths'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLZSubtable in tPlateauSubtable[subrefPlateauLandZones] do
            --Are we interested in patrolling this land zone? Want to ignore very small land zones
            if tLZSubtable[subrefLZMexCount] > 0 or tLZSubtable[subrefLZTotalSegmentCount] >= 40 then

                --First travel towards adjacent locations an add these
                local tUnorderedPatrolPaths = {}
                local tAnglesCovered = {}

                if M28Utilities.IsTableEmpty(tLZSubtable[subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZSubtable[subrefLZAdjacentLandZones] do
                        local tPotentialLocation = ReturnNthValidLocationInSameLandZoneClosestToTarget(iPlateau, iLandZone, tLZSubtable, tAllPlateaus[iPlateau][subrefPlateauLandZones][iAdjLZ][subrefLZMidpoint], 4, 3, 100)
                        if tPotentialLocation then
                            table.insert(tUnorderedPatrolPaths, tPotentialLocation)
                            table.insert(tAnglesCovered, M28Utilities.GetAngleFromAToB(tLZSubtable[subrefLZMidpoint], tPotentialLocation))
                        end
                    end
                end
                --Identify any gaps in the path if we arent near the edge of the map
                local tbBaseAngleCovered = {}
                local iDistThreshold = 90
                if tLZSubtable[subrefLZMidpoint][3] >= rMapPlayableArea[2] + iDistThreshold then
                    --Arent close to the top of the map so can look north
                    tbBaseAngleCovered[0] = false
                end
                if tLZSubtable[subrefLZMidpoint][1] <= rMapPlayableArea[3] - iDistThreshold then
                    --Arent close to the rh of the map so can look east
                    tbBaseAngleCovered[90] = false
                end
                if tLZSubtable[subrefLZMidpoint][3] <= rMapPlayableArea[4] - iDistThreshold then
                    --Arent close to the bottom of the map so can look south
                    tbBaseAngleCovered[180] = false
                end
                if tLZSubtable[subrefLZMidpoint][1] >= rMapPlayableArea[1] + iDistThreshold then
                    --Aren't close to left hand part of map so can look west
                    tbBaseAngleCovered[270] = false
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLZ='..iLandZone..'; tAnglesCovered='..repru(tAnglesCovered)..'; Midpoint='..repru(tLZSubtable[subrefLZMidpoint])..'; playable area='..repru(rMapPlayableArea)..'; iDistThreshold='..iDistThreshold..'; tbBaseAngleCovered before factoring in angles covered='..repru(tbBaseAngleCovered)) end

                if M28Utilities.IsTableEmpty(tAnglesCovered) == false then

                    for _, iAngle in tAnglesCovered do
                        for iBaseAngle, bCovered in tbBaseAngleCovered do
                            if not(bCovered) then
                                if M28Utilities.GetAngleDifference(iBaseAngle, iAngle) <= 45 then
                                    tbBaseAngleCovered[iBaseAngle] = true
                                end
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': tbBaseAngleCovered='..repru(tbBaseAngleCovered)) end
                for iBaseAngle, bCovered in tbBaseAngleCovered do
                    if not(bCovered) then
                        local tPotentialLocation = ReturnNthValidLocationInSameLandZoneClosestToTarget(iPlateau, iLandZone, tLZSubtable, M28Utilities.MoveInDirection(tLZSubtable[subrefLZMidpoint], iBaseAngle, iDistThreshold, false, false), 4, 3, 70)
                        if tPotentialLocation then
                            table.insert(tUnorderedPatrolPaths, tPotentialLocation)
                        end
                    end
                end


                --Order the path based on distance, and add the midpoint of the land zone
                --Originally did based on distance, but based on angle looks slightly better
                --tLZSubtable[subreftPatrolPath] = ReorderPathBasedOnDistanceToFirstEntry(tUnorderedPatrolPaths, {tLZSubtable[subrefLZMidpoint][1] + 3, tLZSubtable[subrefLZMidpoint][2], tLZSubtable[subrefLZMidpoint][3] + 3}, true)
                tLZSubtable[subreftPatrolPath] = ReorderPathBasedOnAngleToFirstEntry(tUnorderedPatrolPaths, {tLZSubtable[subrefLZMidpoint][1] + 3, tLZSubtable[subrefLZMidpoint][2], tLZSubtable[subrefLZMidpoint][3] + 3}, true)

                if bDebugMessages == true then
                    LOG(sFunctionRef..': Finished recording patrol path for plateau '..iPlateau..'; Land zone ='..iLandZone..'; Patrol path='..repru(tLZSubtable[subreftPatrolPath]))
                    M28Utilities.DrawLocation(tLZSubtable[subrefLZMidpoint])
                    if M28Utilities.IsTableEmpty(tLZSubtable[subreftPatrolPath]) == false then
                        M28Utilities.DrawPath(tLZSubtable[subreftPatrolPath], 5, nil)
                    end

                end
            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordWaterZonePatrolPaths()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordWaterZonePatrolPaths'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    for iPond, tPondSubtable in tPondDetails do
        for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
            --Are we interested in patrolling this water zone? Want to ignore very small water zones
            if table.getn(tWZData[subrefWZSegments]) >= 40 then

                --First travel towards adjacent locations an add these
                local tUnorderedPatrolPaths = {}
                local tAnglesCovered = {}

                if M28Utilities.IsTableEmpty(tWZData[subrefWZOtherWaterZones]) == false then
                    for iEntry, iAltWZ in tWZData[subrefWZAdjacentWaterZones] do
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Will draw midpoint of the current water zone in gold and the target in light blue; this waterzone midpoint='..repru(tWZData[subrefWZMidpoint])..'; Target WZ iAltWZ '..iAltWZ..'='..repru(tPondDetails[iPond][subrefPondWaterZones][iAltWZ][subrefWZMidpoint]))
                            M28Utilities.DrawLocation(tWZData[subrefWZMidpoint], 4)
                            M28Utilities.DrawLocation(tPondDetails[iPond][subrefPondWaterZones][iAltWZ][subrefWZMidpoint], 5)
                        end
                        local tPotentialLocation = ReturnNthValidLocationInSameWaterZoneClosestToTarget(iPond, iWaterZone, tWZData, tPondDetails[iPond][subrefPondWaterZones][iAltWZ][subrefWZMidpoint], 4, 3, 150)
                        if bDebugMessages == true then LOG(sFunctionRef..': Start WZ='..iWaterZone..'; iAltWZ='..iAltWZ..'; tPotentialLocation='..repru(tPotentialLocation)) end
                        if tPotentialLocation then
                            table.insert(tUnorderedPatrolPaths, tPotentialLocation)
                            table.insert(tAnglesCovered, M28Utilities.GetAngleFromAToB(tWZData[subrefWZMidpoint], tPotentialLocation))
                        end
                    end
                end
                --Identify any gaps in the path if we arent near the edge of the map
                local tbBaseAngleCovered = {}
                local iDistThreshold = 90
                if tWZData[subrefWZMidpoint][3] >= rMapPlayableArea[2] + iDistThreshold then
                    --Arent close to the top of the map so can look north
                    tbBaseAngleCovered[0] = false
                end
                if tWZData[subrefWZMidpoint][1] <= rMapPlayableArea[3] - iDistThreshold then
                    --Arent close to the rh of the map so can look east
                    tbBaseAngleCovered[90] = false
                end
                if tWZData[subrefWZMidpoint][3] <= rMapPlayableArea[4] - iDistThreshold then
                    --Arent close to the bottom of the map so can look south
                    tbBaseAngleCovered[180] = false
                end
                if tWZData[subrefWZMidpoint][1] >= rMapPlayableArea[1] + iDistThreshold then
                    --Aren't close to left hand part of map so can look west
                    tbBaseAngleCovered[270] = false
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iPond='..iPond..'; iWZ='..iWaterZone..'; tAnglesCovered='..repru(tAnglesCovered)..'; Midpoint='..repru(tWZData[subrefWZMidpoint])..'; playable area='..repru(rMapPlayableArea)..'; iDistThreshold='..iDistThreshold..'; tbBaseAngleCovered before factoring in angles covered='..repru(tbBaseAngleCovered)) end

                if M28Utilities.IsTableEmpty(tAnglesCovered) == false then

                    for _, iAngle in tAnglesCovered do
                        for iBaseAngle, bCovered in tbBaseAngleCovered do
                            if not(bCovered) then
                                if M28Utilities.GetAngleDifference(iBaseAngle, iAngle) <= 45 then
                                    tbBaseAngleCovered[iBaseAngle] = true
                                end
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iWaterZone='..iWaterZone..'; tbBaseAngleCovered='..repru(tbBaseAngleCovered)) end
                for iBaseAngle, bCovered in tbBaseAngleCovered do
                    if not(bCovered) then
                        local tPotentialLocation = ReturnNthValidLocationInSameWaterZoneClosestToTarget(iPond, iWaterZone, tWZData, M28Utilities.MoveInDirection(tWZData[subrefWZMidpoint], iBaseAngle, iDistThreshold, false, false), 4, 3, 100)
                        if bDebugMessages == true then LOG(sFunctionRef..': tPotentialLocation for iBaseAngle='..iBaseAngle..'='..repru(tPotentialLocation)) end
                        if tPotentialLocation then
                            table.insert(tUnorderedPatrolPaths, tPotentialLocation)
                        end
                    end
                end


                --Order the path based on distance, and add the midpoint of the land zone
                --Originally did based on distance, but based on angle looks slightly better
                --tWZData[subreftPatrolPath] = ReorderPathBasedOnDistanceToFirstEntry(tUnorderedPatrolPaths, {tWZData[subrefLZMidpoint][1] + 3, tWZData[subrefLZMidpoint][2], tWZData[subrefLZMidpoint][3] + 3}, true)
                tWZData[subreftPatrolPath] = ReorderPathBasedOnAngleToFirstEntry(tUnorderedPatrolPaths, {tWZData[subrefWZMidpoint][1] + 3, tWZData[subrefWZMidpoint][2], tWZData[subrefWZMidpoint][3] + 3}, true)

                if bDebugMessages == true then
                    LOG(sFunctionRef..': Finished recording patrol path for pond '..iPond..'; Water zone ='..iWaterZone..'; Patrol path='..repru(tWZData[subreftPatrolPath]))
                    M28Utilities.DrawLocation(tWZData[subrefWZMidpoint])
                    if M28Utilities.IsTableEmpty(tWZData[subreftPatrolPath]) == false then
                        M28Utilities.DrawPath(tWZData[subreftPatrolPath], 5, nil)
                    end

                end
            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function SetupLandZones()
    --Divides the map into 'land zones' based on mex placement and plateau groups, which is to form the basis for managing land units.  Land zones are areas that can be pathed by land units and are intended to group the map based on how long it takes to travel
    --Intended to be called at start of game when AI is created (so after siminit and recordresourcepoints has run), and after plateaus have been generated
    --Broadly, will group nearby mexes together in the same land zone, along with the nearby area; then will look for any places on the map with no nearby land zone and create a zone for these, and then go through the whole map and ensure every land pathable area has an assigned land zone
    --To avoid too much of a CPU load, the map is first divided into small 'segment' squares, the size of which varies based on the size of a map (1x1 for a 5km map, 2x2 for a 10km map, etc.), with it assumed that any location within a segment square has the same pathing as the midpoint of that segment
    --i.e. there will inevitably be cases where units go near a cliff where the land pathing zone is inconsistent with where the unit can path to

    --Using land zones:
    --To return both the plateau reference, and the land zone reference, of a position tPosiiton, use the function GetPlateauAndLandZoneReferenceFromPosition(tPosition) (which will return nil if it doesnt have a value)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of land zone generation, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end

    --First go through every mex on the map, and assign it a land zone (grouping mexes near each other together):
    AssignMexesALandZone()
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Now add any areas that can easily be pathed to each mex to the same land zone as that mex:
    if bDebugMessages == true then LOG(sFunctionRef..': Finished assining mexes to a land zone, will now assign the area near mexes') end
    AssignSegmentsNearMexesToLandZones()
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    if bDebugMessages == true then
        LOG(sFunctionRef..': Finished assining area aound mexes, will now draw resulting land zones, system time='..GetSystemTimeSecondsOnlyForProfileUse())
        DrawLandZones()
        WaitTicks(5)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Now look for empty spots on the map without land zones and assign them a land zone, creating new ones (that have no mexes in them) where they are far from any existing land zone:
    AssignRemainingSegmentsToLandZones()
    if bDebugMessages == true then LOG(sFunctionRef..': Added remaining segments to land zones') end

    --Clear variables that we no longer need:
    tTempZoneTravelDistanceBySegment =  nil
    tTempZonePlateauBySegment = nil

    RecordLandZoneMidpointAndUnbuiltMexes()
    if bDebugMessages == true then LOG(sFunctionRef..': Finished recording land zone midpoint and unbuilt mexes system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    RecordHydroInLandZones()
    ReorderLandZoneSegmentsForEachPlateau()
    RecordAdjacentLandZones()
    RecordMassStorageLocationsForEachLandZone()
    RecordLandZonePatrolPaths()

    if bDebugMessages == true then LOG(sFunctionRef..': Finished LZ patrol paths, sys time='..GetSystemTimeSecondsOnlyForProfileUse()) end

    RecordPathingBetweenZones() --Includes a waitticks(1)

    --Map out how long it will take each LZ to path to each other LZ
    ForkThread(RecordTravelDistBetweenZonesOverTime)

    --If debug is enabled, draw land zones (different colour for each land zone on a plateau)
    if bDebugMessages == true then
        LOG(sFunctionRef..': Finished generating all land zones, will now draw them. System time='..GetSystemTimeSecondsOnlyForProfileUse())
        DrawLandZones()
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordIslands()
    --Assumes have already setup every land zone on the map - will now record details of islands
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordIslands'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --First record every island where there are mexes in the plateau
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; About to record any islands for plateau '..iPlateau..'; if it has mexes, tPlateauSubtable[subrefPlateauTotalMexCount]='..tPlateauSubtable[subrefPlateauTotalMexCount]) end
        if tPlateauSubtable[subrefPlateauTotalMexCount] > 0 then
            tPlateauSubtable[subrefPlateauIslandLandZones] = {}
            tPlateauSubtable[subrefPlateauIslandMexCount] = { }
            local tLandZonesWithoutIslands = {}
            for iLandZone, tLZData in tPlateauSubtable[subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iLandZone='..iLandZone..'; in Plateau '..iPlateau..'; Amphibious label='..(NavUtils.GetLabel(refPathingTypeLand, tLZData[subrefLZMidpoint]) or 'nil')) end
                tLZData[subrefLZIslandRef] = NavUtils.GetLabel(refPathingTypeLand, tLZData[subrefLZMidpoint])
                if tLZData[subrefLZIslandRef] > 0 then
                    if not(tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]]) then tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]] = {} end
                    table.insert(tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]], iLandZone)
                    tPlateauSubtable[subrefPlateauIslandMexCount][tLZData[subrefLZIslandRef]] = (tPlateauSubtable[subrefPlateauIslandMexCount][tLZData[subrefLZIslandRef]] or 0) + tLZData[subrefLZMexCount]
                else
                    table.insert(tLandZonesWithoutIslands, iLandZone)
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have an island ref for iLandZone='..iLandZone..'; so will record in tLandZonesWithoutIslands') end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking all land zones for plateau '..iPlateau..' for first pass; is table of tLandZonesWithoutIslands empty='..tostring(M28Utilities.IsTableEmpty(tLandZonesWithoutIslands))) end
            if M28Utilities.IsTableEmpty(tLandZonesWithoutIslands) == false then
                for iEntry, iLandZone in tLandZonesWithoutIslands do
                    local tLZData = tPlateauSubtable[subrefPlateauLandZones][iLandZone]
                    --Cycle through adjacent LZs to see if any of them have an island recorded
                    if M28Utilities.IsTableEmpty(tLZData[subrefLZPathingToOtherLandZones]) == false then
                        for iEntry, tSubtable in tLZData[subrefLZPathingToOtherLandZones] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent LZs for iLandZone='..iLandZone..'; Adjacent LZ='..tSubtable[subrefLZNumber]..'; Island ref for this='..(tPlateauSubtable[subrefPlateauLandZones][tSubtable[subrefLZNumber]][subrefLZIslandRef] or 'nil')) end
                            if (tPlateauSubtable[subrefPlateauLandZones][tSubtable[subrefLZNumber]][subrefLZIslandRef] or 0) > 0 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will use htis island ref') end
                                tLZData[subrefLZIslandRef] = tPlateauSubtable[subrefPlateauLandZones][tSubtable[subrefLZNumber]][subrefLZIslandRef]
                                if not(tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]]) then tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]] = {} end
                                table.insert(tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]], iLandZone)
                                tPlateauSubtable[subrefPlateauIslandMexCount][tLZData[subrefLZIslandRef]] = (tPlateauSubtable[subrefPlateauIslandMexCount][tLZData[subrefLZIslandRef]] or 0) + tLZData[subrefLZMexCount]
                                break
                            end
                        end
                    end
                    --If still dont have an island ref then try searching around the midpoint until come across an island
                    if (tLZData[subrefLZIslandRef] or 0) == 0 then
                        local tAltMidpoint
                        for iAdjust = 1, 50 do
                            for iXMod = -1, 1, 1 do
                                for iZMod = -1, 1, 1 do
                                    tAltMidpoint = {tLZData[subrefLZMidpoint][1] + iAdjust * iXMod, 0, tLZData[subrefLZMidpoint][3] + iAdjust * iZMod}
                                    tAltMidpoint[2] = GetTerrainHeight(tAltMidpoint[1], tAltMidpoint[3])
                                    tLZData[subrefLZIslandRef] = NavUtils.GetLabel(refPathingTypeLand, tAltMidpoint)
                                    if (tLZData[subrefLZIslandRef] or 0) > 0 then
                                        break
                                    end
                                end
                                if (tLZData[subrefLZIslandRef] or 0) > 0 then break end
                            end
                            if (tLZData[subrefLZIslandRef] or 0) > 0 then break end
                        end
                        if (tLZData[subrefLZIslandRef] or 0) == 0 then tLZData[subrefLZIslandRef] = 0 end
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished searching nearby, tLZData[subrefLZIslandRef]='..(tLZData[subrefLZIslandRef] or 'nil')) end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished recording all islands in plateau '..iPlateau..'; Mex count by island='..repru(tPlateauSubtable[subrefPlateauIslandMexCount])..'; LZs by island='..repru(tPlateauSubtable[subrefPlateauIslandLandZones])) end


            for iLandZone, tLZData in tPlateauSubtable[subrefPlateauLandZones] do
                --Cycle through each island in this plateau and consider pathing for it
                if bDebugMessages == true then LOG(sFunctionRef..': Will record the pathing to every island from iLandZone='..iLandZone..'; ') end
                for iIsland, tLandZonesInIsland in tPlateauSubtable[subrefPlateauIslandLandZones] do
                    --Only consider islands with mexes (for performance reasons)
                    if tPlateauSubtable[subrefPlateauIslandMexCount][iIsland] > 0 and not(iIsland == tLZData[subrefLZIslandRef]) then
                        --Get the land zone in this island that is closest to our current land zone
                        local iClosestTravelDist = 100000
                        local iCurTravelDistance
                        local iClosestLZRef


                        for iEntry, iIslandLZ in tLandZonesInIsland do
                            iCurTravelDistance = M28Utilities.GetTravelDistanceBetweenPositions(tLZData[subrefLZMidpoint], tPlateauSubtable[subrefPlateauLandZones][iIslandLZ][subrefLZMidpoint], refPathingTypeHover)
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurTravelDistance='..repru(iCurTravelDistance)..'; iClosestTravelDist='..repru(iClosestTravelDist)) end
                            if iCurTravelDistance and iCurTravelDistance < iClosestTravelDist then
                                iClosestTravelDist = iCurTravelDistance
                                iClosestLZRef = iIslandLZ
                            end
                        end

                        --Get the position in the current table
                        local iPosition = 1
                        if not(tLZData[subrefLZPathingToOtherIslands]) then
                            tLZData[subrefLZPathingToOtherIslands] = {}
                            iPosition = 1
                        else
                            for iExistingIsland, tExistingSubtable in tLZData[subrefLZPathingToOtherIslands] do
                                if tExistingSubtable[subrefIslandTravelDist] < iClosestTravelDist then
                                    iPosition = iPosition + 1
                                else
                                    break
                                end
                            end
                        end
                        local tFullPath, iPathSize, iDistance = NavUtils.PathTo(refPathingTypeHover, tLZData[subrefLZMidpoint], tPlateauSubtable[subrefPlateauLandZones][iClosestLZRef][subrefLZMidpoint], nil)

                        --Reduce tFullPath to a table of land zones
                        if tFullPath then
                            local iPathingPlateau, iPathingLandZone
                            local tPathingLZConsidered = {}
                            local tPathingLZFromStartToTarget = {}


                            local iTravelDistance = 0
                            local tStart = {tLZData[subrefLZMidpoint][1], tLZData[subrefLZMidpoint][2], tLZData[subrefLZMidpoint][3]}
                            local tEnd = {tPlateauSubtable[subrefPlateauLandZones][iClosestLZRef][subrefLZMidpoint][1], tPlateauSubtable[subrefPlateauLandZones][iClosestLZRef][subrefLZMidpoint][2], tPlateauSubtable[subrefPlateauLandZones][iClosestLZRef][subrefLZMidpoint][3]}
                            tFullPath[0] = tStart
                            tFullPath[iPathSize + 1] = tEnd
                            for iPath = 1, iPathSize + 1 do
                                iTravelDistance = iTravelDistance + VDist2(tFullPath[iPath - 1][1], tFullPath[iPath - 1][3], tFullPath[iPath][1], tFullPath[iPath][3])
                                iPathingPlateau, iPathingLandZone = GetPlateauAndLandZoneReferenceFromPosition(tFullPath[iPath])
                                if iPathingLandZone > 0 then
                                    if not(tPathingLZConsidered[iPathingLandZone]) and not(iLandZone == iPathingLandZone) then
                                        tPathingLZConsidered[iPathingLandZone] = true
                                        table.insert(tPathingLZFromStartToTarget, iPathingLandZone)
                                    end
                                end
                            end
                            if not(tPathingLZConsidered[iClosestLZRef]) then
                                table.insert(tPathingLZFromStartToTarget, iPathingLandZone)
                                tPathingLZConsidered[iClosestLZRef] = true
                            end
                            table.insert(tLZData[subrefLZPathingToOtherIslands], iPosition, {[subrefIslandNumber] = iIsland, [subrefIslandClosestLZRef] = iClosestLZRef, [subrefLZTravelDist] = iClosestTravelDist, [subrefIslandLZPath] = { } })
                            --Add in the LZ path
                            for iEntry, iLZ in tPathingLZFromStartToTarget do
                                table.insert(tLZData[subrefLZPathingToOtherIslands][iPosition][subrefIslandLZPath], iLZ)
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Plateau '..iPlateau..': Finished recording pathing to get from iLandZone='..iLandZone..' to iClosestLZRef='..(iClosestLZRef or 'nil')..' in island '..iIsland..'; tLZData[subrefLZPathingToOtherIslands]='..repru(tLZData[subrefLZPathingToOtherIslands])) end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished recording for iPlateau='..iPlateau) end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param tPosition table
---@param bReturnSufaceHeightInstead boolean
---@param iOptionalAmountToBeUnderwatner number
---@return boolean
function IsUnderwater(tPosition, bReturnSurfaceHeightInstead, iOptionalAmountToBeUnderwater)
    --Returns true if tPosition underwater, otherwise returns false
    --bReturnSurfaceHeightInstead:: Return the actual height at which underwater, instead of true/false
    if bReturnSurfaceHeightInstead then return iMapWaterHeight
    else
        --LOG('IsUnderwater: tPosition='..repru(tPosition))
        if M28Utilities.IsTableEmpty(tPosition) then
            M28Utilities.ErrorHandler('tPosition is empty')
        else
            if iMapWaterHeight > tPosition[2] + (iOptionalAmountToBeUnderwater or 0) then
                --Check we're not just under an arch but are actually underwater
                if not(GetTerrainHeight(tPosition[1], tPosition[3]) == iMapWaterHeight) then
                    return true
                end
            end
        end
        return false
    end
end

local function GetMapWaterHeight()
    --Updates iMapWaterHeight to the water height on the map (if the map has water)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetMapWaterHeight'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --rMapPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2} - Set at start of the game, use instead of the scenarioinfo method
    local iWaterCount = 0
    local iWaterLevel = 10000
    local iCurTerrainHeight = 10000
    local iInterval = 1

    --Cycle through the map in iInterval sizes, until we come to a point where the surface height exceeds the terrain height, which suggests it is water:
    for iX = rMapPlayableArea[1] + iInterval, rMapPlayableArea[3], iInterval do
        for iZ = rMapPlayableArea[2] + iInterval, rMapPlayableArea[4], iInterval do
            iCurTerrainHeight =  GetTerrainHeight(iX, iZ)
            if GetSurfaceHeight(iX, iZ) > GetTerrainHeight(iX, iZ) then
                iWaterCount = iWaterCount + 1
                iWaterLevel = math.min(iWaterLevel, GetSurfaceHeight(iX, iZ))
                if bDebugMessages == true then LOG(sFunctionRef..': Found water at position X-Z='..iX..'-'..iZ..'; Surface height='..GetSurfaceHeight(iX, iZ)..'; Terrain height='..GetTerrainHeight(iX, iZ)) end
                if iWaterCount >= 3 then
                    break
                end
            else
                --Backup for maps like theta passage arch - have commented out as running on theta passage with interval of 1 it never triggers a water count in the first place, but could remove comments if do come across this issue
                --if bDebugMessages == true and iWaterCount > 0 and GetTerrainHeight(iX, iZ) < iWaterLevel and iWaterLevel < 10000 then LOG(sFunctionRef..': Have suspected arch previously so will adjust water level to terrain height='..GetTerrainHeight(iX, iZ)..'; for iX-Z='..iX..'-'..iZ..'; prev iWaterLevel='..iWaterLevel) end
                --iWaterLevel = math.min(iWaterLevel, GetTerrainHeight(iX, iZ))
            end
        end
        if iWaterCount >= 3 then break end
    end
    if iWaterCount == 0 then iMapWaterHeight = 0
    else
        iMapWaterHeight = iWaterLevel
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iWaterCount='..iWaterCount..'; iMapWaterHeight='..iMapWaterHeight) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetReclaimablesResourceValue(tReclaimables, bAlsoReturnLargestReclaimPosition, iIgnoreReclaimIfNotMoreThanThis, bAlsoReturnAmountOfHighestIndividualReclaim, bEnergyNotMass)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetReclaimablesResourceValue'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bAlsoReturnLargestReclaimPosition == nil then bAlsoReturnLargestReclaimPosition = false end
    if iIgnoreReclaimIfNotMoreThanThis == nil then iIgnoreReclaimIfNotMoreThanThis = 0 end
    if iIgnoreReclaimIfNotMoreThanThis < 0 then iIgnoreReclaimIfNotMoreThanThis = 0 end

    local sResourceRef = 'MaxMassReclaim'
    if bEnergyNotMass then sResourceRef = 'MaxEnergyReclaim' end

    local tWreckPos = {}
    local iTotalResourceValue = 0
    local iLargestCurReclaim = 0
    local tReclaimPos = {}
    if tReclaimables and table.getn( tReclaimables ) > 0 then
        for _, v in tReclaimables do
            tWreckPos = v.CachePosition
            if tWreckPos[1] then
                if v[sResourceRef] > iIgnoreReclaimIfNotMoreThanThis then
                    if not(v:BeenDestroyed()) then
                        iTotalResourceValue = iTotalResourceValue + v[sResourceRef]
                        if bAlsoReturnLargestReclaimPosition and v.MaxMassReclaim > iLargestCurReclaim then
                            iLargestCurReclaim = v.MaxMassReclaim
                            tReclaimPos = {tWreckPos[1], tWreckPos[2], tWreckPos[3]}
                        end
                    end
                end
            else
                if not(v.MaxMassReclaim == nil) then
                    if v.MaxMassReclaim > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Warning - have ignored wreck location despite it having a mass reclaim value') end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bAlsoReturnLargestReclaimPosition then
        if bAlsoReturnAmountOfHighestIndividualReclaim then return iTotalResourceValue, tReclaimPos, iLargestCurReclaim
        else return iTotalResourceValue, tReclaimPos end
    else
        if bAlsoReturnAmountOfHighestIndividualReclaim then return iTotalResourceValue, iLargestCurReclaim
        else return iTotalResourceValue end
    end
end

function GetReclaimInRectangle(iReturnType, rRectangleToSearch, bForceDebug)
    --iReturnType: 1 = true/false; 2 = number of wrecks; 3 = total mass, 4 = valid wrecks, 5 = energy
    local sFunctionRef = 'GetReclaimInRectangle'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local bDebugMessages = bForceDebug if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    --NOTE: Best to try and debug via forcedebug, as dont want to run for everything due to how intensive the log of reclaim is
    --Have also commented out one of the logs to help with performance

    local tReclaimables = GetReclaimablesInRect(rRectangleToSearch)
    local iWreckCount = 0
    local iTotalResourceValue
    local bHaveReclaim = false
    local tValidWrecks = {}
    if M28Utilities.IsTableEmpty(tReclaimables) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': iReturnType='..iReturnType..'; rRectangleToSearch='..repru(rRectangleToSearch)) end
        if iReturnType == 3 or iReturnType == 5 then
            if iReturnType == 3 then iTotalResourceValue = GetReclaimablesResourceValue(tReclaimables, false, 0, false, false)
            else iTotalResourceValue = GetReclaimablesResourceValue(tReclaimables, false, 0, false, true)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iTotalResourceValue='..iTotalResourceValue) end
        else
            for _, v in tReclaimables do
                --if bDebugMessages == true then LOG(sFunctionRef..': _='.._..'; repr of reclaimable='..repru(tReclaimables)) end
                local WreckPos = v.CachePosition
                if not(WreckPos[1]==nil) then
                    if bDebugMessages == true then LOG(sFunctionRef..': _='.._..'; Cur mass value='..(v.MaxMassReclaim or 0)..'; Energy value='..(v.MaxEnergyReclaim or 0)) end
                    if (v.MaxMassReclaim or 0) > 0 or (v.MaxEnergyReclaim or 0) > 0 then
                        if bDebugMessages == true then LOG('Been destroyed='..tostring(v:BeenDestroyed())) end
                        if not(v:BeenDestroyed()) then
                            iWreckCount = iWreckCount + 1
                            bHaveReclaim = true
                            if iReturnType == 1 then break
                            elseif iReturnType == 4 then tValidWrecks[iWreckCount] = v end
                        end
                    end
                end
            end
        end
    elseif bDebugMessages == true then LOG(sFunctionRef..': tReclaimables is empty')
    end
    if bDebugMessages == true then LOG(sFunctionRef..': rRectangleToSearch='..repru(rRectangleToSearch)..'; bHaveReclaim='..tostring(bHaveReclaim)..'; iWreckCount='..iWreckCount) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if iReturnType == 1 then return bHaveReclaim
    elseif iReturnType == 2 then return iWreckCount
    elseif iReturnType == 3 or iReturnType == 5 then return iTotalResourceValue
    elseif iReturnType == 4 then return tValidWrecks
    else M28Utilities.ErrorHandler('Invalid return type')
    end
end

function SetWhetherCanPathToEnemy(aiBrain)
    --Set flag for whether AI can path to enemy base
    --Also updates other values that are based on the nearest enemy

    local sFunctionRef = 'SetWhetherCanPathToEnemy'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if not(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated]) then
        local tEnemyStartPosition = GetPrimaryEnemyBaseLocation(aiBrain)
        local tOurBase = PlayerStartPoints[aiBrain:GetArmyIndex()]

        if NavUtils.GetLabel(refPathingTypeLand, tOurBase) == NavUtils.GetLabel(refPathingTypeLand, tEnemyStartPosition) and not(IsUnderwater({tOurBase[1], GetTerrainHeight(tOurBase[1], tOurBase[3]), tOurBase[3]})) then
            aiBrain[refbCanPathToEnemyBaseWithLand] = true
        else aiBrain[refbCanPathToEnemyBaseWithLand] = false
        end

        if NavUtils.GetLabel(refPathingTypeHover, tOurBase) == NavUtils.GetLabel(refPathingTypeHover, tEnemyStartPosition) then
            aiBrain[refbCanPathToEnemyBaseWithAmphibious] = true
        else aiBrain[refbCanPathToEnemyBaseWithAmphibious] = false end

        aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] = M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[aiBrain:GetArmyIndex()], tEnemyStartPosition)
        M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiMaxScoutRadius] = math.max(1500, (M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiMaxScoutRadius] or 1500), aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 1.5)

        --Record mitpoint between base (makes it easier to calc mod distance
        aiBrain[reftMidpointToPrimaryEnemyBase] = M28Utilities.MoveInDirection(PlayerStartPoints[aiBrain:GetArmyIndex()], M28Utilities.GetAngleFromAToB(PlayerStartPoints[aiBrain:GetArmyIndex()], tEnemyStartPosition), aiBrain[M28Overseer.refiDistanceToNearestEnemyBase], false)
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetOppositeLocation(tLocation)
    --Returns a point on the opposite side of the map to tLocation
    local tOpposite = {rMapPlayableArea[3] - tLocation[1] + rMapPlayableArea[1], 0, rMapPlayableArea[4] - tLocation[3] + rMapPlayableArea[2]}
    tOpposite[2] = GetSurfaceHeight(tOpposite[1], tOpposite[3])
    return tOpposite
end

function UpdateNewPrimaryBaseLocation(aiBrain)
    --Updates reftPrimaryEnemyBaseLocation to the nearest enemy start position (unless there are no structures there in which case it searches for a better start position)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateNewPrimaryBaseLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --LOG(sFunctionRef..': aiBrain='..aiBrain:GetArmyIndex()..'; Start position='..(aiBrain:GetArmyIndex() or 'nil'))
    if bDebugMessages == true then LOG(sFunctionRef..': About to get new primary base location for brain '..aiBrain.Nickname..' unless it is civilian or defeated. IsCivilian='..tostring(M28Conditions.IsCivilianBrain(aiBrain))..'; .M28IsDefeated='..tostring((aiBrain.M28IsDefeated or false))) end
    if not(M28Conditions.IsCivilianBrain(aiBrain)) and not(aiBrain.M28IsDefeated) and not(aiBrain:IsDefeated()) then
        local tPrevPosition
        if aiBrain[reftPrimaryEnemyBaseLocation] then tPrevPosition = {aiBrain[reftPrimaryEnemyBaseLocation][1], aiBrain[reftPrimaryEnemyBaseLocation][2], aiBrain[reftPrimaryEnemyBaseLocation][3]} end
        if bDebugMessages == true then LOG(sFunctionRef..': Team='..(aiBrain.M28Team or 'nil')..'; Are all enemies defated for this team='..tostring(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated] or false)) end
        if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated] then
            local tFriendlyBrainStartPoints = {}
            local iFriendlyBrainCount = 0
            tFriendlyBrainStartPoints[iFriendlyBrainCount] = {PlayerStartPoints[aiBrain:GetArmyIndex()][1], PlayerStartPoints[aiBrain:GetArmyIndex()][2], PlayerStartPoints[aiBrain:GetArmyIndex()][3]}
            if bDebugMessages == true then LOG(sFunctionRef..': Have no enemies, so will get average of friendly brain start points provided not the centre of the map. Is table of friendly ally active brains empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyActiveBrains]))) end

            for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyActiveBrains] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering ally brain index='..oBrain:GetArmyIndex()..'; Nickname='..(oBrain.Nickname or 'nil')..'; Start point='..repru((PlayerStartPoints[oBrain:GetArmyIndex()] or {'nil'}))) end
                --if not(oBrain == aiBrain) then
                iFriendlyBrainCount = iFriendlyBrainCount + 1
                tFriendlyBrainStartPoints[iFriendlyBrainCount] = {PlayerStartPoints[oBrain:GetArmyIndex()][1], PlayerStartPoints[oBrain:GetArmyIndex()][2], PlayerStartPoints[oBrain:GetArmyIndex()][3]}
                --end
            end
            local tAverageTeamPosition
            if iFriendlyBrainCount == 1 then tAverageTeamPosition = tFriendlyBrainStartPoints[iFriendlyBrainCount]
            else tAverageTeamPosition = M28Utilities.GetAverageOfLocations(tFriendlyBrainStartPoints)
            end

            if bDebugMessages == true then LOG(sFunctionRef..': iFriendlyBrainCount='..iFriendlyBrainCount..'; Friendly brain start points='..repru((tFriendlyBrainStartPoints or {'nil'}))..'; tAverageTeamPosition='..repru(tAverageTeamPosition)..'; rMapPlayableArea='..repru(rMapPlayableArea)) end

            if M28Utilities.GetDistanceBetweenPositions(tAverageTeamPosition, {rMapPlayableArea[1] + (rMapPlayableArea[3] - rMapPlayableArea[1])*0.5, 0, rMapPlayableArea[2] + (rMapPlayableArea[4] - rMapPlayableArea[2])*0.5}) <= 50 then
                --Average is really close to middle of the map, so just  assume enemy base is in the opposite direction to us
                aiBrain[reftPrimaryEnemyBaseLocation] = GetOppositeLocation(PlayerStartPoints[aiBrain:GetArmyIndex()])
            else
                --Average isnt really close to mid of map, so assume enemy base is in opposite directino to average
                aiBrain[reftPrimaryEnemyBaseLocation] = GetOppositeLocation(tAverageTeamPosition)
            end
        else --Still have enemies that are alive
            local tEnemyBase = PlayerStartPoints[M28Logic.GetNearestEnemyIndex(aiBrain)]
            if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy index='..(M28Logic.GetNearestEnemyIndex(aiBrain) or 'nil')..'; tEnemyBase='..repru(tEnemyBase)) end
            --Is this different from the current location we are using?
            if not(tEnemyBase[1] == aiBrain[reftPrimaryEnemyBaseLocation][1]) or not(tEnemyBase[3] == aiBrain[reftPrimaryEnemyBaseLocation][3]) then
                aiBrain[refiLastTimeCheckedEnemyBaseLocation] = GetGameTimeSeconds()
                aiBrain[reftPrimaryEnemyBaseLocation] = {tEnemyBase[1], tEnemyBase[2], tEnemyBase[3]}
            end
            --Below is from M27 - not sure if still need it; it is also based in part on how long since we last scouted the location with an air scout and whether there were any enemy buildings there, but land zone logic should give an alternative way of checking if any buildings there
            --[[if aiBrain.M28AI then
            --Consider if we want to check for alternative locations to the actual enemy start:
            --Have we recently checked for a base location; --Do we have at least T2 (as a basic guide that this isn't the start of the game), has at least 3m of gametime elapsed, and have scouted the enemy base location recently, and have built at least 1 air scout this game?
            if GetGameTimeSeconds() - (aiBrain[refiLastTimeCheckedEnemyBaseLocation] or -1000) >= 10 and GetGameTimeSeconds() >= 180 then
                --(below includes alternative condition just in case there are strange unit restrictions)
                if M28Utilities.IsTableEmpty(ScenarioInfo.Options.RestrictedCategories) or (GetGameTimeSeconds() >= 600 or (aiBrain[M28Economy.refiOurHighestFactoryTechLevel] >= 2 and not(M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryAirScout) < 2))) then
                    if not(IsEnemyStartPositionValid(aiBrain, tEnemyBase)) then
                        aiBrain[reftPrimaryEnemyBaseLocation] = nil
                        local iNearestEnemyBase = 10000
                        local tNearestEnemyBase
                        --Cycle through every valid enemy brain and pick the nearest one, if there is one
                        if bDebugMessages == true then LOG(sFunctionRef..': Will cycle through each brain to identify nearest enemy base') end
                        for iCurBrain, brain in ArmyBrains do
                            if not(brain == aiBrain) and not(M28Logic.IsCivilianBrain(brain)) and IsEnemy(brain:GetArmyIndex(), aiBrain:GetArmyIndex()) and (not(brain:IsDefeated() and not(brain.M28IsDefeated)) or not(ScenarioInfo.Options.Victory == "demoralization")) then
                                if M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[brain:GetArmyIndex()], PlayerStartPoints[aiBrain:GetArmyIndex()]) < iNearestEnemyBase then
                                    if IsEnemyStartPositionValid(aiBrain, PlayerStartPoints[brain:GetArmyIndex()]) then
                                        iNearestEnemyBase = M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[brain:GetArmyIndex()], PlayerStartPoints[aiBrain:GetArmyIndex()])
                                        tNearestEnemyBase = {PlayerStartPoints[brain:GetArmyIndex()][1], PlayerStartPoints[brain:GetArmyIndex()][2], PlayerStartPoints[brain:GetArmyIndex()][3]}
                                    end
                                end
                            end
                        end
                        aiBrain[reftPrimaryEnemyBaseLocation] = tNearestEnemyBase
                        if not(aiBrain[reftPrimaryEnemyBaseLocation]) then
                            local tiCategoriesToConsider = {M28UnitInfo.refCategoryExperimentalStructure + M28UnitInfo.refCategorySML + M28UnitInfo.refCategoryFixedT3Arti, M28UnitInfo.refCategoryT3Mex, M28UnitInfo.refCategoryT2Mex, M28UnitInfo.refCategoryAirFactory + M28UnitInfo.refCategoryLandFactory}
                            local tEnemyUnits
                            tNearestEnemyBase = nil
                            for iRef, iCategory in tiCategoriesToConsider do
                                tEnemyUnits = aiBrain:GetUnitsAroundPoint(iCategory, PlayerStartPoints[aiBrain:GetArmyIndex()], 10000, 'Enemy')
                                if M28Utilities.IsTableEmpty(tEnemyUnits) == false then
                                    tNearestEnemyBase = M28Utilities.GetNearestUnit(tEnemyUnits, PlayerStartPoints[aiBrain:GetArmyIndex()], aiBrain, nil, nil):GetPosition()
                                    break
                                end
                            end
                            if tNearestEnemyBase then aiBrain[reftPrimaryEnemyBaseLocation] = tNearestEnemyBase
                            else
                                --Cant find anywhere so just pick the furthest away enemy start location
                                iNearestEnemyBase = 10000
                                for iCurBrain, brain in ArmyBrains do
                                    if not(brain == aiBrain) and not(M28Logic.IsCivilianBrain(brain)) and IsEnemy(brain:GetArmyIndex(), aiBrain:GetArmyIndex()) then
                                        if M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[brain:GetArmyIndex()], PlayerStartPoints[aiBrain:GetArmyIndex()]) < iNearestEnemyBase then
                                            iNearestEnemyBase = M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[brain:GetArmyIndex()], PlayerStartPoints[aiBrain:GetArmyIndex()])
                                            tNearestEnemyBase = {PlayerStartPoints[brain:GetArmyIndex()][1], PlayerStartPoints[brain:GetArmyIndex()][2], PlayerStartPoints[brain:GetArmyIndex()][3]}
                                        end
                                    end
                                end
                                aiBrain[reftPrimaryEnemyBaseLocation] = tNearestEnemyBase
                            end
                        end
                    end
                end
            end
        end--]]
        end
        --Have we changed position and are dealing with an M28 brain?
        if aiBrain.M28AI and not(tPrevPosition[1] == aiBrain[reftPrimaryEnemyBaseLocation][1] and tPrevPosition[3] == aiBrain[reftPrimaryEnemyBaseLocation][3]) then
            --We have changed position so update any global variables that reference this
            if bDebugMessages == true then LOG(sFunctionRef..': Will update whether we can path to enemy') end
            ForkThread(SetWhetherCanPathToEnemy, aiBrain)
        end

        aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] = M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[aiBrain:GetArmyIndex()], aiBrain[reftPrimaryEnemyBaseLocation])

    elseif bDebugMessages == true then LOG(sFunctionRef..': Dealing with a civilian brain')
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, primary enemy base location='..repru(aiBrain[reftPrimaryEnemyBaseLocation])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetPrimaryEnemyBaseLocation(aiBrain)
    --Returns a table {x,y,z} - usually this is the start position of the nearest enemy base.  However in certain cases it will be different
    --Used as the main location for the AI to evaluate things such as threats and make decisions; by default will be the nearest enemy start position

    --Done as a function so easier to adjust in the future if decide we want to
    if not(aiBrain[reftPrimaryEnemyBaseLocation]) then UpdateNewPrimaryBaseLocation(aiBrain) end
    return aiBrain[reftPrimaryEnemyBaseLocation]
end

function AddLocationToPlateauExceptions(tLocation, iPlateau, iLandZone)
    local iX = math.floor(tLocation[1])
    local iZ = math.floor(tLocation[3])
    if not(tPathingPlateauAndLZOverride[iX]) then tPathingPlateauAndLZOverride[iX] = {} end
    tPathingPlateauAndLZOverride[iX][iZ] = {iPlateau, iLandZone}
end

function ClearTemporarySetupVariables()
    --Free up memory by clearing global variables used for map setup
    WaitTicks(10) --As basicp rotection in case any functions are still running
    tbTempConsideredLandPathingForLZ = {}
end

function CreateNewPond(iPond)
    tPondDetails[iPond] = {}
    tPondDetails[iPond][subreftiWaterSegmentXZ] = {}
    tPondDetails[iPond][subrefiSegmentCount] = 0

    tPondDetails[iPond][subrefPondMinX] = 100000
    tPondDetails[iPond][subrefPondMinZ] = 100000
    tPondDetails[iPond][subrefPondMaxX] = 0
    tPondDetails[iPond][subrefPondMaxZ] = 0
    tPondDetails[iPond][subrefiSegmentCount] = 0
    --tPondDetails[iPond][subrefPondNearbyBrains] = {}
    tPondDetails[iPond][subrefPondMidpoint] = {}
    tPondDetails[iPond][subrefPondMexInfo] = {}
end

function RecordNavalSegment(iPond, iBaseSegmentX, iBaseSegmentZ, tSegmentPosition)
    --Called from logic for land creation that cycles through every segment on the map
    if not(tPondDetails[iPond]) then
        CreateNewPond(iPond)
    end
    table.insert(tPondDetails[iPond][subreftiWaterSegmentXZ], iBaseSegmentX, iBaseSegmentZ)
    if not(tPondBySegment[iBaseSegmentX]) then tPondBySegment[iBaseSegmentX] = {} end
    tPondBySegment[iBaseSegmentX][iBaseSegmentZ] = iPond
    iTotalSegmentsInPonds = iTotalSegmentsInPonds + 1
    tPondDetails[iPond][subrefiSegmentCount] = tPondDetails[iPond][subrefiSegmentCount] + 1

    tPondDetails[iPond][subrefPondMinX] = math.min(tPondDetails[iPond][subrefPondMinX], tSegmentPosition[1])
    tPondDetails[iPond][subrefPondMinZ] = math.min(tPondDetails[iPond][subrefPondMinZ], tSegmentPosition[3])
    tPondDetails[iPond][subrefPondMaxX] = math.max(tPondDetails[iPond][subrefPondMaxX], tSegmentPosition[1])
    tPondDetails[iPond][subrefPondMaxZ] = math.max(tPondDetails[iPond][subrefPondMaxZ], tSegmentPosition[3])

end

function RecordPondDetails()
    --Call after recording all pathfinding for the map, so after we have recorded all naval segments against ponds
    --intended to record key information on any ponds of interest, in particular mexes that can be hit from the pond (and the range required)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RecordPondDetails'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tbUnderwaterGroup = {}
    local tSegmentPosition

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code. Does map have water? Water height(0 means no water)='..iMapWaterHeight) end

    if iMapWaterHeight > 0 then
        --Record the size and dimensions of every pond
        local iMaxMexDist = 200 --range of aeon missile ship
        local iPondMexCount
        local iCurMexDist
        local tiDistToTry = { 24, 40, 56, 88, 120, 145, iMaxMexDist }
        local bInRange
        local iAngleInterval = 45
        local tPossibleWaterPosition
        local iPrevDist
        local tShotStartPosition
        local tShotEndPosition
        local iAOE

        --Want a brain in case we end up using the alternative 'line is blocked' built in functionality
        local aiBrain
        for iBrain, oBrain in ArmyBrains do
            if oBrain.M28AI then
                aiBrain = oBrain
                break
            end
        end
        if not (aiBrain) then
            for iBrain, oBrain in ArmyBrains do
                aiBrain = oBrain
                break
            end
        end

        for iPond, tPondSubtable in tPondDetails do
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Considering pond group ' .. iPond .. '; Pond size=' .. (tPondSubtable[subrefiSegmentCount] or 'nil'))
            end
            if (tPondSubtable[subrefiSegmentCount] or 0) >= iMinPondSize then
                --Pond is large enough for us to consider tracking; record information of interest for the pond:
                iPondMexCount = 0
                tPondSubtable[subrefPondMidpoint] = { (tPondDetails[iPond][subrefPondMinX] + tPondDetails[iPond][subrefPondMaxX]) * 0.5, iMapWaterHeight, (tPondDetails[iPond][subrefPondMinZ] + tPondDetails[iPond][subrefPondMaxZ]) * 0.5 }
                if bDebugMessages == true then LOG(sFunctionRef .. ': Recording pond, will check how many mexes are nearby. Pond midpoint=' .. repru(tPondSubtable[subrefPondMidpoint]) .. '; Pond min X-Z=' .. tPondDetails[iPond][subrefPondMinX] .. '-' .. tPondDetails[iPond][subrefPondMinZ] .. '; Max X-Z=' .. tPondDetails[iPond][subrefPondMaxX] .. '-' .. tPondDetails[iPond][subrefPondMaxZ]) end

                --Details of all mexes near enough to the pond to be of interest
                for iMex, tMex in tMassPoints do
                    bInRange = false

                    if tMex[1] >= tPondSubtable[subrefPondMinX] - iMaxMexDist and tMex[1] <= tPondSubtable[subrefPondMaxX] + iMaxMexDist and tMex[3] >= tPondSubtable[subrefPondMinZ] - iMaxMexDist and tMex[3] <= tPondSubtable[subrefPondMaxZ] + iMaxMexDist then
                        --See how far away the water is
                        for iEntry, iDist in tiDistToTry do
                            for iAngleAdjust = iAngleInterval, 360, iAngleInterval do
                                tPossibleWaterPosition = M28Utilities.MoveInDirection(tMex, iAngleAdjust, iDist, true, true) --Gets terrainheight rather than surface height
                                if IsUnderwater(tPossibleWaterPosition, false, iMinWaterDepth) then
                                    --Have a match, record the mex details:
                                    bInRange = true
                                    iCurMexDist = iDist

                                    --Record initial mex details:
                                    iPondMexCount = iPondMexCount + 1
                                    tPondSubtable[subrefPondMexInfo][iPondMexCount] = {}
                                    tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexLocation] = { tMex[1], tMex[2], tMex[3] }

                                    --Do we expect to be able to hit the mex from here? a UEF Frigate y height is 1.1, while a t1 mex is 1.4; cant be bothered to check height of weapon and mex bone, and will vary based on how far away we are as well
                                    tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                                    tShotEndPosition = { tMex[1], tMex[2] + 1.1, tMex[3] }

                                    iAOE = 0
                                    if iCurMexDist >= 30 then
                                        iAOE = 1
                                    end --most destroyers have an aoe attack (except sera)

                                    if M28Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, iAOE) then
                                        tShotStartPosition[2] = tShotStartPosition[2] + 8
                                        tShotEndPosition[2] = tShotEndPosition[2] + 8
                                        if M28Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, 1) then
                                            --cant hit with df or indirect
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] = 10000
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = 10000
                                        else
                                            --Can hit with indirect but not DF, so consider whether if we move further back we can then hit
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] = iCurMexDist
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}

                                            --Find the point at which DF can hit, if any, in intervals of 5, assuming at max range we can hit
                                            local iMaxDistAdjust = math.max(5, math.min(100, math.floor((150 - iCurMexDist) / 5) * 5))
                                            tPossibleWaterPosition = M28Utilities.MoveInDirection(tMex, iAngleAdjust, iDist + iMaxDistAdjust, true, true)
                                            if IsUnderwater(tPossibleWaterPosition, false, iMinWaterDepth) then
                                                tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                                                if M28Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, 1) then
                                                    --Assume wont find any match
                                                    tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = 10000
                                                else
                                                    tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = iDist + iMaxDistAdjust
                                                    --Refine the distance by moving closer
                                                    for iDFDistAdjust = 5, math.max(5, math.min(100, math.floor((150 - iCurMexDist) / 5) * 5)), 5 do
                                                        tPossibleWaterPosition = M28Utilities.MoveInDirection(tMex, iAngleAdjust, iDist + iDFDistAdjust, true, true)
                                                        tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                                                        if not (M28Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, 1)) then
                                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = iDist + iDFDistAdjust
                                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}
                                                            break
                                                        end
                                                    end
                                                end
                                            else
                                                --Assume wont find any match as if move really far back we are not on water
                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = 10000
                                            end
                                        end

                                        if bDebugMessages == true and tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] then
                                            LOG(sFunctionRef .. ' Drawing start in white and end in orangy pink')
                                            M28Utilities.DrawLocation({ tShotStartPosition[1], tShotStartPosition[2] - 8, tShotStartPosition[3] }, 7, 100, nil)
                                            M28Utilities.DrawLocation({ tShotEndPosition[1], tShotEndPosition[2] - 8, tShotEndPosition[3] }, 8, 100, nil)
                                        end
                                    else
                                        --DF can hit from cur position so assume indirect can as well
                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = iCurMexDist
                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] = iCurMexDist
                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}
                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}
                                    end

                                    --Refine the distance - see if can get any closer
                                    if iEntry == 1 then
                                        iPrevDist = 0
                                    else
                                        iPrevDist = tiDistToTry[iEntry - 1]
                                    end
                                    for iShortDist = iPrevDist + 1, iDist - 1, 1 do
                                        tPossibleWaterPosition = M28Utilities.MoveInDirection(tMex, iAngleAdjust, iDist, true)
                                        if IsUnderwater(tPossibleWaterPosition, false, iMinWaterDepth) then
                                            iCurMexDist = iShortDist
                                            break
                                        end
                                    end

                                    tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDistance] = iCurMexDist

                                    if bDebugMessages == true then LOG(sFunctionRef .. ': Finished recording mex in range for pond ' .. iPond .. '; iPondMexCount=' .. iPondMexCount .. '; full mex table of info=' .. repru(tPondSubtable[subrefPondMexInfo][iPondMexCount])) end
                                    break
                                end
                            end
                            if bInRange then
                                break
                            end
                        end
                    end
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Considered Mex ' .. repru(tMex) .. '; bInRange=' .. tostring(bInRange))
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording all ponds, repr='..reprs(tPondDetails)) end
    end
    bHaveRecordedPonds = true
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordPondToExpandTo(aiBrain)
    --Calculates which pond we think is most important to hold; assumes we have already recorded all segments and ponds (but havent yet setup water zones)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RecordPondToExpandTo'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    bHaveConsideredPreferredPondForM28AI = true
    if bDebugMessages == true then LOG(sFunctionRef..': Starting RecordPondToExpandTo at '..GetGameTimeSeconds()..', Is table of pond details empty='..tostring(M28Utilities.IsTableEmpty(tPondDetails))..'; bHaveRecordedPonds='..tostring(bHaveRecordedPonds)) end
    local iWaitCount = 0
    while not(bHaveRecordedPonds) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        iWaitCount = iWaitCount + 1
        if iWaitCount >= 20 then break end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting, time='..GetGameTimeSeconds()..'; Is table of pond details empty='..tostring(M28Utilities.IsTableEmpty(tPondDetails))..'; bHaveRecordedPonds='..tostring(bHaveRecordedPonds)) end
    if M28Utilities.IsTableEmpty(tPondDetails) == false then
        local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
        aiBrain[M28Navy.reftiPondThreatToUs] = {}
        aiBrain[M28Navy.reftiPondValueToUs] = {}
        local iCurPondValue
        local iCurPondDefensiveValue --Value of mexes that are threatened by enemy if they get navy
        local iBestPondValue = 0
        local iBestPondRef

        local iDistanceThreshold = math.max(138, math.min(180, aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.35))
        if not(aiBrain[refbCanPathToEnemyBaseWithLand]) then iDistanceThreshold = iDistanceThreshold + 50 end

        local iFrigateRange = 28
        local iDestroyerRange = 60
        local iBattleshipRange = 128
        local iMissileShipRange = 150
        local iFrigateValue = 1
        local iDestroyerValue = 0.8
        local iBattleshipValue = 0.45
        local iMissileShipValue = 0.6

        local iEnemyDestroyerRange = 60
        local iEnemyBattleshipRange = 128
        local iEnemyMissileShipRange = 150


        if aiBrain:GetFactionIndex() == M28UnitInfo.refFactionUEF then
            iBattleshipRange = 150
        elseif aiBrain:GetFactionIndex() == M28UnitInfo.refFactionCybran then
            iDestroyerRange = 80
            iMissileShipRange = 0
        elseif aiBrain:GetFactionIndex() == M28UnitInfo.refFactionAeon then
            iMissileShipRange = 200
            iMissileShipValue = iBattleshipValue
            --Seraphim - no change to default
        end

        local iEnemyBrainIndex = M28Logic.GetNearestEnemyIndex(aiBrain)
        if iEnemyBrainIndex == M28UnitInfo.refFactionUEF then
            iEnemyBattleshipRange = 150
        elseif iEnemyBrainIndex == M28UnitInfo.refFactionCybran then
            iEnemyDestroyerRange = 80
            iEnemyMissileShipRange = 0
        elseif iEnemyBrainIndex == M28UnitInfo.refFactionAeon then
            iEnemyMissileShipRange = 200
        end

        local iMinModDistanceWanted = math.max(155, aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.4)
        if bDebugMessages == true then LOG(sFunctionRef..': aiBrain='..aiBrain.Nickname..'; Start of logic to consider the best pond. iMinModDistanceWanted='..iMinModDistanceWanted..'; Dist to enemy base='..(aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] or 'nil')) end
        local iMidModDistance = aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.5
        local iBelowMidFactor = 0.3 --Reudces value of mex that is closer to our base than enemy base to this %, assuming it is above the iMinModDistanceWanted
        local iCurMexValue
        local iCurMexDefensiveValue
        local iCurModDistance
        local iDefensiveModDistanceMaxValue = math.max(120, math.min(300, aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.4))

        local iPathingGroupWanted = NavUtils.GetLabel(refPathingTypeHover, PlayerStartPoints[aiBrain:GetArmyIndex()])

        for iCurPondRef, tPondSubtable in tPondDetails do
            aiBrain[M28Navy.reftiPondValueToUs][iCurPondRef] = 0
            aiBrain[M28Navy.reftiPondThreatToUs][iCurPondRef] = 0
            if M28Utilities.IsTableEmpty(tPondSubtable) == false then
                iCurPondValue = 0
                iCurPondDefensiveValue = 0
                if bDebugMessages == true then LOG(sFunctionRef..': iCurPondRef='..iCurPondRef..'; Repru of subtable='..repru(tPondSubtable)..'; ai brain start point='..repru(PlayerStartPoints[aiBrain:GetArmyIndex()])) end

                --Is the pond within 175 of our start position?  First see if X is within distance threshold:
                if math.abs(tPondSubtable[subrefPondMinX] - PlayerStartPoints[aiBrain:GetArmyIndex()][1]) <= iDistanceThreshold or math.abs(PlayerStartPoints[aiBrain:GetArmyIndex()][1] - tPondSubtable[subrefPondMaxX]) <= iDistanceThreshold or (PlayerStartPoints[aiBrain:GetArmyIndex()][1] >= tPondSubtable[subrefPondMinX] and PlayerStartPoints[aiBrain:GetArmyIndex()][1] <= tPondSubtable[subrefPondMaxX]) then
                    --X is in range, is Z?
                    if math.abs(tPondSubtable[subrefPondMinZ] - PlayerStartPoints[aiBrain:GetArmyIndex()][3]) <= iDistanceThreshold or math.abs(PlayerStartPoints[aiBrain:GetArmyIndex()][3] - tPondSubtable[subrefPondMaxZ]) <= iDistanceThreshold or (PlayerStartPoints[aiBrain:GetArmyIndex()][3] >= tPondSubtable[subrefPondMinZ] and PlayerStartPoints[aiBrain:GetArmyIndex()][3] <= tPondSubtable[subrefPondMaxZ]) then
                        --X and Z are in range


                        for iMex, tMexInfo in tPondSubtable[subrefPondMexInfo] do
                            iCurMexValue = 0
                            iCurMexDefensiveValue = 0
                            if tMexInfo[subrefMexDFDistance] <= iBattleshipRange or tMexInfo[subrefMexIndirectDistance] <= iMissileShipRange then
                                --Can reach this mex with a ship, so it will have at least some value
                                if tMexInfo[subrefMexDFDistance] <= iFrigateRange then iCurMexValue = iFrigateValue
                                elseif tMexInfo[subrefMexDFDistance] <= iDestroyerRange then iCurMexValue = iDestroyerValue
                                elseif tMexInfo[subrefMexIndirectDistance] <= iMissileShipRange then iCurMexValue = iMissileShipValue
                                else iCurMexValue = iBattleshipValue
                                end
                            end

                            --Adjust mex value based on distance
                            iCurModDistance = GetModDistanceFromStart(aiBrain, tMexInfo[subrefMexLocation])
                            if iCurMexValue > 0 then
                                if iCurModDistance <  iMinModDistanceWanted then iCurMexValue = 0
                                else
                                    if iCurModDistance < iMidModDistance then
                                        iCurMexValue = iCurMexValue * iBelowMidFactor
                                    end
                                end
                                iCurPondValue = iCurPondValue + iCurMexValue
                            end


                            --Get defensive value
                            if iCurModDistance <= iDefensiveModDistanceMaxValue then
                                if tMexInfo[subrefMexDFDistance] <= iEnemyBattleshipRange or tMexInfo[subrefMexIndirectDistance] <= iEnemyMissileShipRange then
                                    --Can reach this mex with a ship, so it will have at least some value
                                    if tMexInfo[subrefMexDFDistance] <= iFrigateRange then iCurMexDefensiveValue = iFrigateValue
                                    elseif tMexInfo[subrefMexDFDistance] <= iEnemyDestroyerRange then iCurMexDefensiveValue = iDestroyerValue
                                    elseif tMexInfo[subrefMexIndirectDistance] <= iEnemyMissileShipRange then iCurMexDefensiveValue = iMissileShipValue
                                    else iCurMexDefensiveValue = iBattleshipValue
                                    end
                                end
                                iCurPondDefensiveValue = iCurPondDefensiveValue + iCurMexDefensiveValue
                            end

                        end

                        --Increase vlaue if in part of pond likely to be near enemy base
                        local tEnemyBase = GetPrimaryEnemyBaseLocation(aiBrain)
                        local iEnemyBaseThreshold = math.max(iBattleshipRange, iMissileShipRange - 10)
                        if math.abs(tPondSubtable[subrefPondMinX] - tEnemyBase[1]) <= iEnemyBaseThreshold or math.abs(tEnemyBase[1] - tPondSubtable[subrefPondMaxX]) <= iEnemyBaseThreshold or (tEnemyBase[1] >= tPondSubtable[subrefPondMinX] and tEnemyBase[1] <= tPondSubtable[subrefPondMaxX]) then
                            --X is in range, is Z?
                            if math.abs(tPondSubtable[subrefPondMinZ] - tEnemyBase[3]) <= iEnemyBaseThreshold or math.abs(tEnemyBase[3] - tPondSubtable[subrefPondMaxZ]) <= iEnemyBaseThreshold or (tEnemyBase[3] >= tPondSubtable[subrefPondMinZ] and tEnemyBase[3] <= tPondSubtable[subrefPondMaxZ]) then
                                iCurPondValue = math.max(iCurPondValue * 1.2, iCurPondValue + 2)
                                if bDebugMessages == true then LOG(sFunctionRef..': Can probably hit enemy base with navy so increasing pond value by 20%') end
                            end
                        end


                        if bDebugMessages == true then LOG(sFunctionRef..': Have a pond that is in range of our start position, value based on mexes in range pre adjust='..iCurPondValue) end
                        --Do we have sufficient value to consider?
                        if iCurPondValue >= 4 or iCurPondDefensiveValue >= 4 then
                            if iCurPondValue <= 0 then iCurPondValue = 0.1 end --Pond has defensive value so greater than 0
                            --Adjust value based on how close the naval build location would be for this pond
                            if not(tPondSubtable[subrefBuildLocationByStartPosition]) then
                                tPondSubtable[subrefBuildLocationByStartPosition] = {}
                            end
                            local tNavalBuildArea = {}
                            local iAngleToCentre = M28Utilities.GetAngleFromAToB(PlayerStartPoints[aiBrain:GetArmyIndex()], tPondSubtable[subrefPondMidpoint])
                            local iDistInterval = 8
                            local iBuildingInterval = 4
                            local tPossibleLocationBase
                            local tPossibleBuildLocation
                            local bHaveValidLocation = false
                            if bDebugMessages == true then LOG(sFunctionRef..': About to search for location to build naval factory for iCurPondRef='..iCurPondRef..'; iDistInterval='..iDistInterval..'; Angle='..iAngleToCentre..'; Midpoint='..repru(tPondSubtable[subrefPondMidpoint])..'; Start position='..repru(PlayerStartPoints[aiBrain:GetArmyIndex()])) end
                            for iDistToTravel = iDistInterval, math.max(iDistInterval, math.floor(M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[aiBrain:GetArmyIndex()], tPondSubtable[subrefPondMidpoint]) / iDistInterval) * iDistInterval), iDistInterval do
                                for iAngleAdjust = 0, 170, 10 do
                                    for iAngleFactor = -1, 1, 2 do
                                        tPossibleLocationBase = M28Utilities.MoveInDirection(PlayerStartPoints[aiBrain:GetArmyIndex()], iAngleToCentre + iAngleAdjust * iAngleFactor, iDistToTravel, true, true)
                                        if NavUtils.GetLabel(refPathingTypeNavy, tPossibleLocationBase) == iCurPondRef then
                                            --Try and find somewhere around here to build a naval factory
                                            for iBuildingAdjustX = 0, iBuildingInterval, 1 do
                                                for iBuildingAdjustZ = 0, iBuildingInterval, 1 do
                                                    for iXFactor = -1, 1, 2 do
                                                        for iZFactor = -1, 1, 2 do
                                                            tPossibleBuildLocation = {tPossibleLocationBase[1] + iBuildingAdjustX * iXFactor, 0, tPossibleLocationBase[3] + iBuildingAdjustZ * iZFactor}
                                                            tPossibleBuildLocation[2] = GetSurfaceHeight(tPossibleBuildLocation[1], tPossibleBuildLocation[3])
                                                            if aiBrain:CanBuildStructureAt('ueb0103', tPossibleBuildLocation) then
                                                                bHaveValidLocation = true
                                                                tNavalBuildArea = {tPossibleBuildLocation[1], tPossibleBuildLocation[2], tPossibleBuildLocation[3]}
                                                                if bDebugMessages == true then
                                                                    LOG(sFunctionRef..': Have valid location='..repru(tPossibleBuildLocation)..'; will draw in white')
                                                                    M28Utilities.DrawLocation(tPossibleBuildLocation, 1, 100, 2)
                                                                end
                                                                break
                                                            else
                                                                if bDebugMessages == true then
                                                                    LOG(sFunctionRef..': Have invalid location='..repru(tPossibleBuildLocation)..'; will draw in red')
                                                                    M28Utilities.DrawLocation(tPossibleBuildLocation, 2, 100, 2)
                                                                end
                                                            end
                                                        end
                                                        if bHaveValidLocation then break end
                                                    end
                                                    if bHaveValidLocation then break end

                                                end
                                                if bHaveValidLocation then break end
                                            end
                                            if iAngleAdjust == 0 or bHaveValidLocation then break end
                                        elseif bDebugMessages == true then
                                            LOG(sFunctionRef..': Failed tPossibleLocationBase pathing group, tPossibleLocationBase='..repru(tPossibleLocationBase)..'; naval label='..(NavUtils.GetLabel(refPathingTypeNavy, tPossibleLocationBase) or 'nil')..'; iCurPondRef='..iCurPondRef..'; iPathingGroupWanted='..iPathingGroupWanted..'; will draw in gold')
                                            M28Utilities.DrawLocation(tPossibleLocationBase, 4, 100, 2)
                                        end
                                        if bHaveValidLocation then break end
                                    end
                                    if bHaveValidLocation then break end
                                end
                                if bHaveValidLocation then break end
                            end

                            if bDebugMessages == true then LOG(sFunctionRef..': Finsihed searching for naval build area, is table empty='..tostring(M28Utilities.IsTableEmpty(tNavalBuildArea))) end


                            if M28Utilities.IsTableEmpty(tNavalBuildArea) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': tNavalBuildArea pre adjust='..repru(tNavalBuildArea)) end
                                --Move towards base to help with cliff building if we have cliffs
                                local bHaveNearbyCliff = false
                                local iDistToMoveTarget = M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[aiBrain:GetArmyIndex()], tNavalBuildArea)
                                local iAngleFromTarget = M28Utilities.GetAngleFromAToB(tNavalBuildArea, PlayerStartPoints[aiBrain:GetArmyIndex()])
                                local tCliffPositionCheck
                                local sPathing = refPathingTypeHover
                                local iStartPathingGroup = NavUtils.GetLabel(sPathing,PlayerStartPoints[aiBrain:GetArmyIndex()])

                                if iDistToMoveTarget > 1 then
                                    for iDistAdjust = 1, math.min(13, math.floor(iDistToMoveTarget)) do
                                        tCliffPositionCheck = M28Utilities.MoveInDirection(tNavalBuildArea, iAngleFromTarget, iDistAdjust, true, false)
                                        if not(NavUtils.GetLabel(sPathing, tCliffPositionCheck) == iStartPathingGroup) then
                                            bHaveNearbyCliff = true
                                            break
                                        end

                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': bHaveNearbyCliff='..tostring(bHaveNearbyCliff)) end
                                if bHaveNearbyCliff then
                                    --Try to move closer to base
                                    local tLastValidPosition = {tNavalBuildArea[1], tNavalBuildArea[2], tNavalBuildArea[3]}
                                    local tAlternativePosition

                                    for iDistAdjust = 1, math.min(13, math.floor(iDistToMoveTarget)) do
                                        tAlternativePosition = M28Utilities.MoveInDirection(tNavalBuildArea, iAngleFromTarget, iDistAdjust, true, false)
                                        if not(NavUtils.GetLabel(refPathingTypeNavy, tAlternativePosition) == iCurPondRef) then
                                            break
                                        else
                                            --Can we build here?
                                            if aiBrain:CanBuildStructureAt('ueb0103', tAlternativePosition) then
                                                tLastValidPosition = {tAlternativePosition[1], tAlternativePosition[2], tAlternativePosition[3]}
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have an alternative position that is closer to our base, iDistAdjust='..iDistAdjust) end
                                            else
                                                break
                                            end
                                        end
                                    end
                                    tNavalBuildArea = tLastValidPosition


                                end



                                if bDebugMessages == true then
                                    LOG(sFunctionRef..': Have a naval build area='..repru(tNavalBuildArea)..'; will draw large square around it in blue')
                                    M28Utilities.DrawLocation(tNavalBuildArea, nil, 200, 10)
                                end
                                tPondSubtable[subrefBuildLocationByStartPosition][aiBrain:GetArmyIndex()] = tNavalBuildArea

                                --Record pond value before distance adjustments - i.e. if we already have navy somewhere, this is how much the pond is worth to us
                                aiBrain[M28Navy.reftiPondValueToUs][iCurPondRef] = iCurPondValue
                                --Adjust pond value based on distance to us - used only for decision on whether to choose as a pond we want


                                --Can we path here amphibiously?
                                if not(NavUtils.GetLabel(refPathingTypeHover, tNavalBuildArea) == iPathingGroupWanted) then
                                    iCurPondValue = 0
                                    if bDebugMessages == true then LOG(sFunctionRef..': We cant path here amphibiously') end
                                else
                                    --Adjust value based on distance
                                    local iDistToBuildArea = M28Utilities.GetDistanceBetweenPositions(tNavalBuildArea, PlayerStartPoints[aiBrain:GetArmyIndex()])
                                    if iDistToBuildArea <= 50 then iCurPondValue = iCurPondValue * 1.1
                                    else
                                        iCurPondValue = iCurPondValue * math.max(0.1, 1 - 0.4 * iDistToBuildArea / iDistanceThreshold)
                                    end

                                    --Are we close enough to enemy base to be in danger and we can land path to enemy base?
                                    if bDebugMessages == true then LOG(sFunctionRef..': Dist to nearest enemy base='..aiBrain[M28Overseer.refiDistanceToNearestEnemyBase]..'; Can path with land='..tostring(aiBrain[refbCanPathToEnemyBaseWithLand])..'; Dist from naval build location to enemy base='..M28Utilities.GetDistanceBetweenPositions(tNavalBuildArea, GetPrimaryEnemyBaseLocation(aiBrain))) end
                                    if aiBrain[refbCanPathToEnemyBaseWithLand] then
                                        --Reduce value of pond if enemy base is close for land anyway
                                        if aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] <= 300 then
                                            iCurPondValue = iCurPondValue * 0.5
                                        end
                                        if M28Utilities.GetDistanceBetweenPositions(tNavalBuildArea, GetPrimaryEnemyBaseLocation(aiBrain)) <= 200 then
                                            iCurPondValue = 0
                                        end
                                    end
                                end
                            else
                                iCurPondValue = 0
                            end
                            aiBrain[M28Navy.reftiPondThreatToUs][iCurPondRef] = iCurPondDefensiveValue
                            if bDebugMessages == true then LOG(sFunctionRef..': Pond value after getting naval build area='..iCurPondValue..'; Defensive value='..(aiBrain[M28Navy.reftiPondThreatToUs][iCurPondRef] or 'nil')) end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Pond value is too low to be worth considering') end
                            iCurPondValue = 0
                        end
                    end
                end
                if iCurPondValue > iBestPondValue then
                    if bDebugMessages == true then LOG(sFunctionRef..': Updating the best pond ref to be '..iCurPondRef..'; as the cur pond value '..iCurPondValue..' is more than the prev best of '..iBestPondValue) end
                    iBestPondRef = iCurPondRef
                    iBestPondValue = iCurPondValue

                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Near end of code, iBestPondRef='..(iBestPondRef or 'nil')..'; iBestPondValue='..(iBestPondValue or 'nil')) end
        if iBestPondRef and iBestPondValue >= 4 then
            aiBrain[M28Navy.refiPriorityPondRef] = iBestPondRef
            if bDebugMessages == true then
                LOG(sFunctionRef..': Have a priority pond ref='..aiBrain[M28Navy.refiPriorityPondRef]..'; will draw a square in orangy pink for the build position='..repru(tPondDetails[aiBrain[M28Navy.refiPriorityPondRef]][subrefBuildLocationByStartPosition][aiBrain:GetArmyIndex()]))
                M28Utilities.DrawLocation(tPondDetails[aiBrain[M28Navy.refiPriorityPondRef]][subrefBuildLocationByStartPosition][aiBrain:GetArmyIndex()], 8, 200, 10)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AddSegmentToWaterZone(iPond, iWaterZone, iSegmentX, iSegmentZ)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddSegmentToWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': About to add Segment X-Z'..iSegmentX..'-'..iSegmentZ..' to iPond='..iPond..' and water zone='..iWaterZone..'; iTotalWaterZoneRecordedSegmentCount prior to this='..iTotalWaterZoneRecordedSegmentCount) end
    table.insert(tPondDetails[iPond][subrefPondWaterZones][iWaterZone][subrefWZSegments], {iSegmentX, iSegmentZ})
    if not(tWaterZoneBySegment[iSegmentX]) then tWaterZoneBySegment[iSegmentX] = {} end
    tWaterZoneBySegment[iSegmentX][iSegmentZ] = iWaterZone
    iTotalWaterZoneRecordedSegmentCount = iTotalWaterZoneRecordedSegmentCount + 1
    tPondDetails[iPond][subrefiRecordedSegmentsInWaterZones] = (tPondDetails[iPond][subrefiRecordedSegmentsInWaterZones] or 0) + 1
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordWaterZoneAtPosition(tSegmentPosition)
    iTotalWaterZoneCount = iTotalWaterZoneCount + 1
    local iPond = NavUtils.GetLabel(refPathingTypeNavy, tSegmentPosition)
    if not(iPond) then M28Utilities.ErrorHandler('Dont have a valid pond')
    else
        if not(tPondDetails[iPond][subrefPondWaterZones]) then tPondDetails[iPond][subrefPondWaterZones] = {} end
        tPondDetails[iPond][subrefPondWaterZones][iTotalWaterZoneCount] = {}
        tPondDetails[iPond][subrefPondWaterZones][iTotalWaterZoneCount][subrefWZSegments] = {}
        tiPondByWaterZone[iTotalWaterZoneCount] = iPond
        local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tSegmentPosition)
        AddSegmentToWaterZone(iPond, iTotalWaterZoneCount, iSegmentX, iSegmentZ)
    end
end

local function DrawWaterZones()
    --For debug use - will draw each land zone in a plateau in a different colour to allow a visual check of how land zones have been created.  Can be called part-way through the process (e.g. to show land zones after the initial mex creation and nearby areas)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DrawWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Create fixed colours per ref
    local iUniqueColourCount = 30
    local tColourTable = M28Utilities.GenerateUniqueColourTable(iUniqueColourCount)

    --Subfunction which assigns a unique colour to each land zone
    function GetColourFromWaterZoneNumber(iWaterZoneRef)
        local iColour = iWaterZoneRef
        while iColour >= iUniqueColourCount do
            iColour = iColour - iUniqueColourCount
        end

        return tColourTable[iColour]
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Will now draw every land zone in every plateau, cycling the colour used') end
    local tLocation, iWaterZoneRef
    --Cycle through every segment on the map and draw a colour for it based on the land zone that it's part of
    for iCurSegmentX = 1, iMaxLandSegmentX do
        for iCurSegmentZ = 1, iMaxLandSegmentZ do
            iWaterZoneRef = tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ]
            if (iWaterZoneRef or 0) > 0 then
                tLocation = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                if bDebugMessages == true then LOG(sFunctionRef..': Water zone ref for segments X-Z='..iCurSegmentX..'-'..iCurSegmentZ..' = '..iWaterZoneRef..'; Plataeu ref based on navutils='..NavUtils.GetLabel(refPathingTypeHover, tLocation)) end
                --M28Utilities.DrawLocation(tLocation, GetColourFromWaterZoneNumber(iWaterZoneRef), nil, iLandZoneSegmentSize - 0.1)
                M28Utilities.DrawLocation(tLocation, GetColourFromWaterZoneNumber(iWaterZoneRef), nil, iLandZoneSegmentSize - 0.1)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CreateWaterZones()
    --Creates each separate water zones and assign segments to each water zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iSystemTimeStart = GetSystemTimeSecondsOnlyForProfileUse()
    local iMapSize = math.max(rMapPlayableArea[3] - rMapPlayableArea[1], rMapPlayableArea[4] - rMapPlayableArea[2])
    local iWaterZoneInterval = 130 + 30 * math.floor(iMapSize / 512) --i.e. 130 for 5km, 160 for 10km, 190 for 20km, 370 for 80km


    --local iMinDistanceFromFactoryBuildPosition = 100
    local iSegmentInterval = iWaterZoneInterval / iLandZoneSegmentSize
    local iStartSegment = iSegmentInterval * 0.5
    --local iEndSegmentX =
    local iMaxXIntervals = math.floor((iMaxLandSegmentX * iLandZoneSegmentSize - iStartSegment * iLandZoneSegmentSize) / iWaterZoneInterval) + 1
    local iMaxZIntervals = math.floor((iMaxLandSegmentZ * iLandZoneSegmentSize - iStartSegment * iLandZoneSegmentSize) / iWaterZoneInterval) + 1
    local iBaseSegmentX, iBaseSegmentZ
    local iPotentialZoneStartSegmentX, iPotentialZoneStartSegmentZ
    local iMaxSegmentAdjust = math.max(1, math.floor(iSegmentInterval * 0.5))
    local iCurSegmentX, iCurSegmentZ, iPotentialPond
    local bFoundForThisInterval
    --local bRecordAsWaterZone

    if bDebugMessages == true then LOG(sFunctionRef..': About to divide map into grids and assign to a zone, iMaxLandSegmentX='..iMaxLandSegmentX..'; iLandZoneSegmentSize='..iLandZoneSegmentSize..'; iStartSegment='..iStartSegment..'; iWaterZoneInterval='..iWaterZoneInterval..'; iMaxXIntervals='..iMaxXIntervals..'; iMaxZIntervals='..iMaxZIntervals..'; Playablearea='..repru(rMapPlayableArea)) end
    for iIntervalCountX = 1, iMaxXIntervals do
        iBaseSegmentX = iSegmentInterval * (iIntervalCountX - 0.5)
        for iIntervalCountZ = 1, iMaxZIntervals do
            iPotentialZoneStartSegmentX = nil
            iPotentialZoneStartSegmentZ = nil
            bFoundForThisInterval = false

            iBaseSegmentZ = iSegmentInterval * (iIntervalCountZ - 0.5)
            if tWaterZoneBySegment[iBaseSegmentX][iBaseSegmentZ] then --redundancy
                bFoundForThisInterval = true
            else
                --See if there is anywhere near the base segment that is in a pond, and if so use this as the waterzone start point
                iPotentialPond = NavUtils.GetLabel(refPathingTypeNavy, GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ))
                if (iPotentialPond or 0) > 0 then
                    iPotentialZoneStartSegmentX = iBaseSegmentX
                    iPotentialZoneStartSegmentZ = iBaseSegmentZ
                else
                    --Search nearby in intervals of 20, up to 80 (adjusted for segment size)
                    for iAdjustBase = 1, iMaxSegmentAdjust do
                        for iCurSegmentX = math.max(1, iBaseSegmentX - iAdjustBase), math.min(iMaxLandSegmentX, iBaseSegmentX + iAdjustBase) do
                            for iCurSegmentZ = math.max(1, iBaseSegmentZ - iAdjustBase), math.min(iMaxLandSegmentZ, iBaseSegmentZ + iAdjustBase) do
                                if tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] then --redundancy
                                    bFoundForThisInterval = true
                                    break
                                else
                                    iPotentialPond = NavUtils.GetLabel(refPathingTypeNavy, GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ))
                                    if (iPotentialPond or 0) > 0 then
                                        bFoundForThisInterval = true
                                        iPotentialZoneStartSegmentX = iCurSegmentX
                                        iPotentialZoneStartSegmentZ = iCurSegmentZ
                                        break
                                    end
                                end
                            end
                            if bFoundForThisInterval then break end
                        end
                        if bFoundForThisInterval then break end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for potential point for water zone for iIntervalCountX='..iIntervalCountX..'; iIntervalCountZ='..iIntervalCountZ..'; iPotentialZoneStartSegmentX='..(iPotentialZoneStartSegmentX or 'nil')..'; iPotentialZoneStartSegmentZ='..(iPotentialZoneStartSegmentZ or 'nil')) end

            if iPotentialZoneStartSegmentX then
                --Below was to not record near a start position, but on reflection will just let start positiosn be on the edge of a water zone, to keep things simple for now
                local tSegmentPosition = GetPositionFromPathingSegments(iPotentialZoneStartSegmentX, iPotentialZoneStartSegmentZ)

                --Have found a segment that is on water, record this as a waterzone unless it is close to a factory
                --bRecordAsWaterZone = true

                --[[if M28Utilities.IsTableEmpty(tPondDetails[iPotentialPond][subrefBuildLocationByStartPosition]) == false then
                for iArmyIndex, tBuildPosition in tPondDetails[iPotentialPond][subrefBuildLocationByStartPosition] do
                    if M28Utilities.GetDistanceBetweenPositions(tSegmentPosition, tBuildPosition) <= iMinDistanceFromFactoryBuildPosition then
                        bRecordAsWaterZone = false
                        break
                    end
                end
            end--]]
                --if bRecordAsWaterZone then
                RecordWaterZoneAtPosition(tSegmentPosition)
                --end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished recording the first segment for each water zone, will now check for any ponds that lack a water zone') end
    --Now go through any ponds that dont have a water zone and create one
    for iPond, tPondSubtable in tPondDetails do
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if pond '..iPond..' has any water zones, is table of water zones empty='..tostring(M28Utilities.IsTableEmpty(tPondSubtable[subrefPondWaterZones]))..'; tPondSubtable[subrefiSegmentCount]='..(tPondSubtable[subrefiSegmentCount] or 'nil')) end
        if M28Utilities.IsTableEmpty(tPondSubtable[subrefPondWaterZones]) and tPondSubtable[subrefiSegmentCount] > 0 then
            iPotentialZoneStartSegmentX = tPondSubtable[subreftiWaterSegmentXZ][1]
            iPotentialZoneStartSegmentZ = tPondSubtable[subreftiWaterSegmentXZ][2]
            if bDebugMessages == true then LOG(sFunctionRef..': About to record a water zone using iPotentialZoneStartSegmentX-Z='..iPotentialZoneStartSegmentX..'-'..iPotentialZoneStartSegmentZ..'; water zone for this (hopefully shoudl be nil)='..(tWaterZoneBySegment[iPotentialZoneStartSegmentX][iPotentialZoneStartSegmentZ] or 'nil')) end
            RecordWaterZoneAtPosition(GetPositionFromPathingSegments(iPotentialZoneStartSegmentX, iPotentialZoneStartSegmentZ))
        end
    end

    --Now record segments around each waterzone as belonging to that waterzone if they dont already have a waterzone recorded and are on water
    local bAbort = false
    local iCurSegmentX, iCurSegmentZ
    local iMaxPondSegmentX, iMaxPondSegmentZ
    local iMinPondSegmentX, iMinPondSegmentZ

    for iPond, tPondSubtable in tPondDetails do

        iMaxPondSegmentX, iMaxPondSegmentZ = GetPathingSegmentFromPosition({ tPondSubtable[subrefPondMaxX], 0, tPondSubtable[subrefPondMaxZ] })
        iMinPondSegmentX, iMinPondSegmentZ = GetPathingSegmentFromPosition({ tPondSubtable[subrefPondMinX], 0, tPondSubtable[subrefPondMinZ] })

        for iAdjustBase = 1, math.max(iMaxLandSegmentX, iMaxLandSegmentZ), 1 do --need to do the max values incase we only have 1 waterzone in say the top-right of hte map that somehow has a small path to other waterzones that were missed by the initial waterzone creation
            for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
                iBaseSegmentX = tWZData[subrefWZSegments][1][1]
                iBaseSegmentZ = tWZData[subrefWZSegments][1][2]
                for iCurSegmentX = math.max(1, iBaseSegmentX - iAdjustBase), math.min(iMaxLandSegmentX, iBaseSegmentX + iAdjustBase) do
                    for iCurSegmentZ = math.max(1, iBaseSegmentZ - iAdjustBase), math.min(iMaxLandSegmentZ, iBaseSegmentZ + iAdjustBase) do
                        if tPondBySegment[iCurSegmentX][iCurSegmentZ] and not(tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ]) then
                            AddSegmentToWaterZone(iPond, iWaterZone, iCurSegmentX, iCurSegmentZ)
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Considered segment XZ='..iCurSegmentX..'-'..iCurSegmentZ..'; tPondBySegment[iCurSegmentX][iCurSegmentZ]='..(tPondBySegment[iCurSegmentX][iCurSegmentZ] or 'nil')..'; tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ]='..(tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] or 'nil')) end
                    end
                end
            end

            --Have we recorded water zones against all segments in this pond?
            if bDebugMessages == true then LOG(sFunctionRef..': On pond '..iPond..'; Finished for iAdjustBase='..iAdjustBase..'; tPondSubtable[subrefiRecordedSegmentsInWaterZones]='..tPondSubtable[subrefiRecordedSegmentsInWaterZones]..'; tPondSubtable[subrefiSegmentCount]='..tPondSubtable[subrefiSegmentCount]) end
            if tPondSubtable[subrefiRecordedSegmentsInWaterZones] >= tPondSubtable[subrefiSegmentCount] then break end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, finished recording segments in water zone, iTotalWaterZoneRecordedSegmentCount='..iTotalWaterZoneRecordedSegmentCount..'; iTotalSegmentsInPonds='..iTotalSegmentsInPonds..'; iTotalWaterZoneCount='..iTotalWaterZoneCount..'; will draw all water zones. Time taken to run water zone logic='..GetSystemTimeSecondsOnlyForProfileUse() - iSystemTimeStart) end
    if iTotalWaterZoneRecordedSegmentCount < iTotalSegmentsInPonds then
        M28Utilities.ErrorHandler('May not have assigned every water segment a water zone - consider adding code to go through every pond water segment as backup')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SetupWaterZones()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTotalWaitTime = 0
    --Allow up to 1s to setup preferred pond location, otherwise iwll just create water zones ignoring preferred factory build locations
    while not(bHaveConsideredPreferredPondForM28AI) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        iTotalWaitTime = iTotalWaitTime + 1
        if iTotalWaitTime >= 50 then M28Utilities.ErrorHandler('Havent setup preferred factory locations yet, will proceed with water zone creation anyway') break end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': About to start with creating water zones, is tPondDetails empty='..tostring(M28Utilities.IsTableEmpty(tPondDetails))..'; GameTime='..GetGameTimeSeconds()..'; System time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    if M28Utilities.IsTableEmpty(tPondDetails) == false then
        CreateWaterZones()
        if bDebugMessages == true then
            LOG(sFunctionRef..': Finished running CreateWaterZones, Systemtime='..GetSystemTimeSecondsOnlyForProfileUse()..'; will draw water zones now')
            DrawWaterZones()
        end


        RecordWaterZoneMidpointAndMinMaxPositions()
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording water zone midpoint etc., system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
        RecordHydroInWaterZones()
        RecordWaterZoneAdjacentLandZones()
        RecordAdjacentWaterZones()
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording adjacency for land zones vs water zones, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
        RecordWaterZonePathingToOtherWaterZones()
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording water zone pathing to other water zones, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
        RecordWaterZonePatrolPaths()
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording water zone patrol paths for land scouts, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    end
    bWaterZoneInitialCreation = true
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordWaterZoneMidpointAndMinMaxPositions()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordWaterZoneMidpointAndMinMaxPositions'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iMinX, iMaxX, iMinZ, iMaxZ, iAveragePond, iAverageWaterZone
    local iAverageSegmentX, iAverageSegmentZ
    for iPond, tPondSubtable in tPondDetails do
        --Go through any mexes near a pond, and record against a waterzone if they're in water
        if M28Utilities.IsTableEmpty(tPondSubtable[subrefPondMexInfo]) == false then
            local iMexWaterZone, iMexPond
            for iMex, tSubtable in  tPondSubtable[subrefPondMexInfo] do
                local tMex = tSubtable[subrefMexLocation]
                iMexWaterZone = GetWaterZoneFromPosition(tMex)
                if (iMexWaterZone or 0) > 0 then
                    iMexPond = tiPondByWaterZone[iMexWaterZone]
                    AddMexToWaterZone(iMexPond, iMexWaterZone, tMex)
                    if bDebugMessages == true then LOG(sFunctionRef..': Just added mex at position '..repru(tMex)..' to iMexWaterZone='..iMexWaterZone) end
                end
            end
        end

        for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
            --Record min and max values
            iMinX = 100000
            iMinZ = 100000
            iMaxX = 0
            iMaxZ = 0
            for iEntry, tiSegmentXZ in tWZData[subrefWZSegments] do
                iMinX = math.min(tiSegmentXZ[1], iMinX)
                iMinZ = math.min(tiSegmentXZ[2], iMinZ)
                iMaxX = math.max(tiSegmentXZ[1], iMaxX)
                iMaxZ = math.max(tiSegmentXZ[2], iMaxZ)
            end
            tWZData[subrefWZMinSegX] = iMinX
            tWZData[subrefWZMinSegZ] = iMinZ
            tWZData[subrefWZMaxSegX] = iMaxX
            tWZData[subrefWZMaxSegZ] = iMaxZ

            --Record midpoint
            local tAverage = {(iMinX + iMaxX)*0.5, 0, (iMinZ + iMaxZ) * 0.5}
            iAveragePond = NavUtils.GetLabel(refPathingTypeNavy, tAverage)
            iAverageSegmentX, iAverageSegmentZ = GetPathingSegmentFromPosition(tAverage)
            iAverageWaterZone = tWaterZoneBySegment[iAverageSegmentX][iAverageSegmentZ]


            --Move the midpoint if nav utils doesnt work for this position (to reduce the amount of grief we might have later)
            if not(iPond == iAveragePond) or not(iAverageWaterZone == iWaterZone) then
                local tAltMidpoint
                local iAdjustedSegmentX, iAdjustedSegmentZ
                local bHaveValidAltMidpoint = false
                for iAdjust = 1, 50 do
                    for iXAdjust = -iAdjust, iAdjust, 1 do
                        for iZAdjust = -iAdjust, iAdjust, 1 do
                            if not(iXAdjust == 0 and iZAdjust == 0) then
                                iAdjustedSegmentX = iAverageSegmentX + iAdjust * iXAdjust
                                iAdjustedSegmentZ = iAverageSegmentZ + iAdjust * iZAdjust
                                iAverageWaterZone = tWaterZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ]
                                if iAverageWaterZone == iWaterZone then
                                    tAltMidpoint = GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering adjusted segment X-Z='..iAdjustedSegmentX..'-'..iAdjustedSegmentZ..'; with water zone '..tWaterZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ]..'; tAltMidpoint='..repru(tAltMidpoint)..'; Pond from navutils='..(NavUtils.GetLabel(refPathingTypeNavy, tAltMidpoint) or 'nil')) end
                                    if NavUtils.GetLabel(refPathingTypeNavy, tAltMidpoint) == iPond then
                                        --Have a valid midpoint; as this is water, see whether if we move further in the adjust direction we can still have a vlid point (so we arent as likely to be on the shore/by a cliff):
                                        local iXNewAdjust = 0
                                        local iZNewAdjust = 0
                                        local iXSizeAdjust = math.ceil(10 / iLandZoneSegmentSize)
                                        local iZSizeAdjust = math.ceil(10 / iLandZoneSegmentSize)
                                        if math.abs(iXAdjust) >= 10 then iXSizeAdjust = iXSizeAdjust * 2 end
                                        if math.abs(iZAdjust) >= 10 then iZSizeAdjust = iZSizeAdjust * 2 end
                                        if iXAdjust < 0 then iXNewAdjust = - iXSizeAdjust
                                        elseif iXAdjust > 0 then iXNewAdjust = iXSizeAdjust end
                                        if iZNewAdjust < 0 then iZNewAdjust = - iZSizeAdjust
                                        elseif iZNewAdjust > 0 then iZNewAdjust = iZSizeAdjust end
                                        if tWaterZoneBySegment[iAdjustedSegmentX + iXNewAdjust][iAdjustedSegmentZ + iZNewAdjust] == iAverageWaterZone and NavUtils.GetLabel(refPathingTypeNavy, GetPositionFromPathingSegments(iAdjustedSegmentX + iXNewAdjust, iAdjustedSegmentZ + iZNewAdjust)) == iPond then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will go with adjusted segment value, tAltMidpoint before adjust='..repru(tAltMidpoint)..'; tAltMidpoint after adjust='..repru(GetPositionFromPathingSegments(iAdjustedSegmentX + iXNewAdjust, iAdjustedSegmentZ + iZNewAdjust))..'; iXNewAdjust='..iXNewAdjust..'; iZNewAdjust='..iZNewAdjust) end
                                            tAltMidpoint = GetPositionFromPathingSegments(iAdjustedSegmentX + iXNewAdjust, iAdjustedSegmentZ + iZNewAdjust)
                                        end

                                        bHaveValidAltMidpoint = true
                                        iAveragePond = iPond
                                        tAverage = {tAltMidpoint[1], tAltMidpoint[2], tAltMidpoint[3]}
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have valid alternative midpoint which will now record and use, tAverage after update='..repru(tAverage)..'; will see if can adjust slightly to be more in the water') end
                                        break
                                    end
                                elseif bDebugMessages == true then
                                    LOG(sFunctionRef..': Adjusted semgnet X-Z='..iAdjustedSegmentX..'-'..iAdjustedSegmentZ..'; didnt have the right Water zone, was '..(tWaterZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ] or 'nil')..'; will draw segment midpoint in red if its in playaable area')
                                    local tAltLocation = GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)
                                    if tAltLocation and tAltLocation[1] > rMapPlayableArea[1] and tAltLocation[1] < rMapPlayableArea[3] and tAltLocation[3] > rMapPlayableArea[2] and tAltLocation[3] < rMapPlayableArea[4] then
                                        M28Utilities.DrawLocation(tAltLocation, 2)
                                    end
                                end
                            end
                        end
                        if bHaveValidAltMidpoint then break end
                    end
                    if bHaveValidAltMidpoint then break end
                end

                --If still dont have a valid location, then just try any segment recorded in the land zone (this wont be in the middle of the land zone, but is better than having an unpathable midpoint)
                if not(bHaveValidAltMidpoint) then
                    for iSegment, tSegmentXZ in tWZData[subrefWZSegments] do
                        if tWaterZoneBySegment[tSegmentXZ[1]][tSegmentXZ[2]] == iWaterZone then
                            tAltMidpoint = GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
                            if bDebugMessages == true then LOG(sFunctionRef..': Cycling through recorded segments for this LZ, and considering segment X-Z='..tSegmentXZ[1]..'-'..tSegmentXZ[2]..'; with land zone '..tLandZoneBySegment[tSegmentXZ[1]][tSegmentXZ[2]]..'; tAltMidpoint='..repru(tAltMidpoint)..'; Plateau from navutils='..(NavUtils.GetLabel(refPathingTypeHover, tAltMidpoint) or 'nil')..'; Island from navutils='..(NavUtils.GetLabel(refPathingTypeLand, tAltMidpoint) or 'nil')) end
                            if NavUtils.GetLabel(refPathingTypeNavy, tAltMidpoint) == iPond then
                                bHaveValidAltMidpoint = true
                                iAveragePond = NavUtils.GetLabel(refPathingTypeNavy, tAltMidpoint)
                                tAverage = {tAltMidpoint[1], tAltMidpoint[2], tAltMidpoint[3]}
                                if bDebugMessages == true then LOG(sFunctionRef..': Have valid alternative midpoint which will now record and use, tAverage after update='..repru(tAverage)) end
                                break
                            end
                        end
                    end
                    if not(bHaveValidAltMidpoint) then
                        M28Utilities.ErrorHandler(' dont have valid midpoint even after checking every water zone segment for iPond='..iPond)
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': iWaterZone='..iWaterZone..'; tWZData[subrefWZSegments]='..repru(tWZData[subrefWZSegments] or 'nil')..'; First segment position='..repru(GetPositionFromPathingSegments(tWZData[subrefWZSegments][1][1], tWZData[subrefWZSegments][1][2]))..'; playable area='..repru(rMapPlayableArea)..'; GetLabel navy pathing result for the first segment position='..(NavUtils.GetLabel(refPathingTypeNavy, GetPositionFromPathingSegments(tWZData[subrefWZSegments][1][1], tWZData[subrefWZSegments][1][2])) or 'nil')..'; water zone of this segment position='..(tWaterZoneBySegment[tWZData[subrefWZSegments][1][1]][tWZData[subrefWZSegments][1][2]] or 'nil')..'; will draw the water zone')
                            DrawSpecificWaterZone(iWaterZone, math.random(1, 8))
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iAveragePond='..(iAveragePond or 'nil')..'; iPond='..(iPond or 'nil')..'; iAverageWaterZone='..(iAverageWaterZone or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'; tAverage='..repru(tAverage)) end
            if (iAveragePond == iPond and iAverageWaterZone == iWaterZone) then
                tWZData[subrefWZMidpoint] = {tAverage[1], tAverage[2], tAverage[3]}
                if bDebugMessages == true then LOG(sFunctionRef..': Will use the average position as the midpoint') end
            else
                --Just use the first recorded segment of the water zone as the midpoint
                tWZData[subrefWZMidpoint] = GetPositionFromPathingSegments(tWZData[subrefWZSegments][1][1], tWZData[subrefWZSegments][1][2])
                if bDebugMessages == true then LOG(sFunctionRef..': WIll use the first recorded segment as the midpoint, tWZData[subrefWZMidpoint]='..repru(tWZData[subrefWZMidpoint])) end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordWaterZoneAdjacentLandZones()
    --Update land zones with details of adjacent water zones, and update water zones wit hdetails of adjacent land zones
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordWaterZoneAdjacentLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iPlateau
    local iSegmentGapAllowed = math.max(3, math.ceil(24 / iLandZoneSegmentSize))
    local iDistBetweenMidpoints, iMaxLineInterval, iLineAngle, iCurLineSegmentX, iCurLineSegmentZ
    local iLineInterval = iLandZoneSegmentSize
    local tLinePosition
    local bIsAdjacent
    local iAdjacencyTablePosition

    for iPond, tPondSubtable in tPondDetails do
        for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
            iPlateau = NavUtils.GetLabel(refPathingTypeHover, tWZData[subrefWZMidpoint])
            if iPlateau > 0 and M28Utilities.IsTableEmpty(tAllPlateaus[iPlateau]) == false then
                --Cycle through every land zone on the map, and check if it is near this
                for iLandZone, tLZData in tAllPlateaus[iPlateau][subrefPlateauLandZones] do
                    --Is this land zone adjacent? Might be adjacent the following are both the case:
                    --LZMinX is >= WZMinX and <=WZMaxX; or LZMaxX is >= WZMinX and <=WZMaxX
                    --As above but for Z
                    --Hover want to have a small tolerance for cliffs etc
                    if (tLZData[subrefLZMinSegX] + iSegmentGapAllowed >= tWZData[subrefWZMinSegX] and tLZData[subrefLZMinSegX] - iSegmentGapAllowed <= tWZData[subrefWZMaxSegX]) or (tLZData[subrefLZMaxSegX] + iSegmentGapAllowed >= tWZData[subrefWZMinSegX] and tLZData[subrefLZMaxSegX] - iSegmentGapAllowed <= tWZData[subrefWZMaxSegX])
                            and (tLZData[subrefLZMinSegZ] + iSegmentGapAllowed >= tWZData[subrefWZMinSegZ] and tLZData[subrefLZMinSegZ] - iSegmentGapAllowed <= tWZData[subrefWZMaxSegZ]) or (tLZData[subrefLZMaxSegZ] + iSegmentGapAllowed >= tWZData[subrefWZMinSegZ] and tLZData[subrefLZMaxSegZ] - iSegmentGapAllowed <= tWZData[subrefWZMaxSegZ]) then
                        --It looks like we might overlap, do a more precise calculation drawing a line from the two midpoints to see if we come across other land zones
                        bIsAdjacent = false
                        iDistBetweenMidpoints = M28Utilities.GetDistanceBetweenPositions(tWZData[subrefWZMidpoint], tLZData[subrefLZMidpoint])
                        iMaxLineInterval = math.floor(iDistBetweenMidpoints / iLineInterval) * iLineInterval
                        iLineAngle = M28Utilities.GetAngleFromAToB(tWZData[subrefWZMidpoint], tLZData[subrefLZMidpoint])
                        for iDistAlongLine = iLineInterval, iMaxLineInterval, iLineInterval do
                            tLinePosition = M28Utilities.MoveInDirection(tWZData[subrefWZMidpoint], iLineAngle, iDistAlongLine, false, false)
                            iCurLineSegmentX, iCurLineSegmentZ = GetPathingSegmentFromPosition(tLinePosition)
                            if tLandZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ] then
                                if tLandZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ] == iLandZone then
                                    bIsAdjacent = true
                                    break
                                else
                                    --Not adjacent as is another land zone inbetween
                                    break
                                end
                            elseif tWaterZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ] then
                                if not(tWaterZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ] == iWaterZone) then
                                    --not adjacent as is another water zone inbetween
                                    break
                                end
                            end
                        end
                        if bIsAdjacent then
                            --Record water zone as adjacent to land zone
                            iAdjacencyTablePosition = 1
                            if M28Utilities.IsTableEmpty(tLZData[subrefAdjacentWaterZones]) then
                                tLZData[subrefAdjacentWaterZones] = {}
                            else
                                for iEntry, tAdjacencySubtable in tLZData[subrefAdjacentWaterZones] do
                                    if tAdjacencySubtable[subrefAWZDistance] < iDistBetweenMidpoints then
                                        iAdjacencyTablePosition = iEntry + 1
                                    else
                                        --Since table is ordered by distance later entries should be furhter away
                                        break
                                    end
                                end
                            end
                            table.insert(tLZData[subrefAdjacentWaterZones], iAdjacencyTablePosition, {[subrefAWZRef] = iWaterZone, [subrefAWZDistance] = iDistBetweenMidpoints})
                            if bDebugMessages == true then LOG(sFunctionRef..': Added iWaterZone='..iWaterZone..' as being adjacent to iLandZone='..iLandZone..'; tLZData[subrefAdjacentWaterZones]='..repru(tLZData[subrefAdjacentWaterZones])) end

                            --Record land zone as adjacent to water zone
                            iAdjacencyTablePosition = 1
                            if M28Utilities.IsTableEmpty(tWZData[subrefAdjacentLandZones]) then
                                tWZData[subrefAdjacentLandZones] = {}
                            else
                                for iEntry, tAdjacencySubtable in tWZData[subrefAdjacentLandZones] do
                                    if tAdjacencySubtable[subrefALZDistance] < iDistBetweenMidpoints then
                                        iAdjacencyTablePosition = iEntry + 1
                                    else
                                        --Since table is ordered by distance later entries should be furhter away
                                        break
                                    end
                                end
                            end
                            table.insert(tWZData[subrefAdjacentLandZones], iAdjacencyTablePosition, {[subrefWPlatAndLZNumber] = {iPlateau, iLandZone}, [subrefALZDistance] = iDistBetweenMidpoints})
                        end
                    end

                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished recording adjacent water zones for iWaterZone='..iWaterZone..'; tWZData[subrefAdjacentLandZones]='..repru(tWZData[subrefAdjacentLandZones])) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordWaterZonePathingToOtherWaterZones()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordWaterZonePathingToOtherWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tiWaterZonePairsConsideredByLowestWZ = {}
    local iLowestWZ, iHighestWZ
    local iNavalTravelDistance
    local iStartWZAdjacencyTablePosition
    local iEndWZAdjacencyTablePosition
    for iPond, tPondSubtable in tPondDetails do
        for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
            --Cycle through each other water zone in this pond and determine pathing
            for iOtherWaterZone, tOtherWZData in tPondSubtable[subrefPondWaterZones] do
                if not(iWaterZone == iOtherWaterZone) then
                    if iWaterZone < iOtherWaterZone then
                        iLowestWZ = iWaterZone
                        iHighestWZ = iOtherWaterZone
                    else
                        iLowestWZ = iOtherWaterZone
                        iHighestWZ = iWaterZone
                    end
                    if not(tiWaterZonePairsConsideredByLowestWZ[iLowestWZ][iHighestWZ]) then
                        if not(tiWaterZonePairsConsideredByLowestWZ[iLowestWZ]) then tiWaterZonePairsConsideredByLowestWZ[iLowestWZ] = {} end
                        iNavalTravelDistance = M28Utilities.GetTravelDistanceBetweenPositions(tWZData[subrefWZMidpoint], tOtherWZData[subrefWZMidpoint], refPathingTypeNavy)
                        if iNavalTravelDistance then
                            iStartWZAdjacencyTablePosition = 1
                            if M28Utilities.IsTableEmpty(tWZData[subrefWZOtherWaterZones]) then
                                tWZData[subrefWZOtherWaterZones] = {}
                            else
                                for iEntry, tAdjacencySubtable in tWZData[subrefWZOtherWaterZones] do
                                    if tAdjacencySubtable[subrefWZAWZDistance] < iNavalTravelDistance then
                                        iStartWZAdjacencyTablePosition = iEntry + 1
                                    else
                                        --Since table is ordered by distance later entries should be furhter away
                                        break
                                    end
                                end
                            end
                            table.insert(tWZData[subrefWZOtherWaterZones], iStartWZAdjacencyTablePosition, {[subrefWZAWZRef] = iOtherWaterZone, [subrefWZAWZDistance] = iNavalTravelDistance})

                            iEndWZAdjacencyTablePosition = 1
                            if M28Utilities.IsTableEmpty(tOtherWZData[subrefWZOtherWaterZones]) then
                                tOtherWZData[subrefWZOtherWaterZones] = {}
                            else
                                for iEntry, tAdjacencySubtable in tOtherWZData[subrefWZOtherWaterZones] do
                                    if tAdjacencySubtable[subrefWZAWZDistance] < iNavalTravelDistance then
                                        iEndWZAdjacencyTablePosition = iEntry + 1
                                    else
                                        --Since table is ordered by distance later entries should be furhter away
                                        break
                                    end
                                end
                            end
                            table.insert(tOtherWZData[subrefWZOtherWaterZones], iEndWZAdjacencyTablePosition, {[subrefWZAWZRef] = iWaterZone, [subrefWZAWZDistance] = iNavalTravelDistance})

                            tiWaterZonePairsConsideredByLowestWZ[iLowestWZ][iHighestWZ] = true
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished considering all pathing for iWaterZone='..iWaterZone..'; tiWaterZonePairsConsideredByLowestWZ='..repru(tiWaterZonePairsConsideredByLowestWZ)..'; tWZData[subrefWZOtherWaterZones]='..repru(tWZData[subrefWZOtherWaterZones])) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SetupMap()
    --Sets up non-brain specific info on the map
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupMap'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Send a message warning players this could take a while
    for iBrain, oBrain in ArmyBrains do
        if oBrain.M28AI then
            M28Chat.SendForkedMessage(oBrain, 'LoadingMap', 'Analysing map, this usually takes 1-2 minutes...', 0, 10000, false)
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1) --So chat message displays
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Decide how accurate map related functions are to be based on the map size:
    SetupPlayableAreaAndSegmentSizes()

    --Generate pathing
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; system time='..GetSystemTimeSecondsOnlyForProfileUse()..'; will generate navmesh if it isnt already generated, NavUtils.IsGenerated()='..tostring(NavUtils.IsGenerated())) end
    if not(NavUtils.IsGenerated()) then
        --local NavGen = import("/lua/sim/navgenerator.lua")
        --NavGen.Generate()
        NavUtils.Generate()
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1) --Redundancy so chat message displays
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    GetMapWaterHeight()

    --Create table that stores details for each pathing group (e.g. land, amphibious) each mex in that group for easy reference later
    RecordMexForPathingGroup()

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1) --want to make sure our chat message displays (redundancy as moved to earlier now)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Create table with details on all plateaus (initially just those with mexes, although the land zone logic may add to this)
    RecordAllPlateaus() --Needed first since will organise land zones by plateau

    --Setup land zones
    SetupLandZones()

    RecordIslands()
    RecordPondDetails()

    bMapLandSetupComplete = true
    if bDebugMessages == true then LOG(sFunctionRef..': Finished setting up land aspects of the map, will move on to water zones, time='..GetGameTimeSeconds()..'; system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    SetupWaterZones() --Includes a wait to make sure we have M28 brains
    if bDebugMessages == true then LOG(sFunctionRef..': Finished setting up water zones, will also now clal forked threads for other aspects, time='..GetGameTimeSeconds()..'; system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    ForkThread(ClearTemporarySetupVariables)
    ForkThread(ReclaimManager)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

--function GetDistanceFromStartAdjustedForDistanceFromMid()  end -- have replaced with GetModDistanceFromStart
function GetModDistanceFromStart(aiBrain, tTarget, bUseEnemyStartInstead)
    local sFunctionRef = 'GetModDistanceFromStart'
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Start of code, GameTime=' .. GetGameTimeSeconds() .. '; aiBrain army index=' .. aiBrain:GetArmyIndex() .. '; tTarget=' .. repru(tTarget) .. '; bUseEnemyStartInstead=' .. tostring((bUseEnemyStartInstead or false)) .. '; will draw the location in white')
        M28Utilities.DrawLocation(tTarget, false, 7, 20, nil)
    end

    local iEmergencyRangeToUse = 50

    local tStartPos
    local tEnemyBase
    if bUseEnemyStartInstead then
        tStartPos = GetPrimaryEnemyBaseLocation(aiBrain)
        tEnemyBase = PlayerStartPoints[aiBrain:GetArmyIndex()]
    else
        tStartPos = PlayerStartPoints[aiBrain:GetArmyIndex()]
        tEnemyBase = GetPrimaryEnemyBaseLocation(aiBrain)
    end

    local iDistStartToTarget = M28Utilities.GetDistanceBetweenPositions(tStartPos, tTarget)
    if bDebugMessages == true then LOG(sFunctionRef .. ': tStartPos=' .. repru(tStartPos) .. '; iDistStartToTarget=' .. iDistStartToTarget .. '; iEmergencyRangeToUse=' .. iEmergencyRangeToUse) end

    if iDistStartToTarget <= iEmergencyRangeToUse then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        if bDebugMessages == true then LOG(sFunctionRef .. ': Are within emergency range so will just return actual dist, iDistStartToTarget=' .. iDistStartToTarget .. '; if instead we only had 1 enemy and got mod dist for this the result would be ' .. math.cos(math.abs(M28Utilities.ConvertAngleToRadians(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, GetPrimaryEnemyBaseLocation(aiBrain))))) * iDistStartToTarget) end

        return iDistStartToTarget
    else
        --If only 1 enemy group then treat anywhere behind us as the emergency range
        if bUseEnemyStartInstead then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            if bDebugMessages == true then LOG(sFunctionRef .. ': will ignore multiple enemies since have flagged to use enemy start instead, will return ' .. math.cos(M28Utilities.ConvertAngleToRadians(math.abs(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, PlayerStartPoints[aiBrain:GetArmyIndex()])))) * iDistStartToTarget) end

            return iEmergencyRangeToUse, math.cos(math.abs(M28Utilities.ConvertAngleToRadians(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, tEnemyBase)))) * iDistStartToTarget
        else
            local bIsBehindUs = true
            if bDebugMessages == true then LOG(sFunctionRef .. ': Is table of enemy brains empty=' .. tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains]))) end

            if M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains]) then
                if M28Utilities.GetDistanceBetweenPositions(tTarget, tEnemyBase) < M28Utilities.GetDistanceBetweenPositions(tStartPos, tEnemyBase) or M28Utilities.GetDistanceBetweenPositions(tTarget, tStartPos) > M28Utilities.GetDistanceBetweenPositions(tStartPos, tEnemyBase) then
                    bIsBehindUs = false
                end
            else
                for iEnemyGroup, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains] do
                    if bDebugMessages == true then LOG(sFunctionRef .. ': Distance from target to start=' .. M28Utilities.GetDistanceBetweenPositions(tTarget, tStartPos) .. '; Distance from start to enemy base=' .. M28Utilities.GetDistanceBetweenPositions(tStartPos, PlayerStartPoints[oBrain:GetArmyIndex()])) end

                    if M28Utilities.GetDistanceBetweenPositions(tTarget, PlayerStartPoints[oBrain:GetArmyIndex()]) < M28Utilities.GetDistanceBetweenPositions(tStartPos, PlayerStartPoints[oBrain:GetArmyIndex()]) or M28Utilities.GetDistanceBetweenPositions(tTarget, tStartPos) > M28Utilities.GetDistanceBetweenPositions(tStartPos, PlayerStartPoints[oBrain:GetArmyIndex()]) then
                        bIsBehindUs = false
                        break
                    end
                end
            end

            if bIsBehindUs then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                if bDebugMessages == true then LOG(sFunctionRef .. ': Will return emergency range as enemy is behind us, so returning ' .. iEmergencyRangeToUse) end

                return iEmergencyRangeToUse
            else
                --Cycle through each enemy group and get lowest value, but stop if <= emergency range
                local iCurDist
                local iLowestDist = 10000
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains]) then
                    iLowestDist = math.cos(M28Utilities.ConvertAngleToRadians(math.abs(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, tEnemyBase)))) * iDistStartToTarget
                else
                    for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains] do
                        iCurDist = math.cos(M28Utilities.ConvertAngleToRadians(math.abs(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, PlayerStartPoints[oBrain:GetArmyIndex()])))) * iDistStartToTarget
                        if bDebugMessages == true then LOG(sFunctionRef .. ': iCurDist for enemy oBrain index ' .. oBrain:GetArmyIndex() .. ' = ' .. iCurDist .. '; Enemy base=' .. repru(PlayerStartPoints[oBrain:GetArmyIndex()]) .. '; tEnemyBase=' .. repru(tEnemyBase) .. '; Angle from start to target=' .. M28Utilities.GetAngleFromAToB(tStartPos, tTarget) .. '; Angle from Start to enemy base=' .. M28Utilities.GetAngleFromAToB(tStartPos, PlayerStartPoints[oBrain:GetArmyIndex()]) .. '; iDistStartToTarget=' .. iDistStartToTarget) end

                        if iCurDist < iLowestDist then
                            iLowestDist = iCurDist
                            if iLowestDist < iEmergencyRangeToUse then
                                iLowestDist = iEmergencyRangeToUse
                                break
                            end
                        end
                    end
                end

                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                if bDebugMessages == true then LOG(sFunctionRef .. ': iLowestDist=' .. iLowestDist) end

                return iLowestDist
            end
        end
    end
end

function RecordAvailableMassStorageLocationsForLandZone(iPlateau, iLandZone)
    local tLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
    tLZData[subrefLZMassStorageLocationsAvailable] = {}
    if M28Utilities.IsTableEmpty(tLZData[subrefLZMexLocations]) == false then
        local tiXZOffset = {{-2,0}, {0, -2}, {0, 2}, {2, 0}}
        local tCurPos
        for iMex, tMex in tLZData[subrefLZMexLocations] do
            for iOffset, tXZOffset in tiXZOffset do
                tCurPos = {tMex[1] + tXZOffset[1], 0, tMex[3] + tXZOffset[2]}
                tCurPos[2] = GetSurfaceHeight(tCurPos[1], tCurPos[3])
                if M28Conditions.CanBuildStorageAtLocation(tCurPos) then
                    table.insert(tLZData[subrefLZMassStorageLocationsAvailable], tCurPos)
                end
            end
        end
    end
end

function RecordMassStorageLocationsForEachLandZone()
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLZSubtable in tPlateauSubtable[subrefPlateauLandZones] do
            RecordAvailableMassStorageLocationsForLandZone(iPlateau, iLandZone)
        end
    end
end


function GetReclaimLocationFromSegment(iReclaimSegmentX, iReclaimSegmentZ)
    --e.g. segment (1,1) will be 0 to ReclaimSegmentSizeX and 0 to ReclaimSegmentSizeZ in size
    --This will return the midpoint
    local iX = math.max(rMapPlayableArea[1], math.min(rMapPlayableArea[3], (iReclaimSegmentX - 0.5) * iReclaimSegmentSizeX))
    local iZ = math.max(rMapPlayableArea[2], math.min(rMapPlayableArea[4], (iReclaimSegmentZ - 0.5) * iReclaimSegmentSizeZ))
    return {iX, GetSurfaceHeight(iX, iZ), iZ}
end

function GetReclaimSegmentsFromLocation(tLocation)
    return math.ceil(tLocation[1] / iReclaimSegmentSizeX), math.ceil(tLocation[3] / iReclaimSegmentSizeZ)
end

function ReclaimManager()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'ReclaimManager'

    local tAreasToUpdateThisCycle
    local iUpdateCount = 0
    local iMaxUpdatesPerTick
    local iWaitCount
    local iLoopCount
    if not(bReclaimManagerActive) then
        bReclaimManagerActive = true
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart) --Want the profile coutn to reflect the number of times actually running the core code

        while bReclaimManagerActive do
            if bDebugMessages == true then LOG(sFunctionRef..': Start of main active loop') end

            tAreasToUpdateThisCycle = {}
            iUpdateCount = 0
            iWaitCount = 0
            if M28Utilities.IsTableEmpty(tReclaimSegmentsToUpdate) then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(10)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            else
                --Copy table into tAreasToUpdateThisCycle
                if bDebugMessages == true then
                    LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..'; Will list out all entries in tReclaimSegmentsToUpdate if it isnt nil')
                    if tReclaimSegmentsToUpdate then LOG(repru(tReclaimSegmentsToUpdate)) end
                end
                for iEntry, tSubtable in tReclaimSegmentsToUpdate do
                    if (tSubtable[2] or 0) > 0 and (tSubtable[1] or 0) > 0 then --Dont bother updating places right on map edge in case pathfinding issue
                        if not(tAreasToUpdateThisCycle[tSubtable[1]]) then tAreasToUpdateThisCycle[tSubtable[1]] = {} end
                        if not(tAreasToUpdateThisCycle[tSubtable[1]][tSubtable[2]]) then
                            iUpdateCount = iUpdateCount + 1
                            tAreasToUpdateThisCycle[tSubtable[1]][tSubtable[2]] = true
                        end
                    end
                end
                --Clear the table for the next cycle
                tReclaimSegmentsToUpdate = {}
                if iUpdateCount == 0 then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(10)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                else
                    iMaxUpdatesPerTick = math.max(5, math.min(20, math.ceil(iUpdateCount / 10)))
                    iLoopCount = 0
                    if bDebugMessages == true then LOG(sFunctionRef..': About to update for iUpdateCount='..iUpdateCount..' entries; max updates per tick='..iMaxUpdatesPerTick..'; tAreasToUpdateThisCycle='..repru(tAreasToUpdateThisCycle)) end
                    for iSegmentX, tSubtable1 in tAreasToUpdateThisCycle do
                        for iSegmentZ, tSubtable2 in tAreasToUpdateThisCycle[iSegmentX] do
                            iLoopCount = iLoopCount + 1
                            if iLoopCount > iMaxUpdatesPerTick then
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                WaitTicks(1)
                                iWaitCount = iWaitCount + 1
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                                iLoopCount = 1
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': About to update reclaim data for segments '..iSegmentX..'-'..iSegmentZ) end
                            UpdateReclaimDataNearSegments(iSegmentX, iSegmentZ, 0, nil)
                        end
                    end
                    if iWaitCount < 10 then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(10 - iWaitCount)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function CreateReclaimSegment(iReclaimSegmentX, iReclaimSegmentZ)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'CreateReclaimSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ] = {}
    tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint] = GetReclaimLocationFromSegment(iReclaimSegmentX, iReclaimSegmentZ)
    --tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refsSegmentMidpointLocationRef] = M28Utilities.ConvertLocationToReference(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint])
    local iPlateau, iLandZone = GetPlateauAndLandZoneReferenceFromPosition(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint])
    if (iPlateau or 0) == 0 then
        --If we get the reclaim location, is it in a pathable area, or within 2 of a pathable area?
        local rRect = M28Utilities.GetRectAroundLocation(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint], iReclaimSegmentSizeX * 0.5)
        local tReclaimables = GetReclaimInRectangle(4, rRect)
        if M28Utilities.IsTableEmpty(tReclaimables) == false then
            local iCurPlateau, iCurLandZone
            local tiXZOffset = {{-2,-2}, {-2, 2}, {2, -2}, {2, 2}}
            for iReclaim, oReclaim in tReclaimables do
                iCurPlateau, iCurLandZone = GetPlateauAndLandZoneReferenceFromPosition(oReclaim.CachePosition)
                if (iCurPlateau or 0) == 0 then
                    --Search nearby
                    for _, tiXZAdjust in tiXZOffset do
                        iCurPlateau, iCurLandZone = GetPlateauAndLandZoneReferenceFromPosition({oReclaim.CachePosition[1] + tiXZAdjust[1], oReclaim.CachePosition[2], oReclaim.CachePosition[3] + tiXZAdjust[2]})
                        if (iCurPlateau or 0) > 0 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Reclaim location '..repru(oReclaim.CachePosition)..' isnt pathable but if we adjust by '..repru(tiXZAdjust)..' then it becomes pathable, adjusted position='..repru({oReclaim.CachePosition[1] + tiXZAdjust[1], oReclaim.CachePosition[2], oReclaim.CachePosition[3] + tiXZAdjust[2]})..'; iCurPlateau='..iCurPlateau..'; iCurLandZone='..(iCurLandZone or 'nil')) end
                            break
                        end
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Reclaim midpoint '..repru(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint])..' isnt pathable but the reclaim position itself, '..repru(oReclaim.CachePosition)..' is pathable, iCurPlateau='..iCurPlateau..'; iCurLandZone='..(iCurLandZone or 'nil')) end
                end
                if (iCurPlateau or 0) > 0 then
                    iPlateau = iCurPlateau
                    iLandZone = iCurLandZone
                    break
                end
            end
        end

    end
    if bDebugMessages == true then LOG(sFunctionRef..': Adding iReclaimSegmentX-Z'..iReclaimSegmentX..'-'..iReclaimSegmentZ..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
    if (iLandZone or 0) > 0 then
        --Record in the land zone
        if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefReclaimSegments]) then tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefReclaimSegments] = {} end
        table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefReclaimSegments], {iReclaimSegmentX, iReclaimSegmentZ})
        if bDebugMessages == true then
            LOG(sFunctionRef..': Finished adding reclaim segment to LZ, all reclaim segments for this LZ='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefReclaimSegments]))
            local rCurRect = M28Utilities.GetRectAroundLocation(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint], iReclaimSegmentSizeX * 0.5)
            M28Utilities.DrawRectangle(rCurRect, 4)
        end
    elseif (iPlateau or 0) > 0 then
        --Record in the water zone
        local iWaterZone = GetWaterZoneFromPosition(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint])
        if (iWaterZone or 0) > 0 then
            local iPond = tiPondByWaterZone[iWaterZone]
            local tWZData = tPondDetails[iPond][subrefPondWaterZones][iWaterZone]
            if not(tWZData[subrefReclaimSegments]) then tWZData[subrefReclaimSegments] = {} end
            table.insert(tWZData[subrefReclaimSegments], {iReclaimSegmentX, iReclaimSegmentZ})
            if bDebugMessages == true then
                LOG(sFunctionRef..': Finished adding reclaim segment to WZ, all reclaim segments for this WZ='..repru(tWZData[subrefReclaimSegments]))
                local rCurRect = M28Utilities.GetRectAroundLocation(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint], iReclaimSegmentSizeX * 0.5)
                M28Utilities.DrawRectangle(rCurRect, 4)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshLandOrWaterZoneReclaimValue(iPlateauOrPond, iLandOrWaterZone, bIsWaterZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RefreshLandOrWaterZoneReclaimValue'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tLZOrWZData
    if bIsWaterZone then tLZOrWZData = tPondDetails[iPlateauOrPond][subrefPondWaterZones][iLandOrWaterZone]
    else
        tLZOrWZData = tAllPlateaus[iPlateauOrPond][subrefPlateauLandZones][iLandOrWaterZone]
    end
    tLZOrWZData[subrefLastReclaimRefresh] = GetGameTimeSeconds()
    local iMassReclaim = 0
    local iEnergyReclaim = 0
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; bIsWaterZone='..tostring(bIsWaterZone or false)..'; Considering PlateauOrPond='..iPlateauOrPond..'; iLandOrWaterZone='..iLandOrWaterZone..'; Is table of LZ or WZ reclaim segments empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[subrefReclaimSegments]))) end
    if M28Utilities.IsTableEmpty(tLZOrWZData[subrefReclaimSegments]) == false then
        for iSegmentCount, tSegmentXZ in tLZOrWZData[subrefReclaimSegments] do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering tSegmentXZ='..tSegmentXZ[1]..'-'..tSegmentXZ[2]..'; total mass in this segment='..tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][refReclaimTotalMass]) end
            iMassReclaim = iMassReclaim + tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][refReclaimTotalMass]
            iEnergyReclaim = iEnergyReclaim + tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][refReclaimTotalEnergy]
        end
    end
    tLZOrWZData[subrefTotalMassReclaim] = iMassReclaim
    tLZOrWZData[subrefTotalEnergyReclaim] = iEnergyReclaim
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iMassReclaim='..iMassReclaim..'; LZ reclaim='..tLZOrWZData[subrefTotalMassReclaim]) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetReclaimablesMassAndEnergy(tReclaimables, iMinMass, iMinEnergy)
    --Largely a copy of GetReclaimablesResourceValue, but focused specificaly on the reclaim segment update logic
    --Must have at least iMinMass or iMinEnergy to be recorded
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetReclaimablesMassAndEnergy'
    --V14 and earlier would modify total mass value to reduce it by 25% if its small, and 50% if its medium; v15 removed this
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local sMassRef = 'MaxMassReclaim'
    local sEnergyRef = 'MaxEnergyReclaim'

    local tWreckPos = {}
    local iTotalMass = 0
    local iTotalEnergy = 0

    local iLargestCurReclaim = 0
    local iLargestReclaimRef = 0

    if tReclaimables and table.getn( tReclaimables ) > 0 then
        for iReclaimRef, v in tReclaimables do
            tWreckPos = v.CachePosition
            if tWreckPos[1] then
                --if v.MaxMassReclaim > iIgnoreReclaimIfNotMoreThanThis then
                if v[sMassRef] > iMinMass or v[sEnergyRef] > iMinEnergy then
                    if not(v:BeenDestroyed()) then
                        iTotalMass = iTotalMass + v[sMassRef]
                        iTotalEnergy = iTotalEnergy + v[sEnergyRef]
                        if v[sMassRef] > iLargestCurReclaim then
                            iLargestCurReclaim = v[sMassRef]
                            iLargestReclaimRef = iReclaimRef
                        end
                    end
                end
            else
                if not(v.MaxMassReclaim == nil) then
                    if v.MaxMassReclaim > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Warning - have ignored wreck location despite it having a mass reclaim value') end
                    end
                end
            end
        end
    end
    local tReclaimPos
    if iLargestReclaimRef then tReclaimPos = {tReclaimables[iLargestReclaimRef][1], tReclaimables[iLargestReclaimRef][2], tReclaimables[iLargestReclaimRef][3]} end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iTotalMass, tReclaimPos, iLargestCurReclaim, iTotalEnergy
end

function UpdateReclaimDataNearSegments(iBaseSegmentX, iBaseSegmentZ, iSegmentRange)
    --Updates reclaim data for all segments within iSegmentRange of tLocation

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'UpdateReclaimDataNearSegments'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart) --Want the profile coutn to reflect the number of times actually running the core code

    local iMinValueOfIndividualReclaim = 2.5
    local iMinEnergyValue = 15

    local iTotalMassValue, tReclaimables, iLargestCurReclaim, tReclaimPos, iTotalEnergyValue
    local iCumulativeMassValue = 0

    if bDebugMessages == true then
        LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; About to update for iBaseSegmentX='..(iBaseSegmentX or 'nil')..'; iSegmentRange='..(iSegmentRange or 'nil')..'; iBaseSegmentZ='..(iBaseSegmentZ or 'nil'))
    end

    local iPlateau, iLandZone

    for iCurX = iBaseSegmentX - iSegmentRange, iBaseSegmentX + iSegmentRange do
        for iCurZ = iBaseSegmentZ - iSegmentRange, iBaseSegmentZ + iSegmentRange do
            iTotalMassValue = 0
            tReclaimables = GetReclaimablesInRect(Rect((iCurX - 1) * iReclaimSegmentSizeX, (iCurZ - 1) * iReclaimSegmentSizeZ, iCurX * iReclaimSegmentSizeX, iCurZ * iReclaimSegmentSizeZ))
            iLargestCurReclaim = 0

            if bDebugMessages == true then LOG(sFunctionRef..': iCurX='..iCurX..'; iCurZ='..iCurZ..'; iReclaimSegmentSizeX='..iReclaimSegmentSizeX..'; iReclaimSegmentSizeZ='..iReclaimSegmentSizeZ..'; Reclaim search rect='..repru(Rect((iCurX - 1) * iReclaimSegmentSizeX, (iCurZ - 1) * iReclaimSegmentSizeZ, iCurX * iReclaimSegmentSizeX, iCurZ * iReclaimSegmentSizeZ))..'; Is tReclaimables empty='..tostring(M28Utilities.IsTableEmpty(tReclaimables))) end

            if tReclaimables and table.getn( tReclaimables ) > 0 then
                -- local iWreckCount = 0
                --local bIsProp = nil  --only used for log/testing
                if bDebugMessages == true then LOG('Have wrecks within the segment iCurXZ='..iCurX..'-'..iCurZ) end
                iTotalMassValue, tReclaimPos, iLargestCurReclaim, iTotalEnergyValue = GetReclaimablesMassAndEnergy(tReclaimables, iMinValueOfIndividualReclaim, iMinEnergyValue)
                --Record this table:
                if tReclaimAreas[iCurX] == nil then
                    tReclaimAreas[iCurX] = {}
                    if bDebugMessages == true then LOG('Setting table to nothing as is currently nil; iCurX='..iCurX) end
                end
                if tReclaimAreas[iCurX][iCurZ] == nil then
                    CreateReclaimSegment(iCurX, iCurZ)
                end
                --tReclaimAreas[iCurX][iCurZ][refiReclaimTotalPrev] = (tReclaimAreas[iCurX][iCurZ][refReclaimTotalMass] or 0)
                tReclaimAreas[iCurX][iCurZ][refReclaimTotalMass] = iTotalMassValue
                --tReclaimAreas[iCurX][iCurZ][refReclaimHighestIndividualReclaim] = iLargestCurReclaim
                --iHighestReclaimInASegment = math.max(iHighestReclaimInASegment, iTotalMassValue)
                tReclaimAreas[iCurX][iCurZ][refReclaimTotalEnergy] = iTotalEnergyValue
                iPlateau, iLandZone = GetPlateauAndLandZoneReferenceFromPosition(tReclaimAreas[iCurX][iCurZ][refReclaimSegmentMidpoint])
                if bDebugMessages == true then LOG(sFunctionRef..': Reclaim segment midpoint='..repru(tReclaimAreas[iCurX][iCurZ][refReclaimSegmentMidpoint])..'; iPlateau for this='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
                if iLandZone > 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Time of last refresh for land zone '..iLandZone..'='.. (tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLastReclaimRefresh] or 0)) end
                    if GetGameTimeSeconds() - (tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLastReclaimRefresh] or 0) >= 1 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will refresh the reclaim value for land zone '..iLandZone) end
                        RefreshLandOrWaterZoneReclaimValue(iPlateau, iLandZone)
                    end
                else
                    local iWaterZone = GetWaterZoneFromPosition(tReclaimAreas[iCurX][iCurZ][refReclaimSegmentMidpoint])
                    if (iWaterZone or 0) > 0 then
                        local iPond = tiPondByWaterZone[iWaterZone]
                        if bDebugMessages == true then LOG(sFunctionRef..': Time of last refresh for water zone '..iWaterZone..'='.. (tPondDetails[iPond][subrefPondWaterZones][iWaterZone][subrefLastReclaimRefresh] or 0)) end
                        if GetGameTimeSeconds() - (tPondDetails[iPond][subrefPondWaterZones][iWaterZone][subrefLastReclaimRefresh] or 0) >= 1 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will refresh the reclaim value for land zone '..iLandZone) end
                            RefreshLandOrWaterZoneReclaimValue(iPond, iWaterZone, true)
                        end
                    end
                end


            end
            iCumulativeMassValue = iCumulativeMassValue + iTotalMassValue
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iCumulativeMassValue='..iCumulativeMassValue..'; SystemTime='..GetSystemTimeSecondsOnlyForProfileUse()) end

    --M28Profiler.tiProfilerEndCountByFunction[sFunctionRef] = (M28Profiler.tiProfilerStartCountByFunction[sFunctionRef] or 0) + 1 LOG(sFunctionRef..': M28Profiler.tiProfilerEndCountByFunction[sFunctionRef]='..M28Profiler.tiProfilerEndCountByFunction[sFunctionRef])
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iCumulativeMassValue
end

function RecordThatWeWantToUpdateReclaimAtLocation(tLocation, iNearbySegmentsToUpdate)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RecordThatWeWantToUpdateReclaimAtLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if iReclaimSegmentSizeX == 0 then
        M28Utilities.ErrorHandler('Dont have a reclaim segment size specified, will set it to 8.5, but something else has likely gone wrong')
        iReclaimSegmentSizeX = 8.5
        iReclaimSegmentSizeZ = 8.5
    end
    local iReclaimSegmentX, iReclaimSegmentZ = GetReclaimSegmentsFromLocation(tLocation)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time='..GetGameTimeSeconds()..'; tLocation='..repru(tLocation)..'; iReclaimSegmentX-Z='..iReclaimSegmentX..'-'..iReclaimSegmentZ) end
    if iReclaimSegmentX >= 10000 or iNearbySegmentsToUpdate >= 10000 or iReclaimSegmentZ >= 10000 then M28Utilities.ErrorHandler('Likely infinite loop about to start. iReclaimSegmentX='..(iReclaimSegmentX or 'nil')..'; iNearbySegmentsToUpdate='..(iNearbySegmentsToUpdate or 'nil')..'; iReclaimSegmentSizeX='..(iReclaimSegmentSizeX or 'nil')..'; iReclaimSegmentSizeZ='..(iReclaimSegmentSizeX or 'nil')..'; rMapPlayableArea='..repru(rMapPlayableArea or {'nil'})..'; iMaxSegmentInterval='..(iMaxSegmentInterval or 'nil'))
    else

        if iNearbySegmentsToUpdate then
            for iSegmentX = iReclaimSegmentX - iNearbySegmentsToUpdate, iReclaimSegmentX + iNearbySegmentsToUpdate do
                for iSegmentZ = iReclaimSegmentZ - iNearbySegmentsToUpdate, iReclaimSegmentZ + iNearbySegmentsToUpdate do
                    if bDebugMessages == true then LOG(sFunctionRef..': Will record that we want to update the reclaim segment XZ='..iSegmentX..'-'..iSegmentZ) end
                    RecordThatWeWantToUpdateReclaimSegment(iSegmentX, iSegmentZ)
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Will record that we want to update the base reclaim segment XZ='..iReclaimSegmentX..'-'..iReclaimSegmentZ) end
            RecordThatWeWantToUpdateReclaimSegment(iReclaimSegmentX, iReclaimSegmentZ)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordThatWeWantToUpdateReclaimSegment(iReclaimSegmentX, iReclaimSegmentZ)
    if iReclaimSegmentX >= 0 and iReclaimSegmentZ >= 0 then table.insert(tReclaimSegmentsToUpdate, {iReclaimSegmentX, iReclaimSegmentZ}) end
end


function GetTravelDistanceBetweenLandZones(iPlateau, iStartLZ, iEndLZ)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetTravelDistanceBetweenLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tStartLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLZ]
    if not(tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau][iEndLZ]) then
        if not(tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau]) then tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau] = {} end
        tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau][iEndLZ] = M28Utilities.GetTravelDistanceBetweenPositions(tStartLZData[subrefLZMidpoint], tAllPlateaus[iPlateau][subrefPlateauLandZones][iEndLZ][subrefLZMidpoint], refPathingTypeLand)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Travel distance from iStartLZ='..iStartLZ..' to iEndLZ='..iEndLZ..' is '..(tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau][iEndLZ] or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau][iEndLZ]
end


function GetPositionAtOrNearTargetInPathingGroup(tStartPos, tTargetPos, iDistanceFromTargetToStart, iAngleAdjust, oPathingUnit, bMoveCloserBeforeFurtherIfBlocked, bCheckIfExistingTargetIsBetter, iMinDistanceFromExistingCommandTarget)
    --Intended as a rewriting of GetPositionNearTargetInSamePathingGroup due to some inconsistencies arising with the below, to make use of new logic that allows any angle; introduced from v15
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPositionAtOrNearTargetInPathingGroup'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Get angle from target to start
    local iAngleFromTargetToStart = M28Utilities.GetAngleFromAToB(tTargetPos, tStartPos) + (iAngleAdjust or 0)
    --Get initial desired position
    local tPossibleTarget = M28Utilities.MoveInDirection(tTargetPos, iAngleFromTargetToStart, iDistanceFromTargetToStart)
    local sPathing = M28UnitInfo.GetUnitPathingType(oPathingUnit)
    local iPathingGroupWanted = NavUtils.GetLabel(sPathing, tTargetPos)
    local iPathingGroupOfPossibleTarget = NavUtils.GetLabel(sPathing, tPossibleTarget)
    local bCanPathToTarget = false

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code; oPathingUnit='..oPathingUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPathingUnit)..'; tTargetPos='..repru(tTargetPos)..'; iAngleAdjust ='..iAngleAdjust..'; iDistanceFromTargetToStart='..iDistanceFromTargetToStart..'; tStartPos='..repru(tStartPos)..'; iPathingGroupOfPossibleTarget='..iPathingGroupOfPossibleTarget..'; iPathingGroupWanted='..iPathingGroupWanted..'; Angle from start to target='..M28Utilities.GetAngleFromAToB(tStartPos, tTargetPos)..'; iAngleFromTargetToStart='..iAngleFromTargetToStart..'; Amphibious group of target position='..NavUtils.GetLabel(refPathingTypeHover, tTargetPos)..'; Amphib group of our base='..NavUtils.GetLabel(refPathingTypeHover, PlayerStartPoints[oPathingUnit:GetAIBrain():GetArmyIndex()])..'; tPossibleTarget before adjust='..repru(tPossibleTarget)..'; Distance between possible target and tTargetPos='..M28Utilities.GetDistanceBetweenPositions(tPossibleTarget, tTargetPos)) end
    --Find a target we can path to
    if iPathingGroupOfPossibleTarget == iPathingGroupWanted then
        bCanPathToTarget = true
    else
        --Dif pathing group, need to try alternatives; first try the target itself
        if not(bMoveCloserBeforeFurtherIfBlocked == false) then
            tPossibleTarget = {tTargetPos[1], tTargetPos[2], tTargetPos[3]}
            iPathingGroupOfPossibleTarget = NavUtils.GetLabel(sPathing, tPossibleTarget)
            if bDebugMessages == true then LOG(sFunctionRef..': Pathing group if just try target position='..iPathingGroupOfPossibleTarget) end
            if iPathingGroupOfPossibleTarget == iPathingGroupWanted then
                bCanPathToTarget = true
            end
        end

        if bCanPathToTarget == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Cant path to the initial expected point so will try nearby points') end
            local tDistanceFactors
            if bMoveCloserBeforeFurtherIfBlocked then
                tDistanceFactors = {0.5, 1.5, 3}
            else tDistanceFactors = {1.25, 3}
            end
            local tAngleVariations = {-45, 0, 45}
            --Make sure we have at least some distance we're moving away from
            if iDistanceFromTargetToStart == 0 then iDistanceFromTargetToStart = 1 end

            if math.abs(iDistanceFromTargetToStart) < 4 then
                local iFactorIncrease = 4 / iDistanceFromTargetToStart
                for iDistanceFactor = 1, table.getn(tDistanceFactors) do
                    tDistanceFactors[iDistanceFactor] = tDistanceFactors[iDistanceFactor] * iFactorIncrease
                end
            end
            for iDistanceFactor = 1, table.getn(tDistanceFactors) do
                for iAngleAlternative = 1, table.getn(tAngleVariations) do
                    tPossibleTarget = M28Utilities..MoveInDirection(tTargetPos, iAngleFromTargetToStart + tAngleVariations[iAngleAlternative], iDistanceFromTargetToStart * tDistanceFactors[iDistanceFactor])
                    if NavUtils.GetLabel(sPathing, tPossibleTarget) == iPathingGroupWanted then
                        bCanPathToTarget = true
                        break
                    end
                end
                if bCanPathToTarget then break end
                if bDebugMessages == true then LOG(sFunctionRef..': iDistanceFactor='..iDistanceFactor..'; tPossibleTarget based on the last of the angle variations='..repru(tPossibleTarget)..'; still cant path to the target so will keep looking') end
            end
        end

    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if can path to target, bCanPathToTarget='..tostring(bCanPathToTarget)..'; tPossibleTarget='..repru(tPossibleTarget)) end

    if bCanPathToTarget then
        --Consider if the target meets any other values specified (e.g. if must be certain distance away from current target or unit)
        if bCheckIfExistingTargetIsBetter == true or iMinDistanceFromExistingCommandTarget then
            if bDebugMessages == true then LOG(sFunctionRef..': Checking against existing target to see if thats better') end
            if oPathingUnit.GetNavigator then
                local oNavigator = oPathingUnit:GetNavigator()
                if oNavigator.GetCurrentTargetPos then
                    local tExistingTargetPos = oNavigator:GetCurrentTargetPos()
                    if M28Utilities.IsTableEmpty(tExistingTargetPos) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': tExistingTargetPos='..repru(tExistingTargetPos)..'; Distance to possible target='..M28Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tPossibleTarget)..'; iMinDistanceFromExistingCommandTarget='..(iMinDistanceFromExistingCommandTarget or 'nil')..'; Pathing group of this='..NavUtils.GetLabel(sPathing, tExistingTargetPos)..'; Pathing group wanted='..iPathingGroupWanted..'; sPathing='..sPathing..'; Distance of existing position toa ctual target='..M28Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tTargetPos)) end
                        if NavUtils.GetLabel(sPathing, tExistingTargetPos) == iPathingGroupWanted then

                            --Do we have a minimum distance away from current target required?
                            if iMinDistanceFromExistingCommandTarget and M28Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tPossibleTarget) < iMinDistanceFromExistingCommandTarget then
                                if bDebugMessages == true then LOG(sFunctionRef..': Distance between existing target position and possible target position is less than the min distance; tExistingTargetPos='..repru(tExistingTargetPos)..'; tPossibleTarget='..repru(tPossibleTarget)) end
                                tPossibleTarget = tExistingTargetPos
                            else
                                --Is the existing target position closer to the distance required than the new position, factoring in if we want a negative position or not?
                                local iDistanceFromQueuedMoveLocationToTarget = M28Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tTargetPos)
                                local iDistanceFromPossibleTargetToTarget = M28Utilities.GetDistanceBetweenPositions(tPossibleTarget, tTargetPos)
                                --Are these further away from the start position than the actual target?
                                if math.abs(iDistanceFromQueuedMoveLocationToTarget - iDistanceFromTargetToStart) < math.abs(iDistanceFromPossibleTargetToTarget - iDistanceFromTargetToStart) then
                                    --Have we said we want to move closer if the initial point is blocked?
                                    if not(bMoveCloserBeforeFurtherIfBlocked) or iDistanceFromQueuedMoveLocationToTarget <= iDistanceFromTargetToStart then
                                        --Factor in we might be infront of the target and actually want to be behind
                                        local iDistanceFromStartToTarget = M28Utilities.GetDistanceBetweenPositions(tStartPos, tTargetPos)
                                        local iDistanceFromQueuedToStart = M28Utilities.GetDistanceBetweenPositions(tStartPos, tExistingTargetPos)
                                        if bDebugMessages == true then LOG(sFunctionRef..': iDistanceFromQueuedMoveLocationToTarget='..iDistanceFromQueuedMoveLocationToTarget..'; iDistanceFromPossibleTargetToTarget='..iDistanceFromPossibleTargetToTarget..'; iDistanceFromQueuedToStart='..iDistanceFromQueuedToStart..'; iDistanceFromStartToTarget='..iDistanceFromStartToTarget..'; iDistanceFromTargetToStart='..iDistanceFromTargetToStart) end
                                        if iDistanceFromQueuedToStart > 1 and ((iDistanceFromQueuedToStart < iDistanceFromStartToTarget and iDistanceFromTargetToStart > 0) or (iDistanceFromQueuedToStart > iDistanceFromStartToTarget and iDistanceFromTargetToStart < 0)) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Existing location is closer than the new possible location so go with this') end
                                            --Existing location is closer than the new location so go with this
                                            tPossibleTarget = tExistingTargetPos
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    else
        --This could be due to a pathfinding error, will just use the potential target
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code; tPossibleTarget='..repru(tPossibleTarget or {'nil'})..'; bCanPathToTarget='..tostring(bCanPathToTarget)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tPossibleTarget
end