---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 16/11/2022 07:22
---

local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local NavUtils = M28Utilities.NavUtils --import("/lua/sim/navutils.lua")
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Chat = import('/mods/M28AI/lua/AI/M28Chat.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Config = import('/mods/M28AI/lua/M28Config.lua')

bPlayableAreaSetup = false
bMapLandSetupComplete = false --set to true once have finished setting up map (used to decide how long to wait before starting main aibrain logic)
bWaterZoneInitialCreation = false --set to true once have finished code for recording water zones (note WZ setup wont be fully complete yet)
bWaterZoneFirstTeamInitialisation = false --set to true when the first team runs logic for creating team related variables for a water zone
bRecordedIslands = false
bIsCampaignMap = false --set at start of game
bFirstM28TeamHasBeenInitialised = false --set to true once we have run the teaminitialisation function
bIsLowMexMap = false --true if are dealing with a low mex map
bLowMexMapCheck = false --true if have checked if dealing with a low mex map

--Pathing types
--NavLayers 'Land' | 'Water' | 'Amphibious' | 'Hover' | 'Air'
refPathingTypeHover = 'Hover' --Amphibious is more restrictive so more likely to run into errors if base pathing on hover if enemy units then hover over it
refPathingTypeAmphibious = 'Amphibious' --Use sparingly - most logic uses hover instead of amphibious
refPathingTypeNavy = 'Water'
refPathingTypeAir = 'Air'
refPathingTypeLand = 'Land'
refPathingTypeNone = 'None'
refPathingTypeAll = {refPathingTypeHover, refPathingTypeNavy, refPathingTypeAir, refPathingTypeLand}

--Map size
rMapPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2} - Set at start of the game, use instead of the scenarioinfo method; note that x0 z0 is the top-left corner of the map
rMapPotentialPlayableArea = {0,0,256,256} --as above but is for campaigns where it will return the totla map size as the map may expand later
iMapSize = 256 -- Currently playable area only - average of the rmap playable area difs, e.g. 256 for a 5kmx5km, but smaller than this if its 2.5kmx5km
iMaxLandSegmentX = 1
iMaxLandSegmentZ = 1

iMapWaterHeight = 0 --Surface height of water on the map

--Resource information
tMassPoints = {} --[x] is an integer count, returns the location of a mass point; stores all mexes on the map
tHydroPoints = {} --[x] is an integer count, returns the location of a hydro point; stores all hydro points on the map
tMexByPathingAndGrouping = {} --Stores position of each mex based on the pathing group that it's part of; [a][b][c]: [a] = pathing type ('Land' etc.); [b] = Segment grouping; [c] = Mex position
tMexPathingLabelOverride = {} --[x] is the entry in tMassPoints, returns {iPlateauOverride, iIslandOverride, iPondOverride}
tHydroNearStart = {} --[x] is an integer count, records any hydro that we have recorded as being in a starting zone of any player (done so on high hydro maps we can avoid assigning these to zones again)

--Player start points
PlayerStartPoints = {} --Try to use M28Map.GetPlayerStartPosition(aiBrain) instead (improves campaign compatibility for where start positions arent in a valid zone); [x] is aiBrain army index, returns the start position {x,y,z}; Will be updated whenever a brain is created, index is the army index, i.e. do PlayerStartPoints[aiBrain:GetArmyIndex()] to get a table {x,y,z} that is the army's start position; more convenient than aiBrain:GetArmyStartPos() which returns x and z values but not as a table


--Reclaim info (non-LZ/plateau specific):
bReclaimManagerActive = false --used to spread updates of reclaim areas over each second
tReclaimSegmentsToUpdate = {} --[n] where n is the count, returns {segmentX,segmentZ} as value; i.e. update by using table.insert
tiVeryHighValueReclaimSegments = {} --[x] = 1,2,3...; returns {SegmentX, SegmentZ}
iVeryHighReclaimThreshold = 10000 --Will record any segemnts with at least this much reclaim in tiVeryHighValueReclaimSegments
tReclaimAreas = {} --Stores reclaim info for each segment: tReclaimAreas[iSegmentX][iSegmentZ][x]
    refReclaimTotalMass = 1
    refReclaimSegmentMidpoint = 2
    refReclaimHighestIndividualMassReclaim = 3
    refReclaimTotalSignificantMass = 4 --Total mass avlue of wrecks with a mass value above a hardcoded threshold (e.g. 10) so can ignore the distortion from trees
    refSegmentReclaimTotalEnergy = 8
iSignificantMassThreshold = 10 --global variable (not part of above table), being the threshold for recording mass reclaim as significant mass
iLowestMassThreshold = 0.8 --E.g. covers some but not all individual trees on twin rivers; wont record any mass value for wrecks below this when updating segment info
tiPlateauAndZonesToRefreshReclaimAgain = {} --[x] is the plateau or zero for water, [y] is 1,2,3....z, and returns the land/water zone
--reftReclaimTimeOfLastEngineerDeathByArmyIndex = 4 --Table: [a] where a is the army index, and it returns the time the last engineer died
    --refReclaimTimeLastEnemySightedByArmyIndex = 5
    --refsSegmentMidpointLocationRef = 6
    --refiReclaimTotalPrev = 7 --Previous total reclaim mass in a segment

--tLastReclaimRefreshByGroup = {} --time that last refreshed reclaim positions for [x] group
--iLastReclaimRefresh = 0 --stores time that last refreshed reclaim positions
--refiLastRefreshOfReclaimAreasOfInterest = 'M28MapLastRefreshOfReclaim'
--refiTotalReclaimAreasOfInterestByPriority = 'M28MapReclaimAreasOfInterestCount' --[1] = total for priority 1, etc.; up to 4 priority
--reftReclaimAreasOfInterest = 'M28MapReclaimAreasOfInterest' --assigned to aiBrain, [1] = priority (1, 2, 3); [2] = {segmentx, segmentz}
--reftReclaimAreaPriorityByLocationRef = 'M28MapReclaimAreaPriorityByLocationRef' --key is location ref
iReclaimSegmentSizeX = 0 --Updated separately
iReclaimSegmentSizeZ = 0 --Updated separately
--iReclaimAreaOfInterestTickCount = 0 --Updated as part of may reclaim update loop, used to avoid excessive load on an individual tick
--bReclaimRefreshActive = false --Used to avoid duplciating reclaim update logic



--Plateaus - core (NOTE: Some of these variables wont work for a plateau that has no mexes)
tPathingPlateauAndLZOverride = {} --Global, Pathing override where no plateau recognised; key is [math.floor(x)][math.floor(z)] and returns {iPlateau, iLandZone}
tbTempConsideredLandPathingForLZ = {} --Global, used to track if we have considered land pathing for this LZ as part of the initial LZ setup
tNearestPlateauOrZeroAndZoneSegmentOverride = {} --Global, [x] is segmentx, [y] is segmenty, returns the Plateau (0 if water zone) and land/water zone reference to use; closest is based on straight line dist

iPlateauCount = 0
tAllPlateaus = {} --[x] = AmphibiousPathingGroup, [y]: subrefs, e.g. subrefPlateauMexes;
--aibrain variables for plateaus (not currently incorporated):
reftPlateausOfInterest = 'M28PlateausOfInterest' --[x] = Amphibious pathing group; will record a table of the pathing groups we're interested in expanding to, returns the location of then earest mex
--refiLastPlateausUpdate = 'M28LastTimeUpdatedPlateau' --gametime that we last updated the plateaus
--reftOurPlateauInformation = 'M28OurPlateauInformation' --[x] = AmphibiousPathingGroup; [y] = subref, e.g. subrefPlateauLandFactories; Used to store details such as factories on the plateau
--refiOurBasePlateauGroup = 'M28PlateausOurBaseGroup' --Segment group of our base (so can easily check somewhere is in a dif plateau)

--subrefs for tables
--tAllPlateaus[iPlateau] subrefs
    subrefbMinorPlateau = 'M28PlatMin' --true if an inconsequential plateau (i.e. no mexes, and a small area of land)
    subrefiMinorCycleRef = 'M28PlatMnC' --number from 1 to 10, to denote the 'cycle' in which to update zones in this plateau if it is a minor plateau (so it is updated 10% as often as a non-minor plateau)
    subrefPlateauMexes = 'M28PlateauMex' --[x] = mex count, returns mex position
    subrefPlateauMinXZ = 'M28PlateauMinXZ' --{x,z} min values
    subrefPlateauMaxXZ = 'M28PlateauMaxXZ' --{x,z} max values - i.e. can create a rectangle covering entire plateau using min and max xz values
    subrefPlateauTotalMexCount = 'M28PlateauMexCount' --Number of mexes on the plateau
    subrefPlateauReclaimSegments = 'M28PlateauReclaimSegments' --[x] = reclaim segment x, [z] = reclaim segment z, returns true if part of plateau
    subrefPlateauMidpoint = 'M28PlateauMidpoint' --Location of the midpoint of the plateau
    subrefPlateauMaxRadius = 'M28PlateauMaxRadius' --Radius to use to ensure the circle coveres the square of the plateau

    --Plateaus: Island variables (against tAllPlateaus[iPlateau])
    subrefPlateauIslandLandZones = 'M28PlateauIslands' --[x] is the island, returns a table of land zones in that island for this plateau; the table returned has a key 1....x, and returns the land zone reference number
    subrefPlateauIslandMexCount = 'M28IslandMexCount' --[x] is the island, returns the number of mexes in the island

--Plateaus - Land zone variables (still against tAllPlateaus[iPlateau]
    subrefLandZoneCount = 'M28PlateauZoneCount' --against the main plateau table, records how many land zones there are (alternative to table.getn on the land zones)
    subrefPlateauLandZones = 'M28PlateauLandZones' --against the main plateau table, stores info on land zones for that plateau

iLandZoneSegmentSize = 5 --Gets updated by the SetupLandZones - the size of one side of the square that is the lowest resolution land zones go to; each segment that is land pathable gets assigned to a land zone
    --Land zone subrefs (against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]):
        subrefLZMexCount = 'MexCount' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns number of mexes in the LZ
        subrefLZMexLocations = 'MexLoc' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns table of mex locations in the LZ, e.g. get with tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefLZMexLocations]
        subrefMexUnbuiltLocations = 'MexAvailLoc' --used by water and land zones; e.g. for LZ is against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns table of mex locations in the LZ, e.g. get with tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefLZMexLocations]
        refiTimeOfLastMexDeath = 'MexLstDth' --Gametimeseconds that a mex died in this land zone - used to avoid sending an error message if it is rebuilt immediately (due to the mex deaht logic having a delay)
        subrefMidpoint = 'Midpoint' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns the midpoint of the land zone, e.g. get with tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefMidpoint]
        subrefLZMinSegX = 'LZMinSegX'
        subrefLZMinSegZ = 'LZMinSegZ'
        subrefLZMaxSegX = 'LZMaxSegX'
        subrefLZMaxSegZ = 'LZMaxSegZ'
        subrefHydroLocations = 'HydroLoc' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns table of hydro locations in the LZ or WZ
        subrefHydroUnbuiltLocations = 'HydroAvailLoc' --against land or water zone, e.g. tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns table of hydro locations in the LZ that dont have buildings on them
        subrefBuildLocationsBySizeAndSegment = 'BuildLoc' --contains a table, [buildingsize][SegX][SegZ], returns true if can build on the location
        subrefBuildableSizeBySegment = 'BuildSizSeg' --Table, [x] segment, [z] segment, returns highest size of building that can be built from the segment midpoint
        subrefSegmentsConsideredThisTick = 'BuildSTisT' --Number of segments that have been through to analyse the largest build size available
        subrefBuildLocationSegmentCountBySize = 'BuildSegment' --[x] is the building size considered, returns Number of segments that we have considered when identifying segment build locations for the land zone for that particular size
        subrefiLastSegmentEntryConsideredForBuilding = 'BuildLastSeg' --returns the segment ref in the LZ valid segment listings (i.e. subrefLZSegments) that we last considered
        subrefiCumulativeSegmentsConsideredForBuilding = 'BuildCumS' --Total number of segments considered over the course of the game
        subrefQueuedLocationsByPosition = 'BuildQu' --[x] is floor(x), y is floor(z), returns true if queued
        subrefBuildLocationBlacklistByPosition = 'Blacklst' --[x] is floor(x), [y] is floor(z), returns true if blacklisted
        subrefGameEnderTemplateBackupLocationSizeAndSegment = 'GEBck' --returns {size, SegX, SegZ,.... per below}, i.e. a single entry table with these values, decided near start of game, so can be used if we no longer have somewhere large enough for gameender
            subrefiSize = 1
            subrefiSegX = 2
            subrefiSegZ = 3
            --Below values for if using small shielding (Aeon/Cybran):
            subrefiSmallArtiLocationCount = 4
            subrefiSmallArtiMaxSize = 5
            subrefiSmallShieldLocationCount = 6
            subreftSmallArtiLocations = 7
            subreftSmallShieldLocations = 8
            --Below values for if using large shielding (UEF/Seraphim):
            subrefiLargeArtiLocationCount = 9
            subrefiLargeArtiMaxSize = 10
            subrefiLargeShieldLocationCount = 11
            subreftLargeArtiLocations = 12
            subreftLargeShieldLocations = 13

        --subrefBuildLocationBlacklist = 'Blacklst' --[x] is the entry, returns the location
            --subrefBlacklistLocation = 1
            --subrefBlacklistSize = 2 --radius of the square, i.e. if do a square around the location where eaech side is this * 2 in length, then will cover the blacklist location
            --subrefBlacklistType = 3
                --BlacklistTimeout = 1 --i.e. we have tried building something for ages and have failed
                --BlacklistReserved = 2 --i.e. we dont want to build anything here because it's being saved for something--]]
        subrefLZOrWZMassStorageLocationsAvailable = 'MassStorageLocations' --Against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], Returns table of locations which should be valid to build on for mass storage
        subrefLZSegments = 'Segments' --Contains a table which returns the X and Z segment values for every segment assigned to this land zone
        subrefLZTotalSegmentCount = 'SegCount' --Number of segments in a land zone, against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
        subrefLZAdjacentLandZones = 'AdjLZ' --table containing all adjacent land zone references for the plateau in question, against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], i.e. ordered 1,2,3,...; and returns the LZ ref (based on the order it was added)
        subrefDangerousNearbyPlateauAndZones = 'NrLZ' --Ideally adjacent zones capture all units that can hit into the zone; this table is for any adidtional zones that have managed to hit units in this zone, returns table of entries, 1,2,...,x, which return {iPlateau, iLandZone}
        subrefLZPathingToOtherLandZones = 'PathLZ' --table containing the land zone ref of some (but not all) other LZs where have recorded the paths and time taken, sorted by closest LZ first
            subrefLZNumber = 1 --Land zone reference number
            subrefLZPath = 2 --against subrefLZPathingToOtherLandZones subtable, returns a table [x]=1,2,3...; which returns the land zone reference for each land zone that will go through on a path from these
            subrefLZTravelDist = 3 --against subrefLZPathingToOtherLandZones subtable
        subrefLZPathingToOtherLZEntryRef = 'PathRfLZ' --[x] is the target LZ reference; will return the entry in subrefLZPathingToOtherLandZones containing this path, if there is one
        subrefLZTravelDistToOtherLandZones = 'TravelLZ' --table used to store all land travel distance calculations to get from one LZ to another LZ; similar to subrefLZPathingToOtherLandZones, but intended to allow for all land zones to be recorded
        subrefLZPathingToOtherIslands = 'PathIsl' --array, [x] = (1, 2...); Ordered based on shortest travel distance; ONLY DONE FOR ZONES WITH MEXES
            subrefIslandNumber = 1 --Island reference number
            subrefIslandClosestLZRef = 2 --LZ ref of the LZ closest to us in this island
            subrefIslandTravelDist = 3 --Amphibious travel distance from the land zone to the closestLZRef in the IslandNumber
            subrefIslandLZPath = 4 --table of the land zones that an amphibious unit would go through to get from this LZ to the ClosestLZRef
        subrefAdjacentWaterZones = 'LZAdjWZ' --table of details for water zones adjacent to the land zone
            subrefAWZRef = 1 --The water zone reference
            subrefAWZDistance = 2 --Distance between midpoint from LZ to the WZ
        subrefLZFurthestAdjacentLandZoneTravelDist = 'FurthestAdjLZ' --Returns the travel distance (rounded up) of the furthest immediately adjacent land zone - can combine with subrefLZPathingToOtherLandZones so can stop cycling through the prerecorded LZs once get further away than the immediately adjacent ones
        subrefOtherLandAndWaterZonesByDistance = 'AirAdjLZWZ' --Need to have called RecordOtherLandAndWaterZonesByDistance first; for LZ and WZData; orders land and air zones by distance, contains subtable with the following info:
            subrefiPlateauOrPond = 1
            subrefiLandOrWaterZoneRef = 2
            subrefbIsWaterZone = 3
            subrefiDistance = 4 --straight line distance
        subrefLZPlayerWallSegments = 'PlWalls' --Table of wall units that aren't owned by M28AI
        --Reclaim related (same values used for water zone)
        subrefReclaimSegments = 'ReclSeg' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], table, orderd 1,2,3...; returns {iReclaimSegmentX, iReclaimSegmentZ}
        subrefTotalMassReclaim = 'RecMass' --total mass reclaim in the land zone
        subrefTotalSignificantMassReclaim = 'RecSigM' --Total mass recalim that is at least the value of iSignificantMassThreshold individually
        subrefHighestIndividualReclaim = 'RecHighS' --Highest individual reclaim in the zone itself
        subrefLZTotalEnergyReclaim = 'RecEn' --Total energy reclaim in the land zone
        subrefLastReclaimRefresh = 'RecTime' --Time that we last refreshed the reclaim in the land zone, against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
        subrefLastComprehensiveReclaimRefresh = 'CmRecTim' --time we last refreshed every segment with mass in the zone
        subrefiTimeFailedToGetReclaim = 'RecTmFl' --Gametimeseconds that engineers failed to be given an order to reclaim something when on reclaimorder duty for this land or water zone (same ref for both types of zone)

        --Land scout/intel related
        subreftPatrolPath = 'PatrPth' --table of locations intended for a land scout to patrol the perimeter of the land zone / water zone
        reftoAllOmniRadar = 'AllOmn' --table of all omni radar units providing some coverage to this zone's midpoint - i.e. includes ally and enemy alike
        refiAllOmniCoverage = 'AllOmC' --Omni coverage of the zone midpoint by any player (ally and enemy alike)
        refiTimeOfNearbyEnemyNovax = 'NrENvx' --Gametimeseconds that enemy had a nearby novax satellite

        --Island related
        subrefLZIslandRef = 'Island' --the island ref of the land zone (can also get by using NavUtils.GetLabel(refPathingTypeLand) for the midpoint

        --Capture and repair (done on zone rather than team basis, since intended for civilian targets and/or objectives so want to consider for all M28 teams; same ref used for water zones
        subreftoUnitsToCapture = 'UnitsToCap' --AGAINST ZONEData not TEAMZoneData
        subreftoUnitsToRepair = 'UnitsToRep' --AGAINST ZONEData not TEAMZoneData
        --Mission objective specific - disable targeting logic
        subrefbPacifistArea = 'PacAre' --true if this is a pacificst area

        --Land zone subteam data (update M28Teams.TeamInitialisation function to include varaibles here so dont have to check if they exist each time)
        subrefLZTeamData = 'Subteam' --tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData] - Table for all the data by team for a plateau's land zone
            --Variables that are against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData]:
            subrefLZTValue = 'ZVal' --Value of the zone factoring in mass, reclaim, and allied units
            subrefLZSValue = 'ZBVal' --Value of friendly buildings in the land zone
            subrefLZbCoreBase = 'ZCore' --true if this is considered a 'core base' land zone
            refbBaseInSafePosition = 'ZSafCr' --true if friendly bases are closer to every enemy than this location (i.e. rear slot on maps like setons)
            subrefLZCoreExpansion = 'ZExp' --true if considered the main land zone for an expansion (e.g. on an island); nil if we havent considered yet if it is a core expansion, and false if we have considered and it isnt
            subrefbCoreBaseOverride = 'ZCreO' --true if we want to make this locatio na core zone even if it doesnt meet the normal criteria (e.g. to be used when we run out of places to build in our actual core LZ)
            subrefLZExpansionOverride = 'ZExpO' --true if want to make this location a core expansion even if doesnt meet normal criteria (e.g. if we use transport to drop somewhere on same island but far away, then building land facs there may be of use)
            subrefLZFortify = 'ZFor' --True if we want to fortify this firebase, e.g. for scenarios like M2 UEF
            subrefAlliedACU = 'AACU' --table of ACU units for the land zone (so can factor into decisions on support and attack)
            refbACUInTrouble = 'AACTr' --true if we have acu in this zone that we are worreid might be about to die to tanks
            subreftoLZOrWZAlliedUnits = 'Allies' --USE SAME REF AS FOR WATER ZONES - table of all allied units in the land zone, tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam][subreftoLZOrWZAlliedUnits]
            subrefLZTAlliedCombatUnits = 'AllComb' --table of allied units that are to be considered for combat orders
            subrefiTimeOfLastEnemyUnitPosUpdate = 'EnPosTim' --Gametimeseconds that we updated the last known position of enemy units in this zone
            subrefTEnemyUnits = 'Enemies' --table of all enemy units in the land zone or water zone (same ref used for WZ)
            reftoNearestDFEnemies = 'NearestDF' --Table of enemy DF units in this LZ, plus the nearest DF unit in each adjacnet LZ, with proximity based on unit distance and unit range (i.e. the dist until the unit is in range)
            refoNearestStructureInOtherPlateauIfNoEnemiesHere = 'NearSPl' --If dealing with a large enough land zone, this will record here the closest enemy structure in another plateau near to this land zone, if there is one
            refbEnemiesInNearbyPlateau = 'EnNrPl' --true if a nearby plateau has enemies in it - works imilsarly to refoNearestStructureInOtherPlateauIfNoEnemiesHere, and is intended so can do more detailed calc for mobile units if relevant

            --Ground threat values for land zones (also against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam])
            subrefTThreatEnemyCombatTotal = 'ECTotal'
            subrefLZTThreatAllyCombatTotal = 'ACTotal'
            subrefLZDFThreatWanted = 'DFWanted'
            subrefLZMAAThreatWanted = 'MAAThreatWanted'
            subrefiNearbyEnemyLongRangeThreat = 'NrEnLRT' --Number equalling the threat value; intended for fatboys who can outrange adjacent land zones - for enemies that arent in this zone but have a long range and are close to being in range of this zone; units are added to here as a result of AddUnitToLongRangeThreatTable (which adds to the team baesd table, which is then checked to add to subrefoNearbyEnemyLongRangeThreats, which then determines subrefiNearbyEnemyLongRangeThreat
            subrefoNearbyEnemyLongRangeThreats = 'NrEnLRU' --As above, but a table of the units (likely a table of fatboys; t2 arti are kept in a separate table)
            subrefoNearbyEnemyLandFacs = 'NrEnLFac' --table of enemy landfacs that are nearby - used to trigger more of a T1 spam focus
            subreftoAllNearbyEnemyT2ArtiUnits = 'NrEnT2A' --Table of t2 arti near this zone
            subrefLZThreatEnemyMobileDFByRange = 'EMDFByRange'
            subrefLZThreatEnemyMobileDFTotal = 'EMDFTo'
            subrefLZThreatAllyMobileDFByRange = 'AMDFByRange'
            subrefLZThreatAllyMobileDFTotal = 'ATDFT'
            subrefLZThreatEnemyMobileIndirectByRange = 'EMIFByRange'
            subrefLZThreatEnemyMobileIndirectTotal = 'EMIFTo'
            subrefLZThreatAllyMobileIndirectByRange = 'AMIFByRange'
            subrefLZThreatAllyMobileIndirectTotal = 'ATIFT'
            subrefLZThreatEnemyBestMobileDFRange = 'EBDFR'
            subrefLZThreatEnemyBestStructureDFRange = 'EBSDFR'
            subrefLZThreatEnemyBestMobileIndirectRange = 'EBIR'
            subrefThreatEnemyStructureTotalMass = 'ESTM' --Used for LZ and WZ, returns total mass in buildings
            subrefiAvailableMobileShieldThreat = 'LMST' --mass value of friendly mobile shields in the land zone
            reftoAdjacentStructuresWithHighRange = 'ASDr' --ONLY UPDATED IF WE HAVE COMBAT UNITS in the zone this is recorded against - e.g. talbe of T2 PD+ (includes T1 pd if no mobile units with a better range), so can give a more refined decision on whether are in scenario 1


            subrefLZThreatEnemyStructureDFByRange = 'ESDFByRange'
            subrefThreatEnemyDFStructures = 'ESDFTo'
            subrefLZIndirectThreatWanted = 'IFWanted'
            subrefLZThreatAllyStructureDFByRange = 'ASDFByRange'
            subrefLZThreatEnemyStructureIndirect = 'ESITotal'
            subrefLZThreatAllyStructureIndirect = 'ASITotal'
            subrefLZThreatEnemyShield = 'EShTot' --Fixed and mobile shields
            subrefLZThreatEnemyGroundAA = 'EAATotal'
            subrefiT3FixedShieldConstructedCount = 'FSCCn' --number of allied M28 shields that have been constructed less number that have been killed
            subreftoTeammateFixedDF = 'DFTm8U' --Non-M28 teammate fixed DF table of units (i.e. PD)
            subreftoTeammateFixedAA = 'AATm8U' --Non-M28 teammate fixed AA table of units
            subrefLZThreatAllyGroundAA = 'AAATotal'
            subrefLZThreatAllyMAA = 'MAATotal' --only MAA, excludes structure, wz uses same ref deinition ('MAATotal')
            subrefbEnemiesInThisOrAdjacentLZ = 'NearbyEnemies' --true if this LZ or adjacent LZ have nearby enemies
            subrefbDangerousEnemiesInThisLZ = 'HasDangEnemy' --true if combat units in this LZ
            subrefbDangerousEnemiesInAdjacentWZ = 'WZNearEnemies' --true if there is an adjacent water zone that has dangerous enemies; used for both alnd and water zones
            subrefbLZWantsSupport = 'LZWantsSupport' --true if want DF or indirect units for the LZ
            subrefbLZWantsDFSupport = 'LZWantsDFSupport' --true if want DF units for the LZ
            subrefbLZWantsIndirectSupport = 'LZWantsIndirectSupport' --true if want indirect units for the LZ
            subrefiTimeOfMMLFiringNearTMDOrShield = 'LZTimMMLFNrTMD' --Gametimeseconds that had MML firing in the zone who were near TMD
            subrefiTimeFriendlyTMDHitEnemyMissile = 'LZTimTMDVsEn' --GetGameTimeSeconds that had TMD intercept enemy missile

            subreftEnemyFirebasesInRange = 'LZEnemyFirebasesInRange' --[x] is just a count (1,2,3), returns {iPlateau, iLandZone} of the firebase
            refiTimeOfLastIndirectFirebaseAttack = 'LZIndFBAtc' --gametimeseconds that we last attacked a firebase in this zone with indirect units
            subreftoEnemyTMD = 'LZEnemyTMD' --TMD owned by the enemy in the LZ
            subreftoEnemyPotentialTMLTargets = 'LZPotentialTMLTargets' --potential targets for TML in the LZ (ignoring TMD)

            --Engineer related values
            subreftoPartBuiltMexes = 'PBMex' --If we are building a mex and the builder gets its orders cleared or dies, and it was building a mex, then the mex should be recorded in a table so it can be rebuilt
            subrefTbWantBP = 'WantBP' --true if we want BP at any tech level
            subreftiBPWantedByAction = 'BPByAct' --table of bp wanted for each action for a zone
            subrefTBuildPowerByTechWanted = 'BPByTechW' --{[1]=a, [2]=b, [3]=c} where a,b,c are the build power wanted wanted
            subreftbBPByFactionWanted = 'BPByFaction' --[x] = faction ref, returns true if we want engineers of that faction
            subrefTEngineersTravelingHere = 'EUnitsTrav' --Table of any engineer units in another LZ/WZ that have been told to move to this LZ/WZ
            subrefTScoutsTravelingHere = 'SUnitsTrav' --Table of any land scout units in another LZ/WZ that have been told to move to this LZ/WZ
            subrefSpareBPByTech = 'SpareBPByTech' --{[1]=a, [2]=b, [3]=c} where a,b,c are the build power of that tech level that we have spare
            subrefReclaimAreaAssignmentsBySegment = 'RecSegAss' --[ReclaimSegX][ReclaimZegY], returns count of how many engineers have been assigned
            subrefQueuedBuildings = 'QBByBP' --Queued buildings for a land zone
                subrefQueueRef = 1 --Unique queue reference number
                subrefBuildingID = 2 --Blueprint/UnitId of the building queued
                subrefBuildingLocation = 3 --Location the building is to be built at
                subrefBuildingRadius = 4 --Size (radius) of the building
                subrefPrimaryBuilder = 5 --Engineer given the build order
            subreftiPotentialNukeTargetZones = 'NkTrgtZ' --contains subtables, ordered 1,2,...x returning {iPlateauOrZero, iLandOrWaterZone} for each zone that can probably be hit by a nuke from this zone
            refbAdjZonesWantEngiForUnbuiltMex = 'AZwEMx' --true if have adj zones wanting engineer for unbuilt mex
            subreftoEmergencyPDEngineers = 'EmPDEngis' --table of engineers with emergency PD build order
            subrefiTimeLastWantSACUForExp = 'sacuexp' --Gametimeseconds that we last failed to build an experimental in the zone due to trying with an engineer
            subrefiTimeLastWantSACUForSMD = 'sacusmd' --Gametimeseconds that we last failed to build an SMD in the zone due to trying with an engineer

            refbIgnoreEmergencyPDReassignmentLogic = 'EmPDAtv' --true if have logic monitoring emergency PD builders active
            --subrefLZTAdjacentBPByTechWanted = 'AdjBPByTechW' --{[1]=a, [2]=b, [3]=c} where a,b,c are the build power wanted wanted
            --Economy related values
            subreftoActiveUpgrades = 'ActiveUpgrades' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam]
            subrefiActiveMexUpgrades = 'ActiveMexUpgrades'
            subrefMexCountByTech = 'MexByTech' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam], returns {[1]=x,[2]=y,[3]=z} where xyz are counts of mexes
            refiZoneConstructedExperimentalCount = 'ExpConC' --Total number of experimental level units built in this zone
            refiLastGameEnderTemplateCategory = 'ExpCatT' --If doing a 'build t3 arti/gameender per template' action, then this is used to indicate what category to use
            reftActiveGameEnderTemplates = 'ExpTmpA' --Table of active 'gameender template' actions for this zone, [x] = 1,2,...x, returns subtable
                 subrefGEMidpoint = 1
                 subrefGESize = 2
                 subrefGEArtiLocations = 3
                 subrefGEShieldLocations = 4
                 subrefGESMDLocation = 5 --Only one location to be allowed, in contrast to the other slots
                 subrefGEArtiUnits = 6
                 subrefGEShieldUnits = 7
                 subrefGESMDUnit = 8 --SINGLE unit not a table
                 subrefGEEngineers = 9
                 subrefGEbActiveMonitor = 10
                subrefGEbDontNeedEngineers = 11
                subrefbFailedToGetArtiLocation = 12
                subrefGEbActiveShieldMonitor = 13
                subrefiCyclesWaitingForEngineer = 14
                subrefGEShieldBlockedFailureCount = 15 --used to stop constantly searching for blocking buildings for a shield
                subrefGEArtiBlockedFailureCount = 16 --used to stop constantly searching for blocking buildings for an arti
                subrefGEDefenceBlockedFailureCount = 17



            subreftoUnitsToReclaim = 'UnitToRec' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam], table of units that we should reclaim
            subrefiTimeLandFacHadNothingToBuild = 'TimeLFNoB' --Gametimeseconds that had a land fac in this zone with nothing to build
            subrefiTimeAirFacHadNothingToBuild = 'TimeAFNoB' --Gametimeseconds that had an air fac in this zone with nothing to build
            subrefiTimeNavalFacHadNothingToBuild = 'TimeNNoB' --Gametimeseconds that had a naval fac with nothing to build
            --Intel related values
            refbWantLandScout = 'LandScout' --True/false, used by water and land zones
            refiRadarCoverage = 'RadCov' --Radar coverage of the centre of the land zone midpoint
            refiOmniCoverage = 'OmnCov' --Omni coverage of the centre of the land or water zone midpoint
            refiEnemyOmniCoverage = 'EOmCov' --Enemy omni coverage of the centre of the land or water zone midpoint
            refiSonarCoverage = 'SonCov' --Sonar coverage of the centre of the land or water zone midpoint (intended for water zones)
            refoBestRadar = 'BestRad' --Radar providing the best Radar Coverage for the land zone midpoint
            refoBestSonar = 'BestSon' --Sonar providing the best sonar coverage for the water zone midpoint
            reftoUnitsWantingPriorityScouts = 'PrLndS' --If the land subteam has any units flagged as wanting priority scouts, then they should be assigned against this zone
            --Note: reftoAllOmniRadar is against LZData and contains all omni for all players
            refiTimeLastHadVisual = 'LstVis' --Gametimeseconds that last had an intel unit (e.g. land or air scout) in the land or water zone
            refiScoutingPriority = 'SctPrio' --will return the scouting priority (i.e. 1, 2 or 3 per below subrefs)
                subrefiScoutingHighPriority = 1
                subrefiScoutingMediumPriority = 2
                subrefiScoutingLowPriority = 3
            refiRecentlyFailedScoutAttempts = 'SctFail' --if a scout dies trying to reach here, this should increase the failure count
            --Enemy air
            reftLZEnemyAirUnits = 'EnAir' --All enemy air units that are currently in the land zone (LZ and WZ use the same definition)
            refiEnemyAirToGroundThreat = 'EnA2GT' --Air to ground threat of enemy air units in the LZ / WZ
            refiEnemyAirAAThreat = 'EnAAT' --AirAA threat in the LZ/WZ
            refiEnemyAirOtherThreat = 'EnAirOT' --mass value of AirAA, air scouts and transports in the LZ / WZ
            refiTimeOfLastAirUpdate = 'EnAirTim' --Gametimeseconds that last refreshed the positiosn of air units (done given high mobility of air to approximate a human player realising the air force is no longer there)
            --Shield, stealth and tmd
            refbLZWantsMobileShield = 'MobSh' --true if LZ wants mobile shields
            reftoLZUnitsWantingMobileShield = 'UMobSh' --table of units in the LZ that want mobile shield
            reftoLZUnitWantingFixedShield = 'UFixSh' --table of untis in the LZ taht want a fixed shield
            reftPriorityShieldsToAssist = 'FShAss' --Table of fixed shields that want to assist
            refiTimeOfLastShieldPriorityRefresh = 'FSTimC' --Time that we last updated the list of priority shields to be assisted
            refiFixedShieldT2EngiFailureCount = 'FST2Ec' --number of times a t2 engi has failed to get something to build when trying to build a fixed shield (used to decide to switch to t3 only)
            refbLZWantsMobileStealth = 'MobSt' --true if LZ wants mobile stealth
            reftoLZUnitsWantingMobileStealth = 'UMobSt' --table of units in the LZ that want mobile stealth
            reftUnitsWantingTMD = 'TMDW' --table of units in the LZ that want TMD coverage
            reftoUnitsForSpecialShieldProtection = 'GmEnd' --I.e. gameenders (and possibly T3 arti) that we want to protect with special shield covering logic
            reftFactoriesWantedForEngineers = 'FEng' --table of factory units that are assigend against a unit (e.g. a gameender) as providing engineers of a particular faction (e.g. for shields)
            --Misc
            reftClosestFriendlyBase = 'ClosestFB' --Position of the closest friendly start position (same for water zone)
            reftClosestEnemyBase = 'ClosestEB' --Closest enemy start position to water zone or land zone (i.e. same variable used by both)
            reftiClosestFriendlyM28BrainIndex = 'ClsM28Br' --initially based on the closest friendly base (start position)
            refiModDistancePercent = 'ModDPC' --For LZ and WZ; % of the distance to the enemy base, e.g. 0.5 should be middle of the map, >0.5 should be on the enemy's side of the map; e.g. LZ is against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam], mod dist based on closest friendly start position to closest enemy start position
            refbIslandBeachhead = 'IslBeachd' --true if we are sending units to a closest island LZ to try and attack enemy - means will check for nearby untis vs enemy nearby units when deciding whether to attack or not
            refiTimeOfLastTorpAttack = 'TLstTorp' --Gametimeseconds that last sent torpedo bombers to attack units in this location
            reftoTransportsWaitingForUnits = 'TWntEng' --Table of any transports in this LZ wanting engineers
            reftoCombatUnitsLoadingOntoTransport = 'TrCmbU' --table of units trying to load onto a transport
            refbActiveCombatUnitLoader = 'TrCmUA' --true if have active combat unit loader for transport
            refiTransportRecentUnloadCount = 'TRUnC' --Number of times transports have tried to unload here recently
            refiTimeLastBuiltAtFactory = 'TLstBFac' --Gametimeseconds that a factory last tried ot build (used to make sure we spread things out by several ticks)
            reftoGroundFireFriendlyTarget = 'TGFTrg' --Location of a ground fire target that we wont be trying to target via normal means, e..g intended for Cybran mission 2 where need to ground fire temples that dont show as enemies and cant be reclaimed
            reftObjectiveSMDLocation = 'TSMDOL' --For campaign maps - locaiton of SMD to complete objective
            refiTimeLastShowedBuildLocationFailure = 'TLFBL' --Gametimeseconds we last showed a warning that we had nowhere to build
            refiNonM28TeammateFactoryCount = 'NMTFc' --Approx number of teammate factories in the zone
            refiNonM28TeammateMexCount = 'NMTMx' --approx number of teammate mexes in the zone
            --reftiLocationsToAvoid = 'TLocAv' --if have enemy aoe unit targeting an M28 unit, then the first 10 such locations get recorded - removed as not sure it actually made things better

--Pond and naval variables
    --General
iMinPondSize = 250 --1000 is a small pond that probably barely fits a couple of naval factories; c.320 on larger maps can fit things though so go with 250
iMinWaterDepth = 1.5 --Ships cant move right up to shore, this is a guess at how much clearance is needed (testing on Africa, depth of 2 leads to some pathable areas being considered unpathable)
bHaveConsideredPreferredPondForM28AI = false --Used to make sure we dont try and create water zones until we have setup the factory build locations for each M28AI
bHaveRecordedPonds = false --set to true once finished the RecordPonds logic
    --Ponds:
tPondDetails = {}
    subreftiWaterSegmentXZ = 'WatSegXZ' --returns table, index is sequentially from 1, returns {segmentX, SegmentZ}
    subrefiSegmentCount = 'WatSegCnt' --Number of segments for a particular pond (means can quickly tell the size of the pond)
    subrefiRecordedSegmentsInWaterZones = 'WatSegRCnt' --Number of segments recorded against a specific water zone for this pond
    --subrefPondSize - use subrefiSegmentCount instead
    subrefPondMinX = 'PondMinX'
    subrefPondMinZ = 'PondMinZ'
    subrefPondMaxX = 'PondMaxX'
    subrefPondMaxZ = 'PondMaxZ'
    subrefPondMidpoint = 'PondMidpoint'
--subrefPondNearbyBrains = 'PondNearbyBrains'
    subrefPondMexInfo = 'PondMexInfo'
        subrefMexLocation = 'PondMexLocation'
        subrefMexDistance = 'PondMexDistance'
        subrefMexDFDistance = 'PondMexDFDistance'
        subrefMexDFUnblockedLocation = 'PondMexDFLocation' --i.e. the closest location we found where a DF unit should be able to hit the mex
        subrefMexIndirectDistance = 'PondMexIndirectDistance'
        subrefMexIndirectUnblockedLocation = 'PondMexIndirectLocation' --i.e. the closest location we found where an indirect unit should be able to hit the mex
    subrefBuildLocationByStartPosition = 'PondBuildLocationByStart' --Subtable, key is start position number, which stores the build location for that start position (will only record for M28 brain start positions)

    --Water zones (against tPondDetails)
    subrefPondWZCount = 'PWZCount' --Total number of water zones in a pond (cant use table.getn on below as theyre not ordered from 1-x)
    subrefPondWaterZones = 'PondWZ' --e.g. access the water zone data tables via M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone], where iWaterZone is the NavUtils refPathingTypeNavy pathing result
        subrefWZMexCount = 'MexCount' --(same ref as for land zones; reason for repating is to avoid confusion with the pond variables which track different information)
        subrefWZMexLocations = 'MexLoc' --(same ref as for land zones)
        --subrefMexUnbuiltLocations Uses same ref as LZ

        --subrefMidpoint = 'Midpoint' --Uses same ref as land zone
        refiMidpointAmphibiousLabel = 'MPAmphbL' --Navutils label for the midpoint of the water zone; same ref is used for land zones
        subrefWZSegments = 'PWZSeg' --e.g. tPondDetails[iPond][subrefPondWaterZones][iWaterZone][subrefWZSegments]
        subrefWZMinSegX = 'PWZMinSX'
        subrefWZMinSegZ = 'PWZMinSZ'
        subrefWZMaxSegX = 'PWZMaxSX'
        subrefWZMaxSegZ = 'PWZMaxSZ'
        subrefAdjacentLandZones = 'WZAdjLZ' --table of details for land zones adjacent to the water zone
            subrefWPlatAndLZNumber = 1 --returns {Plateau, LandZone}
            subrefALZDistance = 2 --Distance between midpoint from LZ to the WZ
        subrefWZAdjacentWaterZones = 'WZAdjWZ' --table of water zones that are adjacent, i.e. returns {x,y,z,...} where x y z are the water zone references for adjacent water zones
        subrefWZOtherWaterZones = 'WZOthWZ' --table of details for water zones adjacent and further away, ordered by distance
            subrefWZAWZRef = 1 --the water zone reference
            subrefWZAWZDistance = 2 --Travel distance between the midpoints of the water zones
        subrefWZManualNavalPathToOtherPlateauOrZeroAndZone = 'WZPathOtherZ' --Use the function GetWaterZonePathToWaterOrAdjacentLandZone to get this; Intended for land zones adjacent to a water zone in the same pond as this one; [x] is the target plateau or zero, [y] is the target land or water zone, returns a table, with {iEntry (1,2,....x), iPlateauOrZero, iLandOrWaterZone}
        --Reclaim related - uses same values as water zone
        --subrefReclaimSegments
        --subrefTotalMassReclaim
        --subrefLZTotalEnergyReclaim
        --subrefLastReclaimRefresh

        subrefWZTeamData = 'PWZTeam' --Used to house team related data for a particular water zone
            subrefWZbCoreBase = 'LZCoreB' --true if is a 'core' base (i.e. has a naval factory in); uses same ref as LZbCoreBase
            subrefWZbContainsUnderwaterStart = 'WZUndwSt' --true if an M28brain start position is in this water zone and is underwater
            subrefWZbContainsNavalBuildLocation = 'WZNavBL' --true if contains a naval build location for a friendly M28AI
            subrefWZTValue = 'WZVal' --Value of the WZ, used to prioritise sending untis to different water zones; likely to be based on distance to core base water zone
            --refiRadarCoverage - use same ref as for land zone
            --refiOmniCoverage - use same ref as land zone
            --refoBestRadar - use same ref as for land zone
            --refiTimeLastHadVisual -use same ref as for land zone
            --reftClosestFriendlyBase - use same ref as for land zone
            --reftClosestEnemyBase - use same ref as for land zone
            --refiModDistancePercent - use same ref as for land zone
            --refbWantLandScout - use same ref as for land zone
            --subreftPatrolPath - use same ref as for land zone
            --subrefOtherLandAndWaterZonesByDistance - use same ref as for land zone

            --subreftoLZOrWZAlliedUnits = 'Allies' --USEs SAME REF AS FOR LAND ZONE - table of all allied units in the water zone
            subrefWZTAlliedCombatUnits = 'AllComb' --table of allied units that are to be considered for combat orders
            --subrefTEnemyUnits = 'Enemies' --table of all enemy units in the water zone - uses same ref as for land zone
            reftWZEnemyAirUnits = 'EnAir' --All enemy air units that are currently in the water zone
            --Threat values
            subrefbEnemiesInThisOrAdjacentWZ = 'EnInAdjWZ' --true if enemy in this or adjacent WZ; for land zones this will return true if any adjacent WZ has enemies

            --subrefThreatEnemyStructureTotalMass - uses same ref as for LZ
            --subrefTThreatEnemyCombatTotal = 'ECTotal' --Uses same ref as for LZ
            subrefWZThreatEnemyAntiNavy = 'EnANav'
            subrefWZThreatEnemySubmersible = 'EnSub'
            subrefWZThreatEnemySurface = 'EnSurf'
            subrefWZThreatEnemyAA = 'EnEAA' --Think this is just the ground based AA not airaa
            subrefWZBestEnemyDFRange = 'EnDFRnge'
            subrefWZBestEnemyAntiNavyRange = 'EnANavRng'
            subrefWZBestEnemySubmersibleRange = 'EnSNavRng' --antinavy range of underwater units

            reftoNearestCombatEnemies = 'WNrSufE'
            subreftEnemyLongRangeUnits = 'WEnLRU' --Table of enemy 'longer range' units (e.g. T2PD+ in range), based on iLongRangeThreshold

            subrefWZTThreatAllyCombatTotal = 'AlCom'
            subrefWZThreatAlliedAntiNavy = 'AlANav'
            subrefWZThreatAlliedSubmersible = 'AlSub'
            subrefWZThreatAlliedSurface = 'AlSurf'
            subrefWZThreatAlliedAA = 'AlAA'
            subrefWZThreatAlliedMAA = 'MAATotal'
            subrefWZBestAlliedDFRange = 'AlDFRnge'
            subrefWZBestAlliedSubmersibleRange = 'AlANavRng'
            refiLastBombardmentSearchRange = 'WZBmbRng' --Last range used for searching for bmobardment targets
            refbLastBombardmentSearchRangeSuccess = 'WZBmbSuc' --true if last time searched for enemies aroudn a location it found results
            refiClosestRaidingPlateauAndLandZone = 'WZClRLZ' --returns {Plateau, LandZone} if htere is a land zone we want to consider as a raiding target
            refiRaidWZForBombardment = 'WZRdBmWZ' --water zone where we expect to be able to attack enemy structures
            refiMinRangeRaidingZone = 'WZClRng' --returns the min range we want raiding naval units to have to join the raid on the land zone
            reftoWZRaiders = 'WZRaidr' --table of units assigned to raid; recorded against the base (factory) zone
            refbActiveRaiderLogic = 'WZActR' --true if are monitoring raider orders
            refoLastRaidTarget = 'WZRaidT' --Raid target building (used as backup for bombardment logic)
            refiRaidTechLevel = 'WZRadTL' --Tech level to use for raiding logic to estimate permissible ranges and enemy threat values

            subrefWZCombatThreatWanted = 'CombWant'
            subrefWZMAAThreatWanted = 'MAAWant'
            subrefbWZWantsSupport = 'WZWntSup'
            subrefbWZOnlyHoverEnemies = 'WZHvEn' --true if only hover units (so we dont want to send subs to support)
            subrefbWZOnlySubmersibleEnemies = 'WZSubEn' --true if only submersible enemies (so we dont want to send units without antinavy to support)

            reftoWZUnitsWantingMobileShield = 'MShUnit'
            refbWZWantsMobileShield = 'bWntMSh'
            reftoWZUnitsWantingMobileStealth = 'MStUnit'
            refbWZWantsMobileStealth = 'bWntMSt'

            --T3 arti (same ref used for LZ and WZ):
            subrefiIneffectiveArtiShotCount = 'T3ArtC' --Every time t3 arti fires a shot at a zone this increases, when it does notable damage this decreases

            --subrefTScoutsTravelingHere - uses same variable as land zone
            --subrefAlliedACU --Uses same variable as land zone
            --refiEnemyAirToGroundThreat --Uses same variable as land zone
            --refiEnemyAirOtherThreat --Uses same variable as land zone
            --subrefTotalMassReclaim --Uses same variable as land zone
            --Various engineer related variables - use the same references as for land zones



tPondBySegment = {} --[x][z] are the x and z segments based on iLandZoneSegmentSize, shoudl return the pond number (which is also the same as doing NavUtils.GetLabel(refPathingTypeNavy, tPosition)
tiPondByWaterZone = {} --[x] is the water zone ref, returns the pond that it belongs to
tWaterZoneBySegment = {} --[x][z] should be the x and z segments baed on iLandZoneSegmentSize, and should return the water zone number, or nil if there is none
iTotalWaterZoneCount = 0 --Unique value for waterzones so if know the waterzone reference then can identify the pond and other information just from this
iTotalWaterZoneRecordedSegmentCount = 0 --total number of segments regorded against water zones
iTotalSegmentsInPonds = 0 --Total number of segments which appear to be on water

--Land pathing segment data
tLandZoneBySegment = {} --[x][z] should be the x and z segments baed on iLandZoneSegmentSize, and should return the land zone number, or 0 if there is none
tTempZoneTravelDistanceBySegment = {} --[x][z][LZ] should be the x and z segments, used to temporarily store the distance values for segments at start of the game when setting up land zones
tTempZonePlateauBySegment = {} --[x][z][LZ] shoudl be the plateau; used as a backup where we could find a LZ nearby but not a plateau


--General aiBrain variables
reftPrimaryEnemyBaseLocation = 'M28PrimaryEnemyBase' --against aiBrain, returns location of the nearest enemy base
refiLastTimeCheckedEnemyBaseLocation = 'M28MapLastTimeCheckedEnemyBase' --against aiBrain, gametimeseconds that last checked the enemy base location
reftMidpointToPrimaryEnemyBase = 'M28MapMidpointToPrimaryEnemy' --against aiBrain, midpoint between the start position and the nearest enemy start position
refbCanPathToEnemyBaseWithLand = 'M28MapCanPathToEnemyWithLand'
refbCanPathToEnemyBaseWithAmphibious = 'M28MapCanPathToEnemyWithAmphibious'

---@param tPosition table
---@return number, number
function GetPathingSegmentFromPosition(tPosition)
    --The map is divided into equal sized square segments with each segment allocated to a land zone; this can be used to get the segment X and Z references
    --tPosition shoudl be {x,y,z} format, although y value is ignored)
    return math.floor( (tPosition[1] - rMapPotentialPlayableArea[1]) / iLandZoneSegmentSize) + 1, math.floor((tPosition[3] - rMapPotentialPlayableArea[2]) / iLandZoneSegmentSize) + 1
end

---@param iSegmentX number
---@param iSegmentZ number
---@return table
function GetPositionFromPathingSegments(iSegmentX, iSegmentZ)
    --Returns the position/location of land segment X and Z references iSegmentX and iSegmentZ (i.e. the map is divided into equal sized square segments, with each segment allocated to a land zone)
    local x = iSegmentX * iLandZoneSegmentSize - iLandZoneSegmentSize * 0.5 + rMapPotentialPlayableArea[1]
    local z = iSegmentZ * iLandZoneSegmentSize - iLandZoneSegmentSize * 0.5 + rMapPotentialPlayableArea[2] --If changing this, then also update AssignRemainingSegmentsToLandZone which manually does this for performance
    return {x, GetTerrainHeight(x, z), z}
end

function GetPathingOverridePlateauAndLandZone(tPosition, bOptionalShouldBePathable, oOptionalPathingUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPathingOverridePlateauAndLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iX = math.floor(tPosition[1])
    --if bDebugMessages == true then LOG(sFunctionRef..': iPlateau is nil or 0, tPosition='..repru(tPosition)..'; tPathingPlateauAndLZOverride[ix]='..repru(tPathingPlateauAndLZOverride[iX])..'; bOptionalShouldBePathable='..tostring(bOptionalShouldBePathable or false)..'; Is oOptionalPathingUnit valid='..tostring(M28UnitInfo.IsUnitValid(oOptionalPathingUnit))) end
    if tPathingPlateauAndLZOverride[iX] then
        local iZ = math.floor(tPosition[3])
        if tPathingPlateauAndLZOverride[iX][iZ] then
            --if bDebugMessages == true then LOG(sFunctionRef..': Have a valid override so will return this, override='..repru(tPathingPlateauAndLZOverride[iX][iZ])) end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return tPathingPlateauAndLZOverride[iX][iZ][1], tPathingPlateauAndLZOverride[iX][iZ][2]
        end
    end
    --Dont have an override for here - if we think it shoudl be pathable then create an override
    if bOptionalShouldBePathable and oOptionalPathingUnit then
        --if bDebugMessages == true then LOG(sFunctionRef..': No plateau for a unit that should be pathable, tPosition='..repru(tPosition)..'; bOptionalShouldBePathable='..tostring(bOptionalShouldBePathable)..'; oOptionalPathingUnit='..oOptionalPathingUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOptionalPathingUnit)..'; oOptionalPathingUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]='..repru(oOptionalPathingUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam])..'; Unit state='..M28UnitInfo.GetUnitState(oOptionalPathingUnit)..'; iMapWaterHeight='..iMapWaterHeight..'; about to run ConsiderAddingPlateauOverrideForUnit')
        if M28Land.ConsiderAddingPlateauOverrideForUnit(oOptionalPathingUnit) then
            if tPathingPlateauAndLZOverride[iX] then
                local iZ = math.floor(tPosition[3])
                if tPathingPlateauAndLZOverride[iX][iZ] then
                    --if bDebugMessages == true then LOG(sFunctionRef..': GetPathingOverridePlateauAndLandZone: Have a valid override after considering plateau override for unit, override='..repru(tPathingPlateauAndLZOverride[iX][iZ])) end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return tPathingPlateauAndLZOverride[iX][iZ][1], tPathingPlateauAndLZOverride[iX][iZ][2]
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of function, will return nil') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return nil, nil
end

function GetWaterZoneFromPosition(tPosition)
    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tPosition)
    return tWaterZoneBySegment[iSegmentX][iSegmentZ]
end

---@param tPosition table
---@param bOptionalShouldBePathable boolean
---@return number, number
function GetPlateauAndLandZoneReferenceFromPosition(tPosition, bOptionalShouldBePathable, oOptionalPathingUnit)
    --Returns the plateau reference of tPosition (where tPosition is {x,y,z}), and the Land zone reference for that position
    --returns nil if cant find valid plateau or land zone
    --bOptionalShouldBePathable - if e.g. have a unit at tPosition, then set this to true as it means somehow a unit could path in this area, and the code will then try backup options and give error messages

    --Get the plateau reference and the land segment X and Z references:
    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tPosition)
    local iPlateau = NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iSegmentX, iSegmentZ))
    local iLandZone

    if (iPlateau or 0) <= 0 or not(tAllPlateaus[iPlateau]) then
        --Check if we have previously recorded this location with a pathing override
        --LOG('GetPlateauAndLandZoneReferenceFromPosition iPlateau='..(iPlateau or 'nil'))
        iPlateau, iLandZone = GetPathingOverridePlateauAndLandZone(tPosition, bOptionalShouldBePathable, oOptionalPathingUnit)
        --LOG('GetPlateauAndLandZoneReferenceFromPosition iPlateau after getting override='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil'))
        if not(tAllPlateaus[iPlateau]) then
            --Potential error - see if there is a plateau for the preicse position if it shoudl be pathable

            --LOG('GetPlateauAndLandZoneReferenceFromPosition: tAllPlateaus is nil for iPlateau='..(iPlateau or 'nil')..'; if should be pathable will check the segment we are in/ bOptionalShouldBePathable='..tostring(bOptionalShouldBePathable or false))
            if bOptionalShouldBePathable then
                iPlateau = NavUtils.GetLabel(refPathingTypeHover, tPosition)

                if not(tAllPlateaus[iPlateau]) then
                    if bOptionalShouldBePathable then
                        --If get this error, then refer to GetUnitPlateauAndLandZoneOverride
                        M28Utilities.ErrorHandler('No plateau group for iSegmentX='..iSegmentX..'; iSegmentZ='..iSegmentZ..'; Plateau group of segment midpoint='..(NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iSegmentX, iSegmentZ)) or 'nil')..'; Plateau Group of tPosition='..(NavUtils.GetLabel(refPathingTypeHover, tPosition) or 'nil')..'; This can happen on larger maps with long cliffs with narrow paths that small units can travel partially along. Enable logs in the function GetUnitPlateauAndLandZoneOverride for more details', true)
                    end
                    return nil
                else
                    if tAllPlateaus[iPlateau][subrefPlateauTotalMexCount] == 0 then
                        iLandZone = 1
                    else
                        --more than 1 land zone so return nil
                        iLandZone = nil
                    end
                end
            else
                return nil
            end
        end
        return iPlateau, iLandZone
    else
        --Have a valid plateau, get the land zone reference:
        --local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tPosition)
        iLandZone = tLandZoneBySegment[iSegmentX][iSegmentZ]
        --LOG('GetPlateauAndLandZoneReferenceFromPosition - iLandZOne based on segment='..(iLandZone or 'nil'))
        if not(iLandZone) then
            --Are we above water in height? If so check for override
            if tPosition[2] > iMapWaterHeight then
                local iAltPlateau
                iAltPlateau, iLandZone = GetPathingOverridePlateauAndLandZone(tPosition, bOptionalShouldBePathable, oOptionalPathingUnit)
                --LOG('GetPlateauAndLandZoneReferenceFromPosition: iLandZone after checking for override='..(iLandZone or 'nil'))
                if not(iLandZone) and bOptionalShouldBePathable then
                    --Possible explanation - engineer has traveled across water and reached a cliff
                    if EntityCategoryContains(categories.HOVER + M28UnitInfo.refCategoryAmphibious, oOptionalPathingUnit.UnitId) then
                        --Do nothing - hopefully unit has orders that it will follow that will resolve this on its own; however update the plateau
                    else
                        --If terrain height is also above map waterhight then have error (as might be units ahve been dropped from transport into water)
                        if GetTerrainHeight(tPosition[1], tPosition[3]) > iMapWaterHeight then
                            M28Utilities.ErrorHandler('Unable to find valid land zone, iSegmentX='..(iSegmentX or 'nil')..'; iSegmentZ='..(iSegmentZ or 'nil')..'; Optional pathing unit ID='..(oOptionalPathingUnit.UnitId or 'nil'))
                            LOG('tPosition='..repru(tPosition)..'; Land label of position='..(NavUtils.GetLabel(refPathingTypeLand, tPosition) or 'nil'))
                        end
                        --M28Utilities.DrawLocation(tPosition)
                    end
                else
                    if iAltPlateau then
                        iPlateau = iAltPlateau
                    end
                end
            end
        elseif not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]) then
            local iAltPlateau
            iAltPlateau, iLandZone = GetPathingOverridePlateauAndLandZone(tPosition, bOptionalShouldBePathable, oOptionalPathingUnit)
            if tAllPlateaus[iAltPlateau][subrefPlateauLandZones][iLandZone] then
                iPlateau = iAltPlateau
            else
                iPlateau = nil
                iLandZone = nil
            end
        end
    end
    --LOG('GetPlateauAndLandZoneReferenceFromPosition - end of code, iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil'))


    return iPlateau, iLandZone
end

function GetNearestPlateauOrLandOrWaterZoneToLocationFORLOOKUP(tLocation)  --Only to help with lookup - use below function
    return GetClosestPlateauOrZeroAndZoneToPosition(tPosition)
end --Only to help with lookup - use below function
function GetClosestPlateauOrZeroAndZoneToPosition(tPosition)

    --e.g.:
    --                                  iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tEnemyStartPosition)
    --                             if iPlateauOrZero > 0 then
    --                                    tLZOrWZTeamData  = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][aiBrain.M28Team]
    --                                else
    --                                    --Water zone
    --                                tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][aiBrain.M28Team]
    --                            end


    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetClosestPlateauOrZeroAndZoneToPosition'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tPosition)

    if bDebugMessages == true then LOG(sFunctionRef..': tPosition='..repru(tPosition)..'; iSegmentX='..(iSegmentX or 'nil')..' iSegmentZ='..(iSegmentZ or 'nil')..'; Is override for this nil='..tostring(tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ] == nil)..'; GetPositionFromPathingSegments(iSegmentX, iSegmentZ)='..repru(GetPositionFromPathingSegments(iSegmentX, iSegmentZ))..'; Hover nav utils for segment midpoint='..(NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iSegmentX, iSegmentZ)) or 'nil')..'; Hover nav utils for tPosition='..(NavUtils.GetLabel(refPathingTypeHover, tPosition) or 'nil')..'; tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ]='..repru(tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ])..'; tLandZoneBySegment[iSegmentX][iSegmentZ]='..(tLandZoneBySegment[iSegmentX][iSegmentZ] or 'nil')..'; tWaterZoneBySegment[iSegmentX][iSegmentZ]='..(tWaterZoneBySegment[iSegmentX][iSegmentZ] or 'nil')) end

    if tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ] then
        if bDebugMessages == true then LOG(sFunctionRef..': Returning override, which is:'..repru(tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ])) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ][1], tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ][2]
    else
        local iPlateau = NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iSegmentX, iSegmentZ))
        local iLandZone = tLandZoneBySegment[iSegmentX][iSegmentZ]
        local tLZData
        if iLandZone and iPlateau then tLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone] end

        if bDebugMessages == true then LOG(sFunctionRef..': Position from segments='..repru(GetPositionFromPathingSegments(iSegmentX, iSegmentZ))..'; iPlateau for this='..(iPlateau or 'nil')) end
        if not(iPlateau) or (not(tLZData) and tWaterZoneBySegment[iSegmentX][iSegmentZ] == nil) then
            if (iSegmentX <= -30 or iSegmentZ <= -30 or iSegmentX >= iMaxLandSegmentX + 30 or iSegmentZ >= iMaxLandSegmentZ + 30) then
                --E.g. RNG can sometimes send air units far outside the map area
                M28Utilities.ErrorHandler('Given a position that is far outside the playable area, even if it was for an air unit, so wont search for a potential zone', true)
            else

                --Need to get an override if dont already have one
                local iAltPlateau, iAltLZOrWZ
                local iFailureCount = 0
                if not(tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX]) then tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX] = {} end
                for iAdjust = 1, math.min(iMaxLandSegmentX, iMaxLandSegmentZ) do
                    for iXAdjust = -iAdjust, iAdjust, 1 do
                        for iZAdjust = -iAdjust, iAdjust, 1 do
                            if not(iXAdjust == 0 and iZAdjust == 0) then
                                if tLandZoneBySegment[iSegmentX+ iXAdjust][iSegmentZ+ iZAdjust] or tWaterZoneBySegment[iSegmentX+ iXAdjust][iSegmentZ+ iZAdjust] then
                                    local tMidpoint = GetPositionFromPathingSegments(iSegmentX + iXAdjust, iSegmentZ + iZAdjust)
                                    tMidpoint = {math.floor(tMidpoint[1]), tMidpoint[2], math.floor(tMidpoint[3])}
                                    if tPathingPlateauAndLZOverride[tMidpoint[1]][tMidpoint[3]][2] then
                                        if bDebugMessages == true then LOG(sFunctionRef..': We already recorded an override for this position') end
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        return tPathingPlateauAndLZOverride[tMidpoint[1]][tMidpoint[3]][1], tPathingPlateauAndLZOverride[tMidpoint[1]][tMidpoint[3]][2]
                                    else
                                        iAltPlateau = NavUtils.GetLabel(refPathingTypeHover, tMidpoint)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjust='..iAdjust..'; iXAdjust='..iXAdjust..'; iZAdjust='..iZAdjust..'; iAltPlateau='..(iAltPlateau or 'nil')..'; LandZoneBySegment='..(tLandZoneBySegment[iSegmentX+ iXAdjust][iSegmentZ+ iZAdjust] or 'nil')..'; Water zone by segment='..(tWaterZoneBySegment[iSegmentX+ iXAdjust][iSegmentZ+ iZAdjust] or 'nil')) end
                                        if (iAltPlateau or 0) > 0 then
                                            iAltLZOrWZ = tLandZoneBySegment[iSegmentX+ iXAdjust][iSegmentZ+ iZAdjust]
                                            if (iAltLZOrWZ or 0) == 0 then
                                                iAltLZOrWZ = tWaterZoneBySegment[iSegmentX+ iXAdjust][iSegmentZ+ iZAdjust]
                                                iAltPlateau = 0
                                            end
                                            if (iAltLZOrWZ or 0) > 0 and (iAltPlateau == 0 or tAllPlateaus[iAltPlateau][subrefPlateauLandZones][iAltLZOrWZ]) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have adjusted segments which have valid values, iAltLZOrWZ='..iAltLZOrWZ..'; iXAdjust='..iXAdjust..'; iZAdjust='..iZAdjust) end
                                                tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ] = {[1] = iAltPlateau, [2] = iAltLZOrWZ}
                                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                                return iAltPlateau, iAltLZOrWZ
                                            else
                                                --Redundancy
                                                iFailureCount = iFailureCount + 1
                                                if iFailureCount >= 20 then
                                                    M28Utilities.ErrorHandler('Have a valid plateau for SegmentX-Z='..(iSegmentX + iXAdjust)..'-'..(iSegmentZ + iZAdjust)..' but not a valid land or water zone, and have failed '..iFailureCount..' times now (will reset count after this)')
                                                    if bDebugMessages == true then LOG(sFunctionRef..': iAltPlateau='..iAltPlateau..'; iAltLZOrWZ='..iAltLZOrWZ..'; Is LZ info for this nil='..tostring(tAllPlateaus[iAltPlateau][subrefPlateauLandZones][iAltLZOrWZ] == nil)..'; Hover label for segment at this adjustment='..(NavUtils.GetTerrainLabel(refPathingTypeHover, tMidpoint) or 'nil')..'; tMidpoint='..repru(tMidpoint))
                                                        M28Utilities.DrawLocation(tMidpoint, 2)
                                                    end
                                                    iFailureCount = 0
                                                end
                                            end
                                        else
                                            if iFailureCount >= 20 then
                                                M28Utilities.ErrorHandler('Have a valid land or WZ for SegmentX-Z='..(iSegmentX + iXAdjust)..'-'..(iSegmentZ + iZAdjust)..' but not a valid plateau, and have failed '..iFailureCount..' times now (will reset count after this)')
                                                iFailureCount = 0
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    if iAdjust >= 100 then M28Utilities.ErrorHandler('Likely error locating valid segment for iSegmentX-Z='..iSegmentX..'-'..iSegmentZ..'; iMaxLandSegmentX='..iMaxLandSegmentX..'; iMaxLandSegmentZ='..iMaxLandSegmentZ..'; iLandZoneSegmentSize='..iLandZoneSegmentSize..'; iMapSize='..iMapSize) end
                end
            end
        else
            --Have a valid plateau and land or water zone
            if bDebugMessages == true then LOG(sFunctionRef..': Have a valid plateau, tLandZoneBySegment='..(tLandZoneBySegment[iSegmentX][iSegmentZ] or 'nil')..'; tWaterZoneBySegment='..(tWaterZoneBySegment[iSegmentX][iSegmentZ] or 'nil')) end
            if (tLandZoneBySegment[iSegmentX][iSegmentZ] or 0) == 0 then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return 0, tWaterZoneBySegment[iSegmentX][iSegmentZ]
            else

                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return iPlateau, tLandZoneBySegment[iSegmentX][iSegmentZ]
            end
        end
    end
end

---@param tLocation table
---@return number, number
function GetReclaimSegmentsFromLocation(tLocation)
    --Returns the reclaim segment X and Z values for a given location on the map (i.e. map is divided into reclaim segment squares which are a different size to land zone segments)
    --tLocation should be in the {x,y,z} format, although y value is ignored
    return math.ceil(tLocation[1] / iReclaimSegmentSizeX), math.ceil(tLocation[3] / iReclaimSegmentSizeZ)
end

---@param iReclaimSegmentX number
---@param iReclaimSegmentZ number
---@return table
function GetReclaimLocationFromSegment(iReclaimSegmentX, iReclaimSegmentZ)
    --If given the reclaim segment X and Z values, then will convert this into an {x,y,z} position
    --e.g. segment (1,1) will be 0 to ReclaimSegmentSizeX and 0 to ReclaimSegmentSizeZ in size
    --This will return the midpoint of the reclaim segment
    if tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint] then return tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint]
    else
        local iX = math.max(rMapPotentialPlayableArea[1], math.min(rMapPotentialPlayableArea[3], (iReclaimSegmentX - 0.5) * iReclaimSegmentSizeX))
        local iZ = math.max(rMapPotentialPlayableArea[2], math.min(rMapPotentialPlayableArea[4], (iReclaimSegmentZ - 0.5) * iReclaimSegmentSizeZ))
        return {iX, GetSurfaceHeight(iX, iZ), iZ}
    end
end

function SetupPlayableAreaAndSegmentSizes(rCampaignPlayableAreaOverride)
    --Sets up key values needed to divide the map up into segments (small squares) for both land zone segments and reclaim segments - should be called as one of the first pieces of code
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupPlayableAreaAndSegmentSizes'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': About to set playable area at time='..GetGameTimeSeconds()..'; ScenarioInfo.MapData.PlayableRect='..repru(ScenarioInfo.MapData.PlayableRect)..'; bMapLandSetupComplete='..tostring(bMapLandSetupComplete or false)..'; bIsCampaignMap='..tostring(bIsCampaignMap or false)..'; rCampaignPlayableAreaOverride='..repru(rCampaignPlayableAreaOverride)..'; Sync.NewPlayableArea='..repru(Sync.NewPlayableArea)..'; bPlayableAreaSetup='..tostring(bPlayableAreaSetup)) end
    if ScenarioInfo.MapData.PlayableRect then --and (bMapLandSetupComplete or not(bIsCampaignMap)) then
        rMapPlayableArea = ScenarioInfo.MapData.PlayableRect
    else
        rMapPlayableArea = {0, 0, ScenarioInfo.size[1], ScenarioInfo.size[2]}
    end
    if bIsCampaignMap then --Want to setup segments etc. based on total map size as the map is likely to expand later on
        rMapPotentialPlayableArea = {0, 0, ScenarioInfo.size[1], ScenarioInfo.size[2]}
    else
        rMapPotentialPlayableArea = rMapPlayableArea
    end
    if rCampaignPlayableAreaOverride and M28Utilities.IsTableEmpty(rCampaignPlayableAreaOverride) == false then
        local rNewRect = {}
        if rCampaignPlayableAreaOverride['x0'] then
            rNewRect = {rCampaignPlayableAreaOverride['x0'], rCampaignPlayableAreaOverride['y0'], rCampaignPlayableAreaOverride['x1'], rCampaignPlayableAreaOverride['y1']}
        else
            for iEntry, tPosition in rCampaignPlayableAreaOverride do
                table.insert(rNewRect, tPosition)
            end
        end
        if ScenarioInfo.MapData.PlayableRect then --limit playable area to scenarioinfo playable area
            local rScenarioPlayableRect = ScenarioInfo.MapData.PlayableRect
            rNewRect[1] = math.max(rNewRect[1], rScenarioPlayableRect[1])
            rNewRect[2] = math.max(rNewRect[2], rScenarioPlayableRect[2])
            rNewRect[3] = math.min(rNewRect[3], rScenarioPlayableRect[3])
            rNewRect[4] = math.min(rNewRect[4], rScenarioPlayableRect[4])
        end
        if bDebugMessages == true then
            LOG(sFunctionRef..': Updating playable rect for override, rCampaignPlayableAreaOverride='..repru(rCampaignPlayableAreaOverride)..'; ScenarioInfo.MapData.PlayableRect='..repru(ScenarioInfo.MapData.PlayableRect)..'; rNewRect='..repru(rNewRect))
            M28Utilities.DrawRectangle(rCampaignPlayableAreaOverride, 2, 1000, 0)
        end
        rMapPlayableArea = rNewRect
    end

    iMapSize = (rMapPotentialPlayableArea[3] - rMapPotentialPlayableArea[1] + rMapPotentialPlayableArea[4] - rMapPotentialPlayableArea[2]) * 0.5


    --Decide on land zone segment sizes
    local iHighestSize = math.max(rMapPlayableArea[3] - rMapPlayableArea[1], rMapPlayableArea[4] - rMapPlayableArea[2])
    local iTableSizeCap = 125000 --e.g. 1x1 resolution on a 10km, 3x3 resolution on a 20km (athough changed to 2x2 resolution on 10km per the below)
    if not(bMapLandSetupComplete) then --e.g. if this is a campaign we may want to change playable area size
        --iTableSizeCap = SegmentCount^2; SegmentCount = iTotalSize / SegmentSize; (TotalSize/SegmentSize)^2 = iTableSizeCap; SemgentSize = TotalSize/Sqrt(iTableSizeCap)
        iLandZoneSegmentSize = math.ceil(iHighestSize / math.sqrt(iTableSizeCap))
        if iMapSize > 256 then ilandZoneSegmentSize = math.max(iLandZoneSegmentSize, 2) end --otherwise get too many building locations

        --Record the max values
        iMaxLandSegmentX, iMaxLandSegmentZ = GetPathingSegmentFromPosition({rMapPotentialPlayableArea[3], 0, rMapPotentialPlayableArea[4]})

        if bDebugMessages == true then LOG(sFunctionRef..': iHighestSize='..iHighestSize..'; iTableSizeCap='..iTableSizeCap..'; iLandZoneSegmentSize='..iLandZoneSegmentSize..'; Max Segment X-Z='..iMaxLandSegmentX..'-'..iMaxLandSegmentZ) end


        local iMinReclaimSegmentSize = 8.5 --Engineer build range is 6; means that a square of about 4.2 will fit inside this circle; If have 2 separate engineers assigned to adjacent reclaim segments, and want their build range to cover the two areas, then would want a gap twice this, so 8.4; will therefore go with min size of 8
        local iMapSizeX = rMapPotentialPlayableArea[3] - rMapPotentialPlayableArea[1]
        local iMapSizeZ = rMapPotentialPlayableArea[4] - rMapPotentialPlayableArea[2]
        iReclaimSegmentSizeX = math.max(iMinReclaimSegmentSize, iLandZoneSegmentSize)
        iReclaimSegmentSizeZ = math.max(iMinReclaimSegmentSize, iLandZoneSegmentSize)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, rMapPotentialPlayableArea='..repru(rMapPotentialPlayableArea)..'; actual playable area='..repru(rMapPlayableArea)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end



---@param sPathing string
---@param tLocation table
---@return number
function GetSegmentGroupOfLocation(sPathing, tLocation)
    --Included for backwards compatibility with M27 logic; better to use the below line directly
    --Returns a reference number based on sPathing that groups areas based on whether they can path to each other (so if two locations have the same reference, they can path to each other)
    --sPathing should be one of the refPathingType variables defined at the top of this file; tLocation is {x,y,z} format
    return NavUtils.GetLabel(sPathing, tLocation)
end

local function RecordMexForPathingGroup()
    --Cycles through every mex on the map, and includes it in a table of mexes that is grouped by pathing type, so in future we can easily cycle through mexes for a particular pathing type
    --e.g. after running this, can use tMexByPathingAndGrouping[sPathing][iPathingGroup] where sPathing is the refPathingType variable, and ipathingGroup is the NavUtils.GetLabel(sPathing, tLocation) reference
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordMexForPathingGroup'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': About to record mexes for each pathing group. MassPoints='..repru(tMassPoints)) end
    local tsPathingTypes = {refPathingTypeHover, refPathingTypeNavy, refPathingTypeLand}
    local iCurResourceGroup
    local iValidCount = 0
    tMexByPathingAndGrouping = {}
    if bDebugMessages == true then
        LOG(sFunctionRef..': NavUtils test - will cycle through each mex and get land label')
        for iMex, tMex in tMassPoints do
            LOG(sFunctionRef..': tMex='..repru(tMex)..'; Label='..(NavUtils.GetTerrainLabel('Land', tMex) or 'nil'))
            if not(NavUtils.GetTerrainLabel('Land', tMex)) then
                LOG(sFunctionRef..': WARNING - dont have a land label for mex '..repru(tMex))
            else
                LOG(sFunctionRef..': Have a land label for mex '..repru(tMex)..' so will stop with warning messages as pathing apepars generated')
                break
            end
        end
    end
    local tbMexNeedsPathingAdjust = {}
    local bHadInvalidMex = false
    for iPathingType, sPathing in tsPathingTypes do
        tMexByPathingAndGrouping[sPathing] = {}
        iValidCount = 0

        if bDebugMessages == true then LOG(sFunctionRef..': About to record all mexes for pathing type sPathing='..sPathing) end

        for iCurMex, tMexLocation in tMassPoints do

            iValidCount = iValidCount + 1
            iCurResourceGroup = NavUtils.GetTerrainLabel(sPathing, tMexLocation)

            if not(iCurResourceGroup) then
                if sPathing == refPathingTypeHover or (sPathing == refPathingTypeLand and tbMexNeedsPathingAdjust[iCurMex] == nil) then
                    tbMexNeedsPathingAdjust[iCurMex] = true
                    bHadInvalidMex = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Unable to find any land or navy pathing groups, or lack a hover pathing type, so want to search wider for the mex to find a pathing group') end
                end
                if bDebugMessages == true then LOG('For sPathing '..sPathing..' we dont have a resource group for mex location '..repru(tMexLocation)..'; This is expected if mexes are located outside the playable area or are testing water pathing for land mexes and vice versa') end
            else
                if bDebugMessages == true then
                    LOG(sFunctionRef..': iCurMex='..iCurMex..'; About to get segment group for pathing='..sPathing..'; location='..repru((tMexLocation or {'nil'}))..'; iCurResourceGroup='..(iCurResourceGroup or 'nil'))
                    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tMexLocation)
                    LOG(sFunctionRef..': Pathing segments='..(iSegmentX or 'nil')..'; iSegmentZ='..(iSegmentZ or 'nil')..'; rMapPotentialPlayableArea='..repru(rMapPotentialPlayableArea)..'; iLandZoneSegmentSize='..(iLandZoneSegmentSize or 'nil'))
                end
                if tMexByPathingAndGrouping[sPathing][iCurResourceGroup] == nil then
                    tMexByPathingAndGrouping[sPathing][iCurResourceGroup] = {}
                    iValidCount = 1
                else iValidCount = table.getn(tMexByPathingAndGrouping[sPathing][iCurResourceGroup]) + 1
                end
                tMexByPathingAndGrouping[sPathing][iCurResourceGroup][iValidCount] = tMexLocation
                if sPathing == refPathingTypeLand or sPathing == refPathingTypeNavy then tbMexNeedsPathingAdjust[iCurMex] = false end
                if bDebugMessages == true then LOG(sFunctionRef..': iValidCount='..iValidCount..'; sPathing='..sPathing..'; iCurResourceGroup='..iCurResourceGroup..'; just added tMexLocation='..repru(tMexLocation)..' to this group') end
            end
        end
        if sPathing == refPathingTypeLand and iValidCount == 0 then M28Utilities.ErrorHandler('Dont have any mexes recording for land pathing type') end
    end
    if bHadInvalidMex then
        local iBaseSegmentX, iBaseSegmentZ, iDistAdjust, iPossiblePlateau, iPossibleIsland, iPossiblePond, bFoundAlternative
        function ConsiderAltLocation(iCurMex, tAltLocation, tMexLocation)
            iPossiblePlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, tAltLocation)
            if bDebugMessages == true then LOG(sFunctionRef..': tAltLocation='..repru(tAltLocation)..'; iPossiblePlateau='..(iPossiblePlateau or 'nil')) end
            if iPossiblePlateau then
                iPossiblePond = NavUtils.GetTerrainLabel(refPathingTypeNavy, tAltLocation)
                iPossibleIsland = NavUtils.GetTerrainLabel(refPathingTypeLand, tAltLocation)
                if bDebugMessages == true then LOG(sFunctionRef..': iPossiblePond='..(iPossiblePond or 'nil')..'; iPossibleIsland='..(iPossibleIsland or 'nil')) end
                if iPossibleIsland or iPossiblePond then
                    tMexPathingLabelOverride[iCurMex] = {iPossiblePlateau, iPossibleIsland, iPossiblePond}
                    local iValidPlateauCount = 1
                    local iValidIslandCount = 1
                    local iValidPondCount = 1
                    if M28Utilities.IsTableEmpty(tMexByPathingAndGrouping[refPathingTypeHover][iPossiblePlateau]) == false then
                        iValidPlateauCount = table.getn(tMexByPathingAndGrouping[refPathingTypeHover][iPossiblePlateau]) + 1
                    else
                        tMexByPathingAndGrouping[refPathingTypeHover][iPossiblePlateau] = {}
                    end
                    tMexByPathingAndGrouping[refPathingTypeHover][iPossiblePlateau][iValidPlateauCount] = tMexLocation
                    if iPossiblePond then
                        if M28Utilities.IsTableEmpty(tMexByPathingAndGrouping[refPathingTypeNavy][iPossiblePond]) == false then
                            iValidPondCount = table.getn(tMexByPathingAndGrouping[refPathingTypeNavy][iPossiblePond]) + 1
                        else
                            tMexByPathingAndGrouping[refPathingTypeNavy][iPossiblePond] = {}
                        end
                        tMexByPathingAndGrouping[refPathingTypeNavy][iPossiblePond][iValidPondCount] = tMexLocation
                    end
                    if iPossibleIsland then
                        if M28Utilities.IsTableEmpty(tMexByPathingAndGrouping[refPathingTypeLand][iPossibleIsland]) == false then
                            iValidIslandCount = table.getn(tMexByPathingAndGrouping[refPathingTypeLand][iPossibleIsland]) + 1
                        else
                            tMexByPathingAndGrouping[refPathingTypeLand][iPossibleIsland][iPossibleIsland] = {}
                        end
                        tMexByPathingAndGrouping[refPathingTypeLand][iPossibleIsland][iValidIslandCount] = tMexLocation
                    end
                    bFoundAlternative = true
                    return true
                end
            end
            if bDebugMessages == true then M28Utilities.DrawLocation(tAltLocation, 2, 150, iLandZoneSegmentSize * 0.5) end
        end                
        for iCurMex, tMexLocation in tMassPoints do
            if tbMexNeedsPathingAdjust[iCurMex] then
                bFoundAlternative = false
                iBaseSegmentX, iBaseSegmentZ = GetPathingSegmentFromPosition(tMexLocation)
                local tBasePosition = tMexLocation --for ease of reference since code was copied from similar function elsewhere
                if bDebugMessages == true then LOG(sFunctionRef..': Trying to find alternative location for tMex='..repru(tMexLocation)..'; iCurMex='..iCurMex) end
                for iBaseAdjust = 1, 4 do

                    iDistAdjust = math.max(2, iLandZoneSegmentSize) * iBaseAdjust
                    local tLocationAdjust = {{-iDistAdjust,0}, {-iDistAdjust, -iDistAdjust}, {-iDistAdjust, iDistAdjust}, {0, -iDistAdjust}, {0, iDistAdjust}, {iDistAdjust, -iDistAdjust}, {iDistAdjust, 0}, {iDistAdjust,iDistAdjust}}
                    if bDebugMessages == true then LOG(sFunctionRef..': Will look in a box around the unit to see if can find a valid plateau, iDistAdjust='..iDistAdjust) end
                    for iEntry, tAdjustXZ in tLocationAdjust do
                        if ConsiderAltLocation(iCurMex, { tBasePosition[1] + tAdjustXZ[1], tBasePosition[2], tBasePosition[3] + tAdjustXZ[2] }, tMexLocation) then break end
                    end
                    if not(bFoundAlternative) then
                        --Try in a 1x1 box around the unit to see if we can find a plateau that is land pathable, and if so, see if we can path to a land zone, and if so then update to record this as the closest land zone
                        iDistAdjust = 1
                        tLocationAdjust = {{0,0}, {-iDistAdjust,0}, {-iDistAdjust, -iDistAdjust}, {-iDistAdjust, iDistAdjust}, {0, -iDistAdjust}, {0, iDistAdjust}, {iDistAdjust, -iDistAdjust}, {iDistAdjust, 0}, {iDistAdjust,iDistAdjust}}
                        if bDebugMessages == true then LOG(sFunctionRef..': Will look in a smaller radius box around the unit to see if can find a valid plateau, iDistAdjust='..iDistAdjust) end
                        for iEntry, tAdjustXZ in tLocationAdjust do
                            if ConsiderAltLocation(iCurMex, { tBasePosition[1] + tAdjustXZ[1], tBasePosition[2], tBasePosition[3] + tAdjustXZ[2] }, tMexLocation) then break end
                        end
                    end
                    if bFoundAlternative then break end
                end
                if not(bFoundAlternative) then M28Utilities.ErrorHandler('Have a mex where we couldnt find a nearby valid land or water zone, Mex=X'..tMexLocation[1]..'Y'..tMexLocation[2]..'Z'..tMexLocation[3]) end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..'; tMexByPathingAndGrouping='..repru(tMexByPathingAndGrouping)..'; tMexPathingLabelOverride='..repru(tMexPathingLabelOverride)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordMexlessPlateau(iPlateau)
    tAllPlateaus[iPlateau] = {}
    tAllPlateaus[iPlateau][subrefPlateauTotalMexCount] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones] = {}
    tAllPlateaus[iPlateau][subrefLandZoneCount] = 0
end

local function RecordAllPlateaus()
    --Records any plateaus that contain mexes, along with info on the plateau
    --tAllPlateaus[iSegmentGroup] can be used to then reference subtables with further information on the plateau, where iSegmentGroup is the result of NavUtils.GetLabel(refPathingTypeHover, {x,y,z})

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAllPlateaus'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCurPlateauMex
    local iMinSegmentX, iMinSegmentZ, iMaxSegmentX, iMaxSegmentZ, iCurSegmentGroup

    if bDebugMessages == true then LOG(sFunctionRef..': About to get max map segment X and Z based on rMapPotentialPlayableArea='..repru(rMapPotentialPlayableArea)) end
    local iMapMaxSegmentX, iMapMaxSegmentZ = GetPathingSegmentFromPosition({rMapPotentialPlayableArea[3], 0, rMapPotentialPlayableArea[4]})
    local iStartSegmentX, iStartSegmentZ
    local bSearchingForBoundary
    local iCurCount
    local tSegmentPositionMin, tSegmentPositionMax
    local iReclaimSegmentStartX, iReclaimSegmentStartZ, iReclaimSegmentEndX, iReclaimSegmentEndZ
    local sPathing = refPathingTypeHover


    --Cycle through every amphibious pathing group that has mexes in it:
    for iSegmentGroup, tSubtable in tMexByPathingAndGrouping[sPathing] do
        --If we dont already have a plateau setup then create one:
        if not(tAllPlateaus[iSegmentGroup]) then
            --Have a plateau with mexes that havent already recorded
            tAllPlateaus[iSegmentGroup] = {}
            tAllPlateaus[iSegmentGroup][subrefPlateauMexes] = {}
            iCurPlateauMex = 0
            --Record every mex against the PlateausWithMexes table:
            for iMex, tMex in tMexByPathingAndGrouping[sPathing][iSegmentGroup] do
                iCurPlateauMex = iCurPlateauMex + 1
                tAllPlateaus[iSegmentGroup][subrefPlateauMexes][iCurPlateauMex] = tMex
            end
            tAllPlateaus[iSegmentGroup][subrefPlateauTotalMexCount] = iCurPlateauMex
            --Record additional information if the plateau has mexes (v101 - removed this so we can drop mexless plateaus with reclaim):
            if iCurPlateauMex > 0 then
                --NOTE: Minor plateaus will have details added later on after zones have been recorded along with zone min and max values
                                
                --Record information on the size of the plateau:
                --Start from mex, and move up on map to determine top point; then move left to determine left point, and right to determine right point etc.
                --i.e. dont want to go through every segment on map since could take ages if lots of plateaus and may only be dealing with small area
                iStartSegmentX, iStartSegmentZ = GetPathingSegmentFromPosition(tAllPlateaus[iSegmentGroup][subrefPlateauMexes][1])

                --First find the smallest z (so go up)
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount > iStartSegmentZ then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetTerrainLabel(sPathing, GetPositionFromPathingSegments(iStartSegmentX, iStartSegmentZ - iCurCount))  --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX][iStartSegmentZ - iCurCount]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartX = 1, iMapMaxSegmentX do
                            iCurSegmentGroup = NavUtils.GetTerrainLabel(sPathing, GetPositionFromPathingSegments(iAltStartX, iStartSegmentZ - iCurCount)) --tPathingSegmentGroupBySegment[sPathing][iAltStartX][iStartSegmentZ - iCurCount]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentX = iAltStartX
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                --Will have the min Z value now
                iMinSegmentZ = iStartSegmentZ - iCurCount + 1


                --Now check for the min X value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount > iStartSegmentX then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetTerrainLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX - iCurCount), iStartSegmentZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX - iCurCount][iStartSegmentZ]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same X value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartZ = iMinSegmentZ, iMapMaxSegmentZ do
                            iCurSegmentGroup = NavUtils.GetTerrainLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX - iCurCount), iAltStartZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX - iCurCount][iAltStartZ]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentZ = iAltStartZ
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end

                --Will now have the min X value
                iMinSegmentX = iStartSegmentX - iCurCount + 1

                --Now get max Z value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount + iStartSegmentZ > iMapMaxSegmentZ then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetTerrainLabel(sPathing, GetPositionFromPathingSegments(iStartSegmentX, (iStartSegmentZ + iCurCount))) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX][iStartSegmentZ + iCurCount]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartX = iMinSegmentX, iMapMaxSegmentX do
                            iCurSegmentGroup = NavUtils.GetTerrainLabel(sPathing, GetPositionFromPathingSegments(iAltStartX, (iStartSegmentZ + iCurCount))) --tPathingSegmentGroupBySegment[sPathing][iAltStartX][iStartSegmentZ + iCurCount]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentX = iAltStartX
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                iMaxSegmentZ = iStartSegmentZ + iCurCount - 1

                --Now get the max X value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount + iStartSegmentX > iMapMaxSegmentX then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetTerrainLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX + iCurCount), iStartSegmentZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX + iCurCount][iStartSegmentZ]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartZ = iMinSegmentZ, iMaxSegmentZ do
                            iCurSegmentGroup = NavUtils.GetTerrainLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX + iCurCount), iAltStartZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX + iCurCount][iAltStartZ]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentZ = iAltStartZ
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                iMaxSegmentX = iStartSegmentX + iCurCount - 1

                --Have now got the min and max land segment X and Z values for the plateau
                tSegmentPositionMin = GetPositionFromPathingSegments(iMinSegmentX, iMinSegmentZ)
                tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ] = {tSegmentPositionMin[1], tSegmentPositionMin[3]}                

                tSegmentPositionMax = GetPositionFromPathingSegments(iMaxSegmentX, iMaxSegmentZ)
                tAllPlateaus[iSegmentGroup][subrefPlateauMaxXZ] = {tSegmentPositionMax[1], tSegmentPositionMax[3]}

                RecordPlateauReclaimSegmentsMidpointAndRadius(iSegmentGroup, sPathing, tSegmentPositionMin, tSegmentPositionMax)
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, listing tAllPlateaus='..repru(tAllPlateaus)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordPlateauReclaimSegmentsMidpointAndRadius(iPlateau, sPathing, tSegmentPositionMin, tSegmentPositionMax)
    iReclaimSegmentStartX, iReclaimSegmentStartZ = GetReclaimSegmentsFromLocation(tSegmentPositionMin)
    iReclaimSegmentEndX, iReclaimSegmentEndZ = GetReclaimSegmentsFromLocation(tSegmentPositionMax)

    --Record all reclaim segments that are part of the plateau
    tAllPlateaus[iPlateau][subrefPlateauReclaimSegments] = {}
    for iCurReclaimSegmentX = iReclaimSegmentStartX, iReclaimSegmentEndX do
        tAllPlateaus[iPlateau][subrefPlateauReclaimSegments][iCurReclaimSegmentX] = {}
        for iCurReclaimSegmentZ = iReclaimSegmentStartZ, iReclaimSegmentEndZ do
            if iPlateau == NavUtils.GetTerrainLabel(sPathing,GetReclaimLocationFromSegment(iCurReclaimSegmentX, iCurReclaimSegmentZ)) then
                tAllPlateaus[iPlateau][subrefPlateauReclaimSegments][iCurReclaimSegmentX][iCurReclaimSegmentZ] = true
            end
        end
    end
    --Clear any empty values
    for iCurReclaimSegmentX = iReclaimSegmentStartX, iReclaimSegmentEndX do
        if tAllPlateaus[iPlateau][subrefPlateauReclaimSegments][iCurReclaimSegmentX] and M28Utilities.IsTableEmpty(tAllPlateaus[iPlateau][subrefPlateauReclaimSegments][iCurReclaimSegmentX]) then tAllPlateaus[iPlateau][subrefPlateauReclaimSegments][iCurReclaimSegmentX] = nil end
    end

    --Record midpoint of the plateau
    local iXRadius = (tAllPlateaus[iPlateau][subrefPlateauMaxXZ][1] - tAllPlateaus[iPlateau][subrefPlateauMinXZ][1])*0.5
    local iZRadius = (tAllPlateaus[iPlateau][subrefPlateauMaxXZ][2] - tAllPlateaus[iPlateau][subrefPlateauMinXZ][2])*0.5
    tAllPlateaus[iPlateau][subrefPlateauMidpoint] = {tAllPlateaus[iPlateau][subrefPlateauMinXZ][1] + iXRadius, 0, tAllPlateaus[iPlateau][subrefPlateauMinXZ][2] + iZRadius}
    tAllPlateaus[iPlateau][subrefPlateauMidpoint][2] = GetTerrainHeight(tAllPlateaus[iPlateau][subrefPlateauMidpoint][1], tAllPlateaus[iPlateau][subrefPlateauMidpoint][3])
    --CIrcle radius will be the square/rectangle diagonal, so (square radius^2*2)^0.5 for a square, or (x^2+z^2)^0.5

    tAllPlateaus[iPlateau][subrefPlateauMaxRadius] = (iXRadius^2+iZRadius^2)^0.5
end

---@param iPlateau number
local function AddNewLandZoneReferenceToPlateau(iPlateau)
    --Adds a new land zone reference number to iPlateau, assumes that information about the zone will be added later
    --Intended to be called as part of wider code for recording a land zone, e.g. from CreateNewLandZoneAtSegment and similar functions
    --iPlateau is the result of NavUtils.GetLabel(refPathingTypeHover, tLocation)
    --To get the land zone created by this immediately after it is created, use iLandZone = tAllPlateaus[iPlateau][subrefLandZoneCount]
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddNewLandZoneReferenceToPlateau'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if not(tAllPlateaus[iPlateau]) then
        --Presumably we have a plateau with no mexes so add this plateau to the table of plateaus
        tAllPlateaus[iPlateau] = {}
        tAllPlateaus[iPlateau][subrefPlateauTotalMexCount] = 0
    end
    if not(tAllPlateaus[iPlateau][subrefLandZoneCount]) then
        tAllPlateaus[iPlateau][subrefLandZoneCount] = 0
        tAllPlateaus[iPlateau][subrefPlateauLandZones] = {}
    end
    tAllPlateaus[iPlateau][subrefLandZoneCount] = (tAllPlateaus[iPlateau][subrefLandZoneCount] or 0) + 1
    local iLandZone = tAllPlateaus[iPlateau][subrefLandZoneCount]
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexCount] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexLocations] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefMexUnbuiltLocations] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefHydroLocations] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefHydroUnbuiltLocations] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefBuildLocationsBySizeAndSegment] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefBuildLocationBlacklistByPosition] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefQueuedLocationsByPosition] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefBuildLocationSegmentCountBySize] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTotalSegmentCount] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefTotalMassReclaim] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefTotalSignificantMassReclaim] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefHighestIndividualReclaim] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTotalEnergyReclaim] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTravelDistToOtherLandZones] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZPlayerWallSegments] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][refiAllOmniCoverage] = 0

    if bDebugMessages == true then LOG('Time='..GetGameTimeSeconds()..'; Finished setting up variables for iPlateau='..iPlateau..'; iLandZone='..iLandZone) end


    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end



function RecordSegmentLandZone(iSegmentX, iSegmentZ, iPlateau, iLandZone)
    if not(tLandZoneBySegment[iSegmentX]) then tLandZoneBySegment[iSegmentX] = {} end
    tLandZoneBySegment[iSegmentX][iSegmentZ] = iLandZone
    if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments]) then
        if not(tAllPlateaus[iPlateau]) then
            if not(iPlateau) then M28Utilities.ErrorHandler('Plateau is nil') end
            RecordMexlessPlateau(iPlateau)
        end
        if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]) then
            AddNewLandZoneReferenceToPlateau(iPlateau)
            iLandZone = tAllPlateaus[iPlateau][subrefLandZoneCount]
        end

    end
    if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments]) then
        LOG('ERROR - RecordSegmentLandZoneTempLog: iSegmentX='..(iSegmentX or 'nil')..'; iSegmentZ='..(iSegmentZ or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iPlateau='..(iPlateau or 'nil')..'; tAllPlateaus[iPlateau][subrefPlateauLandZones]='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones]))
        M28Utilities.DrawLocation(GetPositionFromPathingSegments(iSegmentX, iSegmentZ), 1, 200, 3)
    else
        table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments], {iSegmentX, iSegmentZ})
        tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTotalSegmentCount] = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTotalSegmentCount] + 1
    end
    if not(NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iSegmentX, iSegmentZ)) == iPlateau) then
        --Record an override to avoid issues later on when using getlabel
        local tMidpoint = GetPositionFromPathingSegments(iSegmentX, iSegmentZ)
        AddLocationToPlateauExceptions(tMidpoint, iPlateau, iLandZone)
        if not(tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX]) then tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX] = {} end
        tNearestPlateauOrZeroAndZoneSegmentOverride[iSegmentX][iSegmentZ] = {[1] = iPlateau, [2] = iLandZone}

        --LOG('Warning - navutils hover label='..(NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iSegmentX, iSegmentZ)) or 'nil')..'; iSegmentXZ='..iSegmentX..'Z'..iSegmentZ..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil'))
    end
end

local function ReorderLandZoneSegmentsForEachPlateau()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReorderLandZoneSegmentsForEachPlateau'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Updates tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments] so it is sorted based on the distance to the middle of the zone
    local iMidSegmentX, iMidSegmentZ
    local tiSegmentsByDistance
    local tiSortedSegmentsByDistance
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLZSubtable in tPlateauSubtable[subrefPlateauLandZones] do
            tiSegmentsByDistance = {}
            tiSortedSegmentsByDistance = {}
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Midpoint='..repru(tLZSubtable[subrefMidpoint])) end
            iMidSegmentX, iMidSegmentZ = GetPathingSegmentFromPosition(tLZSubtable[subrefMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': About to reorder the segments in iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Segments before sorting='..repru(tLZSubtable[subrefLZSegments])) end
            for iSegmentRef, tSegmentXZ in tLZSubtable[subrefLZSegments] do
                table.insert(tiSegmentsByDistance, {['Segments']={tSegmentXZ[1], tSegmentXZ[2]}, ['Distance']=(math.abs(tSegmentXZ[1] - iMidSegmentX) + math.abs(tSegmentXZ[2] - iMidSegmentZ))})
            end
            --Now sort by distance
            tLZSubtable[subrefLZSegments] = {}
            if bDebugMessages == true then LOG(sFunctionRef..': tiSegmentsByDistance='..repru(tiSegmentsByDistance)) end
            for iEntry, tValue in M28Utilities.SortTableBySubtable(tiSegmentsByDistance, 'Distance', true) do
                if bDebugMessages == true then LOG(sFunctionRef..': iEntry='..iEntry..';tValue='..repru(tValue)..'; Inserting value '..repru(tValue['Segments'])..' into the main LZSubtable') end
                table.insert(tLZSubtable[subrefLZSegments], tValue['Segments'])
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished sorting for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Segments after sorting='..repru(tLZSubtable[subrefLZSegments])) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


---@param iBaseSegmentX number
---@param iBaseSegmentZ number
local function CreateNewLandZoneAtSegment(iBaseSegmentX, iBaseSegmentZ, iOptionalPlateauBackup)
    --Creates a new land zone reference at the land segment given by iBaseSegmentX-iBaseSegmentZ (includes adding new land zone reference to the plateau group that these segments are part of)
    --iBaseSegmentX and Z are the land segment X and Z references
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateNewLandZoneAtSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --First check we dont have a zone assigned already (redundancy)
    if not(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
        --PlateauGroup ref will be the amphibious pathing ref from navutils.getlabel (since that's what is used to define mexes by amphibious pathing group, and plateau recognition then uses the same reference)
        local tMidpoint = GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
        local iPlateau = (NavUtils.GetLabel(refPathingTypeHover, tMidpoint) or NavUtils.GetLabel('Amphibious', tMidpoint) or iOptionalPlateauBackup)
        if (iPlateau or 0) > 0 then
            AddNewLandZoneReferenceToPlateau(iPlateau)
            --LOG('Have just created a new land zone reference for base segment XZ='..iBaseSegmentX..'-'..iBaseSegmentZ..' in the iPlateau='..iPlateau)
            RecordSegmentLandZone(iBaseSegmentX, iBaseSegmentZ, iPlateau, tAllPlateaus[iPlateau][subrefLandZoneCount])
        else
            M28Utilities.ErrorHandler('Tried creating new zone for '..iBaseSegmentX..'-'..iBaseSegmentZ..' but dont have valid plateau iPlateau='..(iPlateau or 'nil'))
        end

    else
        M28Utilities.ErrorHandler('Trying to create a new zone for base segment '..iBaseSegmentX..'-'..iBaseSegmentZ..' when it already has a land zone assigned '..tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ])
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param iPlateau number
---@param iOptionalLandZone number
---@param iPlateauMexRef number
---@param tTempPlateauLandZoneByMexRef table
local function AddMexToLandZone(iPlateau, iOptionalLandZone, iPlateauMexRef, tTempPlateauLandZoneByMexRef, tOptionalMexLocationIfAddingDuringGame)
    --Determine the land zone if it isnt specified
    --iPlateau is the result of NavUtils.GetLabel(refPathingTypeHover, tLocation)
    --iOptionalLandZone - if not specified, then this will create a new land zone for iPlateau and use htis reference
    --iPlateauMexRef - the reference key in the table tAllPlateaus[iPlateau][subrefPlateauMexes], which should return the location of the mex; if nill then will create a new ref
    --tTempPlateauLandZoneByMexRef - temporary table used to store information for purposes of creating the land zones

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddMexToLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Get the land zone that we are using (/create a new land zone if we haven't had one specified to be used):
    local iLandZone
    if iOptionalLandZone then iLandZone = iOptionalLandZone
    else
        AddNewLandZoneReferenceToPlateau(iPlateau)
        iLandZone = tAllPlateaus[iPlateau][subrefLandZoneCount]
    end

    --Add mex to the plateau if no iPlateauMexRef, and also to locations to build - i.e. assume if this triggers taht we are adding the mex part-way through
    if not(iPlateauMexRef) or not(tAllPlateaus[iPlateau][subrefPlateauMexes][iPlateauMexRef]) then
        if M28Utilities.IsTableEmpty(tAllPlateaus[iPlateau][subrefPlateauMexes]) or not(tOptionalMexLocationIfAddingDuringGame) then
            M28Utilities.ErrorHandler('Dont have any mexes recorded for iPlateau '..(iPlateau or 'nil')..'; or havent specified a value for tOptionalMexLocationIfAddingDuringGame')
        else
            local bAlreadyIncluded = false
            for iEntry, tMex in tAllPlateaus[iPlateau][subrefPlateauMexes] do
                if tMex[1] == tOptionalMexLocationIfAddingDuringGame[1] and tMex[3] == tOptionalMexLocationIfAddingDuringGame[3] then
                    if bDebugMessages == true then LOG(sFunctionRef..': Mex '..repru(tOptionalMexLocationIfAddingDuringGame)..' is already included, tMex='..repru(tMex)) end
                    bAlreadyIncluded = true
                    break
                end
            end
            if not(bAlreadyIncluded) then
                local iExistingCount = table.getn(tAllPlateaus[iPlateau][subrefPlateauMexes])

                table.insert(tAllPlateaus[iPlateau][subrefPlateauMexes], {tOptionalMexLocationIfAddingDuringGame[1], tOptionalMexLocationIfAddingDuringGame[2], tOptionalMexLocationIfAddingDuringGame[3]})
                iPlateauMexRef = iExistingCount + 1
                if M28Conditions.CanBuildOnMexLocation(tOptionalMexLocationIfAddingDuringGame) then
                    local tLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
                    if not(tLZData[subrefMexUnbuiltLocations]) then tLZData[subrefMexUnbuiltLocations] = {} end
                    table.insert(tLZData[subrefMexUnbuiltLocations], { tOptionalMexLocationIfAddingDuringGame[1], tOptionalMexLocationIfAddingDuringGame[2], tOptionalMexLocationIfAddingDuringGame[3] })
                    if bDebugMessages == true then LOG(sFunctionRef..': Added mex to table of unbuilt mex locations, iExistingCount='..iExistingCount..'; iPlateauMexRef='..iPlateauMexRef) end
                end
            end
        end
    end

    --Add the mex to this land zone
    local bAlreadyRecorded = false
    local tThisMexLocation = {tAllPlateaus[iPlateau][subrefPlateauMexes][iPlateauMexRef][1], tAllPlateaus[iPlateau][subrefPlateauMexes][iPlateauMexRef][2], tAllPlateaus[iPlateau][subrefPlateauMexes][iPlateauMexRef][3]}
    if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexCount]) then
        M28Utilities.ErrorHandler('No mex count for iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil'))
        tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexCount] = 0
    else
        --Have we already recorded this mex (redundancy for strange issue where getting same mex recorded twice sometimes)

        for iMex, tMex in tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexLocations] do
            if tMex[1] == tThisMexLocation[1] and tMex[3] == tThisMexLocation[3] then
                M28Utilities.ErrorHandler('Already recorded mex, will ignore', true)
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Have already recorded mex, tMex='..repru(tMex)..'; iMex='..iMex..'; tThisMexLocation='..repru(tThisMexLocation))
                end
                bAlreadyRecorded = true
                break
            end
        end
    end
    if not(bAlreadyRecorded) then
        tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexCount] = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexCount] + 1
        table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexLocations], tThisMexLocation)
        if tTempPlateauLandZoneByMexRef[iPlateau] then tTempPlateauLandZoneByMexRef[iPlateau][iPlateauMexRef] = iLandZone end
        if bDebugMessages == true then LOG(sFunctionRef..': iPlateauMexRef='..(iPlateauMexRef or 'nil')..'; tAllPlateaus[iPlateau][subrefPlateauMexes][iPlateauMexRef] repru='..repru(tAllPlateaus[iPlateau][subrefPlateauMexes][iPlateauMexRef])..'; table.getn of mexes for LZ='..table.getn(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexLocations])..'; Recorded mex count='..tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexCount]) end
        local iCurSegmentX, iCurSegmentZ = GetPathingSegmentFromPosition(tAllPlateaus[iPlateau][subrefPlateauMexes][iPlateauMexRef])
        if not(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] == iLandZone) then
            RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iPlateau, iLandZone)
            if bDebugMessages == true then LOG(sFunctionRef..': Hvae recorded a new land zone for segment '..iCurSegmentX..'-'..iCurSegmentZ..' for iPlateau '..iPlateau..'; iLandZone='..iLandZone) end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function AddMexToWaterZone(iPond, iWaterZone, tMex)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddMexToWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Add the mex to this water zone
    local bAlreadyRecorded = false --(expect to be the case every time, but were getting issues with the same location appearing multiple itmes in unbuilt locations so adding as redundancy)
    local tWZData = tPondDetails[iPond][subrefPondWaterZones][iWaterZone]
    if not(tWZData[subrefWZMexLocations]) then
        tWZData[subrefWZMexLocations] = {}
        tWZData[subrefWZMexCount] = 0
    else
        --Check not already recorded
        for iEntry, tLocation in tWZData[subrefWZMexLocations] do
            if math.abs(tLocation[1] - tMex[1]) <= 0.9 and math.abs(tLocation[3] - tMex[3]) <= 0.9 then
                bAlreadyRecorded = true
                break
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Considering recording mex at position '..repru(tMex)..' for iWaterZone'..iWaterZone..'; bAlreadyRecorded='..tostring(bAlreadyRecorded)..'; Can build on mex='..tostring(M28Conditions.CanBuildOnMexLocation(tMex))) end
    if not(bAlreadyRecorded) then
        tWZData[subrefWZMexCount] = tWZData[subrefWZMexCount] + 1
        table.insert(tWZData[subrefWZMexLocations], tMex)

        if M28Conditions.CanBuildOnMexLocation(tMex) then
            if not(tWZData[subrefMexUnbuiltLocations]) then tWZData[subrefMexUnbuiltLocations] = {} end
            table.insert(tWZData[subrefMexUnbuiltLocations], tMex)
            if bDebugMessages == true then LOG(sFunctionRef..': Added mex to table of unbuilt mex locations') end
        else
            --DOuble-check - if there are no buildings in a rectangle around the mex then treat it as buildable (note - havent tested the below as added when thought were failing to record mexes on a map but it turned out to be another unrelated issue)
            local rRect = M28Utilities.GetRectAroundLocation(tMex, 0.9)
            local tUnitsByMex = GetUnitsInRect(rRect)
            local bNearbyMex = false
            if M28Utilities.IsTableEmpty(tUnitsByMex) == false then
                local tBuildingsNearby = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tUnitsByMex)
                if M28Utilities.IsTableEmpty(tBuildingsNearby) == false then
                    bNearbyMex = true
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Backup logic, is tUnitsByMex empty='..tostring(M28Utilities.IsTableEmpty(tUnitsByMex))..'; bNearbyMex ='..tostring(bNearbyMex)) end
            if not(bNearbyMex) then
                if not(tWZData[subrefMexUnbuiltLocations]) then tWZData[subrefMexUnbuiltLocations] = {} end
                table.insert(tWZData[subrefMexUnbuiltLocations], tMex)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param sResourceType string
---@param x number
---@param y number
---@param z number
function RecordResourcePoint(sResourceType,x,y,z,size)
    --called by hook into simInit, more reliable method of figuring out if have adaptive map than using markers, as not all mass markers may have mexes generated on an adaptive map
    --Whenever a resource location is created in the map, this is called, and will record the resource location into a table of mex points (tMassPoints) and hydro points (tHydroPoints) for referencing in later code
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordResourcePoint'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': sResourceType='..sResourceType..'; x='..x..'; y='..y..'; z='..z..'; size='..repru(size)..'; Mass count pre update='..table.getn(tMassPoints)..'; Hydro points pre update='..table.getn(tHydroPoints)) end

    local bAlreadyRecorded = false
    local tResourceTableRef
    if sResourceType == 'Mass' then
        tResourceTableRef = tMassPoints
    elseif sResourceType == 'Hydrocarbon' then
        tResourceTableRef = tHydroPoints
    end
    if M28Utilities.IsTableEmpty(tResourceTableRef) == false then
        for iEntry, tResource in tResourceTableRef do
            if tResource[1] == x and tResource[3] == z then bAlreadyRecorded = true break end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': bAlreadyRecorded='..tostring(bAlreadyRecorded)..'; GameTime='..GetGameTimeSeconds()..'; bMapLandSetupComplete='..tostring(bMapLandSetupComplete or false)) end
    if not(bAlreadyRecorded) then
        table.insert(tResourceTableRef, {x,y,z})

        if bMapLandSetupComplete and GetGameTimeSeconds() >= 3 then
            --E.g. crazyrush type map
            local iPlateauOrZero, iLandOrWaterZone = GetClosestPlateauOrZeroAndZoneToPosition({ x,y,z })
            if bDebugMessages == true then LOG(sFunctionRef..': Map setup is already complete, assumed crazyrsuh scenario, iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; xyz='..x..'-'..y..'-'..z..'; Water position on map='..iMapWaterHeight) end
            if iLandOrWaterZone > 0 then
                if iPlateauOrZero == 0 then
                    AddMexToWaterZone(tiPondByWaterZone[iLandOrWaterZone], iLandOrWaterZone, { x,y,z})
                else
                    AddMexToLandZone(iPlateauOrZero, iLandOrWaterZone, nil, nil, {x,y,z})
                end
            end
        end
    else
        M28Utilities.ErrorHandler('Tried to record a mex but a resource point was already recorded at this position - presumed an error with the map', true)
        LOG(sFunctionRef..': Mex position=X'..x..'Z'..z)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of hook; Mass points post update='..table.getn(tMassPoints)..'; Hydro poitns post update='..table.getn(tHydroPoints)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function AssignTempSegmentsWithDistance()
    --Used to go through the temporary table tTempZoneTravelDistanceBySegment and assign any segments within here to the nearest land zone
    --i.e. Assumes tTempZoneTravelDistanceBySegment has been setup and is a table that has [SegmentX][SegmentZ] values that returns a table with [zone] as the key, which in turn returns the pathing distance from SegmentX-SegmentZ for each zone
    --Goes through all the distance values in tTempZoneTravelDistanceBySegment and picks the lowest distance, and then assigns the X+Z segment to land zone that corresponds to that distance, then clears the table tTempZoneTravelDistanceBySegment


    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignTempSegmentsWithDistance'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iLowestDistance
    local iLowestZone
    local iCurPlateau
    --Cycle through every entry
    if M28Utilities.IsTableEmpty(tTempZoneTravelDistanceBySegment) == false then
        for iCurSegmentX, tSubtable in tTempZoneTravelDistanceBySegment do
            if not(tLandZoneBySegment[iCurSegmentX]) then tLandZoneBySegment[iCurSegmentX] = {} end
            for iCurSegmentZ, tDistanceByZone in tSubtable do
                --Have we not recorded a zone for this segment?
                if not(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]) then
                    iLowestDistance = 10000
                    iLowestZone = nil
                    --Cycle through every distance that has been recorded for this segment, and record the lowest distance and the zone that corresponds to this distance
                    if M28Utilities.IsTableEmpty(tDistanceByZone) == false then
                        for iZone, iDistance in tDistanceByZone do
                            if iDistance < iLowestDistance then
                                iLowestDistance = iDistance
                                iLowestZone = iZone
                            end
                        end
                        --if bDebugMessages == true then LOG(sFunctionRef..': iCurSegmentX='..iCurSegmentX..'; iCurSegmentZ='..iCurSegmentZ..'; Position from pathing segments='..repru(GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ))..'; iLowestZone='..(iLowestZone or 'nil')..'; plateau group='..(NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)) or 'nil')) end
                        iCurPlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ))
                        if not(iCurPlateau) then
                            --We have a land zone, so presumably this segment in isolation isn't in somewhere we recognise, but it is near somewhere suitable; keep searching nearby segments to try and find this land zone
                            iCurPlateau = tTempZonePlateauBySegment[iCurSegmentX][iCurSegmentZ][iLowestZone]

                        end
                        RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iCurPlateau, iLowestZone)
                    end
                end
                tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ] = nil --Clear the value so when we cycle through in the future we dont reconsider this
                tTempZonePlateauBySegment[iCurSegmentX][iCurSegmentZ] = nil
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AssignSegmentsNearMexesToLandZones()
    --With thanks to Jip for providing the core idea for this and some example code

    --The below works on a segment by segment basis, so has issues where our segments are larger than the segments used by navmesh (since unpathable locations appear pathable), so uses a workaround of requiring the two segments to be pathable in a straight line between each other at a more granular level of detail
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignSegmentsNearMexesToLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Polar depression for debugging

    --[[if bDebugMessages == true then
        local tLocations = {{366, 0, 470}, {366, 0, 478}}
        --info: AssignSegmentsNearMexesToLandZones: Segment XZ=X92Z118; iEntry=4; tPosition={ table: 21FAFA50  366, 0, 470 }; Land label=8; tiSegmentXZAndZone[4] label=8
        --info: AssignSegmentsNearMexesToLandZones: Segment XZ=X92Z120; iEntry=4; tPosition={ table: 20998460  366, 0, 478 }; Land label=8; tiSegmentXZAndZone[4] label=8
        tLocations[1][2] = GetSurfaceHeight(tLocations[1][1], tLocations[1][3])
        tLocations[2][2] = GetSurfaceHeight(tLocations[2][1], tLocations[2][3])
        M28Utilities.DrawLocation(tLocations[1], 2) --red
        M28Utilities.DrawLocation(tLocations[2], 4) --gold
        LOG('Label for location '..repru(tLocations[2])..'='..(NavUtils.GetTerrainLabel('Land', tLocations[2]) or 'nil')..'; Label for location '..repru(tLocations[1])..'='..(NavUtils.GetTerrainLabel('Land', tLocations[1]) or 'nil')..'; Terrain label of loc1='..(NavUtils.GetTerrainLabel('Land', tLocations[1]) or 'nil')..'Terrain label of loc2='..(NavUtils.GetTerrainLabel('Land', tLocations[2]) or 'nil'))
        LOG('Travel time between location 1 and 2='..(M28Utilities.GetTravelDistanceBetweenPositions(tLocations[1], tLocations[2], 'Land') or 'nil'))
    end--]]


    function GetNeighbours(iSegmentX, iSegmentZ, tBasePosition)
        --Get the adjacent segments to iSegmentX and Z, and the position of these adjacent segments (ntoe this is slightly different from the segment midpoint as it is based on tBasePosition for simplicity)
        local tTableBeforePositions = {{iSegmentX - 1, iSegmentZ, {{tBasePosition[1] - 1, 0, tBasePosition[3]}}}, {iSegmentX, iSegmentZ - 1, {{tBasePosition[1], 0, tBasePosition[3] - 1}}}, {iSegmentX, iSegmentZ + 1, {{tBasePosition[1], 0, tBasePosition[3] + 1}}}, {iSegmentX + 1, iSegmentZ, {{tBasePosition[1] + 1, 0, tBasePosition[3]}}}}
        if iLandZoneSegmentSize > 1 then
            for iEntry, tSubtable in tTableBeforePositions do
                --if bDebugMessages == true then LOG(sFunctionRef..': tSubtable='..repru(tSubtable)..'; tSubtable[3]='..repru(tSubtable[3])) end
                for iPositionAdjust = 2, iLandZoneSegmentSize, 1 do
                    if iEntry == 1 then
                        table.insert(tSubtable[3], {tBasePosition[1] - iPositionAdjust, 0, tBasePosition[3]})
                    elseif iEntry == 2 then
                        table.insert(tSubtable[3], {tBasePosition[1], 0, tBasePosition[3] - iPositionAdjust})
                    elseif iEntry == 3 then
                        table.insert(tSubtable[3], {tBasePosition[1], 0, tBasePosition[3] + iPositionAdjust})
                    elseif iEntry == 4 then
                        table.insert(tSubtable[3], {tBasePosition[1] + iPositionAdjust, 0, tBasePosition[3]})
                    end
                end
            end
        end
        --if bDebugMessages == true then LOG(sFunctionRef..': tTableBeforePositions='..repru(tTableBeforePositions)) end
        return tTableBeforePositions
    end

    local iMaxSegmentSearchDistance = math.max(10, math.ceil(85 / iLandZoneSegmentSize)) --NOTE: If changing this consider if also want to change the value for AssignRemainingSegmentsToLandZones
    --iMaxSegmentSearchDistance = 5 --Temp for testing
    local iBaseSegmentX, iBaseSegmentZ
    local bHadSomeEntries = false
    local iMexLandZone, iMexLandLabel, bSameLandLabel
    if bDebugMessages == true then LOG(sFunctionRef..': About to start cycling through plateaus and mexes, iLandZoneSegmentSize='..iLandZoneSegmentSize..'; iMaxSegmentSearchDistance='..iMaxSegmentSearchDistance) end
    local bConsiderMexOverride = false
    local tiMexZoneOverrideForPlateau
    local bHaveOverrideForCurPlateau = false
    local bAssignAdjacentToNilPlateau = false
    if M28Utilities.IsTableEmpty(tMexPathingLabelOverride) == false then
        bConsiderMexOverride = true
        if iLandZoneSegmentSize >= 2 then bAssignAdjacentToNilPlateau = true end
    end

    --Cycle through every plateau
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        local tbSegmentHasDifferentZone = {}
        if M28Utilities.IsTableEmpty(tPlateauSubtable[subrefPlateauMexes]) == false then
            bHaveOverrideForCurPlateau = false
            if bConsiderMexOverride then tiMexZoneOverrideForPlateau = { } end
            local iBaseQueueCount = 0
            local tiAdjacentSegmentsForSearchCountByMex = {}
            tiAdjacentSegmentsForSearchCountByMex[0] = {}
            --Cycle through every mex in the current plateau and record as the 'base' position to start searching from
            for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do

                iBaseSegmentX, iBaseSegmentZ = GetPathingSegmentFromPosition(tMex)
                iMexLandZone = tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]
                iMexLandLabel = nil
                if bConsiderMexOverride then
                    for iEntry, tPosition in tMassPoints do
                        if tPosition[1] == tMex[1] and tPosition[3] == tMex[3] then
                            if  tMexPathingLabelOverride[iEntry] then
                                bHaveOverrideForCurPlateau = true
                                iMexLandLabel = tMexPathingLabelOverride[iEntry][2]
                                table.insert(tiMexZoneOverrideForPlateau, {iMex, iMexLandZone})
                            end
                            break
                        end
                    end
                    if not(iMexLandLabel) then iMexLandLabel = NavUtils.GetTerrainLabel('Land', tMex) end
                else
                    iMexLandLabel = NavUtils.GetTerrainLabel('Land', tMex)
                end


                if (iMexLandZone or 0) > 0 and (iMexLandLabel or 0) > 0 then
                    iBaseQueueCount = iBaseQueueCount + 1
                    iBaseSegmentX, iBaseSegmentZ = GetPathingSegmentFromPosition(tMex)
                    tiAdjacentSegmentsForSearchCountByMex[0][iBaseQueueCount] = {{iBaseSegmentX, iBaseSegmentZ, iMexLandZone, iMexLandLabel, tMex}}
                else
                    if not(tbSegmentHasDifferentZone[iBaseSegmentX]) then tbSegmentHasDifferentZone[iBaseSegmentX] = {} end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iMex='..iMex..'; iPlateau='..iPlateau..'; iBaseSegmentXZ='..iBaseSegmentX..'-'..iBaseSegmentZ..'; tMex='..repru(tMex)..'; iMexLandZone='..(iMexLandZone or 0)..'; iBaseQueueCount='..iBaseQueueCount..'; tiAdjacentSegmentsForSearchCountByMex[0][iBaseQueueCount]='..repru(tiAdjacentSegmentsForSearchCountByMex[0][iBaseQueueCount])..'; iMexLandLabel='..(iMexLandLabel or 'nil')..'; iMaxSegmentSearchDistance='..iMaxSegmentSearchDistance) end
                --tiBaseQueueSegments[iBaseQueueCount] = {iBaseSegmentX, iBaseSegmentZ}
            end
            --Cycle through any hydro locations that have been recorded near a start position and also add as a 'base' location to search from

            if bDebugMessages == true then LOG(sFunctionRef..': Is tHydroNearStart empty='..tostring(M28Utilities.IsTableEmpty(tHydroNearStart))) end
            if M28Utilities.IsTableEmpty(tHydroNearStart) == false then
                for iEntry, tHydroLocation in tHydroNearStart do
                    if bDebugMessages == true then LOG(sFunctionRef..': Hover terrain label for hydro='..NavUtils.GetTerrainLabel(refPathingTypeHover, tHydroLocation)) end
                    if NavUtils.GetTerrainLabel(refPathingTypeHover, tHydroLocation) == iPlateau then
                        iBaseSegmentX, iBaseSegmentZ = GetPathingSegmentFromPosition(tHydroLocation)
                        iMexLandZone = tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]
                        iMexLandLabel = NavUtils.GetTerrainLabel('Land', tHydroLocation)

                        if bDebugMessages == true then LOG(sFunctionRef..': Considering hydro at position '..repru(tHydroLocation)..'; iMexLandZone='..(iMexLandZone or 'nil')..'; iMexLandLabel='..(iMexLandLabel or 'nil')) end

                        if (iMexLandZone or 0) > 0 and (iMexLandLabel or 0) > 0 then
                            iBaseQueueCount = iBaseQueueCount + 1
                            iBaseSegmentX, iBaseSegmentZ = GetPathingSegmentFromPosition(tHydroLocation)
                            tiAdjacentSegmentsForSearchCountByMex[0][iBaseQueueCount] = {{iBaseSegmentX, iBaseSegmentZ, iMexLandZone, iMexLandLabel, tHydroLocation}}
                            if bDebugMessages == true then LOG(sFunctionRef..': Added hydro as a base location') end
                        else
                            if not(tbSegmentHasDifferentZone[iBaseSegmentX]) then tbSegmentHasDifferentZone[iBaseSegmentX] = {} end
                        end
                    end
                end
            end



            --Cycle through each base position and consider adjcent pathable segments for inclusion in the base position's zone.  Record any such segments as the base points for the next search count (so the process repeats up to iMaxSegmentSearchDistance times)
            for iSearchCount = 1, iMaxSegmentSearchDistance + 1 do --+1 since we only consider iSearchCount-1 values
                tiAdjacentSegmentsForSearchCountByMex[iSearchCount] = {}
                bHadSomeEntries = false
                if bHaveOverrideForCurPlateau and iSearchCount == 4 then
                    --Manual assignment of 3 segments around an 'override' mex to the same zone if mex has an override, where they arent assigned - this is because it is likely that the neighbours of the mex wont return a valid pathing label, but we stillw ant a small area to constitute a zone for the mex
                    if M28Utilities.IsTableEmpty(tiMexZoneOverrideForPlateau) == false then --, {iMex, iMexLandZone}
                        local iCurSegmentX, iCurSegmentZ
                        for iEntry, tMexAndLZ in tiMexZoneOverrideForPlateau do
                            local tMexPosition = tAllPlateaus[iPlateau][subrefPlateauMexes][tMexAndLZ[1]]
                            local iBaseSegmentX, iBaseSegmentZ = GetPathingSegmentFromPosition(tMexPosition)
                            local iCurPlateau
                            local bAssignAdjacentToNilPlateau = false
                            if iLandZoneSegmentSize >= 2 then bAssignAdjacentToNilPlateau = true end
                            for iAdjustX = -3, 3, 1 do
                                for iAdjustZ = -3, 3, 1 do
                                    iCurSegmentX = iBaseSegmentX + iAdjustX
                                    iCurSegmentZ = iBaseSegmentZ + iAdjustZ
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering assigning nearby segments, iAdjustX='..iAdjustX..'; iAdjustZ='..iAdjustZ..'; Cur SegX='..iCurSegmentX..'; iCurSegmentZ='..iCurSegmentZ..'; tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]='..(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] or 'nil')) end
                                    if not(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]) then
                                        local tCurPosition = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Hover label for this segment position='..(NavUtils.GetLabel(refPathingTypeHover, tCurPosition) or 'nil')) end
                                        iCurPlateau = NavUtils.GetLabel(refPathingTypeHover, tCurPosition)
                                        if iCurPlateau == iPlateau or (bAssignAdjacentToNilPlateau and not(iCurPlateau) and (math.abs(iAdjustX) <= 1 and math.abs(iAdjustZ) <= 1)) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Are we at or above water height? terrain height='..GetTerrainHeight(tCurPosition[1], tCurPosition[3])..' Map water height='..iMapWaterHeight) end
                                            if GetTerrainHeight(tCurPosition[1], tCurPosition[3]) >= iMapWaterHeight then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Manually recording land zone '..tMexAndLZ[2]..' for the mex at position '..repru(tMexPosition)..'; iAdjustX='..iAdjustX..'; iAdjustZ='..iAdjustZ) end
                                                RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iPlateau, tMexAndLZ[2])
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                for iBaseQueueCount, tiQueueEntries in tiAdjacentSegmentsForSearchCountByMex[iSearchCount-1] do --i.e. at count-1 = 0 this is each mex; each search count after that is all adjacent locations ot the previous search count entry?
                    tiAdjacentSegmentsForSearchCountByMex[iSearchCount][iBaseQueueCount] = {}
                    for iEntry, tiSegmentXZAndZone in tiQueueEntries do
                        for iNeighbourEntry, tiNeighbourXZ in GetNeighbours(tiSegmentXZAndZone[1], tiSegmentXZAndZone[2], tiSegmentXZAndZone[5]) do
                            --Check we dont already have this segment assigned to another land zone
                            if not(tLandZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]]) then
                                --Check we can path to this neighbouring segment from the base segment
                                if not(tLandZoneBySegment[tiNeighbourXZ[1]]) then tLandZoneBySegment[tiNeighbourXZ[1]] = {} end
                                bSameLandLabel = true
                                for iEntry, tPosition in tiNeighbourXZ[3] do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Segment XZ=X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iEntry='..iEntry..'; tPosition='..repru(tPosition)..'; Land label='..(NavUtils.GetTerrainLabel('Land', tPosition) or 'nil')..'; tiSegmentXZAndZone[4] label='..(tiSegmentXZAndZone[4] or 'nil')) end
                                    if not(NavUtils.GetTerrainLabel('Land', tPosition) == tiSegmentXZAndZone[4]) then
                                        bSameLandLabel = false
                                        break
                                    end
                                end

                                if bSameLandLabel then
                                    --We can path here, so update the land zone to group it with the base segment, and then record it so we consider the neighbours of this segment in the next iSearchCount
                                    RecordSegmentLandZone(tiNeighbourXZ[1], tiNeighbourXZ[2], iPlateau, tiSegmentXZAndZone[3])
                                    --tLandZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]] = tiSegmentXZAndZone[3]
                                    table.insert(tiAdjacentSegmentsForSearchCountByMex[iSearchCount][iBaseQueueCount], {tiNeighbourXZ[1], tiNeighbourXZ[2],  tiSegmentXZAndZone[3], tiSegmentXZAndZone[4], GetPositionFromPathingSegments(tiNeighbourXZ[1], tiNeighbourXZ[2])})
                                    bHadSomeEntries = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering segment X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iCurLandLabel='..(tiSegmentXZAndZone[4] or 'nil')..'; adding to table of valid locations, iBaseQueueCount='..iBaseQueueCount) end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have unpathable segment X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iCurLandLabel='..(tiSegmentXZAndZone[4] or 'nil')..'; adding to table of segments that cant path to, iBaseQueueCount='..iBaseQueueCount) end
                                end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Already have land zone recorded for segment X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..' or '..(tLandZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]] or 'nil')..'; iCurLandLabel='..(tiSegmentXZAndZone[4] or 'nil')..'; adding to table of valid locations, iBaseQueueCount='..iBaseQueueCount) end
                            end
                        end
                    end
                end
                if not(bHadSomeEntries) then
                    --Didnt find any valid entries this cycle so abort
                    if bDebugMessages == true then LOG(sFunctionRef..': No entries for iSearchCount='..iSearchCount..' so will abort further entries') end
                    break
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished for iSearchCount='..iSearchCount..' and have some more entries to consider, Size of entries to go through next='..table.getn(tiAdjacentSegmentsForSearchCountByMex[iSearchCount])) end
                end
            end
        end
    end

    if bDebugMessages == true then LOG('End of code') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param iBaseSegmentX number
---@param iBaseSegmentZ number
---@param iLandPathingGroupWanted number
---@param tBasePosition table
---@param iMaxSegmentSearchDistance number
---@param iDistanceCap number
---@param bUseRoughPathingDistance boolean
local function RecordTemporaryTravelDistanceForBaseSegment(iBaseSegmentX, iBaseSegmentZ, iLandPathingGroupWanted, tBasePosition, iMaxSegmentSearchDistance, iDistanceCap, bUseRoughPathingDistance)
    --Cycle through segments adjacent to the base segment to see if they have a land zone assigned; if they do, check how far it takes to path to the base segment, and record in the tTempZoneTravelDistanceBySegment any zones that are within the distance cap
    --iMaxSegmentSearchDistance - number of segments to search (will do +/- this)
    --iDistanceCap - will ignore any segment zones further away than this
    --bUseRoughPathingDistance - will rely on the default FAF pathfinding distance rather than manually recalculating all the distance values (runs quicker, but less accurate)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordTemporaryTravelDistanceForBaseSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tCurPosition
    local iCurZone, iCurTravelDist
    local bAbort = false --if we find a really close location then will stop looking for better ones

    if bDebugMessages == true then LOG(sFunctionRef..': About to look for segments near base segment '..iBaseSegmentX..'-'..iBaseSegmentZ..'; iMaxSegmentSearchDistance='..iMaxSegmentSearchDistance..'; iDistanceCap='..iDistanceCap..'; iLandPathingGroupWanted='..(iLandPathingGroupWanted or 'nil')) end

    local iAbortThreshold --This is used so we can stop looking through nearby segments if we find one that is likely to be the closest we will find

    --Below sub-function will consider the segment iCurSegmentX-iCurSegmentZ, if it has a land zone assigned then will check how far it is to the base segment and if it satisfies the requirements then will record in the temporary table of distances
    function CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
        --Does the segment have a land zone assigned, and we haven't just assigned it in this loop?
        if bDebugMessages == true then
            LOG(sFunctionRef..': Considering curSegmentX-z='..iCurSegmentX..'-'..iCurSegmentZ..'; Will note if we have a landzone for this')
            if tLandZoneBySegment[iCurSegmentX] then LOG('tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]='..repru(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]))
            else
                LOG('Dont have any land zone for anything with semgnet X='..iCurSegmentX)
            end
        end
        if tLandZoneBySegment[iCurSegmentX] and tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] then --and (not(tTempZoneTravelDistanceBySegment[iCurSegmentX]) or not(tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ])) then
            tCurPosition = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
            if bDebugMessages == true then LOG(sFunctionRef..': Have a land zone for CurSegmentX-Z'..iCurSegmentX..'-'..iCurSegmentZ..'; Pathing label of this segment='..NavUtils.GetTerrainLabel(refPathingTypeLand, tCurPosition)..'; iLandPathingGroupWanted='..iLandPathingGroupWanted) end
            if NavUtils.GetTerrainLabel(refPathingTypeLand, tCurPosition) == iLandPathingGroupWanted then

                if bUseRoughPathingDistance then
                    iCurTravelDist = M28Utilities.GetApproxTravelDistanceBetweenPositions(tBasePosition, tCurPosition)
                else
                    iCurTravelDist = M28Utilities.GetTravelDistanceBetweenPositions(tBasePosition, tCurPosition)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iCurTravelDist='..iCurTravelDist) end
                if (iCurTravelDist or 100000) < iDistanceCap then

                    --Update the distance between the bsae segment and a segment in iCurZone to the lower of the current distance and any previously recorded distance
                    iCurZone = tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
                    if bDebugMessages == true then LOG(sFunctionRef..': We have a segment nearby with a land zone, iCurZone='..iCurZone..'; will record iCurTravelDist of '..iCurTravelDist..'; against the base segment') end
                    if not(tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ]) then
                        if not(tTempZoneTravelDistanceBySegment[iBaseSegmentX]) then tTempZoneTravelDistanceBySegment[iBaseSegmentX] = {} end
                        tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ] = {}
                    end
                    tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone] = math.min(iCurTravelDist, (tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone] or 100000))
                    if not(tTempZonePlateauBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone]) then tTempZonePlateauBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone] = NavUtils.GetTerrainLabel(refPathingTypeHover, tCurPosition) end
                    if iCurTravelDist <= iAbortThreshold then
                        if bDebugMessages == true then LOG(sFunctionRef..': Found a really close segment so will stop looking for more') end
                        bAbort = true
                    end
                end
            end
        end
    end

    local iMaxAdjustedX, iMaxAdjustedZ, iMinAdjustedX, iMinAdjustedZ, iZInterval

    --Cycle through each segment, starting with those closest to the base position
    for iAdjustmentSize = 1, iMaxSegmentSearchDistance do
        iAbortThreshold = iLandZoneSegmentSize * (iAdjustmentSize * 1.3 + 1)
        iMaxAdjustedX = math.min(iAdjustmentSize + iBaseSegmentX, iMaxLandSegmentX)
        iMaxAdjustedZ = math.min(iAdjustmentSize + iBaseSegmentZ, iMaxLandSegmentZ)
        iMinAdjustedX = math.max(1, iBaseSegmentX-iAdjustmentSize)
        iMinAdjustedZ = math.max(1, iBaseSegmentZ-iAdjustmentSize)
        iZInterval = math.max(1, iMaxAdjustedZ - iMinAdjustedZ)



        for iCurSegmentX = iMinAdjustedX, iMaxAdjustedX, 1 do
            --Since we are starting from the closest segments and moving out, we effectively want to cycle through a hollow square of segments with each change in iAdjustmentSize:
            if iCurSegmentX == iMinAdjustedX or iCurSegmentX == iMaxAdjustedX then
                for iCurSegmentZ = iMinAdjustedZ, iMaxAdjustedZ, 1 do
                    CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
                    if bAbort then break end
                end
            else
                for iCurSegmentZ = iMinAdjustedZ, iMaxAdjustedZ, iZInterval do
                    CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
                    if bAbort then break end
                end
            end
            if bAbort then break end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed recording if we have any nearby zones that can path here, tTempZoneTravelDistanceBySegment for base segment '..iBaseSegmentX..'-'..iBaseSegmentZ..'='..repru(tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ])..'; bAbort='..tostring(bAbort)) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param iBaseSegmentX number
---@param iBaseSegmentZ number
---@param iLandZone number
---@param iSegmentSearchRange number
---@param iDistanceCap number
local function AssignNearbySegmentsToSameLandZone(iBaseSegmentX, iBaseSegmentZ, iSegmentSearchRange, iDistanceCap)
    --Cycles through every segment within iSegmentSearchRange of the base segment X-Z value, and if the pathing distance is within the distance cap iDistanceCap then will assign it to the same land zone as the base segment X and Z
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignNearbySegmentsToSameLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iLandZone = tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]
    local iCurTravelDist
    local tBaseMidpoint = GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
    local iPlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, tBaseMidpoint)
    for iCurSegmentX = math.max(1, iBaseSegmentX - iSegmentSearchRange), math.min(iBaseSegmentX + iSegmentSearchRange, iMaxLandSegmentX), 1 do
        for iCurSegmentZ = math.max(1, iBaseSegmentZ - iSegmentSearchRange), math.min(iBaseSegmentZ + iSegmentSearchRange, iMaxLandSegmentZ), 1 do
            if not(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]) then
                iCurTravelDist = M28Utilities.GetTravelDistanceBetweenPositions(GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ), tBaseMidpoint)
                if (iCurTravelDist or 100000) <= iDistanceCap then
                    if not(tLandZoneBySegment[iCurSegmentX]) then tLandZoneBySegment[iCurSegmentX] = {} end
                    RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iPlateau, iLandZone)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function AssignRemainingSegmentsToLandZones()
    --Cycles through key points on the map and if they ahve no nearby land zone then creates a new land zone and assigns nearby segments to it
    --then cycles through every segment on the map and if it has no land zone assigns it to the nearest existing land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignRemainingSegmentsToLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --rMapPotentialPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2}
    local iLandPathingGroupWanted
    local iPlateauGroup

    local iMaxSegmentZoneCopyThreshold
    if iMapSize > 512 then iMaxSegmentZoneCopyThreshold = math.max(3, math.ceil(50 / iLandZoneSegmentSize)) --NOTE: If changing this consider if also want to change the value for AssignSegmentsNearMexesToLandZones; for first draft have this as slightly lower
    else iMaxSegmentZoneCopyThreshold = math.max(3, math.ceil(30 / iLandZoneSegmentSize))
    end

    local iMaxSegmentSearchDistance = iMaxSegmentZoneCopyThreshold * 2
    --Reduce the actual copy segment range by 1 for non-campaign, reduce further for campaign
    if bIsCampaignMap then
        iMaxSegmentZoneCopyThreshold = math.max(math.floor(iMaxSegmentZoneCopyThreshold * 0.5), math.min(iMaxSegmentZoneCopyThreshold - 1, 3))
    else
        iMaxSegmentZoneCopyThreshold = math.max(math.floor(iMaxSegmentZoneCopyThreshold * 0.9), math.min(iMaxSegmentZoneCopyThreshold - 1, 3))
    end


    if bDebugMessages == true then LOG(sFunctionRef..': iMaxSegmentZoneCopyThreshold='..iMaxSegmentZoneCopyThreshold) end

    local iDistanceCap = math.max(40, iMaxSegmentSearchDistance * iLandZoneSegmentSize) --used from old appraoch kept in for the redundancy approach; in theory should never acutally be needed

    local tBasePosition

    --Create a new zone for any locations with no nearby pathable zones
    local iBasePositionX = - iLandZoneSegmentSize * 0.5 + rMapPotentialPlayableArea[1]
    local iBasePositionZ
    local iNearbyAssignmentSegmentRange = math.min(iMaxSegmentSearchDistance, math.ceil(iMaxSegmentSearchDistance * 0.5) + 1)
    local tiLZEntryByNavUtilsRef = {}

    function GetNeighbours(iSegmentX, iSegmentZ, tBasePosition)
        local tTableBeforePositions = {{iSegmentX - 1, iSegmentZ, {{tBasePosition[1] - 1, 0, tBasePosition[3]}}}, {iSegmentX, iSegmentZ - 1, {{tBasePosition[1], 0, tBasePosition[3] - 1}}}, {iSegmentX, iSegmentZ + 1, {{tBasePosition[1], 0, tBasePosition[3] + 1}}}, {iSegmentX + 1, iSegmentZ, {{tBasePosition[1] + 1, 0, tBasePosition[3]}}}}
        if iLandZoneSegmentSize > 1 then
            for iEntry, tSubtable in tTableBeforePositions do
                if bDebugMessages == true then LOG(sFunctionRef..': tSubtable='..repru(tSubtable)..'; tSubtable[3]='..repru(tSubtable[3])) end
                for iPositionAdjust = 2, iLandZoneSegmentSize, 1 do
                    if iEntry == 1 then
                        table.insert(tSubtable[3], {tBasePosition[1] - iPositionAdjust, 0, tBasePosition[3]})
                    elseif iEntry == 2 then
                        table.insert(tSubtable[3], {tBasePosition[1], 0, tBasePosition[3] - iPositionAdjust})
                    elseif iEntry == 3 then
                        table.insert(tSubtable[3], {tBasePosition[1], 0, tBasePosition[3] + iPositionAdjust})
                    elseif iEntry == 4 then
                        table.insert(tSubtable[3], {tBasePosition[1] + iPositionAdjust, 0, tBasePosition[3]})
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': tTableBeforePositions='..repru(tTableBeforePositions)) end
        return tTableBeforePositions
    end

    --Subfunction that checks nearby segments that we can path to with a land zone already assigned, and if there are none then creates a new land zone for the base position and assigns segments near it to the same land zone
    function CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ, iMaxSearchCycle, iCopyZoneThreshold, bTryHardToFindExistingZone)
        --iCopyZoneThreshold - if come across segments with valid existing zone before this threshold is reached in the iSearchCount loop then will set everything to that zone
            --bTryHardToFindExistingZone - used for remaining segments that have no zone - want to avoid creating lots of 1 segment sized zones, so this is intended to try and search further than normal for an existing zone to join
        if not(tLandZoneBySegment[iBaseSegmentX]) or not(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
            local bHadSomeEntries, bSameLandLabel
            tBasePosition = {iBasePositionX, 0, iBasePositionZ} --GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
            local iRevisedBaseSegmentX = iBaseSegmentX
            local iRevisedBaseSegmentZ = iBaseSegmentZ
            --tBasePosition[2] = GetSurfaceHeight(tBasePosition[1], tBasePosition[3]) --Dont think this is needed
            iLandPathingGroupWanted = NavUtils.GetTerrainLabel(refPathingTypeLand, tBasePosition)
            if (iLandPathingGroupWanted or 0) == 0 then
                --We shouldnt have got here unless plateau returned a valid pathing value; however can have cases where is pathable by one measure but not another due to imprecisions in the FAF pathfinding approach
                --Therefore, want to check if we are on land (rather htan water which is handled separately) and if so then include still
                iPlateauGroup = NavUtils.GetTerrainLabel(refPathingTypeHover, tBasePosition)
                if bDebugMessages == true then LOG(sFunctionRef..': iPlateauGroup of the target location='..(iPlateauGroup or 'nil')..'; Surface height='..GetSurfaceHeight(iBasePositionX, iBasePositionZ)..'; Terrain height='..GetTerrainHeight(iBasePositionX, iBasePositionZ)..'; tBasePosition='..repru(tBasePosition)..'; iBasePositionX-Z='..iBasePositionX..'-'..iBasePositionZ) end
                if (iPlateauGroup or 0) > 0 then
                    --Check we arent on water
                    if GetSurfaceHeight(iBasePositionX, iBasePositionZ) <= GetTerrainHeight(iBasePositionX, iBasePositionZ) then
                        local tiAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}, {-3,0}, {-3, -3}, {-3, 3}, {0, -3}, {0, 3}, {3, -3}, {3, 0}, {3,3}}
                        local iPotentialLandGroup
                        for iEntry, tXZAdjust in tiAdjust do

                            iPotentialLandGroup = NavUtils.GetTerrainLabel(refPathingTypeLand, { tBasePosition[1] + tXZAdjust[1], tBasePosition[2], tBasePosition[3] + tXZAdjust[2] })
                            if (iPotentialLandGroup or 0) > 0 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have al ocation with a plateau ref but no land ref, but adjusting for tXZAdjust='..repru(tXZAdjust)..' gives us a valid land group, iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ) end
                                iLandPathingGroupWanted = iPotentialLandGroup
                                tBasePosition = { tBasePosition[1] + tXZAdjust[1], tBasePosition[2], tBasePosition[3] + tXZAdjust[2] }
                                iRevisedBaseSegmentX, iRevisedBaseSegmentZ = GetPathingSegmentFromPosition({tBasePosition[1] + tXZAdjust[1], tBasePosition[2], tBasePosition[3] + tXZAdjust[2]})
                                break
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Unable to find any nearby locations with land pathing') end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ..'; iLandPathingGroupWanted='..(iLandPathingGroupWanted or 'nil')) end
            if (iLandPathingGroupWanted or 0) > 0 then
                --Are we from a plateau that has mexes?
                iPlateauGroup = (NavUtils.GetTerrainLabel(refPathingTypeHover, tBasePosition) or NavUtils.GetTerrainLabel('Amphibious', tBasePosition))
                if not(iPlateauGroup) then
                    local tiAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}, {-3,0}, {-3, -3}, {-3, 3}, {0, -3}, {0, 3}, {3, -3}, {3, 0}, {3,3}}
                    for iEntry, tXZAdjust in tiAdjust do

                        iPlateauGroup = NavUtils.GetTerrainLabel(refPathingTypeHover, { tBasePosition[1] + tXZAdjust[1], tBasePosition[2], tBasePosition[3] + tXZAdjust[2] })
                        if iPlateauGroup then
                            iLandPathingGroupWanted = (NavUtils.GetTerrainLabel(refPathingTypeLand, { tBasePosition[1] + tXZAdjust[1], tBasePosition[2], tBasePosition[3] + tXZAdjust[2] }) or (NavUtils.GetLabel(refPathingTypeLand, { tBasePosition[1] + tXZAdjust[1], tBasePosition[2], tBasePosition[3] + tXZAdjust[2] }) or iLandPathingGroupWanted))
                            if iLandPathingGroupWanted then
                                break
                            end
                        end
                    end
                    if not(iPlateauGroup) then
                        iPlateauGroup = NavUtils.GetLabel(refPathingTypeHover, tBasePosition)
                        if not(iPlateauGroup) or not(iLandPathingGroupWanted) then
                            M28Utilities.ErrorHandler('Unable to find a valid plateau at or near position for iBaseSegmentX='..iBaseSegmentX..';Z='..iBaseSegmentZ..'; will no longer want a land zone recording', true)
                            iLandPathingGroupWanted = nil
                        end
                    end
                end
                if iPlateauGroup then
                    --Cycle through adjacent segments to see if find a land zone, and if so then assign this
                    local tiSegmentsForAssignment = {}
                    local iLandZoneToUse
                    local tiAdjacentSegmentsForSearchBySearchCount = {}
                    local iTotalSegmentsForAssignment = 1
                    tiAdjacentSegmentsForSearchBySearchCount[0] = {{iRevisedBaseSegmentX, iRevisedBaseSegmentZ, iLandPathingGroupWanted, iLandPathingGroupWanted, tBasePosition}}
                    if bDebugMessages == true then LOG(sFunctionRef..': About to cycle thorugh adjacent segments to try and find a land zone that should assign this to, in same pathing group as iRevisedBaseSegmentX and Z, X'..iRevisedBaseSegmentX..'Z'..iRevisedBaseSegmentZ..'; iLandPathingGroupWanted='..(iLandPathingGroupWanted or 'nil')..'; tBasePosition='..repru(tBasePosition)..'; iMaxSegmentSearchDistance='..iMaxSegmentSearchDistance..'; iMaxSearchCycle='..iMaxSearchCycle) end
                    for iSearchCount = 1, iMaxSearchCycle + 1 do
                        tiAdjacentSegmentsForSearchBySearchCount[iSearchCount] = {}
                        bHadSomeEntries = false
                        for iEntry, tiSegmentXZAndZone in tiAdjacentSegmentsForSearchBySearchCount[iSearchCount-1] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iSearchCount-1='..(iSearchCount - 1)..'; tiSegmentXZAndZone='..repru(tiSegmentXZAndZone)) end
                            for iNeighbourEntry, tiNeighbourXZ in GetNeighbours(tiSegmentXZAndZone[1], tiSegmentXZAndZone[2], tiSegmentXZAndZone[5]) do
                                if bDebugMessages == true then LOG(sFunctionRef..': Cycling through each neighbour for iSearchCount='..iSearchCount..' and iEntry='..iEntry..', neighbour Segment XZ=X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iNeighbourEntry='..iNeighbourEntry..'; tLandZoneBySegment for this='..(tLandZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]] or 'nil')..'; tiSegmentsForAssignment[tiNeighbourXZ[1]][tiNeighbourXZ[2]]='..tostring(tiSegmentsForAssignment[tiNeighbourXZ[1]][tiNeighbourXZ[2]] or false)..'; iPlateauGroup='..iPlateauGroup..'; Neighbour plateau='..(NavUtils.GetTerrainLabel(refPathingTypeHover, GetPositionFromPathingSegments(tiNeighbourXZ[1], tiNeighbourXZ[2])) or 'nil')) end
                                if not(tLandZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]]) or not(iLandPathingGroupWanted == NavUtils.GetTerrainLabel(refPathingTypeLand, GetPositionFromPathingSegments(tiNeighbourXZ[1], tiNeighbourXZ[2]))) then
                                    --The neighbour doesnt have an assignment either or isnt in the same plateau, if we haven't recorded it already as a segment for assignment, then receord it if it is in the same land terrain label as the base position
                                    if not(tiSegmentsForAssignment[tiNeighbourXZ[1]][tiNeighbourXZ[2]]) then
                                        if not(tLandZoneBySegment[tiNeighbourXZ[1]]) then tLandZoneBySegment[tiNeighbourXZ[1]] = {} end
                                        bSameLandLabel = true
                                        for iEntry, tPosition in tiNeighbourXZ[3] do
                                            if bDebugMessages == true then LOG(sFunctionRef..': Segment XZ=X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iEntry='..iEntry..'; tPosition='..repru(tPosition)..'; Land label='..(NavUtils.GetTerrainLabel('Land', tPosition) or 'nil')..'; tiSegmentXZAndZone[4] label='..(tiSegmentXZAndZone[4] or 'nil')) end
                                            if not(NavUtils.GetTerrainLabel('Land', tPosition) == tiSegmentXZAndZone[4]) then
                                                bSameLandLabel = false
                                                break
                                            end
                                        end

                                        if bSameLandLabel then
                                            if not(tiSegmentsForAssignment[tiNeighbourXZ[1]]) then tiSegmentsForAssignment[tiNeighbourXZ[1]] = {} end
                                            tiSegmentsForAssignment[tiNeighbourXZ[1]][tiNeighbourXZ[2]] = true
                                            bHadSomeEntries = true
                                            iTotalSegmentsForAssignment = iTotalSegmentsForAssignment + 1

                                            table.insert(tiAdjacentSegmentsForSearchBySearchCount[iSearchCount], {tiNeighbourXZ[1], tiNeighbourXZ[2], iLandPathingGroupWanted, iLandPathingGroupWanted, GetPositionFromPathingSegments(tiNeighbourXZ[1], tiNeighbourXZ[2])})
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering segment X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iCurLandLabel='..(tiSegmentXZAndZone[4] or 'nil')..'; adding to table of valid locations') end
                                        else
                                            if bDebugMessages == true then LOG(sFunctionRef..': Have unpathable segment X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iCurLandLabel='..(tiSegmentXZAndZone[4] or 'nil')..'; adding to table of segments that cant path to') end
                                        end
                                    end
                                else
                                    --Have a valid segment so use this as the land zone unless have reached iCopyZoneThreshold
                                    if bDebugMessages == true then LOG(sFunctionRef..': Already considered or recorded this zone will check if it is within copy zone threshold, iLandZoneToUse='..(iLandZoneToUse or 'nil')..'; iSearchCount='..iSearchCount..'; iCopyZoneThreshold='..(iCopyZoneThreshold or 'nil')..'; Neighbour land zone='..(tLandZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]] or 'nil')..'; Neighbour segment=X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]) end
                                    if not(iLandZoneToUse) and iSearchCount < (iCopyZoneThreshold or 10000) then
                                        iLandZoneToUse = tLandZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]]
                                        if bDebugMessages == true then LOG(sFunctionRef..': Are within copy zone threshold so will assign to this zone '..iLandZoneToUse) end
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG('Finished for iSearchCount='..iSearchCount..'; Size of tiAdjacentSegmentsForSearchBySearchCount='..table.getn(tiAdjacentSegmentsForSearchBySearchCount[iSearchCount])..'; iLandZoneToUse='..(iLandZoneToUse or 'nil')..'; bHadSomeEntries='..tostring(bHadSomeEntries)..'; iTotalSegmentsForAssignment='..iTotalSegmentsForAssignment) end
                        if not(bHadSomeEntries) or (iLandZoneToUse and iSearchCount >= iCopyZoneThreshold) then break end
                    end
                    --If we didnt come across an existing nearby land zone we can path to then create a new zone:
                    if bDebugMessages == true then LOG(sFunctionRef..': FInished cycling through all nearby pathable segments for base segments X'..iRevisedBaseSegmentX..'Z'..iRevisedBaseSegmentZ..'; iLandZoneToUse='..(iLandZoneToUse or 'nil')) end
                    if not(iLandZoneToUse) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Plateau mex count='..(tAllPlateaus[iPlateauGroup][subrefPlateauTotalMexCount] or 0)..'; iPlateauGroup='..(iPlateauGroup or 'nil')) end
                        if (tAllPlateaus[iPlateauGroup][subrefPlateauTotalMexCount] or 0) > 0 then
                            if iTotalSegmentsForAssignment <= 30 then
                                local iNewLandZone
                                --small land zone - find the nearest segment with a land zone for this plateau group
                                for iAdjustBase = 1, iCopyZoneThreshold do
                                    for iCurSegmentX = iRevisedBaseSegmentX - iAdjustBase, iRevisedBaseSegmentX + iAdjustBase, 1 do
                                        for iCurSegmentZ = iRevisedBaseSegmentZ - iAdjustBase, iRevisedBaseSegmentZ + iAdjustBase, iAdjustBase * 2 do
                                            if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                                                if tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] and NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)) == iPlateauGroup then
                                                    iNewLandZone = tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
                                                    break
                                                end
                                            end
                                        end
                                        if iNewLandZone then break end
                                    end
                                    if iNewLandZone then break end
                                    --Then do the left and right row (excl corners which ahve already done per the above)
                                    for iCurSegmentX = iRevisedBaseSegmentX - iAdjustBase, iRevisedBaseSegmentX + iAdjustBase, iAdjustBase * 2 do
                                        for iCurSegmentZ = iRevisedBaseSegmentZ - iAdjustBase + 1, iRevisedBaseSegmentZ + iAdjustBase - 1, 1 do
                                            if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                                                if tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] and NavUtils.GetLabel(refPathingTypeHover, GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)) == iPlateauGroup then
                                                    iNewLandZone = tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
                                                    break
                                                end
                                            end
                                        end
                                        if iNewLandZone then break end
                                    end
                                    if iNewLandZone then break end
                                end
                                iLandZoneToUse = iNewLandZone
                                if bDebugMessages == true then LOG(sFunctionRef..': iLandZoneToUse after running backup for small new zones='..(iLandZoneToUse or 'nil')) end
                                if not(iLandZoneToUse) then
                                    CreateNewLandZoneAtSegment(iRevisedBaseSegmentX, iRevisedBaseSegmentZ, iPlateauGroup)
                                    iLandZoneToUse = tAllPlateaus[iPlateauGroup][subrefLandZoneCount]
                                end
                            else
                                CreateNewLandZoneAtSegment(iRevisedBaseSegmentX, iRevisedBaseSegmentZ, iPlateauGroup)
                                iLandZoneToUse = tAllPlateaus[iPlateauGroup][subrefLandZoneCount]
                                if bDebugMessages == true then LOG(sFunctionRef..': Created new zone for this plateau, iLandZoneToUse='..iLandZoneToUse..'; will use this as the land zone') end
                            end
                        else
                            if (iPlateauGroup or 0) > 0 then
                                --We haven't created this LZ yet; have we created the plateau?
                                if bDebugMessages == true then LOG(sFunctionRef..': Will create a new land zone but first checking if we have this plateau recorded, is all plateaus nil for iPlateauGroup='..iPlateauGroup..'='..tostring(tAllPlateaus[iPlateauGroup] == nil)..'; Is tiLZEntryByNavUtilsRef nil='..tostring(tiLZEntryByNavUtilsRef == nil)..'; tAllPlateaus[iPlateauGroup][subrefLandZoneCount]='..(tAllPlateaus[iPlateauGroup][subrefLandZoneCount] or 'nil')) end
                                if not(tAllPlateaus[iPlateauGroup]) then
                                    RecordMexlessPlateau(iPlateauGroup)
                                end

                                if not(tiLZEntryByNavUtilsRef[iPlateauGroup]) then
                                    tiLZEntryByNavUtilsRef[iPlateauGroup] = {}
                                end

                                --Need to add land zone reference to this plateau
                                AddNewLandZoneReferenceToPlateau(iPlateauGroup)
                                tiLZEntryByNavUtilsRef[iPlateauGroup][iLandPathingGroupWanted] = tAllPlateaus[iPlateauGroup][subrefLandZoneCount]
                                RecordSegmentLandZone(iBaseSegmentX, iBaseSegmentZ, iPlateauGroup, tAllPlateaus[iPlateauGroup][subrefLandZoneCount])
                                iLandZoneToUse = tAllPlateaus[iPlateauGroup][subrefLandZoneCount]
                                if bDebugMessages == true then LOG(sFunctionRef..': Created new land zone, iLandZoneToUse='..iLandZoneToUse) end
                            else
                                M28Utilities.ErrorHandler('somehow have a land zone but not a plateau group; Refer to log for base position and other details if logs are enabled')
                                if bDebugMessages == true then
                                    LOG(sFunctionRef..': Base position='..repru(tBasePosition)..'; Land nav='..(NavUtils.GetTerrainLabel(refPathingTypeLand, tBasePosition) or 'nil')..'; Plateau nav='..(NavUtils.GetTerrainLabel(refPathingTypeHover, tBasePosition) or 'nil')..'; Amphibious plateau='..(NavUtils.GetTerrainLabel('Amphibious', tBasePosition) or 'nil')..'; Get label for hover='..(NavUtils.GetLabel(refPathingTypeHover, tBasePosition) or 'nil'))
                                    M28Utilities.DrawLocation(tBasePosition, 2)
                                end

                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished creating land zone if we didnt have one, iLandZoneTOUse='..(iLandZoneToUse or 'nil')..'; iPlateauGroup='..(iPlateauGroup or 'nil')..'; iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ..'; iCopyZoneThreshold='..iCopyZoneThreshold..'; tiSegmentsForAssignment='..repru(tiSegmentsForAssignment)..'; tiAdjacentSegmentsForSearchBySearchCount='..repru(tiAdjacentSegmentsForSearchBySearchCount)) end
                    if iLandZoneToUse then
                        RecordSegmentLandZone(iBaseSegmentX, iBaseSegmentZ, iPlateauGroup, iLandZoneToUse)
                        if M28Utilities.IsTableEmpty(tiSegmentsForAssignment) == false then
                            for iCurSegmentX, tSubtable in tiSegmentsForAssignment do
                                for iCurSegmentZ, bIncluded in tSubtable do
                                    RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iPlateauGroup, iLandZoneToUse)
                                end
                            end
                        end
                    end
                end
            elseif bDebugMessages == true then
                LOG(sFunctionRef..': No land pathing group for base position '..repru(tBasePosition)..'; iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ..'; will draw base position')
                M28Utilities.DrawLocation(tBasePosition)
            end
        end

    end

    --Cycle through every nth segment on the map - only consider every iMaxSegmentSearchDistance 'th segment (for performance reasons), and check if it has nearby land zones, and if not then create a new land zone at this position
    local iXTotalIntervals = math.floor(iMaxLandSegmentX / iMaxSegmentSearchDistance)
    local iXDifToSegmentSize = iMaxLandSegmentX - iMaxSegmentSearchDistance * iXTotalIntervals
    local iXStartSegmentAdjust =  math.floor((-iXDifToSegmentSize + iMaxSegmentSearchDistance) * -0.5)
    local iXStartSegment = iXStartSegmentAdjust + iMaxSegmentSearchDistance
    local iXEndSegment = iXStartSegmentAdjust + iMaxSegmentSearchDistance * iXTotalIntervals
    local iDistanceBetweenSquares = iMaxSegmentSearchDistance * iLandZoneSegmentSize
    local iStartPositionX = iXStartSegment * iLandZoneSegmentSize - iLandZoneSegmentSize * 0.5 + rMapPotentialPlayableArea[1] - iDistanceBetweenSquares

    local iZTotalIntervals = math.floor(iMaxLandSegmentZ / iMaxSegmentSearchDistance)
    local iZDifToSegmentSize = iMaxLandSegmentZ - iMaxSegmentSearchDistance * iZTotalIntervals
    local iZStartSegmentAdjust =  math.floor((-iZDifToSegmentSize + iMaxSegmentSearchDistance) * -0.5)
    local iZStartSegment = iZStartSegmentAdjust + iMaxSegmentSearchDistance
    local iZEndSegment = iZStartSegmentAdjust + iMaxSegmentSearchDistance * iZTotalIntervals

    iBasePositionX = iStartPositionX
    if bDebugMessages == true then LOG(sFunctionRef..': iMaxLandSegmentX='..iMaxLandSegmentX..'; iMaxSegmentSearchDistance='..iMaxSegmentSearchDistance..'; iXTotalIntervals='..iXTotalIntervals..'; iXDifToSegmentSize='..iXDifToSegmentSize..'; iXStartSegmentAdjust='..iXStartSegmentAdjust..'; iXStartSegment='..iXStartSegment..'; iXEndSegment='..iXEndSegment..'; iStartPositionX='..iStartPositionX..'; rMapPotentialPlayableArea='..repru(rMapPotentialPlayableArea)..'; iDistanceBetweenSquares='..iDistanceBetweenSquares) end

    for iBaseSegmentX = iXStartSegment, iXEndSegment, iMaxSegmentSearchDistance do
        iBasePositionX = iBasePositionX + iDistanceBetweenSquares --Manually done instead of GetPositionFromPathingSegments for performance
        iBasePositionZ = iZStartSegment * iLandZoneSegmentSize - iLandZoneSegmentSize * 0.5 + rMapPotentialPlayableArea[2] - iDistanceBetweenSquares

        if not(tLandZoneBySegment[iBaseSegmentX]) then tLandZoneBySegment[iBaseSegmentX] = {} end
        if not(tTempZoneTravelDistanceBySegment[iBaseSegmentX]) then
            tTempZoneTravelDistanceBySegment[iBaseSegmentX] = {}
            tTempZonePlateauBySegment[iBaseSegmentX] = {}
        end
        for iBaseSegmentZ = iZStartSegment, iZEndSegment, iMaxSegmentSearchDistance do
            iBasePositionZ = iBasePositionZ + iDistanceBetweenSquares
            --Check we dont already have a zone assigned
            CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ, iMaxSegmentSearchDistance, iMaxSegmentZoneCopyThreshold)
            if bDebugMessages == true then
                LOG('iBaseSegmentX = '..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ..'; iBasePositionX='..iBasePositionX..'; iBasePositionZ='..iBasePositionZ)
                M28Utilities.DrawLocation({iBasePositionX, GetSurfaceHeight(iBasePositionX, iBasePositionZ), iBasePositionZ}, 3, 200, iLandZoneSegmentSize)
            end
        end
        --WaitTicks(1)
        if bDebugMessages == true then LOG(sFunctionRef..': Finished all iBaseSegmentX='..iBaseSegmentX..'; moving to next X segments, systemtime='..GetSystemTimeSecondsOnlyForProfileUse()) end
    end
    --Now go through each segment considered and pick the lowest value distance as the assigned land zone
    --AssignTempSegmentsWithDistance()
    if bDebugMessages == true then
        LOG(sFunctionRef..': Finished assigning land zones for locations with no nearby zones, systemtime='..GetSystemTimeSecondsOnlyForProfileUse())
        WaitTicks(10)
    end

    --Now cycle through every segment on the map, and assign to a land zone (or create a new land zone if none nearby, but hopefully after the above code this will be rare)

    iBasePositionX = - iLandZoneSegmentSize * 0.5 + rMapPotentialPlayableArea[1] --Calculate the position manually (instead of using the function GetPositionFromPathingSegments) for performance
    local iCurSearchDistance, iCurCopyThreshold
    for iBaseSegmentX = 1, iMaxLandSegmentX do
        iBasePositionX = iBasePositionX + iLandZoneSegmentSize --(i.e. as per GetPositionFromPathingSegments)
        iBasePositionZ = - iLandZoneSegmentSize * 0.5 + rMapPotentialPlayableArea[2]
        for iBaseSegmentZ = 1, iMaxLandSegmentZ do
            iBasePositionZ = iBasePositionZ + iLandZoneSegmentSize
            if bDebugMessages == true then LOG(sFunctionRef..': Cycling through all segments, just about to check iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ..'; tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]='..(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ] or 'nil')) end
            --CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ, iMaxSearchCycle, iCopyZoneThreshold, bTryHardToFindExistingZone)
            CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ, iMaxSegmentSearchDistance, iMaxSegmentZoneCopyThreshold, true)
            if bDebugMessages == true then LOG(sFunctionRef..': Land zone after checking='..(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ] or 'nil'))
                if tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ] then
                    local iTempPlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, {iBasePositionX, 0, iBasePositionZ})
                    if iTempPlateau then
                        local tTempLZData = tAllPlateaus[iTempPlateau][subrefPlateauLandZones][tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]]
                        LOG(sFunctionRef..': iTempPlateau='..iTempPlateau..'; segment count for zone='..(tTempLZData[subrefLZTotalSegmentCount] or 0))
                        M28Utilities.DrawLocation({iBasePositionX, GetSurfaceHeight(iBasePositionX, iBasePositionZ), iBasePositionZ})
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed creating land zones for any remaining locations with no nearby land zone, system time='..GetSystemTimeSecondsOnlyForProfileUse()..'; Land zone for base segment1-1='..(tLandZoneBySegment[1][1] or 'nil')) end

    --The above will have updated the temporary table with details of how long to path to each zone; now go through and assign each segment to the closest zone to it
    --AssignTempSegmentsWithDistance()

    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed assigning zones for any temporary distances for the zones created in the previous step, system time='..GetSystemTimeSecondsOnlyForProfileUse()..'; about to run logic to check for any rmeaining segment') end


    --Redundancy - cycle through any zones that dont have a segment and create new zones for them - hopefully this shouldnt be possible provided we have setup the segment search ranges correctly above
    --Also setup initial details on water segments

    for iBaseSegmentX = 1, iMaxLandSegmentX do
        for iBaseSegmentZ = 1, iMaxLandSegmentZ do
            if bDebugMessages == true then LOG(sFunctionRef..': iBaseSegmentX-Z='..iBaseSegmentX..'-'..iBaseSegmentZ..'; Is the land zone for htis segment nil='..tostring(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]==nil)..'; Hover label='..(NavUtils.GetTerrainLabel(refPathingTypeHover, tBasePosition) or 0)..'; Land label='..(NavUtils.GetTerrainLabel(refPathingTypeLand, tBasePosition) or 'nil')..'; NavUtils.GetTerrainLabel(refPathingTypeNavy, tBasePosition)='..(NavUtils.GetTerrainLabel(refPathingTypeNavy, tBasePosition) or 'nil')..'; tLandZoneBySegment='..(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ] or 'nil')) end
            if not(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
                tBasePosition = GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
                if (NavUtils.GetTerrainLabel(refPathingTypeHover, tBasePosition) or 0) > 0 then
                    iLandPathingGroupWanted = NavUtils.GetTerrainLabel(refPathingTypeLand, tBasePosition)
                    if (iLandPathingGroupWanted or 0) >= 1 then
                        M28Utilities.ErrorHandler('Have a location that is land pathable which has an unassigned land zone for base segments XZ='..iBaseSegmentX..'-'..iBaseSegmentZ..'; tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]='..(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ] or 'nil'))
                        CreateNewLandZoneAtSegment(iBaseSegmentX, iBaseSegmentZ)
                        RecordTemporaryTravelDistanceForBaseSegment(iBaseSegmentX, iBaseSegmentZ, iLandPathingGroupWanted, tBasePosition, iMaxSegmentSearchDistance, iDistanceCap)
                        AssignTempSegmentsWithDistance()
                    else
                        --Do we have a water segment?
                        local iPond = NavUtils.GetTerrainLabel(refPathingTypeNavy, tBasePosition)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iBaseSegmentX-Z='..iBaseSegmentX..'-'..iBaseSegmentZ..'; we have hover pathing but not water;tBasePosition='..repru(tBasePosition)..'; Surface height='..GetSurfaceHeight(tBasePosition[1], tBasePosition[3])..'; Terrain height='..GetTerrainHeight(tBasePosition[1], tBasePosition[3])..'; iPond='..(iPond or 'nil')) end
                        if (iPond or 0) == 0 and GetSurfaceHeight(tBasePosition[1], tBasePosition[3]) > GetTerrainHeight(tBasePosition[1], tBasePosition[3]) then
                            --We are on water, so check nearby as FAF pathfinding not 100% accurate on larger maps
                            local tiAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}, {-3,0}, {-3, -3}, {-3, 3}, {0, -3}, {0, 3}, {3, -3}, {3, 0}, {3,3}}
                            local iPotentialPond
                            for iEntry, tXZAdjust in tiAdjust do
                                iPotentialPond = NavUtils.GetTerrainLabel(refPathingTypeNavy, { tBasePosition[1] + tXZAdjust[1], tBasePosition[2], tBasePosition[3] + tXZAdjust[2] })
                                if (iPotentialPond or 0) > 0 then
                                    iPond = iPotentialPond
                                    if bDebugMessages == true then LOG(sFunctionRef..': Foudn a nearby pond '..iPotentialPond..', tXZAdjust='..repru(tXZAdjust)) end
                                    break
                                end
                            end
                        end
                        if (iPond or 0) > 0 then
                            if bDebugMessages == true then LOG(sFunctionRef..': About to record a pond for iBaseSegmentX-Z='..iBaseSegmentX..'-'..iBaseSegmentZ..' for pond '..iPond..'; tBasePosition='..repru(tBasePosition)) end
                            RecordNavalSegment(iPond, iBaseSegmentX, iBaseSegmentZ, tBasePosition)
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished redundancy of checking every segment has a land zone if it is land pathable, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


local function AssignMexesALandZone()
    --Cycles through every mex and assigns it to a new land zone, unless it is near another mex in which case they should both use the same land zone

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignMexesALandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Key config values
    local iNearbyMexRange --Initially mexes will be grouped together based on this, i.e. will assign mexes within this distance of each other to the same land zone
    local iRecursiveFactor
    --rMapPotentialPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2}
    local iMaxMapSize = math.max(rMapPotentialPlayableArea[3] - rMapPotentialPlayableArea[1], rMapPotentialPlayableArea[4] - rMapPotentialPlayableArea[2])
    if iMaxMapSize > 1024 then --1024 is 20k, so this is 40k or 80k
        iNearbyMexRange = 54
        iRecursiveFactor = 4
    elseif iMaxMapSize > 512 then --i.e. 20k
        iNearbyMexRange = 46
        iRecursiveFactor = 3.5
    elseif iMaxMapSize > 256 then
        iNearbyMexRange = 42
        iRecursiveFactor = 3
    else
        iNearbyMexRange = 35
        iRecursiveFactor = 2
    end


    if bDebugMessages == true then LOG('About to setup land zones') end

    local tiPlateauLandZoneByMexRef = {} --[x] is plateau ref, [y] is mex number, returns the LZ
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        tiPlateauLandZoneByMexRef[iPlateau] = {}
    end

    local bHaveLabelOverrides = false
    if M28Utilities.IsTableEmpty(tMexPathingLabelOverride) == false then bHaveLabelOverrides = true end

    --Subfunction - if we have a mex to assign to a land zone then this subfunction should be called to check for any nearby mexes without a zone and assign these to the same zone
    function AddNearbyMexesToLandZone(iPlateau, iCurLandZone, tMex, iRecursiveCount, iCurMex)
        if bDebugMessages == true then LOG(sFunctionRef..': Adding nearby mexes to land zone, iPlateau='..(iPlateau or 'nil')..'; iCurLandZone='..(iCurLandZone or 'nil')..'; tMex='..repru(tMex)..'; iRecursiveCount='..(iRecursiveCount or 'nil')..'; Hover terrain label for tMex='..(NavUtils.GetTerrainLabel(refPathingTypeHover, tMex) or 'nil')) end

        local iLandGroupWanted
        if bHaveLabelOverrides and iCurMex and tMexPathingLabelOverride[iCurMex][2] then iLandGroupWanted = tMexPathingLabelOverride[iCurMex][2]
        else iLandGroupWanted = NavUtils.GetTerrainLabel(refPathingTypeLand, tMex)
        end
        local iMaxRange
        local iCurDist
        local iRecursiveThreshold = 10 --If around 13 or 14 then run into recursive limit and crash
        local iVeryLowDist = 8
        if iRecursiveCount <= 1 then iMaxRange = math.max(15, iNearbyMexRange)
        else
            if iRecursiveCount >= iRecursiveThreshold then
                iMaxRange = iVeryLowDist
            else
                iMaxRange = math.max(15, iNearbyMexRange - iRecursiveCount * iRecursiveFactor)
            end
        end

        local tVeryCloseMexesToDoRecursiveLogic = {}
        local tMexesToAddAndDoRecursiveLogic = {}

        for iAltMex, tAltMex in tAllPlateaus[iPlateau][subrefPlateauMexes] do
            if not(tiPlateauLandZoneByMexRef[iPlateau][iAltMex]) then
                if (NavUtils.GetTerrainLabel(refPathingTypeLand, tAltMex) == iLandGroupWanted or (bHaveLabelOverrides and tMexPathingLabelOverride[iAltMex][2] == iLandGroupWanted)) and not(IsUnderwater(tAltMex, false, 0.1)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAltMex='..iAltMex..' for zone '..iCurLandZone..'; Distance straight line='..M28Utilities.GetDistanceBetweenPositions(tAltMex, tMex)..'; Travel distance='..M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex)) end
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tAltMex, tMex)
                    --First assign mexes that are very close to each other to the same zone; if mex is further away but still close enough then add to a table for further logic
                    if iCurDist <= iVeryLowDist then
                        AddMexToLandZone(iPlateau, iCurLandZone, iAltMex, tiPlateauLandZoneByMexRef)
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Added mex '..repru(iAltMex)..' with position '..repru(tAltMex)..' to land zone, tiPlateauLandZoneByMexRef='..repru((tiPlateauLandZoneByMexRef[iPlateau] or {'nil'}))..'; Distance in straight line='..M28Utilities.GetDistanceBetweenPositions(tAltMex, tMex)..'; Travel distance='..M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex)..'; tMex='..repru(tMex)..'; tAltMex='..repru(tAltMex)..'; Land label for tMex='..(NavUtils.GetLabel(refPathingTypeLand, tMex) or 'nil')..'; land label for tAltMex='..(NavUtils.GetLabel(refPathingTypeLand, tAltMex) or 'nil'))
                            M28Utilities.DrawLocation(tAltMex, 2)
                            M28Utilities.DrawLocation(tMex, 1)
                        end
                        tVeryCloseMexesToDoRecursiveLogic[iAltMex] = tAltMex
                    elseif iCurDist <= iMaxRange and M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex) <= iMaxRange then
                        tMexesToAddAndDoRecursiveLogic[iAltMex] = tAltMex
                    end
                end
            end
        end
        --First do recursive logic on the very close mexes
        if M28Utilities.IsTableEmpty(tVeryCloseMexesToDoRecursiveLogic) == false and iRecursiveCount < iRecursiveThreshold then
            for iAltMex, tAltMex in tVeryCloseMexesToDoRecursiveLogic do
                AddNearbyMexesToLandZone(iPlateau, iCurLandZone, tAltMex, iRecursiveCount + 1, iAltMex) --Needs to be recursive or else can end up with 2 mees that are really close to each other not being in the same group depending on the order in which the original mexes are called
            end
        end
        --Next do recursive logic on further away mexes (and add those mexes to this land zone), if they are still unassigned
        if M28Utilities.IsTableEmpty(tMexesToAddAndDoRecursiveLogic) == false then
            for iAltMex, tAltMex in tMexesToAddAndDoRecursiveLogic do
                if not(tiPlateauLandZoneByMexRef[iPlateau][iAltMex]) then
                    AddMexToLandZone(iPlateau, iCurLandZone, iAltMex, tiPlateauLandZoneByMexRef)
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Added mex '..repru(iAltMex)..' with position '..repru(tAltMex)..' to land zone, tiPlateauLandZoneByMexRef='..repru((tiPlateauLandZoneByMexRef[iPlateau] or {'nil'}))..'; Distance in straight line='..M28Utilities.GetDistanceBetweenPositions(tAltMex, tMex)..'; Travel distance='..M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex)..'; tMex='..repru(tMex)..'; tAltMex='..repru(tAltMex)..'; Land label for tMex='..(NavUtils.GetLabel(refPathingTypeLand, tMex) or 'nil')..'; land label for tAltMex='..(NavUtils.GetLabel(refPathingTypeLand, tAltMex) or 'nil'))
                        M28Utilities.DrawLocation(tAltMex, 2)
                        M28Utilities.DrawLocation(tMex, 1)
                    end
                end
                if iRecursiveCount < iRecursiveThreshold then
                    AddNearbyMexesToLandZone(iPlateau, iCurLandZone, tAltMex, iRecursiveCount + 1, iAltMex) --Needs to be recursive or else can end up with 2 mees that are really close to each other not being in the same group depending on the order in which the original mexes are called
                end
            end
        end
    end

    --First setup core base land zones, including merging core bases if they are close to each other into a single land zone - have the size of the core base impacted by if there is a hydro nearby

    --Get the start points to actually consider
    local tRelevantStartPointsByIndex = {}
    for iBrain, oBrain in ArmyBrains do
        if not(M28Conditions.IsCivilianBrain(oBrain)) then
            local iStartPositionX, iStartPositionZ = GetPlayerStartPosition(oBrain, true)
            if iStartPositionX and iStartPositionZ then
                if bDebugMessages == true then LOG(sFunctionRef..': Recording the start position for brain '..oBrain.Nickname..'; X='..iStartPositionX..'Z='..iStartPositionZ) end
                tRelevantStartPointsByIndex[oBrain:GetArmyIndex()] = {iStartPositionX, GetSurfaceHeight(iStartPositionX, iStartPositionZ), iStartPositionZ}
            end
        end
    end



    local tiStartIndexPlateauAndLZ = {} --[x] is the player index, returns the land zone to use
    local iLZToUse
    local iCurPlateau
    --Create a table of the start locations that have their own unique land zone (as we want to combine those that are close together):
    for iIndex, tStartPosition in tRelevantStartPointsByIndex do
        iLZToUse = nil
        iCurPlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, tStartPosition)
        if bDebugMessages == true then LOG(sFunctionRef..': Considering tStartPosition='..repru(tStartPosition)..'; iCurPlateau based on hover terrain label='..(iCurPlateau or 'nil')) end
        --Are we close to an existing start position such that we should use the same LZ for both positions?
        if M28Utilities.IsTableEmpty(tiStartIndexPlateauAndLZ) == false then
            for iExistingIndex, tExistingPlateauAndLZ in tiStartIndexPlateauAndLZ do
                if bDebugMessages == true then LOG(sFunctionRef..': Dist between start position and iExistingIndex='..iExistingIndex..'='..M28Utilities.GetDistanceBetweenPositions(tStartPosition, tRelevantStartPointsByIndex[iExistingIndex])) end
                if tExistingPlateauAndLZ[1] == iCurPlateau and M28Utilities.GetDistanceBetweenPositions(tStartPosition, tRelevantStartPointsByIndex[iExistingIndex]) <= 40 then
                    iLZToUse = tExistingPlateauAndLZ[2]
                    break
                end
            end
        end
        if not(iLZToUse) then
            --Check the start position is on land
            if (NavUtils.GetTerrainLabel(refPathingTypeLand, tStartPosition) or 0) > 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': About to add a new LZ reference to iCurPlateau '..(iCurPlateau or 'nil')..' for start position '..repru(tStartPosition)) end
                AddNewLandZoneReferenceToPlateau(iCurPlateau)
                iLZToUse = tAllPlateaus[iCurPlateau][subrefLandZoneCount]
                if bDebugMessages == true then LOG(sFunctionRef..': Just added iLZToUse='..iLZToUse..'; tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]='..reprs(tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iLZToUse])) end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Start position isnt on valid land pathable location, so assuming it is on water and wont create a lnad zone here') end
            end
        end
        if iLZToUse then
            tiStartIndexPlateauAndLZ[iIndex] = {iCurPlateau, iLZToUse}
            local iCurSegmentX, iCurSegmentZ = GetPathingSegmentFromPosition(tStartPosition)
            RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iCurPlateau, iLZToUse)
            if bDebugMessages == true then LOG(sFunctionRef..': Have just recorded iLZToUse='..iLZToUse..' for iCurPlateau='..iCurPlateau..'; iCurSegmentX-Z='..iCurSegmentX..'-'..iCurSegmentZ..'; Start position='..repru(tStartPosition)..'; Brain index='..iIndex) end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished creating land zone by each start position, tiStartIndexPlateauAndLZ='..repru(tiStartIndexPlateauAndLZ)..'; tRelevantStartPointsByIndex='..repru(tRelevantStartPointsByIndex)) end

    --Now find any mexes within the desired travel distance and assign them to the nearest start position - first exclude based on distance, and if they meet the straight line distance check then consider travel distance
    local iCurDistStraightLine
    local iCurDistTravel
    local iClosestDistTravel
    local iClosestBrainIndex

    local tiStartResourcesByBrainIndex = {}

    local iStraightLineToIgnoreTravelDist = 40
    local iStraightLineThreshold = 70 --Ignore locations that are more than this distance away
    local iHydroStraightLineThreshold = iStraightLineThreshold + 5
    local iTravelDistThreshold = 75 --Ignore locations that are more than this land travel distance away
    local iHydroTravelDistThreshold = iTravelDistThreshold + 5
    local iStartPositionTravelThreshold = iTravelDistThreshold + 5
    local tiSlightlyNearMexDistByPlateauMexAndBrain = {}
    local tPotentialNearMexesByBrain = {}
    local tiMexesAssignedByBrain = {} --used in campaign maps if a brain location lacks a mex

    local iCampaignSlightlyNearThreshold = iStraightLineThreshold

    if bIsCampaignMap then
        iStraightLineThreshold = 40 --40 caused issue on fort claeke assault (prior to the slightlynear logic)
    end
    local iClosestStraightLineDist
    local iClosestStraightLineIndex
    local iClosestStraightLineTravelDist


    --Work out the closest mex for the brain index
    local iClosestMexToFirstPlayer = 1000
    if M28Utilities.IsTableEmpty(tRelevantStartPointsByIndex) == false then
        for iIndex, tStartPosition in tRelevantStartPointsByIndex do
            local tiStartPlateauAndZone = tiStartIndexPlateauAndLZ[iIndex]
            local iCurMexDist
            if M28Utilities.IsTableEmpty(tAllPlateaus[tiStartPlateauAndZone[1]][subrefPlateauMexes]) == false then
                for iMex, tMex in tAllPlateaus[tiStartPlateauAndZone[1]][subrefPlateauMexes] do
                    --Only consider if mex isnt underwater
                    if tMex[2] >= iMapWaterHeight then
                        iCurMexDist = M28Utilities.GetDistanceBetweenPositions(tMex, tStartPosition)
                        if iCurMexDist < iClosestMexToFirstPlayer then iClosestMexToFirstPlayer = iCurMexDist end
                    end
                end
            end
            if iClosestMexToFirstPlayer < 1000 then break end --only want to consider the first
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering the closest dist of a mex to the first player, iClosestMexToFirstPlayer='..iClosestMexToFirstPlayer..'; iStraightLineThreshold='..iStraightLineThreshold) end
    if iClosestMexToFirstPlayer > iStraightLineThreshold * 0.8 and iClosestMexToFirstPlayer <= 200 then
        iStraightLineThreshold = math.max(iClosestMexToFirstPlayer * 1.15, iClosestMexToFirstPlayer + 15)
        iTravelDistThreshold = math.max(iTravelDistThreshold + 10, iStraightLineThreshold * 1.15, iStraightLineThreshold + 20)
        if bDebugMessages == true then LOG(sFunctionRef..': Changing straight line threshold to '..iStraightLineThreshold..'; iTravelDistThreshold='..iTravelDistThreshold) end
    end

    local tbStartingMexesRecordedByPlateau = {} --Tracks if we have already recorded a mex as near a brain start so we dont try and re-record it
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        if M28Utilities.IsTableEmpty(tPlateauSubtable[subrefPlateauMexes]) == false then
            tbStartingMexesRecordedByPlateau[iPlateau] = {}
            if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through all mexes on plateau '..iPlateau..' and assign them to the nearest start position on taht plateau, if there is one') end
            for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do
                --Only consider if mex isnt underwater

                if bDebugMessages == true then LOG(sFunctionRef..': Considering iMex '..iMex..'; tMex '..repru(tMex)..'; iMapWaterHeight='..iMapWaterHeight) end
                if tMex[2] >= iMapWaterHeight then
                    --Find the closest start point
                    iClosestDistTravel = iTravelDistThreshold --Ignore points whose travel distance is further away than this
                    iClosestBrainIndex = nil
                    iClosestStraightLineDist = 100000
                    iClosestStraightLineIndex = nil
                    iClosestStraightLineTravelDist = 100000
                    local tiBrainsWithinThreshold = {}
                    --Get the start position closest to this mex (if there are any close enough that we might want the mex to be part of the start zone)
                    for iBrainIndex, tStartPoint in tRelevantStartPointsByIndex do
                        if tiStartIndexPlateauAndLZ[iBrainIndex][1] == iPlateau then
                            iCurDistStraightLine = M28Utilities.GetDistanceBetweenPositions(tMex, tStartPoint)
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurDistStraightLine='..iCurDistStraightLine..'; iStraightLineThreshold='..iStraightLineThreshold..'; iClosestStraightLineTravelDist='..iClosestStraightLineTravelDist..'; iCampaignSlightlyNearThreshold='..iCampaignSlightlyNearThreshold..'; Travel dist='..(M28Utilities.GetTravelDistanceBetweenPositions(tStartPoint, tMex, refPathingTypeHover) or 'nil')) end
                            if iCurDistStraightLine <= iStraightLineThreshold and (iCurDistStraightLine <= iStraightLineToIgnoreTravelDist or M28Utilities.GetTravelDistanceBetweenPositions(tStartPoint, tMex, refPathingTypeHover) or 1000) < iStartPositionTravelThreshold then
                                table.insert(tiBrainsWithinThreshold, {iBrainIndex, iCurDistStraightLine})
                                if iCurDistStraightLine < iClosestStraightLineTravelDist then
                                    iClosestStraightLineTravelDist = iCurDistStraightLine
                                    iClosestStraightLineIndex = iBrainIndex
                                end
                                --[[
                                --Get the land pathing distance
                                iCurDistTravel = M28Utilities.GetTravelDistanceBetweenPositions(tMex, tStartPoint, refPathingTypeLand)
                                if iCurDistTravel < iClosestDistTravel then
                                    iClosestDistTravel = iCurDistTravel
                                    iClosestBrainIndex = iBrainIndex
                                end--]]
                            elseif iCurDistStraightLine <= iCampaignSlightlyNearThreshold and bIsCampaignMap then
                                if not(tiSlightlyNearMexDistByPlateauMexAndBrain[iPlateau][iMex]) then
                                    if not(tiSlightlyNearMexDistByPlateauMexAndBrain[iPlateau]) then tiSlightlyNearMexDistByPlateauMexAndBrain[iPlateau] = {} end
                                    tiSlightlyNearMexDistByPlateauMexAndBrain[iPlateau][iMex] = {}
                                end
                                tiSlightlyNearMexDistByPlateauMexAndBrain[iPlateau][iMex][iBrainIndex] = iCurDistStraightLine
                                if bDebugMessages == true then LOG(sFunctionRef..': Added mex to slightly near mex by dist, iMex='..iMex..'; iBrain='..iBrainIndex) end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Mex is above water, considering iMex='..iMex..'; tMex='..repru(tMex)..' for iPlateau='..iPlateau..'; will look for the closest brain start position and assign the mex to the same zone if it is close enough. iClosestStraightLineIndex='..(iClosestStraightLineIndex or 'nil')) end
                    if iClosestStraightLineIndex then
                        iClosestDistTravel = M28Utilities.GetTravelDistanceBetweenPositions(tMex, tRelevantStartPointsByIndex[iClosestStraightLineIndex], refPathingTypeLand)
                        iClosestBrainIndex = iClosestStraightLineIndex
                        for iEntry, tiIndexAndDist in tiBrainsWithinThreshold do
                            if bDebugMessages == true then LOG(sFunctionRef..': iClosestStraightLineIndex='..iClosestStraightLineIndex..'; tiIndexAndDist='..repru(tiIndexAndDist)..'; tRelevantStartPointsByIndex[tiIndexAndDist[1]]='..repru(tRelevantStartPointsByIndex[tiIndexAndDist[1]])..'; tMex='..repru(tMex)) end
                            if tiIndexAndDist[2] < iClosestDistTravel and not(tiIndexAndDist[1] == iClosestStraightLineIndex) then
                                iCurDistTravel = M28Utilities.GetTravelDistanceBetweenPositions(tMex, tRelevantStartPointsByIndex[tiIndexAndDist[1]], refPathingTypeLand)
                                if bDebugMessages == true then LOG(sFunctionRef..': iCurDistTravel='..(iCurDistTravel or 'nil')..'; iClosestDistTravel='..iClosestDistTravel) end
                                if iCurDistTravel < iClosestDistTravel then
                                    iClosestDistTravel = iCurDistTravel
                                    iClosestBrainIndex = tiIndexAndDist[1]
                                end
                            end
                        end
                    end

                    if bDebugMessages == true then LOG(sFunctionRef..': Searching for closest brain index to tMex '..repru(tMex)..' that is close enough, iClosestBrainIndex='..(iClosestBrainIndex or 'nil')..'; Is tiSlightlyNearMexDistByPlateauMexAndBrain[iPlateau][iMex] nil='..tostring(tiSlightlyNearMexDistByPlateauMexAndBrain[iPlateau][iMex]==nil)) end
                    if iClosestBrainIndex then
                        if bIsCampaignMap and tiSlightlyNearMexDistByPlateauMexAndBrain[iPlateau][iMex] then tiSlightlyNearMexDistByPlateauMexAndBrain[iPlateau][iMex] = nil end
                        if not(tiStartResourcesByBrainIndex[iClosestBrainIndex]) then tiStartResourcesByBrainIndex[iClosestBrainIndex] = {} end
                        table.insert(tiStartResourcesByBrainIndex[iClosestBrainIndex], tMex)
                        tbStartingMexesRecordedByPlateau[iPlateau][iMex] = true
                        AddMexToLandZone(iPlateau, tiStartIndexPlateauAndLZ[iClosestBrainIndex][2], iMex, tiPlateauLandZoneByMexRef)
                        tiMexesAssignedByBrain[iClosestBrainIndex] = (tiMexesAssignedByBrain[iClosestBrainIndex] or 0) + 1
                        if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..(tiStartIndexPlateauAndLZ[iClosestBrainIndex][2] or 'nil')..'; Adding iMex='..iMex..'; at position '..repru(tMex)..'; to the start position for aiBrain index='..(iClosestBrainIndex or 'nil')..' which is at '..repru(tRelevantStartPointsByIndex[iClosestBrainIndex])) end
                    elseif bIsCampaignMap and tiSlightlyNearMexDistByPlateauMexAndBrain[iPlateau][iMex] then
                        --Add to the cloesest brain index
                        --Get the closest entry
                        iClosestStraightLineTravelDist = 10000
                        for iBrain, iDist in tiSlightlyNearMexDistByPlateauMexAndBrain[iPlateau][iMex] do
                            if iDist < iClosestStraightLineTravelDist then
                                iClosestStraightLineTravelDist = iDist
                                iClosestBrainIndex = iBrain
                            end
                        end
                        if not(tPotentialNearMexesByBrain[iClosestBrainIndex]) then tPotentialNearMexesByBrain[iClosestBrainIndex] = {} end
                        if bDebugMessages == true then LOG(sFunctionRef..': Campaign redundancy, iClosestBrainIndex='..iClosestBrainIndex..'; iPlateau='..iPlateau..'; iMax='..iMex) end
                        table.insert(tPotentialNearMexesByBrain[iClosestBrainIndex], {iPlateau, iMex})
                    elseif bDebugMessages == true then LOG(sFunctionRef..': Not recording mex against a start position land zone')
                    end
                end
            end
        end
    end
    --Consider further away mexes in campaign if the brain start position doesnt have any nearby
    if bIsCampaignMap then
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if any brainsl ack an assigned mex, tiMexesAssignedByBrain='..repru(tiMexesAssignedByBrain)) end
        for iBrainIndex, tStartPoint in tRelevantStartPointsByIndex do
            if (tiMexesAssignedByBrain[iBrainIndex] or 0) == 0 then
                if M28Utilities.IsTableEmpty(tPotentialNearMexesByBrain[iBrainIndex]) == false then
                    for iEntry, tPlateauAndMexIndex in tPotentialNearMexesByBrain[iBrainIndex] do
                        local iPlateau = tPlateauAndMexIndex[1]
                        local iMex = tPlateauAndMexIndex[2]
                        local tMex = tAllPlateaus[iPlateau][subrefPlateauMexes][iMex]
                        if not(tiStartResourcesByBrainIndex[iBrainIndex]) then tiStartResourcesByBrainIndex[iBrainIndex] = {} end
                        table.insert(tiStartResourcesByBrainIndex[iBrainIndex], tMex)
                        tbStartingMexesRecordedByPlateau[iPlateau][iMex] = true
                        AddMexToLandZone(iPlateau, tiStartIndexPlateauAndLZ[iBrainIndex][2], iMex, tiPlateauLandZoneByMexRef)
                        tiMexesAssignedByBrain[iBrainIndex] = (tiMexesAssignedByBrain[iBrainIndex] or 0) + 1
                        if bDebugMessages == true then LOG(sFunctionRef..': Campaign redundancy for mex free start points, iBrainIndex='..iBrainIndex..'; iMex='..iMex..'; tMex='..repru(tMex)) end
                    end
                end
            end
        end
    end

    --Debug - draw the groupings of mexes with black rectangles around them to show how they've been grouped
    if bDebugMessages == true then
        local iColour = 0
        for iPlateau, tPlateauSubtable in tAllPlateaus do
            LOG(sFunctionRef..': About to draw results of land zones for iPlateau='..iPlateau..'; tiPlateauLandZoneByMexRef[iPlateau]='..repru(tiPlateauLandZoneByMexRef[iPlateau])..'; tAllPlateaus[iPlateau][subrefPlateauLandZones]='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones]))
            iColour = 3
            --Draw the mex groupings
            if M28Utilities.IsTableEmpty(tAllPlateaus[iPlateau][subrefPlateauLandZones]) == false then
                for iZone, tZone in tAllPlateaus[iPlateau][subrefPlateauLandZones] do
                    local iMinX = 100000
                    local iMaxX = 0
                    local iMinZ = 100000
                    local iMaxZ = 0

                    for iMex, tMex in tZone[subrefLZMexLocations] do
                        iMinX = math.min(tMex[1], iMinX)
                        iMaxX = math.max(tMex[1], iMaxX)
                        iMinZ = math.min(tMex[3], iMinZ)
                        iMaxZ = math.max(tMex[3], iMaxZ)
                    end
                    M28Utilities.DrawRectangle(Rect(iMinX, iMinZ, iMaxX, iMaxZ), iColour, 1000, 10)
                end
            end
        end
    end


    --Now add any mexes near these resource locations to the same land zone
    if bDebugMessages == true then LOG(sFunctionRef..': Will now add mexes near the start position resources to the same land zone, tiStartResourcesByBrainIndex='..repru(tiStartResourcesByBrainIndex)) end
    local iStartRecursiveCountToUse
    for iBrainIndex, tResources in tiStartResourcesByBrainIndex do
        iStartRecursiveCountToUse = 1
        if table.getn(tResources) >= 3 then iStartRecursiveCountToUse = table.getn(tResources) - 2 end
        for iResource, tResourceLocation in tResources do
            if (tiStartIndexPlateauAndLZ[iBrainIndex][2] or 0) > 0 then
                AddNearbyMexesToLandZone(tiStartIndexPlateauAndLZ[iBrainIndex][1], tiStartIndexPlateauAndLZ[iBrainIndex][2], tResourceLocation, iStartRecursiveCountToUse, nil)
            end
        end
    end


    --Debug - draw the groupings of mexes with gold rectangles around them to show how they've been grouped following the above
    if bDebugMessages == true then
        local iColour = 0
        for iPlateau, tPlateauSubtable in tAllPlateaus do
            LOG(sFunctionRef..': About to draw results of land zones for iPlateau='..iPlateau..'; tiPlateauLandZoneByMexRef[iPlateau]='..repru(tiPlateauLandZoneByMexRef[iPlateau])..'; tAllPlateaus[iPlateau][subrefPlateauLandZones]='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones]))
            iColour = 4
            --Draw the mex groupings
            if M28Utilities.IsTableEmpty(tAllPlateaus[iPlateau][subrefPlateauLandZones]) == false then
                for iZone, tZone in tAllPlateaus[iPlateau][subrefPlateauLandZones] do
                    local iMinX = 100000
                    local iMaxX = 0
                    local iMinZ = 100000
                    local iMaxZ = 0

                    for iMex, tMex in tZone[subrefLZMexLocations] do
                        iMinX = math.min(tMex[1], iMinX)
                        iMaxX = math.max(tMex[1], iMaxX)
                        iMinZ = math.min(tMex[3], iMinZ)
                        iMaxZ = math.max(tMex[3], iMaxZ)
                    end
                    M28Utilities.DrawRectangle(Rect(iMinX - 0.1, iMinZ - 0.1, iMaxX + 0.1, iMaxZ + 0.1), iColour, 1000, 10)
                end
            end
        end
    end

    --Now assign any hydros near to a start zone to the start zone
    for iHydro, tHydro in tHydroPoints do
        --Get closest start position to this hydro
        local iPlateau = NavUtils.GetLabel(refPathingTypeHover, tHydro)
        --Get the start position closest to this mex (if there are any close enough that we might want the mex to be part of the start zone)
        iClosestDistTravel = iHydroTravelDistThreshold --Ignore points whose travel distance is further away than this
        iClosestBrainIndex = nil
        iClosestStraightLineDist = 100000
        iClosestStraightLineIndex = nil
        iClosestStraightLineTravelDist = 100000
        local tiBrainsWithinThreshold = {}
        for iBrainIndex, tStartPoint in tRelevantStartPointsByIndex do
            if tiStartIndexPlateauAndLZ[iBrainIndex][1] == iPlateau then
                iCurDistStraightLine = M28Utilities.GetDistanceBetweenPositions(tHydro, tStartPoint)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering hydro at '..repru(tHydro)..' vs start point at '..repru(tStartPoint)..'; iCurDistStraightLine='..iCurDistStraightLine..'; iHydroStraightLineThreshold='..iHydroStraightLineThreshold..'; iClosestStraightLineTravelDist='..iClosestStraightLineTravelDist) end
                if iCurDistStraightLine <= iHydroStraightLineThreshold then
                    table.insert(tiBrainsWithinThreshold, {iBrainIndex, iCurDistStraightLine})
                    if iCurDistStraightLine < iClosestStraightLineTravelDist then
                        iClosestStraightLineTravelDist = iCurDistStraightLine
                        iClosestStraightLineIndex = iBrainIndex
                    end
                end
            end
        end
        if iClosestStraightLineIndex then
            iClosestDistTravel = M28Utilities.GetTravelDistanceBetweenPositions(tHydro, tRelevantStartPointsByIndex[iClosestStraightLineIndex], refPathingTypeLand)
            iClosestBrainIndex = iClosestStraightLineIndex
            for iEntry, tiIndexAndDist in tiBrainsWithinThreshold do
                if bDebugMessages == true then LOG(sFunctionRef..': iClosestStraightLineIndex='..iClosestStraightLineIndex..'; tiIndexAndDist='..repru(tiIndexAndDist)..'; tRelevantStartPointsByIndex[tiIndexAndDist[1]]='..repru(tRelevantStartPointsByIndex[tiIndexAndDist[1]])..'; tHydro='..repru(tHydro)) end
                if tiIndexAndDist[2] < iClosestDistTravel and not(tiIndexAndDist[1] == iClosestStraightLineIndex) then
                    iCurDistTravel = M28Utilities.GetTravelDistanceBetweenPositions(tHydro, tRelevantStartPointsByIndex[tiIndexAndDist[1]], refPathingTypeLand)
                    if bDebugMessages == true then LOG(sFunctionRef..': iCurDistTravel='..(iCurDistTravel or 'nil')..'; iClosestDistTravel='..iClosestDistTravel) end
                    if iCurDistTravel < iClosestDistTravel then
                        iClosestDistTravel = iCurDistTravel
                        iClosestBrainIndex = tiIndexAndDist[1]
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Searching for closest brain index to tHydro '..repru(tHydro)..' that is close enough, iClosestBrainIndex='..(iClosestBrainIndex or 'nil')) end
        if iClosestBrainIndex then
            if not(tiStartResourcesByBrainIndex[iClosestBrainIndex]) then tiStartResourcesByBrainIndex[iClosestBrainIndex] = {} end
            table.insert(tiStartResourcesByBrainIndex[iClosestBrainIndex], tHydro)
            RecordHydroInLandZone(tHydro, iPlateau, tiStartIndexPlateauAndLZ[iClosestBrainIndex][2], true)
            if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..(tiStartIndexPlateauAndLZ[iClosestBrainIndex][2] or 'nil')..'; Adding iHydro='..iHydro..'; at position '..repru(tHydro)..'; to the start position for aiBrain index='..(iClosestBrainIndex or 'nil')..' which is at '..repru(tRelevantStartPointsByIndex[iClosestBrainIndex])..'; iClosestDistTravel='..iClosestDistTravel) end
        end
    end
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        if M28Utilities.IsTableEmpty(tPlateauSubtable[subrefPlateauMexes]) == false then
            for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do
                --Ignore if we have already recorded this mex above
                if not(tbStartingMexesRecordedByPlateau[iPlateau][iMex]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Dealing with a mex that we havent yet assigned, iPlateau='..iPlateau..'; iMex='..iMex..'; tMex='..repru(tMex)..'; iMapWaterHeight='..iMapWaterHeight) end
                    --Only consider if mex isnt underwater
                    if tMex[2] >= iMapWaterHeight then
                        --Find the closest start point
                        iClosestDistTravel = iTravelDistThreshold --Ignore points whose travel distance is further away than this
                        iClosestBrainIndex = nil
                        iClosestStraightLineDist = 100000
                        iClosestStraightLineIndex = nil
                        iClosestStraightLineTravelDist = 100000
                        local tiBrainsWithinThreshold = {}
                        --Get the start position closest to this mex (if there are any close enough that we might want the mex to be part of the start zone)
                        for iBrainIndex, tStartPoint in tRelevantStartPointsByIndex do
                            if tiStartIndexPlateauAndLZ[iBrainIndex][1] == iPlateau then
                                iCurDistStraightLine = M28Utilities.GetDistanceBetweenPositions(tMex, tStartPoint)
                                if bDebugMessages == true then LOG(sFunctionRef..': iCurDistStraightLine='..iCurDistStraightLine..'; iStraightLineThreshold='..iStraightLineThreshold..'; iClosestStraightLineTravelDist='..iClosestStraightLineTravelDist) end
                                if iCurDistStraightLine <= iStraightLineThreshold and (iCurDistStraightLine <= iStraightLineToIgnoreTravelDist or M28Utilities.GetTravelDistanceBetweenPositions(tStartPoint, tMex, refPathingTypeHover) or 1000) < iStartPositionTravelThreshold then
                                    table.insert(tiBrainsWithinThreshold, {iBrainIndex, iCurDistStraightLine})
                                    if iCurDistStraightLine < iClosestStraightLineTravelDist then
                                        iClosestStraightLineTravelDist = iCurDistStraightLine
                                        iClosestStraightLineIndex = iBrainIndex
                                    end
                                    --[[
                                    --Get the land pathing distance
                                    iCurDistTravel = M28Utilities.GetTravelDistanceBetweenPositions(tMex, tStartPoint, refPathingTypeLand)
                                    if iCurDistTravel < iClosestDistTravel then
                                        iClosestDistTravel = iCurDistTravel
                                        iClosestBrainIndex = iBrainIndex
                                    end--]]
                                end
                            end
                        end
                        if iClosestStraightLineIndex then
                            iClosestDistTravel = M28Utilities.GetTravelDistanceBetweenPositions(tMex, tRelevantStartPointsByIndex[iClosestStraightLineIndex], refPathingTypeLand)
                            iClosestBrainIndex = iClosestStraightLineIndex
                            for iEntry, tiIndexAndDist in tiBrainsWithinThreshold do
                                if bDebugMessages == true then LOG(sFunctionRef..': iClosestStraightLineIndex='..iClosestStraightLineIndex..'; tiIndexAndDist='..repru(tiIndexAndDist)..'; tRelevantStartPointsByIndex[tiIndexAndDist[1]]='..repru(tRelevantStartPointsByIndex[tiIndexAndDist[1]])..'; tMex='..repru(tMex)) end
                                if tiIndexAndDist[2] < iClosestDistTravel and not(tiIndexAndDist[1] == iClosestStraightLineIndex) then
                                    iCurDistTravel = M28Utilities.GetTravelDistanceBetweenPositions(tMex, tRelevantStartPointsByIndex[tiIndexAndDist[1]], refPathingTypeLand)
                                    if bDebugMessages == true then LOG(sFunctionRef..': iCurDistTravel='..(iCurDistTravel or 'nil')..'; iClosestDistTravel='..iClosestDistTravel) end
                                    if iCurDistTravel < iClosestDistTravel then
                                        iClosestDistTravel = iCurDistTravel
                                        iClosestBrainIndex = tiIndexAndDist[1]
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Searching for closest brain index to tMex '..repru(tMex)..' that is close enough, iClosestBrainIndex='..(iClosestBrainIndex or 'nil')) end
                        if iClosestBrainIndex then
                            if not(tiStartResourcesByBrainIndex[iClosestBrainIndex]) then tiStartResourcesByBrainIndex[iClosestBrainIndex] = {} end
                            table.insert(tiStartResourcesByBrainIndex[iClosestBrainIndex], tMex)

                            AddMexToLandZone(iPlateau, tiStartIndexPlateauAndLZ[iClosestBrainIndex][2], iMex, tiPlateauLandZoneByMexRef)
                            if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..(tiStartIndexPlateauAndLZ[iClosestBrainIndex][2] or 'nil')..'; Adding iMex='..iMex..'; at position '..repru(tMex)..'; to the start position for aiBrain index='..(iClosestBrainIndex or 'nil')..' which is at '..repru(tRelevantStartPointsByIndex[iClosestBrainIndex])) end
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': Mex is underwater so not assigning')
                    end
                end
            end
        end
    end

    --Assign zones to mex locations - group mexes that are near each other in the same zone
    local iCurLandZone
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        if not(tAllPlateaus[iPlateau][subrefPlateauLandZones]) then tAllPlateaus[iPlateau][subrefPlateauLandZones] = {} end
        if bDebugMessages == true then LOG(sFunctionRef..': tPlateauSubtable[subrefPlateauMexes]='..repru(tPlateauSubtable[subrefPlateauMexes])) end
        if M28Utilities.IsTableEmpty(tPlateauSubtable[subrefPlateauMexes]) == false then
            for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do
                --Only do this if we didnt record as part of start position (as we already add nearby mexes as part of that)
                if not(tbStartingMexesRecordedByPlateau[iPlateau][iMex]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Dealing with mexes not assigned from either start zone logic, so will look for nearby mex, iMex='..iMex..'; tMex='..repru(tMex)..'; Is mex underwater='..tostring(IsUnderwater(tMex, false, 0.1))) end
                    if not(IsUnderwater(tMex, false, 0.1)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Plateau='..iPlateau..': Considering mex with plateau mex ref='..iMex..'; position='..repru(tMex)..'; tiPlateauLandZoneByMexRef for this ref='..(tiPlateauLandZoneByMexRef[iPlateau][iMex] or 'nil')) end
                        if not(tiPlateauLandZoneByMexRef[iPlateau][iMex]) then
                            AddMexToLandZone(iPlateau, nil, iMex, tiPlateauLandZoneByMexRef)
                            iCurLandZone = tiPlateauLandZoneByMexRef[iPlateau][iMex]
                            if bDebugMessages == true then LOG(sFunctionRef..': Added mex '..iMex..' with position '..repru(tMex)..' to land zone, tiPlateauLandZoneByMexRef='..(tiPlateauLandZoneByMexRef[iPlateau][iMex] or 'nil')) end

                            --Cycle through each other mex in the plateau and if it is within iNearbyMexRange then assign it to the same group if it hasnt had a group assigned already
                            AddNearbyMexesToLandZone(iPlateau, iCurLandZone, tMex, 0, iMex)
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording land zone mexes for iPlateau='..iPlateau..'; Size of land zones table='..table.getn(tAllPlateaus[iPlateau][subrefPlateauLandZones])) end
    end

    --Debug - draw the groupings of mexes with rectangles around them to show how they've been grouped, with a different colour for each plateau group:
    if bDebugMessages == true then
        local iColour = 0
        for iPlateau, tPlateauSubtable in tAllPlateaus do
            LOG(sFunctionRef..': About to draw results of land zones for iPlateau='..iPlateau..'; tiPlateauLandZoneByMexRef[iPlateau]='..repru(tiPlateauLandZoneByMexRef[iPlateau])..'; tAllPlateaus[iPlateau][subrefPlateauLandZones]='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones]))
            iColour = iColour + 1
            if iColour > 7 then iColour = 1 end
            --Draw the mex groupings
            for iZone, tZone in tAllPlateaus[iPlateau][subrefPlateauLandZones] do
                local iMinX = 100000
                local iMaxX = 0
                local iMinZ = 100000
                local iMaxZ = 0

                for iMex, tMex in tZone[subrefLZMexLocations] do
                    iMinX = math.min(tMex[1], iMinX)
                    iMaxX = math.max(tMex[1], iMaxX)
                    iMinZ = math.min(tMex[3], iMinZ)
                    iMaxZ = math.max(tMex[3], iMaxZ)
                end
                M28Utilities.DrawRectangle(Rect(iMinX, iMinZ, iMaxX, iMaxZ), iColour, 1000, 10)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DrawSpecificLandZone(iPlateau, iLandZone, iColour)
    local tLocation
    for iSegmentRef, tSegmentXZ in tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments] do
        tLocation = GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
        M28Utilities.DrawLocation(tLocation, iColour, nil, iLandZoneSegmentSize - 0.1)
    end
end

function DrawSpecificWaterZone(iWaterZone, iOptionalColour, iOptionalTime)
    local tLocation
    local iPond = tiPondByWaterZone[iWaterZone]
    local tWZData = tPondDetails[iPond][subrefPondWaterZones][iWaterZone]
    if iOptionalColour == nil then
        iOptionalColour = iWaterZone
        while iOptionalColour > 8 do
            iOptionalColour = iOptionalColour - 8
        end
        if iOptionalColour == 2 then iOptionalColour = iOptionalColour + 1 end
    end

    for iSegmentRef, tSegmentXZ in tWZData[subrefWZSegments] do
        tLocation = GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
        M28Utilities.DrawLocation(tLocation, iOptionalColour, iOptionalTime, iLandZoneSegmentSize - 0.1)
    end
    --Draw midpoint in red if there is one
    if M28Utilities.IsTableEmpty(tWZData[subrefMidpoint]) == false then
        M28Utilities.DrawLocation(tWZData[subrefMidpoint], 2, iOptionalTime, iLandZoneSegmentSize - 0.05)
    end
end

function DrawLandZones()
    --For debug use - will draw each land zone in a plateau in a different colour to allow a visual check of how land zones have been created.  Can be called part-way through the process (e.g. to show land zones after the initial mex creation and nearby areas)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DrawLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Create fixed colours per ref
    local iUniqueColourCount = 30
    local tColourTable = M28Utilities.GenerateUniqueColourTable(iUniqueColourCount)

    --Subfunction which assigns a unique colour to each land zone
    function GetColourFromLandZoneNumber(iLandZoneRef)
        local iColour = iLandZoneRef
        while iColour >= iUniqueColourCount do
            iColour = iColour - iUniqueColourCount
        end

        return tColourTable[iColour]
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Will now draw every land zone in every plateau, cycling the colour used') end
    local tLocation, iLandZoneRef
    --Cycle through every segment on the map and draw a colour for it based on the land zone that it's part of
    for iCurSegmentX = 1, iMaxLandSegmentX do
        for iCurSegmentZ = 1, iMaxLandSegmentZ do
            iLandZoneRef = tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
            if (iLandZoneRef or 0) > 0 then
                tLocation = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                if bDebugMessages == true then LOG(sFunctionRef..': Land zone ref for segments X-Z='..iCurSegmentX..'-'..iCurSegmentZ..' = '..iLandZoneRef..'; Plataeu ref based on navutils='..NavUtils.GetTerrainLabel(refPathingTypeHover, tLocation)) end
                --M28Utilities.DrawLocation(tLocation, GetColourFromLandZoneNumber(iLandZoneRef), nil, iLandZoneSegmentSize - 0.1)
                M28Utilities.DrawLocation(tLocation, GetColourFromLandZoneNumber(iLandZoneRef), nil, iLandZoneSegmentSize - 0.1)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordMidpointAndOtherDataForZone(iPlateau, iZone, tLZData, tOptionalStartPositionsInZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordMidpointAndOtherDataForZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tAverage, iAveragePlateau, iAverageLandZone

    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Considering iPlateau='..iPlateau..'; iZone='..iZone..'; Is table of mex locations empty='..tostring(M28Utilities.IsTableEmpty(tLZData[subrefLZMexLocations]))) end
    local iMinX = 100000
    local iMaxX = 0
    local iMinZ = 100000
    local iMaxZ = 0
    local iBaseIslandWanted

    local iMinSegX = 100000
    local iMaxSegX = 0
    local iMinSegZ = 100000
    local iMaxSegZ = 0
    --First record min and max segX values for the LZ
    for iSegment, tSegmentXZ in tLZData[subrefLZSegments] do
        iMinSegX = math.min(iMinSegX, tSegmentXZ[1])
        iMinSegZ = math.min(iMinSegZ, tSegmentXZ[2])
        iMaxSegX = math.max(iMaxSegX, tSegmentXZ[1])
        iMaxSegZ = math.max(iMaxSegZ, tSegmentXZ[2])
    end
    tLZData[subrefLZMinSegX] = iMinSegX
    tLZData[subrefLZMinSegZ] = iMinSegZ
    tLZData[subrefLZMaxSegX] = iMaxSegX
    tLZData[subrefLZMaxSegZ] = iMaxSegZ
    if bDebugMessages == true then LOG(sFunctionRef..': Finished recording min and max segments for Plateau '..iPlateau..' with LZ='..iZone..'; tLZData[subrefLZMinSegX]='..(tLZData[subrefLZMinSegX] or 'nil')..'; tLZData[subrefLZMinSegZ]='..(tLZData[subrefLZMinSegZ] or 'nil')..'; tLZData[subrefLZMaxSegX]='..(tLZData[subrefLZMaxSegX] or 'nil')..'; tLZData[subrefLZMaxSegZ]='..(tLZData[subrefLZMaxSegZ] or 'nil')) end


    if M28Utilities.IsTableEmpty(tLZData[subrefLZMexLocations]) == false then
        for iMex, tMex in tLZData[subrefLZMexLocations] do
            --Get min and max values for midpoint:
            iMinX = math.min(tMex[1], iMinX)
            iMaxX = math.max(tMex[1], iMaxX)
            iMinZ = math.min(tMex[3], iMinZ)
            iMaxZ = math.max(tMex[3], iMaxZ)
            if not(iBaseIslandWanted) then iBaseIslandWanted = NavUtils.GetTerrainLabel(refPathingTypeLand, tMex) end
            --Record if can build on it:
            if bDebugMessages == true then LOG(sFunctionRef..': About to check if can build on iMex='..iMex..'; tMex='..repru(tMex)..'; can we build on it='..tostring(M28Conditions.CanBuildOnMexLocation(tMex))..'; aiBrain check whether can build using brain '..(M28Overseer.tAllActiveM28Brains[1].Nickname or 'nil')..'='..tostring(M28Overseer.tAllActiveM28Brains[1]:CanBuildStructureAt('urb1103', tMex))..'; Result of is resource blocked='..tostring(M28Conditions.IsResourceBlockedByResourceBuilding(M28UnitInfo.refCategoryMex, 'urb1103', tMex))) end
            if M28Conditions.CanBuildOnMexLocation(tMex) then
                table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefMexUnbuiltLocations], tMex)
            else
                --DOuble-check - if there are no buildings in a rectangle around the mex then treat it as buildable (note - havent tested the below as added when thought were failing to record mexes on a map but it turned out to be another unrelated issue)
                local rRect = M28Utilities.GetRectAroundLocation(tMex, 0.9)
                local tUnitsByMex = GetUnitsInRect(rRect)
                local bNearbyMex = false
                if M28Utilities.IsTableEmpty(tUnitsByMex) == false then
                    local tBuildingsNearby = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tUnitsByMex)
                    if M28Utilities.IsTableEmpty(tBuildingsNearby) == false then
                        bNearbyMex = true
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Backup logic, is tUnitsByMex empty='..tostring(M28Utilities.IsTableEmpty(tUnitsByMex))..'; bNearbyMex ='..tostring(bNearbyMex)) end
                if not(bNearbyMex) then
                    table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefMexUnbuiltLocations], tMex)
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Size of mex locations for LZ='..table.getn(tLZData[subrefLZMexLocations])..'; Size of unbuilt locations='..table.getn(tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefMexUnbuiltLocations])) end
    else
        --No mexes for the plateau, so cycle through every zone and record the lowest and largest X and Z values

        --for iSegment, tSegmentXZ in tLZData[subrefLZSegments] do
        --tCurPosition = GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
        local tMinPosition = GetPositionFromPathingSegments(tLZData[subrefLZMinSegX], tLZData[subrefLZMinSegZ])
        local tMaxPosition = GetPositionFromPathingSegments(tLZData[subrefLZMaxSegX], tLZData[subrefLZMaxSegZ])
        iMinX = tMinPosition[1]
        iMinZ = tMinPosition[3]
        iMaxX = tMaxPosition[1]
        iMaxZ = tMaxPosition[3]
        for iSegment, tSegmentXZ in tLZData[subrefLZSegments] do
            if not(iBaseIslandWanted) then iBaseIslandWanted = NavUtils.GetTerrainLabel(refPathingTypeLand, GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])) end
            break
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Min and max position: iMinX='..iMinX..'; iMaxX='..iMaxX..'; iMinZ='..iMinZ..'; iMaxZ='..iMaxZ) end
    end
    local bUseStartPosition = false
    if tOptionalStartPositionsInZone then
        tAverage = M28Utilities.GetAverageOfLocations(tOptionalStartPositionsInZone)
        if iPlateau == NavUtils.GetTerrainLabel(refPathingTypeHover, tAverage) and iBaseIslandWanted == NavUtils.GetTerrainLabel(refPathingTypeLand, tAverage) then
            local iStartSegmentX, iStartSegmentZ = GetPathingSegmentFromPosition(tAverage)
            if tLandZoneBySegment[iStartSegmentX][iStartSegmentZ] == iZone then
                bUseStartPosition = true
                if bDebugMessages == true then M28Utilities.DrawLocation(tAverage) end
            end
        end
    end
    if not(bUseStartPosition) then
        tAverage = {(iMinX + iMaxX)*0.5, 0, (iMinZ + iMaxZ) * 0.5}
    end
    iAveragePlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, tAverage)
    local iAverageIsland
    iAverageIsland = NavUtils.GetTerrainLabel(refPathingTypeLand, tAverage)


    --Move the midpoint if nav utils doesnt work for this position (to reduce the amount of grief we might have later)
    if bDebugMessages == true then LOG(sFunctionRef..': iAveragePlateau='..(iAveragePlateau or 'nil')..'; iPlateau='..iPlateau..'; iAverageIsland='..(iAverageIsland or 'nil')..'; iBaseIslandWanted='..(iBaseIslandWanted or 'nil')) end
    if not(iAveragePlateau == iPlateau) or not(iAverageIsland == iBaseIslandWanted) then
        local iStartSegmentX, iStartSegmentZ = GetPathingSegmentFromPosition(tAverage)
        local tAltMidpoint
        local iAdjustedSegmentX, iAdjustedSegmentZ
        local bHaveValidAltMidpoint = false
        for iAdjust = 1, 50 do
            for iXAdjust = -1, 1, 1 do
                for iZAdjust = -1, 1, 1 do
                    if not(iXAdjust == 0 and iZAdjust == 0) then
                        iAdjustedSegmentX = iStartSegmentX + iAdjust * iXAdjust
                        iAdjustedSegmentZ = iStartSegmentZ + iAdjust * iZAdjust
                        iAverageLandZone = tLandZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ]
                        if iAverageLandZone == iZone then
                            tAltMidpoint = GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering adjusted segment X-Z='..iAdjustedSegmentX..'-'..iAdjustedSegmentZ..'; with land zone '..tLandZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ]..'; tAltMidpoint='..repru(tAltMidpoint)..'; Plateau from navutils='..(NavUtils.GetTerrainLabel(refPathingTypeHover, tAltMidpoint) or 'nil')..'; Island from navutils='..(NavUtils.GetTerrainLabel(refPathingTypeLand, tAltMidpoint) or 'nil')) end
                            if NavUtils.GetTerrainLabel(refPathingTypeHover, tAltMidpoint) == iPlateau and NavUtils.GetTerrainLabel(refPathingTypeLand, tAltMidpoint) == iBaseIslandWanted then
                                bHaveValidAltMidpoint = true
                                iAveragePlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, tAltMidpoint)
                                iAverageIsland = NavUtils.GetTerrainLabel(refPathingTypeLand, tAltMidpoint)
                                tAverage = {tAltMidpoint[1], GetSurfaceHeight(tAltMidpoint[1], tAltMidpoint[3]), tAltMidpoint[3]}
                                if bDebugMessages == true then LOG(sFunctionRef..': Have valid alternative midpoint which will now record and use, tAverage after update='..repru(tAverage)..'; iAverageIsland='..(iAverageIsland or 'nil')) end
                                break
                            end
                        elseif bDebugMessages == true then
                            LOG(sFunctionRef..': Adjusted semgnet X-Z='..iAdjustedSegmentX..'-'..iAdjustedSegmentZ..'; didnt have the right land zone, was '..(tLandZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ] or 'nil')..'; will draw segment midpoint in red if its in playaable area')
                            local tAltLocation = GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)
                            if tAltLocation and tAltLocation[1] > rMapPotentialPlayableArea[1] and tAltLocation[1] < rMapPotentialPlayableArea[3] and tAltLocation[3] > rMapPotentialPlayableArea[2] and tAltLocation[3] < rMapPotentialPlayableArea[4] then
                                M28Utilities.DrawLocation(tAltLocation, 2)
                            end
                        end
                    end
                end
                if bHaveValidAltMidpoint then break end
            end
            if bHaveValidAltMidpoint then break end
        end

        --If still dont have a valid location, then just try any segment recorded in the land zone (this wont be in the middle of the land zone, but is better than having an unpathable midpoint)
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveValidAltMidpoint='..tostring(bHaveValidAltMidpoint)) end
        if not(bHaveValidAltMidpoint) then
            for iSegment, tSegmentXZ in tLZData[subrefLZSegments] do
                if tLandZoneBySegment[tSegmentXZ[1]][tSegmentXZ[2]] == iZone then
                    tAltMidpoint = GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
                    if bDebugMessages == true then LOG(sFunctionRef..': Cycling through recorded segments for this LZ, and considering segment X-Z='..tSegmentXZ[1]..'-'..tSegmentXZ[2]..'; with land zone '..tLandZoneBySegment[tSegmentXZ[1]][tSegmentXZ[2]]..'; tAltMidpoint='..repru(tAltMidpoint)..'; Plateau from navutils='..(NavUtils.GetTerrainLabel(refPathingTypeHover, tAltMidpoint) or 'nil')..'; Island from navutils='..(NavUtils.GetTerrainLabel(refPathingTypeLand, tAltMidpoint) or 'nil')) end
                    if NavUtils.GetTerrainLabel(refPathingTypeHover, tAltMidpoint) == iPlateau and NavUtils.GetTerrainLabel(refPathingTypeLand, tAltMidpoint) == iBaseIslandWanted then
                        bHaveValidAltMidpoint = true
                        iAveragePlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, tAltMidpoint)
                        iAverageIsland = NavUtils.GetTerrainLabel(refPathingTypeLand, tAltMidpoint)
                        tAverage = {tAltMidpoint[1], tAltMidpoint[2], tAltMidpoint[3]}
                        if bDebugMessages == true then LOG(sFunctionRef..': Have valid alternative midpoint which will now record and use, tAverage after update='..repru(tAverage)) end
                        break
                    end
                end
            end
        end
    end

    --Further alternative/backup (hopefully will never need to use this - this was the old backup which didnt work very well)
    if not(iAveragePlateau == iPlateau and iAverageLandZone == iZone) then
        iAveragePlateau, iAverageLandZone = GetPlateauAndLandZoneReferenceFromPosition(tAverage, false)
    end
    if (iAveragePlateau == iPlateau and iAverageLandZone == iZone) or M28Utilities.IsTableEmpty(tLZData[subrefLZMexLocations]) then
        --Either we have a valid location (in which case fine), or we have no mexes to use as a backup so will just use the midpoint (will cause some issues down the line though e.g. with the LZ not registering as being pathable to other land zones)
        tLZData[subrefMidpoint] = {tAverage[1], GetSurfaceHeight(tAverage[1], tAverage[3]), tAverage[3]}
    else
        --We have mexes so will just use one of these as the midpoint as a basic backup
        tLZData[subrefMidpoint] = {tLZData[subrefLZMexLocations][1][1], tLZData[subrefLZMexLocations][1][2], tLZData[subrefLZMexLocations][1][3]}
    end
    tLZData[refiMidpointAmphibiousLabel] = (NavUtils.GetTerrainLabel(refPathingTypeAmphibious, tLZData[subrefMidpoint]) or 0)
    if bDebugMessages == true then LOG(sFunctionRef..': Checking the midpoint is pathable by amphibious, tLZData[refiMidpointAmphibiousLabel]='..(tLZData[refiMidpointAmphibiousLabel] or 'nil')..'; Midpoint='..repru(tLZData[subrefMidpoint])) end
    if tLZData[refiMidpointAmphibiousLabel] == 0 then
        --Further redundancy - try and move the midpoint to a nearby segment to get a valid point - do by moving outwards in hollow boxes based on iAdjustBase
        local iBaseSegmentX, iBaseSegmentZ = GetPathingSegmentFromPosition(tLZData[subrefMidpoint])
        local iAdjustedSegmentX, iAdjustedSegmentZ
        local bHaveValidMidpoint
        for iAdjustBase = 1, 25 do
            for iAdjustedSegmentX = iBaseSegmentX - iAdjustBase, iBaseSegmentX + iAdjustBase, 1 do
                for iAdjustedSegmentZ = iBaseSegmentZ - iAdjustBase, iBaseSegmentZ + iAdjustBase, iAdjustBase * 2 do
                    if tLandZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ] == iZone and (NavUtils.GetTerrainLabel(refPathingTypeAmphibious, GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)) or 0) > 0 then
                        bHaveValidMidpoint = true
                        local tNewMidpoint = GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)
                        tLZData[subrefMidpoint] = {tNewMidpoint[1], tNewMidpoint[2], tNewMidpoint[3]}
                        break
                    end
                end
                if  bHaveValidMidpoint then break end
            end
            if bHaveValidMidpoint then break end
            --Then do the left and right row (excl corners which ahve already done per the above)
            for iAdjustedSegmentX = iBaseSegmentX - iAdjustBase, iBaseSegmentX + iAdjustBase, iAdjustBase * 2 do
                for iAdjustedSegmentZ = iBaseSegmentZ - iAdjustBase + 1, iBaseSegmentZ + iAdjustBase - 1, 1 do
                    if tLandZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ] == iZone and (NavUtils.GetTerrainLabel(refPathingTypeAmphibious, GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)) or 0) > 0 then
                        bHaveValidMidpoint = true
                        local tNewMidpoint = GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)
                        tLZData[subrefMidpoint] = {tNewMidpoint[1], tNewMidpoint[2], tNewMidpoint[3]}
                        break
                    end
                end
                if bHaveValidMidpoint then break end
            end
            if bHaveValidMidpoint then break end
        end
        if not(bHaveValidMidpoint) then
            --Try the first segment
            local iAdjustedSegmentX, iAdjustedSegmentZ
            for iEntry, tSegmentsXZ in tLZData[subrefLZSegments] do
                iAdjustedSegmentX = tSegmentsXZ[1]
                iAdjustedSegmentZ = tSegmentsXZ[2]
                if (NavUtils.GetTerrainLabel(refPathingTypeAmphibious, GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)) or 0) > 0 then
                    bHaveValidMidpoint = true
                    local tNewMidpoint = GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)
                    tLZData[subrefMidpoint] = {tNewMidpoint[1], tNewMidpoint[2], tNewMidpoint[3]}
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished trying to adjust midpoint to amphibious pathable location, bHaveValidMidpoint='..tostring(bHaveValidMidpoint or false)..'; tLZData[subrefMidpoint]='..repru(tLZData[subrefMidpoint])) end
    end

    if bDebugMessages == true then
        local iColour = iPlateau
        while iColour > 8 do
            iColour = iColour - 8
        end
        M28Utilities.DrawRectangle(Rect(iMinX, iMinZ, iMaxX, iMaxZ), iColour, 1000, 10)
        if iColour <= 1 then iColour = 8 end
        M28Utilities.DrawLocation(tLZData[subrefMidpoint], iColour, 1000)
        if bDebugMessages == true then LOG(sFunctionRef..': Midpoint after adjustment for iPlateau='..iPlateau..' and zone='..iZone..' = '..repru(tLZData[subrefMidpoint])..'; iBaseIslandWanted='..(iBaseIslandWanted or 'nil')..'; NavUtils result for label='..(NavUtils.GetLabel(refPathingTypeAmphibious, tLZData[subrefMidpoint]) or 'nil')..'; Land terrain label for midpoint='..(NavUtils.GetLabel(refPathingTypeLand, tLZData[subrefMidpoint]) or 'nil')) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function RecordLandZoneMidpointAndUnbuiltMexes()
    --Run at the start of the game - Cycles through each land zone, and calculates the average positio nof the mexes.  If this is in the asme land zone then records this as the midpoint, toehrwise records the first mex as the midpoint
    --Also records which mexes can be built on initially
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordLandZoneMidpointAndUnbuiltMexes'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tiStartPointsByPlateauAndZone = {}
    local iCurPlateau, iCurLandZone
    for iEntry, tStart in PlayerStartPoints do
        iCurPlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, tStart)
        if iCurPlateau then
            if not(tiStartPointsByPlateauAndZone[iCurPlateau]) then tiStartPointsByPlateauAndZone[iCurPlateau] = {} end
            local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tStart)
            iCurLandZone = tLandZoneBySegment[iSegmentX][iSegmentZ]
            if iCurLandZone then
                if not(tiStartPointsByPlateauAndZone[iCurPlateau][iCurLandZone]) then tiStartPointsByPlateauAndZone[iCurPlateau][iCurLandZone] = {} end
                table.insert(tiStartPointsByPlateauAndZone[iCurPlateau][iCurLandZone], {tStart[1], tStart[2], tStart[3]})
            end
        end
    end
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        if bDebugMessages == true then LOG(sFunctionRef..': About to record the midpoint and other data for land zones in plateau '..iPlateau) end
        for iZone, tLZData in tAllPlateaus[iPlateau][subrefPlateauLandZones] do
            RecordMidpointAndOtherDataForZone(iPlateau, iZone, tLZData, tiStartPointsByPlateauAndZone[iPlateau][iZone])
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordHydroInLandZone(tHydro, iPlateau, iLandZone, bNearStartPosition)
    if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefHydroLocations]) then tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefHydroLocations] = {} end
    table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefHydroLocations], tHydro)
    if M28Conditions.CanBuildOnHydroLocation(tHydro) then
        table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefHydroUnbuiltLocations], tHydro)
    end
    if bNearStartPosition then
        table.insert(tHydroNearStart, tHydro)
        local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tHydro)
        RecordSegmentLandZone(iSegmentX, iSegmentZ, iPlateau, iLandZone)
    end
end

local function RecordAllHydroInLandZones()
    --Updates land zone data to include details of any hydro locations in the land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAllHydroInLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(tHydroPoints) == false then
        local iPlateau, iLandZone
        local bAlreadyRecorded = false

        for iHydro, tHydro in tHydroPoints do
            iPlateau, iLandZone = GetPlateauAndLandZoneReferenceFromPosition(tHydro)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iHydro='..iHydro..'; tHydro='..repru(tHydro)..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
            if iLandZone > 0 then
                --Check not already recorded
                bAlreadyRecorded = false
                if M28Utilities.IsTableEmpty(tHydroNearStart) == false then
                    for iRecorded, tRecorded in tHydroNearStart do
                        if M28Utilities.GetRoughDistanceBetweenPositions(tRecorded, tHydro) <= 1 then
                            bAlreadyRecorded = true
                            break
                        end
                    end
                end
                if not(bAlreadyRecorded) then


                    if bDebugMessages == true then LOG(sFunctionRef..': Have a hydro location, CanBuildOnHydro='..tostring(M28Conditions.CanBuildOnHydroLocation(tHydro))) end
                    RecordHydroInLandZone(tHydro, iPlateau, iLandZone, false)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function RecordHydroInWaterZones()
    --Updates land zone data to include details of any hydro locations in the land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordHydroInWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(tHydroPoints) == false then
        local iWaterZone
        local bAlreadyRecorded

        for iHydro, tHydro in tHydroPoints do
            iWaterZone = GetWaterZoneFromPosition(tHydro)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iHydro='..iHydro..'; tHydro='..repru(tHydro)..'; iWaterZone='..(iWaterZone or 'nil')) end
            if iWaterZone > 0 then
                --Check not already recorded
                bAlreadyRecorded = false
                if M28Utilities.IsTableEmpty(tHydroNearStart) == false then
                    for iRecorded, tRecorded in tHydroNearStart do
                        if M28Utilities.GetRoughDistanceBetweenPositions(tRecorded, tHydro) <= 1 then
                            bAlreadyRecorded = true
                            break
                        end
                    end
                end
                if not(bAlreadyRecorded) then

                    if bDebugMessages == true then LOG(sFunctionRef..': Have a hydro location, CanBuildOnHydro='..tostring(M28Conditions.CanBuildOnHydroLocation(tHydro))) end
                    if not(tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone][subrefHydroLocations]) then tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone][subrefHydroLocations] = {} end
                    table.insert(tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone][subrefHydroLocations], tHydro)
                    if M28Conditions.CanBuildOnHydroLocation(tHydro) then
                        if not(tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone][subrefHydroUnbuiltLocations]) then tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone][subrefHydroUnbuiltLocations] = {} end
                        table.insert(tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone][subrefHydroUnbuiltLocations], tHydro)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordAdjacentLandZones()
    --Cycles through each land zone and identifies adjacent land zones
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAdjacentLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tiSegmentAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}}
    local tiBorderSegmentAdjust = {}
    local iMaxAdjacencyToConsider = 1
    if iMapSize <= 1024 then
        iMaxAdjacencyToConsider = 2
        if iMapSize <= 512 then
            iMaxAdjacencyToConsider = 3
            if iMapSize <= 256 then iMaxAdjacencyToConsider = 5 end
        end
    end
    if iMaxAdjacencyToConsider > 1 then
        for iMaxAdjacencyToConsider = 2, iMaxAdjacencyToConsider do
            for iX = -iMaxAdjacencyToConsider, iMaxAdjacencyToConsider, iMaxAdjacencyToConsider do
                for iZ = -iMaxAdjacencyToConsider, iMaxAdjacencyToConsider, iMaxAdjacencyToConsider do
                    if not(iX == 0 and iZ == 0) then
                        table.insert(tiBorderSegmentAdjust, {iX, iZ})
                    end
                end
            end
        end
    end


    local iAltLandZone
    local iAltSegX, iAltSegZ
    local tRecordedAdjacentZones
    local iIslandRefWanted
    local bHaveBorderSegment

    function ConsiderAdjustmentSegment(iPlateau, iLandZone, iAltSegX, iAltSegZ)

        iAltLandZone = tLandZoneBySegment[iAltSegX][iAltSegZ]
        if iAltLandZone and not(iAltLandZone == iLandZone) then
            bHaveBorderSegment = true
            if not(tRecordedAdjacentZones[iAltLandZone]) then

                if bDebugMessages == true then LOG(sFunctionRef..': Consideing iAltSegX'..iAltSegX..'Z'..iAltSegZ..'; iAltLandZone='..iAltLandZone..'; Hover terrain label='..(NavUtils.GetTerrainLabel(refPathingTypeHover, GetPositionFromPathingSegments(iAltSegX, iAltSegZ)) or 'nil')..'; iPlateau for base seg='..iPlateau) end
                if NavUtils.GetTerrainLabel(refPathingTypeHover, GetPositionFromPathingSegments(iAltSegX, iAltSegZ)) == iPlateau then
                    --We should have the same plateau, but double-check - do we have a land zone recorded?
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAltLandZone='..iAltLandZone..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Is alt land zone for this plateau nil='..tostring(tAllPlateaus[iPlateau][subrefPlateauLandZones][iAltLandZone] == nil)) end
                    if tAllPlateaus[iPlateau][subrefPlateauLandZones][iAltLandZone] then
                        tRecordedAdjacentZones[iAltLandZone] = true
                        --Only actually record this as an adjacent land zone if the land pathing label is the same
                        if NavUtils.GetLabel(refPathingTypeLand, tAllPlateaus[iPlateau][subrefPlateauLandZones][iAltLandZone][subrefMidpoint]) == iIslandRefWanted then
                            local tLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
                            table.insert(tLZData[subrefLZAdjacentLandZones], iAltLandZone)
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering land zone '..iLandZone..' and if the adjacent segment X'..iAltSegX..'Z'..iAltSegZ..' is in another land zone '..iAltLandZone..'; will record as being adjacent and draw the adjcent segment in blue')
                                M28Utilities.DrawLocation(GetPositionFromPathingSegments(iAltSegX, iAltSegZ))
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Different island refs for iLandZone='..iLandZone..' and iAltLandZone='..iAltLandZone..' so wont record as being adjacent') end
                        end
                    end
                end
            end
        end
    end

    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLZData in tPlateauSubtable[subrefPlateauLandZones] do
            tLZData[subrefLZAdjacentLandZones] = {}
            tRecordedAdjacentZones = {}
            iIslandRefWanted = NavUtils.GetLabel(refPathingTypeLand, tLZData[subrefMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through every segment in land zone '..iLandZone..' to look for adjacent land zones, segment count='..( tLZData[subrefLZTotalSegmentCount] or 'nil')..'; iIslandRefWanted='..iIslandRefWanted) end
            for iSegmentRef, tSegmentXZ in tLZData[subrefLZSegments] do
                bHaveBorderSegment = false
                for iSegAdjust, tSegAdjXZ in tiSegmentAdjust do
                    ConsiderAdjustmentSegment(iPlateau, iLandZone, tSegmentXZ[1] + tSegAdjXZ[1], tSegmentXZ[2] + tSegAdjXZ[2])
                end
                if bHaveBorderSegment and iMaxAdjacencyToConsider > 1 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Think we have a border segment, X'..tSegmentXZ[1]..'Z'..tSegmentXZ[2]..'; will now consider further away segments inbordersegmentadjust, iMaxAdjacencyToConsider='..iMaxAdjacencyToConsider) end
                    for iSegAdjust, tSegAdjXZ in tiBorderSegmentAdjust do
                        ConsiderAdjustmentSegment(iPlateau, iLandZone, tSegmentXZ[1] + tSegAdjXZ[1], tSegmentXZ[2] + tSegAdjXZ[2])
                    end
                end
            end


            if bDebugMessages == true then
                LOG(sFunctionRef..': Finished considering Plateau '..iPlateau..' LZ '..iLandZone..': subrefLZAdjacentLandZones='..repru(tLZData[subrefLZAdjacentLandZones]))
                local iColour = 1
                DrawSpecificLandZone(iPlateau, iLandZone, iColour)
                if M28Utilities.IsTableEmpty(tLZData[subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZData[subrefLZAdjacentLandZones] do
                        iColour = iColour + 1
                        if iColour > 8 then iColour = 2 end
                        DrawSpecificLandZone(iPlateau, iAdjLZ, iColour)
                    end
                end

            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordAdjacentWaterZones()
    --Cycles through each water zone and identifies adjacent water zones
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAdjacentWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tiSegmentAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}}
    local iAltWaterZone
    local iAltSegX, iAltSegZ
    local tRecordedAdjacentZones
    for iPond, tPondSubtable in tPondDetails do
        for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
            tWZData[subrefWZAdjacentWaterZones] = {}
            tRecordedAdjacentZones = {}
            for iSegmentRef, tSegmentXZ in tWZData[subrefWZSegments] do
                for iSegAdjust, tSegAdjXZ in tiSegmentAdjust do
                    iAltSegX = tSegmentXZ[1] + tSegAdjXZ[1]
                    iAltSegZ = tSegmentXZ[2] + tSegAdjXZ[2]
                    iAltWaterZone = tWaterZoneBySegment[iAltSegX][iAltSegZ]
                    if iAltWaterZone and not(iAltWaterZone == iWaterZone) and not(tRecordedAdjacentZones[iAltWaterZone]) then
                        if tiPondByWaterZone[iAltWaterZone] == iPond then
                            tRecordedAdjacentZones[iAltWaterZone] = true
                            table.insert(tWZData[subrefWZAdjacentWaterZones], iAltWaterZone)
                            if bDebugMessages == true then LOG(sFunctionRef..': iAltWaterZone='..iAltWaterZone..' which is in iPond='..(tiPondByWaterZone[iAltWaterZone] or 'nil')..'; iPond='..(iPond or 'nil')..' so will record it as adjacent') end
                        end
                    end
                end
            end

            if bDebugMessages == true then
                LOG(sFunctionRef..': Finished considering Pond '..iPond..' WZ '..iWaterZone..': subrefWZAdjacentLandZones='..repru(tWZData[subrefWZAdjacentWaterZones]))
                local iColour = 1
                DrawSpecificWaterZone(iWaterZone, iColour)
                if M28Utilities.IsTableEmpty(tWZData[subrefWZAdjacentWaterZones]) == false then
                    for _, iAdjWZ in tWZData[subrefWZAdjacentWaterZones] do
                        iColour = iColour + 1
                        if iColour > 8 then iColour = 2 end
                        DrawSpecificWaterZone(iAdjWZ, iColour)
                    end
                end

            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iPlateau, iStartLandZone, iTargetLandZone, tStart, bWillUpdateLZEntryRefLater)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderAddingTargetLandZoneToDistanceFromBaseTable'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --Have we not already considered this?
    if not(tbTempConsideredLandPathingForLZ[iPlateau][iStartLandZone][iTargetLandZone]) then
        local tEnd = tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefMidpoint]
        local tFullPath, iPathSize, iDistance = NavUtils.PathTo(refPathingTypeLand, tStart, tEnd, nil)
        if bDebugMessages == true then LOG(sFunctionRef..': Have just tried to get land path from tStart='..repru(tStart)..' to tEnd='..repru(tEnd)..'; iStartLandZone='..iStartLandZone..'; iTargetLandZone='..iTargetLandZone..'; tFullPath='..repru(tFullPath)..'; iPathSize='..iPathSize..'; will draw midpoint of the target LZ, and draw the start point, in blue, iDistance='..iDistance..'; straight line dist='..M28Utilities.GetDistanceBetweenPositions(tStart, tEnd))
            M28Utilities.DrawLocation(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefMidpoint])
            M28Utilities.DrawLocation(tStart)
        end

        if tFullPath then
            local iPathingPlateau, iPathingLandZone
            local tPathingLZConsidered = {}
            local tPathingLZFromStartToTarget = {}


            local iTravelDistance = 0
            tFullPath[0] = tStart
            tFullPath[iPathSize + 1] = tEnd
            for iPath = 1, iPathSize + 1 do
                iTravelDistance = iTravelDistance + VDist2(tFullPath[iPath - 1][1], tFullPath[iPath - 1][3], tFullPath[iPath][1], tFullPath[iPath][3])
                iPathingPlateau, iPathingLandZone = GetPlateauAndLandZoneReferenceFromPosition(tFullPath[iPath])
                if iPathingLandZone > 0 then
                    if not(tPathingLZConsidered[iPathingLandZone]) and not(iStartLandZone == iPathingLandZone) then
                        tPathingLZConsidered[iPathingLandZone] = true
                        table.insert(tPathingLZFromStartToTarget, iPathingLandZone)
                    end
                end
            end
            if not(tPathingLZConsidered[iTargetLandZone]) then
                table.insert(tPathingLZFromStartToTarget, iPathingLandZone)
                tPathingLZConsidered[iTargetLandZone] = true
            end
            --Record the travel distance
            if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZTravelDistToOtherLandZones][iPlateau]) then tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZTravelDistToOtherLandZones][iPlateau] = {} end
            tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZTravelDistToOtherLandZones][iPlateau][iStartLandZone] = iTravelDistance
            if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZTravelDistToOtherLandZones][iPlateau]) then tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZTravelDistToOtherLandZones][iPlateau] = {} end
            tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZTravelDistToOtherLandZones][iPlateau][iTargetLandZone] = iTravelDistance

            if bDebugMessages == true then
                LOG(sFunctionRef..': Travel distance to iTargetLandZone '..iTargetLandZone..' from '..iStartLandZone..' = '..iTravelDistance..'; tPathingLZConsidered='..repru(tPathingLZConsidered)..'; will draw path between LZs')
                M28Utilities.DrawPath(tFullPath, 1)
            end

            --Get position in new table
            local iPosition = 1
            if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones]) then
                tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones] = {}
                tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLZEntryRef] = {}
                iPosition = 1
            else
                for iExistingLandZone, tExistingSubtable in tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones] do
                    if tExistingSubtable[subrefLZTravelDist] <  iTravelDistance then
                        iPosition = iPosition + 1
                    else
                        break
                    end
                end
            end

            local iOppositePosition = 1
            if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones]) then
                tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones] = {}
                tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLZEntryRef] = {}
                iOppositePosition = 1
            else
                for iExistingLandZone, tExistingSubtable in tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones] do
                    if tExistingSubtable[subrefLZTravelDist] <  iTravelDistance then
                        iOppositePosition = iOppositePosition + 1
                    else
                        break
                    end
                end
            end

            table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones], iPosition, {[subrefLZNumber] = iTargetLandZone, [subrefLZPath] = {}, [subrefLZTravelDist] = iTravelDistance})
            table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones], iOppositePosition, {[subrefLZNumber] = iStartLandZone, [subrefLZPath] = {}, [subrefLZTravelDist] = iTravelDistance})

            --Will update subrefLZPathingToOtherLZEntryRef in UpdateLZPathingEntryReferences, as we need to do this for iOppositePositon once we have finished adding all oppositepositions or it will end up out of order

            --Record the land zone path from start to target
            for iEntry, iLZ in tPathingLZFromStartToTarget do
                table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones][iPosition][subrefLZPath], iLZ)
            end
            --Record the land zone path from target to start (adding in the start as the final point)
            local iTotalEntries = table.getn(tPathingLZFromStartToTarget)
            for iEntry = iTotalEntries, 1, -1 do
                if not(tPathingLZFromStartToTarget[iEntry] == iTargetLandZone) then
                    table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones][iOppositePosition][subrefLZPath], tPathingLZFromStartToTarget[iEntry])
                end
            end
            if not(tPathingLZFromStartToTarget[1] == iStartLandZone) then
                table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones][iOppositePosition][subrefLZPath], iStartLandZone)
            end

            --Record that we have considered the pathing between these two points
            if not(tbTempConsideredLandPathingForLZ[iPlateau]) then tbTempConsideredLandPathingForLZ[iPlateau] = {} end
            if not(tbTempConsideredLandPathingForLZ[iPlateau][iStartLandZone]) then tbTempConsideredLandPathingForLZ[iPlateau][iStartLandZone] = {} end
            if not(tbTempConsideredLandPathingForLZ[iPlateau][iTargetLandZone]) then tbTempConsideredLandPathingForLZ[iPlateau][iTargetLandZone] = {} end
            tbTempConsideredLandPathingForLZ[iPlateau][iStartLandZone][iTargetLandZone] = true
            tbTempConsideredLandPathingForLZ[iPlateau][iTargetLandZone][iStartLandZone] = true

            if bDebugMessages == true then LOG(sFunctionRef..': Path for goign the opposite direction='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones][iOppositePosition][subrefLZPath])..'; path for going the normal direction='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones][iPosition][subrefLZPath])..'; iPosition='..iPosition..'; iOppositePosition='..iOppositePosition) end

        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finsihed recording for iPlateau='..iPlateau..'; iStartLandZone='..iStartLandZone..'; subrefLZPathingToOtherLandZones='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones])..'; will now do repru of the target land zone pathing to other land zones='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones])..'; bWillUpdateLZEntryRefLater='..tostring(bWillUpdateLZEntryRefLater or false)) end
        if not(bWillUpdateLZEntryRefLater) then
            UpdateLZPathingEntryReferences(iPlateau, iStartLandZone)
            UpdateLZPathingEntryReferences(iPlateau, iTargetLandZone)
            if bDebugMessages == true then LOG(sFunctionRef..': Have just finished updating pathing entry refs, iStartLandZone='..iStartLandZone..'; iTargetLandZone='..iTargetLandZone..'; subrefLZPathingToOtherLandZones for start='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLZEntryRef])..'; Same for target='..repru(repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLZEntryRef]))..'; repru of pathing to other zones for start zone='..repru(repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones]))) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function RecordMaxAdjacencyTravelDistance()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordMaxAdjacencyTravelDistance'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iMaxAdjacentDistance
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            if M28Utilities.IsTableEmpty(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZAdjacentLandZones]) == false then
                iMaxAdjacentDistance = 0
                for _, iAdjLZ in tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZAdjacentLandZones] do
                    iMaxAdjacentDistance = math.max(iMaxAdjacentDistance, (tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTravelDistToOtherLandZones][iPlateau][iAdjLZ] or 0))
                end

                tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZFurthestAdjacentLandZoneTravelDist] = iMaxAdjacentDistance
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateLZPathingEntryReferences(iPlateau, iLandZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateLZPathingEntryReferences'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local tLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
    if M28Utilities.IsTableEmpty(tLZData[subrefLZPathingToOtherLandZones]) == false then
        local iCurCount = 0
        for iEntry, tPathData in tLZData[subrefLZPathingToOtherLandZones] do
            iCurCount = iCurCount + 1
            tLZData[subrefLZPathingToOtherLZEntryRef][tPathData[subrefLZNumber]] = iCurCount
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code for iPlateau '..iPlateau..'; iLandZone '..iLandZone..'; Is table of pathing to other land zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[subrefLZPathingToOtherLandZones]))..'; Pathing entry ref repru='..repru(tLZData[subrefLZPathingToOtherLZEntryRef])..'; repru of pathing to other zones='..repru(tLZData[subrefLZPathingToOtherLandZones])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function RecordPathingBetweenZones()
    --For each zone that is where a player starts, record pathing to every other zone; for other zones, record pathing to up to 3 layers of adjacency
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordPathingBetweenZones'

    WaitTicks(1) --To ensure all brains will be setup
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    RecordLandZonePathingToOtherLandZonesInSamePlateau()
    for iCurPlateau, tPlateauSubtable in tAllPlateaus do
        --[[for iCurLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iCurLandZone='..iCurLandZone..' for plateau '..iCurPlateau..'; will go through every other LZ in the plateau and consider adding to the table of other land zones near this') end
            local tStartPoint = tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iCurLandZone][subrefMidpoint]
            for iTargetLandZone, tTargetLZInfo in tPlateauSubtable[subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Will consider iTargetLandZone='..iTargetLandZone..' for starting LZ '..iCurLandZone) end
                if not(iTargetLandZone == iCurLandZone) then
                    ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iCurPlateau, iCurLandZone, iTargetLandZone, tStartPoint, true)
                end
            end
        end--]]
        --Now record the entry refs
        local iCurCount
        for iCurLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            if bDebugMessages == true then LOG(sFunctionRef..': About to update LZ pathing entry references for iCurLandZone='..iCurLandZone..'; in iCurPlateau='..iCurPlateau) end
            UpdateLZPathingEntryReferences(iCurPlateau, iCurLandZone)
        end
    end
    --Record max adjacency distance
    RecordMaxAdjacencyTravelDistance()


    --[[
local tiPlateauLandZoneStartPoints = {}
local iCurPlateau, iCurLandZone
for iStart, tPlayerStart in PlayerStartPoints do
    iCurPlateau, iCurLandZone = GetPlateauAndLandZoneReferenceFromPosition(tPlayerStart)
    if (iCurLandZone or 0) > 0 then
        if not(tiPlateauLandZoneStartPoints[iCurPlateau]) then tiPlateauLandZoneStartPoints[iCurPlateau] = {} end
        tiPlateauLandZoneStartPoints[iCurPlateau][iCurLandZone] = true
        local tStartPoint = tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iCurLandZone][subrefMidpoint]

        --Consider all land zones in this plateau for start positions
        for iTargetLandZone, tTargetLandZoneInfo in tAllPlateaus[iCurPlateau][subrefPlateauLandZones] do
            if not(iTargetLandZone == iCurLandZone) then
                ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iCurPlateau, iCurLandZone, iTargetLandZone, tStartPoint)
            end
        end
    end
end

--Consider adjacent locations for non-core
for iCurPlateau, tPlateauSubtable in tAllPlateaus do
    for iCurLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
        if not(tiPlateauLandZoneStartPoints[iCurPlateau][iCurLandZone]) then
            local tiAdjacentLandZonesToConsider = {}
            if M28Utilities.IsTableEmpty(tLandZoneInfo[subrefLZAdjacentLandZones]) == false then
                for _, iAdjLZ1 in tLandZoneInfo[subrefLZAdjacentLandZones] do
                    if M28Utilities.IsTableEmpty(tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iAdjLZ1][subrefLZAdjacentLandZones]) == false then
                        for _, iAdjLZ2 in tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iAdjLZ1][subrefLZAdjacentLandZones] do
                            if M28Utilities.IsTableEmpty(tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iAdjLZ2][subrefLZAdjacentLandZones]) == false then
                                for _, iAdjLZ3 in tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iAdjLZ2][subrefLZAdjacentLandZones] do
                                    if not(tiAdjacentLandZonesToConsider[iAdjLZ3]) then tiAdjacentLandZonesToConsider[iAdjLZ3] = true end
                                end
                            end
                            if not(tiAdjacentLandZonesToConsider[iAdjLZ2]) then tiAdjacentLandZonesToConsider[iAdjLZ2] = true end
                        end
                    end
                    if not(tiAdjacentLandZonesToConsider[iAdjLZ1]) then tiAdjacentLandZonesToConsider[iAdjLZ1] = true end
                end
                local tStartPoint = tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iCurLandZone][subrefMidpoint]
                for iAdjLandZone, _ in tiAdjacentLandZonesToConsider do
                    if not(iAdjLandZone == iCurLandZone) then
                        ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iCurPlateau, iCurLandZone, iAdjLandZone, tStartPoint)
                    end
                end
            end
        end
    end
end--]]
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function RecordTravelDistBetweenZonesOverTime()
    --Record how  long it would take to travel between each other land zone upfront so dont have to calculate on the fly
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordTravelDistBetweenZonesOverTime'
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iCurCount = 0
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iStartLZ, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            if bDebugMessages == true then LOG(sFunctionRef..': About to consider all other land zones in plateau '..iPlateau..' for iStartLZ='..iStartLZ) end
            for iEndLZ,  tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iEndLZ='..iEndLZ) end
                if not(iStartLZ == iEndLZ) then
                    iCurCount = iCurCount + 1
                    if iCurCount >= 10 then
                        iCurCount = 0
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    end

                    GetTravelDistanceBetweenLandZones(iPlateau, iStartLZ, iEndLZ)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordClosestAllyAndEnemyBaseForEachLandZone(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordClosestAllyAndEnemyBaseForEachLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    while not(bMapLandSetupComplete) or not(bWaterZoneInitialCreation) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if GetGameTimeSeconds() >= 5 and ((bMapLandSetupComplete and (M28Utilities.bFAFActive or GetGameTimeSeconds() >= 6)) or GetGameTimeSeconds() >= 10) then
            M28Utilities.ErrorHandler('Have been waiting too long for map setup to complete')
            break
        end
    end

    local tEnemyBases = {}
    local tAllyBases = {}
    local tBrainsByIndex = {}
    if bDebugMessages == true then LOG(sFunctionRef..': About to record enemy brains in table of enemy bases, is table of enemy brains empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains]) == false then
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
            if not(oBrain.M28IsDefeated) then
                if bDebugMessages == true then LOG(sFunctionRef..': Recording enemy base for brain '..oBrain.Nickname..' with index='..oBrain:GetArmyIndex()..'; location='..repru(GetPlayerStartPosition(oBrain))..'; Island ref of the base='..(NavUtils.GetTerrainLabel(refPathingTypeLand, GetPlayerStartPosition(oBrain)) or 'nil')) end
                table.insert(tEnemyBases, GetPlayerStartPosition(oBrain))
                tBrainsByIndex[oBrain:GetArmyIndex()] = oBrain
            end
        end
    end

    function IsInPlayableArea(tLocation)
        if tLocation[1] >= rMapPlayableArea[1] and tLocation[1] <= rMapPlayableArea[3] and tLocation[2] >= rMapPlayableArea[2] and tLocation[4] <= rMapPlayableArea[4] then
            return true
        end
        return false
    end
    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
        if bDebugMessages == true then LOG(sFunctionRef..': Cycling through friedly active brains in iTeam='..iTeam..'; oBrain.Nickname='..(oBrain.Nickname or 'nil')..' with start position '..repru(PlayerStartPoints[oBrain:GetArmyIndex()])..'; bIsCampaignMap='..tostring(bIsCampaignMap)..'; Land result for brain start='..(NavUtils.GetTerrainLabel(refPathingTypeLand, PlayerStartPoints[oBrain:GetArmyIndex()]) or 'nil')..'; Brain type='..(oBrain.BrainType or 'nil')..'; Playable area='..repru(rMapPlayableArea)) end
        --Campaign specific - ignore any start positions other than M28 (prevoiusly would allow any on valid land zones, but led to too many issues due to poor placement of these in some campaign maps)
        --Old logic: if not(bIsCampaignMap) or not(oBrain.BrainType == "AI") or oBrain.M28AI or ((NavUtils.GetTerrainLabel(refPathingTypeLand, PlayerStartPoints[oBrain:GetArmyIndex()]) or 0) > 0 and IsInPlayableArea(PlayerStartPoints[oBrain:GetArmyIndex()])) then
        if not(bIsCampaignMap) or oBrain.M28AI then
            if not(oBrain.M28IsDefeated) then
                tAllyBases[oBrain:GetArmyIndex()] = GetPlayerStartPosition(oBrain)
                tBrainsByIndex[oBrain:GetArmyIndex()] = oBrain
            end
        end
    end

    if M28Utilities.IsTableEmpty(tEnemyBases) then
        if bDebugMessages == true then LOG(sFunctionRef..': Backup logic - will get the first active brain on the enemy team as the enmy base location') end
        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        if aiBrain then
            table.insert(tEnemyBases, GetPrimaryEnemyBaseLocation(aiBrain))
        end
    end

    local iCurBrainDist
    local iClosestBrainDist
    local iClosestBrainRef

    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLZData in tPlateauSubtable[subrefPlateauLandZones] do
            iClosestBrainDist = 100000
            for iBrain, tStartPoint in tAllyBases do
                iCurBrainDist = M28Utilities.GetDistanceBetweenPositions(tLZData[subrefMidpoint], tStartPoint)
                if iCurBrainDist < iClosestBrainDist then
                    iClosestBrainRef = iBrain
                    iClosestBrainDist = iCurBrainDist
                end
            end
            local tLZTeamData = tLZData[subrefLZTeamData][iTeam]
            tLZTeamData[reftClosestFriendlyBase] = {PlayerStartPoints[iClosestBrainRef][1], PlayerStartPoints[iClosestBrainRef][2], PlayerStartPoints[iClosestBrainRef][3]}
            tLZTeamData[reftiClosestFriendlyM28BrainIndex] = iClosestBrainRef
            tLZTeamData[reftClosestEnemyBase] = GetPrimaryEnemyBaseLocation(tBrainsByIndex[iClosestBrainRef])
            tLZTeamData[refiModDistancePercent] = GetModDistanceFromStart(tBrainsByIndex[iClosestBrainRef], tLZData[subrefMidpoint], false) /  math.max(1, GetModDistanceFromStart(tBrainsByIndex[iClosestBrainRef], tLZTeamData[reftClosestEnemyBase]))
            if bDebugMessages == true then LOG(sFunctionRef..': Have recorded closest enemy base for iPlateau '..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; tLZTeamData[reftClosestFriendlyBase]='..repru(tLZTeamData[reftClosestFriendlyBase])..'; repru(tLZTeamData[reftClosestEnemyBase])='..repru(tLZTeamData[reftClosestEnemyBase])..'; iClosestBrainRef='..iClosestBrainRef..'; tBrainsByIndex[iClosestBrainRef].Nickname='..tBrainsByIndex[iClosestBrainRef].Nickname..'; aiBrain[reftPrimaryEnemyBaseLocation] for this brain='..repru(tBrainsByIndex[iClosestBrainRef][reftPrimaryEnemyBaseLocation])..'; iClosestBrainDist='..iClosestBrainDist) end
        end
    end

    --Record any ally bases which are in 'eco/air' slots (no enemy that is closer to them than another ally)
    if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 then
        if M28Utilities.IsTableEmpty(tEnemyBases) == false then
            local iMaxDistToBaseWanted
            local iCurFriendlyDistToBase
            local bHaveCloserTeammate = false
            local bHaveDangerousEnemyBase = false
            for iBaseFriendlyBase, tBaseFriendlyBase in tAllyBases do
                if bDebugMessages == true then LOG(sFunctionRef..': About to check if we have any friendl ybases that are closer to every enemy base than this, iBaseFriendlyBase='..iBaseFriendlyBase..'; tBaseFriendlyBase='..repru(tBaseFriendlyBase)..'; Size of tEnemyBases='..table.getn(tEnemyBases)) end
                bHaveDangerousEnemyBase = false
                for iEntry, tEnemyBase in tEnemyBases do
                    bHaveCloserTeammate = false
                    iMaxDistToBaseWanted = M28Utilities.GetDistanceBetweenPositions(tEnemyBase, tBaseFriendlyBase) - 10
                    if bDebugMessages == true then LOG(sFunctionRef..': About to consider whether we have a friendly base protecting iBaseFriendlyBase '..iBaseFriendlyBase..' from the enemy base iEntry='..iEntry) end
                    for iFriendlyBase, tCurFriendlyBase in tAllyBases do
                        if not(iBaseFriendlyBase == iFriendlyBase) then
                            iCurFriendlyDistToBase = M28Utilities.GetDistanceBetweenPositions(tEnemyBase,  tCurFriendlyBase)
                            if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have a friendly brain closer to enemy than us for the enemy base with iEntry='..iEntry..', considering iFriendlyBase='..iFriendlyBase..'; iMaxDistToBaseWanted='..iMaxDistToBaseWanted..'; iCurFriendlyDistToBase='..iCurFriendlyDistToBase) end
                            if iCurFriendlyDistToBase <= iMaxDistToBaseWanted then
                                local iAngleDif = M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(tEnemyBase, tCurFriendlyBase), M28Utilities.GetAngleFromAToB(tEnemyBase, tBaseFriendlyBase))
                                if bDebugMessages == true then LOG(sFunctionRef..': Closer teammate dist='..iCurFriendlyDistToBase..'; Angle from enemy to cur teammate base='..M28Utilities.GetAngleFromAToB(tEnemyBase, tCurFriendlyBase)..'; Angle from enemy to base friendly base='..M28Utilities.GetAngleFromAToB(tEnemyBase, tBaseFriendlyBase)..'; iAngleDif='..iAngleDif..'; iMaxDistToBaseWanted - iCurFriendlyDistToBase='..(iMaxDistToBaseWanted - iCurFriendlyDistToBase)..'; iMaxDistToBaseWanted='..iMaxDistToBaseWanted..'; Angle from base friendl yto cur friendly='..M28Utilities.GetAngleFromAToB(tBaseFriendlyBase, tCurFriendlyBase)..'; Angle from base friendly to enemy='..M28Utilities.GetAngleFromAToB(tBaseFriendlyBase, tEnemyBase)..'; Dist from base friendly to cur firendly='..M28Utilities.GetDistanceBetweenPositions(tBaseFriendlyBase, tCurFriendlyBase)) end
                                if iAngleDif <= 50 and (iAngleDif <= 30 or (iMaxDistToBaseWanted - iCurFriendlyDistToBase >= math.max(100, iMaxDistToBaseWanted*0.25) and (iAngleDif <= 40 or iMaxDistToBaseWanted - iCurFriendlyDistToBase >= math.max(150, iMaxDistToBaseWanted*0.5)))) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': We have a closer teammate for this enemy base with iEntry='..iEntry) end
                                    if bDebugMessages == true and M28Utilities.GetDistanceBetweenPositions(tBaseFriendlyBase, {718.5, 25.416015625, 232.5}) <= 5 then
                                        --Draw line from enemy base to the friendly base
                                        ForkThread(M28Utilities.ForkedDrawLine,tEnemyBase, tCurFriendlyBase, 1)
                                        ForkThread(M28Utilities.ForkedDrawLine,tEnemyBase, tBaseFriendlyBase, 3)
                                    end
                                    bHaveCloserTeammate = true
                                    break
                                elseif bDebugMessages == true then LOG(sFunctionRef..': Angle dif not sufficient to treat as a safe base')
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finishing considering enemy base iEntry'..iEntry..' for the friendly base iBaseFriendlyBase='..iBaseFriendlyBase..'; bHaveCloserTeammate='..tostring(bHaveCloserTeammate or false)) end
                    if not(bHaveCloserTeammate) then
                        if bDebugMessages == true then LOG(sFunctionRef..': We dont have a friendly base protecting us from this enemy so will abort loop') end
                        bHaveDangerousEnemyBase = true
                        break
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished cehcking if have closer teammate than us to each enemy base, iBaseFriendlyBase='..iBaseFriendlyBase..'; bHaveCloserTeammate='..tostring(bHaveCloserTeammate)..'; tBaseFriendlyBase='..repru(tBaseFriendlyBase)..'; iTeam='..(iTeam or 'nil')..'; bHaveDangerousEnemyBase='..tostring(bHaveDangerousEnemyBase or false)) end
                if bHaveCloserTeammate and not(bHaveDangerousEnemyBase) then
                    local tBaseLZOrWZData, tBaseLZOrWZTeamData = GetLandOrWaterZoneData(tBaseFriendlyBase, true, iTeam)
                    if tBaseLZOrWZData and not(tBaseLZOrWZTeamData) then
                        local iPlateauOrZero, iLandOrWaterZone = GetClosestPlateauOrZeroAndZoneToPosition(tBaseFriendlyBase)
                        if iPlateauOrZero == 0 then --we havent have called WaterZoneTeamInitialisation yet (as of v32)
                            if not(tBaseLZOrWZData[subrefWZTeamData]) then tBaseLZOrWZData[subrefWZTeamData] = {} end
                            if not(tBaseLZOrWZData[subrefWZTeamData][iTeam]) then tBaseLZOrWZData[subrefWZTeamData][iTeam] = {} end
                            tBaseLZOrWZTeamData = tBaseLZOrWZData[subrefWZTeamData][iTeam]
                        end
                    end
                    if bDebugMessages == true then
                        local iPlateauOrZero, iLandOrWaterZone = GetClosestPlateauOrZeroAndZoneToPosition(tBaseFriendlyBase)
                        LOG(sFunctionRef..': iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Is tBaseLZOrWZData empty='..tostring(M28Utilities.IsTableEmpty(tBaseLZOrWZData))..'; Is team data empty='..tostring(M28Utilities.IsTableEmpty(tBaseLZOrWZTeamData)))
                        if iPlateauOrZero == 0 then
                            LOG(sFunctionRef..': Pond='..(tiPondByWaterZone[iLandOrWaterZone] or 'nil'))
                        end
                    end
                    tBaseLZOrWZTeamData[refbBaseInSafePosition] = true
                end
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordClosestAllyAndEnemyBaseForEachWaterZone(iTeam, bDontInitializeWZLogic)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordClosestAllyAndEnemyBaseForEachWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --bDontInitializeWZLogic - set to true if we arent calling this at the start of the game but just want to update the closest ally and enemy base

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then

        while not(bWaterZoneInitialCreation) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if GetGameTimeSeconds() >= 5 and (M28Utilities.bFAFActive or GetGameTimeSeconds() >= 6) then
                M28Utilities.ErrorHandler('Have been waiting too long for map setup to complete')
                break
            end
        end

        local tEnemyBases = {}
        local tAllyBases = {}
        local tBrainsByIndex = {}

        local iCurBrainDist
        local iClosestBrainDist
        local iClosestBrainRef

        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains]) == false then
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
                if not(oBrain.M28IsDefeated) then
                    table.insert(tEnemyBases, GetPlayerStartPosition(oBrain))
                    tBrainsByIndex[oBrain:GetArmyIndex()] = oBrain
                end
            end
        end
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
            if bDebugMessages == true then LOG(sFunctionRef..': Cycling through friedly active brains in iTeam='..iTeam..'; oBrain.Nickname='..(oBrain.Nickname or 'nil')..' with start position '..repru(PlayerStartPoints[oBrain:GetArmyIndex()])..'; bIsCampaignMap='..tostring(bIsCampaignMap)..'; Navy result for brain start='..(NavUtils.GetTerrainLabel(refPathingTypeNavy, PlayerStartPoints[oBrain:GetArmyIndex()]) or 'nil')..'; Brain type='..(oBrain.BrainType or 'nil')..'; Playable area='..repru(rMapPlayableArea)) end
            --Campaign specific - check this is on a valid land zone
            if not(bIsCampaignMap) or not(oBrain.BrainType == "AI") or oBrain.M28AI or ((NavUtils.GetTerrainLabel(refPathingTypeNavy, GetPlayerStartPosition(oBrain)) or 0) > 0 and IsInPlayableArea(GetPlayerStartPosition(oBrain))) then
                if not(oBrain.M28IsDefeated) then
                    tAllyBases[oBrain:GetArmyIndex()] = GetPlayerStartPosition(oBrain)
                    tBrainsByIndex[oBrain:GetArmyIndex()] = oBrain
                end
            end
        end

        if M28Utilities.IsTableEmpty(tEnemyBases) then
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            if aiBrain then

                table.insert(tEnemyBases, GetPrimaryEnemyBaseLocation(aiBrain))
            end
        end

        --Update water zones
        if bDebugMessages == true then LOG(sFunctionRef..': About to start with updating water zone information, GameTime='..GetGameTimeSeconds()..'; bMapLandSetupComplete='..tostring(bMapLandSetupComplete or false)..'; bHaveConsideredPreferredPondForM28AI='..tostring(bHaveConsideredPreferredPondForM28AI or false)) end
        for iPond, tPondSubtable in tPondDetails do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iPond='..iPond) end
            for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
                if not(tWZData[subrefWZTeamData]) then tWZData[subrefWZTeamData] = {} end
                if not(tWZData[subrefWZTeamData][iTeam]) then tWZData[subrefWZTeamData][iTeam] = {} end
                local tWZTeamData = tWZData[subrefWZTeamData][iTeam]

                iClosestBrainDist = 100000
                for iBrain, tStartPoint in tAllyBases do
                    iCurBrainDist = M28Utilities.GetDistanceBetweenPositions(tWZData[subrefMidpoint], tStartPoint)
                    if iCurBrainDist < iClosestBrainDist then
                        iClosestBrainRef = iBrain
                        iClosestBrainDist = iCurBrainDist
                    end
                end

                tWZTeamData[reftClosestFriendlyBase] = {PlayerStartPoints[iClosestBrainRef][1], PlayerStartPoints[iClosestBrainRef][2], PlayerStartPoints[iClosestBrainRef][3]}
                tWZTeamData[reftiClosestFriendlyM28BrainIndex] = iClosestBrainRef
                if bDebugMessages == true then LOG(sFunctionRef..': Recorded closest friendly base '..repru(tWZTeamData[reftClosestFriendlyBase])..' for iWaterZone='..iWaterZone..'; iPond='..iPond) end
                tWZTeamData[reftClosestEnemyBase] = GetPrimaryEnemyBaseLocation(tBrainsByIndex[iClosestBrainRef])
                tWZTeamData[refiModDistancePercent] = GetModDistanceFromStart(tBrainsByIndex[iClosestBrainRef], tWZData[subrefMidpoint], false) / math.max(1, GetModDistanceFromStart(tBrainsByIndex[iClosestBrainRef], tWZTeamData[reftClosestEnemyBase]))

            end
        end
        if not(bDontInitializeWZLogic) then ForkThread(M28Team.WaterZoneTeamInitialisation, iTeam) end
    else
        M28Utilities.ErrorHandler('No M28 active brain')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ReturnNthValidLocationInSameLandZoneClosestToTarget(iPlateau, iLandZoneWanted, tStartLZData, tTargetDestination, iDistanceInterval, iNthEntryWanted, iMaxDistance)
    local iSearchDistance = 0
    local tValidLocations = {}
    local iValidLocationCount = 0
    local iAngleToTarget = M28Utilities.GetAngleFromAToB(tStartLZData[subrefMidpoint], tTargetDestination)
    local iFailureCount = 0 --After 5 failures in a row will abort
    local iCurPlateau, iCurLandZone
    if iDistanceInterval < 0 then M28Utilities.ErrorHandler('Likely infinite loop as have negative distance interval') end

    while iSearchDistance <= (iMaxDistance or 150) do
        iSearchDistance = iSearchDistance + iDistanceInterval
        local tPotentialLocation = M28Utilities.MoveInDirection(tStartLZData[subrefMidpoint], iAngleToTarget, iSearchDistance, true, false, false)
        iCurPlateau, iCurLandZone = GetPlateauAndLandZoneReferenceFromPosition(tPotentialLocation)
        if iCurPlateau == iPlateau and iCurLandZone == iLandZoneWanted then
            iValidLocationCount = iValidLocationCount + 1
            tValidLocations[iValidLocationCount] = {tPotentialLocation[1], tPotentialLocation[2], tPotentialLocation[3]}
            iFailureCount = 0
        else
            iFailureCount = iFailureCount + 1
            if iFailureCount >= 5 then break end
        end
    end
    if iValidLocationCount > 0 then
        if iValidLocationCount <= iNthEntryWanted then return tValidLocations[iValidLocationCount]
        else return tValidLocations[iValidLocationCount - iNthEntryWanted]
        end
    else
        return nil
    end
end

function ReturnNthValidLocationInSameWaterZoneClosestToTarget(iPond, iWaterZoneWanted, tStartWZData, tTargetDestination, iDistanceInterval, iNthEntryWanted, iMaxDistance)
    local iSearchDistance = 0
    local tValidLocations = {}
    local iValidLocationCount = 0
    local iAngleToTarget = M28Utilities.GetAngleFromAToB(tStartWZData[subrefMidpoint], tTargetDestination)
    local iFailureCount = 0 --After 5 failures in a row will abort
    local iCurPond, iCurWaterZone
    if iDistanceInterval < 0 then M28Utilities.ErrorHandler('Likely infinite loop as have negative distance interval') end

    while iSearchDistance <= (iMaxDistance or 150) do
        iSearchDistance = iSearchDistance + iDistanceInterval
        local tPotentialLocation = M28Utilities.MoveInDirection(tStartWZData[subrefMidpoint], iAngleToTarget, iSearchDistance, true, false, false)
        iCurWaterZone = GetWaterZoneFromPosition(tPotentialLocation)
        iCurPond = tiPondByWaterZone[iCurWaterZone]
        if iCurPond == iPond and iCurWaterZone == iWaterZoneWanted then
            iValidLocationCount = iValidLocationCount + 1
            tValidLocations[iValidLocationCount] = {tPotentialLocation[1], tPotentialLocation[2], tPotentialLocation[3]}
            iFailureCount = 0
        else
            iFailureCount = iFailureCount + 1
            if iFailureCount >= 5 then break end
        end
    end
    if iValidLocationCount > 0 then
        if iValidLocationCount <= iNthEntryWanted then return tValidLocations[iValidLocationCount]
        else return tValidLocations[iValidLocationCount - iNthEntryWanted]
        end
    else
        return nil
    end
end

function ReorderPathBasedOnAngleToFirstEntry(tUnorderedPatrolPaths, tFirstPointInPath, bAddFirstPoint)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReorderPathBasedOnDistanceToFirstEntry'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tReorderedPositions = {}
    if bAddFirstPoint then
        table.insert(tReorderedPositions, {tFirstPointInPath[1], tFirstPointInPath[2], tFirstPointInPath[3]})
    end
    if M28Utilities.IsTableEmpty(tUnorderedPatrolPaths) == false then

        local iCurAngleFromFirstPosition
        local iClosestAngleDifFromLast
        local iClosestDistRef
        local tCurStartPoint = {tFirstPointInPath[1], tFirstPointInPath[2], tFirstPointInPath[3]}
        local iLoopCount = 0

        local iMaxLoop = table.getn(tUnorderedPatrolPaths) + 2
        if bDebugMessages == true then LOG(sFunctionRef..': About to order paths, tUnorderedPatrolPaths='..repru(tUnorderedPatrolPaths)..'; tFirstPointInPath='..repru(tFirstPointInPath)..'; bAddFirstPoint='..tostring(bAddFirstPoint or false)) end

        --First get closest point to the start
        local iClosestDistToStart = 10000
        local iCurDistToStart
        local iCurAngleDif
        for iEntry, tPosition in tUnorderedPatrolPaths do
            iCurDistToStart = M28Utilities.GetDistanceBetweenPositions(tCurStartPoint, tPosition)
            if iCurDistToStart < iClosestDistToStart then
                iClosestDistToStart = iCurDistToStart
                iClosestDistRef = iEntry
            end
        end
        local iLastAngleUsed = M28Utilities.GetAngleFromAToB(tCurStartPoint, tUnorderedPatrolPaths[iClosestDistRef])
        table.insert(tReorderedPositions, {tUnorderedPatrolPaths[iClosestDistRef][1], tUnorderedPatrolPaths[iClosestDistRef][2], tUnorderedPatrolPaths[iClosestDistRef][3]})
        if bDebugMessages == true then LOG(sFunctionRef..': Angle from tCurStartPoint '..repru(tCurStartPoint)..' to first point after this, '..repru(tUnorderedPatrolPaths[iClosestDistRef])..' is '..iLastAngleUsed) end
        table.remove(tUnorderedPatrolPaths, iClosestDistRef)


        while M28Utilities.IsTableEmpty(tUnorderedPatrolPaths) == false do
            iLoopCount = 1
            iClosestAngleDifFromLast = 10000
            for iEntry, tPosition in tUnorderedPatrolPaths do
                iCurAngleFromFirstPosition = M28Utilities.GetAngleFromAToB(tCurStartPoint, tPosition)
                iCurAngleDif = M28Utilities.GetAngleDifference(iCurAngleFromFirstPosition, iLastAngleUsed)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering tPosition='..repru(tPosition)..'; Angle from start to here='..iCurAngleFromFirstPosition..'; Angle dif to last angle='..M28Utilities.GetAngleDifference(iCurAngleFromFirstPosition, iLastAngleUsed)) end
                if iCurAngleDif < iClosestAngleDifFromLast then
                    iClosestAngleDifFromLast = iCurAngleDif
                    iClosestDistRef = iEntry
                end
            end
            iLastAngleUsed = M28Utilities.GetAngleFromAToB(tCurStartPoint, tUnorderedPatrolPaths[iClosestDistRef])
            table.insert(tReorderedPositions, {tUnorderedPatrolPaths[iClosestDistRef][1], tUnorderedPatrolPaths[iClosestDistRef][2], tUnorderedPatrolPaths[iClosestDistRef][3]})
            if bDebugMessages == true then LOG(sFunctionRef..': Best location='..repru(tUnorderedPatrolPaths[iClosestDistRef])..'; iLastAngleUsed='..iLastAngleUsed) end
            table.remove(tUnorderedPatrolPaths, iClosestDistRef)
            if iLoopCount > iMaxLoop then M28Utilities.ErrorHandler('Infinite loop') break end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished reordering path, tReorderedPositions='..repru(tReorderedPositions)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tReorderedPositions
end

function ReorderPathBasedOnDistanceToFirstEntry(tUnorderedPatrolPaths, tFirstPointInPath, bAddFirstPoint)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReorderPathBasedOnDistanceToFirstEntry'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tReorderedPositions = {}
    if bAddFirstPoint then
        table.insert(tReorderedPositions, {tFirstPointInPath[1], tFirstPointInPath[2], tFirstPointInPath[3]})
    end

    local iCurDistToStart
    local iClosestDistToStart
    local iClosestDistRef
    local tCurStartPoint = {tFirstPointInPath[1], tFirstPointInPath[2], tFirstPointInPath[3]}
    local iLoopCount = 0
    local iMaxLoop = table.getn(tUnorderedPatrolPaths) + 2
    if bDebugMessages == true then LOG(sFunctionRef..': About to order paths, tUnorderedPatrolPaths='..repru(tUnorderedPatrolPaths)..'; tFirstPointInPath='..repru(tFirstPointInPath)..'; bAddFirstPoint='..tostring(bAddFirstPoint or false)) end

    while M28Utilities.IsTableEmpty(tUnorderedPatrolPaths) == false do
        iLoopCount = 1
        iClosestDistToStart = 10000
        for iEntry, tPosition in tUnorderedPatrolPaths do
            iCurDistToStart = M28Utilities.GetDistanceBetweenPositions(tCurStartPoint, tPosition)
            if iCurDistToStart < iClosestDistToStart then
                iClosestDistToStart = iCurDistToStart
                iClosestDistRef = iEntry
            end
        end
        table.insert(tReorderedPositions, {tUnorderedPatrolPaths[iClosestDistRef][1], tUnorderedPatrolPaths[iClosestDistRef][2], tUnorderedPatrolPaths[iClosestDistRef][3]})
        tCurStartPoint = {tUnorderedPatrolPaths[iClosestDistRef][1], tUnorderedPatrolPaths[iClosestDistRef][2], tUnorderedPatrolPaths[iClosestDistRef][3]}
        table.remove(tUnorderedPatrolPaths, iClosestDistRef)
        if iLoopCount > iMaxLoop then M28Utilities.ErrorHandler('Infinite loop') break end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished reordering path, tReorderedPositions='..repru(tReorderedPositions)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tReorderedPositions
end

function RecordLandZonePatrolPaths()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordLandZonePatrolPaths'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLZSubtable in tPlateauSubtable[subrefPlateauLandZones] do
            --Are we interested in patrolling this land zone? Want to ignore very small land zones
            if bDebugMessages == true then LOG(sFunctionRef..': Start of loop, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; tLZSubtable[subrefLZMexCount]='..(tLZSubtable[subrefLZMexCount] or 'nil')..'; tLZSubtable[subrefLZTotalSegmentCount]='..(tLZSubtable[subrefLZTotalSegmentCount] or 'nil')) end
            if tLZSubtable[subrefLZMexCount] > 0 or tLZSubtable[subrefLZTotalSegmentCount] >= 40 then

                --First travel towards adjacent locations an add these
                local tUnorderedPatrolPaths = {}
                local tAnglesCovered = {}

                if M28Utilities.IsTableEmpty(tLZSubtable[subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZSubtable[subrefLZAdjacentLandZones] do
                        if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iAdjLZ='..iAdjLZ..'; LZ midpoint='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iAdjLZ][subrefMidpoint])) end
                        local tPotentialLocation = ReturnNthValidLocationInSameLandZoneClosestToTarget(iPlateau, iLandZone, tLZSubtable, tAllPlateaus[iPlateau][subrefPlateauLandZones][iAdjLZ][subrefMidpoint], 4, 3, 100)
                        if tPotentialLocation then
                            table.insert(tUnorderedPatrolPaths, tPotentialLocation)
                            table.insert(tAnglesCovered, M28Utilities.GetAngleFromAToB(tLZSubtable[subrefMidpoint], tPotentialLocation))
                        end
                    end
                end
                --Identify any gaps in the path if we arent near the edge of the map
                local tbBaseAngleCovered = {}
                local iDistThreshold = 90
                if tLZSubtable[subrefMidpoint][3] >= rMapPotentialPlayableArea[2] + iDistThreshold then
                    --Arent close to the top of the map so can look north
                    tbBaseAngleCovered[0] = false
                end
                if tLZSubtable[subrefMidpoint][1] <= rMapPotentialPlayableArea[3] - iDistThreshold then
                    --Arent close to the rh of the map so can look east
                    tbBaseAngleCovered[90] = false
                end
                if tLZSubtable[subrefMidpoint][3] <= rMapPotentialPlayableArea[4] - iDistThreshold then
                    --Arent close to the bottom of the map so can look south
                    tbBaseAngleCovered[180] = false
                end
                if tLZSubtable[subrefMidpoint][1] >= rMapPotentialPlayableArea[1] + iDistThreshold then
                    --Aren't close to left hand part of map so can look west
                    tbBaseAngleCovered[270] = false
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLZ='..iLandZone..'; tAnglesCovered='..repru(tAnglesCovered)..'; Midpoint='..repru(tLZSubtable[subrefMidpoint])..'; playable area='..repru(rMapPotentialPlayableArea)..'; iDistThreshold='..iDistThreshold..'; tbBaseAngleCovered before factoring in angles covered='..repru(tbBaseAngleCovered)) end

                if M28Utilities.IsTableEmpty(tAnglesCovered) == false then

                    for _, iAngle in tAnglesCovered do
                        for iBaseAngle, bCovered in tbBaseAngleCovered do
                            if not(bCovered) then
                                if M28Utilities.GetAngleDifference(iBaseAngle, iAngle) <= 45 then
                                    tbBaseAngleCovered[iBaseAngle] = true
                                end
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': tbBaseAngleCovered='..repru(tbBaseAngleCovered)) end
                for iBaseAngle, bCovered in tbBaseAngleCovered do
                    if not(bCovered) then
                        local tPotentialLocation = ReturnNthValidLocationInSameLandZoneClosestToTarget(iPlateau, iLandZone, tLZSubtable, M28Utilities.MoveInDirection(tLZSubtable[subrefMidpoint], iBaseAngle, iDistThreshold, false, false, false), 4, 3, 70)
                        if tPotentialLocation then
                            table.insert(tUnorderedPatrolPaths, tPotentialLocation)
                        end
                    end
                end


                --Order the path based on distance, and add the midpoint of the land zone
                --Originally did based on distance, but based on angle looks slightly better
                --tLZSubtable[subreftPatrolPath] = ReorderPathBasedOnDistanceToFirstEntry(tUnorderedPatrolPaths, {tLZSubtable[subrefMidpoint][1] + 3, tLZSubtable[subrefMidpoint][2], tLZSubtable[subrefMidpoint][3] + 3}, true)
                tLZSubtable[subreftPatrolPath] = ReorderPathBasedOnAngleToFirstEntry(tUnorderedPatrolPaths, {tLZSubtable[subrefMidpoint][1] + 3, tLZSubtable[subrefMidpoint][2], tLZSubtable[subrefMidpoint][3] + 3}, true)

                if bDebugMessages == true then
                    LOG(sFunctionRef..': Finished recording patrol path for plateau '..iPlateau..'; Land zone ='..iLandZone..'; Patrol path='..repru(tLZSubtable[subreftPatrolPath]))
                    M28Utilities.DrawLocation(tLZSubtable[subrefMidpoint])
                    if M28Utilities.IsTableEmpty(tLZSubtable[subreftPatrolPath]) == false then
                        M28Utilities.DrawPath(tLZSubtable[subreftPatrolPath], 5, nil)
                    end

                end
            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordWaterZonePatrolPaths()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordWaterZonePatrolPaths'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    for iPond, tPondSubtable in tPondDetails do
        for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
            --Are we interested in patrolling this water zone? Want to ignore very small water zones
            if table.getn(tWZData[subrefWZSegments]) >= 40 then

                --First travel towards adjacent locations an add these
                local tUnorderedPatrolPaths = {}
                local tAnglesCovered = {}

                if M28Utilities.IsTableEmpty(tWZData[subrefWZOtherWaterZones]) == false then
                    for iEntry, iAltWZ in tWZData[subrefWZAdjacentWaterZones] do
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Will draw midpoint of the current water zone in gold and the target in light blue; this waterzone midpoint='..repru(tWZData[subrefMidpoint])..'; Target WZ iAltWZ '..iAltWZ..'='..repru(tPondDetails[iPond][subrefPondWaterZones][iAltWZ][subrefMidpoint]))
                            M28Utilities.DrawLocation(tWZData[subrefMidpoint], 4)
                            M28Utilities.DrawLocation(tPondDetails[iPond][subrefPondWaterZones][iAltWZ][subrefMidpoint], 5)
                        end
                        local tPotentialLocation = ReturnNthValidLocationInSameWaterZoneClosestToTarget(iPond, iWaterZone, tWZData, tPondDetails[iPond][subrefPondWaterZones][iAltWZ][subrefMidpoint], 4, 3, 150)
                        if bDebugMessages == true then LOG(sFunctionRef..': Start WZ='..iWaterZone..'; iAltWZ='..iAltWZ..'; tPotentialLocation='..repru(tPotentialLocation)) end
                        if tPotentialLocation then
                            table.insert(tUnorderedPatrolPaths, tPotentialLocation)
                            table.insert(tAnglesCovered, M28Utilities.GetAngleFromAToB(tWZData[subrefMidpoint], tPotentialLocation))
                        end
                    end
                end
                --Identify any gaps in the path if we arent near the edge of the map
                local tbBaseAngleCovered = {}
                local iDistThreshold = 90
                if tWZData[subrefMidpoint][3] >= rMapPotentialPlayableArea[2] + iDistThreshold then
                    --Arent close to the top of the map so can look north
                    tbBaseAngleCovered[0] = false
                end
                if tWZData[subrefMidpoint][1] <= rMapPotentialPlayableArea[3] - iDistThreshold then
                    --Arent close to the rh of the map so can look east
                    tbBaseAngleCovered[90] = false
                end
                if tWZData[subrefMidpoint][3] <= rMapPotentialPlayableArea[4] - iDistThreshold then
                    --Arent close to the bottom of the map so can look south
                    tbBaseAngleCovered[180] = false
                end
                if tWZData[subrefMidpoint][1] >= rMapPotentialPlayableArea[1] + iDistThreshold then
                    --Aren't close to left hand part of map so can look west
                    tbBaseAngleCovered[270] = false
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iPond='..iPond..'; iWZ='..iWaterZone..'; tAnglesCovered='..repru(tAnglesCovered)..'; Midpoint='..repru(tWZData[subrefMidpoint])..'; playable area='..repru(rMapPotentialPlayableArea)..'; iDistThreshold='..iDistThreshold..'; tbBaseAngleCovered before factoring in angles covered='..repru(tbBaseAngleCovered)) end

                if M28Utilities.IsTableEmpty(tAnglesCovered) == false then

                    for _, iAngle in tAnglesCovered do
                        for iBaseAngle, bCovered in tbBaseAngleCovered do
                            if not(bCovered) then
                                if M28Utilities.GetAngleDifference(iBaseAngle, iAngle) <= 45 then
                                    tbBaseAngleCovered[iBaseAngle] = true
                                end
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iWaterZone='..iWaterZone..'; tbBaseAngleCovered='..repru(tbBaseAngleCovered)) end
                for iBaseAngle, bCovered in tbBaseAngleCovered do
                    if not(bCovered) then
                        local tPotentialLocation = ReturnNthValidLocationInSameWaterZoneClosestToTarget(iPond, iWaterZone, tWZData, M28Utilities.MoveInDirection(tWZData[subrefMidpoint], iBaseAngle, iDistThreshold, false, false, false), 4, 3, 100)
                        if bDebugMessages == true then LOG(sFunctionRef..': tPotentialLocation for iBaseAngle='..iBaseAngle..'='..repru(tPotentialLocation)) end
                        if tPotentialLocation then
                            table.insert(tUnorderedPatrolPaths, tPotentialLocation)
                        end
                    end
                end


                --Order the path based on distance, and add the midpoint of the land zone
                --Originally did based on distance, but based on angle looks slightly better
                --tWZData[subreftPatrolPath] = ReorderPathBasedOnDistanceToFirstEntry(tUnorderedPatrolPaths, {tWZData[subrefMidpoint][1] + 3, tWZData[subrefMidpoint][2], tWZData[subrefMidpoint][3] + 3}, true)
                tWZData[subreftPatrolPath] = ReorderPathBasedOnAngleToFirstEntry(tUnorderedPatrolPaths, {tWZData[subrefMidpoint][1] + 3, tWZData[subrefMidpoint][2], tWZData[subrefMidpoint][3] + 3}, true)

                if bDebugMessages == true then
                    LOG(sFunctionRef..': Finished recording patrol path for pond '..iPond..'; Water zone ='..iWaterZone..'; Patrol path='..repru(tWZData[subreftPatrolPath]))
                    M28Utilities.DrawLocation(tWZData[subrefMidpoint])
                    if M28Utilities.IsTableEmpty(tWZData[subreftPatrolPath]) == false then
                        M28Utilities.DrawPath(tWZData[subreftPatrolPath], 5, nil)
                    end

                end
            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function RecordMinorPlateaus()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordMinorPlateaus'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bIsMinor
    iPlateauCount = 0
    local iCurPlateauCycle = 0
    local iMinSegmentX, iMinSegmentZ, iMaxSegmentX, iMaxSegmentZ, tSegmentPositionMin, tSegmentPositionMax
    local bValidLZs
    local sPathing = refPathingTypeHover
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        iPlateauCount = iPlateauCount + 1
        iCurPlateauCycle = iCurPlateauCycle + 1
        if iCurPlateauCycle > 10 then iCurPlateauCycle = 1 end
        bIsMinor = false
        if not(tPlateauSubtable[subrefPlateauMaxRadius]) then
            --record details for the plateau - first get the min and max x positions based on land zones
            iMinSegmentX = 1000000
            iMaxSegmentX = 0
            iMinSegmentZ = 1000000
            iMaxSegmentZ = 0
            bValidLZs = false
            if M28Utilities.IsTableEmpty(tPlateauSubtable[subrefPlateauLandZones]) == false then
                bValidLZs = true
                for iLandZone, tLZData in tPlateauSubtable[subrefPlateauLandZones] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Updating min and max values for iPlateau='..iPlateau..' iLandZone='..iLandZone..'; tLZData[subrefLZMinSegX]='..(tLZData[subrefLZMinSegX] or 'nil')..'; tLZData[subrefLZMinSegZ]='..(tLZData[subrefLZMinSegZ] or 'nil')) end
                    iMinSegmentX = math.min(iMinSegmentX, tLZData[subrefLZMinSegX])
                    iMinSegmentZ = math.min(iMinSegmentZ, tLZData[subrefLZMinSegZ])
                    iMaxSegmentX = math.max(iMaxSegmentX, tLZData[subrefLZMaxSegX])
                    iMaxSegmentZ = math.max(iMaxSegmentZ, tLZData[subrefLZMaxSegZ])
                end
            end
            if bValidLZs then
                --Have now got the min and max land segment X and Z values for the plateau
                tSegmentPositionMin = GetPositionFromPathingSegments(iMinSegmentX, iMinSegmentZ)
                tAllPlateaus[iPlateau][subrefPlateauMinXZ] = {tSegmentPositionMin[1], tSegmentPositionMin[3]}

                tSegmentPositionMax = GetPositionFromPathingSegments(iMaxSegmentX, iMaxSegmentZ)
                tAllPlateaus[iPlateau][subrefPlateauMaxXZ] = {tSegmentPositionMax[1], tSegmentPositionMax[3]}

                RecordPlateauReclaimSegmentsMidpointAndRadius(iPlateau, sPathing, tSegmentPositionMin, tSegmentPositionMax)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished attempting to record plateau min and max position data for plateau '..iPlateau..'; bValidLZs='..tostring(bValidLZs)..'; tPlateauSubtable[subrefPlateauMaxRadius]='..(tPlateauSubtable[subrefPlateauMaxRadius] or 'nil')) end
        end
        if (tPlateauSubtable[subrefPlateauTotalMexCount] or 0) == 0 and (tPlateauSubtable[subrefLandZoneCount] <= 5 and tPlateauSubtable[subrefPlateauMaxRadius] <= 50 and (tPlateauSubtable[subrefLandZoneCount] <= 2 or tPlateauSubtable[subrefPlateauMaxRadius] <= 25)) then
            bIsMinor = true
        end
        tPlateauSubtable[subrefbMinorPlateau] = bIsMinor
        if bIsMinor then
            tPlateauSubtable[subrefiMinorCycleRef] = iCurPlateauCycle
        end
    end
    if iPlateauCount >= 2000 then
        local oFirstM28Brain
        for iBrain, oBrain in ArmyBrains do
            if oBrain.M28AI and not(oBrain.M28IsDefeated) then
                oFirstM28Brain = oBrain
                break
            end
        end
        if oFirstM28Brain then
            M28Chat.SendMessage(oFirstM28Brain, 'MinorPlateau', 'This map has a lot of cliffs :(', 120, 100000, false, true)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function SetupLandZones()
    --Divides the map into 'land zones' based on mex placement and plateau groups, which is to form the basis for managing land units.  Land zones are areas that can be pathed by land units and are intended to group the map based on how long it takes to travel
    --Intended to be called at start of game when AI is created (so after siminit and recordresourcepoints has run), and after plateaus have been generated
    --Broadly, will group nearby mexes together in the same land zone, along with the nearby area; then will look for any places on the map with no nearby land zone and create a zone for these, and then go through the whole map and ensure every land pathable area has an assigned land zone
    --To avoid too much of a CPU load, the map is first divided into small 'segment' squares, the size of which varies based on the size of a map (1x1 for a 5km map, 2x2 for a 10km map, etc.), with it assumed that any location within a segment square has the same pathing as the midpoint of that segment
    --i.e. there will inevitably be cases where units go near a cliff where the land pathing zone is inconsistent with where the unit can path to

    --Using land zones:
    --To return both the plateau reference, and the land zone reference, of a position tPosiiton, use the function GetPlateauAndLandZoneReferenceFromPosition(tPosition) (which will return nil if it doesnt have a value)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of land zone generation, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end

    --First go through every mex on the map, and assign it a land zone (grouping mexes near each other together):
    AssignMexesALandZone()
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Now add any areas that can easily be pathed to each mex to the same land zone as that mex:
    if bDebugMessages == true then LOG(sFunctionRef..': Finished assining mexes to a land zone, will now assign the area near mexes') end

    AssignSegmentsNearMexesToLandZones()
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then
        LOG(sFunctionRef..': Finished assining area aound mexes, will now draw resulting land zones, system time='..GetSystemTimeSecondsOnlyForProfileUse())
        DrawLandZones()

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(5)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end



    --Now look for empty spots on the map without land zones and assign them a land zone, creating new ones (that have no mexes in them) where they are far from any existing land zone:
    AssignRemainingSegmentsToLandZones()
    if bDebugMessages == true then LOG(sFunctionRef..': Added remaining segments to land zones') end

    --Clear variables that we no longer need:
    tTempZoneTravelDistanceBySegment =  nil
    tTempZonePlateauBySegment = nil

    RecordLandZoneMidpointAndUnbuiltMexes()
    if bDebugMessages == true then LOG(sFunctionRef..': Finished recording land zone midpoint and unbuilt mexes system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    RecordAllHydroInLandZones()
    ReorderLandZoneSegmentsForEachPlateau()
    RecordAdjacentLandZones()
    RecordMassStorageLocationsForEachLandZone()
    RecordLandZonePatrolPaths()
    RecordMinorPlateaus()

    if bDebugMessages == true then LOG(sFunctionRef..': Finished LZ patrol paths, sys time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    --Use below if want to highlight a particular plateua at this stage:
    --[[bDebugMessages = true local iCurColour = 0 if M28Utilities.IsTableEmpty(tAllPlateaus[145][subrefPlateauLandZones]) == false then for iLandZone, tLZData in tAllPlateaus[145][subrefPlateauLandZones] do
        iCurColour = iCurColour + 1
        if iCurColour >= 9 then iCurColour = 1 end
        DrawSpecificLandZone(145, iLandZone)
        LOG(sFunctionRef..': Segment count for LZ '..iLandZone..'='..tLZData[subrefLZTotalSegmentCount]) end
    end     --]]

    RecordPathingBetweenZones() --Includes a waitticks(1)

    --Map out how long it will take each LZ to path to each other LZ
    ForkThread(RecordTravelDistBetweenZonesOverTime)

    --[[if bDebugMessages == true then
        --If want to only draw zones for 1 plateau use below instead
        local iCurColour = 0 local iSpecialPlateau = 20
        for iLandZone, tLZData in tAllPlateaus[iSpecialPlateau][subrefPlateauLandZones] do
            iCurColour = iCurColour + 1
            if iCurColour >= 9 then iCurColour = 1 end
            DrawSpecificLandZone(iSpecialPlateau, iLandZone)
            LOG(sFunctionRef..': Land zone count for plateau '..iSpecialPlateau..'='..tAllPlateaus[iSpecialPlateau][subrefLandZoneCount])
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(5)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end--]]
    ForkThread(RecordBackupGameEnderLocation)
    --If debug is enabled, draw land zones (different colour for each land zone on a plateau)
    if bDebugMessages == true then
        LOG(sFunctionRef..': Finished generating all land zones, will now draw them. System time='..GetSystemTimeSecondsOnlyForProfileUse())
        DrawLandZones()
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordIslands()
    --Assumes have already setup every land zone on the map - will now record details of islands
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordIslands'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(bRecordedIslands) then
        bRecordedIslands = true

        --Decide how detailed pathing to do when identifying the nearest land zone - on large maps we want to use straight line distance due to how long the map can take to load
        local bUseDistanceForNearestIslandLZ = false
        local bConsiderIgnoringTravelDistForShortlist = false
        local bActuallyIgnoreTravelDistForShortlist
        if iMapSize >= 512 then --10km+
            local iTotalLandZoneCount = 0
            for iPlateau, tPlateauSubtable in tAllPlateaus do
                iTotalLandZoneCount = iTotalLandZoneCount + (tPlateauSubtable[subrefLandZoneCount] or 0)
            end
            if iTotalLandZoneCount >= 45 or (iTotalLandZoneCount >= 30 and iMapSize >= 512) then
                bUseDistanceForNearestIslandLZ = true
                if iTotalLandZoneCount >= 100 and iMapSize >= 1024 then bConsiderIgnoringTravelDistForShortlist = true end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iTotalLandZoneCount='..iTotalLandZoneCount..'; bUseDistanceForNearestIslandLZ='..tostring(bUseDistanceForNearestIslandLZ)) end
        end

        --First record every island where there are mexes in the plateau or the location is relatively large
        for iPlateau, tPlateauSubtable in tAllPlateaus do
            if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; About to record any islands for plateau '..iPlateau..'; if it has mexes, tPlateauSubtable[subrefPlateauTotalMexCount]='..tPlateauSubtable[subrefPlateauTotalMexCount]..'; Max radius='..(tPlateauSubtable[subrefPlateauMaxRadius] or 'nil')) end
            if (tPlateauSubtable[subrefPlateauTotalMexCount] or 0) > 0 or (tPlateauSubtable[subrefPlateauMaxRadius] or 0) >= 50 then
                tPlateauSubtable[subrefPlateauIslandLandZones] = {}
                tPlateauSubtable[subrefPlateauIslandMexCount] = { }
                local tLandZonesWithoutIslands = {}
                for iLandZone, tLZData in tPlateauSubtable[subrefPlateauLandZones] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iLandZone='..iLandZone..'; in Plateau '..iPlateau..'; Amphibious label='..(NavUtils.GetTerrainLabel(refPathingTypeLand, tLZData[subrefMidpoint]) or 'nil')..'; LZData[subrefMidpoint]='..repru(tLZData[subrefMidpoint])) end
                    tLZData[subrefLZIslandRef] = NavUtils.GetTerrainLabel(refPathingTypeLand, tLZData[subrefMidpoint])
                    if (tLZData[subrefLZIslandRef] or -1) > 0 then
                        if not(tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]]) then tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]] = {} end
                        table.insert(tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]], iLandZone)
                        tPlateauSubtable[subrefPlateauIslandMexCount][tLZData[subrefLZIslandRef]] = (tPlateauSubtable[subrefPlateauIslandMexCount][tLZData[subrefLZIslandRef]] or 0) + tLZData[subrefLZMexCount]
                    else
                        table.insert(tLandZonesWithoutIslands, iLandZone)
                        if bDebugMessages == true then LOG(sFunctionRef..': Dont have an island ref for iLandZone='..iLandZone..'; so will record in tLandZonesWithoutIslands') end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished checking all land zones for plateau '..iPlateau..' for first pass; is table of tLandZonesWithoutIslands empty='..tostring(M28Utilities.IsTableEmpty(tLandZonesWithoutIslands))) end
                if M28Utilities.IsTableEmpty(tLandZonesWithoutIslands) == false then
                    for iEntry, iLandZone in tLandZonesWithoutIslands do
                        local tLZData = tPlateauSubtable[subrefPlateauLandZones][iLandZone]
                        --Cycle through adjacent LZs to see if any of them have an island recorded
                        M28Profiler.FunctionProfiler(sFunctionRef..': AjdLZ', M28Profiler.refProfilerStart)
                        if M28Utilities.IsTableEmpty(tLZData[subrefLZPathingToOtherLandZones]) == false then
                            for iEntry, tSubtable in tLZData[subrefLZPathingToOtherLandZones] do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent LZs for iLandZone='..iLandZone..'; Adjacent LZ='..tSubtable[subrefLZNumber]..'; Island ref for this='..(tPlateauSubtable[subrefPlateauLandZones][tSubtable[subrefLZNumber]][subrefLZIslandRef] or 'nil')) end
                                if (tPlateauSubtable[subrefPlateauLandZones][tSubtable[subrefLZNumber]][subrefLZIslandRef] or 0) > 0 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will use htis island ref') end
                                    tLZData[subrefLZIslandRef] = tPlateauSubtable[subrefPlateauLandZones][tSubtable[subrefLZNumber]][subrefLZIslandRef]
                                    if not(tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]]) then tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]] = {} end
                                    table.insert(tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]], iLandZone)
                                    tPlateauSubtable[subrefPlateauIslandMexCount][tLZData[subrefLZIslandRef]] = (tPlateauSubtable[subrefPlateauIslandMexCount][tLZData[subrefLZIslandRef]] or 0) + tLZData[subrefLZMexCount]
                                    break
                                end
                            end
                        end
                        M28Profiler.FunctionProfiler(sFunctionRef..': AjdLZ', M28Profiler.refProfilerEnd)
                        M28Profiler.FunctionProfiler(sFunctionRef..': MidpointSearch', M28Profiler.refProfilerStart)
                        --If still dont have an island ref then try searching around the midpoint until come across an island
                        if (tLZData[subrefLZIslandRef] or 0) == 0 then
                            local tAltMidpoint
                            for iAdjust = 1, 50 do
                                for iXMod = -1, 1, 1 do
                                    for iZMod = -1, 1, 1 do
                                        tAltMidpoint = {tLZData[subrefMidpoint][1] + iAdjust * iXMod, 0, tLZData[subrefMidpoint][3] + iAdjust * iZMod}
                                        tAltMidpoint[2] = GetTerrainHeight(tAltMidpoint[1], tAltMidpoint[3])
                                        tLZData[subrefLZIslandRef] = NavUtils.GetTerrainLabel(refPathingTypeLand, tAltMidpoint)
                                        if (tLZData[subrefLZIslandRef] or 0) > 0 then
                                            break
                                        end
                                    end
                                    if (tLZData[subrefLZIslandRef] or 0) > 0 then break end
                                end
                                if (tLZData[subrefLZIslandRef] or 0) > 0 then break end
                            end
                            if (tLZData[subrefLZIslandRef] or 0) == 0 then tLZData[subrefLZIslandRef] = 0 end
                            if bDebugMessages == true then LOG(sFunctionRef..': Finished searching nearby, tLZData[subrefLZIslandRef]='..(tLZData[subrefLZIslandRef] or 'nil')) end
                        end
                        M28Profiler.FunctionProfiler(sFunctionRef..': MidpointSearch', M28Profiler.refProfilerEnd)
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished recording all islands in plateau '..iPlateau..'; Mex count by island='..repru(tPlateauSubtable[subrefPlateauIslandMexCount])..'; LZs by island='..repru(tPlateauSubtable[subrefPlateauIslandLandZones])) end

                local iIslandCount
                if bConsiderIgnoringTravelDistForShortlist then
                    bActuallyIgnoreTravelDistForShortlist = false
                    iIslandCount = 0
                    for iIsland, tLandZonesInIsland in tPlateauSubtable[subrefPlateauIslandLandZones] do
                        iIslandCount = iIslandCount + 1
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Plateau '..iPlateau..' has iIslandCount of '..iIslandCount..'; and land zone count of '..(tPlateauSubtable[subrefLandZoneCount] or 0)) end
                    if iIslandCount >= 25 then
                        bActuallyIgnoreTravelDistForShortlist = true
                        if bDebugMessages == true then LOG(sFunctionRef..': will use faster but less accurate pathing method') end
                    end
                end




                M28Profiler.FunctionProfiler(sFunctionRef..': Pathing', M28Profiler.refProfilerStart)
                for iLandZone, tLZData in tPlateauSubtable[subrefPlateauLandZones] do
                    --For performance reasons only record pathing for zones with mexes
                    if tLZData[subrefLZMexCount] > 0 then

                        --Cycle through each island in this plateau and consider pathing for it
                        if bDebugMessages == true then LOG(sFunctionRef..': Will record the pathing to every island from iLandZone='..iLandZone..'; ') end
                        for iIsland, tLandZonesInIsland in tPlateauSubtable[subrefPlateauIslandLandZones] do
                            --Only consider islands with mexes (for performance reasons)
                            if tPlateauSubtable[subrefPlateauIslandMexCount][iIsland] > 0 and not(iIsland == tLZData[subrefLZIslandRef]) then
                                --Get the land zone in this island that is closest to our current land zone
                                M28Profiler.FunctionProfiler(sFunctionRef..': Excl land path', M28Profiler.refProfilerStart)
                                local iClosestLZRef
                                local iClosestTravelDist = 100000
                                local iCurTravelDistance

                                if bUseDistanceForNearestIslandLZ then
                                    if bActuallyIgnoreTravelDistForShortlist then
                                        local iCurDistance, iCurPosition
                                        for iEntry, iIslandLZ in tLandZonesInIsland do
                                            iCurDistance = M28Utilities.GetDistanceBetweenPositions(tLZData[subrefMidpoint], tPlateauSubtable[subrefPlateauLandZones][iIslandLZ][subrefMidpoint])
                                            if iCurDistance < iClosestTravelDist then
                                                iClosestTravelDist = iCurDistance
                                                iClosestLZRef = iIslandLZ
                                            end
                                        end
                                    else
                                        local tiTopThreeZonesByDistance = {}
                                        local tiDistanceOfTopThreeZones = {[1]=100000, [2]=100000,[3]=100000}
                                        local iCurDistance, iCurPosition
                                        for iEntry, iIslandLZ in tLandZonesInIsland do
                                            iCurDistance = M28Utilities.GetDistanceBetweenPositions(tLZData[subrefMidpoint], tPlateauSubtable[subrefPlateauLandZones][iIslandLZ][subrefMidpoint])

                                            if iCurDistance < tiDistanceOfTopThreeZones[3] then
                                                if iCurDistance <     tiDistanceOfTopThreeZones[2] then
                                                    if iCurDistance < tiDistanceOfTopThreeZones[1] then
                                                        iCurPosition = 1
                                                    else
                                                        iCurPosition = 2
                                                    end
                                                else
                                                    iCurPosition = 3
                                                end
                                                if iCurPosition == 1 then
                                                    tiTopThreeZonesByDistance[3] = tiTopThreeZonesByDistance[2]
                                                    tiDistanceOfTopThreeZones[3] = tiDistanceOfTopThreeZones[2]
                                                    tiTopThreeZonesByDistance[2] = tiTopThreeZonesByDistance[1]
                                                    tiDistanceOfTopThreeZones[3] = tiDistanceOfTopThreeZones[2]
                                                elseif iCurPosition == 2 then
                                                    tiTopThreeZonesByDistance[3] = tiTopThreeZonesByDistance[2]
                                                    tiDistanceOfTopThreeZones[3] = tiDistanceOfTopThreeZones[2]
                                                end
                                                tiTopThreeZonesByDistance[iCurPosition] = iIslandLZ
                                                tiDistanceOfTopThreeZones[iCurPosition] = iCurDistance
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': iCurTravelDistance='..repru(iCurTravelDistance)..'; iClosestTravelDist='..repru(iClosestTravelDist)) end
                                        end
                                        --Get the closest of these
                                        local iClosestTravelDist = 100000

                                        for iEntry, iIslandLZ in tiTopThreeZonesByDistance do
                                            iCurTravelDistance = M28Utilities.GetTravelDistanceBetweenPositions(tLZData[subrefMidpoint], tPlateauSubtable[subrefPlateauLandZones][iIslandLZ][subrefMidpoint], refPathingTypeHover)
                                            if bDebugMessages == true then LOG(sFunctionRef..': iCurTravelDistance='..repru(iCurTravelDistance)..'; iClosestTravelDist='..repru(iClosestTravelDist)) end
                                            if iCurTravelDistance and iCurTravelDistance < iClosestTravelDist then
                                                iClosestTravelDist = iCurTravelDistance
                                                iClosestLZRef = iIslandLZ
                                            end
                                        end
                                    end
                                else
                                    for iEntry, iIslandLZ in tLandZonesInIsland do

                                        iCurTravelDistance = M28Utilities.GetTravelDistanceBetweenPositions(tLZData[subrefMidpoint], tPlateauSubtable[subrefPlateauLandZones][iIslandLZ][subrefMidpoint], refPathingTypeHover)
                                        if bDebugMessages == true then LOG(sFunctionRef..': iCurTravelDistance='..repru(iCurTravelDistance)..'; iClosestTravelDist='..repru(iClosestTravelDist)) end
                                        if iCurTravelDistance and iCurTravelDistance < iClosestTravelDist then
                                            iClosestTravelDist = iCurTravelDistance
                                            iClosestLZRef = iIslandLZ
                                        end
                                    end
                                end

                                --Get the position in the current table
                                local iPosition = 1
                                if not(tLZData[subrefLZPathingToOtherIslands]) then
                                    tLZData[subrefLZPathingToOtherIslands] = {}
                                    iPosition = 1
                                else
                                    for iExistingIsland, tExistingSubtable in tLZData[subrefLZPathingToOtherIslands] do
                                        if tExistingSubtable[subrefIslandTravelDist] < iClosestTravelDist then
                                            iPosition = iPosition + 1
                                        else
                                            break
                                        end
                                    end
                                end
                                M28Profiler.FunctionProfiler(sFunctionRef..': Excl land path', M28Profiler.refProfilerEnd)
                                M28Profiler.FunctionProfiler(sFunctionRef..': land path', M28Profiler.refProfilerStart)
                                local tPathingLZFromStartToTarget = {}
                                if bActuallyIgnoreTravelDistForShortlist then
                                    --Since we are only recording the land zones along the path, just check if both the target and destination land zones have an adjacent water zone in the same pond; if they do, have these as the start and end land zones
                                    if M28Utilities.IsTableEmpty(tLZData[subrefAdjacentWaterZones]) == false then
                                        local tiValidPonds = {}
                                        local tTargetLZData = tPlateauSubtable[subrefPlateauLandZones][iClosestLZRef]

                                        if M28Utilities.IsTableEmpty(tTargetLZData[subrefAdjacentWaterZones]) == false then
                                            local tbIsTargetWaterZone = {}
                                            for iEntry, tWZSubtable in tTargetLZData[subrefAdjacentWaterZones] do
                                                tiValidPonds[tiPondByWaterZone[tWZSubtable[subrefAWZRef]]] = true
                                                tbIsTargetWaterZone[tWZSubtable[subrefAWZRef]] = true
                                            end
                                            local bHaveAdjacentWaterZonesInSamePond = false
                                            --local iCurCycle = 0
                                            local tiAdjacentWaterZones = {}

                                            --tiAdjacentWaterZones[0] = {}
                                            for iEntry, tWZSubtable in tLZData[subrefAdjacentWaterZones] do
                                                if tiValidPonds[tiPondByWaterZone[tWZSubtable[subrefAWZRef]]] then
                                                    bHaveAdjacentWaterZonesInSamePond = true
                                                    break
                                                    --table.insert(tiAdjacentWaterZones[0], tWZSubtable[subrefAWZRef])
                                                end
                                            end
                                            if bHaveAdjacentWaterZonesInSamePond then
                                                table.insert(tPathingLZFromStartToTarget, iLandZone)
                                                table.insert(tPathingLZFromStartToTarget, iClosestLZRef)

                                                table.insert(tLZData[subrefLZPathingToOtherIslands], iPosition, {[subrefIslandNumber] = iIsland, [subrefIslandClosestLZRef] = iClosestLZRef, [subrefLZTravelDist] = iClosestTravelDist, [subrefIslandLZPath] = { } })
                                                --Add in the LZ path
                                                for iEntry, iLZ in tPathingLZFromStartToTarget do
                                                    table.insert(tLZData[subrefLZPathingToOtherIslands][iPosition][subrefIslandLZPath], iLZ)
                                                end
                                            end
                                        end
                                    end

                                end
                                if M28Utilities.IsTableEmpty(tPathingLZFromStartToTarget) then
                                    local tFullPath, iPathSize, iDistance = NavUtils.PathTo(refPathingTypeHover, tLZData[subrefMidpoint], tPlateauSubtable[subrefPlateauLandZones][iClosestLZRef][subrefMidpoint], nil)

                                    --Reduce tFullPath to a table of land zones
                                    if tFullPath then
                                        local iPathingPlateau, iPathingLandZone
                                        local tPathingLZConsidered = {}


                                        local iTravelDistance = 0
                                        local tStart = {tLZData[subrefMidpoint][1], tLZData[subrefMidpoint][2], tLZData[subrefMidpoint][3]}
                                        local tEnd = {tPlateauSubtable[subrefPlateauLandZones][iClosestLZRef][subrefMidpoint][1], tPlateauSubtable[subrefPlateauLandZones][iClosestLZRef][subrefMidpoint][2], tPlateauSubtable[subrefPlateauLandZones][iClosestLZRef][subrefMidpoint][3]}
                                        tFullPath[0] = tStart
                                        tFullPath[iPathSize + 1] = tEnd
                                        for iPath = 1, iPathSize + 1 do
                                            iTravelDistance = iTravelDistance + VDist2(tFullPath[iPath - 1][1], tFullPath[iPath - 1][3], tFullPath[iPath][1], tFullPath[iPath][3])
                                            iPathingPlateau, iPathingLandZone = GetPlateauAndLandZoneReferenceFromPosition(tFullPath[iPath])
                                            if iPathingLandZone > 0 then
                                                if not(tPathingLZConsidered[iPathingLandZone]) and not(iLandZone == iPathingLandZone) then
                                                    tPathingLZConsidered[iPathingLandZone] = true
                                                    table.insert(tPathingLZFromStartToTarget, iPathingLandZone)
                                                end
                                            end
                                        end
                                        if not(tPathingLZConsidered[iClosestLZRef]) then
                                            table.insert(tPathingLZFromStartToTarget, iPathingLandZone)
                                            tPathingLZConsidered[iClosestLZRef] = true
                                        end
                                        table.insert(tLZData[subrefLZPathingToOtherIslands], iPosition, {[subrefIslandNumber] = iIsland, [subrefIslandClosestLZRef] = iClosestLZRef, [subrefLZTravelDist] = iClosestTravelDist, [subrefIslandLZPath] = { } })
                                        --Add in the LZ path
                                        for iEntry, iLZ in tPathingLZFromStartToTarget do
                                            table.insert(tLZData[subrefLZPathingToOtherIslands][iPosition][subrefIslandLZPath], iLZ)
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Plateau '..iPlateau..': Finished recording pathing to get from iLandZone='..iLandZone..' to iClosestLZRef='..(iClosestLZRef or 'nil')..' in island '..iIsland..'; tLZData[subrefLZPathingToOtherIslands]='..repru(tLZData[subrefLZPathingToOtherIslands])) end
                                M28Profiler.FunctionProfiler(sFunctionRef..': land path', M28Profiler.refProfilerEnd)
                            end
                        end
                    end
                end
                M28Profiler.FunctionProfiler(sFunctionRef..': Pathing', M28Profiler.refProfilerEnd)
                if bDebugMessages == true then LOG(sFunctionRef..': Finished recording for iPlateau='..iPlateau) end
            else
                if not(tPlateauSubtable[subrefPlateauLandZones]) then
                    M28Utilities.ErrorHandler('Have no land zone recorded for plateau '..iPlateau, false, true)
                end
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param tPosition table
---@param bReturnSufaceHeightInstead boolean
---@param iOptionalAmountToBeUnderwatner number
---@return boolean
function IsUnderwater(tPosition, bReturnSurfaceHeightInstead, iOptionalAmountToBeUnderwater)
    --Returns true if tPosition underwater, otherwise returns false
    --bReturnSurfaceHeightInstead:: Return the actual height at which underwater, instead of true/false
    if bReturnSurfaceHeightInstead then return iMapWaterHeight
    else
        --LOG('IsUnderwater: tPosition='..repru(tPosition))
        if M28Utilities.IsTableEmpty(tPosition) then
            M28Utilities.ErrorHandler('tPosition is empty')
        else
            if iMapWaterHeight > tPosition[2] + (iOptionalAmountToBeUnderwater or 0) then
                --Check we're not just under an arch but are actually underwater
                if not(GetTerrainHeight(tPosition[1], tPosition[3]) == iMapWaterHeight) then
                    return true
                end
            end
        end
        return false
    end
end

local function GetMapWaterHeight()
    --Updates iMapWaterHeight to the water height on the map (if the map has water)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetMapWaterHeight'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --rMapPotentialPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2} - Set at start of the game, use instead of the scenarioinfo method
    local iWaterCount = 0
    local iWaterLevel = 10000
    local iCurTerrainHeight = 10000
    local iInterval = 1

    --Cycle through the map in iInterval sizes, until we come to a point where the surface height exceeds the terrain height, which suggests it is water:
    for iX = rMapPotentialPlayableArea[1] + iInterval, rMapPotentialPlayableArea[3], iInterval do
        for iZ = rMapPotentialPlayableArea[2] + iInterval, rMapPotentialPlayableArea[4], iInterval do
            iCurTerrainHeight =  GetTerrainHeight(iX, iZ)
            if GetSurfaceHeight(iX, iZ) > GetTerrainHeight(iX, iZ) then
                iWaterCount = iWaterCount + 1
                iWaterLevel = math.min(iWaterLevel, GetSurfaceHeight(iX, iZ))
                if bDebugMessages == true then LOG(sFunctionRef..': Found water at position X-Z='..iX..'-'..iZ..'; Surface height='..GetSurfaceHeight(iX, iZ)..'; Terrain height='..GetTerrainHeight(iX, iZ)) end
                if iWaterCount >= 3 then
                    break
                end
            else
                --Backup for maps like theta passage arch - have commented out as running on theta passage with interval of 1 it never triggers a water count in the first place, but could remove comments if do come across this issue
                --if bDebugMessages == true and iWaterCount > 0 and GetTerrainHeight(iX, iZ) < iWaterLevel and iWaterLevel < 10000 then LOG(sFunctionRef..': Have suspected arch previously so will adjust water level to terrain height='..GetTerrainHeight(iX, iZ)..'; for iX-Z='..iX..'-'..iZ..'; prev iWaterLevel='..iWaterLevel) end
                --iWaterLevel = math.min(iWaterLevel, GetTerrainHeight(iX, iZ))
            end
        end
        if iWaterCount >= 3 then break end
    end
    if iWaterCount == 0 then iMapWaterHeight = 0
    else
        iMapWaterHeight = iWaterLevel
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iWaterCount='..iWaterCount..'; iMapWaterHeight='..iMapWaterHeight) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetReclaimablesResourceValue(tReclaimables, bAlsoReturnLargestReclaimPosition, iIgnoreReclaimIfNotMoreThanThis, bAlsoReturnAmountOfHighestIndividualReclaim, bEnergyNotMass)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetReclaimablesResourceValue'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bAlsoReturnLargestReclaimPosition == nil then bAlsoReturnLargestReclaimPosition = false end
    if iIgnoreReclaimIfNotMoreThanThis == nil then iIgnoreReclaimIfNotMoreThanThis = 0 end
    if iIgnoreReclaimIfNotMoreThanThis < 0 then iIgnoreReclaimIfNotMoreThanThis = 0 end

    local sResourceRef = 'MaxMassReclaim'
    if bEnergyNotMass then sResourceRef = 'MaxEnergyReclaim' end

    local tWreckPos = {}
    local iTotalResourceValue = 0
    local iLargestCurReclaim = 0
    local tReclaimPos = {}
    if tReclaimables and table.getn( tReclaimables ) > 0 then
        for _, v in tReclaimables do
            tWreckPos = v.CachePosition
            if tWreckPos[1] then
                if v[sResourceRef] > iIgnoreReclaimIfNotMoreThanThis then
                    if not(v:BeenDestroyed()) then
                        iTotalResourceValue = iTotalResourceValue + v[sResourceRef]
                        if bAlsoReturnLargestReclaimPosition and v.MaxMassReclaim > iLargestCurReclaim then
                            iLargestCurReclaim = v.MaxMassReclaim
                            tReclaimPos = {tWreckPos[1], tWreckPos[2], tWreckPos[3]}
                        end
                    end
                end
            else
                if not(v.MaxMassReclaim == nil) then
                    if v.MaxMassReclaim > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Warning - have ignored wreck location despite it having a mass reclaim value') end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bAlsoReturnLargestReclaimPosition then
        if bAlsoReturnAmountOfHighestIndividualReclaim then return iTotalResourceValue, tReclaimPos, iLargestCurReclaim
        else return iTotalResourceValue, tReclaimPos end
    else
        if bAlsoReturnAmountOfHighestIndividualReclaim then return iTotalResourceValue, iLargestCurReclaim
        else return iTotalResourceValue end
    end
end

function GetReclaimInRectangle(iReturnType, rRectangleToSearch, bForceDebug)
    --iReturnType: 1 = true/false; 2 = number of wrecks; 3 = total mass, 4 = valid wrecks, 5 = energy
    local sFunctionRef = 'GetReclaimInRectangle'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local bDebugMessages = bForceDebug if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    --NOTE: Best to try and debug via forcedebug, as dont want to run for everything due to how intensive the log of reclaim is
    --Have also commented out one of the logs to help with performance



    local tReclaimables = GetReclaimablesInRect(rRectangleToSearch)
    local iWreckCount = 0
    local iTotalResourceValue
    local bHaveReclaim = false
    local tValidWrecks = {}
    if M28Utilities.IsTableEmpty(tReclaimables) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': iReturnType='..iReturnType..'; rRectangleToSearch='..repru(rRectangleToSearch)) end
        if iReturnType == 3 or iReturnType == 5 then
            if iReturnType == 3 then iTotalResourceValue = GetReclaimablesResourceValue(tReclaimables, false, 0, false, false)
            else iTotalResourceValue = GetReclaimablesResourceValue(tReclaimables, false, 0, false, true)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iTotalResourceValue='..iTotalResourceValue) end
        else
            for _, v in tReclaimables do
                --if bDebugMessages == true then LOG(sFunctionRef..': _='.._..'; repr of reclaimable='..repru(tReclaimables)) end
                local WreckPos = v.CachePosition
                if not(WreckPos[1]==nil) then
                    if bDebugMessages == true then LOG(sFunctionRef..': _='.._..'; Cur mass value='..(v.MaxMassReclaim or 0)..'; Energy value='..(v.MaxEnergyReclaim or 0)) end
                    if (v.MaxMassReclaim or 0) > 0 or (v.MaxEnergyReclaim or 0) > 0 then
                        if bDebugMessages == true then LOG('Been destroyed='..tostring(v:BeenDestroyed())) end
                        if not(v:BeenDestroyed()) then
                            iWreckCount = iWreckCount + 1
                            bHaveReclaim = true
                            if iReturnType == 1 then break
                            elseif iReturnType == 4 then tValidWrecks[iWreckCount] = v end
                        end
                    end
                end
            end
        end
    elseif bDebugMessages == true then LOG(sFunctionRef..': tReclaimables is empty')
    end
    if bDebugMessages == true then LOG(sFunctionRef..': rRectangleToSearch='..repru(rRectangleToSearch)..'; bHaveReclaim='..tostring(bHaveReclaim)..'; iWreckCount='..iWreckCount) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if iReturnType == 1 then return bHaveReclaim
    elseif iReturnType == 2 then return iWreckCount
    elseif iReturnType == 3 or iReturnType == 5 then return iTotalResourceValue
    elseif iReturnType == 4 then return tValidWrecks
    else M28Utilities.ErrorHandler('Invalid return type')
    end
end

function SetWhetherCanPathToEnemy(aiBrain)
    --Set flag for whether AI can path to enemy base
    --Also updates other values that are based on the nearest enemy
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetWhetherCanPathToEnemy'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for aiBrain index'..aiBrain:GetArmyIndex()..'; Nickname='..(aiBrain.Nickname or 'nil')..'; Team='..(aiBrain.M28Team or 'nil')..'; Are all enemies defeated='..tostring(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated] or false)..'; Time='..GetGameTimeSeconds()) end
    if not(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated]) then
        local tEnemyStartPosition = GetPrimaryEnemyBaseLocation(aiBrain)
        local tOurBase = GetPlayerStartPosition(aiBrain)

        if NavUtils.GetTerrainLabel(refPathingTypeLand, tOurBase) == NavUtils.GetTerrainLabel(refPathingTypeLand, tEnemyStartPosition) and not(IsUnderwater({tOurBase[1], GetTerrainHeight(tOurBase[1], tOurBase[3]), tOurBase[3]})) then
            aiBrain[refbCanPathToEnemyBaseWithLand] = true
        else aiBrain[refbCanPathToEnemyBaseWithLand] = false
        end

        if NavUtils.GetTerrainLabel(refPathingTypeHover, tOurBase) == NavUtils.GetTerrainLabel(refPathingTypeHover, tEnemyStartPosition) then
            aiBrain[refbCanPathToEnemyBaseWithAmphibious] = true
        else aiBrain[refbCanPathToEnemyBaseWithAmphibious] = false end

        aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] = M28Utilities.GetDistanceBetweenPositions(GetPlayerStartPosition(aiBrain), tEnemyStartPosition)
        M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiMaxScoutRadius] = math.max(1500, (M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiMaxScoutRadius] or 1500), aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 1.5)

        --Record mitpoint between base (makes it easier to calc mod distance
        aiBrain[reftMidpointToPrimaryEnemyBase] = M28Utilities.MoveInDirection(GetPlayerStartPosition(aiBrain), M28Utilities.GetAngleFromAToB(GetPlayerStartPosition(aiBrain), tEnemyStartPosition), aiBrain[M28Overseer.refiDistanceToNearestEnemyBase], false, false, false)
        if bDebugMessages == true then LOG(sFunctionRef..': Set enemy base and whether we can path there, dist to nearest enem ybase='..(aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] or 'nil')) end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetOppositeLocation(tLocation)
    --Returns a point on the opposite side of the map to tLocation
    local tOpposite = {rMapPotentialPlayableArea[3] - tLocation[1] + rMapPotentialPlayableArea[1], 0, rMapPotentialPlayableArea[4] - tLocation[3] + rMapPotentialPlayableArea[2]}
    tOpposite[2] = GetSurfaceHeight(tOpposite[1], tOpposite[3])
    return tOpposite
end

function UpdateNewPrimaryBaseLocation(aiBrain)
    --Updates reftPrimaryEnemyBaseLocation to the nearest enemy start position (unless there are no structures there in which case it searches for a better start position)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateNewPrimaryBaseLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --LOG(sFunctionRef..': aiBrain='..aiBrain:GetArmyIndex()..'; Start position='..(aiBrain:GetArmyIndex() or 'nil'))
    if bDebugMessages == true then
        LOG(sFunctionRef..': About to get new primary base location for brain '..(aiBrain.Nickname or 'nil')..' unless it is civilian or defeated')
        LOG(sFunctionRef..': IsCivilian='..tostring(M28Conditions.IsCivilianBrain(aiBrain))..'; .M28IsDefeated='..tostring((aiBrain.M28IsDefeated or false)))
    end
    if not(M28Conditions.IsCivilianBrain(aiBrain)) and not(aiBrain.M28IsDefeated) and not(aiBrain:IsDefeated()) then
        local tPrevPosition
        if aiBrain[reftPrimaryEnemyBaseLocation] then tPrevPosition = {aiBrain[reftPrimaryEnemyBaseLocation][1], aiBrain[reftPrimaryEnemyBaseLocation][2], aiBrain[reftPrimaryEnemyBaseLocation][3]} end
        if bDebugMessages == true then LOG(sFunctionRef..': Team='..(aiBrain.M28Team or 'nil')..'; Are all enemies defated for this team='..tostring(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated] or false)) end
        if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated] then
            local tFriendlyBrainStartPoints = {}
            local iFriendlyBrainCount = 0
            tFriendlyBrainStartPoints[iFriendlyBrainCount] = GetPlayerStartPosition(aiBrain)
            if bDebugMessages == true then LOG(sFunctionRef..': Have no enemies, so will get average of friendly brain start points provided not the centre of the map. Is table of friendly ally active brains empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyHumanAndAIBrains]))) end

            for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyHumanAndAIBrains] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering ally brain index='..oBrain:GetArmyIndex()..'; Nickname='..(oBrain.Nickname or 'nil')..'; Start point='..repru((PlayerStartPoints[oBrain:GetArmyIndex()] or {'nil'}))) end
                --if not(oBrain == aiBrain) then
                iFriendlyBrainCount = iFriendlyBrainCount + 1
                tFriendlyBrainStartPoints[iFriendlyBrainCount] = GetPlayerStartPosition(oBrain)
                --end
            end
            local tAverageTeamPosition
            if bDebugMessages == true then LOG(sFunctionRef..': About to record average team position, iFriendlyBrainCount='..iFriendlyBrainCount) end
            if iFriendlyBrainCount == 1 then tAverageTeamPosition = tFriendlyBrainStartPoints[iFriendlyBrainCount]
            else tAverageTeamPosition = M28Utilities.GetAverageOfLocations(tFriendlyBrainStartPoints)
            end

            if bDebugMessages == true then LOG(sFunctionRef..': iFriendlyBrainCount='..iFriendlyBrainCount..'; Friendly brain start points='..repru((tFriendlyBrainStartPoints or {'nil'}))..'; tAverageTeamPosition='..repru(tAverageTeamPosition)..'; rMapPotentialPlayableArea='..repru(rMapPotentialPlayableArea)) end

            if M28Utilities.GetDistanceBetweenPositions(tAverageTeamPosition, {rMapPotentialPlayableArea[1] + (rMapPotentialPlayableArea[3] - rMapPotentialPlayableArea[1])*0.5, 0, rMapPotentialPlayableArea[2] + (rMapPotentialPlayableArea[4] - rMapPotentialPlayableArea[2])*0.5}) <= 50 then
                --Average is really close to middle of the map, so just  assume enemy base is in the opposite direction to us
                aiBrain[reftPrimaryEnemyBaseLocation] = GetOppositeLocation(GetPlayerStartPosition(aiBrain))
                if bDebugMessages == true then LOG(sFunctionRef..': Average close to middle of map so assuming enemy base is opposite direction to us') end
            else
                --Average isnt really close to mid of map, so assume enemy base is in opposite directino to average
                aiBrain[reftPrimaryEnemyBaseLocation] = GetOppositeLocation(tAverageTeamPosition)
                if bDebugMessages == true then LOG(sFunctionRef..': Assuming enemy base is opposite direction to average allied position') end
            end
        else --Still have enemies that are alive
            local tEnemyBase = PlayerStartPoints[M28Logic.GetNearestEnemyIndex(aiBrain)]
            if not(tEnemyBase) then
                --Make the enemy base the aiBrain furthest from us
                local iCurDist
                local iFurthestDist = 0
                local tOurStart = GetPlayerStartPosition(aiBrain)

                for iBrain, oBrain in ArmyBrains do
                    --Get the furthest enemy brain; if none hten fursthest non-ally brain; if none then furthest ally brain
                    local tCurBase = GetPlayerStartPosition(oBrain)
                    iModDist = M28Utilities.GetDistanceBetweenPositions(tCurBase, tOurStart)
                    if not(IsAlly(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex())) then
                        iModDist = iModDist + iMapSize * 2
                        if IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()) then
                            iModDist = iModDist + iMapSize * 2
                        end
                    end

                    if iModDist > iFurthestDist then
                        tEnemyBase = {tCurBase[1], tCurBase[2], tCurBase[3]}
                        iFurthestDist = iModDist
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy index='..(M28Logic.GetNearestEnemyIndex(aiBrain) or 'nil')..'; tEnemyBase='..repru(tEnemyBase)) end
            --Is this different from the current location we are using?
            if not(tEnemyBase[1] == aiBrain[reftPrimaryEnemyBaseLocation][1]) or not(tEnemyBase[3] == aiBrain[reftPrimaryEnemyBaseLocation][3]) then
                aiBrain[refiLastTimeCheckedEnemyBaseLocation] = GetGameTimeSeconds()
                aiBrain[reftPrimaryEnemyBaseLocation] = {tEnemyBase[1], tEnemyBase[2], tEnemyBase[3]}
            end

            --If this is on the same island as this brain, then check for overrides if we dont have a land zone for this location
            local iEnemyLandLabel = NavUtils.GetLabel(refPathingTypeLand, tEnemyBase)
            local iOurLandLabel = NavUtils.GetLabel(refPathingTypeLand, GetPlayerStartPosition(aiBrain))
            if bDebugMessages == true then LOG(sFunctionRef..': Checking if enemy base on same island as aiBrain '..aiBrain.Nickname..' base, iEnemyLandLabel='..(iEnemyLandLabel or 'nil')..'; iOurLandLabel='..(iOurLandLabel or 'nil')) end
            if iEnemyLandLabel == iOurLandLabel and iEnemyLandLabel then
                local iEnemyPlateau, iEnemyLandZone = GetPlateauAndLandZoneReferenceFromPosition(tEnemyBase)
                local iOurPlateau, iOurLandZone = GetPlateauAndLandZoneReferenceFromPosition(GetPlayerStartPosition(aiBrain))
                if bDebugMessages == true then LOG(sFunctionRef..': We are on same island so should have a valid land zone, iEnemyLandZone='..(iEnemyLandZone or 'nil')..'; iOurPlateau='..(iOurPlateau or 'nil')..'; iEnemyPlateau='..(iEnemyPlateau or 'nil')) end
                if iEnemyLandZone == nil and iOurPlateau == iEnemyPlateau then
                    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tEnemyBase)
                    --Search in a hollow box
                    local iNewLandZone
                    local iNewLandLabel
                    local iNewPlateau
                    --Search nearby but not that far
                    local iMaxAdjust = math.max(1, math.floor(10 / iLandZoneSegmentSize))

                    for iAdjustBase = 1, iMaxAdjust do
                        for iCurSegmentX = iSegmentX - iAdjustBase, iSegmentX + iAdjustBase, 1 do
                            for iCurSegmentZ = iSegmentZ - iAdjustBase, iSegmentZ + iAdjustBase, iAdjustBase * 2 do
                                if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                                    if tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] then
                                        iNewLandLabel = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ))
                                        if iNewLandLabel == iOurLandLabel then
                                            iNewLandZone = tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
                                            AddLocationToPlateauExceptions(tEnemyBase, iOurPlateau, iNewLandZone)
                                            break
                                        end
                                    end
                                end
                            end
                            if iNewLandZone then break end
                        end
                        if iNewLandZone then break end
                        --Then do the left and right row (excl corners which ahve already done per the above)
                        for iCurSegmentX = iSegmentX - iAdjustBase, iSegmentX + iAdjustBase, iAdjustBase * 2 do
                            for iCurSegmentZ = iSegmentZ - iAdjustBase + 1, iSegmentZ + iAdjustBase - 1, 1 do
                                if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                                    if tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] then
                                        iNewLandLabel = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ))
                                        if iNewLandLabel == iOurLandLabel then
                                            iNewLandZone = tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
                                            AddLocationToPlateauExceptions(tEnemyBase, iOurPlateau, iNewLandZone)
                                            break
                                        end
                                    end
                                end
                            end
                            if iNewLandZone then break end
                        end
                        if iNewLandZone then break end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for overrides, iNewLandZone='..(iNewLandZone or 'nil')) end
                end
            end

            --Below is from M27 - not sure if still need it; it is also based in part on how long since we last scouted the location with an air scout and whether there were any enemy buildings there, but land zone logic should give an alternative way of checking if any buildings there
            --[[if aiBrain.M28AI then
            --Consider if we want to check for alternative locations to the actual enemy start:
            --Have we recently checked for a base location; --Do we have at least T2 (as a basic guide that this isn't the start of the game), has at least 3m of gametime elapsed, and have scouted the enemy base location recently, and have built at least 1 air scout this game?
            if GetGameTimeSeconds() - (aiBrain[refiLastTimeCheckedEnemyBaseLocation] or -1000) >= 10 and GetGameTimeSeconds() >= 180 then
                --(below includes alternative condition just in case there are strange unit restrictions)
                if M28Utilities.IsTableEmpty(ScenarioInfo.Options.RestrictedCategories) or (GetGameTimeSeconds() >= 600 or (aiBrain[M28Economy.refiOurHighestFactoryTechLevel] >= 2 and not(M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryAirScout) < 2))) then
                    if not(IsEnemyStartPositionValid(aiBrain, tEnemyBase)) then
                        aiBrain[reftPrimaryEnemyBaseLocation] = nil
                        local iNearestEnemyBase = 10000
                        local tNearestEnemyBase
                        --Cycle through every valid enemy brain and pick the nearest one, if there is one
                        if bDebugMessages == true then LOG(sFunctionRef..': Will cycle through each brain to identify nearest enemy base') end
                        for iCurBrain, brain in ArmyBrains do
                            if not(brain == aiBrain) and not(M28Logic.IsCivilianBrain(brain)) and IsEnemy(brain:GetArmyIndex(), aiBrain:GetArmyIndex()) and (not(brain:IsDefeated() and not(brain.M28IsDefeated)) or not(ScenarioInfo.Options.Victory == "demoralization")) then
                                if M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[brain:GetArmyIndex()], PlayerStartPoints[aiBrain:GetArmyIndex()]) < iNearestEnemyBase then
                                    if IsEnemyStartPositionValid(aiBrain, PlayerStartPoints[brain:GetArmyIndex()]) then
                                        iNearestEnemyBase = M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[brain:GetArmyIndex()], PlayerStartPoints[aiBrain:GetArmyIndex()])
                                        tNearestEnemyBase = {PlayerStartPoints[brain:GetArmyIndex()][1], PlayerStartPoints[brain:GetArmyIndex()][2], PlayerStartPoints[brain:GetArmyIndex()][3]}
                                    end
                                end
                            end
                        end
                        aiBrain[reftPrimaryEnemyBaseLocation] = tNearestEnemyBase
                        if not(aiBrain[reftPrimaryEnemyBaseLocation]) then
                            local tiCategoriesToConsider = {M28UnitInfo.refCategoryExperimentalStructure + M28UnitInfo.refCategorySML + M28UnitInfo.refCategoryFixedT3Arti, M28UnitInfo.refCategoryT3Mex, M28UnitInfo.refCategoryT2Mex, M28UnitInfo.refCategoryAirFactory + M28UnitInfo.refCategoryLandFactory}
                            local tEnemyUnits
                            tNearestEnemyBase = nil
                            for iRef, iCategory in tiCategoriesToConsider do
                                tEnemyUnits = aiBrain:GetUnitsAroundPoint(iCategory, PlayerStartPoints[aiBrain:GetArmyIndex()], 10000, 'Enemy')
                                if M28Utilities.IsTableEmpty(tEnemyUnits) == false then
                                    tNearestEnemyBase = M28Utilities.GetNearestUnit(tEnemyUnits, PlayerStartPoints[aiBrain:GetArmyIndex()], aiBrain, nil, nil):GetPosition()
                                    break
                                end
                            end
                            if tNearestEnemyBase then aiBrain[reftPrimaryEnemyBaseLocation] = tNearestEnemyBase
                            else
                                --Cant find anywhere so just pick the furthest away enemy start location
                                iNearestEnemyBase = 10000
                                for iCurBrain, brain in ArmyBrains do
                                    if not(brain == aiBrain) and not(M28Logic.IsCivilianBrain(brain)) and IsEnemy(brain:GetArmyIndex(), aiBrain:GetArmyIndex()) then
                                        if M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[brain:GetArmyIndex()], PlayerStartPoints[aiBrain:GetArmyIndex()]) < iNearestEnemyBase then
                                            iNearestEnemyBase = M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[brain:GetArmyIndex()], PlayerStartPoints[aiBrain:GetArmyIndex()])
                                            tNearestEnemyBase = {PlayerStartPoints[brain:GetArmyIndex()][1], PlayerStartPoints[brain:GetArmyIndex()][2], PlayerStartPoints[brain:GetArmyIndex()][3]}
                                        end
                                    end
                                end
                                aiBrain[reftPrimaryEnemyBaseLocation] = tNearestEnemyBase
                            end
                        end
                    end
                end
            end
        end--]]
        end
        --Have we changed position and are dealing with an M28 brain?
        if aiBrain.M28AI and not(tPrevPosition[1] == aiBrain[reftPrimaryEnemyBaseLocation][1] and tPrevPosition[3] == aiBrain[reftPrimaryEnemyBaseLocation][3]) then
            --We have changed position so update any global variables that reference this
            if bDebugMessages == true then LOG(sFunctionRef..': Will update whether we can path to enemy') end
            ForkThread(SetWhetherCanPathToEnemy, aiBrain)
        end

        aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] = M28Utilities.GetDistanceBetweenPositions(GetPlayerStartPosition(aiBrain), aiBrain[reftPrimaryEnemyBaseLocation])

    elseif bDebugMessages == true then LOG(sFunctionRef..': Dealing with a civilian brain')
    end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, primary enemy base location='..repru(aiBrain[reftPrimaryEnemyBaseLocation])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetPrimaryEnemyBaseLocation(aiBrain)
    --Returns a table {x,y,z} - usually this is the start position of the nearest enemy base.  However in certain cases it will be different
    --Used as the main location for the AI to evaluate things such as threats and make decisions; by default will be the nearest enemy start position

    --Done as a function so easier to adjust in the future if decide we want to
    if not(aiBrain[reftPrimaryEnemyBaseLocation]) then UpdateNewPrimaryBaseLocation(aiBrain) end
    return aiBrain[reftPrimaryEnemyBaseLocation]
end

function AddLocationToPlateauExceptions(tLocation, iPlateau, iLandZone)
    local iX = math.floor(tLocation[1])
    local iZ = math.floor(tLocation[3])
    if not(tPathingPlateauAndLZOverride[iX]) then tPathingPlateauAndLZOverride[iX] = {} end
    if not(math.floor(iLandZone) == iLandZone) then M28Utilities.ErrorHandler('Land zone isnt rounded', false, true) end
    tPathingPlateauAndLZOverride[iX][iZ] = {iPlateau, iLandZone}
end

function ClearTemporarySetupVariables()
    --Free up memory by clearing global variables used for map setup
    WaitTicks(10) --As basicp rotection in case any functions are still running
    tbTempConsideredLandPathingForLZ = {}
end

function CreateNewPond(iPond)
    tPondDetails[iPond] = {}
    tPondDetails[iPond][subreftiWaterSegmentXZ] = {}

    tPondDetails[iPond][subrefPondMinX] = 100000
    tPondDetails[iPond][subrefPondMinZ] = 100000
    tPondDetails[iPond][subrefPondMaxX] = 0
    tPondDetails[iPond][subrefPondMaxZ] = 0
    tPondDetails[iPond][subrefiSegmentCount] = 0
    --tPondDetails[iPond][subrefPondNearbyBrains] = {}
    tPondDetails[iPond][subrefPondMidpoint] = {}
    tPondDetails[iPond][subrefPondMexInfo] = {}
    tPondDetails[iPond][subrefPondWZCount] = 0
end

function RecordNavalSegment(iPond, iBaseSegmentX, iBaseSegmentZ, tSegmentPosition)
    --Called from logic for land creation that cycles through every segment on the map
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RecordNavalSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if not(tPondDetails[iPond]) then
        CreateNewPond(iPond)
    end
    table.insert(tPondDetails[iPond][subreftiWaterSegmentXZ], {iBaseSegmentX, iBaseSegmentZ})
    if not(tPondBySegment[iBaseSegmentX]) then tPondBySegment[iBaseSegmentX] = {} end
    tPondBySegment[iBaseSegmentX][iBaseSegmentZ] = iPond
    iTotalSegmentsInPonds = iTotalSegmentsInPonds + 1
    tPondDetails[iPond][subrefiSegmentCount] = tPondDetails[iPond][subrefiSegmentCount] + 1

    tPondDetails[iPond][subrefPondMinX] = math.min(tPondDetails[iPond][subrefPondMinX], tSegmentPosition[1])
    tPondDetails[iPond][subrefPondMinZ] = math.min(tPondDetails[iPond][subrefPondMinZ], tSegmentPosition[3])
    tPondDetails[iPond][subrefPondMaxX] = math.max(tPondDetails[iPond][subrefPondMaxX], tSegmentPosition[1])
    tPondDetails[iPond][subrefPondMaxZ] = math.max(tPondDetails[iPond][subrefPondMaxZ], tSegmentPosition[3])
    if bDebugMessages == true then LOG(sFunctionRef..': Finished recording naval segment for pond '..iPond..'; Segment count for this point='..tPondDetails[iPond][subrefiSegmentCount]..'; Size of tPondDetails[iPond][subreftiWaterSegmentXZ]='..table.getn(tPondDetails[iPond][subreftiWaterSegmentXZ])..'; iBaseSegmentX='..(iBaseSegmentX or 'nil')..'; iBaseSegmentZ='..(iBaseSegmentZ or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordPondDetails()
    --Call after recording all pathfinding for the map, so after we have recorded all naval segments against ponds
    --intended to record key information on any ponds of interest, in particular mexes that can be hit from the pond (and the range required)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RecordPondDetails'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tbUnderwaterGroup = {}
    local tSegmentPosition

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code. Does map have water? Water height(0 means no water)='..iMapWaterHeight) end

    if iMapWaterHeight > 0 then
        --Record the size and dimensions of every pond
        local iMaxMexDist = 200 --range of aeon missile ship
        local iPondMexCount
        local iCurMexDist
        local tiDistToTry = { 24, 40, 56, 88, 120, 145, iMaxMexDist }
        local bInRange
        local iAngleInterval = 45
        local tPossibleWaterPosition
        local iPrevDist
        local tShotStartPosition
        local tShotEndPosition
        local iAOE
        local iPotentialSegmentX, iPotentialSegmentZ

        --Want a brain in case we end up using the alternative 'line is blocked' built in functionality
        local aiBrain
        for iBrain, oBrain in ArmyBrains do
            if oBrain.M28AI then
                aiBrain = oBrain
                break
            end
        end
        if not (aiBrain) then
            for iBrain, oBrain in ArmyBrains do
                aiBrain = oBrain
                break
            end
        end

        --Record every pond that has mexes (as an override for pond size)
        local tiMexesByPond = {}
        if M28Utilities.IsTableEmpty(tMassPoints) == false then
            local iCurPond
            for iMex, tMex in tMassPoints do
                if tMex[2] < iMapWaterHeight then
                    iCurPond = NavUtils.GetTerrainLabel(refPathingTypeNavy, tMex)
                    if iCurPond then
                        tiMexesByPond[iCurPond] = (tiMexesByPond[iCurPond] or 0) + 1
                    end
                end

            end
        end

        for iPond, tPondSubtable in tPondDetails do
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Considering pond group ' .. iPond .. '; Pond size=' .. (tPondSubtable[subrefiSegmentCount] or 'nil')..'; iMinPondSize='..(iMinPondSize or 'nil')..'; tiMexesByPond='..repru(tiMexesByPond))
            end

            tPondSubtable[subrefPondMidpoint] = { (tPondDetails[iPond][subrefPondMinX] + tPondDetails[iPond][subrefPondMaxX]) * 0.5, iMapWaterHeight, (tPondDetails[iPond][subrefPondMinZ] + tPondDetails[iPond][subrefPondMaxZ]) * 0.5 }
            if (tPondSubtable[subrefiSegmentCount] or 0) >= iMinPondSize or (tiMexesByPond[iPond] or 0) > 0 then
                --Pond is large enough for us to consider tracking; record information of interest for the pond:
                iPondMexCount = 0
                if bDebugMessages == true then LOG(sFunctionRef .. ': Recording pond, will check how many mexes are nearby. Pond midpoint=' .. repru(tPondSubtable[subrefPondMidpoint]) .. '; Pond min X-Z=' .. tPondDetails[iPond][subrefPondMinX] .. '-' .. tPondDetails[iPond][subrefPondMinZ] .. '; Max X-Z=' .. tPondDetails[iPond][subrefPondMaxX] .. '-' .. tPondDetails[iPond][subrefPondMaxZ]) end

                --Details of all mexes near enough to the pond to be of interest
                for iMex, tMex in tMassPoints do
                    bInRange = false
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if tMex '..repru(tMex)..' is close enough to Pond='..iPond..'; Pond minX='..tPondSubtable[subrefPondMinX]..'; MaxX='..tPondSubtable[subrefPondMaxX]..'; Pond minZ='..tPondSubtable[subrefPondMinZ]..'; Mond max Z='..tPondSubtable[subrefPondMaxZ]) end

                    if tMex[1] >= tPondSubtable[subrefPondMinX] - iMaxMexDist and tMex[1] <= tPondSubtable[subrefPondMaxX] + iMaxMexDist and tMex[3] >= tPondSubtable[subrefPondMinZ] - iMaxMexDist and tMex[3] <= tPondSubtable[subrefPondMaxZ] + iMaxMexDist then
                        --See how far away the water is
                        for iEntry, iDist in tiDistToTry do
                            for iAngleAdjust = iAngleInterval, 360, iAngleInterval do
                                tPossibleWaterPosition = M28Utilities.MoveInDirection(tMex, iAngleAdjust, iDist, true, true, false) --Gets terrainheight rather than surface height
                                if bDebugMessages == true then
                                    local iTempSegmentX, iTempSegmentZ = GetPathingSegmentFromPosition(tPossibleWaterPosition)
                                    LOG(sFunctionRef..': Considering mex '..repru(tMex)..'; iDist='..iDist..'; iAngleAdjust='..iAngleAdjust..'; tPossibleWaterPosition='..repru(tPossibleWaterPosition)..'; Is underwater='..tostring(IsUnderwater(tPossibleWaterPosition, false, iMinWaterDepth))..'; Pond for the segment at this position='..(tPondBySegment[iTempSegmentX][iTempSegmentZ] or 'nil'))
                                end
                                if IsUnderwater(tPossibleWaterPosition, false, iMinWaterDepth) then
                                    --NOTE: We wont have water zone segments setup yet so cant refer to WZ by segment, only pond by segemnt
                                    iPotentialSegmentX, iPotentialSegmentZ = GetPathingSegmentFromPosition(tPossibleWaterPosition)
                                    if tPondBySegment[iPotentialSegmentX][iPotentialSegmentZ] == iPond then
                                        --Have a match, record the mex details:
                                        bInRange = true
                                        iCurMexDist = iDist

                                        --Record initial mex details:
                                        iPondMexCount = iPondMexCount + 1
                                        tPondSubtable[subrefPondMexInfo][iPondMexCount] = {}
                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexLocation] = { tMex[1], tMex[2], tMex[3] }

                                        --Do we expect to be able to hit the mex from here? a UEF Frigate y height is 1.1, while a t1 mex is 1.4; cant be bothered to check height of weapon and mex bone, and will vary based on how far away we are as well
                                        tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                                        tShotEndPosition = { tMex[1], tMex[2] + 1.1, tMex[3] }

                                        iAOE = 0
                                        if iCurMexDist >= 30 then
                                            iAOE = 1
                                        end --most destroyers have an aoe attack (except sera)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have a mex that is near water, will see if expect to hit it from the water position? islineblocked='..tostring(M28Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, iAOE))) end
                                        if M28Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, iAOE) then
                                            tShotStartPosition[2] = tShotStartPosition[2] + 8
                                            tShotEndPosition[2] = tShotEndPosition[2] + 8
                                            if M28Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, 1) then
                                                --cant hit with df or indirect
                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] = 10000
                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = 10000
                                            else
                                                --Can hit with indirect but not DF, so consider whether if we move further back we can then hit
                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] = iCurMexDist
                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}

                                                --Find the point at which DF can hit, if any, in intervals of 5, assuming at max range we can hit
                                                local iMaxDistAdjust = math.max(5, math.min(100, math.floor((150 - iCurMexDist) / 5) * 5))
                                                tPossibleWaterPosition = M28Utilities.MoveInDirection(tMex, iAngleAdjust, iDist + iMaxDistAdjust, true, true, false)
                                                if IsUnderwater(tPossibleWaterPosition, false, iMinWaterDepth) then

                                                    tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                                                    if M28Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, 1) then
                                                        --Assume wont find any match
                                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = 10000
                                                    else
                                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = iDist + iMaxDistAdjust
                                                        --Refine the distance by moving closer
                                                        for iDFDistAdjust = 5, math.max(5, math.min(100, math.floor((150 - iCurMexDist) / 5) * 5)), 5 do
                                                            tPossibleWaterPosition = M28Utilities.MoveInDirection(tMex, iAngleAdjust, iDist + iDFDistAdjust, true, true, false)
                                                            tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                                                            if not (M28Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, 1)) then
                                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = iDist + iDFDistAdjust
                                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}
                                                                break
                                                            end
                                                        end
                                                    end
                                                else
                                                    --Assume wont find any match as if move really far back we are not on water
                                                    tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = 10000
                                                end
                                            end

                                            if bDebugMessages == true and tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] then
                                                LOG(sFunctionRef .. ' Drawing start in white and end in orangy pink')
                                                M28Utilities.DrawLocation({ tShotStartPosition[1], tShotStartPosition[2] - 8, tShotStartPosition[3] }, 7, 100, nil)
                                                M28Utilities.DrawLocation({ tShotEndPosition[1], tShotEndPosition[2] - 8, tShotEndPosition[3] }, 8, 100, nil)
                                            end
                                        else
                                            --DF can hit from cur position so assume indirect can as well
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = iCurMexDist
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] = iCurMexDist
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}
                                        end

                                        --Refine the distance - see if can get any closer
                                        if iEntry == 1 then
                                            iPrevDist = 0
                                        else
                                            iPrevDist = tiDistToTry[iEntry - 1]
                                        end
                                        for iShortDist = iPrevDist + 1, iDist - 1, 1 do
                                            tPossibleWaterPosition = M28Utilities.MoveInDirection(tMex, iAngleAdjust, iDist, true, false, false)
                                            if IsUnderwater(tPossibleWaterPosition, false, iMinWaterDepth) then
                                                iCurMexDist = iShortDist
                                                break
                                            end
                                        end

                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDistance] = iCurMexDist

                                        if bDebugMessages == true then LOG(sFunctionRef .. ': Finished recording mex in range for pond ' .. iPond .. '; iPondMexCount=' .. iPondMexCount .. '; full mex table of info=' .. repru(tPondSubtable[subrefPondMexInfo][iPondMexCount])) end
                                        break
                                    end
                                end
                            end
                            if bInRange then
                                break
                            end
                        end
                    end
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Considered Mex ' .. repru(tMex) .. '; bInRange=' .. tostring(bInRange))
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording all ponds, repr='..reprs(tPondDetails)) end
    end
    bHaveRecordedPonds = true
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordPondToExpandTo(aiBrain)
    --Calculates which pond we think is most important to hold; assumes we have already recorded all segments and ponds (but havent yet setup water zones)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RecordPondToExpandTo'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    bHaveConsideredPreferredPondForM28AI = true
    if bDebugMessages == true then LOG(sFunctionRef..': Starting RecordPondToExpandTo at '..GetGameTimeSeconds()..' for brain '..aiBrain.Nickname..', Is table of pond details empty='..tostring(M28Utilities.IsTableEmpty(tPondDetails))..'; bHaveRecordedPonds='..tostring(bHaveRecordedPonds)..'; Brain team='..(aiBrain.M28Team or 'nil')) end
    GetPrimaryEnemyBaseLocation(aiBrain)
    local iWaitCount = 0
    while not(bHaveRecordedPonds) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        iWaitCount = iWaitCount + 1
        if iWaitCount >= 20 then break end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting, time='..GetGameTimeSeconds()..'; Is table of pond details empty='..tostring(M28Utilities.IsTableEmpty(tPondDetails))..'; bHaveRecordedPonds='..tostring(bHaveRecordedPonds)) end
    if M28Utilities.IsTableEmpty(tPondDetails) == false then
        local bStartLocationIsUnderwater = false
        local tStartPos = GetPlayerStartPosition(aiBrain)
        if GetTerrainHeight(tStartPos[1], tStartPos[3]) < GetSurfaceHeight(tStartPos[1], tStartPos[3]) then bStartLocationIsUnderwater = true end
        if bDebugMessages == true then
            local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
            LOG(sFunctionRef..': Considering aiBrain '..aiBrain.Nickname..' location for naval fac, bStartLocationIsUnderwater='..tostring(bStartLocationIsUnderwater)..'; tStartPos='..repru(tStartPos)..'; Terrain height='..GetTerrainHeight(tStartPos[1], tStartPos[3])..'; Surface height='..GetSurfaceHeight(tStartPos[1], tStartPos[3])..'; aiBrain[M28Overseer.refiDistanceToNearestEnemyBase]='..(aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] or 'nil')..'; Brain index='..aiBrain:GetArmyIndex()..'; reprs of start poitns='..reprs(PlayerStartPoints)..'; refbInitialised='..tostring(aiBrain[M28Overseer.refbInitialised] or false)..'; GameTime='..GetGameTimeSeconds())
        end
        local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
        aiBrain[M28Navy.reftiPondThreatToUs] = {}
        aiBrain[M28Navy.reftiPondValueToUs] = {}
        local iCurPondValue
        local iCurPondDefensiveValue --Value of mexes that are threatened by enemy if they get navy
        local iBestPondValue = 0
        local iBestPondRef

        local iDistanceThreshold = math.max(138, math.min(180, aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.35), math.min(math.max(iMapSize * 0.2, aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.5), iMapSize * 0.25, 400))

        if not(aiBrain[refbCanPathToEnemyBaseWithLand]) then iDistanceThreshold = iDistanceThreshold + 50 end
        if bIsCampaignMap then iDistanceThreshold = iDistanceThreshold + 50 end

        local iFrigateRange = 28
        local iDestroyerRange = 60
        local iBattleshipRange = 128
        local iMissileShipRange = 150
        local iFrigateValue = 1
        local iDestroyerValue = 0.8
        local iBattleshipValue = 0.45
        local iMissileShipValue = 0.6

        local iEnemyDestroyerRange = 60
        local iEnemyBattleshipRange = 128
        local iEnemyMissileShipRange = 150


        if aiBrain:GetFactionIndex() == M28UnitInfo.refFactionUEF then
            iBattleshipRange = 150
        elseif aiBrain:GetFactionIndex() == M28UnitInfo.refFactionCybran then
            iDestroyerRange = 80
            iMissileShipRange = 0
        elseif aiBrain:GetFactionIndex() == M28UnitInfo.refFactionAeon then
            iMissileShipRange = 200
            iMissileShipValue = iBattleshipValue
            --Seraphim - no change to default
        end

        local iEnemyBrainIndex = M28Logic.GetNearestEnemyIndex(aiBrain)
        if iEnemyBrainIndex == M28UnitInfo.refFactionUEF then
            iEnemyBattleshipRange = 150
        elseif iEnemyBrainIndex == M28UnitInfo.refFactionCybran then
            iEnemyDestroyerRange = 80
            iEnemyMissileShipRange = 0
        elseif iEnemyBrainIndex == M28UnitInfo.refFactionAeon then
            iEnemyMissileShipRange = 200
        end

        local iMinModDistanceWanted = math.max(155, aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.4)
        if bDebugMessages == true then LOG(sFunctionRef..': aiBrain='..aiBrain.Nickname..'; Start of logic to consider the best pond. iMinModDistanceWanted='..iMinModDistanceWanted..'; Dist to enemy base='..(aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] or 'nil')..'; iDistanceThreshold='..iDistanceThreshold) end
        local iMidModDistance = aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.5
        local iBelowMidFactor = 0.3 --Reudces value of mex that is closer to our base than enemy base to this %, assuming it is above the iMinModDistanceWanted
        local iCurMexValue
        local iCurMexDefensiveValue
        local iCurModDistance
        local iDefensiveModDistanceMaxValue = math.max(120, math.min(math.max(300, iMapSize * 0.4), aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.4))

        local iPathingGroupWanted = NavUtils.GetTerrainLabel(refPathingTypeHover, GetPlayerStartPosition(aiBrain))

        --Adjust the distance to search for ponds based on the closest dist to a teammate for larger ponds
        local iClosestTeammatePondDist = 10000

        function GetAverageDistToPond(tPondSubtable, oBrain)
            local iXVal
            local iZVal
            if (GetPlayerStartPosition(aiBrain)[1] >= tPondSubtable[subrefPondMinX] and GetPlayerStartPosition(aiBrain)[1] <= tPondSubtable[subrefPondMaxX]) then iXVal = 0
            else iXVal = math.min(math.abs(tPondSubtable[subrefPondMinX] - GetPlayerStartPosition(oBrain)[1]), math.abs(GetPlayerStartPosition(oBrain)[1] - tPondSubtable[subrefPondMaxX]))
            end
            if (GetPlayerStartPosition(aiBrain)[3] >= tPondSubtable[subrefPondMinZ] and GetPlayerStartPosition(aiBrain)[3] <= tPondSubtable[subrefPondMaxZ]) then iZVal = 0
            else iZVal = math.min(math.abs(tPondSubtable[subrefPondMinZ] - GetPlayerStartPosition(oBrain)[3]),  math.abs(GetPlayerStartPosition(oBrain)[3] - tPondSubtable[subrefPondMaxZ]))
            end
            return (iXVal + iZVal) * 0.5
        end
        for iCurPondRef, tPondSubtable in tPondDetails do
            if M28Utilities.IsTableEmpty(tPondSubtable) == false and (tPondSubtable[subrefiSegmentCount] or 0) >= iMinPondSize * 2 then
                for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyHumanAndAIBrains] do
                    iClosestTeammatePondDist = math.min(iClosestTeammatePondDist, GetAverageDistToPond(tPondSubtable, oBrain))
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to increase search dist for navy, iClosestTeammatePondDist='..iClosestTeammatePondDist..'; aiBrain[M28Overseer.refiDistanceToNearestEnemyBase]='..aiBrain[M28Overseer.refiDistanceToNearestEnemyBase]..'; iDistanceThreshold pre adjust='..iDistanceThreshold..'; iMapSize='..iMapSize..'; iDefensiveModDistanceMaxValue='..iDefensiveModDistanceMaxValue) end
        if iClosestTeammatePondDist <= math.max(math.min(iMapSize * 0.4, aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.75), math.min(iMapSize * 0.6, aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.5)) then
            iDistanceThreshold = math.max(iDistanceThreshold, iClosestTeammatePondDist + math.max(50, iMapSize * 0.1))
            if bDebugMessages == true then LOG(sFunctionRef..': Updated distancethreshold if it was lower, potentially revised value='..iDistanceThreshold) end
        end
        local bMexIsUnderwaterInPond = false

        for iCurPondRef, tPondSubtable in tPondDetails do
            aiBrain[M28Navy.reftiPondValueToUs][iCurPondRef] = 0
            aiBrain[M28Navy.reftiPondThreatToUs][iCurPondRef] = 0
            if M28Utilities.IsTableEmpty(tPondSubtable) == false and (tPondSubtable[subrefiSegmentCount] or 0) >= iMinPondSize then
                iCurPondValue = 0
                iCurPondDefensiveValue = 0
                if bDebugMessages == true then LOG(sFunctionRef..': iCurPondRef='..iCurPondRef..'; GetAverageDistToPond='..GetAverageDistToPond(tPondSubtable, aiBrain)..'; Dist of X to our start='..math.min(math.abs(tPondSubtable[subrefPondMinX] - GetPlayerStartPosition(aiBrain)[1]), math.abs(GetPlayerStartPosition(aiBrain)[1] - tPondSubtable[subrefPondMaxX]))..'; Dist of Z to our start='..math.min(math.abs(tPondSubtable[subrefPondMinZ] - GetPlayerStartPosition(aiBrain)[3]),  math.abs(GetPlayerStartPosition(aiBrain)[3] - tPondSubtable[subrefPondMaxZ]))..'; MaxX='..tPondSubtable[subrefPondMaxX]..'Z='..tPondSubtable[subrefPondMaxZ]..'; MinX='..tPondSubtable[subrefPondMinX]..'Z='..tPondSubtable[subrefPondMinZ]..'; Mex info='..repru(tPondSubtable[subrefPondMexInfo])..'; Midpoint='..repru(tPondSubtable[subrefPondMidpoint])..'; Segment count='..tPondSubtable[subrefiSegmentCount]) end

                --Is the pond within 175 of our start position?  First see if X is within distance threshold:
                if GetAverageDistToPond(tPondSubtable, aiBrain) <= iDistanceThreshold then
                    --X and Z are in range
                    if bDebugMessages == true then LOG(sFunctionRef..': repru of pond mex info='..repru(tPondSubtable[subrefPondMexInfo])) end

                    for iMex, tMexInfo in tPondSubtable[subrefPondMexInfo] do
                        iCurMexValue = 0
                        iCurMexDefensiveValue = 0
                        bMexIsUnderwaterInPond = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iMex='..iMex..' for pond '..iCurPondRef..'; tMexInfo[subrefMexDFDistance]='..(tMexInfo[subrefMexDFDistance] or 'nil')..'; tMexInfo[subrefMexIndirectDistance]='..(tMexInfo[subrefMexIndirectDistance] or 'nil')..'; Is mex underwater='..tostring(IsUnderwater(tMexInfo[subrefMexLocation]))) end
                        if tMexInfo[subrefMexDFDistance] <= iBattleshipRange or tMexInfo[subrefMexIndirectDistance] <= iMissileShipRange then
                            --Can reach this mex with a ship, so it will have at least some value
                            if tMexInfo[subrefMexDFDistance] <= iFrigateRange then iCurMexValue = iFrigateValue
                            elseif tMexInfo[subrefMexDFDistance] <= iDestroyerRange then iCurMexValue = iDestroyerValue
                            elseif tMexInfo[subrefMexIndirectDistance] <= iMissileShipRange then iCurMexValue = iMissileShipValue
                            else iCurMexValue = iBattleshipValue
                            end
                        end
                        --If mex is underwater then give it frigate value
                        if IsUnderwater(tMexInfo[subrefMexLocation]) then
                            --If same pond then give it frigate value - doublecheck to be safe
                            local iCurMexWaterZone = GetWaterZoneFromPosition(tMexInfo[subrefMexLocation])
                            if iCurMexWaterZone and tiPondByWaterZone[iCurMexWaterZone] == iCurPondRef then
                                if bDebugMessages == true then LOG(sFunctionRef..': Mex is underwater and in same pond') end
                                bMexIsUnderwaterInPond = true
                                if iCurMexValue < iFrigateValue then iCurMexValue = iFrigateValue end
                            end
                        end

                        --Adjust mex value based on distance
                        iCurModDistance = GetModDistanceFromStart(aiBrain, tMexInfo[subrefMexLocation])
                        if iCurMexValue > 0 then
                            local tMexWZData, tMexWZTeamData = GetLandOrWaterZoneData(tMexInfo[subrefMexLocation], true, aiBrain.M28Team)
                            if iCurModDistance <  iMinModDistanceWanted then iCurMexValue = 0 --i.e. dont want to value mexes on our 'half' of the map
                            else
                                if iCurModDistance < iMidModDistance then
                                    iCurMexValue = iCurMexValue * iBelowMidFactor
                                end
                            end
                            iCurPondValue = iCurPondValue + iCurMexValue
                            if bDebugMessages == true then LOG(sFunctionRef..': Adjusting mex value based on mod distance, iCurModDistance='..iCurModDistance..'; iMinModDistanceWanted='..iMinModDistanceWanted..'; iCurMexValue='..iCurMexValue..'; Mod dist%='..(tMexWZTeamData[refiModDistancePercent] or 'nil')) end
                        end


                        --Get defensive value
                        if iCurModDistance <= iDefensiveModDistanceMaxValue then
                            if bMexIsUnderwaterInPond then iCurMexDefensiveValue = iFrigateValue
                            elseif tMexInfo[subrefMexDFDistance] <= iEnemyBattleshipRange or tMexInfo[subrefMexIndirectDistance] <= iEnemyMissileShipRange then
                                --Can reach this mex with a ship, so it will have at least some value
                                if tMexInfo[subrefMexDFDistance] <= iFrigateRange then iCurMexDefensiveValue = iFrigateValue
                                elseif tMexInfo[subrefMexDFDistance] <= iEnemyDestroyerRange then iCurMexDefensiveValue = iDestroyerValue
                                elseif tMexInfo[subrefMexIndirectDistance] <= iEnemyMissileShipRange then iCurMexDefensiveValue = iMissileShipValue
                                else iCurMexDefensiveValue = iBattleshipValue
                                end

                            end

                        end
                        if bMexIsUnderwaterInPond and iCurMexDefensiveValue < 1 and iCurMexValue == 0 then
                            iCurMexDefensiveValue = 0.5
                            if bDebugMessages == true then LOG(sFunctionRef..': Have far away underwater mex in the pond, will assign it half value') end
                        end
                        if iCurMexDefensiveValue > 0 then
                            iCurPondDefensiveValue = iCurPondDefensiveValue + iCurMexDefensiveValue
                        end
                    end

                    --Increase vlaue if in part of pond likely to be near enemy base
                    local tEnemyBase = GetPrimaryEnemyBaseLocation(aiBrain)
                    local iEnemyBaseThreshold = math.max(iBattleshipRange, iMissileShipRange - 10)
                    if math.abs(tPondSubtable[subrefPondMinX] - tEnemyBase[1]) <= iEnemyBaseThreshold or math.abs(tEnemyBase[1] - tPondSubtable[subrefPondMaxX]) <= iEnemyBaseThreshold or (tEnemyBase[1] >= tPondSubtable[subrefPondMinX] and tEnemyBase[1] <= tPondSubtable[subrefPondMaxX]) then
                        --X is in range, is Z?
                        if math.abs(tPondSubtable[subrefPondMinZ] - tEnemyBase[3]) <= iEnemyBaseThreshold or math.abs(tEnemyBase[3] - tPondSubtable[subrefPondMaxZ]) <= iEnemyBaseThreshold or (tEnemyBase[3] >= tPondSubtable[subrefPondMinZ] and tEnemyBase[3] <= tPondSubtable[subrefPondMaxZ]) then
                            iCurPondValue = math.max(iCurPondValue * 1.2, iCurPondValue + 2)
                            if bDebugMessages == true then LOG(sFunctionRef..': Can probably hit enemy base with navy so increasing pond value by 20%, iEnemyBaseThreshold='..iEnemyBaseThreshold) end
                        end
                    end

                    --Increase value for massive ponds
                    if tPondSubtable[subrefiSegmentCount] >= 10000 then
                        if tPondSubtable[subrefiSegmentCount] >= 50000 or tPondSubtable[subrefPondMaxX] + tPondSubtable[subrefPondMaxZ] - tPondSubtable[subrefPondMinX] - tPondSubtable[subrefPondMinZ] >= 0.5 * iMapSize then
                            if bIsCampaignMap then iCurPondValue = iCurPondValue + 1 end
                            iCurPondValue = iCurPondValue * 1.5
                        end
                    end

                    --Increase value for campaign maps or maps where we cant path to the enemy by land but can by water
                    if bIsCampaignMap then iCurPondValue = iCurPondValue * 2 end
                    if aiBrain[refbCanPathToEnemyBaseWithAmphibious] and not(aiBrain[refbCanPathToEnemyBaseWithLand]) then iCurPondValue = iCurPondValue * 4 end
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a pond that is in range of our start position, value based on mexes in range pre main adjust (but post adjusting for campaign and pathing)='..iCurPondValue..'; aiBrain[refbCanPathToEnemyBaseWithAmphibious]='..tostring(aiBrain[refbCanPathToEnemyBaseWithAmphibious] or false)..'; aiBrain[refbCanPathToEnemyBaseWithLand]='..tostring(aiBrain[refbCanPathToEnemyBaseWithLand] or false)) end
                    --Do we have sufficient value to consider?
                    if iCurPondValue >= 4 or iCurPondDefensiveValue >= 4 or bStartLocationIsUnderwater then
                        if iCurPondValue <= 0 then iCurPondValue = 0.1 end --Pond has defensive value so greater than 0
                        --Adjust value based on how close the naval build location would be for this pond
                        if not(tPondSubtable[subrefBuildLocationByStartPosition]) then
                            tPondSubtable[subrefBuildLocationByStartPosition] = {}
                        end
                        local tNavalBuildArea = {}
                        if not(bStartLocationIsUnderwater) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Brain='..aiBrain.Nickname..'; Index='..aiBrain:GetArmyIndex()..'; Start point='..repru(PlayerStartPoints[aiBrain:GetArmyIndex()])..'; Midpoint of pond='..repru(tPondSubtable[subrefPondMidpoint])..'; iCurPondRef='..(iCurPondRef or 'nil')) end
                            local iAngleToCentre = M28Utilities.GetAngleFromAToB(GetPlayerStartPosition(aiBrain), tPondSubtable[subrefPondMidpoint])
                            local iDistInterval = 8
                            local iBuildingInterval = 4
                            local tPossibleLocationBase
                            local tPossibleBuildLocation
                            local bHaveValidLocation = false
                            if bDebugMessages == true then LOG(sFunctionRef..': About to search for location to build naval factory for iCurPondRef='..iCurPondRef..'; iDistInterval='..iDistInterval..'; Angle='..iAngleToCentre..'; Midpoint='..repru(tPondSubtable[subrefPondMidpoint])..'; Start position='..repru(PlayerStartPoints[aiBrain:GetArmyIndex()])) end
                            tNavalBuildArea = GetNearestWaterToBuildNavalFactoryInPlayableArea(aiBrain, GetPlayerStartPosition(aiBrain), iDistInterval, iCurPondRef, iAngleToCentre)
                            --[[for iDistToTravel = iDistInterval, math.max(iDistInterval, math.floor(M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[aiBrain:GetArmyIndex()], tPondSubtable[subrefPondMidpoint]) / iDistInterval) * iDistInterval), iDistInterval do
                                for iAngleAdjust = 0, 170, 10 do
                                    for iAngleFactor = -1, 1, 2 do
                                        tPossibleLocationBase = M28Utilities.MoveInDirection(PlayerStartPoints[aiBrain:GetArmyIndex()], iAngleToCentre + iAngleAdjust * iAngleFactor, iDistToTravel, true, true, false)
                                        if NavUtils.GetTerrainLabel(refPathingTypeNavy, tPossibleLocationBase) == iCurPondRef then
                                            --Try and find somewhere around here to build a naval factory
                                            for iBuildingAdjustX = 0, iBuildingInterval, 1 do
                                                for iBuildingAdjustZ = 0, iBuildingInterval, 1 do
                                                    for iXFactor = -1, 1, 2 do
                                                        for iZFactor = -1, 1, 2 do
                                                            tPossibleBuildLocation = {tPossibleLocationBase[1] + iBuildingAdjustX * iXFactor, 0, tPossibleLocationBase[3] + iBuildingAdjustZ * iZFactor}
                                                            tPossibleBuildLocation[2] = GetSurfaceHeight(tPossibleBuildLocation[1], tPossibleBuildLocation[3])
                                                            if aiBrain:CanBuildStructureAt('ueb0103', tPossibleBuildLocation) then
                                                                bHaveValidLocation = true
                                                                tNavalBuildArea = {tPossibleBuildLocation[1], tPossibleBuildLocation[2], tPossibleBuildLocation[3]}
                                                                if bDebugMessages == true then
                                                                    LOG(sFunctionRef..': Have valid location='..repru(tPossibleBuildLocation)..'; will draw in white')
                                                                    M28Utilities.DrawLocation(tPossibleBuildLocation, 1, 100, 2)
                                                                end
                                                                break
                                                            else
                                                                if bDebugMessages == true then
                                                                    LOG(sFunctionRef..': Have invalid location='..repru(tPossibleBuildLocation)..'; will draw in red')
                                                                    M28Utilities.DrawLocation(tPossibleBuildLocation, 2, 100, 2)
                                                                end
                                                            end
                                                        end
                                                        if bHaveValidLocation then break end
                                                    end
                                                    if bHaveValidLocation then break end

                                                end
                                                if bHaveValidLocation then break end
                                            end
                                            if iAngleAdjust == 0 or bHaveValidLocation then break end
                                        elseif bDebugMessages == true then
                                            LOG(sFunctionRef..': Failed tPossibleLocationBase pathing group, tPossibleLocationBase='..repru(tPossibleLocationBase)..'; naval label='..(NavUtils.GetTerrainLabel(refPathingTypeNavy, tPossibleLocationBase) or 'nil')..'; iCurPondRef='..iCurPondRef..'; iPathingGroupWanted='..iPathingGroupWanted..'; will draw in gold')
                                            M28Utilities.DrawLocation(tPossibleLocationBase, 4, 100, 2)
                                        end
                                        if bHaveValidLocation then break end
                                    end
                                    if bHaveValidLocation then break end
                                end
                                if bHaveValidLocation then break end
                            end--]]
                        else
                            local iIndex = aiBrain:GetArmyIndex()
                            tNavalBuildArea = {PlayerStartPoints[iIndex][1], PlayerStartPoints[iIndex][2], PlayerStartPoints[iIndex][3]}
                        end

                        if bDebugMessages == true then LOG(sFunctionRef..': Finsihed searching for naval build area, is table empty='..tostring(M28Utilities.IsTableEmpty(tNavalBuildArea))) end


                        if M28Utilities.IsTableEmpty(tNavalBuildArea) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': tNavalBuildArea pre adjust='..repru(tNavalBuildArea)) end
                            --Move towards base to help with cliff building if we have cliffs
                            local bHaveNearbyCliff = false
                            local iDistToMoveTarget = M28Utilities.GetDistanceBetweenPositions(GetPlayerStartPosition(aiBrain), tNavalBuildArea)
                            local iAngleFromTarget = M28Utilities.GetAngleFromAToB(tNavalBuildArea, GetPlayerStartPosition(aiBrain))
                            local tCliffPositionCheck
                            local sPathing = refPathingTypeHover
                            local iStartPathingGroup = NavUtils.GetTerrainLabel(sPathing,GetPlayerStartPosition(aiBrain))

                            if iDistToMoveTarget > 1 then
                                for iDistAdjust = 1, math.min(13, math.floor(iDistToMoveTarget)) do
                                    tCliffPositionCheck = M28Utilities.MoveInDirection(tNavalBuildArea, iAngleFromTarget, iDistAdjust, true, false, false)
                                    if not(NavUtils.GetTerrainLabel(sPathing, tCliffPositionCheck) == iStartPathingGroup) then
                                        bHaveNearbyCliff = true
                                        break
                                    end

                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': bHaveNearbyCliff='..tostring(bHaveNearbyCliff)) end
                            if bHaveNearbyCliff then
                                --Try to move closer to base
                                local tLastValidPosition = {tNavalBuildArea[1], tNavalBuildArea[2], tNavalBuildArea[3]}
                                local tAlternativePosition

                                for iDistAdjust = 1, math.min(13, math.floor(iDistToMoveTarget)) do
                                    tAlternativePosition = M28Utilities.MoveInDirection(tNavalBuildArea, iAngleFromTarget, iDistAdjust, true, false, false)
                                    if not(NavUtils.GetTerrainLabel(refPathingTypeNavy, tAlternativePosition) == iCurPondRef) then
                                        break
                                    else
                                        --Can we build here?
                                        if aiBrain:CanBuildStructureAt('ueb0103', tAlternativePosition) then
                                            tLastValidPosition = {tAlternativePosition[1], tAlternativePosition[2], tAlternativePosition[3]}
                                            if bDebugMessages == true then LOG(sFunctionRef..': Have an alternative position that is closer to our base, iDistAdjust='..iDistAdjust) end
                                        else
                                            break
                                        end
                                    end
                                end
                                tNavalBuildArea = tLastValidPosition


                            end



                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Have a naval build area='..repru(tNavalBuildArea)..'; will draw large square around it in blue, and will set this as the build area for brain '..aiBrain.Nickname)
                                M28Utilities.DrawLocation(tNavalBuildArea, nil, 200, 10)
                            end
                            tPondSubtable[subrefBuildLocationByStartPosition][aiBrain:GetArmyIndex()] = tNavalBuildArea

                            --Record pond value before distance adjustments - i.e. if we already have navy somewhere, this is how much the pond is worth to us
                            aiBrain[M28Navy.reftiPondValueToUs][iCurPondRef] = iCurPondValue
                            --Adjust pond value based on distance to us - used only for decision on whether to choose as a pond we want


                            --Can we path here amphibiously?
                            if not(NavUtils.GetTerrainLabel(refPathingTypeHover, tNavalBuildArea) == iPathingGroupWanted) then
                                iCurPondValue = 0
                                if bDebugMessages == true then LOG(sFunctionRef..': We cant path here amphibiously') end
                            else
                                --Adjust value based on distance
                                local iDistToBuildArea = M28Utilities.GetDistanceBetweenPositions(tNavalBuildArea, GetPlayerStartPosition(aiBrain))
                                if iDistToBuildArea <= 50 then iCurPondValue = iCurPondValue * 1.1
                                else
                                    iCurPondValue = iCurPondValue * math.max(0.1, 1 - 0.4 * iDistToBuildArea / iDistanceThreshold)
                                    if bDebugMessages == true then LOG(sFunctionRef..': iCurPondValue after adjusting for distance to build area='..iCurPondValue..'; iDistToBuildArea='..iDistToBuildArea..'; iDistanceThreshold='..iDistanceThreshold) end
                                end

                                --Are we close enough to enemy base to be in danger and we can land path to enemy base?
                                if bDebugMessages == true then LOG(sFunctionRef..': Dist to nearest enemy base='..aiBrain[M28Overseer.refiDistanceToNearestEnemyBase]..'; Can path with land='..tostring(aiBrain[refbCanPathToEnemyBaseWithLand])..'; Dist from naval build location to enemy base='..M28Utilities.GetDistanceBetweenPositions(tNavalBuildArea, GetPrimaryEnemyBaseLocation(aiBrain))..'; Dist from naval build location to our base='..M28Utilities.GetDistanceBetweenPositions(GetPlayerStartPosition(aiBrain), tNavalBuildArea)) end
                                if aiBrain[refbCanPathToEnemyBaseWithLand] and not(bIsCampaignMap) then
                                    --Reduce value of pond if enemy base is close for land anyway
                                    if aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] <= 300 then
                                        iCurPondValue = iCurPondValue * 0.5
                                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy base within 300 so halving curpondvalue, value='..iCurPondValue) end
                                    end
                                    if M28Utilities.GetDistanceBetweenPositions(tNavalBuildArea, GetPrimaryEnemyBaseLocation(aiBrain)) <= 200 then
                                        if M28Utilities.GetDistanceBetweenPositions(GetPlayerStartPosition(aiBrain), tNavalBuildArea) <= 200 then
                                            iCurPondValue = iCurPondValue * 0.25
                                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy primary base is within 200 of the naval build area so reducing pond value to 25% of normal') end
                                        else
                                            iCurPondValue = 0
                                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy primary base is closer than our own base and is within 200 so reducing pond value to 25% of normal') end
                                        end
                                    end
                                end
                            end
                        else
                            iCurPondValue = 0
                            if bDebugMessages == true then LOG(sFunctionRef..': We couldnt find anywhere to build a naval fac so reducing pond value to 0') end
                        end
                        aiBrain[M28Navy.reftiPondThreatToUs][iCurPondRef] = iCurPondDefensiveValue
                        if bDebugMessages == true then LOG(sFunctionRef..': Pond value after getting naval build area='..iCurPondValue..'; Defensive value='..(aiBrain[M28Navy.reftiPondThreatToUs][iCurPondRef] or 'nil')) end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Pond value is too low to be worth considering') end
                        iCurPondValue = 0
                    end
                end
            end
            if iCurPondValue > iBestPondValue then
                if bDebugMessages == true then LOG(sFunctionRef..': Updating the best pond ref to be '..iCurPondRef..'; as the cur pond value '..iCurPondValue..' is more than the prev best of '..iBestPondValue) end
                iBestPondRef = iCurPondRef
                iBestPondValue = iCurPondValue

            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Near end of code, iBestPondRef='..(iBestPondRef or 'nil')..'; iBestPondValue='..(iBestPondValue or 'nil')) end
        if iBestPondRef and (iBestPondValue >= 4 or (iBestPondValue >= 2 and bIsCampaignMap)) then
            aiBrain[M28Navy.refiPriorityPondRef] = iBestPondRef
            if bDebugMessages == true then
                local iBuildSegmentX, iBuildSegmentZ = GetPathingSegmentFromPosition(tPondDetails[aiBrain[M28Navy.refiPriorityPondRef]][subrefBuildLocationByStartPosition][aiBrain:GetArmyIndex()])
                local iWaterZone = tWaterZoneBySegment[iBuildSegmentX][iBuildSegmentZ]
                LOG(sFunctionRef..': Have a priority pond ref='..aiBrain[M28Navy.refiPriorityPondRef]..' at water zone '..(iWaterZone or 'nil')..'; will draw a square in orangy pink for the build position='..repru(tPondDetails[aiBrain[M28Navy.refiPriorityPondRef]][subrefBuildLocationByStartPosition][aiBrain:GetArmyIndex()]))
                M28Utilities.DrawLocation(tPondDetails[aiBrain[M28Navy.refiPriorityPondRef]][subrefBuildLocationByStartPosition][aiBrain:GetArmyIndex()], 8, 200, 10)
            end
            local bInTeamList = false
            local iTeam = aiBrain.M28Team
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues]) == false then
                for iEntry, iPond in M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues] do
                    if iBestPondRef == iPond then
                        bInTeamList = true
                        break
                    end
                end
            end
            if not(bInTeamList) then
                if not(M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues]) then M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues] = {} end
                M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][iBestPondRef] = math.max((M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][iBestPondRef] or 0), iBestPondValue)
            end
        elseif bDebugMessages == true then LOG(sFunctionRef..'; Etiher dont have a pond to expand to, or the value is too low to want to expand')
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AddSegmentToWaterZone(iPond, iWaterZone, iSegmentX, iSegmentZ)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddSegmentToWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': About to add Segment X-Z'..iSegmentX..'-'..iSegmentZ..' to iPond='..iPond..' and water zone='..iWaterZone..'; iTotalWaterZoneRecordedSegmentCount prior to this='..iTotalWaterZoneRecordedSegmentCount) end
    table.insert(tPondDetails[iPond][subrefPondWaterZones][iWaterZone][subrefWZSegments], {iSegmentX, iSegmentZ})
    if not(tWaterZoneBySegment[iSegmentX]) then tWaterZoneBySegment[iSegmentX] = {} end
    tWaterZoneBySegment[iSegmentX][iSegmentZ] = iWaterZone
    iTotalWaterZoneRecordedSegmentCount = iTotalWaterZoneRecordedSegmentCount + 1
    tPondDetails[iPond][subrefiRecordedSegmentsInWaterZones] = (tPondDetails[iPond][subrefiRecordedSegmentsInWaterZones] or 0) + 1
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordWaterZoneAtPosition(tSegmentPosition)
    iTotalWaterZoneCount = iTotalWaterZoneCount + 1
    local iPond = NavUtils.GetTerrainLabel(refPathingTypeNavy, tSegmentPosition)
    if not(iPond) then
        local tAlternative
        local tiAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}, {-3,0}, {-3, -3}, {-3, 3}, {0, -3}, {0, 3}, {3, -3}, {3, 0}, {3,3}, {-5,0}, {-5, -5}, {-5, 5}, {0, -5}, {0, 5}, {5, -5}, {5, 0}, {5,5}}
        for iEntry, tXZAdjust in tiAdjust do
            iPond = NavUtils.GetTerrainLabel(refPathingTypeNavy, { tSegmentPosition[1] + tXZAdjust[1], tSegmentPosition[2], tSegmentPosition[3] + tXZAdjust[2] })
            if iPond then break end
        end
    end
    if not(iPond) then M28Utilities.ErrorHandler('Dont have a valid pond even after searching nearby')
    else
        if not(tPondDetails[iPond][subrefPondWaterZones]) then
            --if not(tPondDetails[iPond]) then M28Utilities.DrawLocation(tSegmentPosition) LOG('RecordWaterZoneAtPosition: No pond for pond '..(iPond or 'nil')..'; position='..repru(tSegmentPosition)) end
            if not(tPondDetails[iPond]) then CreateNewPond(iPond) end
            tPondDetails[iPond][subrefPondWaterZones] = {}
        end
        tPondDetails[iPond][subrefPondWaterZones][iTotalWaterZoneCount] = {}
        tPondDetails[iPond][subrefPondWaterZones][iTotalWaterZoneCount][subrefWZSegments] = {}
        tPondDetails[iPond][subrefPondWaterZones][iTotalWaterZoneCount][refiAllOmniCoverage] = 0
        tPondDetails[iPond][subrefPondWZCount] = (tPondDetails[iPond][subrefPondWZCount] or 0) + 1
        tiPondByWaterZone[iTotalWaterZoneCount] = iPond
        local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tSegmentPosition)
        AddSegmentToWaterZone(iPond, iTotalWaterZoneCount, iSegmentX, iSegmentZ)
    end
end

function DrawWaterZones()
    --For debug use - will draw each land zone in a plateau in a different colour to allow a visual check of how land zones have been created.  Can be called part-way through the process (e.g. to show land zones after the initial mex creation and nearby areas)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DrawWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Create fixed colours per ref
    local iUniqueColourCount = 30
    local tColourTable = M28Utilities.GenerateUniqueColourTable(iUniqueColourCount)

    --Subfunction which assigns a unique colour to each land zone
    function GetColourFromWaterZoneNumber(iWaterZoneRef)
        local iColour = iWaterZoneRef
        while iColour >= iUniqueColourCount do
            iColour = iColour - iUniqueColourCount
        end

        return tColourTable[iColour]
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Will now draw every land zone in every plateau, cycling the colour used') end
    local tLocation, iWaterZoneRef
    --Cycle through every segment on the map and draw a colour for it based on the land zone that it's part of
    for iCurSegmentX = 1, iMaxLandSegmentX do
        for iCurSegmentZ = 1, iMaxLandSegmentZ do
            iWaterZoneRef = tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ]
            if (iWaterZoneRef or 0) > 0 then
                tLocation = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                if bDebugMessages == true then LOG(sFunctionRef..': Water zone ref for segments X-Z='..iCurSegmentX..'-'..iCurSegmentZ..' = '..iWaterZoneRef..'; Plataeu ref based on navutils='..NavUtils.GetTerrainLabel(refPathingTypeHover, tLocation)) end
                --M28Utilities.DrawLocation(tLocation, GetColourFromWaterZoneNumber(iWaterZoneRef), nil, iLandZoneSegmentSize - 0.1)
                M28Utilities.DrawLocation(tLocation, GetColourFromWaterZoneNumber(iWaterZoneRef), nil, iLandZoneSegmentSize - 0.1)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CreateWaterZones()
    --Creates each separate water zones and assign segments to each water zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)




    local iSystemTimeStart = GetSystemTimeSecondsOnlyForProfileUse()
    --local iMapSize = math.max(rMapPotentialPlayableArea[3] - rMapPotentialPlayableArea[1], rMapPotentialPlayableArea[4] - rMapPotentialPlayableArea[2])
    local iWaterZoneInterval = 115 + 20 * math.floor(iMapSize / 512) --i.e. 125 for 5km, 135 for 10km, 155 for 20km, 200 for 80km (previously tried 130 + 30 * floor(size/512) but WZ were too big and caused unexpected results with air logic


    --local iMinDistanceFromFactoryBuildPosition = 100
    local iSegmentInterval = iWaterZoneInterval / iLandZoneSegmentSize
    local iStartSegment = iSegmentInterval * 0.5
    --local iEndSegmentX =
    local iMaxXIntervals = math.floor((iMaxLandSegmentX * iLandZoneSegmentSize - iStartSegment * iLandZoneSegmentSize) / iWaterZoneInterval) + 1
    local iMaxZIntervals = math.floor((iMaxLandSegmentZ * iLandZoneSegmentSize - iStartSegment * iLandZoneSegmentSize) / iWaterZoneInterval) + 1
    local iBaseSegmentX, iBaseSegmentZ
    local iPotentialZoneStartSegmentX, iPotentialZoneStartSegmentZ
    local iMaxSegmentAdjust = math.max(1, math.floor(iSegmentInterval * 0.35) - 1)
    local iCurSegmentX, iCurSegmentZ, iPotentialPond
    local bFoundForThisInterval
    --local bRecordAsWaterZone

    function GetNeighbours(iSegmentX, iSegmentZ, tBasePosition)
        --Get the adjacent segments to iSegmentX and Z, and the position of these adjacent segments (ntoe this is slightly different from the segment midpoint as it is based on tBasePosition for simplicity)
        local tTableBeforePositions = {{iSegmentX - 1, iSegmentZ, {{tBasePosition[1] - 1, 0, tBasePosition[3]}}}, {iSegmentX, iSegmentZ - 1, {{tBasePosition[1], 0, tBasePosition[3] - 1}}}, {iSegmentX, iSegmentZ + 1, {{tBasePosition[1], 0, tBasePosition[3] + 1}}}, {iSegmentX + 1, iSegmentZ, {{tBasePosition[1] + 1, 0, tBasePosition[3]}}}}
        if iLandZoneSegmentSize > 1 then --land and water zones use same segment size; if size is >1 then risk we are less detailed than navmesh so need to do more detailed calculation to ensure c orrect pathability results
            for iEntry, tSubtable in tTableBeforePositions do
                if bDebugMessages == true then LOG(sFunctionRef..': tSubtable='..repru(tSubtable)..'; tSubtable[3]='..repru(tSubtable[3])) end
                for iPositionAdjust = 2, iLandZoneSegmentSize, 1 do
                    if iEntry == 1 then
                        table.insert(tSubtable[3], {tBasePosition[1] - iPositionAdjust, 0, tBasePosition[3]})
                    elseif iEntry == 2 then
                        table.insert(tSubtable[3], {tBasePosition[1], 0, tBasePosition[3] - iPositionAdjust})
                    elseif iEntry == 3 then
                        table.insert(tSubtable[3], {tBasePosition[1], 0, tBasePosition[3] + iPositionAdjust})
                    elseif iEntry == 4 then
                        table.insert(tSubtable[3], {tBasePosition[1] + iPositionAdjust, 0, tBasePosition[3]})
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': tTableBeforePositions='..repru(tTableBeforePositions)) end
        return tTableBeforePositions
    end

    local iMaxSegmentSearchDistance = math.max(10, iWaterZoneInterval / iLandZoneSegmentSize) --NOTE: If changing this consider if also want to change the value for AssignRemainingSegmentsToLandZones
    --iMaxSegmentSearchDistance = 5 --Temp for testing
    local iBaseSegmentX, iBaseSegmentZ, iBaseLabelWanted
    local bHadSomeEntries = false
    local iMexLandZone, iMexLandLabel, bSameWaterLabel
    if bDebugMessages == true then LOG(sFunctionRef..': About to start cycling through plateaus and mexes, iLandZoneSegmentSize='..iLandZoneSegmentSize..'; iMaxSegmentSearchDistance='..iMaxSegmentSearchDistance) end
    --Cycle through every plateau
    function CycleThroughBaseTableAndRecordNearbyAreaAsSameWaterZone(tBaseTable, iMaxSearchCycle)

        --tBaseTable should contain each entry to be considered simultaneously, and be in the format {[1]={iBaseSegmentX, iBaseSegmentZ, tBasePosition, iWaterZone}, [2]={....} etc.}
        local tiAdjacentSegmentsForSearchCountByMex = {}
        local tiSegmentsByBaseTableKey = {}
        local iWaterZoneByBaseTableKey = {}
        local tbWaterZoneAlreadyConsidered = {}
        tiAdjacentSegmentsForSearchCountByMex[0] = {}
        for iEntry, tSubtable in tBaseTable do
            tiAdjacentSegmentsForSearchCountByMex[0][iEntry] = {{tSubtable[1], tSubtable[2], tSubtable[3], tSubtable[4]}}
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iStart of subfunction, iMaxSearchCycle='..iMaxSearchCycle..'; tiAdjacentSegmentsForSearchCountByMex='..repru(tiAdjacentSegmentsForSearchCountByMex)) end
        --Cycle through each base position and consider adjcent pathable segments for inclusion in the base position's zone.  Record any such segments as the base points for the next search count (so the process repeats up to iMaxSegmentSearchDistance times)
        for iSearchCount = 1, iMaxSearchCycle + 1 do --+1 since we only consider iSearchCount-1 values
            tiAdjacentSegmentsForSearchCountByMex[iSearchCount] = {}
            bHadSomeEntries = false
            for iBaseQueueCount, tiQueueEntries in tiAdjacentSegmentsForSearchCountByMex[iSearchCount-1] do --i.e. at count-1 = 0 this is each mex; each search count after that is all adjacent locations ot the previous search count entry?
                tiAdjacentSegmentsForSearchCountByMex[iSearchCount][iBaseQueueCount] = {}
                if bDebugMessages == true then LOG(sFunctionRef..': iSearchCount='..iSearchCount..'; iBaseQueueCount='..iBaseQueueCount..'; tiQueueEntries='..repru(tiQueueEntries)) end
                for iSegmentEntry, tiSegmentXZAndZone in tiQueueEntries do
                    iBaseLabelWanted = NavUtils.GetTerrainLabel('Water', tiSegmentXZAndZone[3])
                    if bDebugMessages == true then LOG(sFunctionRef..': iSegmentEntry='..iSegmentEntry..'; tiSegmentXZAndZone='..repru(tiSegmentXZAndZone)..'; iBaseLabelWanted='..(iBaseLabelWanted or 'nil')) end
                    if (iBaseLabelWanted or 0) > 0 then
                        for iNeighbourEntry, tiNeighbourXZ in GetNeighbours(tiSegmentXZAndZone[1], tiSegmentXZAndZone[2], tiSegmentXZAndZone[3]) do
                            --Check we dont already have this segment assigned to another water zone
                            if not(tbWaterZoneAlreadyConsidered[tiNeighbourXZ[1]][tiNeighbourXZ[2]]) and not(tWaterZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]]) then
                                --Check we can path to this neighbouring segment from the base segment
                                if not(tWaterZoneBySegment[tiNeighbourXZ[1]]) then tWaterZoneBySegment[tiNeighbourXZ[1]] = {} end
                                bSameWaterLabel = true
                                for iEntry, tPosition in tiNeighbourXZ[3] do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Segment XZ=X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iEntry='..iEntry..'; tPosition='..repru(tPosition)..'; Water label='..(NavUtils.GetTerrainLabel('Water', tPosition) or 'nil')..'; tiSegmentXZAndZone[4] label='..(tiSegmentXZAndZone[4] or 'nil')) end
                                    if not(NavUtils.GetTerrainLabel('Water', tPosition) == iBaseLabelWanted) then
                                        bSameWaterLabel = false
                                        break
                                    end
                                end

                                if bSameWaterLabel then
                                    --We can path here, so update the Water zone to group it with the base segment, and then record it so we consider the neighbours of this segment in the next iSearchCount
                                    --tWaterZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]] = tiSegmentXZAndZone[4]
                                    AddSegmentToWaterZone(iBaseLabelWanted, tiSegmentXZAndZone[4], tiNeighbourXZ[1], tiNeighbourXZ[2])
                                    table.insert(tiAdjacentSegmentsForSearchCountByMex[iSearchCount][iBaseQueueCount], {tiNeighbourXZ[1], tiNeighbourXZ[2],  GetPositionFromPathingSegments(tiNeighbourXZ[1], tiNeighbourXZ[2]), tiSegmentXZAndZone[4]})
                                    bHadSomeEntries = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering segment X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iCurWaterLabel='..(tiSegmentXZAndZone[4] or 'nil')..'; adding to table of valid locations, iBaseQueueCount='..iBaseQueueCount) end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have unpathable segment X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..'; iCurWaterLabel='..(tiSegmentXZAndZone[4] or 'nil')..'; adding to table of segments that cant path to, iBaseQueueCount='..iBaseQueueCount) end
                                end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Already have water zone recorded for segment X'..tiNeighbourXZ[1]..'Z'..tiNeighbourXZ[2]..' or '..(tWaterZoneBySegment[tiNeighbourXZ[1]][tiNeighbourXZ[2]] or 'nil')..'; iCurWaterLabel='..(tiSegmentXZAndZone[4] or 'nil')..'; adding to table of valid locations, iBaseQueueCount='..iBaseQueueCount) end
                            end
                        end
                    end
                end
                if bDebugMessages == true then
                    if not(bHadSomeEntries) then
                        --Didnt find any valid entries this cycle so abort
                        LOG(sFunctionRef..': No entries for iSearchCount='..iSearchCount..' so will abort further entries')
                    else
                        LOG(sFunctionRef..': Finished for iBaseQueueCount and have some more entries to consider, iSearchCount='..iSearchCount..'; iBaseQueueCount='..iBaseQueueCount..'; Size of entries to go through next='..table.getn(tiAdjacentSegmentsForSearchCountByMex[iSearchCount][iBaseQueueCount]))
                    end
                end
            end
            if not(bHadSomeEntries) then
                --Didnt find any valid entries this cycle so abort
                if bDebugMessages == true then LOG(sFunctionRef..': No entries for iSearchCount='..iSearchCount..' so will abort further entries') end
                break
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Finished for iSearchCount='..iSearchCount..' and have some more entries to consider, Size of entries to go through next='..table.getn(tiAdjacentSegmentsForSearchCountByMex[iSearchCount])) end
            end
        end
    end




    --First create a waterzone for any start positions that are underwater
    local tWaterZonePondAndStartSegmentsByZone = {}
    local tBaseWaterStartPositionTable = {}
    local bHadUnderwaterStart = false
    for iCurBrain, oBrain in ArmyBrains do
        if not(M28Conditions.IsCivilianBrain(oBrain)) then
            local iStartPositionX, iStartPositionZ = GetPlayerStartPosition(oBrain, true)
            if iStartPositionX and iStartPositionZ then
                local tStartPosition = {iStartPositionX, GetSurfaceHeight(iStartPositionX, iStartPositionZ), iStartPositionZ}
                if GetTerrainHeight(iStartPositionX, iStartPositionZ) < tStartPosition[2] then
                    --COnfirm it is pathable by water
                    if (NavUtils.GetTerrainLabel(refPathingTypeNavy, tStartPosition) or 0) > 0 then
                        RecordWaterZoneAtPosition(tStartPosition)

                        --Get the segments and include an area around this in the same water zone; area needs to be more than half of the interval for the grid based approach for water zones used later
                        iBaseSegmentX, iBaseSegmentZ = GetPathingSegmentFromPosition(tStartPosition)
                        local iPond = NavUtils.GetTerrainLabel(refPathingTypeNavy, GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ))
                        if (iPond or 0) > 0 then
                            tWaterZonePondAndStartSegmentsByZone[iTotalWaterZoneCount] = {iPond, iBaseSegmentX, iBaseSegmentZ}
                        end
                        table.insert(tBaseWaterStartPositionTable, {iBaseSegmentX, iBaseSegmentZ, tStartPosition, iTotalWaterZoneCount})
                        bHadUnderwaterStart = true

                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Added start position to the table of water zones to include, position='..repru(tStartPosition)..'; Will draw in gold, oBrain='..oBrain.Nickname)
                            M28Utilities.DrawLocation(tStartPosition, 4, nil, 6)
                        end

                    end
                end
            end
        end
    end
    if M28Utilities.IsTableEmpty(tBaseWaterStartPositionTable) == false then
        CycleThroughBaseTableAndRecordNearbyAreaAsSameWaterZone(tBaseWaterStartPositionTable, iMaxSegmentSearchDistance * 1.125) --want start position zone to be larger than a normal water zone
        tBaseWaterStartPositionTable = {}
    end
    if bDebugMessages == true then
        LOG(sFunctionRef..': Will record water zones after covering start positions')
        DrawWaterZones()        
        LOG(sFunctionRef..': Finished drawing the start position water zones, will move on now')
    end

    --pick equally spaced apart points on the map and if are near water then create a water zone, then cycle through each of htese simultaneously assigning adjacent points to water zones
    --local tiAbortedWZSegments = {}
    local iCurSegmentDistToLand
    local bIgnoreCurWaterZone = false
    local iMaxNearbyStartSegmentCheck = 10
    if iLandZoneSegmentSize <= 4 then
        iMaxNearbyStartSegmentCheck = math.min(15, 46 / iLandZoneSegmentSize, iMaxSegmentAdjust - 2)
    end
    for iIntervalCountX = 1, iMaxXIntervals do
        iBaseSegmentX = math.ceil(iSegmentInterval * (iIntervalCountX - 0.5))
        for iIntervalCountZ = 1, iMaxZIntervals do
            iPotentialZoneStartSegmentX = nil
            iPotentialZoneStartSegmentZ = nil
            bFoundForThisInterval = false
            iCurSegmentDistToLand = 0

            iBaseSegmentZ = math.ceil(iSegmentInterval * (iIntervalCountZ - 0.5))
            if bDebugMessages == true then LOG(sFunctionRef..': iIntervalCountX='..iIntervalCountX..'; iIntervalCountZ='..iIntervalCountZ..'; iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ..' tWaterZoneBySegment[iBaseSegmentX][iBaseSegmentZ]='..(tWaterZoneBySegment[iBaseSegmentX][iBaseSegmentZ] or 'nil')) end
            if tWaterZoneBySegment[iBaseSegmentX][iBaseSegmentZ] then --redundancy - make sure havent already recorded here
                bFoundForThisInterval = true
                iPotentialZoneStartSegmentX = nil
                iPotentialZoneStartSegmentZ = nil
                --tiAbortedWZSegments[tWaterZoneBySegment[iBaseSegmentX][iBaseSegmentZ]] = {iBaseSegmentX, iBaseSegmentZ}
                if bDebugMessages == true then LOG(sFunctionRef..': Added aborted WZ Segment for water zone '..tWaterZoneBySegment[iBaseSegmentX][iBaseSegmentZ]..'; iBaseSegmentX-Z='..iBaseSegmentX..'-'..iBaseSegmentZ) end
            else
                --See if there is anywhere near the base segment that is in a pond, and if so use this as the waterzone start point
                iPotentialPond = NavUtils.GetTerrainLabel(refPathingTypeNavy, GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ))
                if (iPotentialPond or 0) > 0 then
                    iPotentialZoneStartSegmentX = iBaseSegmentX
                    iPotentialZoneStartSegmentZ = iBaseSegmentZ
                else
                    --Search nearby in intervals of 20, up to 80 (adjusted for segment size)
                    for iAdjustBase = 1, iMaxSegmentAdjust do
                        for iCurSegmentX = math.max(1, iBaseSegmentX - iAdjustBase), math.min(iMaxLandSegmentX, iBaseSegmentX + iAdjustBase) do
                            for iCurSegmentZ = math.max(1, iBaseSegmentZ - iAdjustBase), math.min(iMaxLandSegmentZ, iBaseSegmentZ + iAdjustBase) do
                                if tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] then --redundancy
                                    bFoundForThisInterval = true
                                    iPotentialZoneStartSegmentX = nil
                                    iPotentialZoneStartSegmentZ = nil
                                    break
                                else
                                    iCurSegmentDistToLand = iAdjustBase
                                    iPotentialPond = NavUtils.GetTerrainLabel(refPathingTypeNavy, GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ))
                                    if (iPotentialPond or 0) > 0 then
                                        bFoundForThisInterval = true
                                        iPotentialZoneStartSegmentX = iCurSegmentX
                                        iPotentialZoneStartSegmentZ = iCurSegmentZ
                                        break
                                    end
                                end
                            end
                            if bFoundForThisInterval then break end
                        end
                        if bFoundForThisInterval then break end
                    end
                end
            end
    
            if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for potential point for water zone for iIntervalCountX='..iIntervalCountX..'; iIntervalCountZ='..iIntervalCountZ..'; iPotentialZoneStartSegmentX='..(iPotentialZoneStartSegmentX or 'nil')..'; iPotentialZoneStartSegmentZ='..(iPotentialZoneStartSegmentZ or 'nil')) end

            if iPotentialZoneStartSegmentX then
                --Check we dont have a nearby segment that belongs to another water zone in this pond
                if bHadUnderwaterStart then

                    --If we search nearby segments do we comr across one already in a water zone? if so dont record this as will just extend the existing water zone slightly
                    for iAdjustBase = 1, iMaxNearbyStartSegmentCheck do
                        for iCurSegmentX = math.max(1, iPotentialZoneStartSegmentX - iAdjustBase), math.min(iMaxLandSegmentX, iPotentialZoneStartSegmentX + iAdjustBase) do
                            for iCurSegmentZ = math.max(1, iPotentialZoneStartSegmentZ - iAdjustBase), math.min(iMaxLandSegmentZ, iPotentialZoneStartSegmentZ + iAdjustBase) do
                                if tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have a nearby water zone to this already='..tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ]..' so will abort creating a water zone here') end
                                    bIgnoreCurWaterZone = true
                                    break
                                end
                            end
                            if bIgnoreCurWaterZone then break end
                        end
                        if bIgnoreCurWaterZone then break end
                    end
                end
                if not(bIgnoreCurWaterZone) then

                    --Below was to not record near a start position, but on reflection will just let start positiosn be on the edge of a water zone, to keep things simple for now
                    local tSegmentPosition = GetPositionFromPathingSegments(iPotentialZoneStartSegmentX, iPotentialZoneStartSegmentZ)

                    --Have found a segment that is on water, record this as a waterzone unless it is close to a factory
                    --bRecordAsWaterZone = true

                    --[[if M28Utilities.IsTableEmpty(tPondDetails[iPotentialPond][subrefBuildLocationByStartPosition]) == false then
                    for iArmyIndex, tBuildPosition in tPondDetails[iPotentialPond][subrefBuildLocationByStartPosition] do
                        if M28Utilities.GetDistanceBetweenPositions(tSegmentPosition, tBuildPosition) <= iMinDistanceFromFactoryBuildPosition then
                            bRecordAsWaterZone = false
                            break
                        end
                    end
                end--]]
                    --if bRecordAsWaterZone then
                    RecordWaterZoneAtPosition(tSegmentPosition)
                    table.insert(tBaseWaterStartPositionTable, {iPotentialZoneStartSegmentX, iPotentialZoneStartSegmentZ, tSegmentPosition, iTotalWaterZoneCount})
                    --end
                end
            end
    
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef..': Finished recording the first segment for each water zone, will now check for any ponds that lack a water zone, and draw water zones')
        DrawWaterZones()        
    end

    --Now go through any ponds that dont have a water zone and create one
    for iPond, tPondSubtable in tPondDetails do

        if bDebugMessages == true then LOG(sFunctionRef..': Considering if pond '..iPond..' has any water zones, is table of water zones empty='..tostring(M28Utilities.IsTableEmpty(tPondSubtable[subrefPondWaterZones]))..'; tPondSubtable[subrefiSegmentCount]='..(tPondSubtable[subrefiSegmentCount] or 'nil')) end

        if M28Utilities.IsTableEmpty(tPondSubtable[subrefPondWaterZones]) and tPondSubtable[subrefiSegmentCount] > 0 then
            iPotentialZoneStartSegmentX = tPondSubtable[subreftiWaterSegmentXZ][1][1]
            iPotentialZoneStartSegmentZ = tPondSubtable[subreftiWaterSegmentXZ][1][2]
            if not(tWaterZoneBySegment[iPotentialZoneStartSegmentX][iPotentialZoneStartSegmentZ]) then
                if bDebugMessages == true then LOG(sFunctionRef..': About to record a water zone using iPotentialZoneStartSegmentX-Z='..(iPotentialZoneStartSegmentX or 'nil')..'-'..(iPotentialZoneStartSegmentZ or 'nil')..'; water zone for this (hopefully shoudl be nil)='..(tWaterZoneBySegment[iPotentialZoneStartSegmentX][iPotentialZoneStartSegmentZ] or 'nil')) end
                local tPosition = GetPositionFromPathingSegments(iPotentialZoneStartSegmentX, iPotentialZoneStartSegmentZ)
                RecordWaterZoneAtPosition(tPosition)
                table.insert(tBaseWaterStartPositionTable, {iPotentialZoneStartSegmentX, iPotentialZoneStartSegmentZ, tPosition, iTotalWaterZoneCount})
            end
        end
    end
    if M28Utilities.IsTableEmpty(tBaseWaterStartPositionTable) == false then
        CycleThroughBaseTableAndRecordNearbyAreaAsSameWaterZone(tBaseWaterStartPositionTable, iMaxSegmentSearchDistance * 2) --done x2 so we keep searching (e.g. for narrow water paths where we didnt have an interval Water nearby) - in most cases would expect to stop much sooner than this
        tBaseWaterStartPositionTable = {}
    end

    --Go through all segments on map and ensure any water ones are assigned
    local iWZToAssign
    local iMaxSearchSize = math.min(12, iMaxSegmentAdjust)
    local iMidSearchSize = math.floor(iMaxSearchSize * 0.5)
    local iCurPond
    local bFoundWZToAddTo
    for iCurSegmentX = 1, iMaxLandSegmentX do
        for iCurSegmentZ = 1, iMaxLandSegmentZ do
            if not(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]) and not(tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ]) then
        
                bFoundWZToAddTo = false
                local tSegmentPosition = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                iCurPond = NavUtils.GetTerrainLabel('Water', tSegmentPosition)
                if (iCurPond or 0) > 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a segment that doesnt have a water zone or land zone assigned and has water pathing, iCurSegmentX='..iCurSegmentX..'Z='..iCurSegmentZ) end
                    --If it's likely that the no. of segments this new zone will cover are at least 12 in size then create a new zone, otherwise assign to nearest zone
                    if not(tLandZoneBySegment[iCurSegmentX + iMaxSegmentAdjust][iCurSegmentZ]) and not(tWaterZoneBySegment[iCurSegmentX + iMaxSegmentAdjust][iCurSegmentZ])
                            and not(tLandZoneBySegment[iCurSegmentX + iMaxSegmentAdjust][iCurSegmentZ + iMaxSegmentAdjust]) and not(tWaterZoneBySegment[iCurSegmentX + iMaxSegmentAdjust][iCurSegmentZ + iMaxSegmentAdjust])
                            and not(tLandZoneBySegment[iCurSegmentX + iMidSearchSize][iCurSegmentZ + iMidSearchSize]) and not(tWaterZoneBySegment[iCurSegmentX + iMidSearchSize][iCurSegmentZ + iMidSearchSize])
                            and not(tLandZoneBySegment[iCurSegmentX + iMidSearchSize][iCurSegmentZ]) and not(tWaterZoneBySegment[iCurSegmentX + iMidSearchSize][iCurSegmentZ])
                    then

                        if bDebugMessages == true then LOG(sFunctionRef..': Dont have a land or water zone nearby when searching with iMaxSegmentAdjust='..iMaxSegmentAdjust..' so will record a new water zone here, iTotalWaterZoneCount before recording (so will be 1 plus this)='..iTotalWaterZoneCount) end
                        RecordWaterZoneAtPosition(tSegmentPosition)
                        table.insert(tBaseWaterStartPositionTable, {iCurSegmentX, iCurSegmentZ, tSegmentPosition, iTotalWaterZoneCount})
                        CycleThroughBaseTableAndRecordNearbyAreaAsSameWaterZone(tBaseWaterStartPositionTable, iMaxSegmentSearchDistance) --done x2 so we keep searching (e.g. for narrow water paths where we didnt have an interval Water nearby) - in most cases would expect to stop much sooner than this
                        tBaseWaterStartPositionTable = {}
                    else
                        --Search for a nearby WZ to add to
                        for iAdjustBase = 3, 1, -1 do
                            --Start with the highest X and Z and move down, since we are moving from the lowest up with the main cycle (so if dont do this will always pick the left/top zone in priority) - still will pick left/top most of the time but at least when start reaching other zones will change a bit sooner
                            for iNearbyCurSegmentX = math.min(iMaxLandSegmentX, iCurSegmentX + iAdjustBase), math.max(1, iCurSegmentX - iAdjustBase), -1 do
                                for iNearbyCurSegmentZ = math.min(iMaxLandSegmentZ, iCurSegmentZ + iAdjustBase), math.max(1, iCurSegmentZ - iAdjustBase), -1 do
                                    if tWaterZoneBySegment[iNearbyCurSegmentX][iNearbyCurSegmentZ] then
                                        if iCurPond == NavUtils.GetTerrainLabel('Water', GetPositionFromPathingSegments(iNearbyCurSegmentX, iNearbyCurSegmentZ)) then
                                            bFoundWZToAddTo = true
                                            AddSegmentToWaterZone(iCurPond, tWaterZoneBySegment[iNearbyCurSegmentX][iNearbyCurSegmentZ], iCurSegmentX, iCurSegmentZ)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Have a nearby water zone to this already='..tWaterZoneBySegment[iNearbyCurSegmentX][iNearbyCurSegmentZ]..' so will add to here') end
                                            break
                                        end
                                    end
                                end
                                if bFoundWZToAddTo then break end
                            end
                            if bFoundWZToAddTo then break end
                        end
                        if not(bFoundWZToAddTo) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Didnt find a nearby entry so will record a new zone after all') end
                            RecordWaterZoneAtPosition(tSegmentPosition)
                            table.insert(tBaseWaterStartPositionTable, {iCurSegmentX, iCurSegmentZ, tSegmentPosition, iTotalWaterZoneCount})
                            CycleThroughBaseTableAndRecordNearbyAreaAsSameWaterZone(tBaseWaterStartPositionTable, iMaxSegmentSearchDistance) --done x2 so we keep searching (e.g. for narrow water paths where we didnt have an interval Water nearby) - in most cases would expect to stop much sooner than this
                            tBaseWaterStartPositionTable = {}
                        end
                    end
                end
            end
        end
    end

    if bDebugMessages == true then
        LOG(sFunctionRef..': End of code, finished recording segments in water zone, iTotalWaterZoneRecordedSegmentCount='..iTotalWaterZoneRecordedSegmentCount..'; iTotalSegmentsInPonds='..iTotalSegmentsInPonds..'; iTotalWaterZoneCount='..iTotalWaterZoneCount..'; will draw all water zones. Time taken to run water zone logic='..GetSystemTimeSecondsOnlyForProfileUse() - iSystemTimeStart)
    end
    if iTotalWaterZoneRecordedSegmentCount < iTotalSegmentsInPonds then
        --Cycle through every zone to see if have any recorded for pond but not WX
        local iMaxAdjust = 3
        local iNewWaterZone, iCurPond
        for iBaseSegmentX = 1, iMaxLandSegmentX do
            for iBaseSegmentZ = 1, iMaxLandSegmentZ do
                if tPondBySegment[iBaseSegmentX][iBaseSegmentZ] and not(tWaterZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
                    --search for nearby zone to be a part of; if have none, then add to existing zone for the pond
                    iNewWaterZone = nil
                    iCurPond = tPondBySegment[iBaseSegmentX][iBaseSegmentZ]
                    if bDebugMessages == true then LOG(sFunctionRef..': Have segment inconsistency between ponds and water zones, iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ) end
                    for iAdjustBase = 1, iMaxAdjust do
                        for iCurSegmentX = iBaseSegmentX - iAdjustBase, iBaseSegmentX + iAdjustBase, 1 do
                            for iCurSegmentZ = iBaseSegmentZ - iAdjustBase, iBaseSegmentZ + iAdjustBase, iAdjustBase * 2 do
                                if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                                    if tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] and tPondBySegment[iCurSegmentX][iCurSegmentZ] == iCurPond then
                                        iNewWaterZone = tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ]
                                        break
                                    end
                                end
                            end
                            if iNewWaterZone then break end
                        end
                        if iNewWaterZone then break end
                        --Then do the left and right row (excl corners which ahve already done per the above)
                        for iCurSegmentX = iBaseSegmentX - iAdjustBase, iBaseSegmentX + iAdjustBase, iAdjustBase * 2 do
                            for iCurSegmentZ = iBaseSegmentZ - iAdjustBase + 1, iBaseSegmentZ + iAdjustBase - 1, 1 do
                                if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                                    if tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] and tPondBySegment[iCurSegmentX][iCurSegmentZ] == iCurPond then
                                        iNewWaterZone = tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ]
                                        break
                                    end
                                end
                            end
                            if iNewWaterZone then break end
                        end
                        if iNewWaterZone then break end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finisihed searching for nearby water zones in the same pond, iNewWaterZone='..(iNewWaterZone or 'nil')) end
                    if iNewWaterZone then
                        AddSegmentToWaterZone(iCurPond, iNewWaterZone, iBaseSegmentX, iBaseSegmentZ)
                    else
                        RecordWaterZoneAtPosition(GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ))
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': After update, iTotalWaterZoneRecordedSegmentCount='..iTotalWaterZoneRecordedSegmentCount..'; iTotalSegmentsInPonds='..iTotalSegmentsInPonds) end
        if iTotalWaterZoneRecordedSegmentCount < iTotalSegmentsInPonds then
            M28Utilities.ErrorHandler('May not have assigned every water segment a water zone')
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SetupWaterZones()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTotalWaitTime = 0
    --Allow up to 1s to setup preferred pond location, otherwise iwll just create water zones ignoring preferred factory build locations
    while not(bHaveConsideredPreferredPondForM28AI) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        iTotalWaitTime = iTotalWaitTime + 1
        if iTotalWaitTime >= 50 then M28Utilities.ErrorHandler('Havent setup preferred factory locations yet, will proceed with water zone creation anyway') break end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': About to start with creating water zones, is tPondDetails empty='..tostring(M28Utilities.IsTableEmpty(tPondDetails))..'; GameTime='..GetGameTimeSeconds()..'; System time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    if M28Utilities.IsTableEmpty(tPondDetails) == false then
        CreateWaterZones()

        if bDebugMessages == true then
            LOG(sFunctionRef..': Finished running CreateWaterZones, Systemtime='..GetSystemTimeSecondsOnlyForProfileUse()..'; will draw water zones now')
            DrawWaterZones()
        end





        RecordWaterZoneMidpointAndMinMaxPositions()
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording water zone midpoint etc., system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
        RecordHydroInWaterZones()
        RecordWaterZoneAdjacentLandZones()
        RecordIslands()
        RecordAdjacentWaterZones()
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording adjacency for land zones vs water zones, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
        RecordWaterZonePathingToOtherWaterZones()
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording water zone pathing to other water zones, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
        RecordWaterZonePatrolPaths()
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording water zone patrol paths for land scouts, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
        RecordMassStorageLocationsForEachWaterZone()
    end
    bWaterZoneInitialCreation = true
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordMidpointMinAndMaxSegmentForWaterZone(iWaterZone, iPond, tWZData)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordMidpointMinAndMaxSegmentForWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iMinX, iMaxX, iMinZ, iMaxZ, iAveragePond, iAverageWaterZone
    local iMinSegmentX, iMinSegmentZ, iMaxSegmentX, iMaxSegmentZ
    local iAverageSegmentX, iAverageSegmentZ
    local iAveragePlateau

    --Record min and max values
    iMinX = 100000
    iMinZ = 100000
    iMaxX = 0
    iMaxZ = 0
    iMinSegmentX = 100000
    iMinSegmentZ = 100000
    iMaxSegmentX = 0
    iMaxSegmentZ = 0

    for iEntry, tiSegmentXZ in tWZData[subrefWZSegments] do
        iMinSegmentX = math.min(tiSegmentXZ[1], iMinSegmentX)
        iMinSegmentZ = math.min(tiSegmentXZ[2], iMinSegmentZ)
        iMaxSegmentX = math.max(tiSegmentXZ[1], iMaxSegmentX)
        iMaxSegmentZ = math.max(tiSegmentXZ[2], iMaxSegmentZ)
    end
    local tMinPos = GetPositionFromPathingSegments(iMinSegmentX, iMinSegmentZ)
    local tMaxPos = GetPositionFromPathingSegments(iMaxSegmentX, iMaxSegmentZ)
    iMinX = tMinPos[1]
    iMinZ = tMinPos[3]
    iMaxX = tMaxPos[1]
    iMaxZ = tMaxPos[3]
    tWZData[subrefWZMinSegX] = iMinSegmentX
    tWZData[subrefWZMinSegZ] = iMinSegmentZ
    tWZData[subrefWZMaxSegX] = iMaxSegmentX
    tWZData[subrefWZMaxSegZ] = iMaxSegmentZ

    --Record midpoint
    local tAverage = {(iMinX + iMaxX)*0.5, 0, (iMinZ + iMaxZ) * 0.5}
    iAveragePond = NavUtils.GetTerrainLabel(refPathingTypeNavy, tAverage)

    iAverageSegmentX, iAverageSegmentZ = GetPathingSegmentFromPosition(tAverage)
    iAverageWaterZone = tWaterZoneBySegment[iAverageSegmentX][iAverageSegmentZ]
    iAveragePlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, tAverage)


    --Move the midpoint if nav utils doesnt work for this position (to reduce the amount of grief we might have later)
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering iWaterZone=' .. iWaterZone .. '; MinX=' .. iMinX .. 'Z' .. iMinZ .. '; iMaxX' .. iMaxX .. 'Z' .. iMaxZ .. '; iMinSegmentX=' .. iMinSegmentX .. 'Z' .. iMinSegmentZ .. '; iMaxSegmentX=' .. iMaxSegmentX .. iMaxSegmentZ..'; iAveragePlateau='..(iAveragePlateau or 'nil'))
    end

    if not (iPond == iAveragePond) or not (iAverageWaterZone == iWaterZone) or not(iAveragePlateau) then
        local tAltMidpoint
        local iAdjustedSegmentX, iAdjustedSegmentZ
        local bHaveValidAltMidpoint = false
        for iAdjust = 1, 50 do
            for iXAdjust = -iAdjust, iAdjust, 1 do
                for iZAdjust = -iAdjust, iAdjust, 1 do
                    if not (iXAdjust == 0 and iZAdjust == 0) then
                        iAdjustedSegmentX = iAverageSegmentX + iAdjust * iXAdjust
                        iAdjustedSegmentZ = iAverageSegmentZ + iAdjust * iZAdjust
                        if iAdjustedSegmentX > 0 and iAdjustedSegmentZ > 0 then
                            iAverageWaterZone = tWaterZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ]
                            if iAverageWaterZone == iWaterZone then
                                tAltMidpoint = GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': Considering adjusted segment X-Z=' .. iAdjustedSegmentX .. '-' .. iAdjustedSegmentZ .. '; with water zone ' .. tWaterZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ] .. '; tAltMidpoint=' .. repru(tAltMidpoint) .. '; Pond from navutils=' .. (NavUtils.GetTerrainLabel(refPathingTypeNavy, tAltMidpoint) or 'nil')..'; Plateau='..(NavUtils.GetTerrainLabel(refPathingTypeHover, tAltMidpoint)))
                                end
                                if NavUtils.GetTerrainLabel(refPathingTypeNavy, tAltMidpoint) == iPond and (NavUtils.GetTerrainLabel(refPathingTypeHover, tAltMidpoint) or 0) > 0 then

                                    --Have a valid midpoint; as this is water, see whether if we move further in the adjust direction we can still have a vlid point (so we arent as likely to be on the shore/by a cliff):
                                    local iXNewAdjust = 0
                                    local iZNewAdjust = 0
                                    local iXSizeAdjust = math.ceil(10 / iLandZoneSegmentSize)
                                    local iZSizeAdjust = math.ceil(10 / iLandZoneSegmentSize)
                                    if math.abs(iXAdjust) >= 10 then
                                        iXSizeAdjust = iXSizeAdjust * 2
                                    end
                                    if math.abs(iZAdjust) >= 10 then
                                        iZSizeAdjust = iZSizeAdjust * 2
                                    end
                                    if iXAdjust < 0 then
                                        iXNewAdjust = -iXSizeAdjust
                                    elseif iXAdjust > 0 then
                                        iXNewAdjust = iXSizeAdjust
                                    end
                                    if iZNewAdjust < 0 then
                                        iZNewAdjust = -iZSizeAdjust
                                    elseif iZNewAdjust > 0 then
                                        iZNewAdjust = iZSizeAdjust
                                    end
                                    local tAdjustedPosition = GetPositionFromPathingSegments(iAdjustedSegmentX + iXNewAdjust, iAdjustedSegmentZ + iZNewAdjust)
                                    if tWaterZoneBySegment[iAdjustedSegmentX + iXNewAdjust][iAdjustedSegmentZ + iZNewAdjust] == iAverageWaterZone and NavUtils.GetTerrainLabel(refPathingTypeNavy, tAdjustedPosition) == iPond and (NavUtils.GetTerrainLabel(refPathingTypeHover, tAdjustedPosition) or 0) > 0 then
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Will go with adjusted segment value, tAltMidpoint before adjust=' .. repru(tAltMidpoint) .. '; tAltMidpoint after adjust=' .. repru(GetPositionFromPathingSegments(iAdjustedSegmentX + iXNewAdjust, iAdjustedSegmentZ + iZNewAdjust)) .. '; iXNewAdjust=' .. iXNewAdjust .. '; iZNewAdjust=' .. iZNewAdjust)
                                        end
                                        tAltMidpoint = GetPositionFromPathingSegments(iAdjustedSegmentX + iXNewAdjust, iAdjustedSegmentZ + iZNewAdjust)
                                    end

                                    bHaveValidAltMidpoint = true
                                    iAveragePond = iPond
                                    tAverage = { tAltMidpoint[1], tAltMidpoint[2], tAltMidpoint[3] }
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': Have valid alternative midpoint which will now record and use, tAverage after update=' .. repru(tAverage) .. '; will see if can adjust slightly to be more in the water')
                                    end
                                    break
                                end
                            elseif bDebugMessages == true then
                                LOG(sFunctionRef .. ': Adjusted semgnet X-Z=' .. iAdjustedSegmentX .. '-' .. iAdjustedSegmentZ .. '; didnt have the right Water zone, was ' .. (tWaterZoneBySegment[iAdjustedSegmentX][iAdjustedSegmentZ] or 'nil') .. '; will draw segment midpoint in red if its in playaable area')
                                local tAltLocation = GetPositionFromPathingSegments(iAdjustedSegmentX, iAdjustedSegmentZ)
                                if tAltLocation and tAltLocation[1] > rMapPotentialPlayableArea[1] and tAltLocation[1] < rMapPotentialPlayableArea[3] and tAltLocation[3] > rMapPotentialPlayableArea[2] and tAltLocation[3] < rMapPotentialPlayableArea[4] then
                                    M28Utilities.DrawLocation(tAltLocation, 2)
                                end
                            end
                        end
                    end
                end
                if bHaveValidAltMidpoint then
                    break
                end
            end
            if bHaveValidAltMidpoint then
                break
            end
        end

        --If still dont have a valid location, then just try any segment recorded in the water zone (this wont be in the middle of the water zone, but is better than having an unpathable midpoint)
        if not (bHaveValidAltMidpoint) then
            local tMostUnderwaterBackupPosition, iCurUnderwaterHeightDif, iBackupPositionWZDataRef
            local iMostUnderwaterBackupPositionDif = 0
            for iSegment, tSegmentXZ in tWZData[subrefWZSegments] do
                if tWaterZoneBySegment[tSegmentXZ[1]][tSegmentXZ[2]] == iWaterZone then
                    tAltMidpoint = GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Cycling through recorded segments for this LZ, and considering segment X-Z=' .. (tSegmentXZ[1] or 'nil') .. '-' .. (tSegmentXZ[2] or 'nil') .. '; with land zone ' .. (tLandZoneBySegment[tSegmentXZ[1]][tSegmentXZ[2]] or 'nil') .. '; tAltMidpoint=' .. repru(tAltMidpoint) .. '; Plateau from navutils=' .. (NavUtils.GetTerrainLabel(refPathingTypeHover, tAltMidpoint) or 'nil') .. '; Island from navutils=' .. (NavUtils.GetTerrainLabel(refPathingTypeLand, tAltMidpoint) or 'nil'))
                    end
                    if NavUtils.GetTerrainLabel(refPathingTypeNavy, tAltMidpoint) == iPond then
                        bHaveValidAltMidpoint = true
                        iAveragePond = NavUtils.GetTerrainLabel(refPathingTypeNavy, tAltMidpoint)
                        tAverage = { tAltMidpoint[1], tAltMidpoint[2], tAltMidpoint[3] }
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Have valid alternative midpoint which will now record and use, tAverage after update=' .. repru(tAverage))
                        end
                        break
                    else
                        iCurUnderwaterHeightDif = GetSurfaceHeight(tAltMidpoint[1], tAltMidpoint[3]) - GetTerrainHeight(tAltMidpoint[1], tAltMidpoint[3])
                        if iCurUnderwaterHeightDif > iMostUnderwaterBackupPositionDif then
                            iMostUnderwaterBackupPositionDif = iCurUnderwaterHeightDif
                            tMostUnderwaterBackupPosition = {tAltMidpoint[1], tAltMidpoint[2], tAltMidpoint[3]}
                            iBackupPositionWZDataRef = iSegment
                        end
                    end
                end
            end
            if not (bHaveValidAltMidpoint) and M28Utilities.IsTableEmpty(tMostUnderwaterBackupPosition) == false then
                local tSegmentXZ = tWZData[subrefWZSegments][iBackupPositionWZDataRef]
                iAveragePond = tPondBySegment[tSegmentXZ[1]][tSegmentXZ[2]] or NavUtils.GetTerrainLabel(refPathingTypeNavy, tMostUnderwaterBackupPosition)
                if iAveragePond then
                    bHaveValidAltMidpoint = true
                    tAverage = {tMostUnderwaterBackupPosition[1], tMostUnderwaterBackupPosition[2], tMostUnderwaterBackupPosition[3]}
                    if bDebugMessages == true then LOG(sFunctionRef..': Will use backup position for midpoint, tMostUnderwaterBackupPosition='..repru(tMostUnderwaterBackupPosition)..'; iMostUnderwaterBackupPositionDif='..iMostUnderwaterBackupPositionDif..'; iAveragePond='..(iAveragePond or 'nil')) end
                end
            end
            if not (bHaveValidAltMidpoint) then
                M28Utilities.ErrorHandler(' dont have valid midpoint even after checking every water zone segment for iPond=' .. iPond .. '; will just use the first WZSegment')
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': iWaterZone=' .. iWaterZone .. '; tWZData[subrefWZSegments]=' .. repru(tWZData[subrefWZSegments] or 'nil') .. '; First segment position=' .. repru(GetPositionFromPathingSegments(tWZData[subrefWZSegments][1][1], tWZData[subrefWZSegments][1][2])) .. '; playable area=' .. repru(rMapPotentialPlayableArea) .. '; GetTerrainLabel navy pathing result for the first segment position=' .. (NavUtils.GetTerrainLabel(refPathingTypeNavy, GetPositionFromPathingSegments(tWZData[subrefWZSegments][1][1], tWZData[subrefWZSegments][1][2])) or 'nil') .. '; water zone of this segment position=' .. (tWaterZoneBySegment[tWZData[subrefWZSegments][1][1]][tWZData[subrefWZSegments][1][2]] or 'nil') .. '; will draw the water zone')
                    DrawSpecificWaterZone(iWaterZone, math.random(1, 8))
                end

            end
        end
    end

    --Campaign override - change midpoint if outside playable area but zone itself isnt
    if bDebugMessages == true then LOG(sFunctionRef..': Is this a campaign map='..tostring(bIsCampaignMap or false)..'; Playable area='..repru(rMapPlayableArea)..'; tverage='..repru(tAverage)..'; is this in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAverage))) end
    if bIsCampaignMap and not(M28Conditions.IsLocationInPlayableArea(tAverage)) then
        --Are we likely in the playable area?
        if ((iMinX >= rMapPlayableArea[1] and iMinX <= rMapPlayableArea[3]) or (iMaxX >= rMapPlayableArea[1] and iMaxX <= rMapPlayableArea[3])) and ((iMinZ >= rMapPlayableArea[2] and iMinZ <= rMapPlayableArea[4]) or (iMaxZ >= rMapPlayableArea[2] and iMaxZ <= rMapPlayableArea[4])) then
            --Cycle through each segment in water zone and record the one closest to the current average
            local iMinPlayableSegmentX, iMinPlayableSegmentZ = GetPathingSegmentFromPosition({rMapPlayableArea[1], 0, rMapPlayableArea[2]})
            iMinPlayableSegmentX = iMinPlayableSegmentX  +1
            iMinPlayableSegmentZ = iMinPlayableSegmentZ + 1
            local iMaxPlayableSegmentX, iMaxPlayableSegmentZ = GetPathingSegmentFromPosition({rMapPlayableArea[3], 0, rMapPlayableArea[4]})
            iMaxPlayableSegmentX = iMaxPlayableSegmentX - 1
            iMaxPlayableSegmentZ = iMaxPlayableSegmentZ - 1
            local iOriginalMidpointSegmentX, iOriginalMidpointSegmentZ = GetPathingSegmentFromPosition(tAverage)
            local iLowestDif = 100000
            local iCurDif
            local iClosestSegmentX, iClosestSegmentZ
            for iEntry, tSegmentXZ in tWZData[subrefWZSegments] do
                if tSegmentXZ[1] >= iMinPlayableSegmentX and tSegmentXZ[1] <= iMaxPlayableSegmentX and tSegmentXZ[2] >= iMinPlayableSegmentZ and tSegmentXZ[2] <= iMaxPlayableSegmentZ then
                    iCurDif = math.abs(tSegmentXZ[1] - iOriginalMidpointSegmentX) + math.abs(tSegmentXZ[2] - iOriginalMidpointSegmentZ)
                    if iCurDif < iLowestDif then
                        --Check that we are still in the pond if we used this position
                        if NavUtils.GetTerrainLabel(refPathingTypeNavy, GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])) == iPond then
                            iLowestDif = iCurDif
                            iClosestSegmentX = tSegmentXZ[1]
                            iClosestSegmentZ = tSegmentXZ[2]
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iLowestDif='..iLowestDif..'; iClosestSegmentXZ='..(iClosestSegmentX or 'nil')..'Z'..(iClosestSegmentZ or 'nil')) end
            if iClosestSegmentX then
                if bDebugMessages == true then LOG(sFunctionRef..': Will move the midpoint for the water zone to reflect the playable area, previous location='..repru(tAverage)..'; New location='..repru(GetPositionFromPathingSegments(iClosestSegmentX, iClosestSegmentZ))..'; Playable area='..repru(rMapPlayableArea)..'; Naval label for the new location='..(NavUtils.GetTerrainLabel(refPathingTypeNavy, GetPositionFromPathingSegments(iClosestSegmentX, iClosestSegmentZ)) or 'nil')..'; iPond='..iPond) end
                local tNewLocation = GetPositionFromPathingSegments(iClosestSegmentX, iClosestSegmentZ)
                tAverage = {tNewLocation[1], tNewLocation[2], tNewLocation[3]}
            end
        end
    end

    if bDebugMessages == true then
        LOG(sFunctionRef .. ': iAveragePond=' .. (iAveragePond or 'nil') .. '; iPond=' .. (iPond or 'nil') .. '; iAverageWaterZone=' .. (iAverageWaterZone or 'nil') .. '; iWaterZone=' .. (iWaterZone or 'nil') .. '; tAverage=' .. repru(tAverage))
    end
    if (iAveragePond == iPond and iAverageWaterZone == iWaterZone) then
        tWZData[subrefMidpoint] = { tAverage[1], tAverage[2], tAverage[3] }
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Will use the average position as the midpoint, tWZData[subrefMidpoint] for iWaterZone '..iWaterZone..'='..repru(tWZData[subrefMidpoint])..'; iPond='..iPond..'; Pond by water zone='..(tiPondByWaterZone[iWaterZone] or 'nil'))
        end
    else
        --Just use the first recorded segment of the water zone as the midpoint
        tWZData[subrefMidpoint] = GetPositionFromPathingSegments(tWZData[subrefWZSegments][1][1], tWZData[subrefWZSegments][1][2])
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': WIll use the first recorded segment as the midpoint, tWZData[subrefMidpoint]=' .. repru(tWZData[subrefMidpoint]))
        end
    end
    tWZData[refiMidpointAmphibiousLabel] = (NavUtils.GetTerrainLabel(refPathingTypeAmphibious, tWZData[subrefMidpoint]) or 0)
    if bDebugMessages == true then
        DrawSpecificWaterZone(iWaterZone, nil, 60)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordWaterZoneMidpointAndMinMaxPositions()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordWaterZoneMidpointAndMinMaxPositions'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    for iPond, tPondSubtable in tPondDetails do
        --Go through any mexes near a pond, and record against a waterzone if they're in water
        if bDebugMessages == true then LOG(sFunctionRef..': considering iPond='..iPond..'; Is table of mexes empty='..tostring(M28Utilities.IsTableEmpty(tPondSubtable[subrefPondMexInfo]))) end
        if M28Utilities.IsTableEmpty(tPondSubtable[subrefPondMexInfo]) == false then
            local iMexWaterZone, iMexPond
            for iMex, tSubtable in  tPondSubtable[subrefPondMexInfo] do
                local tMex = tSubtable[subrefMexLocation]
                iMexWaterZone = GetWaterZoneFromPosition(tMex)
                if (iMexWaterZone or 0) > 0 then
                    iMexPond = tiPondByWaterZone[iMexWaterZone]
                    AddMexToWaterZone(iMexPond, iMexWaterZone, tMex)
                    if bDebugMessages == true then LOG(sFunctionRef..': Just added mex at position '..repru(tMex)..' to iMexWaterZone='..iMexWaterZone) end
                end
            end
        end

        for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
            RecordMidpointMinAndMaxSegmentForWaterZone(iWaterZone, iPond, tWZData)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordWaterZoneAdjacentLandZones()
    --Update land zones with details of adjacent water zones, and update water zones wit hdetails of adjacent land zones
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordWaterZoneAdjacentLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iPlateau
    local iSegmentGapAllowed = math.max(3, math.ceil(24 / iLandZoneSegmentSize))
    local iDistBetweenMidpoints, iMaxLineInterval, iLineAngle, iCurLineSegmentX, iCurLineSegmentZ
    local iLineInterval = iLandZoneSegmentSize
    local tLinePosition
    local bIsAdjacent
    local iAdjacencyTablePosition
    local iBaseIntervalIgnoreThreshold = 4
    local iCloseIntervalIgnoreThreshold = 10
    if iLandZoneSegmentSize >= 2 then
        if iCloseIntervalIgnoreThreshold > 2 then iBaseIntervalIgnoreThreshold = 2 iCloseIntervalIgnoreThreshold = 5
        else iBaseIntervalIgnoreThreshold = 3 iCloseIntervalIgnoreThreshold = 7
        end
    end
    local iActualIntervalIgnoreThreshold
    local iCurIntervalIgnoreCount --i.e. if we are moving from one midpoint to another, and come across a different land or water zone, it increases the ignorecount by 1 if the midpoints aren't too far apart
    local tiAdditionalWaterZonesAdjacentToPlateauLandZone = {} --[x]=plateau, [y]=LZ; [z] = WZ; returns a count of how many times it appeared

    function RecordLandZoneAsAdjacentToWaterZone(tWZData, iWaterZone, tLZData, iPlateau, iLandZone, bCheckNotAlreadyRecorded)
        --Record water zone as adjacent to land zone
        local bNotRecorded = true
        if bCheckNotAlreadyRecorded then
            if M28Utilities.IsTableEmpty(tLZData[subrefAdjacentWaterZones]) == false then
                for iEntry, tAdjacencySubtable in tLZData[subrefAdjacentWaterZones] do
                    if tAdjacencySubtable[subrefAWZRef] == iWaterZone then bNotRecorded = false break end
                end
            end
        end
        if bNotRecorded then
            iAdjacencyTablePosition = 1
            if M28Utilities.IsTableEmpty(tLZData[subrefAdjacentWaterZones]) then
                tLZData[subrefAdjacentWaterZones] = {}
            else
                for iEntry, tAdjacencySubtable in tLZData[subrefAdjacentWaterZones] do
                    if tAdjacencySubtable[subrefAWZDistance] < iDistBetweenMidpoints then
                        iAdjacencyTablePosition = iEntry + 1
                    else
                        --Since table is ordered by distance later entries should be furhter away
                        break
                    end
                end
            end
            table.insert(tLZData[subrefAdjacentWaterZones], iAdjacencyTablePosition, {[subrefAWZRef] = iWaterZone, [subrefAWZDistance] = iDistBetweenMidpoints})
            if bDebugMessages == true then LOG(sFunctionRef..': Added iWaterZone='..iWaterZone..' as being adjacent to iLandZone='..iLandZone..'; tLZData[subrefAdjacentWaterZones]='..repru(tLZData[subrefAdjacentWaterZones])) end

            --Record land zone as adjacent to water zone
            iAdjacencyTablePosition = 1
            if M28Utilities.IsTableEmpty(tWZData[subrefAdjacentLandZones]) then
                tWZData[subrefAdjacentLandZones] = {}
            else
                for iEntry, tAdjacencySubtable in tWZData[subrefAdjacentLandZones] do
                    if tAdjacencySubtable[subrefALZDistance] < iDistBetweenMidpoints then
                        iAdjacencyTablePosition = iEntry + 1
                    else
                        --Since table is ordered by distance later entries should be furhter away
                        break
                    end
                end
            end
            if not(iPlateau) then M28Utilities.ErrorHandler('Have a nil plateau for iLandZone='..(iLandZone or 'nil')) end
            table.insert(tWZData[subrefAdjacentLandZones], iAdjacencyTablePosition, {[subrefWPlatAndLZNumber] = {iPlateau, iLandZone}, [subrefALZDistance] = iDistBetweenMidpoints})
        end
    end

    for iPond, tPondSubtable in tPondDetails do
        for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
            iPlateau = NavUtils.GetTerrainLabel(refPathingTypeHover, tWZData[subrefMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iWaterZone='..iWaterZone..'; iPlateau='..(iPlateau or 'nil')..'; Is plateau data empty='..tostring(M28Utilities.IsTableEmpty(tAllPlateaus[(iPlateau or -1)]))) end
            if (iPlateau or 0) > 0 and M28Utilities.IsTableEmpty(tAllPlateaus[iPlateau]) == false then
                --Cycle through every land zone on the map, and check if it is near this
                if not(tiAdditionalWaterZonesAdjacentToPlateauLandZone[iPlateau]) then tiAdditionalWaterZonesAdjacentToPlateauLandZone[iPlateau] = {} end
                for iLandZone, tLZData in tAllPlateaus[iPlateau][subrefPlateauLandZones] do
                    if not(tiAdditionalWaterZonesAdjacentToPlateauLandZone[iPlateau][iLandZone]) then tiAdditionalWaterZonesAdjacentToPlateauLandZone[iPlateau][iLandZone] = {} end
                    --Is this land zone adjacent? Might be adjacent the following are both the case:
                    --LZMinX is >= WZMinX and <=WZMaxX; or LZMaxX is >= WZMinX and <=WZMaxX
                    --As above but for Z
                    --Hover want to have a small tolerance for cliffs etc
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Considering if land zone '..iLandZone..' is near the water zone '..iWaterZone..'; iSegmentGapAllowed='..iSegmentGapAllowed..'; tLZData[subrefLZMinSegX]='..tLZData[subrefLZMinSegX]..'; tWZData[subrefWZMinSegX]='..tWZData[subrefWZMinSegX]..'; tLZData[subrefLZMaxSegX]='..tLZData[subrefLZMaxSegX]..'; tWZData[subrefWZMaxSegX]='..tWZData[subrefWZMaxSegX]..'; tLZData[subrefLZMinSegZ]='..tLZData[subrefLZMinSegZ]..'; tWZData[subrefWZMinSegZ]='..tWZData[subrefWZMinSegZ]..'; tWZData[subrefWZMaxSegZ]='..tWZData[subrefWZMaxSegZ]..'; tLZData[subrefLZMaxSegZ]='..tLZData[subrefLZMaxSegZ]..'; Test1A='..tostring(tLZData[subrefLZMinSegX] + iSegmentGapAllowed >= tWZData[subrefWZMinSegX])..'; Test1B='..tostring(tLZData[subrefLZMinSegX] - iSegmentGapAllowed <= tWZData[subrefWZMaxSegX])..'; Test 2A='..tostring(tLZData[subrefLZMaxSegX] + iSegmentGapAllowed >= tWZData[subrefWZMinSegX])..'; Test 2B='..tostring(tLZData[subrefLZMaxSegX] - iSegmentGapAllowed <= tWZData[subrefWZMaxSegX])..'; Test 5A='..tostring(tLZData[subrefLZMinSegZ] + iSegmentGapAllowed >= tWZData[subrefWZMinSegZ])..'; Test 5B='..tostring(tLZData[subrefLZMinSegZ] - iSegmentGapAllowed <= tWZData[subrefWZMaxSegZ])..'; Test 6A='..tostring(tLZData[subrefLZMaxSegZ] + iSegmentGapAllowed >= tWZData[subrefWZMinSegZ])..'; Test 6B='..tostring(tLZData[subrefLZMaxSegZ] - iSegmentGapAllowed <= tWZData[subrefWZMaxSegZ])..'; Tests 3-4 and 7-8 relate to where the X or Z is inside the other')
                    end
                    if ((tLZData[subrefLZMinSegX] + iSegmentGapAllowed >= tWZData[subrefWZMinSegX] and tLZData[subrefLZMinSegX] - iSegmentGapAllowed <= tWZData[subrefWZMaxSegX])
                        or (tLZData[subrefLZMaxSegX] + iSegmentGapAllowed >= tWZData[subrefWZMinSegX] and tLZData[subrefLZMaxSegX] - iSegmentGapAllowed <= tWZData[subrefWZMaxSegX])
                        --Cover where water zone is inside land zone:
                        or (tWZData[subrefWZMinSegX] >= tLZData[subrefLZMinSegX] and tWZData[subrefWZMaxSegX] <= tLZData[subrefLZMaxSegX])
                        --or land zone is inside water zone:
                        or (tLZData[subrefLZMinSegX] >= tWZData[subrefWZMinSegX] and tLZData[subrefLZMaxSegX] <= tWZData[subrefWZMaxSegX]))
                    and ((tLZData[subrefLZMinSegZ] + iSegmentGapAllowed >= tWZData[subrefWZMinSegZ] and tLZData[subrefLZMinSegZ] - iSegmentGapAllowed <= tWZData[subrefWZMaxSegZ])
                         or ((tLZData[subrefLZMaxSegZ] + iSegmentGapAllowed >= tWZData[subrefWZMinSegZ]) and (tLZData[subrefLZMaxSegZ] - iSegmentGapAllowed <= tWZData[subrefWZMaxSegZ]))
                            --Cover where water zone is inside land zone:
                        or (tWZData[subrefWZMinSegZ] >= tLZData[subrefLZMinSegZ] and tWZData[subrefWZMaxSegZ] <= tLZData[subrefLZMaxSegZ])
                        --or land zone is inside water zone:
                        or (tLZData[subrefLZMinSegZ] >= tWZData[subrefWZMinSegZ] and tLZData[subrefLZMaxSegZ] <= tWZData[subrefWZMaxSegZ])) then
                        --It looks like we might overlap, do a more precise calculation drawing a line from the two midpoints to see if we come across other land zones
                        bIsAdjacent = false
                        iDistBetweenMidpoints = M28Utilities.GetDistanceBetweenPositions(tWZData[subrefMidpoint], tLZData[subrefMidpoint])
                        iMaxLineInterval = math.floor(iDistBetweenMidpoints / iLineInterval) * iLineInterval
                        iLineAngle = M28Utilities.GetAngleFromAToB(tWZData[subrefMidpoint], tLZData[subrefMidpoint])
                        if iDistBetweenMidpoints <= 150 then
                            if iDistBetweenMidpoints <= 75 then iActualIntervalIgnoreThreshold = iCloseIntervalIgnoreThreshold
                            else iActualIntervalIgnoreThreshold = iBaseIntervalIgnoreThreshold
                            end
                        else
                            iActualIntervalIgnoreThreshold = 0
                        end
                        iCurIntervalIgnoreCount = 0
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Have land zone that is close to a ater zone, checking if we cross other land zones when going from one to the other, iDistBetweenMidpoints='..iDistBetweenMidpoints..'; iMaxLineInterval='..iMaxLineInterval..'; iLineAngle='..iLineAngle..'; tWZData[subrefMidpoint]='..repru(tWZData[subrefMidpoint])..'; LZ midpoint='..repru(tLZData[subrefMidpoint])..'; will draw zone midpoints')
                            M28Utilities.DrawLocation(tWZData[subrefMidpoint], 4, 200) --gold for WZ midpoint
                            M28Utilities.DrawLocation(tLZData[subrefMidpoint], 6, 200) --cyan for LZ midpoint
                        end
                        for iDistAlongLine = iLineInterval, iMaxLineInterval, iLineInterval do
                            tLinePosition = M28Utilities.MoveInDirection(tWZData[subrefMidpoint], iLineAngle, iDistAlongLine, false, false, false)
                            iCurLineSegmentX, iCurLineSegmentZ = GetPathingSegmentFromPosition(tLinePosition)
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': tLinePosition='..repru(tLinePosition)..'; iCurLineSegmentX='..(iCurLineSegmentX or 'nil')..'; iCurLineSegmentZ='..(iCurLineSegmentZ or 'nil')..'; tLandZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ]='..(tLandZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ] or 'nil')..'; tWaterZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ]='..(tWaterZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ] or 'nil')..'; iCurIntervalIgnoreCount='..iCurIntervalIgnoreCount..'; iActualIntervalIgnoreThreshold='..iActualIntervalIgnoreThreshold..'; Will draw this location')
                                M28Utilities.DrawLocation(tLinePosition, nil, 200)
                            end
                            if tLandZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ] then
                                if tLandZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ] == iLandZone then
                                    bIsAdjacent = true
                                    break
                                else
                                    --Not adjacent as is another land zone inbetween
                                    iCurIntervalIgnoreCount = iCurIntervalIgnoreCount + 1
                                    if iCurIntervalIgnoreCount > iActualIntervalIgnoreThreshold then
                                        break
                                    end
                                end
                            elseif tWaterZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ] then
                                if not(tWaterZoneBySegment[iCurLineSegmentX][iCurLineSegmentZ] == iWaterZone) then
                                    --not adjacent as is another water zone inbetween; record the inbetween waterzone as adjacent though
                                    iCurIntervalIgnoreCount = iCurIntervalIgnoreCount + 1
                                    tiAdditionalWaterZonesAdjacentToPlateauLandZone[iPlateau][iLandZone][iWaterZone] = (tiAdditionalWaterZonesAdjacentToPlateauLandZone[iPlateau][iLandZone][iWaterZone] or 0) + 1
                                    if iCurIntervalIgnoreCount > iActualIntervalIgnoreThreshold then
                                        break
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': bIsAdjacent='..tostring(bIsAdjacent)) end
                        if bIsAdjacent then
                            RecordLandZoneAsAdjacentToWaterZone(tWZData, iWaterZone, tLZData, iPlateau, iLandZone)
                        end
                    end

                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished recording adjacent water zones for iWaterZone='..iWaterZone..'; tWZData[subrefAdjacentLandZones]='..repru(tWZData[subrefAdjacentLandZones])) end
        end
    end
    if M28Utilities.IsTableEmpty(tiAdditionalWaterZonesAdjacentToPlateauLandZone) == false then
        for iPlateau, tLandSubtable in tiAdditionalWaterZonesAdjacentToPlateauLandZone do
            for iLandZone, tWaterSubtable in tLandSubtable do
                local tLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
                for iWaterZone, iEntryCount in tWaterSubtable do
                    if bDebugMessages == true then LOG(sFunctionRef..': Cycling through tiAdditionalWaterZonesAdjacentToPlateauLandZone, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iWaterZone='..iWaterZone..'; iEntryCount='..iEntryCount) end
                    if iEntryCount >= iBaseIntervalIgnoreThreshold then
                        local tWZData = tPondDetails[tiPondByWaterZone[iWaterZone]][subrefPondWaterZones][iWaterZone]
                        RecordLandZoneAsAdjacentToWaterZone(tWZData, iWaterZone, tLZData, iPlateau, iLandZone, true)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordLandZonePathingToOtherLandZonesInSamePlateau()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordLandZonePathingToOtherLandZonesInSamePlateau'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tbTempConsideredLandPathingForLZ = {}
    local iLowestLZ, iHighestLZ
    local iLandTravelDistance, iPathSize
    local iStartLZAdjacencyTablePosition
    local iEndLZAdjacencyTablePosition
    local bUseAdjacentApproach
    local iBaseDetailedAdjacencyLevel = 2 --after this will use approx approach

    if iMapSize < 1024 then
        iBaseDetailedAdjacencyLevel = 3
    end
    local iDetailedAdjacencyLevel = iBaseDetailedAdjacencyLevel
    if bDebugMessages == true then LOG(sFunctionRef..': Near code start, iDetailedAdjacencyLevel='..iDetailedAdjacencyLevel) end

    local tiTempLandPathingDistanceForLZ = {}

    function CalculateLandZoneTravelDistance(iPlateau, iStartLandZone, tLZData, iTargetLandZone, tOtherLZData, iOptionalLandTravelDistance, tOptionalLandZoneTravelPath)

        if iStartLandZone < iTargetLandZone then
            iLowestLZ = iStartLandZone
            iHighestLZ = iTargetLandZone
        else
            iLowestLZ = iTargetLandZone
            iHighestLZ = iStartLandZone
        end
        if bDebugMessages == true then
            LOG(sFunctionRef..': Checking if already recorded for iPlateau '..iPlateau..'; iLowestLZ='..iLowestLZ..'; iHighestLZ='..iHighestLZ..'; tiTempLandPathingDistanceForLZ[iPlateau][iLowestLZ][iHighestLZ]='..(tiTempLandPathingDistanceForLZ[iPlateau][iLowestLZ][iHighestLZ] or 'nil'))
        end
        if not(tiTempLandPathingDistanceForLZ[iPlateau][iLowestLZ][iHighestLZ]) then
            if tOptionalLandZoneTravelPath then
                M28Profiler.FunctionProfiler(sFunctionRef..': Adj Method', M28Profiler.refProfilerStart)
                if bDebugMessages == true then LOG(sFunctionRef..': Doing adj method, iPlateau='..iPlateau..'; iStartLandZone='..iStartLandZone..'; iOptionalLandTravelDistance='..(iOptionalLandTravelDistance or 'nil')..'; tOptionalLandZoneTravelPath='..repru(tOptionalLandZoneTravelPath)) end
            else M28Profiler.FunctionProfiler(sFunctionRef..': Detailed Method', M28Profiler.refProfilerStart)
            end
            if not(tiTempLandPathingDistanceForLZ[iPlateau][iLowestLZ]) then tiTempLandPathingDistanceForLZ[iPlateau][iLowestLZ] = {} end
            local tPathingLZFromStartToTarget, tFullPath, iInitialTravelDistance
            if iOptionalLandTravelDistance and tOptionalLandZoneTravelPath then
                tPathingLZFromStartToTarget = tOptionalLandZoneTravelPath
                iLandTravelDistance = iOptionalLandTravelDistance
            else
                tFullPath, iPathSize, iLandTravelDistance = NavUtils.PathTo(refPathingTypeLand, tLZData[subrefMidpoint], tOtherLZData[subrefMidpoint], nil)
                tPathingLZFromStartToTarget = {}
                --Reduce tFullPath to a table of land zones
                if tFullPath then
                    local iPathingPlateau, iPathingLandZone
                    local tPathingLZConsidered = {}
                    local tStart = {tLZData[subrefMidpoint][1], tLZData[subrefMidpoint][2], tLZData[subrefMidpoint][3]}
                    local tEnd = {tOtherLZData[subrefMidpoint][1], tOtherLZData[subrefMidpoint][2], tOtherLZData[subrefMidpoint][3]}

                    tFullPath[iPathSize + 1] = tEnd
                    for iPath = 1, iPathSize + 1 do
                        iPathingPlateau, iPathingLandZone = GetPlateauAndLandZoneReferenceFromPosition(tFullPath[iPath])
                        if iPathingLandZone > 0 then
                            if not(tPathingLZConsidered[iPathingLandZone]) and not(iStartLandZone == iPathingLandZone) then
                                tPathingLZConsidered[iPathingLandZone] = true
                                table.insert(tPathingLZFromStartToTarget, iPathingLandZone)
                            end
                        end
                    end
                    local iExtraStraightLineDist = VDist2(tStart[1], tStart[3], tFullPath[1][1], tFullPath[1][3]) + VDist2(tFullPath[iPathSize][1], tFullPath[iPathSize][3], tEnd[1], tEnd[3])
                    tFullPath[0] = tStart

                    --Redundancy for when the navmesh gives a significantly inaccurate result
                    --[[if bDebugMessages == true then LOG(sFunctionRef..': iLandTravelDistance before adj='..iLandTravelDistance..'; iExtraStraightLineDist='..iExtraStraightLineDist..'; straight line dist='..M28Utilities.GetDistanceBetweenPositions(tStart, tEnd)) end
                    local iStraightLineDist = VDist2(tStart[1], tStart[3], tEnd[1], tEnd[3])
                    iLandTravelDistance = math.max(iStraightLineDist, iLandTravelDistance + iExtraStraightLineDist)
                    if iLandTravelDistance >= 200 then
                        if iLandTravelDistance - iStraightLineDist >= 100 then
                            --Manually calculate
                            local iAltTravelDistance = iExtraStraightLineDist
                            if iPathSize > 1 then
                                for iPath = 2, iPathSize do
                                    iAltTravelDistance = iAltTravelDistance + VDist2(tFullPath[iPath - 1][1], tFullPath[iPath - 1][3], tFullPath[iPath][1], tFullPath[iPath][3])
                                end
                            end
                            if math.abs(iAltTravelDistance -  iLandTravelDistance) >= math.max(30, iAltTravelDistance * 0.25) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will use the more accurate iAltTravelDistance='..iAltTravelDistance..' instead of iLandTravelDistance='..iLandTravelDistance) end
                                iLandTravelDistance = iAltTravelDistance
                            end
                        end
                    end--]]
                end
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Is full path empty='..tostring(M28Utilities.IsTableEmpty(tFullPath))..'; iLandTravelDistance='..(iLandTravelDistance or 'nil')..'; repru of path='..repru(tFullPath)..'; LZ midpoint (start)='..repru(tLZData[subrefMidpoint])..'; Target LZ midpoint (end)='..repru(tOtherLZData[subrefMidpoint])..'; iPathSize='..iPathSize)
                    --Draw full path
                    if M28Utilities.IsTableEmpty(tFullPath) == false then
                        M28Utilities.DrawPath(tFullPath)
                    end
                end
            end
            if iLandTravelDistance then
                tiTempLandPathingDistanceForLZ[iPlateau][iLowestLZ][iHighestLZ] = iLandTravelDistance
                if not(tiTempLandPathingDistanceForLZ[iPlateau][iHighestLZ]) then tiTempLandPathingDistanceForLZ[iPlateau][iHighestLZ] = {} end
                tiTempLandPathingDistanceForLZ[iPlateau][iHighestLZ][iLowestLZ] = iLandTravelDistance

                --Record the travel distance
                if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZTravelDistToOtherLandZones][iPlateau]) then tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZTravelDistToOtherLandZones][iPlateau] = {} end
                tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZTravelDistToOtherLandZones][iPlateau][iStartLandZone] = iLandTravelDistance
                if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZTravelDistToOtherLandZones][iPlateau]) then tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZTravelDistToOtherLandZones][iPlateau] = {} end
                tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZTravelDistToOtherLandZones][iPlateau][iTargetLandZone] = iLandTravelDistance

                if bDebugMessages == true then
                    --[[LOG(sFunctionRef..': Travel distance to iTargetLandZone '..iTargetLandZone..' from '..iStartLandZone..' = '..iLandTravelDistance..'; tiTempLandPathingDistanceForLZ[iPlateau]='..repru(tiTempLandPathingDistanceForLZ[iPlateau])..'; will draw path between LZs')
                    if tFullPath and not(tOptionalLandZoneTravelPath) then M28Utilities.DrawPath(tFullPath, 1) end--]]
                    LOG(sFunctionRef..': Travel distance to iTargetLandZone '..iTargetLandZone..' from '..iStartLandZone..' = '..iLandTravelDistance)
                end

                --Get position in new table
                local iPosition = 1
                if not(tLZData[subrefLZPathingToOtherLandZones]) then
                    tLZData[subrefLZPathingToOtherLandZones] = {}
                    tLZData[subrefLZPathingToOtherLZEntryRef] = {}
                    iPosition = 1
                else
                    for iExistingLandZone, tExistingSubtable in tLZData[subrefLZPathingToOtherLandZones] do
                        if tExistingSubtable[subrefLZTravelDist] <  iLandTravelDistance then
                            iPosition = iPosition + 1
                        else
                            break
                        end
                    end
                end

                local iOppositePosition = 1
                if not(tOtherLZData[subrefLZPathingToOtherLandZones]) then
                    tOtherLZData[subrefLZPathingToOtherLandZones] = {}
                    tOtherLZData[subrefLZPathingToOtherLZEntryRef] = {}
                    iOppositePosition = 1
                else
                    for iExistingLandZone, tExistingSubtable in tOtherLZData[subrefLZPathingToOtherLandZones] do
                        if tExistingSubtable[subrefLZTravelDist] <  iLandTravelDistance then
                            iOppositePosition = iOppositePosition + 1
                        else
                            break
                        end
                    end
                end

                --If this isn't the last position then need to shift subrefLZPathingToOtherLZEntryRef entries
                local iStartTableSize = table.getn(tLZData[subrefLZPathingToOtherLandZones])
                local iEndTableSize = table.getn(tOtherLZData[subrefLZPathingToOtherLandZones])

                if iStartTableSize < iPosition then
                    for iLZRef, iTableRef in tLZData[subrefLZPathingToOtherLZEntryRef] do
                        if iTableRef >= iPosition then
                            tLZData[subrefLZPathingToOtherLZEntryRef][iLZRef] = iTableRef + 1
                        end
                    end
                end
                if iEndTableSize < iOppositePosition then
                    for iLZRef, iTableRef in tOtherLZData[subrefLZPathingToOtherLZEntryRef] do
                        if iTableRef >= iOppositePosition then
                            tOtherLZData[subrefLZPathingToOtherLZEntryRef][iLZRef] = iTableRef + 1
                        end
                    end
                end

                table.insert(tLZData[subrefLZPathingToOtherLandZones], iPosition, {[subrefLZNumber] = iTargetLandZone, [subrefLZPath] = {}, [subrefLZTravelDist] = iLandTravelDistance})
                table.insert(tOtherLZData[subrefLZPathingToOtherLandZones], iOppositePosition, {[subrefLZNumber] = iStartLandZone, [subrefLZPath] = {}, [subrefLZTravelDist] = iLandTravelDistance})

                tLZData[subrefLZPathingToOtherLZEntryRef][iTargetLandZone] = iPosition
                tOtherLZData[subrefLZPathingToOtherLZEntryRef][iStartLandZone] = iOppositePosition

                --Will update subrefLZPathingToOtherLZEntryRef in UpdateLZPathingEntryReferences as a redundancy (previously was the main logic)

                --Record the land zone path from start to target
                for iEntry, iLZ in tPathingLZFromStartToTarget do
                    table.insert(tLZData[subrefLZPathingToOtherLandZones][iPosition][subrefLZPath], iLZ)
                end
                --Record the land zone path from target to start (adding in the start as the final point)
                local iTotalEntries = table.getn(tPathingLZFromStartToTarget)
                for iEntry = iTotalEntries, 1, -1 do
                    if not(tPathingLZFromStartToTarget[iEntry] == iTargetLandZone) then
                        table.insert(tOtherLZData[subrefLZPathingToOtherLandZones][iOppositePosition][subrefLZPath], tPathingLZFromStartToTarget[iEntry])
                    end
                end
                if not(tPathingLZFromStartToTarget[1] == iStartLandZone) then
                    table.insert(tOtherLZData[subrefLZPathingToOtherLandZones][iOppositePosition][subrefLZPath], iStartLandZone)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finishrd subfunction, tLZData[subrefLZPathingToOtherLandZones][iPosition][subrefLZPath]='..repru(tLZData[subrefLZPathingToOtherLandZones][iPosition][subrefLZPath])..'; iPosition='..iPosition) end

            end
            if tOptionalLandZoneTravelPath then M28Profiler.FunctionProfiler(sFunctionRef..': Adj Method', M28Profiler.refProfilerEnd)
            else M28Profiler.FunctionProfiler(sFunctionRef..': Detailed Method', M28Profiler.refProfilerEnd)
            end
        end
    end

    for iPlateau, tPlateauSubtable in tAllPlateaus do
        if tPlateauSubtable[subrefLandZoneCount] >= 5 then M28Profiler.FunctionProfiler(sFunctionRef..': iPlateau '..iPlateau, M28Profiler.refProfilerStart) end

        tiTempLandPathingDistanceForLZ[iPlateau] = {}
        tAdjacencyEntriesByZoneAndLevel = {}
        tiZoneAdjacencyLevelByStartZone = {}
        iDetailedAdjacencyLevel = iBaseDetailedAdjacencyLevel

        if iMapSize >= 512 and tPlateauSubtable[subrefLandZoneCount] >= 14 then --i.e. calculations being done is effectively this number squared
            bUseAdjacentApproach = true --I.e. will use a less accurate method of approximating land travel distance based on adjacent zones
            if iDetailedAdjacencyLevel > 2 and tPlateauSubtable[subrefLandZoneCount] >= 50 then iDetailedAdjacencyLevel = 2 end
        else bUseAdjacentApproach = false
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateau '..iPlateau..', LZ count='..tPlateauSubtable[subrefLandZoneCount]..'; bUseAdjacentApproach='..tostring(bUseAdjacentApproach)..'; iMapSize='..(iMapSize or 'nil')) end
        if bUseAdjacentApproach then
            --First record adjacncies for each zone
            tAdjacencyEntriesByZoneAndLevel[1] = {}
            for iStartLandZone, tLZData in tPlateauSubtable[subrefPlateauLandZones] do
                tAdjacencyEntriesByZoneAndLevel[iStartLandZone] = {}
                tAdjacencyEntriesByZoneAndLevel[iStartLandZone][1] = {}
                tiZoneAdjacencyLevelByStartZone[iStartLandZone] = {}
                for _, iTargetLandZone in tLZData[subrefLZAdjacentLandZones] do
                    table.insert(tAdjacencyEntriesByZoneAndLevel[iStartLandZone][1], iTargetLandZone)
                    local tOtherLZData = tPlateauSubtable[subrefPlateauLandZones][iTargetLandZone]
                    tiZoneAdjacencyLevelByStartZone[iStartLandZone][iTargetLandZone] = 1
                    CalculateLandZoneTravelDistance(iPlateau, iStartLandZone, tLZData, iTargetLandZone, tOtherLZData) --Detailed method
                end
            end

            local bNoNewEntries

            for iCurAdjacencyLevel = 2, 100 do --redundancy, shouldnt need 100 adjacency levels
                bNoNewEntries = true
                tAdjacencyEntriesByZoneAndLevel[iCurAdjacencyLevel] = {}
                for iStartLandZone, tLZData in tPlateauSubtable[subrefPlateauLandZones] do
                    tAdjacencyEntriesByZoneAndLevel[iStartLandZone][iCurAdjacencyLevel] = {}
                    local tPrevAdjacencyZonesByTargetZone = {}
                    for _, iPrevAdjacentZone in tAdjacencyEntriesByZoneAndLevel[iCurAdjacencyLevel - 1] do
                        --Cycle through each zone adjacent to the previous adjacent zone, and consider if we haven't already calculated the pathing from startlandzone to this
                        local tCurLZData = tPlateauSubtable[subrefPlateauLandZones][iPrevAdjacentZone]
                        if M28Utilities.IsTableEmpty(tCurLZData[subrefLZAdjacentLandZones]) == false then
                            for _, iTargetLandZone in tCurLZData[subrefLZAdjacentLandZones] do
                                if not(tiZoneAdjacencyLevelByStartZone[iStartLandZone][iTargetLandZone]) then
                                    bNoNewEntries = false

                                    if iCurAdjacencyLevel <= iDetailedAdjacencyLevel then
                                        --Do detailed calculation instead (this has a check to make sure we dont do more than once)
                                        CalculateLandZoneTravelDistance(iPlateau, iStartLandZone, tLZData, iTargetLandZone, tPlateauSubtable[subrefPlateauLandZones][iTargetLandZone])
                                        tiZoneAdjacencyLevelByStartZone[iStartLandZone][iTargetLandZone] = iCurAdjacencyLevel
                                        table.insert(tAdjacencyEntriesByZoneAndLevel[iStartLandZone][iCurAdjacencyLevel], iTargetLandZone)
                                    else
                                        --Do adjacency method
                                        table.insert(tPrevAdjacencyZonesByTargetZone[iTargetLandZone], iPrevAdjacentZone)
                                    end
                                end
                            end
                        end

                    end

                    --Determine any zones under the adjacency method
                    if M28Utilities.IsTableEmpty(tPrevAdjacencyZonesByTargetZone) == false then
                        for iTargetLandZone, tPrevZones in tPrevAdjacencyZonesByTargetZone do
                            local iClosestPrevAdjacentZone

                            local iCurDistance
                            local iClosestDistance = 100000
                            for iEntry, iPrevAdjacentZone in tPrevZones do
                                iCurDistance =  tiTempLandPathingDistanceForLZ[iPlateau][iStartLandZone][iPrevAdjacentZone] + tiTempLandPathingDistanceForLZ[iPlateau][iPrevAdjacentZone][iTargetLandZone]
                                if iCurDistance < iClosestDistance then
                                    iClosestDistance = iCurDistance
                                    iClosestPrevAdjacentZone = iPrevAdjacentZone
                                end
                            end

                            --Now work out the path based on iClosestPrevAdjacentZone
                            local tiLZPath = {}
                            tiPathFromStartToNextAdjZone[iClosestNextAdjacencyZone] = {}
                            local iAdjacentRef = tLZData[subrefLZPathingToOtherLZEntryRef][iAdjacentLandZone]
                            if bDebugMessages == true then LOG(sFunctionRef..': iStartLandZone='..iStartLandZone..'; iAdjacentLandZone='..iAdjacentLandZone..'; iClosestNextAdjacencyZone='..iClosestNextAdjacencyZone..'; Refs for start LZ to other LZs='..repru(tLZData[subrefLZPathingToOtherLZEntryRef])..'; iCurAdjacencyLevel='..iCurAdjacencyLevel..'; iAdjacentRef='..iAdjacentRef..'; tLZData[subrefLZPathingToOtherLandZones][iAdjacentRef][subrefLZPath]='..repru(tLZData[subrefLZPathingToOtherLandZones][iAdjacentRef][subrefLZPath])) end
                            for iEntry, iPathingLandZone in tLZData[subrefLZPathingToOtherLandZones][iAdjacentRef][subrefLZPath] do
                                table.insert(tiLZPath, iPathingLandZone)
                            end
                            --Add the final destination
                            table.insert(tiLZPath, iTargetLandZone)

                            CalculateLandZoneTravelDistance(iPlateau, iStartLandZone, tLZData, iTargetLandZone, tPlateauSubtable[subrefPlateauLandZones][iTargetLandZone], iClosestDistance, tiLZPath)
                        end
                    end
                end
                if bNoNewEntries then break end
            end
        end
        --Want to do this even if we have done the adjacency approach, to make sure we have got pathing in place for eveyr zone
        for iStartLandZone, tLZData in tPlateauSubtable[subrefPlateauLandZones] do
            --Cycle through each other Land zone in this plateau and determine pathing
            if bDebugMessages == true then LOG(sFunctionRef..': Detailed pathing appraoch for plateaus with fewer Land zones - About to calculate pathing to each other Land zone for iStartLandZone='..iStartLandZone..'; in iPlateau='..iPlateau..'; subrefLZSegments size='..table.getn(tLZData[subrefLZSegments])) end
            for iTargetLandZone, tOtherLZData in tPlateauSubtable[subrefPlateauLandZones] do
                if not(iStartLandZone == iTargetLandZone) then
                    CalculateLandZoneTravelDistance(iPlateau, iStartLandZone, tLZData, iTargetLandZone, tOtherLZData)
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished considering all pathing for iStartLandZone='..iStartLandZone..'; tiTempLandPathingDistanceForLZ[iPlateau]='..repru(tiTempLandPathingDistanceForLZ[iPlateau])) end
        end

        if tPlateauSubtable[subrefLandZoneCount] >= 5 then M28Profiler.FunctionProfiler(sFunctionRef..': iPlateau '..iPlateau, M28Profiler.refProfilerEnd) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordWaterZonePathingToOtherWaterZones()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordWaterZonePathingToOtherWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tiWaterZonePairsConsideredByLowestWZ = {}
    local iLowestWZ, iHighestWZ
    local iNavalTravelDistance
    local iStartWZAdjacencyTablePosition
    local iEndWZAdjacencyTablePosition
    local bUseAdjacentApproach
    local bUseFastestApproach --even faster/more simplified than adjacent approach, done because on e.g. frostmill it was taking 15m and still not finishing with doing 415 water zones

    function CalculateWaterZoneTravelDistance(iWaterZone, tWZData, iOtherWaterZone, tOtherWZData, iOptionalNavalTravelDistance)
        if iWaterZone < iOtherWaterZone then
            iLowestWZ = iWaterZone
            iHighestWZ = iOtherWaterZone
        else
            iLowestWZ = iOtherWaterZone
            iHighestWZ = iWaterZone
        end
        if bDebugMessages == true then LOG(sFunctionRef..': CalculateWaterZoneTravelDistance - Calculating water zone travel distance, iLowestWZ='..iLowestWZ..'; iHighestWZ='..iHighestWZ..'; Dist for these pairs if already considered='..(tiWaterZonePairsConsideredByLowestWZ[iLowestWZ][iHighestWZ] or 'nil')) end
        if not(tiWaterZonePairsConsideredByLowestWZ[iLowestWZ][iHighestWZ]) then
            if not(tiWaterZonePairsConsideredByLowestWZ[iLowestWZ]) then tiWaterZonePairsConsideredByLowestWZ[iLowestWZ] = {} end
            iNavalTravelDistance = iOptionalNavalTravelDistance or M28Utilities.GetTravelDistanceBetweenPositions(tWZData[subrefMidpoint], tOtherWZData[subrefMidpoint], refPathingTypeNavy)
            if iNavalTravelDistance then
                iStartWZAdjacencyTablePosition = 1
                if M28Utilities.IsTableEmpty(tWZData[subrefWZOtherWaterZones]) then
                    tWZData[subrefWZOtherWaterZones] = {}
                else
                    for iEntry, tAdjacencySubtable in tWZData[subrefWZOtherWaterZones] do
                        if tAdjacencySubtable[subrefWZAWZDistance] < iNavalTravelDistance then
                            iStartWZAdjacencyTablePosition = iEntry + 1
                        else
                            --Since table is ordered by distance later entries should be furhter away
                            break
                        end
                    end
                end
                table.insert(tWZData[subrefWZOtherWaterZones], iStartWZAdjacencyTablePosition, {[subrefWZAWZRef] = iOtherWaterZone, [subrefWZAWZDistance] = iNavalTravelDistance})

                iEndWZAdjacencyTablePosition = 1
                if M28Utilities.IsTableEmpty(tOtherWZData[subrefWZOtherWaterZones]) then
                    tOtherWZData[subrefWZOtherWaterZones] = {}
                else
                    for iEntry, tAdjacencySubtable in tOtherWZData[subrefWZOtherWaterZones] do
                        if tAdjacencySubtable[subrefWZAWZDistance] < iNavalTravelDistance then
                            iEndWZAdjacencyTablePosition = iEntry + 1
                        else
                            --Since table is ordered by distance later entries should be furhter away
                            break
                        end
                    end
                end
                table.insert(tOtherWZData[subrefWZOtherWaterZones], iEndWZAdjacencyTablePosition, {[subrefWZAWZRef] = iWaterZone, [subrefWZAWZDistance] = iNavalTravelDistance})

                tiWaterZonePairsConsideredByLowestWZ[iLowestWZ][iHighestWZ] = iNavalTravelDistance
                if bDebugMessages == true then LOG(sFunctionRef..': CalculateWaterZoneTravelDistance - Have recorded adjacency position and naval distance, iNavalTravelDistance='..iNavalTravelDistance) end
            elseif bDebugMessages == true then LOG(sFunctionRef..': CalculateWaterZoneTravelDistance - Unable to travel between the two zones, midpoint for WZData='..repru(tWZData[subrefMidpoint])..'; Midpoint for other zone='..repru(tOtherWZData[subrefMidpoint])..'; Water height='..(iMapWaterHeight or 'nil')..'; Naval label for WZ midpoint='..(NavUtils.GetTerrainLabel(tWZData[subrefMidpoint]) or 'nil')..'; Navel label for other WZ midpoint='..(NavUtils.GetTerrainLabel(tOtherWZData[subrefMidpoint]) or 'nil'))
            end
        end
    end

    for iPond, tPondSubtable in tPondDetails do
        M28Profiler.FunctionProfiler(sFunctionRef..': Pond '..iPond, M28Profiler.refProfilerStart)
        bUseFastestApproach = false
        bUseAdjacentApproach = false
        if tPondSubtable[subrefPondWZCount] >= 21 then --Would take c.70s on a 56 size water zone pond, which is 3.1k squared, so reducing to 21 which is 441 squraed (i.e. hopefully means if would take >10s for this pond under default approach will use less accurate but faster method)
            if tPondSubtable[subrefPondWZCount] >= 50 and (iMapSize > 1024 or (tPondSubtable[subrefPondWZCount] >= 100 and iMapSize == 1024)) then
                bUseFastestApproach = true
            else
                bUseAdjacentApproach = true
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Considering pond '..iPond..', WZ count='..tPondSubtable[subrefPondWZCount]..'; bUseAdjacentApproach='..tostring(bUseAdjacentApproach)..'; System time='..GetSystemTimeSecondsOnlyForProfileUse()..'; bUseFastestApproach='..tostring(bUseFastestApproach)) end
        if bUseAdjacentApproach then
            --First calculate detailed pathing for each adjacent water zone
            for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
                for _, iOtherWaterZone in tWZData[subrefWZAdjacentWaterZones] do
                    local tOtherWZData = tPondSubtable[subrefPondWaterZones][iOtherWaterZone]
                    CalculateWaterZoneTravelDistance(iWaterZone, tWZData, iOtherWaterZone, tOtherWZData)
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished calculating adjacency for iWaterZone='..iWaterZone..'; iOtherWaterZone='..iOtherWaterZone) end
                end
            end

            local bKeepSearching
            local iCurAdjacencyLevel
            local tAdjacencyEntriesByLevel = {}
            local iPrevAdjacencyLevel
            local tiShortestTravelToTargetZone
            local iCurEntryApproxTravelDist
            local tbZoneConsideredForThisZone
            local bNotAlreadyRecordedTravelDistance

            for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
                bKeepSearching = true

                if bDebugMessages == true then LOG(sFunctionRef..': About to record all travel distances using adjacency method for iWaterZone='..iWaterZone) end
                iCurAdjacencyLevel = 1

                tAdjacencyEntriesByLevel = {}
                tAdjacencyEntriesByLevel[1] = {}
                tbZoneConsideredForThisZone = {}
                for _, iOtherWaterZone in tWZData[subrefWZAdjacentWaterZones] do
                    table.insert(tAdjacencyEntriesByLevel[iCurAdjacencyLevel], iOtherWaterZone)
                end
                while bKeepSearching do
                    bKeepSearching = false
                    iPrevAdjacencyLevel = iCurAdjacencyLevel
                    iCurAdjacencyLevel = iCurAdjacencyLevel + 1
                    tAdjacencyEntriesByLevel[iCurAdjacencyLevel] = {}
                    tiShortestTravelToTargetZone = {}

                    for iEntry, iOtherWaterZone in tAdjacencyEntriesByLevel[iPrevAdjacencyLevel] do
                        for _, iNextAdjacencyZone in tPondSubtable[subrefPondWaterZones][iOtherWaterZone][subrefWZAdjacentWaterZones] do
                            --E.g. zone travel from zzone 1 to zone 5 - when we record 1 to 5, that means we also ahve travel from 5 to 1; however since we are using an adjacency search approach, we still want zone 5 to keep searching even if every adjacent zone has been recorded, in case there are further out zone sthat havent been recorded, hence the use of both tbZoneConsideredForThisZone and bNotAlreadyRecordedTravelDistance
                            bNotAlreadyRecordedTravelDistance = (not(tiWaterZonePairsConsideredByLowestWZ[iWaterZone][iNextAdjacencyZone]) and not(tiWaterZonePairsConsideredByLowestWZ[iNextAdjacencyZone][iWaterZone]))
                            --if bDebugMessages == true then LOG(sFunctionRef..': iOtherWaterZone='..iOtherWaterZone..'; iNextAdjacencyZone='..iNextAdjacencyZone..'; iPrevAdjacencyLevel='..iPrevAdjacencyLevel..'; iCurAdjacencyLevel='..iCurAdjacencyLevel..'; Is tbZoneConsideredForThisZone[iNextAdjacencyZone] nil='..tostring(tbZoneConsideredForThisZone[iNextAdjacencyZone] == nil)..'; bNotAlreadyRecordedTravelDistance='..tostring(bNotAlreadyRecordedTravelDistance)) end
                            if bDebugMessages == true then LOG(sFunctionRef..': iNextAdjacencyZone='..iNextAdjacencyZone..'; iOtherWaterZone='..iOtherWaterZone..'; Have we considered for next adj zone='..tostring(tbZoneConsideredForThisZone[iNextAdjacencyZone] or false)..'; Have we considered for other water zone='..tostring(tbZoneConsideredForThisZone[iOtherWaterZone] or false)..'; bNotAlreadyRecordedTravelDistance='..tostring(bNotAlreadyRecordedTravelDistance)) end
                            if not(tbZoneConsideredForThisZone[iNextAdjacencyZone]) or bNotAlreadyRecordedTravelDistance then
                                bKeepSearching = true
                                tbZoneConsideredForThisZone[iNextAdjacencyZone] = true
                                if bDebugMessages == true then LOG(sFunctionRef..': iCurAdjacencyLevel='..iCurAdjacencyLevel..'; iWaterZone='..iWaterZone..'; iOtherWaterZone='..iOtherWaterZone..'; iNextAdjacencyZone='..iNextAdjacencyZone..'; tiWaterZonePairsConsideredByLowestWZ[iOtherWaterZone][iNextAdjacencyZone]='..(tiWaterZonePairsConsideredByLowestWZ[iOtherWaterZone][iNextAdjacencyZone] or 'nil')..'; tiWaterZonePairsConsideredByLowestWZ[iNextAdjacencyZone][iOtherWaterZone]='..(tiWaterZonePairsConsideredByLowestWZ[iNextAdjacencyZone][iOtherWaterZone] or 'nil')..'; tiWaterZonePairsConsideredByLowestWZ[iWaterZone][iOtherWaterZone]='..(tiWaterZonePairsConsideredByLowestWZ[iWaterZone][iOtherWaterZone] or 'nil')..'; tiWaterZonePairsConsideredByLowestWZ[iOtherWaterZone][iWaterZone]='..(tiWaterZonePairsConsideredByLowestWZ[iOtherWaterZone][iWaterZone] or 'nil')..'; bNotAlreadyRecordedTravelDistance='..tostring(bNotAlreadyRecordedTravelDistance or false)) end
                                table.insert(tAdjacencyEntriesByLevel[iCurAdjacencyLevel], iNextAdjacencyZone)
                                if bNotAlreadyRecordedTravelDistance then
                                    iCurEntryApproxTravelDist = (tiWaterZonePairsConsideredByLowestWZ[iOtherWaterZone][iNextAdjacencyZone] or tiWaterZonePairsConsideredByLowestWZ[iNextAdjacencyZone][iOtherWaterZone]) + (tiWaterZonePairsConsideredByLowestWZ[iWaterZone][iOtherWaterZone] or tiWaterZonePairsConsideredByLowestWZ[iOtherWaterZone][iWaterZone])
                                    if not(tiShortestTravelToTargetZone[iNextAdjacencyZone]) or iCurEntryApproxTravelDist < tiShortestTravelToTargetZone[iNextAdjacencyZone] then
                                        tiShortestTravelToTargetZone[iNextAdjacencyZone] = iCurEntryApproxTravelDist
                                    end
                                end
                            end
                        end
                    end
                    --Now record each entry
                    if M28Utilities.IsTableEmpty(tiShortestTravelToTargetZone) == false then
                        for iNextAdjacencyZone, iTravelDistance in tiShortestTravelToTargetZone do
                            CalculateWaterZoneTravelDistance(iWaterZone, tWZData, iNextAdjacencyZone, tPondSubtable[subrefPondWaterZones][iNextAdjacencyZone], iTravelDistance)
                        end
                    end
                end
            end
        end
        --Want to do this even if we have done the adjacency approach, to make sure we have got pathing in place for eveyr zone
        local iReplacementDistIfUsingFastMethod
        for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
            --Cycle through each other water zone in this pond and determine pathing
            if bDebugMessages == true then LOG(sFunctionRef..': Detailed pathing appraoch for ponds with fewer water zones - About to calculate pathing to each other water zone for iWaterZone='..iWaterZone..'; in iPond='..iPond..'; subrefWZSegments size='..table.getn(tWZData[subrefWZSegments])) end
            for iOtherWaterZone, tOtherWZData in tPondSubtable[subrefPondWaterZones] do
                if bUseFastestApproach then iReplacementDistIfUsingFastMethod = M28Utilities.GetDistanceBetweenPositions(tWZData[subrefMidpoint], tOtherWZData[subrefMidpoint]) end
                CalculateWaterZoneTravelDistance(iWaterZone, tWZData, iOtherWaterZone, tOtherWZData, iReplacementDistIfUsingFastMethod)
                --[[if not(iWaterZone == iOtherWaterZone) then
                    if iWaterZone < iOtherWaterZone then
                        iLowestWZ = iWaterZone
                        iHighestWZ = iOtherWaterZone
                    else
                        iLowestWZ = iOtherWaterZone
                        iHighestWZ = iWaterZone
                    end
                    if not(tiWaterZonePairsConsideredByLowestWZ[iLowestWZ][iHighestWZ]) then
                        if not(tiWaterZonePairsConsideredByLowestWZ[iLowestWZ]) then tiWaterZonePairsConsideredByLowestWZ[iLowestWZ] = {} end
                        iNavalTravelDistance = M28Utilities.GetTravelDistanceBetweenPositions(tWZData[subrefMidpoint], tOtherWZData[subrefMidpoint], refPathingTypeNavy)
                        if iNavalTravelDistance then
                            iStartWZAdjacencyTablePosition = 1
                            if M28Utilities.IsTableEmpty(tWZData[subrefWZOtherWaterZones]) then
                                tWZData[subrefWZOtherWaterZones] = {}
                            else
                                for iEntry, tAdjacencySubtable in tWZData[subrefWZOtherWaterZones] do
                                    if tAdjacencySubtable[subrefWZAWZDistance] < iNavalTravelDistance then
                                        iStartWZAdjacencyTablePosition = iEntry + 1
                                    else
                                        --Since table is ordered by distance later entries should be furhter away
                                        break
                                    end
                                end
                            end
                            table.insert(tWZData[subrefWZOtherWaterZones], iStartWZAdjacencyTablePosition, {[subrefWZAWZRef] = iOtherWaterZone, [subrefWZAWZDistance] = iNavalTravelDistance})

                            iEndWZAdjacencyTablePosition = 1
                            if M28Utilities.IsTableEmpty(tOtherWZData[subrefWZOtherWaterZones]) then
                                tOtherWZData[subrefWZOtherWaterZones] = {}
                            else
                                for iEntry, tAdjacencySubtable in tOtherWZData[subrefWZOtherWaterZones] do
                                    if tAdjacencySubtable[subrefWZAWZDistance] < iNavalTravelDistance then
                                        iEndWZAdjacencyTablePosition = iEntry + 1
                                    else
                                        --Since table is ordered by distance later entries should be furhter away
                                        break
                                    end
                                end
                            end
                            table.insert(tOtherWZData[subrefWZOtherWaterZones], iEndWZAdjacencyTablePosition, {[subrefWZAWZRef] = iWaterZone, [subrefWZAWZDistance] = iNavalTravelDistance})

                            tiWaterZonePairsConsideredByLowestWZ[iLowestWZ][iHighestWZ] = true
                        end
                    end
                end--]]
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished considering all pathing for iWaterZone='..iWaterZone..'; tiWaterZonePairsConsideredByLowestWZ='..repru(tiWaterZonePairsConsideredByLowestWZ)..'; tWZData[subrefWZOtherWaterZones]='..repru(tWZData[subrefWZOtherWaterZones])) end
        end

        M28Profiler.FunctionProfiler(sFunctionRef..': Pond '..iPond, M28Profiler.refProfilerEnd)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckIfLowMexMap()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckIfLowMexMap'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(bLowMexMapCheck) then
        bLowMexMapCheck = true
        local iTotalMexCount = 0
        for iPlateau, tPlateauSubtable in tAllPlateaus do
            iTotalMexCount = iTotalMexCount + (tPlateauSubtable[subrefPlateauTotalMexCount] or 0)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iTotalMexCount='..iTotalMexCount..'; Players at start='..M28Team.iPlayersAtGameStart) end

        if iTotalMexCount <= M28Team.iPlayersAtGameStart * 2.5 then
            --2.5 or fewer mexes per player - check total reclaim - cant rely on normal reclaiming tracking since likely hasnt been updated yet (and we need to know early on so we can decide whether to build a factory or not)
            local rRect = Rect(rMapPlayableArea[1], rMapPlayableArea[2], rMapPlayableArea[3], rMapPlayableArea[4])
            local iTotalReclaimMass = GetReclaimInRectangle(3, rRect)
            if bDebugMessages == true then LOG(sFunctionRef..': iTotalReclaimMass on map='..iTotalReclaimMass) end
            if iTotalReclaimMass <= 200 or (iTotalMexCount <= M28Team.iPlayersAtGameStart and iTotalReclaimMass <= 25000 * M28Team.iPlayersAtGameStart) then
                bIsLowMexMap = true
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iTotalReclaimMass='..iTotalReclaimMass..'; bIsLowMexMap='..tostring(bIsLowMexMap)) end
        end
    end



    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SetupMap()
    --Sets up non-brain specific info on the map
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupMap'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Send a message warning players this could take a while - moved to M28Overseer
    --[[for iBrain, oBrain in ArmyBrains do
        if oBrain.M28AI then
            M28Chat.SendMessage(oBrain, 'LoadingMap', 'Analysing map, this usually takes 1-2 minutes...', 0, 10000, false)
        end
    end--]]

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(4) --So chat message displays
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Decide how accurate map related functions are to be based on the map size:
    SetupPlayableAreaAndSegmentSizes()

    --Generate pathing
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; system time='..GetSystemTimeSecondsOnlyForProfileUse()..'; will generate navmesh if it isnt already generated, NavUtils.IsGenerated()='..tostring(NavUtils.IsGenerated())) end
    if not(NavUtils.IsGenerated()) then
        --local NavGen = import("/lua/sim/navgenerator.lua")
        --NavGen.Generate()
        if bDebugMessages == true then LOG('Considering whether to generate map markers for map generation, GameTime='..GetGameTimeSeconds()..'; M28Overseer.bBeginSessionTriggered='..tostring(M28Overseer.bBeginSessionTriggered)) end
        while (not(M28Overseer.bBeginSessionTriggered) and GetGameTimeSeconds() < 4) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        NavUtils.Generate()
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1) --Redundancy so chat message displays
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    GetMapWaterHeight()

    --Create table that stores details for each pathing group (e.g. land, amphibious) each mex in that group for easy reference later
    RecordMexForPathingGroup()

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1) --want to make sure our chat message displays (redundancy as moved to earlier now)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Create table with details on all plateaus (initially just those with mexes, although the land zone logic may add to this)
    RecordAllPlateaus() --Needed first since will organise land zones by plateau
    if bDebugMessages == true then LOG(sFunctionRef..': After RecordAllPlateaus, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end

    --Setup land zones
    SetupLandZones()
    if bDebugMessages == true then LOG(sFunctionRef..': After SetuplandZones, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end


    RecordPondDetails()

    bMapLandSetupComplete = true
    if bDebugMessages == true then LOG(sFunctionRef..': Finished setting up land aspects of the map, will move on to water zones, time='..GetGameTimeSeconds()..'; system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    SetupWaterZones() --Includes a wait to make sure we have M28 brains
    RecordIslands()
    if bDebugMessages == true then LOG(sFunctionRef..': Finished setting up water zones, will also now clal forked threads for other aspects, time='..GetGameTimeSeconds()..'; system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    ForkThread(ClearTemporarySetupVariables)
    ForkThread(ReclaimManager)

    --Campaign specific - reduce playable area to the current playable area (once have setup all zones based on full map size)
    if bIsCampaignMap then
        SetupPlayableAreaAndSegmentSizes()
    end

    CheckIfLowMexMap()
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, Time='..GetGameTimeSeconds()) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

--function GetDistanceFromStartAdjustedForDistanceFromMid()  end -- have replaced with GetModDistanceFromStart
function GetModDistanceFromStart(aiBrain, tTarget, bUseEnemyStartInstead)
    local sFunctionRef = 'GetModDistanceFromStart'
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Start of code, GameTime=' .. GetGameTimeSeconds() .. '; aiBrain army index=' .. aiBrain:GetArmyIndex() .. '; tTarget=' .. repru(tTarget) .. '; bUseEnemyStartInstead=' .. tostring((bUseEnemyStartInstead or false)) .. '; will draw the location in white')
        M28Utilities.DrawLocation(tTarget, false, 7, 20, nil)
    end

    local iEmergencyRangeToUse = 50

    local tStartPos
    local tEnemyBase
    if bUseEnemyStartInstead then
        tStartPos = GetPrimaryEnemyBaseLocation(aiBrain)
        tEnemyBase = GetPlayerStartPosition(aiBrain)
    else
        tStartPos = GetPlayerStartPosition(aiBrain)
        tEnemyBase = GetPrimaryEnemyBaseLocation(aiBrain)
    end

    local iDistStartToTarget = M28Utilities.GetDistanceBetweenPositions(tStartPos, tTarget)
    if bDebugMessages == true then LOG(sFunctionRef .. ': tStartPos=' .. repru(tStartPos) .. '; iDistStartToTarget=' .. iDistStartToTarget .. '; iEmergencyRangeToUse=' .. iEmergencyRangeToUse) end

    if iDistStartToTarget <= iEmergencyRangeToUse then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        if bDebugMessages == true then LOG(sFunctionRef .. ': Are within emergency range so will just return actual dist, iDistStartToTarget=' .. iDistStartToTarget .. '; if instead we only had 1 enemy and got mod dist for this the result would be ' .. math.cos(math.abs(M28Utilities.ConvertAngleToRadians(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, GetPrimaryEnemyBaseLocation(aiBrain))))) * iDistStartToTarget) end

        return iDistStartToTarget
    else
        --If only 1 enemy group then treat anywhere behind us as the emergency range
        if bUseEnemyStartInstead then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            if bDebugMessages == true then LOG(sFunctionRef .. ': will ignore multiple enemies since have flagged to use enemy start instead, will return ' .. math.cos(M28Utilities.ConvertAngleToRadians(math.abs(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, GetPlayerStartPosition(aiBrain))))) * iDistStartToTarget) end

            return iEmergencyRangeToUse, math.cos(math.abs(M28Utilities.ConvertAngleToRadians(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, tEnemyBase)))) * iDistStartToTarget
        else
            local bIsBehindUs = true
            if bDebugMessages == true then LOG(sFunctionRef .. ': Is table of enemy brains empty=' .. tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains]))) end

            if M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains]) then
                if M28Utilities.GetDistanceBetweenPositions(tTarget, tEnemyBase) < M28Utilities.GetDistanceBetweenPositions(tStartPos, tEnemyBase) or M28Utilities.GetDistanceBetweenPositions(tTarget, tStartPos) > M28Utilities.GetDistanceBetweenPositions(tStartPos, tEnemyBase) then
                    bIsBehindUs = false
                end
            else
                for iEnemyGroup, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains] do
                    if bDebugMessages == true then LOG(sFunctionRef .. ': Distance from target to start=' .. M28Utilities.GetDistanceBetweenPositions(tTarget, tStartPos) .. '; Distance from start to enemy base=' .. M28Utilities.GetDistanceBetweenPositions(tStartPos, GetPlayerStartPosition(oBrain))) end

                    if M28Utilities.GetDistanceBetweenPositions(tTarget, GetPlayerStartPosition(oBrain)) < M28Utilities.GetDistanceBetweenPositions(tStartPos, GetPlayerStartPosition(oBrain)) or M28Utilities.GetDistanceBetweenPositions(tTarget, tStartPos) > M28Utilities.GetDistanceBetweenPositions(tStartPos, GetPlayerStartPosition(oBrain)) then
                        bIsBehindUs = false
                        break
                    end
                end
            end

            if bIsBehindUs then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                if bDebugMessages == true then LOG(sFunctionRef .. ': Will return emergency range as enemy is behind us, so returning ' .. iEmergencyRangeToUse) end

                return iEmergencyRangeToUse
            else
                --Cycle through each enemy group and get lowest value, but stop if <= emergency range
                local iCurDist
                local iLowestDist = 10000
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains]) then
                    iLowestDist = math.cos(M28Utilities.ConvertAngleToRadians(math.abs(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, tEnemyBase)))) * iDistStartToTarget
                    if not(bIsCampaignMap) then M28Utilities.ErrorHandler('Dont have any enemy brains recorded for team '..aiBrain.M28Team..' so possible something has gone wrong') end
                else
                    for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains] do
                        iCurDist = math.cos(M28Utilities.ConvertAngleToRadians(math.abs(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, GetPlayerStartPosition(oBrain))))) * iDistStartToTarget
                        if bDebugMessages == true then LOG(sFunctionRef .. ': iCurDist for enemy oBrain index ' .. oBrain:GetArmyIndex() .. ' = ' .. iCurDist .. '; Enemy base=' .. repru(PlayerStartPoints[oBrain:GetArmyIndex()]) .. '; tEnemyBase=' .. repru(tEnemyBase) .. '; Angle from start to target=' .. M28Utilities.GetAngleFromAToB(tStartPos, tTarget) .. '; Angle from Start to enemy base=' .. M28Utilities.GetAngleFromAToB(tStartPos, PlayerStartPoints[oBrain:GetArmyIndex()]) .. '; iDistStartToTarget=' .. iDistStartToTarget) end

                        if iCurDist < iLowestDist then
                            iLowestDist = iCurDist
                            if iLowestDist < iEmergencyRangeToUse then
                                iLowestDist = iEmergencyRangeToUse
                                break
                            end
                        end
                    end
                end

                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                if bDebugMessages == true then LOG(sFunctionRef .. ': iLowestDist=' .. iLowestDist) end

                return iLowestDist
            end
        end
    end
end

function RecordAvailableMassStorageLocationsForLandZone(iPlateau, iLandZone)
    local tLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
    tLZData[subrefLZOrWZMassStorageLocationsAvailable] = {}
    if M28Utilities.IsTableEmpty(tLZData[subrefLZMexLocations]) == false then
        local tiXZOffset = {{-2,0}, {0, -2}, {0, 2}, {2, 0}}
        local tCurPos
        for iMex, tMex in tLZData[subrefLZMexLocations] do
            for iOffset, tXZOffset in tiXZOffset do
                tCurPos = {tMex[1] + tXZOffset[1], 0, tMex[3] + tXZOffset[2]}
                tCurPos[2] = GetSurfaceHeight(tCurPos[1], tCurPos[3])
                if M28Conditions.CanBuildStorageAtLocation(tCurPos) then
                    table.insert(tLZData[subrefLZOrWZMassStorageLocationsAvailable], tCurPos)
                end
            end
        end
    end
end

function RecordAvailableMassStorageLocationsForWaterZone(iWaterZone, tWZData)
    if M28Utilities.IsTableEmpty(tWZData[subrefWZMexLocations]) == false then
        local tiXZOffset = {{-2,0}, {0, -2}, {0, 2}, {2, 0}}
        local tCurPos
        for iMex, tMex in tWZData[subrefWZMexLocations] do
            for iOffset, tXZOffset in tiXZOffset do
                tCurPos = {tMex[1] + tXZOffset[1], 0, tMex[3] + tXZOffset[2]}
                tCurPos[2] = GetSurfaceHeight(tCurPos[1], tCurPos[3])
                if M28Conditions.CanBuildStorageAtLocation(tCurPos) then
                    if not(tWZData[subrefLZOrWZMassStorageLocationsAvailable]) then tWZData[subrefLZOrWZMassStorageLocationsAvailable] = {} end
                    table.insert(tWZData[subrefLZOrWZMassStorageLocationsAvailable], tCurPos)
                end
            end
        end
    end
end

function RecordMassStorageLocationsForEachLandZone()
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLZSubtable in tPlateauSubtable[subrefPlateauLandZones] do
            RecordAvailableMassStorageLocationsForLandZone(iPlateau, iLandZone)
        end
    end
end

function RecordMassStorageLocationsForEachWaterZone()
    if M28Utilities.IsTableEmpty(tPondDetails) == false then
        for iPond, tPondSubtable in tPondDetails do
            for iWaterZone, tWZData in tPondSubtable[subrefPondWaterZones] do
                RecordAvailableMassStorageLocationsForWaterZone(iWaterZone, tWZData)
            end
        end
    end
end


function GetReclaimLocationFromSegment(iReclaimSegmentX, iReclaimSegmentZ)
    --e.g. segment (1,1) will be 0 to ReclaimSegmentSizeX and 0 to ReclaimSegmentSizeZ in size
    --This will return the midpoint
    local iX = math.max(rMapPotentialPlayableArea[1], math.min(rMapPotentialPlayableArea[3], (iReclaimSegmentX - 0.5) * iReclaimSegmentSizeX))
    local iZ = math.max(rMapPotentialPlayableArea[2], math.min(rMapPotentialPlayableArea[4], (iReclaimSegmentZ - 0.5) * iReclaimSegmentSizeZ))
    return {iX, GetSurfaceHeight(iX, iZ), iZ}
end

function GetReclaimSegmentsFromLocation(tLocation)
    return math.ceil(tLocation[1] / iReclaimSegmentSizeX), math.ceil(tLocation[3] / iReclaimSegmentSizeZ)
end

function ReclaimManager()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'ReclaimManager'

    local tAreasToUpdateThisCycle
    local iUpdateCount = 0
    local iMaxUpdatesPerTick
    local iWaitCount
    local iLoopCount
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Time='..GetGameTimeSeconds()) end
    if not(bReclaimManagerActive) then
        bReclaimManagerActive = true
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart) --Want the profile coutn to reflect the number of times actually running the core code
        while bReclaimManagerActive do
            if bDebugMessages == true then LOG(sFunctionRef..': Start of main active loop') end

            tAreasToUpdateThisCycle = {}
            iUpdateCount = 0
            iWaitCount = 0
            if M28Utilities.IsTableEmpty(tReclaimSegmentsToUpdate) then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(10)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            else
                --Copy table into tAreasToUpdateThisCycle
                if bDebugMessages == true then
                    LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..'; Will list out all entries in tReclaimSegmentsToUpdate if it isnt nil')
                    if tReclaimSegmentsToUpdate then LOG(repru(tReclaimSegmentsToUpdate)) end
                end
                for iEntry, tSubtable in tReclaimSegmentsToUpdate do
                    if (tSubtable[2] or 0) > 0 and (tSubtable[1] or 0) > 0 then --Dont bother updating places right on map edge in case pathfinding issue
                        if not(tAreasToUpdateThisCycle[tSubtable[1]]) then tAreasToUpdateThisCycle[tSubtable[1]] = {} end
                        if not(tAreasToUpdateThisCycle[tSubtable[1]][tSubtable[2]]) then
                            iUpdateCount = iUpdateCount + 1
                            tAreasToUpdateThisCycle[tSubtable[1]][tSubtable[2]] = true
                        end
                    end
                end
                --Clear the table for the next cycle
                tReclaimSegmentsToUpdate = {}
                if iUpdateCount == 0 then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(10)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                else
                    iMaxUpdatesPerTick = math.max(5, math.min(20, math.ceil(iUpdateCount / 10)))
                    if GetGameTimeSeconds() <= 10 then iMaxUpdatesPerTick = 50000 end
                    iLoopCount = 0
                    if bDebugMessages == true then LOG(sFunctionRef..': About to update for iUpdateCount='..iUpdateCount..' entries; max updates per tick='..iMaxUpdatesPerTick..'; tAreasToUpdateThisCycle='..repru(tAreasToUpdateThisCycle)) end
                    for iSegmentX, tSubtable1 in tAreasToUpdateThisCycle do
                        for iSegmentZ, tSubtable2 in tAreasToUpdateThisCycle[iSegmentX] do
                            iLoopCount = iLoopCount + 1
                            if iLoopCount > iMaxUpdatesPerTick then
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                WaitTicks(1)
                                iWaitCount = iWaitCount + 1
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                                iLoopCount = 1
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': About to update reclaim data for segments '..iSegmentX..'-'..iSegmentZ) end
                            UpdateReclaimDataNearSegments(iSegmentX, iSegmentZ, 0, nil)
                        end
                    end
                    if iWaitCount < 10 then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(10 - iWaitCount)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    end
                end
            end

            --Update any zones that received multiple updates (since we ewould have only updated the first time from the above)
            UpdateDelayedZoneData()
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function ReassignReclaimSegment(iReclaimSegmentX, iReclaimSegmentZ, tCurAssignedLZOrWZData)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'ReassignReclaimSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(tCurAssignedLZOrWZData[subrefReclaimSegments]) == false then
        for iEntry, tReclaimXZ in tCurAssignedLZOrWZData[subrefReclaimSegments] do
            if tReclaimXZ[1] == iReclaimSegmentX and tReclaimXZ[2] == iReclaimSegmentZ then
                if bDebugMessages == true then LOG(sFunctionRef..': will remove reclaim segment X'..iReclaimSegmentZ..'Z'..iReclaimSegmentZ..' from the LZOrWZData, iEntry='..iEntry) end
                table.remove(tCurAssignedLZOrWZData[subrefReclaimSegments], iEntry)
                break
            end
        end
    end
    CreateReclaimSegment(iReclaimSegmentX, iReclaimSegmentZ)
    UpdateReclaimDataNearSegments(iReclaimSegmentX, iReclaimSegmentZ, 0)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CreateReclaimSegment(iReclaimSegmentX, iReclaimSegmentZ)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'CreateReclaimSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if not(tReclaimAreas[iReclaimSegmentX]) then tReclaimAreas[iReclaimSegmentX] = {} end
    tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ] = {}
    tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint] = GetReclaimLocationFromSegment(iReclaimSegmentX, iReclaimSegmentZ)
    --tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refsSegmentMidpointLocationRef] = M28Utilities.ConvertLocationToReference(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint])
    local iPlateau, iLandZone = GetPlateauAndLandZoneReferenceFromPosition(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint])
    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, iReclaimSegmentX='..iReclaimSegmentX..'Z'..iReclaimSegmentZ..'; Time of '..GetGameTimeSeconds()..'; iPlateau='..(iPlateau or 'nil')..'; iLandZOne='..(iLandZone or 'nil')..'; WZ='..(GetWaterZoneFromPosition(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint]) or 'nil')) end
    if (iPlateau or 0) == 0 or (not(iLandZone) and not(GetWaterZoneFromPosition(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint]))) then
        --If we get the reclaim location, is it in a pathable area, or within 2 of a pathable area?
        local rRect = M28Utilities.GetRectAroundLocation(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint], iReclaimSegmentSizeX * 0.5)
        local tReclaimables = GetReclaimInRectangle(4, rRect)
        if M28Utilities.IsTableEmpty(tReclaimables) == false then
            local iCurPlateau, iCurLandZone
            local tiXZOffset = {{-2,-2}, {-2, 2}, {2, -2}, {2, 2}}
            for iReclaim, oReclaim in tReclaimables do
                iCurPlateau, iCurLandZone = GetPlateauAndLandZoneReferenceFromPosition(oReclaim.CachePosition)
                if (iCurPlateau or 0) == 0 then
                    --Search nearby
                    for _, tiXZAdjust in tiXZOffset do
                        iCurPlateau, iCurLandZone = GetPlateauAndLandZoneReferenceFromPosition({oReclaim.CachePosition[1] + tiXZAdjust[1], oReclaim.CachePosition[2], oReclaim.CachePosition[3] + tiXZAdjust[2]})
                        if (iCurPlateau or 0) > 0 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Reclaim location '..repru(oReclaim.CachePosition)..' isnt pathable but if we adjust by '..repru(tiXZAdjust)..' then it becomes pathable, adjusted position='..repru({oReclaim.CachePosition[1] + tiXZAdjust[1], oReclaim.CachePosition[2], oReclaim.CachePosition[3] + tiXZAdjust[2]})..'; iCurPlateau='..iCurPlateau..'; iCurLandZone='..(iCurLandZone or 'nil')) end
                            break
                        end
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Reclaim midpoint '..repru(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint])..' isnt pathable but the reclaim position itself, '..repru(oReclaim.CachePosition)..' is pathable, iCurPlateau='..iCurPlateau..'; iCurLandZone='..(iCurLandZone or 'nil')) end
                end
                if (iCurPlateau or 0) > 0 then
                    iPlateau = iCurPlateau
                    iLandZone = iCurLandZone
                    break
                end
            end
        end

    end
    if bDebugMessages == true then LOG(sFunctionRef..': Adding iReclaimSegmentX-Z'..iReclaimSegmentX..'-'..iReclaimSegmentZ..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
    if (iLandZone or 0) > 0 then
        --Record in the land zone
        if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefReclaimSegments]) then
            tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefReclaimSegments] = {}
        end
        table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefReclaimSegments], {iReclaimSegmentX, iReclaimSegmentZ})
        if bDebugMessages == true then
            LOG(sFunctionRef..': Finished adding reclaim segment to LZ, all reclaim segments for this LZ='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefReclaimSegments]))
            local rCurRect = M28Utilities.GetRectAroundLocation(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint], iReclaimSegmentSizeX * 0.5)
            M28Utilities.DrawRectangle(rCurRect, 4)
        end
    elseif (iPlateau or 0) > 0 then
        --Record in the water zone
       local iWaterZone = GetWaterZoneFromPosition(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint])
        if (iWaterZone or 0) > 0 then
            local iPond = tiPondByWaterZone[iWaterZone]
            local tWZData = tPondDetails[iPond][subrefPondWaterZones][iWaterZone]
            if not(tWZData[subrefReclaimSegments]) then tWZData[subrefReclaimSegments] = {} end
            table.insert(tWZData[subrefReclaimSegments], {iReclaimSegmentX, iReclaimSegmentZ})
            if bDebugMessages == true then
                LOG(sFunctionRef..': Finished adding reclaim segment to WZ, all reclaim segments for this WZ='..repru(tWZData[subrefReclaimSegments]))
                local rCurRect = M28Utilities.GetRectAroundLocation(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint], iReclaimSegmentSizeX * 0.5)
                M28Utilities.DrawRectangle(rCurRect, 4)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateDelayedZoneData()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'UpdateDelayedZoneData'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28Utilities.IsTableEmpty(tiPlateauAndZonesToRefreshReclaimAgain) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': near start, about to refresh for the following entries at time='..GetGameTimeSeconds()..':'..repru(tiPlateauAndZonesToRefreshReclaimAgain)) end
        local iPlateauOrPond
        for iPlateauOrZero, tZones in tiPlateauAndZonesToRefreshReclaimAgain do
            for iEntry, iLandOrWaterZone in tZones do
                if iPlateauOrZero == 0 then iPlateauOrPond = tiPondByWaterZone[iLandOrWaterZone] else iPlateauOrPond = iPlateauOrZero end
                RefreshLandOrWaterZoneReclaimValue(iPlateauOrPond, iLandOrWaterZone, iPlateauOrZero == 0, false, false)
            end
        end
        tiPlateauAndZonesToRefreshReclaimAgain = {}
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AddZoneForDelayedRefresh(iPlateauOrZero, iLandOrWaterZone)
    --If a zone was refreshed in the last second previously (and a segment in it has since been updated within that last second) then it gets added to a table for a refresh later on
    --local iTime = math.floor(GetGameTimeSeconds())
    local bAlreadyRecorded = false
    --[[if not(tiPlateauAndZonesToRefreshReclaimAgain[iTime]) then
        tiPlateauAndZonesToRefreshReclaimAgain[iTime] = {}
        tiPlateauAndZonesToRefreshReclaimAgain[iTime][iPlateauOrZero] = {}
    else--]]
    if not(tiPlateauAndZonesToRefreshReclaimAgain[iPlateauOrZero]) then
        tiPlateauAndZonesToRefreshReclaimAgain[iPlateauOrZero] = {}
    else
        for iEntry, iZone in tiPlateauAndZonesToRefreshReclaimAgain[iPlateauOrZero] do
            if iZone == iLandOrWaterZone then
                bAlreadyRecorded = true
                break
            end
        end
    end
    if not(bAlreadyRecorded) then table.insert(tiPlateauAndZonesToRefreshReclaimAgain[iPlateauOrZero], iLandOrWaterZone) end
end

function RefreshLandOrWaterZoneReclaimValue(iPlateauOrPond, iLandOrWaterZone, bIsWaterZone, bUpdateAllReclaimSegmentsWithMass, bAlsoUpdateIfNoMass)
    --bUpdateAllReclaimSegmentsWithMass - optional, kif true, then when updating will update the reclaim value in each reclaim segment; i.e. set this to true if we try reclaiming in an area and expect to have reclaim but dont
    --bAlsoUpdateIfNoMass - optional; if bUpdateAllReclaimSegmentsWithMass is true, then if thisi s true will ignore the 'must have mass value to update' condition - intended for start of game logic like deciding tarnsport drop start of game shortlist
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RefreshLandOrWaterZoneReclaimValue'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tLZOrWZData
    if bIsWaterZone then tLZOrWZData = tPondDetails[iPlateauOrPond][subrefPondWaterZones][iLandOrWaterZone]
    else
        tLZOrWZData = tAllPlateaus[iPlateauOrPond][subrefPlateauLandZones][iLandOrWaterZone]
    end
    tLZOrWZData[subrefLastReclaimRefresh] = GetGameTimeSeconds()
    if bUpdateAllReclaimSegmentsWithMass then tLZOrWZData[subrefLastComprehensiveReclaimRefresh] = GetGameTimeSeconds() end
    local iMassReclaim = 0
    local iEnergyReclaim = 0
    local iSignificantMassReclaim = 0
    local iHighestIndividualReclaim = 0
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at Time='..GetGameTimeSeconds()..'; bIsWaterZone='..tostring(bIsWaterZone or false)..'; Considering PlateauOrPond='..iPlateauOrPond..'; iLandOrWaterZone='..iLandOrWaterZone..'; Is table of LZ or WZ reclaim segments empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[subrefReclaimSegments]))) end
    if M28Utilities.IsTableEmpty(tLZOrWZData[subrefReclaimSegments]) == false then
        for iSegmentCount, tSegmentXZ in tLZOrWZData[subrefReclaimSegments] do
            local tCurReclaimArea = tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]]
            if bUpdateAllReclaimSegmentsWithMass then
                if (tCurReclaimArea[refReclaimTotalMass] or 0) > 0 or bAlsoUpdateIfNoMass then
                    UpdateReclaimDataNearSegments(tSegmentXZ[1], tSegmentXZ[2], 0)
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering tSegmentXZ='..tSegmentXZ[1]..'-'..tSegmentXZ[2]..'; total mass in this segment='..(tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][refReclaimTotalMass] or 'nil')..'; Total significant mass in segment='..(tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][refReclaimTotalSignificantMass] or 'nil')..'; Energy='..(tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][refSegmentReclaimTotalEnergy] or 0)) end
            iMassReclaim = iMassReclaim + (tCurReclaimArea[refReclaimTotalMass] or 0)
            iEnergyReclaim = iEnergyReclaim + (tCurReclaimArea[refSegmentReclaimTotalEnergy] or 0)
            iSignificantMassReclaim = iSignificantMassReclaim + (tCurReclaimArea[refReclaimTotalSignificantMass] or 0)
            if tCurReclaimArea[refReclaimHighestIndividualMassReclaim] > iHighestIndividualReclaim then iHighestIndividualReclaim = tCurReclaimArea[refReclaimHighestIndividualMassReclaim] end
        end
    end
    tLZOrWZData[subrefTotalMassReclaim] = iMassReclaim
    tLZOrWZData[subrefTotalSignificantMassReclaim] = iSignificantMassReclaim
    tLZOrWZData[subrefLZTotalEnergyReclaim] = iEnergyReclaim
    tLZOrWZData[subrefHighestIndividualReclaim] = iHighestIndividualReclaim

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iMassReclaim='..iMassReclaim..'; LZ reclaim='..tLZOrWZData[subrefTotalMassReclaim]) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetReclaimablesMassAndEnergy(tReclaimables, iMinMass, iMinEnergy, bApplyDebug)
    --Largely a copy of GetReclaimablesResourceValue, but focused specificaly on the reclaim segment update logic
    --Must have at least iMinMass or iMinEnergy to be recorded
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true or bApplyDebug then   bDebugMessages = true end
    local sFunctionRef = 'GetReclaimablesMassAndEnergy'
    --V14 and earlier would modify total mass value to reduce it by 25% if its small, and 50% if its medium; v15 removed this
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local sMassRef = 'MaxMassReclaim'
    local sEnergyRef = 'MaxEnergyReclaim'

    local tWreckPos = {}
    local iTotalMass = 0
    local iTotalEnergy = 0

    local iLargestCurReclaim = 0
    local iLargestReclaimRef = 0
    local iTotalMassAboveThreshold = 0
    local iMassThreshold = math.max(iSignificantMassThreshold, iMinMass or 0) --Will consider anything >= this for iTotalMassAboveThreshold

    if tReclaimables and table.getn( tReclaimables ) > 0 then
        for iReclaimRef, v in tReclaimables do
            tWreckPos = v.CachePosition
            if tWreckPos[1] then
                --if v.MaxMassReclaim > iIgnoreReclaimIfNotMoreThanThis then
                if not(v:BeenDestroyed()) then
                    if bDebugMessages == true then LOG(sFunctionRef..': iReclaimRef='..iReclaimRef..'; Mass='..(v[sMassRef] or 'nil')..'; Energy='..(v[sEnergyRef] or 'nil')) end
                    if v[sMassRef] > iMinMass then
                        iTotalMass = iTotalMass + v[sMassRef]
                        if v[sMassRef] >= iMassThreshold then
                            iTotalMassAboveThreshold = iTotalMassAboveThreshold + v[sMassRef]
                        end
                        if v[sMassRef] > iLargestCurReclaim then
                            iLargestCurReclaim = v[sMassRef]
                            iLargestReclaimRef = iReclaimRef
                        end
                    end
                    if v[sEnergyRef] > iMinEnergy then
                        iTotalEnergy = iTotalEnergy + v[sEnergyRef]
                    end
                end
            else
                if not(v.MaxMassReclaim == nil) then
                    if v.MaxMassReclaim > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Warning - have ignored wreck location despite it having a mass reclaim value') end
                    end
                end
            end
        end
    end
    local tReclaimPos
    if iLargestReclaimRef then tReclaimPos = {tReclaimables[iLargestReclaimRef][1], tReclaimables[iLargestReclaimRef][2], tReclaimables[iLargestReclaimRef][3]} end

    if bDebugMessages == true then LOG(sFunctionRef..': Is table of tReclaimables empty='..tostring(M28Utilities.IsTableEmpty(tReclaimables))..'; iMinMass='..(iMinMass or 'nil')..'; iMinEnergy='..(iMinEnergy or 'nil')..'; iTotalMass='..iTotalMass..'; iLargestCurReclaim='..iLargestCurReclaim..'; iTotalEnergy='..iTotalEnergy..'; iTotalMassAboveThreshold='..iTotalMassAboveThreshold) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iTotalMass, tReclaimPos, iLargestCurReclaim, iTotalEnergy, iTotalMassAboveThreshold
end

function GetReclaimSegmentRectangle(iSegmentX, iSegmentZ, iOptionalSizeIncrease)
    --iOptionalSizeIncrease - will do the higher of this and the reclaim segment sizeX/Z value if this is specified
    if iOptionalSizeIncrease then
        return Rect((iSegmentX - 1) * iReclaimSegmentSizeX - math.max(0, iOptionalSizeIncrease - iReclaimSegmentSizeX), (iSegmentZ - 1) * iReclaimSegmentSizeZ - math.max(0, iOptionalSizeIncrease - iReclaimSegmentSizeZ), iSegmentX * iReclaimSegmentSizeX + math.max(0, iOptionalSizeIncrease - iReclaimSegmentSizeX), iSegmentZ * iReclaimSegmentSizeZ + math.max(0, iOptionalSizeIncrease - iReclaimSegmentSizeZ))
    else
        return Rect((iSegmentX - 1) * iReclaimSegmentSizeX, (iSegmentZ - 1) * iReclaimSegmentSizeZ, iSegmentX * iReclaimSegmentSizeX, iSegmentZ * iReclaimSegmentSizeZ)
    end
end

function RemoveFromVeryHighValueSegmentTable(iSegmentX, iSegmentZ)
    if M28Utilities.IsTableEmpty(tiVeryHighValueReclaimSegments) == false then
        for iEntry, tSegXZ in tiVeryHighValueReclaimSegments do
            if tSegXZ[1] == iSegmentX and tSegXZ[2] == iSegmentZ then
                table.remove(tiVeryHighValueReclaimSegments, iEntry)
                break
            end
        end
    end
end

function AddToVeryHighValueSegmentTable(iSegmentX, iSegmentZ)
    local bAlreadyIncluded = false
    if M28Utilities.IsTableEmpty(tiVeryHighValueReclaimSegments) == false then
        for iEntry, tSegXZ in tiVeryHighValueReclaimSegments do
            if tSegXZ[1] == iSegmentX and tSegXZ[2] == iSegmentZ then
                bAlreadyIncluded = true
                break
            end
        end
    end
    if not(bAlreadyIncluded) then
        table.insert(tiVeryHighValueReclaimSegments, {iSegmentX, iSegmentZ})
    end

end

function UpdateReclaimDataNearSegments(iBaseSegmentX, iBaseSegmentZ, iSegmentRange)
    --Updates reclaim data for all segments within iSegmentRange of tLocation

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'UpdateReclaimDataNearSegments'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart) --Want the profile coutn to reflect the number of times actually running the core code



    local iMinValueOfIndividualReclaim = iLowestMassThreshold --Note that there is a separate min value used for refReclaimTotalSignificantMass (10 as of v43)
    local iMinEnergyValue = 10

    local iTotalMassValue, tReclaimables, iLargestCurReclaim, tReclaimPos, iTotalEnergyValue, iTotalMassAboveThreshold
    local iCumulativeMassValue = 0

    if bDebugMessages == true then
        LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; About to update for iBaseSegmentX='..(iBaseSegmentX or 'nil')..'; iSegmentRange='..(iSegmentRange or 'nil')..'; iBaseSegmentZ='..(iBaseSegmentZ or 'nil'))
    end

    local iPlateau, iLandZone
    local bWasVeryHighValue

    for iCurX = iBaseSegmentX - iSegmentRange, iBaseSegmentX + iSegmentRange do
        for iCurZ = iBaseSegmentZ - iSegmentRange, iBaseSegmentZ + iSegmentRange do
            iTotalMassValue = 0
            tReclaimables = GetReclaimablesInRect(GetReclaimSegmentRectangle(iCurX, iCurZ))
            iLargestCurReclaim = 0
            if bDebugMessages == true then LOG(sFunctionRef..': iCurX='..iCurX..'; iCurZ='..iCurZ..'; iReclaimSegmentSizeX='..iReclaimSegmentSizeX..'; iReclaimSegmentSizeZ='..iReclaimSegmentSizeZ..'; Reclaim search rect='..repru(GetReclaimSegmentRectangle(iCurX, iCurZ))..'; Is tReclaimables empty='..tostring(M28Utilities.IsTableEmpty(tReclaimables))) end

            if tReclaimables and table.getn( tReclaimables ) > 0 then
                -- local iWreckCount = 0
                --local bIsProp = nil  --only used for log/testing
                if bDebugMessages == true then LOG('Have wrecks within the segment iCurXZ='..iCurX..'-'..iCurZ..', tReclaimAreas[iCurX][iCurZ]='..(repru(tReclaimAreas[iCurX][iCurZ] or 'nil'))) end
                iTotalMassValue, tReclaimPos, iLargestCurReclaim, iTotalEnergyValue, iTotalMassAboveThreshold = GetReclaimablesMassAndEnergy(tReclaimables, iMinValueOfIndividualReclaim, iMinEnergyValue, bDebugMessages)
                --Record this table:
                if tReclaimAreas[iCurX] == nil then
                    tReclaimAreas[iCurX] = {}
                    if bDebugMessages == true then LOG('Setting table to nothing as is currently nil; iCurX='..iCurX) end
                end
                if tReclaimAreas[iCurX][iCurZ] == nil then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will create new reclaim segment as this is the first time we are checking values for this segment') end
                    CreateReclaimSegment(iCurX, iCurZ)
                    bWasVeryHighValue = false
                else
                    if (tReclaimAreas[iCurX][iCurZ][refReclaimTotalSignificantMass] or 0) >= iVeryHighReclaimThreshold then
                        bWasVeryHighValue = true
                    else
                        bWasVeryHighValue = false
                    end
                end

                --tReclaimAreas[iCurX][iCurZ][refiReclaimTotalPrev] = (tReclaimAreas[iCurX][iCurZ][refReclaimTotalMass] or 0)
                tReclaimAreas[iCurX][iCurZ][refReclaimTotalMass] = iTotalMassValue
                tReclaimAreas[iCurX][iCurZ][refReclaimHighestIndividualMassReclaim] = iLargestCurReclaim
                tReclaimAreas[iCurX][iCurZ][refReclaimTotalSignificantMass] = iTotalMassAboveThreshold
                --tReclaimAreas[iCurX][iCurZ][refReclaimHighestIndividualMassReclaim] = iLargestCurReclaim
                --iHighestReclaimInASegment = math.max(iHighestReclaimInASegment, iTotalMassValue)
                tReclaimAreas[iCurX][iCurZ][refSegmentReclaimTotalEnergy] = iTotalEnergyValue
                iPlateau, iLandZone = GetPlateauAndLandZoneReferenceFromPosition(tReclaimAreas[iCurX][iCurZ][refReclaimSegmentMidpoint])

                if bDebugMessages == true then
                    LOG(sFunctionRef..': Reclaim segment midpoint='..repru(tReclaimAreas[iCurX][iCurZ][refReclaimSegmentMidpoint])..'; Segment X'..iCurX..'Z'..iCurZ..' with iTotalMassValue='..iTotalMassValue..' and iTotalMassAboveThreshold='..iTotalMassAboveThreshold..' for plateau '..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; Drawing reclai mrectangle')
                    M28Utilities.DrawRectangle(GetReclaimSegmentRectangle(iCurX, iCurZ))
                end
                if iLandZone > 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Time of last refresh for land zone '..iLandZone..'='.. (tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLastReclaimRefresh] or 0)) end
                    if GetGameTimeSeconds() - (tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLastReclaimRefresh] or 0) >= 1 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will refresh the reclaim value for land zone '..iLandZone) end
                        RefreshLandOrWaterZoneReclaimValue(iPlateau, iLandZone)
                    else
                        AddZoneForDelayedRefresh(iPlateau, iLandZone)
                    end
                else
                    local iWaterZone = GetWaterZoneFromPosition(tReclaimAreas[iCurX][iCurZ][refReclaimSegmentMidpoint])
                    if (iWaterZone or 0) > 0 then
                        local iPond = tiPondByWaterZone[iWaterZone]
                        if bDebugMessages == true then LOG(sFunctionRef..': Time of last refresh for water zone '..iWaterZone..'='.. (tPondDetails[iPond][subrefPondWaterZones][iWaterZone][subrefLastReclaimRefresh] or 0)) end
                        if GetGameTimeSeconds() - (tPondDetails[iPond][subrefPondWaterZones][iWaterZone][subrefLastReclaimRefresh] or 0) >= 1 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will refresh the reclaim value for land zone '..iLandZone) end
                            RefreshLandOrWaterZoneReclaimValue(iPond, iWaterZone, true)
                        else
                            AddZoneForDelayedRefresh(0, iWaterZone)
                        end
                    end
                end
                if bWasVeryHighValue then
                    if tReclaimAreas[iCurX][iCurZ][refReclaimTotalSignificantMass] < iVeryHighReclaimThreshold then
                        RemoveFromVeryHighValueSegmentTable(iCurX, iCurZ)
                    end
                elseif tReclaimAreas[iCurX][iCurZ][refReclaimTotalSignificantMass] >= iVeryHighReclaimThreshold then
                    --wouldnt have been high value before but should be now
                    AddToVeryHighValueSegmentTable(iCurX, iCurZ)
                end
            else
                if tReclaimAreas[iCurX][iCurZ] == nil then
                    CreateReclaimSegment(iCurX, iCurZ)
                elseif tReclaimAreas[iCurX][iCurZ][refReclaimTotalSignificantMass] >= iVeryHighReclaimThreshold then
                    RemoveFromVeryHighValueSegmentTable(iCurX, iCurZ)
                end
                tReclaimAreas[iCurX][iCurZ][refReclaimTotalMass] = 0
                tReclaimAreas[iCurX][iCurZ][refReclaimHighestIndividualMassReclaim] = 0
                tReclaimAreas[iCurX][iCurZ][refReclaimTotalSignificantMass] = 0
                tReclaimAreas[iCurX][iCurZ][refSegmentReclaimTotalEnergy] = 0
            end
                iCumulativeMassValue = iCumulativeMassValue + iTotalMassValue
            end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iCumulativeMassValue='..iCumulativeMassValue..'; SystemTime='..GetSystemTimeSecondsOnlyForProfileUse()) end

    --M28Profiler.tiProfilerEndCountByFunction[sFunctionRef] = (M28Profiler.tiProfilerStartCountByFunction[sFunctionRef] or 0) + 1 LOG(sFunctionRef..': M28Profiler.tiProfilerEndCountByFunction[sFunctionRef]='..M28Profiler.tiProfilerEndCountByFunction[sFunctionRef])
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iCumulativeMassValue
end

function RecordThatWeWantToUpdateReclaimAtLocation(tLocation, iNearbySegmentsToUpdate)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RecordThatWeWantToUpdateReclaimAtLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if iReclaimSegmentSizeX == 0 then
        M28Utilities.ErrorHandler('Dont have a reclaim segment size specified, will set it to 8.5, but something else has likely gone wrong')
        iReclaimSegmentSizeX = 8.5
        iReclaimSegmentSizeZ = 8.5
    end
    local iReclaimSegmentX, iReclaimSegmentZ = GetReclaimSegmentsFromLocation(tLocation)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time='..GetGameTimeSeconds()..'; tLocation='..repru(tLocation)..'; iReclaimSegmentX-Z='..iReclaimSegmentX..'-'..iReclaimSegmentZ) end
    if iReclaimSegmentX >= 10000 or iNearbySegmentsToUpdate >= 10000 or iReclaimSegmentZ >= 10000 then M28Utilities.ErrorHandler('Likely infinite loop about to start. iReclaimSegmentX='..(iReclaimSegmentX or 'nil')..'; iNearbySegmentsToUpdate='..(iNearbySegmentsToUpdate or 'nil')..'; iReclaimSegmentSizeX='..(iReclaimSegmentSizeX or 'nil')..'; iReclaimSegmentSizeZ='..(iReclaimSegmentSizeX or 'nil')..'; rMapPotentialPlayableArea='..repru(rMapPotentialPlayableArea or {'nil'})..'; iMaxSegmentInterval='..(iMaxSegmentInterval or 'nil'))
    else

        if iNearbySegmentsToUpdate then
            for iSegmentX = iReclaimSegmentX - iNearbySegmentsToUpdate, iReclaimSegmentX + iNearbySegmentsToUpdate do
                for iSegmentZ = iReclaimSegmentZ - iNearbySegmentsToUpdate, iReclaimSegmentZ + iNearbySegmentsToUpdate do
                    if bDebugMessages == true then LOG(sFunctionRef..': Will record that we want to update the reclaim segment XZ='..iSegmentX..'-'..iSegmentZ) end
                    RecordThatWeWantToUpdateReclaimSegment(iSegmentX, iSegmentZ)
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Will record that we want to update the base reclaim segment XZ='..iReclaimSegmentX..'-'..iReclaimSegmentZ) end
            RecordThatWeWantToUpdateReclaimSegment(iReclaimSegmentX, iReclaimSegmentZ)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordThatWeWantToUpdateReclaimSegment(iReclaimSegmentX, iReclaimSegmentZ)
    if iReclaimSegmentX >= 0 and iReclaimSegmentZ >= 0 then table.insert(tReclaimSegmentsToUpdate, {iReclaimSegmentX, iReclaimSegmentZ}) end
end


function GetTravelDistanceBetweenLandZones(iPlateau, iStartLZ, iEndLZ)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetTravelDistanceBetweenLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local tStartLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLZ]


    if not(tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau][iEndLZ]) then
        if not(tStartLZData[subrefLZTravelDistToOtherLandZones]) then tStartLZData[subrefLZTravelDistToOtherLandZones] = {} end
        if not(tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau]) then tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau] = {} end
        if not(tStartLZData[subrefMidpoint]) then RecordMidpointAndOtherDataForZone(iPlateau, iStartLZ, tStartLZData) end --redundancy
        if bDebugMessages == true then LOG(sFunctionRef..': About to record travel distance for iPlateau '..(iPlateau or 'nil')..'; iStartLZ '..(iStartLZ or 'nil')..'; iEndLZ='..(iEndLZ or 'nil')..'; start midpoint='..repru(tStartLZData[subrefMidpoint])..'; End LZ midpoint='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iEndLZ][subrefMidpoint])) end
        tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau][iEndLZ] = M28Utilities.GetTravelDistanceBetweenPositions(tStartLZData[subrefMidpoint], tAllPlateaus[iPlateau][subrefPlateauLandZones][iEndLZ][subrefMidpoint], refPathingTypeLand)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Travel distance from iStartLZ='..iStartLZ..' to iEndLZ='..iEndLZ..' is '..(tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau][iEndLZ] or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau][iEndLZ]
end


function GetPositionAtOrNearTargetInPathingGroup(tStartPos, tTargetPos, iDistanceFromTargetToStart, iAngleAdjust, oPathingUnit, bMoveCloserBeforeFurtherIfBlocked, bCheckIfExistingTargetIsBetter, iMinDistanceFromExistingCommandTarget)
    --Intended as a rewriting of GetPositionNearTargetInSamePathingGroup due to some inconsistencies arising with the below, to make use of new logic that allows any angle; introduced from v15
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPositionAtOrNearTargetInPathingGroup'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Get angle from target to start
    local iAngleFromTargetToStart = M28Utilities.GetAngleFromAToB(tTargetPos, tStartPos) + (iAngleAdjust or 0)
    --Get initial desired position
    local tPossibleTarget = M28Utilities.MoveInDirection(tTargetPos, iAngleFromTargetToStart, iDistanceFromTargetToStart, true, false, false)
    local sPathing = M28UnitInfo.GetUnitPathingType(oPathingUnit)
    local iPathingGroupWanted = NavUtils.GetTerrainLabel(sPathing, tTargetPos)
    local iPathingGroupOfPossibleTarget = NavUtils.GetTerrainLabel(sPathing, tPossibleTarget)
    local bCanPathToTarget = false

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code; oPathingUnit='..oPathingUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPathingUnit)..'; tTargetPos='..repru(tTargetPos)..'; iAngleAdjust ='..iAngleAdjust..'; iDistanceFromTargetToStart='..iDistanceFromTargetToStart..'; tStartPos='..repru(tStartPos)..'; iPathingGroupOfPossibleTarget='..iPathingGroupOfPossibleTarget..'; iPathingGroupWanted='..iPathingGroupWanted..'; Angle from start to target='..M28Utilities.GetAngleFromAToB(tStartPos, tTargetPos)..'; iAngleFromTargetToStart='..iAngleFromTargetToStart..'; Amphibious group of target position='..NavUtils.GetTerrainLabel(refPathingTypeHover, tTargetPos)..'; Amphib group of our base='..NavUtils.GetTerrainLabel(refPathingTypeHover, PlayerStartPoints[oPathingUnit:GetAIBrain():GetArmyIndex()])..'; tPossibleTarget before adjust='..repru(tPossibleTarget)..'; Distance between possible target and tTargetPos='..M28Utilities.GetDistanceBetweenPositions(tPossibleTarget, tTargetPos)) end
    --Find a target we can path to
    if iPathingGroupOfPossibleTarget == iPathingGroupWanted then
        bCanPathToTarget = true
    else
        --Dif pathing group, need to try alternatives; first try the target itself
        if not(bMoveCloserBeforeFurtherIfBlocked == false) then
            tPossibleTarget = {tTargetPos[1], tTargetPos[2], tTargetPos[3]}
            iPathingGroupOfPossibleTarget = NavUtils.GetTerrainLabel(sPathing, tPossibleTarget)
            if bDebugMessages == true then LOG(sFunctionRef..': Pathing group if just try target position='..iPathingGroupOfPossibleTarget) end
            if iPathingGroupOfPossibleTarget == iPathingGroupWanted then
                bCanPathToTarget = true
            end
        end

        if bCanPathToTarget == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Cant path to the initial expected point so will try nearby points') end
            local tDistanceFactors
            if bMoveCloserBeforeFurtherIfBlocked then
                tDistanceFactors = {0.5, 1.5, 3}
            else tDistanceFactors = {1.25, 3}
            end
            local tAngleVariations = {-45, 0, 45}
            --Make sure we have at least some distance we're moving away from
            if iDistanceFromTargetToStart == 0 then iDistanceFromTargetToStart = 1 end

            if math.abs(iDistanceFromTargetToStart) < 4 then
                local iFactorIncrease = 4 / iDistanceFromTargetToStart
                for iDistanceFactor = 1, table.getn(tDistanceFactors) do
                    tDistanceFactors[iDistanceFactor] = tDistanceFactors[iDistanceFactor] * iFactorIncrease
                end
            end
            for iDistanceFactor = 1, table.getn(tDistanceFactors) do
                for iAngleAlternative = 1, table.getn(tAngleVariations) do
                    tPossibleTarget = M28Utilities.MoveInDirection(tTargetPos, iAngleFromTargetToStart + tAngleVariations[iAngleAlternative], iDistanceFromTargetToStart * tDistanceFactors[iDistanceFactor], true, false, false)
                    if NavUtils.GetTerrainLabel(sPathing, tPossibleTarget) == iPathingGroupWanted then
                        bCanPathToTarget = true
                        break
                    end
                end
                if bCanPathToTarget then break end
                if bDebugMessages == true then LOG(sFunctionRef..': iDistanceFactor='..iDistanceFactor..'; tPossibleTarget based on the last of the angle variations='..repru(tPossibleTarget)..'; still cant path to the target so will keep looking') end
            end
        end

    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if can path to target, bCanPathToTarget='..tostring(bCanPathToTarget)..'; tPossibleTarget='..repru(tPossibleTarget)) end

    if bCanPathToTarget then
        --Consider if the target meets any other values specified (e.g. if must be certain distance away from current target or unit)
        if bCheckIfExistingTargetIsBetter == true or iMinDistanceFromExistingCommandTarget then
            if bDebugMessages == true then LOG(sFunctionRef..': Checking against existing target to see if thats better') end
            if oPathingUnit.GetNavigator then
                local oNavigator = oPathingUnit:GetNavigator()
                if oNavigator.GetCurrentTargetPos then
                    local tExistingTargetPos = oNavigator:GetCurrentTargetPos()
                    if M28Utilities.IsTableEmpty(tExistingTargetPos) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': tExistingTargetPos='..repru(tExistingTargetPos)..'; Distance to possible target='..M28Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tPossibleTarget)..'; iMinDistanceFromExistingCommandTarget='..(iMinDistanceFromExistingCommandTarget or 'nil')..'; Pathing group of this='..NavUtils.GetTerrainLabel(sPathing, tExistingTargetPos)..'; Pathing group wanted='..iPathingGroupWanted..'; sPathing='..sPathing..'; Distance of existing position toa ctual target='..M28Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tTargetPos)) end
                        if NavUtils.GetTerrainLabel(sPathing, tExistingTargetPos) == iPathingGroupWanted then

                            --Do we have a minimum distance away from current target required?
                            if iMinDistanceFromExistingCommandTarget and M28Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tPossibleTarget) < iMinDistanceFromExistingCommandTarget then
                                if bDebugMessages == true then LOG(sFunctionRef..': Distance between existing target position and possible target position is less than the min distance; tExistingTargetPos='..repru(tExistingTargetPos)..'; tPossibleTarget='..repru(tPossibleTarget)) end
                                tPossibleTarget = tExistingTargetPos
                            else
                                --Is the existing target position closer to the distance required than the new position, factoring in if we want a negative position or not?
                                local iDistanceFromQueuedMoveLocationToTarget = M28Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tTargetPos)
                                local iDistanceFromPossibleTargetToTarget = M28Utilities.GetDistanceBetweenPositions(tPossibleTarget, tTargetPos)
                                --Are these further away from the start position than the actual target?
                                if math.abs(iDistanceFromQueuedMoveLocationToTarget - iDistanceFromTargetToStart) < math.abs(iDistanceFromPossibleTargetToTarget - iDistanceFromTargetToStart) then
                                    --Have we said we want to move closer if the initial point is blocked?
                                    if not(bMoveCloserBeforeFurtherIfBlocked) or iDistanceFromQueuedMoveLocationToTarget <= iDistanceFromTargetToStart then
                                        --Factor in we might be infront of the target and actually want to be behind
                                        local iDistanceFromStartToTarget = M28Utilities.GetDistanceBetweenPositions(tStartPos, tTargetPos)
                                        local iDistanceFromQueuedToStart = M28Utilities.GetDistanceBetweenPositions(tStartPos, tExistingTargetPos)
                                        if bDebugMessages == true then LOG(sFunctionRef..': iDistanceFromQueuedMoveLocationToTarget='..iDistanceFromQueuedMoveLocationToTarget..'; iDistanceFromPossibleTargetToTarget='..iDistanceFromPossibleTargetToTarget..'; iDistanceFromQueuedToStart='..iDistanceFromQueuedToStart..'; iDistanceFromStartToTarget='..iDistanceFromStartToTarget..'; iDistanceFromTargetToStart='..iDistanceFromTargetToStart) end
                                        if iDistanceFromQueuedToStart > 1 and ((iDistanceFromQueuedToStart < iDistanceFromStartToTarget and iDistanceFromTargetToStart > 0) or (iDistanceFromQueuedToStart > iDistanceFromStartToTarget and iDistanceFromTargetToStart < 0)) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Existing location is closer than the new possible location so go with this') end
                                            --Existing location is closer than the new location so go with this
                                            tPossibleTarget = tExistingTargetPos
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    else
        --This could be due to a pathfinding error, will just use the potential target
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code; tPossibleTarget='..repru(tPossibleTarget or {'nil'})..'; bCanPathToTarget='..tostring(bCanPathToTarget)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tPossibleTarget
end

function InPlayableArea(tLocation) --NOTE - also have the same function in M28Conditions
    if tLocation[1] >= rMapPlayableArea[1] and tLocation[1] <= rMapPlayableArea[3] and tLocation[3] >= rMapPlayableArea[2] and tLocation[3] <= rMapPlayableArea[4] then
        return true
    else
        return false
    end
end

function GetLandOrWaterZoneData(tLocation, bReturnTeamDataAsWell, iOptionalTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetLandOrWaterZoneData'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iPlateauOrZero, iLandOrWaterZone = GetClosestPlateauOrZeroAndZoneToPosition(tLocation)
    if (iLandOrWaterZone or 0) > 0 then
        if iPlateauOrZero == 0 then
            --Water zone
            if bReturnTeamDataAsWell then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return tPondDetails[tiPondByWaterZone[iLandOrWaterZone]][subrefPondWaterZones][iLandOrWaterZone], tPondDetails[tiPondByWaterZone[iLandOrWaterZone]][subrefPondWaterZones][iLandOrWaterZone][subrefWZTeamData][iOptionalTeam]
            else
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return tPondDetails[tiPondByWaterZone[iLandOrWaterZone]][subrefPondWaterZones][iLandOrWaterZone]
            end
        else
            if bReturnTeamDataAsWell then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return tAllPlateaus[iPlateauOrZero][subrefPlateauLandZones][iLandOrWaterZone], tAllPlateaus[iPlateauOrZero][subrefPlateauLandZones][iLandOrWaterZone][subrefLZTeamData][iOptionalTeam]
            else
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return tAllPlateaus[iPlateauOrZero][subrefPlateauLandZones][iLandOrWaterZone]
            end
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Unsable to find a valid zone for position '..repru(tLocation)..'; will draw in red')
            M28Utilities.DrawLocation(tLocation, 2)
        end
    end
end

function RecordBrainStartPoint(oBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordBrainStartPoint'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iStartPositionX, iStartPositionZ = oBrain:GetArmyStartPos() --(Nb: For most references use M28Map.GetPlayerStartPosition(aiBrain, true) to get this instead)
    local tStartPoint = {iStartPositionX, GetSurfaceHeight(iStartPositionX, iStartPositionZ), iStartPositionZ}

    if bDebugMessages == true then LOG(sFunctionRef..': Considering start position recorded for brain '..(oBrain.Nickname or 'nil')..' at time='..GetGameTimeSeconds()..'; will wait if havent setup land zones etc yet') end
    --Adjust start point if it isn't on a valid plateau (e.g. means we should work on some coop maps)
    if not(NavUtils.IsGenerated()) then
        if bDebugMessages == true then LOG('Considering whether to generate map markers for oBrain='..oBrain.Nickname..'; GameTime='..GetGameTimeSeconds()) end
        while (not(M28Overseer.bBeginSessionTriggered) and GetGameTimeSeconds() < 4) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        M28Profiler.FunctionProfiler('NavUtilsGenerate', M28Profiler.refProfilerStart)
        NavUtils.Generate()
        M28Profiler.FunctionProfiler('NavUtilsGenerate', M28Profiler.refProfilerEnd)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        SetupPlayableAreaAndSegmentSizes()
    end
    if not(bPlayableAreaSetup) then
        SetupPlayableAreaAndSegmentSizes()
    end
    --NOTE: Cant wait for land and water zone setup to finish, as they require the brain start points

    if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting until land zones and playable area are setup, bMapLandSetupComplete='..tostring(bMapLandSetupComplete)..'; bWaterZoneInitialCreation='..tostring(bWaterZoneInitialCreation)..'; Checking if start point is in a valid plateau and zone for brain '..oBrain.Nickname..'; tStartPoint='..repru(tStartPoint)..'; time='..GetGameTimeSeconds()) end
    local iLocationSegmentX, iLocationSegmentZ, tLocationSegmentMidpoint
    function IsLocationSuitable(tLocation)
        if (NavUtils.GetTerrainLabel(refPathingTypeHover, tLocation) or -1) > 0 then
            iLocationSegmentX, iLocationSegmentZ = GetPathingSegmentFromPosition(tLocation)
            if bDebugMessages == true then LOG(sFunctionRef..': iLocationSegmentX='..iLocationSegmentX..'; iLocationSegmentZ='..iLocationSegmentZ..'; Land label='..(NavUtils.GetTerrainLabel(refPathingTypeLand, tLocation) or 0)..'; Water label='..((NavUtils.GetTerrainLabel(refPathingTypeNavy, tLocation) or 0))) end
            if (NavUtils.GetTerrainLabel(refPathingTypeLand, tLocation) or 0) > 0 or (NavUtils.GetTerrainLabel(refPathingTypeNavy, tLocation) or 0) > 0 then
                return true
            end
        end
        return false
    end

    if not(IsLocationSuitable(tStartPoint)) then
        local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tStartPoint)
        local bHaveValidStartPoint = false
        local tAltStartPoint
        for iAdjustBase = 1, math.min(iMapSize, 250) do
            for iCurSegmentX = iSegmentX - iAdjustBase, iSegmentX + iAdjustBase, 1 do
                for iCurSegmentZ = iSegmentZ - iAdjustBase, iSegmentZ + iAdjustBase, iAdjustBase * 2 do
                    if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                        tAltStartPoint = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering tAltStartPoint='..repru(tAltStartPoint)..'; rMapPotentialPlayableArea='..repru(rMapPotentialPlayableArea)..'; Hover label='..(NavUtils.GetTerrainLabel(refPathingTypeHover, tAltStartPoint) or 'nil')) end
                        if tAltStartPoint[1] <= rMapPotentialPlayableArea[3] and tAltStartPoint[3] <= rMapPotentialPlayableArea[4] then
                            if IsLocationSuitable(tAltStartPoint) then
                                bHaveValidStartPoint = true
                                break
                            end
                        end
                    end
                end
                if bHaveValidStartPoint then break end
            end
            if bHaveValidStartPoint then break end
            --Then do the left and right row (excl corners which ahve already done per the above)
            for iCurSegmentX = iSegmentX - iAdjustBase, iSegmentX + iAdjustBase, iAdjustBase * 2 do
                for iCurSegmentZ = iSegmentZ - iAdjustBase + 1, iSegmentZ + iAdjustBase - 1, 1 do
                    if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                        tAltStartPoint = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                        if tAltStartPoint[1] <= rMapPotentialPlayableArea[3] and tAltStartPoint[3] <= rMapPotentialPlayableArea[4] then
                            if IsLocationSuitable(tAltStartPoint) then
                                bHaveValidStartPoint = true
                                break
                            end
                        end
                    end
                end
                if bHaveValidStartPoint then break end
            end
            if bHaveValidStartPoint then break end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': After checking for alternatives, bHaveValidStartPoint='..tostring(bHaveValidStartPoint)..'; brain='..oBrain.Nickname..'; tAltStartPoint='..repru(tAltStartPoint)..'; rMapPotentialPlayableArea='..repru(rMapPotentialPlayableArea)) end
        if not(bIsCampaignMap) and not(M28Conditions.IsCivilianBrain(oBrain)) then M28Utilities.ErrorHandler('Non-civilian brain '..(oBrain.Nickname or 'nil')..' with index '..oBrain:GetArmyIndex()..' has a start position that doesnt have a plateau reference and this isnt a campaign map') end

        if not(bHaveValidStartPoint) then M28Utilities.ErrorHandler('Have been through 250 adjacent segments and not found a valid start point for brain '..(oBrain.Nickname or 'nil')..' with start position '..repru(tStartPoint))
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Changing start point for brain '..(oBrain.Nickname or 'nil')..' to be '..repru(tAltStartPoint)..' from tStartPoint of '..repru(tStartPoint)) end
            tStartPoint = {tAltStartPoint[1], GetSurfaceHeight(tAltStartPoint[1], tAltStartPoint[3]), tAltStartPoint[3]}
        end
    end

    PlayerStartPoints[oBrain:GetArmyIndex()] = {tStartPoint[1], tStartPoint[2], tStartPoint[3]}
    M28Overseer.tAllAIBrainsByArmyIndex[oBrain:GetArmyIndex()] = oBrain

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetNearestWaterToBuildNavalFactoryInPlayableArea(aiBrain, tStartPosition, iDistInterval, iOptionalPond, iOptionalAngleAdjust, bCheckInPlayableArea)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNearestWaterToBuildNavalFactoryInPlayableArea'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iAngleToCentre = (iOptionalAngleAdjust or 0)
    local iMaxSearch = math.max(rMapPlayableArea[3] - rMapPlayableArea[1], rMapPlayableArea[4] - rMapPlayableArea[2])
    iMaxSearch = math.floor(iMaxSearch / iDistInterval) * iDistInterval
    local tPossibleLocationBase, tPossibleBuildLocation, tNavalBuildArea
    local iBuildingInterval = 4
    local iTerrainLabel
    local bHaveValidLocation = false
    local bDontCheckInPlayableArea = not(bCheckInPlayableArea)
    for iDistToTravel = iDistInterval, iMaxSearch, iDistInterval do
        for iAngleAdjust = 0, 170, 10 do
            for iAngleFactor = -1, 1, 2 do
                tPossibleLocationBase = M28Utilities.MoveInDirection(tStartPosition, iAngleToCentre + iAngleAdjust * iAngleFactor, iDistToTravel, true, true, false)
                iTerrainLabel = NavUtils.GetTerrainLabel(refPathingTypeNavy, tPossibleLocationBase)

                if iTerrainLabel and ((iOptionalPond and  iOptionalPond == iTerrainLabel) or not(iOptionalPond)) and (bDontCheckInPlayableArea or InPlayableArea(tPossibleLocationBase)) then
                    --Try and find somewhere around here to build a naval factory
                    for iBuildingAdjustX = 0, iBuildingInterval, 1 do
                        for iBuildingAdjustZ = 0, iBuildingInterval, 1 do
                            for iXFactor = -1, 1, 2 do
                                for iZFactor = -1, 1, 2 do
                                    tPossibleBuildLocation = {tPossibleLocationBase[1] + iBuildingAdjustX * iXFactor, 0, tPossibleLocationBase[3] + iBuildingAdjustZ * iZFactor}
                                    tPossibleBuildLocation[2] = GetSurfaceHeight(tPossibleBuildLocation[1], tPossibleBuildLocation[3])
                                    if bCheckInPlayableArea and not(InPlayableArea(tPossibleBuildLocation)) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Possible build location isnt in playable area so abortin for this ZFactor') end
                                        break
                                    end
                                    if aiBrain:CanBuildStructureAt('ueb0103', tPossibleBuildLocation) then
                                        bHaveValidLocation = true
                                        tNavalBuildArea = {tPossibleBuildLocation[1], tPossibleBuildLocation[2], tPossibleBuildLocation[3]}
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef..': Have valid location='..repru(tPossibleBuildLocation)..'; will draw in white')
                                            M28Utilities.DrawLocation(tPossibleBuildLocation, 1, 100, 2)
                                        end
                                        break
                                    else
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef..': Have invalid location='..repru(tPossibleBuildLocation)..'; will draw in red')
                                            M28Utilities.DrawLocation(tPossibleBuildLocation, 2, 100, 2)
                                        end
                                    end
                                end
                                if bHaveValidLocation then break end
                            end
                            if bHaveValidLocation then break end

                        end
                        if bHaveValidLocation then break end
                    end
                    if iAngleAdjust == 0 or bHaveValidLocation then break end
                elseif bDebugMessages == true then
                    LOG(sFunctionRef..': Failed tPossibleLocationBase pathing group, tPossibleLocationBase='..repru(tPossibleLocationBase)..'; naval label='..(NavUtils.GetTerrainLabel(refPathingTypeNavy, tPossibleLocationBase) or 'nil')..'; iOptionalPond='..(iOptionalPond or 'nil')..'; will draw in gold')
                    M28Utilities.DrawLocation(tPossibleLocationBase, 4, 100, 2)
                end
                if bHaveValidLocation then break end
            end
            if bHaveValidLocation then break end
        end
        if bHaveValidLocation then break end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tNavalBuildArea='..repru(tNavalBuildArea)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tNavalBuildArea
end

function ConsiderUnitAddingPositionToWaterZone(oUnit)
    --Checks if unit appears to be on water and if so adds this segment to the nearest water zone

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderUnitAddingPositionToWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Is this a naval unit that is on water?
    if EntityCategoryContains(M28UnitInfo.refCategoryAllNavy, oUnit.UnitId) then
        local tUnitPosition = oUnit:GetPosition()
        if GetTerrainHeight(tUnitPosition[1], tUnitPosition[3]) < GetSurfaceHeight(tUnitPosition[1], tUnitPosition[3]) then
            --Find the nearest water zone to this position
            local iWaterZone
            local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tUnitPosition)
            if not(tWaterZoneBySegment[iSegmentX][iSegmentZ]) then
                for iAdjustBase = 1, 10 do
                    for iCurSegmentX = iSegmentX - iAdjustBase, iSegmentX + iAdjustBase, 1 do
                        for iCurSegmentZ = iSegmentZ - iAdjustBase, iSegmentZ + iAdjustBase, iAdjustBase * 2 do
                            if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                                if tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] then iWaterZone = tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] break end
                            end
                        end
                        if iWaterZone then break end
                    end
                    if iWaterZone then break end
                    --Then do the left and right row (excl corners which ahve already done per the above)
                    for iCurSegmentX = iSegmentX - iAdjustBase, iSegmentX + iAdjustBase, iAdjustBase * 2 do
                        for iCurSegmentZ = iSegmentZ - iAdjustBase + 1, iSegmentZ + iAdjustBase - 1, 1 do
                            if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                                if tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] then iWaterZone = tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] break end
                            end
                        end
                        if iWaterZone then break end
                    end
                    if iWaterZone then break end
                end

                if iWaterZone then
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording location '..repru(oUnit:GetPosition())..' as being a water zone based on nearby iWaterZone='..iWaterZone) end
                    AddSegmentToWaterZone(tiPondByWaterZone[iWaterZone], iWaterZone, iSegmentX, iSegmentZ)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DrawLandZonePath(iPlateau, iStartLandZone, iEndLandZone)
    local tLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone]
    local iTargetLZRef = tLZData[subrefLZPathingToOtherLZEntryRef][iEndLandZone]
    local tPathToOtherLZ = tLZData[subrefLZPathingToOtherLandZones][iTargetLZRef][subrefLZPath]
    local iPrevLZRef = iStartLandZone
    for iEntry, iLZ in tPathToOtherLZ do
        local tPrevLZData =      tAllPlateaus[iPlateau][subrefPlateauLandZones][iPrevLZRef]
        local tAltLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLZ]
        ForkThread(M28Utilities.ForkedDrawLine, tPrevLZData[subrefMidpoint], tAltLZData[subrefMidpoint], 2, 100)
        iPrevLZRef = iLZ
    end
end

function RefreshCampaignStartPositionsAfterDelay(iDelayInSeconds)
    --Intended to be called after the map is resized
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshCampaignStartPositionsAfterDelay'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    WaitSeconds(iDelayInSeconds)
    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to update positions, bIsCampaignMap='..tostring(bIsCampaignMap)..'; CampAI setting='..(ScenarioInfo.Options.CampAI or 'nil')..'; Time='..GetGameTimeSeconds()) end
    if bIsCampaignMap and not(ScenarioInfo.Options.CampAI == 1) then --We are applying M28 to either an ally or enemy
        local tbTeamsToUpdate = {}
        for iBrain, oBrain in ArmyBrains do
            if oBrain.CampaignAI and oBrain.M28AI then
                tbTeamsToUpdate[oBrain.M28Team] = true
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Teams to update='..repru(tbTeamsToUpdate)) end
        if M28Utilities.IsTableEmpty(tbTeamsToUpdate) == false then
            function DoesZoneContainHQ(tLZData, iTeam)
                local tCurZoneTeamData = tLZData[subrefLZTeamData][iTeam]
                if M28Utilities.IsTableEmpty(tCurZoneTeamData[subreftoLZOrWZAlliedUnits]) == false then
                    local tFriendlyFactoryHQs = EntityCategoryFilterDown(M28UnitInfo.refCategoryAllHQFactories, tCurZoneTeamData[subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tFriendlyFactoryHQs) == false then
                        return true
                    end
                end
                return false
            end
            for iTeam, bUpdate in tbTeamsToUpdate do
                for iBrain, oBrain in ArmyBrains do
                    if oBrain.M28Team == iTeam and oBrain.M28AI and oBrain.CampaignAI then
                        --Have a campaign AI on this team and map has just expanded, so consider if we should change the start position of this AI
                        local tCurStartPosition = GetPlayerStartPosition(oBrain)
                        local iStartPlateauOrZero, iStartLandZone = GetClosestPlateauOrZeroAndZoneToPosition(tCurStartPosition)
                        local tCurStartLZData, tCurStartLZTeamData = GetLandOrWaterZoneData(tCurStartPosition, true, iTeam)
                        local bStartNoLongerAppropriate = false
                        if (tCurStartLZTeamData[subrefLZSValue] or 0) <= 5000 then
                            bStartNoLongerAppropriate = not(DoesZoneContainHQ(tCurStartLZData, iTeam))
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Checking if brain '..oBrain.Nickname..' still has an appropriate start point, bStartNoLongerAppropriate='..tostring(bStartNoLongerAppropriate)..'; LZ S value='..(tCurStartLZTeamData[subrefLZSValue] or 'nil')..'; Does it contain an HQ='..tostring(DoesZoneContainHQ(tCurStartLZData, iTeam))) end
                        if bStartNoLongerAppropriate then
                            --Cycle through every plateau and land zone looking for a core base, and see if the core base has factory HQs in it
                            local tbPlateauAndZoneShortlist = {}
                            for iPlateau, tPlateauSubtable in tAllPlateaus do
                                if M28Utilities.IsTableEmpty(tAllPlateaus[iPlateau][subrefPlateauLandZones]) == false then
                                    for iLandZone, tLZData in tAllPlateaus[iPlateau][subrefPlateauLandZones] do
                                        if tLZData[subrefLZTeamData][iTeam][subrefLZbCoreBase] then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Found a core base, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iStartPlateauOrZero='..iStartPlateauOrZero..'; iStartLandZone='..iStartLandZone..'; Does zone contain HQ='..tostring(DoesZoneContainHQ(tLZData, iTeam))) end
                                            --Check it contains HQ (otherwise we might be considering the existing one/similar)
                                            if not (iPlateau == iStartPlateauOrZero and iLandZone == iStartLandZone) and DoesZoneContainHQ(tLZData, iTeam) then
                                                if not(tbPlateauAndZoneShortlist[iPlateau]) then tbPlateauAndZoneShortlist[iPlateau] = {} end
                                                tbPlateauAndZoneShortlist[iPlateau][iLandZone] = true
                                            end
                                        end
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': is plateau and zone shortlist empty='..tostring(M28Utilities.IsTableEmpty(tbPlateauAndZoneShortlist))) end
                            if M28Utilities.IsTableEmpty(tbPlateauAndZoneShortlist) == false then
                                --Get the closest zone on the same plateau, or failing that the closest zone on any plateau
                                local iClosestDistSamePlateau = 100000
                                local tiClosestPlateauAndZoneSamePlateau = {}
                                local iClosestDistAnyPlateau = 100000
                                local tiClosestplateauAndZoneAnyPlateau = {}
                                local iCurDist
                                for iPlateau, tZones in tbPlateauAndZoneShortlist do
                                    for iZone, bInclude in tZones do
                                        local tLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone]
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[subrefMidpoint], tCurStartLZData[subrefMidpoint])
                                        if iCurDist < iClosestDistAnyPlateau then
                                            iClosestDistAnyPlateau = iCurDist
                                            tiClosestplateauAndZoneAnyPlateau = {iPlateau, iZone}
                                        end
                                        if iCurDist < iClosestDistSamePlateau and iPlateau == iStartPlateauOrZero then
                                            iClosestDistSamePlateau = iCurDist
                                            tiClosestPlateauAndZoneSamePlateau = {iPlateau, iZone}
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering changing the start position for campaign oBrain='..oBrain.Nickname..'; iClosestDistSamePlateau='..iClosestDistSamePlateau..'; iClosestDistAnyPlateau='..iClosestDistAnyPlateau) end
                                local bChangedStart = false
                                if M28Utilities.IsTableEmpty(tiClosestPlateauAndZoneSamePlateau) == false then
                                    --Set new start position to this zone midpoint
                                    local tLZData = tAllPlateaus[tiClosestPlateauAndZoneSamePlateau[1]][subrefPlateauLandZones][tiClosestPlateauAndZoneSamePlateau[2]]
                                    PlayerStartPoints[oBrain:GetArmyIndex()] = {tLZData[subrefMidpoint][1], tLZData[subrefMidpoint][2], tLZData[subrefMidpoint][3]}
                                    bChangedStart = true
                                elseif M28Utilities.IsTableEmpty(tiClosestplateauAndZoneAnyPlateau) == false then
                                    local tLZData = tAllPlateaus[tiClosestplateauAndZoneAnyPlateau[1]][subrefPlateauLandZones][tiClosestplateauAndZoneAnyPlateau[2]]
                                    PlayerStartPoints[oBrain:GetArmyIndex()] = {tLZData[subrefMidpoint][1], tLZData[subrefMidpoint][2], tLZData[subrefMidpoint][3]}
                                    bChangedStart = true
                                end
                                if bChangedStart then
                                    --Clear core zone flag from old zone
                                    tCurStartLZTeamData[subrefLZbCoreBase] = nil
                                    tCurStartLZTeamData[subrefbCoreBaseOverride] = nil
                                    if (iStartPlateauOrZero or 0) > 0 and iStartLandZone then
                                        if not(M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iStartPlateauOrZero]) then
                                            if not(M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau]) then M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau] = {} end
                                            M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iStartPlateauOrZero] = {}
                                        end
                                        M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iStartPlateauOrZero][iStartLandZone] = nil
                                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iStartPlateauOrZero]) then M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iStartPlateauOrZero] = nil end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetPlayerStartPosition(aiBrain, bJustReturnXAndZ)
    local tStartPosition = {}
    local X, Z
    local iIndex = aiBrain:GetArmyIndex()
    if PlayerStartPoints[iIndex] then
        if bJustReturnXAndZ then
            X = PlayerStartPoints[iIndex][1]
            Z = PlayerStartPoints[iIndex][3]
        else
            tStartPosition = {PlayerStartPoints[iIndex][1], PlayerStartPoints[iIndex][2], PlayerStartPoints[iIndex][3]}
        end
    else
        X, Z = aiBrain:GetArmyStartPos() --(foro ther refs use this function instead of getarmystartpos, i.e. M28Map.GetPlayerStartPosition(aiBrain, true))
        if not(bJustReturnXAndZ) then tStartPosition = {X, GetSurfaceHeight(X, Z), Z} end
        --if aiBrain:GetArmyIndex() == 2 then LOG('Running for brain '..aiBrain.Nickname..'; bMapLandSetupComplete='..tostring(bMapLandSetupComplete)..'; TIme='..GetGameTimeSeconds()) end
        if bMapLandSetupComplete and GetGameTimeSeconds() >= 4 then
            --Adjust the start position if it isn't in a valid zone
            --The below is all a redundancy as would expect RecordBrainStartPoint to handle this, so below is unlikely to trigger
            local tStartPositionToUse = { X, GetSurfaceHeight(X, Z), Z}
            local iStartPlateau, iStartZone = GetClosestPlateauOrZeroAndZoneToPosition(tStartPositionToUse)
            local iRevisedZone
            local iRevisedSegmentX, iRevisedSegmentZ
            if not(iStartPlateau) or not(iStartZone) then
                local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tStartPositionToUse)
                for iAdjustBase = 1, math.min(250, iMapSize) do
                    for iCurSegmentX = iSegmentX - iAdjustBase, iSegmentX + iAdjustBase, 1 do
                        for iCurSegmentZ = iSegmentZ - iAdjustBase, iSegmentZ + iAdjustBase, iAdjustBase * 2 do
                            if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                                if tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] or tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] then
                                    iRevisedZone = (tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] or tLandZoneBySegment[iCurSegmentX][iCurSegmentZ])
                                    iRevisedSegmentX = iCurSegmentX
                                    iRevisedSegmentZ = iCurSegmentZ
                                    break
                                end
                            end
                        end
                        if iRevisedZone then break end
                    end
                    if iRevisedZone then break end
                    --Then do the left and right row (excl corners which ahve already done per the above)
                    for iCurSegmentX = iSegmentX - iAdjustBase, iSegmentX + iAdjustBase, iAdjustBase * 2 do
                        for iCurSegmentZ = iSegmentZ - iAdjustBase + 1, iSegmentZ + iAdjustBase - 1, 1 do
                            if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                                if tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] or tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] then
                                    iRevisedZone = (tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] or tLandZoneBySegment[iCurSegmentX][iCurSegmentZ])
                                    iRevisedSegmentX = iCurSegmentX
                                    iRevisedSegmentZ = iCurSegmentZ
                                    break
                                end
                            end
                        end
                        if iRevisedZone then break end
                    end
                    if iRevisedZone then break end
                end
            end
            if iRevisedZone then
                local tPositionFromSegments = GetPositionFromPathingSegments(iRevisedSegmentX, iRevisedSegmentZ)
                tStartPositionToUse = {tPositionFromSegments[1], GetSurfaceHeight(tPositionFromSegments[1], tPositionFromSegments[3]), tPositionFromSegments[3]}
                if not(bIsCampaignMap) then M28Utilities.ErrorHandler('Adjusted the start position for player '..(aiBrain.Nickname or 'nil')..' to be '..repru(tStartPositionToUse)..'; previously it was X='..X..'Z='..Z..'; Normally would only have expected this to be required for a campaign map', true) end
            else
                M28Utilities.ErrorHandler('Unable to find a valid segment near player start point that has a zone, brain='..(aiBrain.Nickname or 'nil'))
            end

            PlayerStartPoints[iIndex] = {tStartPositionToUse[1], tStartPositionToUse[2], tStartPositionToUse[3]}
        end
    end
    --LOG('GetPlayerStartposition: aiBrain='..aiBrain.Nickname..'; X='..(X or 'nil')..'; Z='..(Z or 'nil')..'; bJustReturnXAndZ='..tostring(bJustReturnXAndZ or false)..'; Army start pos='..repru(aiBrain:GetArmyStartPos()))
    if bJustReturnXAndZ then return X, Z
    else return tStartPosition
    end
end

function GetLandZoneFromPosition(tPosition)
    --Intended for testing, since normally would want to get the plateau
    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tPosition)
    return tLandZoneBySegment[iSegmentX][iSegmentZ]
end

function AddGameEnderTemplateInfoToTable(tMidpoint, iPreferredSize)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddGameEnderTemplateInfoToTable'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iPreferredSegX, iPreferredSegZ = GetPathingSegmentFromPosition(tMidpoint)
    local tBaseTable = {[subrefiSize]=iPreferredSize, [subrefiSegX] = iPreferredSegX, [subrefiSegZ] = iPreferredSegZ, [subrefiSmallArtiLocationCount]=1,[subrefiSmallArtiMaxSize]=10,[subrefiSmallShieldLocationCount]=1,[subreftSmallArtiLocations]=0,[subreftSmallShieldLocations]=0,[subrefiLargeArtiLocationCount]=1,[subrefiLargeArtiMaxSize]=10,[subrefiLargeShieldLocationCount]=1,[subreftLargeArtiLocations]=0,[subreftLargeShieldLocations]=0}

    --tLZData[subrefGameEnderTemplateBackupLocationSizeAndSegment] = {[subrefiSize]=iPreferredSize, [subrefiSegX] = iPreferredSegX, [subrefiSegZ] = iPreferredSegZ, [subrefiSmallArtiLocationCount]=1,[subrefiSmallArtiMaxSize]=10,[subrefiSmallShieldLocationCount]=1,[subreftSmallArtiLocations]=0,[subreftSmallShieldLocations]=0,[subrefiLargeArtiLocationCount]=1,[subrefiLargeArtiMaxSize]=10,[subrefiLargeShieldLocationCount]=1,[subreftLargeArtiLocations]=0,[subreftLargeShieldLocations]=0}

    if bDebugMessages == true then LOG(sFunctionRef..': Adding game ender template info to table for midpoint='..repru(tMidpoint)..'; iPreferredSize='..iPreferredSize..'; Can we build a preferred size unit here='..tostring(M28Overseer.tAllActiveM28Brains[1]:CanBuildStructureAt(import('/mods/M28AI/lua/AI/M28Engineer.lua').tsBlueprintsBySize[iPreferredSize], tMidpoint)))
        M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tMidpoint, iPreferredSize*0.5), 5, 400)
    end

    function RecordSmallShieldTemplate(tBaseTable, tMidpoint)
        tBaseTable[subrefiSmallArtiLocationCount] = 1
        tBaseTable[subrefiSmallArtiMaxSize] = 10
        tBaseTable[subrefiSmallShieldLocationCount] = 7
        --Vertical midpoint: Might as well pick it so we have 2 shields (12) below, and 1 paragon (10) above, so easier to think through adjustments
        --NOTE: Moving to left means -x; moving up means -z; moving down means +z, moving right means +x
        tBaseTable[subreftSmallArtiLocations] = {[1]={tMidpoint[1],0,tMidpoint[3]-5}} --1 paragon: At midpoint horizontally, but is size 10 vs 2 shields which are size 12, so want to move it up 2 vertically
        tBaseTable[subreftSmallShieldLocations] = {
            [1] = { tMidpoint[1] - 8, 0, tMidpoint[3] - 3 }, --To the left of the paragon (-5+-3); vertically the bottom will be in line with the paragon bottom
            [2] = { tMidpoint[1] + 8, 0, tMidpoint[3] - 3 }, --Right size of paragon
            [3] = { tMidpoint[1] - 6, 0, tMidpoint[3] + 3 }, --LH side,X: 2 in from the above LH shield; V: 3 down
            [4] = { tMidpoint[1], 0, tMidpoint[3] + 3 }, --Middle of the row
            [5] = { tMidpoint[1] + 6, 0, tMidpoint[3] + 3 }, --RH side
            [6] = { tMidpoint[1] - 3, 0, tMidpoint[3] + 9 }, --3rd row, LH
            [7] = { tMidpoint[1] + 3, 0, tMidpoint[3] + 9 }, --3rd row, RH
        }
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Will start by recording small shield template for tMidpoint='..repru(tMidpoint)..'; iPreferredSize='..(iPreferredSize or 'nil')..' at time='..GetGameTimeSeconds()) end
    RecordSmallShieldTemplate(tBaseTable, tMidpoint)
    --Now record large shield templates, which in some cases can support more shields and gameenders
    if iPreferredSize == 26 then
        --Can support 2 paragon size gameenders and 8 shields
        tBaseTable[subrefiLargeArtiLocationCount] = 2
        tBaseTable[subrefiLargeArtiMaxSize] = 10
        tBaseTable[subrefiLargeShieldLocationCount] = 8
        --Vertical midpoint: Might as well pick it so we have 2 shields (12) below, and paragon (10) above, so easier to think through adjustments
        tBaseTable[subreftLargeArtiLocations] = {
            [1]={tMidpoint[1]-8,0,tMidpoint[3]-5},
            [2]={tMidpoint[1]+2,0,tMidpoint[3]-5}
        }

        tBaseTable[subreftLargeShieldLocations] = {
            --NOTE: If changing these then review use of tbShieldEntriesNotToConsider
            [1] = { tMidpoint[1] +10, 0, tMidpoint[3] - 3 }, --To the right of the RH paragon
            [2] = { tMidpoint[1] - 10, 0, tMidpoint[3] + 3 }, --Row 2, LH side, X: 3 in from far left (which would be 13) in from the above LH shield; V: 3 down
            [3] = { tMidpoint[1] -4,0, tMidpoint[3] + 3 }, --Row 2 Inner left
            [4] = { tMidpoint[1] +2,0, tMidpoint[3] + 3 }, --Row 2 inner right
            [5] = { tMidpoint[1] +8,0, tMidpoint[3] + 3 }, --Row 2 far right
            [6] = { tMidpoint[1] - 7, 0, tMidpoint[3] + 9 }, --Row 3, LH
            [7] = { tMidpoint[1] -1,0, tMidpoint[3] + 9 }, --Row 3 mid
            [8] = { tMidpoint[1] +5,0, tMidpoint[3] + 9 }, --Row 3 Right
        }
    elseif iPreferredSize == 24 then
        --Can support 2 novax size gameenders and 8 shields
        tBaseTable[subrefiLargeArtiLocationCount] = 2
        tBaseTable[subrefiLargeArtiMaxSize] = 9
        tBaseTable[subrefiLargeShieldLocationCount] = 8

        tBaseTable[subreftLargeArtiLocations] = {
            [1]={tMidpoint[1]-7.5,0,tMidpoint[3]-5},
            [2]={tMidpoint[1]+1.5,0,tMidpoint[3]-5}
        }

        tBaseTable[subreftLargeShieldLocations] = {
            --NOTE: If changing these then review use of tbShieldEntriesNotToConsider
            [1] = { tMidpoint[1] +9, 0, tMidpoint[3] - 3 }, --To the right of the RH novax
            [2] = { tMidpoint[1] - 9, 0, tMidpoint[3] + 3 }, --Row 2, LH side, X: 3 in from far left (which would be 13) in from the above LH shield; V: 3 down
            [3] = { tMidpoint[1]+ -3,0, tMidpoint[3] + 3 }, --Row 2 Inner left
            [4] = { tMidpoint[1]+ 3,0, tMidpoint[3] + 3 }, --Row 2 inner right
            [5] = { tMidpoint[1] + 9,0, tMidpoint[3] + 3 }, --Row 2 inner right
            [6] = { tMidpoint[1] - 6, 0, tMidpoint[3] + 9 }, --Row 3, LH
            [7] = { tMidpoint[1], 0, tMidpoint[3] + 9 }, --Row 3 mid
            [8] = { tMidpoint[1]+ 6,0, tMidpoint[3] + 9 }, --Row 3 Right
        }
    elseif iPreferredSize == 22 then
        --Cant support anything other than the small shield
        tBaseTable[subrefiLargeArtiLocationCount] = 1
        tBaseTable[subrefiLargeArtiMaxSize] = 10
        tBaseTable[subrefiLargeShieldLocationCount] = 7
        --Vertical midpoint: Might as well pick it so we have 2 shields (12) below, and 1 paragon (10) above, so easier to think through adjustments
        tBaseTable[subreftLargeArtiLocations] = {[1]={tMidpoint[1],0,tMidpoint[3]-5}} --1 paragon: At midpoint horizontally, but is size 10 vs 2 shields which are size 12, so want to move it up 2 vertically
        tBaseTable[subreftLargeShieldLocations] = {
            --NOTE: If changing these then review use of tbShieldEntriesNotToConsider
            [1] = { tMidpoint[1] - 8, 0, tMidpoint[3] - 3 }, --To the left of the paragon (-5+-3); vertically the bottom will be in line with the paragon bottom
            [2] = { tMidpoint[1] + 8, 0, tMidpoint[3] - 3 }, --Right size of paragon
            [3] = { tMidpoint[1] - 6, 0, tMidpoint[3] + 3 }, --LH side,X: 2 in from the above LH shield; V: 3 down
            [4] = { tMidpoint[1], 0, tMidpoint[3] + 3 }, --Middle of the row
            [5] = { tMidpoint[1] + 6, 0, tMidpoint[3] + 3 }, --RH side
            [6] = { tMidpoint[1] - 3, 0, tMidpoint[3] + 9 }, --3rd row, LH
            [7] = { tMidpoint[1] + 3, 0, tMidpoint[3] + 9 }, --3rd row, RH
        }
    else M28Utilities.ErrorHandler('Dont have preplanned template for this size, iPreferredSize='..(iPreferredSize or 'nil'))
    end

    --Set the surface height of all arti and shield locations
    local tsLocationRefs = {subreftSmallArtiLocations, subreftSmallShieldLocations, subreftLargeArtiLocations, subreftLargeShieldLocations}
    for _, sTableRef in tsLocationRefs do
        for iEntry, tLocation in tBaseTable[sTableRef] do
            tLocation[2] = GetSurfaceHeight(tLocation[1], tLocation[3])
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code ,tBaseTable='..repru(tBaseTable)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tBaseTable
end

function RecordBackupGameEnderLocation()
    --Cycles through every land zone and records potential game-ender locations after waiting a while (1-off exercise)
    WaitSeconds(20)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordBackupGameEnderLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain
    if M28Utilities.IsTableEmpty(M28Overseer.tAllActiveM28Brains) == false then
        for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
            aiBrain = oBrain
            break
        end
        local iCurCount = 0
        local tiSizesToConsider = {26,24,22} --If changing, then update similar in M28Engineer AssignEngineerToGameEnderTemplate
        local iCurDistToMid, iMidpointX, iMidpointZ, iPreferredSegX, iPreferredSegZ, iPreferredSize, iClosestDistToMid
        local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
        local iSegmentsToSearch
        local iMidpointAdjust = 0
        --[[if math.floor(iLandZoneSegmentSize * 0.5) - iLandZoneSegmentSize * 0.5 == 0 then
            --Have an even number, so midpoint will be rounded; however FA looks like it snaps things to a 0.5 grid
            iMidpointAdjust = 0.49 --will increase midpoint X and Z by this - didnt solve issue of rectangles not being aligned so have commented out for now
        end--]]



        for iPlateau, tPlateauSubtable in tAllPlateaus do
            for iLandZone, tLZData in tAllPlateaus[iPlateau][subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering P'..iPlateau..'Z'..iLandZone..'; MexCount='..(tLZData[subrefLZMexCount] or 'nil')..'; Segment count='..(tLZData[subrefLZTotalSegmentCount] or 'nil')..'; Segment size='..(iLandZoneSegmentSize or 'nil')..'; subrefiLastSegmentEntryConsideredForBuilding='..(tLZData[subrefiLastSegmentEntryConsideredForBuilding] or 'nil')..'; subrefiCumulativeSegmentsConsideredForBuilding='..(tLZData[subrefiCumulativeSegmentsConsideredForBuilding] or 'nil')..'; Time='..GetGameTimeSeconds()) end
                if tLZData[subrefLZMexCount] >= 1 and tLZData[subrefLZTotalSegmentCount] >= 250 / iLandZoneSegmentSize  then
                    iCurCount = iCurCount + 1
                    if iCurCount >= 25 then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        iCurCount = 0
                    end
                    iSegmentsToSearch = 50
                    if (tLZData[subrefiCumulativeSegmentsConsideredForBuilding] or 0) < tLZData[subrefLZTotalSegmentCount] * 0.35 then
                        iSegmentsToSearch = math.max(50, tLZData[subrefLZTotalSegmentCount] * 0.2)
                    end
                    M28Engineer.SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateau, iLandZone, iSegmentsToSearch)
                    if bDebugMessages == true then LOG(sFunctionRef..': After searching, subrefiLastSegmentEntryConsideredForBuilding='..(tLZData[subrefiLastSegmentEntryConsideredForBuilding] or 'nil')..'; subrefiCumulativeSegmentsConsideredForBuilding='..(tLZData[subrefiCumulativeSegmentsConsideredForBuilding] or 'nil')..'; iSegmentsToSearch='..iSegmentsToSearch) end
                    iClosestDistToMid = 10000
                    iMidpointX, iMidpointZ = GetPathingSegmentFromPosition(tLZData[subrefMidpoint])
                    iPreferredSize = nil
                    local iCurRadius, bCanBuild, sCurBP

                    for _, iCurSize in tiSizesToConsider do
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table for size '..iCurSize..' empty='..tostring(M28Utilities.IsTableEmpty(tLZData[subrefBuildLocationsBySizeAndSegment][iCurSize]))) end
                        if M28Utilities.IsTableEmpty(tLZData[subrefBuildLocationsBySizeAndSegment][iCurSize]) == false then
                            sCurBP = M28Engineer.tsBlueprintsBySize[iCurSize]
                            iCurRadius = iCurSize * 0.5
                            for iSegX, tSubtable in tLZData[subrefBuildLocationsBySizeAndSegment][iCurSize] do
                                for iSegZ, bValid in tSubtable do
                                    iCurDistToMid = math.abs(iSegX - iMidpointX) + math.abs(iSegZ - iMidpointZ)
                                    if iCurDistToMid < iClosestDistToMid then
                                        --Check we can actually build here, taking into account resource deposits
                                        if not(M28Engineer.IsBuildLocationBlockedByResources(tLZData, iCurRadius, GetPositionFromPathingSegments(iSegX, iSegZ), true)) then
                                            --Double check if we adjust the midpoint we can still build here
                                            bCanBuild = false
                                            if iMidpointAdjust == 0 then bCanBuild = true
                                            else
                                                local tAdjustedMidpoint = GetPositionFromPathingSegments(iSegX, iSegZ)
                                                tAdjustedMidpoint[1] = tAdjustedMidpoint[1] + iMidpointAdjust
                                                tAdjustedMidpoint[3] = tAdjustedMidpoint[3] + iMidpointAdjust
                                                if aiBrain:CanBuildStructureAt(sCurBP, tAdjustedMidpoint) then
                                                    bCanBuild = true
                                                end

                                            end
                                            if bCanBuild then
                                                iClosestDistToMid = iCurDistToMid
                                                iPreferredSize = iCurSize
                                                iPreferredSegX = iSegX
                                                iPreferredSegZ = iSegZ
                                            end
                                        elseif bDebugMessages == true then LOG(sFunctionRef..': Segment X'..iSegX..'Z'..iSegZ..' is blocked by resources so will ignore')
                                        end
                                    end
                                end
                            end
                        end
                        if iPreferredSize then break end
                    end
                    if iPreferredSize then
                        --Determine the arti location values
                        local tMidpoint = GetPositionFromPathingSegments(iPreferredSegX, iPreferredSegZ)
                        tMidpoint[1] = tMidpoint[1] + iMidpointAdjust --Snapto grid moves things to the nearest .5, i.e. doesnt do round numbers; however have disabled logic relating to this
                        tMidpoint[3] = tMidpoint[3] + iMidpointAdjust

                        --Mavor, yolona, scathis and T3 arti are size 8, novax 9, Paragon+rapid fire arti 10, while shields are size 6; fo all templates vertically want 1 gameender and 2 shields deep, or 2 gameender 1 shield deep
                        --i.e.: Size 22: Supports 2 size 8 gameenders+1 shield (large shields), or 1 size 10 gameender (small shields)
                        --Size 24: Supports 2 size 9 gameenders+1 shield (large shields), or 1 size 10 gameender (small shields)
                        --Size 26: Supports 2 size 10 gameenders+1 shield (large shields), or 1 size 10 gameender (small shields)
                        --tLZData[subrefGameEnderTemplateBackupLocationSizeAndSegment] = {[subrefiSize]=iPreferredSize, [subrefiSegX] = iPreferredSegX, [subrefiSegZ] = iPreferredSegZ, [subrefiSmallArtiLocationCount]=1,[subrefiSmallArtiMaxSize]=10,[subrefiSmallShieldLocationCount]=1,[subreftSmallArtiLocations]=0,[subreftSmallShieldLocations]=0,[subrefiLargeArtiLocationCount]=1,[subrefiLargeArtiMaxSize]=10,[subrefiLargeShieldLocationCount]=1,[subreftLargeArtiLocations]=0,[subreftLargeShieldLocations]=0}
                        --local tBaseTable = tLZData[subrefGameEnderTemplateBackupLocationSizeAndSegment]

                        --For all sizes, want to support a gameender and Aeon/Cybran shields
                        tLZData[subrefGameEnderTemplateBackupLocationSizeAndSegment] = AddGameEnderTemplateInfoToTable(tMidpoint, iPreferredSize)



                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Location recorded for plateau '..iPlateau..' zone '..iLandZone..'; tLZData[subrefGameEnderTemplateBackupLocationSizeAndSegment]='..repru(tLZData[subrefGameEnderTemplateBackupLocationSizeAndSegment])..'; will draw in gold, can aiBrain build structure here='..tostring(aiBrain:CanBuildStructureAt(M28Engineer.tsBlueprintsBySize[iPreferredSize], GetPositionFromPathingSegments(iPreferredSegX, iPreferredSegZ)))..' (using blueprint '..M28Engineer.tsBlueprintsBySize[iPreferredSize]..'), Can brain build novax here='..tostring(aiBrain:CanBuildStructureAt('xeb2402', GetPositionFromPathingSegments(iPreferredSegX, iPreferredSegZ)))..'; Midpoint='..repru(tMidpoint)..'; iMidpointAdjust='..iMidpointAdjust)
                            M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(GetPositionFromPathingSegments(iPreferredSegX, iPreferredSegZ), iPreferredSize*0.5), 4, 400)
                            --Draw the large arti locations in red, and shield locations in blue
                            for iEntry, tLocation in tLZData[subrefGameEnderTemplateBackupLocationSizeAndSegment][subreftLargeArtiLocations] do
                                M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tLocation, tLZData[subrefGameEnderTemplateBackupLocationSizeAndSegment][subrefiLargeArtiMaxSize]*0.5), 2, 400)
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Large shield locations='..repru(tLZData[subrefGameEnderTemplateBackupLocationSizeAndSegment][subreftLargeShieldLocations])) end
                            for iEntry, tLocation in tLZData[subrefGameEnderTemplateBackupLocationSizeAndSegment][subreftLargeShieldLocations] do
                                M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tLocation, 3), 1, 400)
                            end
                        end

                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, Time='..GetGameTimeSeconds()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MarkZoneForFortification(iPlateauOrZero, iLandOrWaterZone, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MarkZoneForFortification'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Will mark P'..iPlateauOrZero..'Z'..iLandOrWaterZone..' for fortification for team '..iTeam..' at time='..GetGameTimeSeconds()) end
    if not(iPlateauOrZero) or not(iLandOrWaterZone) then M28Utilities.ErrorHandler('Trying to mark a zone for fortification but it has a nil plateau or LZ, iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')) end
    local tLZOrWZData
    local tLZOrWZTeamData
    if iPlateauOrZero > 0 then
        tLZOrWZData  = tAllPlateaus[iPlateauOrZero][subrefPlateauLandZones][iLandOrWaterZone]
        tLZOrWZTeamData = tLZOrWZData[subrefLZTeamData][iTeam]
    else
        --Water zone
        tLZOrWZData = tPondDetails[tiPondByWaterZone[iPlateauOrZero]][subrefPondWaterZones][iLandOrWaterZone]
        tLZOrWZTeamData = tLZOrWZData[subrefWZTeamData][iTeam]
    end
    tLZOrWZTeamData[subrefLZFortify] = true
    if not(M28Team.tTeamData[iTeam][M28Team.reftiFortifyZonesByPlateau][iPlateauOrZero]) then
        if not(M28Team.tTeamData[iTeam][M28Team.reftiFortifyZonesByPlateau]) then M28Team.tTeamData[iTeam][M28Team.reftiFortifyZonesByPlateau] = {} end
        M28Team.tTeamData[iTeam][M28Team.reftiFortifyZonesByPlateau][iPlateauOrZero] = {}
    end
    M28Team.tTeamData[iTeam][M28Team.reftiFortifyZonesByPlateau][iPlateauOrZero][iLandOrWaterZone] = true
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ReassessPositionsForPlayerDeath(aiBrain)
    --Intended when a aiBrain's base is destroyed along with that player - i.e. if not in full share, and are in assassination (ACU death) or demoralisation (ACU+SACU death)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReassessPositionsForPlayerDeath'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    for iTeam = 1, M28Team.iTotalTeamCount do
        if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 0 then
            --Reset primary enemy base location (redundancy)
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                if not(aiBrain == oBrain) and not(oBrain.M28IsDefeated) then
                    local tCurEnemyBase = {oBrain[reftPrimaryEnemyBaseLocation][1], oBrain[reftPrimaryEnemyBaseLocation][2], oBrain[reftPrimaryEnemyBaseLocation][3]}
                    oBrain[reftPrimaryEnemyBaseLocation] = nil
                    if M28Utilities.IsTableEmpty(GetPrimaryEnemyBaseLocation(oBrain)) then oBrain[reftPrimaryEnemyBaseLocation] = {tCurEnemyBase[1], tCurEnemyBase[2], tCurEnemyBase[3]} end
                end
            end


            if bDebugMessages == true then LOG(sFunctionRef..': Rerecording distsances to closest friendly and enemy base for iTeam='..iTeam) end
            RecordClosestAllyAndEnemyBaseForEachLandZone(iTeam)
            RecordClosestAllyAndEnemyBaseForEachWaterZone(iTeam, true)
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                if not(aiBrain == oBrain) and not(oBrain.M28IsDefeated) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Reassessing pond to expand to for brain='..oBrain.Nickname) end
                    RecordPondToExpandTo(oBrain)
                end
            end
            local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
            M28Navy.FlagWaterZoneStartPositions(iTeam)
        end
    end
end