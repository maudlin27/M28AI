---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 16/11/2022 07:20
---

local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Chat = import('/mods/M28AI/lua/AI/M28Chat.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')


bInitialSetup = false
tAllActiveM28Brains = {} --[x] is just a unique integer starting with 1 (so table.getn works on this), not the armyindex; returns the aiBrain object
tAllAIBrainsByArmyIndex = {} --[x] is the brain army index, returns the aibrain
bDebugTickCheckerActive = false
iTimeOfLatestBrainToCheckForM28Logic = -1

--Special settings - restrictions and norush
bUnitRestrictionsArePresent = false
bAirFactoriesCantBeBuilt = false
bNoRushActive = false
iNoRushRange = 0
iNoRushTimer = 0 --Gametimeseconds that norush should end
reftNoRushCentre = 'M28OverseerNRCtre' --against aiBrain
reftNoRushM28StartPoints = { } --start positions for all norush buildable locations
bActiveMissionChecker = false --true if are actively checking for mission objectives - now used for niche objectives to monitor
bPacifistModeActive = false --true if we have set certain zones to never be attacked (e.g. Cybran mission 4)
bHaveDisabledGunshipWeaponsForPacifism = false --true if we have disabled gunship weapons due to pacifism
tiPacifistZonesByPlateau = {} --[iPlateau], returns iLandOrWaterZone, for any zone flagged as pacificst
bBeginSessionTriggered = false
bCheckForPrecreatedUnitsActive = false
iMassFabRatio = 1 --e.g. some mods can improve mass fab resources given
bNonAISimModsActive = false

--Campaign specific variables
bActiveObjectiveUnitValidMonitorByObjective = {} --True if already are actively monitoring a particular unit
tbSpecialCodeForMission = {} --[x] is the mission reference, true if have run special code already

--aiBrain variables
refbInitialised = 'M28OvInt' --true if brain has started the main initialisation logic
refiDistanceToNearestEnemyBase = 'M28OverseerDistToNearestEnemyBase'
refoNearestEnemyBrain = 'M28OverseerNearestEnemyBrain'
refbCloseToUnitCap = 'M28OverseerCloseToUnitCap'
refiLastUnitCapTimeCheck = 'M28UnitCapChk' --Gametimeseconds that the brain last did a unit cap check
refbWillDoDelayedUnitCapCheck = 'M28UnitCapD' --true if we are already doing a delayed unit cap check
refiExpectedRemainingCap = 'M28OverseerUnitCap' --number of units to be built before we potentially hit the unit cap, i.e. used as a rough guide for when shoudl call the code to check the unit cap
refiUnitCapCategoriesDestroyed = 'M28OverseerLstCatDest' --Last category destroyed by unit cap logic
refiTimeOfLastUnitCapDeath = 'M28OverseerTmLstCpDth' --time we last ctrlkd a unit due to the unit cap
refiTemporarilySetAsAllyForTeam = 'M28TempSetAsAlly' --against brain, e.g. a civilian brain, returns the .M28Team number that the brain has been set as an ally of temporarily (to reveal civilians at start of game)
refiTransferedUnitCount = 'M28OvsrXfUC' --Increases by one each time units are transferred to a player
reftoTransferredUnitMexesAndFactoriesByCount = 'M28OvsrXfUT'
refiRoughUnitCount = 'M28OvsrUntCn' --Currently only used against M28 brains, returns number of units brain has; is updated periodically to reflect the actual number
refiTimeLastUpdatedUnitCount = 'M28OvsrUntTm' --Gametimeseconds we last used a precise value for refiRoughUnitCount


--Global other variables
refiRoughTotalUnitsInGame = 0 --Very rough count of units in game, so can use more optimised code if this gets high
refiCurGETemplateGlobalCount = 0 --Used to spread out calculations for gameender templates
bLikelyGunUpgrade = false --true if anyone has a gun upgrade


function GetNearestEnemyBrain(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNearestEnemyBrain'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if (aiBrain[refoNearestEnemyBrain] and not(aiBrain[refoNearestEnemyBrain].M28IsDefeated) and not(aiBrain[refoNearestEnemyBrain]:IsDefeated())) or aiBrain.M28IsDefeated then
        if bDebugMessages == true then LOG(sFunctionRef..': Previously nearest enemy brain is still valid='..(aiBrain[refoNearestEnemyBrain].Nickname or 'nil')) end
        return aiBrain[refoNearestEnemyBrain]
    else
        if bDebugMessages == true then LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..'; Is pathing complete='..tostring(M28Map.bMapLandSetupComplete)..'; Dont have a valid nearest enemy already recorded for aiBrain '..(aiBrain.Nickname or 'nil')..' with index '..aiBrain:GetArmyIndex()..' so will get a new one; are all enemies defeated for team '..aiBrain.M28Team..'='..tostring(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated])) end
        local oNearestBrain
        if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated] then
            --All enemies defeated so will consider civilians as enemy brains
            local oCivilianBrain
            if bDebugMessages == true then LOG(sFunctionRef..': All enemies defeated so will consider all brains including civilians') end
            for iCurBrain, oBrain in ArmyBrains do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering obrain '..(oBrain.Nickname or 'nil')..'; is enemy to us='..tostring(IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()))) end
                if IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()) then
                    oNearestBrain = oBrain
                    break
                elseif M28Conditions.IsCivilianBrain(oBrain) then
                    oCivilianBrain = oBrain
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': All normal enemies defeated, oNearestBrain='..(oNearestBrain.Nickname or 'nil')..'; oCivilianBrain='..(oCivilianBrain.Nickname or 'nil')) end

            if not (oNearestBrain) then
                oNearestBrain = oCivilianBrain
            end
        else
            local iCurDist
            local iMinDistToEnemy = 10000000
            if bDebugMessages == true then LOG(sFunctionRef .. ': Start before looping through brains; aiBrain personality=' .. ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality .. '; brain.Name=' .. aiBrain.Name) end

            for iCurBrain, oBrain in ArmyBrains do
                if bDebugMessages == true then LOG(sFunctionRef .. ': Start of brain loop, iCurBrain=' .. iCurBrain .. '; brain personality=' .. ScenarioInfo.ArmySetup[oBrain.Name].AIPersonality .. '; brain Nickname=' .. oBrain.Nickname .. '; Brain index=' .. oBrain:GetArmyIndex() .. '; if brain isnt equal to our AI brain then will get its start position etc. IsCivilian='..tostring(M28Conditions.IsCivilianBrain(oBrain))..'; IsEnemy='..tostring(IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()))..'; Is oBrain a .M28AI brain='..tostring(oBrain.M28AI or false)) end
                if not (oBrain == aiBrain) and (not (M28Conditions.IsCivilianBrain(oBrain)) and IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex())) then
                    if bDebugMessages == true then LOG(sFunctionRef .. ': Brain is dif to aiBrain and a non civilian enemy so will record its start position number if it doesnt have one already') end

                    if not (oBrain:IsDefeated()) and not (oBrain.M28IsDefeated) then
                        --Redundancy for AI like DD that may not trigger the aibrain hook
                        if not(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()]) then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            M28Map.RecordBrainStartPoint(oBrain)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

                        end
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Considering nearest enemy for our brain index '..aiBrain:GetArmyIndex()..'; enemy brain with index' .. oBrain:GetArmyIndex() .. ' and nickname '..(oBrain.Nickname or 'nil')..' is not defeated and is an enemy; M28Map.PlayerStartPoints='..repru( M28Map.PlayerStartPoints))
                            local iX, iZ = M28Map.GetPlayerStartPosition(oBrain, true)
                            LOG(sFunctionRef..': Enemy Start iX='..(iX or 'nil')..'; Start iZ+'..(iZ or 'nil'))
                        end
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()], M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                        if iCurDist < iMinDistToEnemy then
                            iMinDistToEnemy = iCurDist
                            oNearestBrain = oBrain
                        end
                    end

                    --Strange bug where still returns true for empty slot - below line to avoid this:
                    --[[if GetGameTimeSeconds() <= 5 or brain:GetCurrentUnits(categories.ALLUNITS) > 0 then
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': brain has some units')
                        end
                        if M28Map.PlayerStartPoints[brain:GetArmyIndex()] then
                            iDistToCurEnemy = M28Utilities.GetDistanceBetweenPositions(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()], M28Map.PlayerStartPoints[brain:GetArmyIndex()])
                            if bDebugMessages == true then LOG(sFunctionRef..': Dist between brain and aibrain start points='..iDistToCurEnemy) end
                            if iDistToCurEnemy < iMinDistToEnemy then
                                iMinDistToEnemy = iDistToCurEnemy
                                iNearestEnemyIndex = brain:GetArmyIndex()
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': Current nearest enemy index=' .. iNearestEnemyIndex .. '; startp osition of this enemy=' .. repru(M28Map.PlayerStartPoints[iNearestEnemyIndex]))
                                end
                            end
                        else
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Map info doesnt have a start point for brain with index=' .. brain:GetArmyIndex()..' and nickanme='..(brain.Nickname or 'nil')..'; PlayerStartPoints='..repru(M28Map.PlayerStartPoints))
                            end
                        end
                    else
                        --Can have some cases where have an aibrain but no units, e.g. map Africa has ARMY_9 aibrain name, with no personality, that has no units; will flag the brain as being defeated to be safe if getgametimeseonds is more than 1min
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': WARNING: brain isnt defeated but has no units; brain:ArmyIndex=' .. brain:GetArmyIndex())
                        end
                        if GetGameTimeSeconds() >= 60 then brain.M28IsDefeated = true end
                    end--]]
                end
            end
        end
        if not(oNearestBrain) then
            M28Utilities.ErrorHandler('Couldnt find a nearest brain to aiBrain='..aiBrain.Nickname)
            if GetGameTimeSeconds() <= 10 then M28Chat.SendMessage(aiBrain, 'NoEnemies', 'Unable to identify any enemies for '..(aiBrain.Nickname or 'a brain')..', M28 may not function properly', 0, 10000, false) end
            M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated] = true
            --Set the nearest enemy as the furthest away other brain (even if it isnt an enemy) - i.e. if do as furthest enemy then more likely to have units passing enemy units
            local iFurthestDist = 0
            local iCurDist
            for iBrain, oBrain in ArmyBrains do
                if not(oBrain == aiBrain) then
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(M28Map.GetPlayerStartPosition(aiBrain), M28Map.GetPlayerStartPosition(oBrain))
                    if iCurDist > iFurthestDist then
                        oNearestBrain = oBrain
                        iFurthestDist = iCurDist
                    end
                end
            end
        end
        aiBrain[refoNearestEnemyBrain] = oNearestBrain
    end
    return aiBrain[refoNearestEnemyBrain]
end

function GameSettingWarningsChecksAndInitialChatMessages(aiBrain)
    --Run once (i.e. no matter how many M28 brains are present will run max of one time) at start of the game if an M28 brain is present
    local sFunctionRef = 'GameSettingWarningsChecksAndInitialChatMessages'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Start of compatibility check.  Size of tAllActiveM28Brains=' .. table.getsize(tAllActiveM28Brains))
    end
    local sIncompatibleMessage = ''
    local bIncompatible = false
    local bHaveOtherAIMod = false


    if M28Utilities.IsTableEmpty(ScenarioInfo.Options.RestrictedCategories) == false then
        bIncompatible = true
        bUnitRestrictionsArePresent = true
        sIncompatibleMessage = sIncompatibleMessage .. ' Unit restrictions. '
    end
    --Check if we can build air factories
    local tFriendlyACU = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of friendly ACU empty='..tostring(M28Utilities.IsTableEmpty(tFriendlyACU))) end
    while M28Utilities.IsTableEmpty(tFriendlyACU) and GetGameTimeSeconds() < 20 do --UEF Campaign M1 - ACU spawns just after 10s
        WaitTicks(1)
        tFriendlyACU = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
        if bDebugMessages == true then LOG(sFunctionRef..': Is tFriendlyACU empty='..tostring( M28Utilities.IsTableEmpty(tFriendlyACU))..'; Brain='..aiBrain.Nickname..'; Time='..GetGameTimeSeconds()..'; Is allunits empty='..tostring(M28Utilities.IsTableEmpty(aiBrain:GetListOfUnits(categories.ALLUNITS, false, true)))) end
    end
    if M28Utilities.IsTableEmpty(tFriendlyACU) == false then
        --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition,               oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
        local sBlueprint = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryAirFactory, tFriendlyACU[1])
        if bDebugMessages == true then LOG(sFunctionRef..': If ACU '..tFriendlyACU[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tFriendlyACU[1])..' tries to build an air factory, sBLueprint is '..(sBlueprint or 'nil')) end
        local bCantBuild
        if not(sBlueprint) then
            bCantBuild = true
            if bDebugMessages == true then LOG(sFunctionRef..': Blueprint is nil so will set that cant build') end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Is blueprint '..sBlueprint..' restricted for brain '..aiBrain.Nickname..'='..tostring(M28UnitInfo.IsUnitRestricted(sBlueprint, aiBrain:GetArmyIndex()))) end
            if M28UnitInfo.IsUnitRestricted(sBlueprint, aiBrain:GetArmyIndex()) then
                bCantBuild = true
            end
        end
        if bCantBuild then
            bAirFactoriesCantBeBuilt = true
            if not(bUnitRestrictionsArePresent) then
                bUnitRestrictionsArePresent = true
                sIncompatibleMessage = sIncompatibleMessage .. ' Custom map script or mod preventing air factories'
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Setting bAirFactoriesCantBeBuilt to true, bAirFactoriesCantBeBuilt='..tostring(bAirFactoriesCantBeBuilt)) end
        end
    end
    if not(bUnitRestrictionsArePresent) then
        --Check if campaign or map has any active restrictions
        if M28Utilities.bFAFActive then
            if bDebugMessages == true then LOG(sFunctionRef..': bUnitRestrictionsArePresent='..tostring(bUnitRestrictionsArePresent)..'; Is getrestrictions empty='..tostring(M28Utilities.IsTableEmpty(import("/lua/game.lua").GetRestrictions()))..'; reprs of this='..reprs(import("/lua/game.lua").GetRestrictions())) end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Not in FAF so normal method of checking for unit restrictions wont work') end
        end
        if M28Utilities.bFAFActive and M28Utilities.IsTableEmpty(import("/lua/game.lua").GetRestrictions()) == false then
            bUnitRestrictionsArePresent = true
        end
    end


    if not (ScenarioInfo.Options.NoRushOption == "Off") then
        bIncompatible = true
        sIncompatibleMessage = sIncompatibleMessage .. ' No rush timer. '
    end
    --Check for non-AI sim-mods.  Thanks to Softles for pointing me towards the __active_mods variable
    local tSimMods = __active_mods or {}
    local tAIModNameWhitelist = { 'M27AI', 'AI-Swarm', 'AI-Uveso', 'AI: DilliDalli', 'Dalli AI', 'Dilli AI', 'M20AI', 'Marlo\'s Sorian AI edit', 'RNGAI', 'SACUAI', 'M28AI' }

    local tAIModNameWhereExpectAI = { 'AI-Swarm', 'AI-Uveso', 'AI: DilliDalli', 'Dalli AI', 'Dilli AI', 'M20AI', 'Marlo\'s Sorian AI edit', 'RNGAI', 'M27AI' } --Dont include M28 in this list, i.e. it shoudl be every AI except M28
    local tModIsOk = {}
    local bHaveOtherAI = false
    local sUnnecessaryAIMod
    local iUnnecessaryAIModCount = 0
    for iAI, sAI in tAIModNameWhitelist do
        tModIsOk[sAI] = true
    end

    local iSimModCount = 0
    local bFlyingEngineers
    local bM27InGame = false
    for iMod, tModData in tSimMods do
        if not (tModIsOk[tModData.name]) and tModData.enabled and not (tModData.ui_only) then
            iSimModCount = iSimModCount + 1
            bNonAISimModsActive = true
            bIncompatible = true
            if iSimModCount == 1 then
                sIncompatibleMessage = sIncompatibleMessage .. ' SIM mods '
            else
                sIncompatibleMessage = sIncompatibleMessage .. '; '
            end
            sIncompatibleMessage = sIncompatibleMessage .. ' ' .. (tModData.name or 'UnknownName')
            if bDebugMessages == true then
                LOG('Whitelist of mod names=' .. repru(tModIsOk))
                LOG(sFunctionRef .. ' About to do reprs of the tModData for mod ' .. (tModData.name or 'nil')..': '..reprs(tModData))
            end

            if string.find(tModData.name, 'Flying engineers') then
                bFlyingEngineers = true
                if bDebugMessages == true then LOG(sFunctionRef..': Have flying engineers mod enabled so will adjust engineer categories') end
            end
        elseif tModIsOk[tModData.name] then
            if not(bHaveOtherAIMod) then
                for iAIMod, sAIMod in tAIModNameWhereExpectAI do
                    if sAIMod == tModData.name then
                        bHaveOtherAIMod = true
                        if sAIMod == 'M27AI' then bM27InGame = true end
                        break
                    end
                end
                if bHaveOtherAIMod then
                    --Do we have non-M28 AI?
                    for iBrain, oBrain in ArmyBrains do
                        if bDebugMessages == true then LOG(sFunctionRef..': Have another AI mod enabled. reprs of oBrain='..reprs(oBrain)..'; is BrainType empty='..tostring(oBrain.BrainType == 'nil')..'; is brian type an empty string='..tostring(oBrain.BrainType == '')) end
                        if ((oBrain.BrainType == 'AI' and not(oBrain.M28AI)) or oBrain.DilliDalli) and not(M28Conditions.IsCivilianBrain(oBrain)) then
                            bHaveOtherAI = true
                            if bDebugMessages == true then LOG('Have an AI for a brain') end
                            break
                        end
                    end
                end
            end
            if bHaveOtherAIMod and not(bHaveOtherAI) then
                local bUnnecessaryMod = false
                for iAIMod, sAIMod in tAIModNameWhereExpectAI do
                    if sAIMod == tModData.name then
                        bUnnecessaryMod = true
                        break
                    end
                end
                if bUnnecessaryMod then

                    iUnnecessaryAIModCount = iUnnecessaryAIModCount + 1
                    if iUnnecessaryAIModCount == 1 then
                        sUnnecessaryAIMod = tModData.name
                    else
                        sUnnecessaryAIMod = sUnnecessaryAIMod..', '..tModData.name
                    end
                end
            end
        end
    end

    if iSimModCount > 0 then
        sIncompatibleMessage = sIncompatibleMessage .. '. '
    end
    local bDontPlayWithM27 = false
    local iHumans = 0
    for iBrain, oBrain in ArmyBrains do
        if oBrain.BrainType == 'Human' then
            iHumans = iHumans + 1
        end
    end
    if bM27InGame then
        --Count how many players - if more than 1 then desync risk
        if iHumans > 1 then
            bDontPlayWithM27 = true --Azraeel came across desyncs when playing with M27 and M28 together
            bIncompatible = true
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Finished checking compatibility; compatibility message=' .. sIncompatibleMessage .. '; iSimModCount=' .. iSimModCount)
    end

    if iSimModCount > 0 then
        --Basic compatibiltiy with flying engineers mod - allow air engineers to be treated as engineers; also work on mods with similar effect but different name
        if not(bFlyingEngineers) and M28Utilities.IsTableEmpty(EntityCategoryGetUnitList(M28UnitInfo.refCategoryEngineer * categories.TECH1)) then bFlyingEngineers = true end
        if bFlyingEngineers then
            M28UnitInfo.refCategoryEngineer = M28UnitInfo.refCategoryEngineer + categories.ENGINEER * categories.AIR * categories.CONSTRUCTION - categories.EXPERIMENTAL
        end
        --BREWLAN compatibility - it adds the TRANSPORTATION category to units that cant transport, leading to errors when M28 tries using them or getting their cargo
        if categories.TORPEDOBOMBER then M28UnitInfo.refCategoryTransport = M28UnitInfo.refCategoryTransport - categories.TORPEDOBOMBER end --thanks to Balthazaar who gave this tip for checking if a custom category exists
    end

    if bIncompatible then
        if bDontPlayWithM27 then
            if sUnnecessaryAIMod and not(bHaveOtherAI) then
                --Disabled as seen a bunch of games with M27 enabled and M28 active with no desync
                --M28Chat.SendMessage(aiBrain, 'SendGameCompatibilityWarning', 'Sorry I don’t like it when M27AI is watching and adults are around - he teases me about how much better he is and sometimes the game desyncs.  Please disable the M27AI mod.', 15, 15)
            else
                --warning based on Az noting there were sometimes desyncs with M27 and M28 playing together
                M28Chat.SendMessage(aiBrain, 'SendGameCompatibilityWarning', 'Sorry I don’t get on well with my brother M27 when adults are around – he teases me about how much better he is and sometimes the game desyncs', 15, 15)
            end
        else
            M28Chat.SendMessage(aiBrain, 'SendGameCompatibilityWarning', 'Detected '..sIncompatibleMessage .. ' (v'..import('/mods/M28AI/mod_info.lua').version..') if you come across M28AI issues with these settings/mods let maudlin27 know via Discord', 0, 10)
        end
    end
    if not(bDontPlayWithM27) and bHaveOtherAIMod and not(bHaveOtherAI) and sUnnecessaryAIMod then
        M28Chat.SendMessage(aiBrain, 'UnnecessaryMods', 'No other AI detected, These AI mods can be disabled: '..sUnnecessaryAIMod, 1, 10)
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function M28BrainCreated(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'M28BrainCreated'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': M28 Brain has just been created for aiBrain '..aiBrain.Nickname..'; Index='..aiBrain:GetArmyIndex()..'; bInitialSetup='..tostring(bInitialSetup or false)..'; Is campaign AI='..tostring(aiBrain.CampaignAI or false)..'; Cheat enabled='..tostring(aiBrain.CheatEnabled or false)..'; Time='..GetGameTimeSeconds()) end

    aiBrain.M28AI = true
    M28Utilities.bM28AIInGame = true
    table.insert(tAllActiveM28Brains, aiBrain)

    --Set cheat mult if this is campaign (which doesnt allow in game options)
    if aiBrain.CheatEnabled then
        if M28Utilities.bLoudModActive or aiBrain.CheatValue then
            if bDebugMessages == true then LOG(sFunctionRef..': Setting build and resource cheat modifiers based on aiBrain.CheatValue='..aiBrain.CheatValue) end
            SetBuildAndResourceCheatModifiers(aiBrain, (aiBrain.CheatValue or 1), (aiBrain.CheatValue or 1), false)
        elseif not(ScenarioInfo.Options.CheatMult) then
            if bDebugMessages == true then LOG(sFunctionRef..': No cheat mult in scenario options so will set to 1.5 for build and resource') end
            SetBuildAndResourceCheatModifiers(aiBrain, 1.5, 1.5)
        elseif aiBrain.CheatEnabled and (aiBrain.CampaignAI or M28Utilities.bLoudModActive) and ScenarioInfo.Options.CmApplyAIx == 1 then
            if bDebugMessages == true then LOG(sFunctionRef..': Will apply AIx modifiers to brain '..aiBrain.Nickname) end
            SetBuildAndResourceCheatModifiers(aiBrain, tonumber(ScenarioInfo.Options.CheatMult), tonumber(ScenarioInfo.Options.BuildMult), true)
        elseif aiBrain.CheatEnabled then
            SetBuildAndResourceCheatModifiers(aiBrain, (aiBrain.CheatValue or tonumber(ScenarioInfo.Options.CheatMult) or 1), (aiBrain.CheatValue or tonumber(ScenarioInfo.Options.CheatMult) or 1), true, nil, true)
        end
    end

    --Setup AI personality for this
    M28Chat.AssignAIPersonalityAndRating(aiBrain)
    --Set easy flag
    if ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28aie' or ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28aiecheat' then
        aiBrain.M28Easy = true
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering if dealing with easy AI, M28Easy='..tostring(aiBrain.M28Easy or false)) end


    if not(bInitialSetup) then
        bInitialSetup = true
        local LoudCompatibility = import('/mods/M28AI/lua/AI/LOUD/M28OtherLOUDCompatibility.lua')
        if not(M28Utilities.bLoudModActive) or not(_G.reprs) then LoudCompatibility.AddReprCommands() end --If LOUD is active will have already called this
        if bDebugMessages == true then LOG(sFunctionRef..': About to do one-off setup for all brains, will also fork various threads including for overwhelm, Overwhelm rate='..tonumber(ScenarioInfo.Options.M28OvwR or tostring(0))..'; ScenarioInfo.Options.M28OvwT='..(ScenarioInfo.Options.M28OvwT or 'nil')) end
        M28Utilities.bM28AIInGame = true
        --LOG('M28 in game 3')

        --Send a message warning players this could take a while
        M28Chat.SendMessage(aiBrain, 'LoadingMap', 'Analysing map for v'..import('/mods/M28AI/mod_info.lua').version..', this will freeze the game for a while.  Contact maudlin27 on discord if the freeze lasts more than 2 minutes', 0, 10000, false)
        ForkThread(GameSettingWarningsChecksAndInitialChatMessages, aiBrain)
        ForkThread(M28Map.SetupMap)
        ForkThread(UpdateMaxUnitCapForRelevantBrains)
        ForkThread(M28Building.DetermineBuildingExpectedValues)
        if not(tonumber(ScenarioInfo.Options.M28OvwR or tostring(0)) == 0) and ScenarioInfo.Options.M28OvwT then
            ForkThread(M28Economy.AdjustAIxOverwhelmRate)
        end
        ForkThread(GlobalOverseer)
    end
    LOG('Calling overseer manager via a fork')
    ForkThread(OverseerManager, aiBrain)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function SetupNoRushDetails(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupNoRushDetails'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end

    if ScenarioInfo.Options.NoRushOption  and not(ScenarioInfo.Options.NoRushOption == 'Off') then
        if bDebugMessages == true then LOG(sFunctionRef..': No rush isnt active, will record details') end
        if not(bNoRushActive) then --This is the first time for any AI that this is run (redundancy)
            if bDebugMessages == true then LOG(sFunctionRef..': Log of ScenarioInfo='..repru(ScenarioInfo)) end
            bNoRushActive = true
            iNoRushTimer = tonumber(ScenarioInfo.Options.NoRushOption) * 60
            ForkThread(NoRushMonitor)
            if bDebugMessages == true then LOG(sFunctionRef..': First time have run this so ahve set bNoRushActive='..tostring(bNoRushActive)..' and started iNoRushTimer for '..iNoRushTimer..' to change norush back to false') end
        end
        --Setup details of norush range for each M28AI
        if bNoRushActive then
            local tMapInfo = ScenarioInfo
            aiBrain[reftNoRushCentre] = {M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()][1], 0, M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()][3]}
            local sXRef = 'norushoffsetX_ARMY_'..aiBrain:GetArmyIndex()
            local sZRef = 'norushoffsetY_ARMY_'..aiBrain:GetArmyIndex()
            if bDebugMessages == true then LOG(sFunctionRef..': Checking norush adjustments, sXRef='..sXRef..'; sZRef='..sZRef..'; MapInfoX='..(tMapInfo[sXRef] or 'nil')..'; MapInfoZ='..(tMapInfo[sZRef] or 'nil')..'; aiBrain[reftNoRushCentre] before adjustment='..repru(aiBrain[reftNoRushCentre])) end
            if tMapInfo[sXRef] then aiBrain[reftNoRushCentre][1] = aiBrain[reftNoRushCentre][1] + (tMapInfo[sXRef] or 0) end
            if tMapInfo[sZRef] then aiBrain[reftNoRushCentre][3] = aiBrain[reftNoRushCentre][3] + (tMapInfo[sZRef] or 0) end
            aiBrain[reftNoRushCentre][2] = GetTerrainHeight(aiBrain[reftNoRushCentre][1], aiBrain[reftNoRushCentre][3])
            iNoRushRange = tMapInfo.norushradius
            table.insert(reftNoRushM28StartPoints, aiBrain[reftNoRushCentre])
            if bDebugMessages == true then
                LOG(sFunctionRef..': Have recorded key norush details for the ai with index='..aiBrain:GetArmyIndex()..'; iNoRushRange='..iNoRushRange..'; aiBrain[reftNoRushCentre]='..repru(aiBrain[reftNoRushCentre])..'; will draw a circle now in white around the area')
                M28Utilities.DrawCircleAtTarget(aiBrain[reftNoRushCentre], 7, 500, iNoRushRange)
            end

        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': No rush isnt active') end
        bNoRushActive = false --(redundancy)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function NoRushMonitor()
    local sFunctionRef = 'NoRushMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitSeconds(iNoRushTimer)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    bNoRushActive = false
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function TestCustom(aiBrain)
    while true do
        local tLABs = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryAttackBot * categories.TECH1, false, true)
        LOG('Is table of tLABs empty='..tostring(M28Utilities.IsTableEmpty(tLABs)))
        if M28Utilities.IsTableEmpty(tLABs) == false then
            local iRandom = math.random(0,1)
            iRandom = iRandom * 2 - 1
            for iUnit, oUnit in tLABs do
                if not(oUnit:IsUnitState('Moving')) and oUnit[M28UnitInfo.refbLowerPriorityMicroActive] then
                    M28Orders.IssueTrackedMove(oUnit, {oUnit:GetPosition()[1] + 10 * iRandom, oUnit:GetPosition()[2], oUnit:GetPosition()[3] + 10 * iRandom}, 0, false, 'TestMv', true)
                end
                --M28Micro.MoveInCircleTemporarily(oUnit, 10, false, true, nil, nil)
                M28Micro.TrackTemporaryUnitMicro(oUnit, 1, nil, true)
            end
        end
        WaitSeconds(0.5)
    end
    --M28Profiler.CompareDifferentThreatCalculations(aiBrain)


    --M28Profiler.SpawnSetUnitsForBrain(aiBrain)
    --[[local iXAdjust = -8
    local iZAdjust = -8
    for iMex, tMex in M28Map.tMassPoints do
        LOG(sFunctionRef..': for iMex='..iMex..'; can we build novax with a '..iXAdjust..','..iZAdjust..' offset='..tostring(aiBrain:CanBuildStructureAt('xeb2402', {tMex[1]+iXAdjust,GetSurfaceHeight(tMex[1]+iXAdjust,tMex[3]+iZAdjust),tMex[3]+iZAdjust}))..'; Can we build a mai template='..tostring(aiBrain:CanBuildStructureAt('mai2820', {tMex[1]+iXAdjust,GetSurfaceHeight(tMex[1]+iXAdjust,tMex[3]+iZAdjust),tMex[3]+iZAdjust}))..'; Result for size 26 blueprint='..tostring(aiBrain:CanBuildStructureAt('mai2826', {tMex[1]+iXAdjust,GetSurfaceHeight(tMex[1]+iXAdjust,tMex[3]+iZAdjust),tMex[3]+iZAdjust})))
    end--]]

    --brian size profiling:
    --[[
    for iBrain, oBrain in ArmyBrains do
        oBrain.TestCount = (oBrain.TestCount or 59) + 1
        if oBrain.TestCount >= 5 then

            local Utils = import('/lua/system/utils.lua')
            LOG('Size of brain '..oBrain.Nickname..' at time='..GetGameTimeSeconds()..'='..Utils.ToBytes(oBrain))
            LOG('reprs of brain='..reprs(oBrain))
            for iTable, tTable in oBrain do
                LOG('size of table '..iTable..'='..Utils.ToBytes(tTable))
            end
            oBrain.TestCount = 0
        end
    end--]]
    --local tsLotsOfStrings = {}
    --[[for iCurEntry = 1, 100 do
        tsLotsOfStrings[iCurEntry] = {}
        for iNextEntry = 1, 1000 do
            tsLotsOfStrings[iCurEntry][iNextEntry] = 'Test of string 1'..'Test of string 2'..'Test of string 3'
        end
    end--]]
    --local NavUtils = M28Utilities.NavUtils
    --local tFullPath, iPathSize, iLandTravelDistance = NavUtils.PathTo('Land', {43, 28, 430},{188, 22, 268.5}, nil)
    --LOG(sFunctionRef..': iLandTravelDistance='..iLandTravelDistance)
    --LOG(sFunctionRef..': All reclaim segments assigned to P64Z2='..repru(M28Map.tAllPlateaus[64][M28Map.subrefPlateauLandZones][2][M28Map.subrefReclaimSegments]))
    --M28Map.DrawLandZones()
    --M28Utilities.IsLineFromAToBInRangeOfCircleAtC(480.91683959961, 347.65859985352, 826.56427001953, 41.712692260742, 213.6215057373, 91)
    --M28Profiler.IncreaseMemoryUsage(150000) --Can be used to test if high memory usage is likely to lead to a crash
    --M28Map.DrawSpecificLandZone(64, 2, 4)
    --ScenarioInfo.Options
    --LOG('scenario info.options='..reprs(ScenarioInfo.Options))

    --Rerun adj zones so can see what is happening
    --M28Map.RecordWaterZoneAdjacentLandZones()

    --Spawn in a novax for testing:
    --[[local oACU = aiBrain:GetListOfUnits(categories.COMMAND)[1]
    local tPos = oACU:GetPosition()
    tPos[1] = tPos[1] + 10
    tPos[3] = tPos[3] + 10
    CreateUnit('xeb2402', oACU.Army, tPos[1], tPos[2], tPos[3], 0, 0, 0, 0, 'Air')--]]
    --LOG('Is novax restricted='..tostring(import("/lua/game.lua").IsRestricted('xeb2402', aiBrain:GetArmyIndex())))

    --M28Map.DrawLandZonePath(88, 21, 34)


    --M28Map.DrawSpecificLandZone(89, 28, 4)
    --[[
    M28Map.DrawSpecificLandZone(88, 34, 5)--]]
    --local tCivilianMexes = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMex, M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()], 10000, 'Neutral')
    --LOG(sFunctionRef..': is table of civilian mexes empty at time '..GetGameTimeSeconds()..'='..tostring(M28Utilities.IsTableEmpty(tCivilianMexes)))
    --[[local iCurColour = 0
    for iLandZone, tLZData in M28Map.tAllPlateaus[88][M28Map.subrefPlateauLandZones] do
        iCurColour = iCurColour + 1
        if iCurColour >= 9 then iCurColour = 1 end
        M28Map.DrawSpecificLandZone(88, iLandZone)
    end--]]

    --New water zone logic testing
    --local tWZData = M28Map.tPondDetails[51][M28Map.subrefPondWaterZones][269]
    --LOG('Repru of WZData other pathing='..reprs(tWZData[M28Map.subrefWZOtherWaterZones]))

    --Setons hover label testing
    --[[local NavUtils = M28Utilities.NavUtils
    local tLocations = {{667.5, 20.4453125, 244.5 },{709.44091796875, 36.008731842041, 215.21347045898},{668.9853515625, 33.445762634277, 243.86209106445}}
    for iLocation, tLocation in tLocations do
        M28Utilities.DrawLocation(tLocation, iLocation)
        LOG(sFunctionRef..': Hover label for position '..iLocation..'='..(NavUtils.GetLabel(M28Map.refPathingTypeHover, tLocation) or 'nil')..'; Terrain label='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, tLocation) or 'nil'))
    end--]]


    --[[local ScenarioFramework = import('/lua/ScenarioFramework.lua')
    local tLZData = M28Map.tAllPlateaus[25][M28Map.subrefPlateauLandZones][4]
    local rRect = M28Utilities.GetRectAroundLocation({512,0,512}, 512)--]]
    --ScenarioFramework.SetPlayableArea(rRect)
    --M28Map.DrawSpecificLandZone(2, 1, 4)
    --M28Map.DrawWaterZones()
    --[[if GetGameTimeSeconds() <= 20 then M28Map.DrawSpecificWaterZone(5)
    else M28Map.DrawSpecificWaterZone(7)
    end--]]
    --AIx 10.0
    --ScenarioInfo.Options.CheatMult = tostring(10.0)
    --ScenarioInfo.Options.BuildMult = tostring(10.0)

    --Four corners - draw buildable locations in bottom-right with plateau 7 LZ2
    --Island zero - P218 LZ1
    --Twin rivers - bottomright core base: P117LZ3
    --[[while true do
        WaitSeconds(20)
        local iTeam = aiBrain.M28Team
        if GetGameTimeSeconds() >= 240 then
            local tLZData = M28Map.tAllPlateaus[218][M28Map.subrefPlateauLandZones][3]
            M28Engineer.DrawBuildableLocations(tLZData, 1)
            LOG(sFunctionRef..': about to do repru of segmentcount by size='..repru(tLZData[M28Map.subrefBuildLocationSegmentCountBySize]))
        end
    end--]]

    --Hook assist order
    --[[local M28OldIssueGuard = _G.IssueGuard
    _G.IssueGuard = function(units, target)
        LOG('IssueGuard hook - will give trail if hooked factory')
        for iUnit, oUnit in units do
            if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oUnit.UnitId) then M28Utilities.ErrorHandler('Audit trail', true, true) end
        end
        M28OldIssueGuard(units, target)
    end,
    LOG('Have attempted to hook issueguard')
    local M28OldIssueFactoryAssist = _G.IssueFactoryAssist
    _G.IssueFactoryAssist = function(units, target)
        LOG('IssueFactoryAssist hook - will give trail if hooked factory')
        for iUnit, oUnit in units do
            if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oUnit.UnitId) then
                if oUnit:GetAIBrain().M28AI then
                    M28Utilities.ErrorHandler('Audit trail', true, true)
                end
            end
        end
        M28OldIssueFactoryAssist(units, target)
    end,--]]



    --Scenario data
    --WaitSeconds(10)
    --LOG('WIll do reprs of ScenarioFramework')
    --LOG('reprs='..reprs(ScenarioFramework))


    --[[LOG('WIll do reprs of just options'..reprs(ScenarioInfo.Options))
    LOG('Will now try cycling through each entry in ScenarioInfo and note the iEntry value')
    for iEntry, vValue in ScenarioInfo do
        LOG('iEntry='..iEntry)
    end--]]

    --local tWZTeamData = M28Map.tPondDetails[552][M28Map.subrefPondWaterZones][25][M28Map.subrefWZTeamData][aiBrain.M28Team]
    --LOG('WZ25 pond 552 closest friendly base='..repru(tWZTeamData[M28Map.reftClosestFriendlyBase]))
    --WaitSeconds(5)
    --M28Air.CalculateAirTravelPath(0, 18, 0, 22)
    --[[M28Utilities.DrawLocation({10,GetTerrainHeight(10,10),10}, 3)
    M28Utilities.DrawLocation({12,GetTerrainHeight(12,12),10}, 4)
    M28Utilities.DrawLocation({14,GetTerrainHeight(14,14),14}, 5)--]]


    --Destroy a T3 fixed shield to see if we rebuild it
    --[[if GetGameTimeSeconds() >= 1200 and GetGameTimeSeconds() <= 1201 then
        local tFixedShields = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryFixedShield)
        if M28Utilities.IsTableEmpty(tFixedShields) == false then
            for iUnit, oUnit in tFixedShields do
                oUnit:Kill()
                break
            end
        end
    end--]]

    --Detail rally point info for a land zone - Forbidden pass - do we detect that the ridge is pathable?
    --[[local NavUtils = M28Utilities.NavUtils
    local tPosition = { 260.06228637695, 67.514915466309, 148.83508300781 }
    M28Utilities.DrawLocation(tPosition)
    LOG('NavUtils for tPosition='..(NavUtils.GetLabel('Land', tPosition) or 'nil'))--]]

    --[[local tLZData = M28Map.tAllPlateaus[27][M28Map.subrefPlateauLandZones][20]
    local tStartMidpoint = tLZData[M28Map.subrefMidpoint]
    local tRallyPoint = M28Land.GetNearestLandRallyPoint(tLZData, 1, 27, 20, 3)--]]
    --LOG('tStartMidpoint='..repru(tStartMidpoint)..'; tRallyPoint='..repru(tRallyPoint)..'; Path from LZ20 to LZ5='..repru(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][5]]))

    --Draw specific land zones
    --M28Map.DrawSpecificLandZone(27, 33, 2)
    --M28Map.DrawSpecificLandZone(27, 34, 1)

    --Test alternative to table.remove for sequentially indexed numerical keys
    --[[local tTestArray = {[1] = 'Test1', [2] = 'Test2', [3] = 'Test3', [4] = 'Test4'}
    local function WantToKeep(tArray, i, j)
        if tArray[i] == 'Test2' then return false else return true end
    end
    M28Utilities.RemoveEntriesFromArrayBasedOnCondition(tTestArray, WantToKeep)
    LOG('Finished updating array, tTestArray='..repru(tTestArray))--]]


    --Check for sparky and how many orders it has
    --[[local tOurSparkies = aiBrain:GetListOfUnits(categories.FIELDENGINEER, false, true)
    if M28Utilities.IsTableEmpty(tOurSparkies) == false then
        for iUnit, oUnit in tOurSparkies do
            local tQueue = oUnit:GetCommandQueue()
            LOG('Considering sparky '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..': About to list out command queue details. Is queue empty='..tostring(M28Utilities.IsTableEmpty(tQueue)))

            if M28Utilities.IsTableEmpty(tQueue) == false then
                LOG('Total commands='..table.getn(tQueue))
                for iCommand, tOrder in ipairs(tQueue) do
                    LOG('iCommand='..iCommand..'; tOrder='..repru(tOrder)..'; position='..repru(tOrder.position)..'; Type='..repru(tOrder.type))
                end
            end
        end
    end--]]

    M28Utilities.ErrorHandler('Disable testcustom code for final')
end

function UpdateMaxUnitCapForRelevantBrains()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateMaxUnitCapForRelevantBrains'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    for iBrain, oBrain in tAllAIBrainsByArmyIndex do
        if not(M28Map.bIsCampaignMap) or not(oBrain.BrainType == 'AI') or oBrain.M28AI or oBrain.M27AI then
            if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; About to update max unit cap for brian '..oBrain.Nickname..'; Brain type='..(oBrain.BrainType or 'nil')) end
            RefreshMaxUnitCap(oBrain)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshMaxUnitCap(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshUnitCap'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; About to set max unit cap for brain '..aiBrain.Nickname..'; Unit cap per scenarioInfo='..(ScenarioInfo.Options.UnitCap or 'nil')..'; Unit cap before update='..aiBrain:GetArmyStat("UnitCap_MaxCap", 0).Value) end
    if ScenarioInfo.Options.UnitCap then
        local iUnitCap = tonumber(ScenarioInfo.Options.UnitCap)
        local iIndex = aiBrain:GetArmyIndex()
        --SetIgnoreArmyUnitCap(iIndex, true) --Use this and below commented line to ignore unit cap altogther I think based on usage in base FAF code
        --aiBrain.IgnoreArmyCaps = true
        SetArmyUnitCap(iIndex, iUnitCap)
        if bDebugMessages == true then LOG(sFunctionRef..': Brian unit cap after update='..aiBrain:GetArmyStat("UnitCap_MaxCap", 0).Value) end
    else
        M28Utilities.ErrorHandler('No unit cap specified', true)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function Initialisation(aiBrain)
    --Called after 1 tick has passed so all aibrains should hopefully exist now
    --v24 - delay as want to wait until onbeginsession has started for navmesh to generate properly
    local sFunctionRef = 'Initialisation'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    while not(bBeginSessionTriggered) and GetGameTimeSeconds() <= 4 do
        WaitTicks(1)
    end
    WaitTicks(1) --make sure brain setup will have run
    aiBrain[refbInitialised] = true
    if bDebugMessages == true then LOG('About to proceed with initialisation, aiBrain='..aiBrain.Nickname..'; bBeginSessionTriggered='..tostring(bBeginSessionTriggered or false)) end
    ForkThread(SetupNoRushDetails, aiBrain)
    ForkThread(M28UnitInfo.CalculateBlueprintThreatsByType) --Records air and ground threat values for every blueprint
    ForkThread(M28Team.RecordAllPlayers)
    local iWaitCount = 0
    while not(aiBrain.M28Team) do
        if bDebugMessages == true then LOG(sFunctionRef..': Dont have a team assigned yet so will wait 1 tick') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        iWaitCount = iWaitCount + 1
        if iWaitCount >= 10 then
            M28Utilities.ErrorHandler('Dont have a team assigned for brain '..aiBrain.Nickname..'; will create a new team for it as a redundancy')
            M28Team.CreateNewTeam(aiBrain)
        end
    end
    ForkThread(M28Map.CheckIfLowMexMap)
    ForkThread(M28Economy.EconomyInitialisation, aiBrain)
    ForkThread(M28Engineer.EngineerInitialisation, aiBrain)
    ForkThread(M28ACU.ManageACU, aiBrain)
    ForkThread(M28Factory.SetPreferredUnitsByCategory, aiBrain)
    ForkThread(M28Factory.IdleFactoryMonitor, aiBrain)
    ForkThread(M28Map.RecordPondToExpandTo, aiBrain)
    --ForkThread(RevealCiviliansToAI, aiBrain)
    ForkThread(RevealCivilainsToAIByGivingVision, aiBrain)
    ForkThread(RefreshMaxUnitCap, aiBrain) --This logic is  called from a number of palces to try and ensure it overrides things that might be set elsewhere
    ForkThread(DelayedCheckOfUnitsAtStartOfGame)
    ForkThread(DecideOnGeneralMapStrategy, aiBrain)
    ForkThread(M28Chat.ConsiderPerTeamStartMessage, aiBrain)
    if bDebugMessages == true then LOG(sFunctionRef..': Finished initialisation') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderUpdatingBrainUnitCount(aiBrain)
    if GetGameTimeSeconds() - (aiBrain[refiTimeLastUpdatedUnitCount] or 0) >= 30 then
        aiBrain[refiTimeLastUpdatedUnitCount] = GetGameTimeSeconds()
        aiBrain[refiRoughUnitCount] = aiBrain:GetCurrentUnits(categories.ALLUNITS - M28UnitInfo.refCategoryWall) + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryWall) * 0.25
    end
end

function CheckUnitCap(aiBrain)
    local sFunctionRef = 'CheckUnitCap'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if GetGameTimeSeconds() - (aiBrain[refiLastUnitCapTimeCheck] or -1) >= 0.5 then
        aiBrain[refiLastUnitCapTimeCheck] = GetGameTimeSeconds()
        --local iUnitCap = tonumber(ScenarioInfo.Options.UnitCap)
        --Use below method in case a mod has changed this
        local oArmy = aiBrain:GetArmyIndex()
        local iUnitCap = GetArmyUnitCap(oArmy)
        --local armies = ListArmies()
        --for i, army in armies do
        --end
        local iCurUnits = aiBrain:GetCurrentUnits(categories.ALLUNITS - M28UnitInfo.refCategoryWall) + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryWall) * 0.25
        aiBrain[refiRoughUnitCount] = iCurUnits
        aiBrain[refiTimeLastUpdatedUnitCount] = GetGameTimeSeconds()
        local iCurFactories = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory)
        local iThreshold = math.min(30, math.max(math.ceil(iUnitCap * 0.02), 10, iCurFactories * 0.5))
        local iCurUnitsDestroyed = 0
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; iCurUnits='..iCurUnits..'; iUnitCap='..iUnitCap..'; iThreshold='..iThreshold) end
        if iCurUnits > (iUnitCap - iThreshold * 5) then
            aiBrain[refbCloseToUnitCap] = true
            M28Team.tTeamData[aiBrain.M28Team][M28Team.refiTimeLastNearUnitCap] = GetGameTimeSeconds()
            local iMaxToDestroy = math.max(5, math.ceil(iUnitCap * 0.01), math.max(20, iCurFactories) - (iUnitCap - iCurUnits))
            if iUnitCap - iCurUnits < 10 then iMaxToDestroy = math.max(10, iMaxToDestroy) end
            local bReconsiderShortly = false
            if iMaxToDestroy > 10 then
                iMaxToDestroy = 10
                bReconsiderShortly = true
            end
            local tUnitsToDestroy
            local tiCategoryToDestroy = {
                [-1] = M28UnitInfo.refCategoryMobileLand + categories.NAVAL * categories.MOBILE - categories.EXPERIMENTAL - categories.COMMAND - categories.SUBCOMMANDER,
                [0] = categories.TECH1 - categories.COMMAND - M28UnitInfo.refCategoryAirStaging - M28UnitInfo.refCategoryT1Mex + M28UnitInfo.refCategoryAllAir * categories.TECH2 - M28UnitInfo.refCategoryTransport * categories.TECH2 - M28UnitInfo.refCategoryTorpBomber * categories.TECH2 -M28UnitInfo.refCategoryAllHQFactories + categories.TECH2 * M28UnitInfo.refCategoryMobileLandShield - categories.INSIGNIFICANTUNIT,
                [1] = M28UnitInfo.refCategoryAllAir * categories.TECH1 + categories.NAVAL * categories.MOBILE * categories.TECH1 - categories.INSIGNIFICANTUNIT,
                [2] = M28UnitInfo.refCategoryMobileLand * categories.TECH2 - categories.COMMAND - M28UnitInfo.refCategoryMobileLandShield - M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryAirScout * categories.TECH1 + M28UnitInfo.refCategoryAirAA * categories.TECH1 - categories.INSIGNIFICANTUNIT,
                [3] = M28UnitInfo.refCategoryMobileLand * categories.TECH1 - categories.COMMAND - categories.INSIGNIFICANTUNIT,
                [4] = M28UnitInfo.refCategoryWall + M28UnitInfo.refCategoryEngineer - categories.TECH3 + M28UnitInfo.refCategoryMobileLand * categories.TECH1 - categories.COMMAND - M28UnitInfo.refCategoryLandScout - categories.INSIGNIFICANTUNIT,
            }
            --Adjust these categories for special cases
            if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyLandFactoryTech] == 1 and (M28Map.bIsCampaignMap or bUnitRestrictionsArePresent) then
                --exclude T1 land from category 4
                tiCategoryToDestroy[4] =  M28UnitInfo.refCategoryWall + M28UnitInfo.refCategoryEngineer - categories.TECH3 - categories.INSIGNIFICANTUNIT
            end
            if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyFactoryTech] < 3 or ((M28Map.bIsCampaignMap or bUnitRestrictionsArePresent) and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * categories.TECH3) == 0) then
                if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyFactoryTech] == 1 then
                    tiCategoryToDestroy[4] = tiCategoryToDestroy[4] - M28UnitInfo.refCategoryEngineer
                else
                    tiCategoryToDestroy[4] = tiCategoryToDestroy[4] - M28UnitInfo.refCategoryEngineer * categories.TECH2
                end
            end
            if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyLandFactoryTech] == 2 and (M28Map.bIsCampaignMap or bUnitRestrictionsArePresent) and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] then
                --Exclude MML from category 2
                tiCategoryToDestroy[2] = M28UnitInfo.refCategoryMobileLand * categories.TECH2 - categories.COMMAND - M28UnitInfo.refCategoryMAA -M28UnitInfo.refCategoryMML + M28UnitInfo.refCategoryAirScout + M28UnitInfo.refCategoryAirAA * categories.TECH1 - categories.INSIGNIFICANTUNIT
            end
            --If have no T2+ power, then dont include T1 power in units to ctrlK
            if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower - categories.TECH1) == 0 then
                tiCategoryToDestroy[3] = tiCategoryToDestroy[3] - M28UnitInfo.refCategoryPower
            end

            --If have no asfs then exclude inties from cat 2
            if bDebugMessages == true then LOG(sFunctionRef..': Cur T2+ power='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower - categories.TECH1)..'; Cur ASFs='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirAA * categories.TECH3)) end
            if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirAA * categories.TECH3) == 0 then
                tiCategoryToDestroy[2] = tiCategoryToDestroy[2] - M28UnitInfo.refCategoryAirAA
                tiCategoryToDestroy[1] = tiCategoryToDestroy[1] - M28UnitInfo.refCategoryAirAA
                if bDebugMessages == true then LOG(sFunctionRef..': Excluding inties from being ctrlkd from category 1 and 2') end
                if iUnitCap >= 500 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirAA) <= 50 then
                    tiCategoryToDestroy[0] = tiCategoryToDestroy[1] - M28UnitInfo.refCategoryAirAA
                end
            end

            --If exp count is 0 then remove cat -1
            if M28Team.tTeamData[aiBrain.M28Team][M28Team.refiConstructedExperimentalCount] == 0 then
            else
                --If we have <35 T3 engis then exclude engineers from cat -1
                if (M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] or 1) <= 0 then
                    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer) < 35 then
                        tiCategoryToDestroy[-1] = tiCategoryToDestroy[-1] - M28UnitInfo.refCategoryEngineer * categories.TECH3
                    end
                end
            end


            if M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] <= 2 then
                --If have no t3 gunships then keep t2 in cat 0
                if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryGunship * categories.TECH3) == 0 then
                    tiCategoryToDestroy[0] = tiCategoryToDestroy[0] - M28UnitInfo.refCategoryGunship
                end
                --Dont exclude T2 tanks if we have no t3 tanks
                if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMobileLand * categories.TECH3) == 0 then
                    tiCategoryToDestroy[2] = M28UnitInfo.refCategoryMobileLand * categories.TECH1 - categories.COMMAND
                    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryGunship) > 0 then
                        tiCategoryToDestroy[2] = M28UnitInfo.refCategoryMobileLand * categories.TECH1 - categories.COMMAND + M28UnitInfo.refCategoryBomber * categories.TECH1
                    end
                else
                    --exclude t2 maa if we have t3 maa
                    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) > 0 then
                        tiCategoryToDestroy[0] = tiCategoryToDestroy[0] + M28UnitInfo.refCategoryMAA * categories.TECH2
                    end
                end
            end

            --Restrict T3 land combat units being built if we have experimental level units and are at the lowest level of unit cap
            if M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] <= 0 and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryExperimentalLevel) > 0 and aiBrain:GetCurrentUnits(tiCategoryToDestroy[0]) <= 10 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandCombat * categories.TECH3 - categories.SUBCOMMANDER) >= 20 then
                tiCategoryToDestroy[0] = tiCategoryToDestroy[0] + M28UnitInfo.refCategoryLandCombat * categories.TECH3 - categories.SUBCOMMANDER
            end



            if bDebugMessages == true then LOG(sFunctionRef..': We are over the threshold for ctrlking units') end
            if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer) > math.max(30, iUnitCap * 0.35) then tiCategoryToDestroy[0] = tiCategoryToDestroy[0] + M28UnitInfo.refCategoryEngineer end
            local iCumulativeCategory = tiCategoryToDestroy[4]
            local bKilledUnit = false
            for iAdjustmentLevel = 4, -1, -1 do
                if iAdjustmentLevel < 4 then
                    iCumulativeCategory = iCumulativeCategory + tiCategoryToDestroy[iAdjustmentLevel]
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iCurUnitsDestroyed so far='..iCurUnitsDestroyed..'; iMaxToDestroy='..iMaxToDestroy..'; iAdjustmentLevel='..iAdjustmentLevel..'; iCurUnits='..iCurUnits..'; Unit cap='..iUnitCap..'; iThreshold='..iThreshold) end
                if tiCategoryToDestroy[iAdjustmentLevel] then
                    if iCurUnits > (iUnitCap - iThreshold * iAdjustmentLevel) or iCurUnitsDestroyed == 0 then
                        tUnitsToDestroy = aiBrain:GetListOfUnits(tiCategoryToDestroy[iAdjustmentLevel], false, false)
                        if M28Utilities.IsTableEmpty(tUnitsToDestroy) == false then
                            M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] = math.min((M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] or 100), iAdjustmentLevel)
                            local bKillUnit
                            for iUnit, oUnit in tUnitsToDestroy do
                                if oUnit.Kill and (not(oUnit[M28UnitInfo.refbCampaignTriggerAdded]) or not(M28Map.bIsCampaignMap)) and not(oUnit.Parent) then
                                    --Dont kill an engineer that is building, reclaiming, repairing or capturing (unless it is building/repairing and not ap rimary engineer
                                    bKillUnit = true
                                    if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                                        if  oUnit:IsUnitState('Reclaiming') or oUnit:IsUnitState('Capturing') then
                                            bKillUnit = false
                                        elseif oUnit[M28Engineer.refbPrimaryBuilder] and (oUnit:IsUnitState('Building') or oUnit:IsUnitState('Repairing')) then
                                            bKillUnit = false
                                        end
                                    end
                                    if bKillUnit then
                                        if bDebugMessages == true then LOG(sFunctionRef..': iCurUnitsDestroyed so far='..iCurUnitsDestroyed..'; Will destroy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to avoid going over unit cap'..'; Have we already tried to kill this unit? oUnit[M28UnitInfo.refbTriedToKill]='..tostring(oUnit[M28UnitInfo.refbTriedToKill] or false)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                                        if not(oUnit[M28UnitInfo.refbTriedToKill]) then
                                            if EntityCategoryContains(M28UnitInfo.refCategoryWall, oUnit.UnitId) then
                                                iCurUnitsDestroyed = iCurUnitsDestroyed + 0.25
                                            else
                                                iCurUnitsDestroyed = iCurUnitsDestroyed + 1
                                            end
                                        end
                                        M28Orders.IssueTrackedKillUnit(oUnit)
                                        bKilledUnit = true

                                        if iCurUnitsDestroyed >= iMaxToDestroy then
                                            if iAdjustmentLevel <= 3 and not(M28Map.bIsCampaignMap) then
                                                M28Chat.SendUnitCapMessage(aiBrain)
                                            end
                                            break
                                        end
                                    end
                                end
                            end
                        end
                        if iCurUnitsDestroyed >= iMaxToDestroy then break end
                    else
                        break
                    end
                end
            end
            if bKilledUnit then aiBrain[refiTimeOfLastUnitCapDeath] = GetGameTimeSeconds() end
            aiBrain[refiUnitCapCategoriesDestroyed] = iCumulativeCategory
            if bDebugMessages == true then LOG(sFunctionRef..': FInished destroying units, iCurUnitsDestroyed='..iCurUnitsDestroyed) end
            if iCurUnitsDestroyed >= iMaxToDestroy and bReconsiderShortly then
                if bDebugMessages == true then LOG(sFunctionRef..': We wanted to destroy more units, so will reassess in 10 seconds') end
                ForkThread(DelayedUnitCapCheck, aiBrain, 10)
            end
        else
            --Only reset cap if we havent reached the higher ctrlk thresholds, unless we have a massive amount of headroom
            if aiBrain[refbCloseToUnitCap] and (iCurUnits < iUnitCap * 0.5 - 25 or (M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] or 100) > 1) then
                --Only reset cap if we have a bit of leeway
                if iCurUnits < (iUnitCap - iThreshold * 5) - 20 then
                    aiBrain[refbCloseToUnitCap] = false
                end
            end
        end
        aiBrain[refiExpectedRemainingCap] = iUnitCap - iCurUnits + iCurUnitsDestroyed
        if aiBrain[refbCloseToUnitCap] and aiBrain[refiExpectedRemainingCap] <= 25 then
            --Recheck in 30s
            ForkThread(DelayedUnitCapCheck, aiBrain)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': End of code, expected remaining cap='..aiBrain[refiExpectedRemainingCap]) end
    else
        ForkThread(DelayedUnitCapCheck, aiBrain)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedUnitCapCheck(aiBrain, iOptionalSecondsToWait)
    if not(aiBrain[refbWillDoDelayedUnitCapCheck]) then
        aiBrain[refbWillDoDelayedUnitCapCheck] = true
        WaitSeconds(iOptionalSecondsToWait or 30)
        aiBrain[refbWillDoDelayedUnitCapCheck] = false
        CheckUnitCap(aiBrain)
    end
end

function ResetCivilianAllianceForBrain(iOurIndex, iCivilianIndex, sRealState, oCivilianBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ResetCivilianAllianceForBrain'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Call via forkthread
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Time='..GetGameTimeSeconds()..'; iOurIndex='..iOurIndex..'; iCivilianIndex='..iCivilianIndex..'; Is ally='..tostring(IsAlly(iOurIndex, iCivilianIndex))..'; IsEnemy='..tostring(IsEnemy(iOurIndex, iCivilianIndex))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(11)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting for some ticks, iOurIndex='..iOurIndex..'; iCivilianIndex='..iCivilianIndex..'; Is ally='..tostring(IsAlly(iOurIndex, iCivilianIndex))..'; IsEnemy='..tostring(IsEnemy(iOurIndex, iCivilianIndex))) end
    SetAlliance(iOurIndex, iCivilianIndex, sRealState)
    oCivilianBrain[refiTemporarilySetAsAllyForTeam] = nil
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bDebugMessages == true then LOG(sFunctionRef..': Have now set alliance back to real state, Time='..GetGameTimeSeconds()..' Have just set civilian brain '..oCivilianBrain.Nickname..' back to being '..sRealState..' for iOurIndex='..iOurIndex) end
end

function RevealCiviliansToAI(aiBrain)
    --On some maps like burial mounds civilians are revealed to human players but not AI; meanwhile on other maps even if theyre not revealed to humans, the humans will likely know where the buildings are having played the map before
    --Thanks to Relent0r for providing code that I used as a starting point to achieve this

    --SUPERCEDED BY RevealCivilainsToAIByGivingVision
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RevealCiviliansToAI'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    M28Utilities.ErrorHandler('Deprecated function')
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(75) --Waiting only 5 ticks or less resulted in a strange bug where on one map when ahd 2 ACUs on the same team, the code would run for both of htem as expected, but the civilians would only be visible for one of the AI (as though making the civilian an ally had no effect for hte other); This went away when put a delay of 50 ticks; however have compatibility issues with RNG so want to wait a bit longer; waiting 60 meant it worked for M27 but didnt look like it worked for RNG (wiating 50 meant it worked for RNG but not for M27); waiting 70 meant it worked for both; have done 75 for M28 given M27 uses 70
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --if aiBrain:GetArmyIndex() == 3 then
    if bDebugMessages == true then LOG(sFunctionRef..': Have finished waiting, will loop throguh all brians now to look for civilians, aiBrain='..aiBrain.Nickname..' with index ='..aiBrain:GetArmyIndex()..'; M28 team='..(aiBrain.M28Team or 'nil')) end
    local tiCivilianBrains = {}
    local toCivilianBrains = {}
    local iOurIndex = aiBrain:GetArmyIndex()
    local iBrainIndex
    local sRealState
    local iTotalWait = 0

    for i, oBrain in ArmyBrains do
        iBrainIndex = oBrain:GetArmyIndex()
        if bDebugMessages == true then LOG(sFunctionRef..': Considering brain '..(oBrain.Nickname or 'nil')..' with index '..oBrain:GetArmyIndex()..' for aiBrain '..aiBrain.Nickname..'; Is enemy='..tostring(IsEnemy(iOurIndex, iBrainIndex))..'; ArmyIsCivilian(iBrainIndex)='..tostring(ArmyIsCivilian(iBrainIndex))..'; oBrain[refiTemporarilySetAsAllyForTeam]='..(oBrain[refiTemporarilySetAsAllyForTeam] or 'nil')..'; Our team='..aiBrain.M28Team) end
        if ArmyIsCivilian(iBrainIndex) then
            while(oBrain[refiTemporarilySetAsAllyForTeam] and not(oBrain[refiTemporarilySetAsAllyForTeam] == aiBrain.M28Team)) do
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                iTotalWait = iTotalWait + 1
                if iTotalWait >= 12 then
                    break
                end
            end
            if not(oBrain[refiTemporarilySetAsAllyForTeam]) then
                oBrain[refiTemporarilySetAsAllyForTeam] = aiBrain.M28Team
                sRealState = IsAlly(iOurIndex, iBrainIndex) and 'Ally' or IsEnemy(iOurIndex, iBrainIndex) and 'Enemy' or 'Neutral'
                SetAlliance(iOurIndex, iBrainIndex, 'Ally')
                if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Temporarily set the brain as an ally of team '..aiBrain.M28Team..', sRealState='..sRealState) end
                table.insert(tiCivilianBrains, iBrainIndex)
                table.insert(toCivilianBrains, oBrain)
                --Prevent orders being given to these untis by M28
                --[[local tMobileUnits = oBrain:GetListOfUnits(categories.MOBILE, false, true)
                if M28Utilities.IsTableEmpty(tMobileUnits) == false then
                    for iUnit, oUnit in tMobileUnits do
                        M28Micro.TrackTemporaryUnitMicro(oUnit, 30)
                    end
                end--]]
                ForkThread(ResetCivilianAllianceForBrain, iOurIndex, iBrainIndex, sRealState, oBrain)
            elseif oBrain[refiTemporarilySetAsAllyForTeam] == aiBrain.M28Team then
                table.insert(tiCivilianBrains, iBrainIndex)
                table.insert(toCivilianBrains, oBrain)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(8) --When did with just 4 tick delay had issues where getunitsaroundpoint didnt work properly; increasing to 8 tick solved this
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RevealCivilainsToAIByGivingVision(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RevealCivilainsToAIByGivingVision'
    --First wait a couple of seconds to give a chance for units to be created
    if GetGameTimeSeconds() <= 4.4 then
        local iTimeToWait = math.min(3, 4.4 - GetGameTimeSeconds())
        WaitSeconds(iTimeToWait)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': About to reveal civilains and then consider capture targets if this is M28Brain, aiBrain.M28AI='..tostring(aiBrain.M28AI or false)..'; nickname='..(aiBrain.Nickname or 'nil')) end
    if aiBrain.M28AI then --redundancy
        local tACU = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
        for iUnit, oUnit in tACU do
            M28UnitInfo.GiveUnitTemporaryVision(oUnit, 10000)
            break
        end
        --Consider capture targets
        if bDebugMessages == true then LOG(sFunctionRef..': Will now consider capture targets') end
        ForkThread(GetCivilianCaptureTargets, aiBrain)

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetCivilianCaptureTargets(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetCivilianCaptureTargets'

    WaitTicks(2) --tried 1 tick but not working for civilian mexes
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local tStartPoint = M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()]
    local iPlateauWanted, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tStartPoint)
    local iClosestEnemyBase = M28Map.iMapSize
    local iTeam = aiBrain.M28Team

    if iLandZone > 0 then
        local tLZData = M28Map.tAllPlateaus[iPlateauWanted][M28Map.subrefPlateauLandZones][iLandZone]
        local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
        iClosestEnemyBase = M28Utilities.GetDistanceBetweenPositions(tStartPoint, tLZTeamData[M28Map.reftClosestEnemyBase])
    end
    local iSearchRange = math.min(450, math.max(iClosestEnemyBase * 0.6, 200, math.min(275, iClosestEnemyBase * 0.75)))
    local iCategoriesOfInterest = M28UnitInfo.refCategoryLandCombat * categories.RECLAIMABLE - categories.TECH1
    local tUnitsOfInterest = aiBrain:GetUnitsAroundPoint(iCategoriesOfInterest, tStartPoint, iSearchRange, 'Neutral')
    if not(tUnitsOfInterest) then tUnitsOfInterest = {} end
    local tNeutralMexes = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryHydro, tStartPoint, 10000, 'Neutral')
    if M28Utilities.IsTableEmpty(tNeutralMexes) == false then
        for iMex, oMex in tNeutralMexes do
            table.insert(tUnitsOfInterest, oMex)
        end
    end

    local iMaxPowerSearchRange = math.min(250, iClosestEnemyBase * 0.225)
    local tNearbyPower = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryPower, tStartPoint, iMaxPowerSearchRange, 'Neutral')
    if M28Utilities.IsTableEmpty(tNearbyPower) == false then
        for iPower, oPower in tNearbyPower do
            table.insert(tUnitsOfInterest, oPower)
        end
    end

    --local sPathing = M28Map.refPathingTypeAmphibious


    if bDebugMessages == true then LOG(sFunctionRef..': Running for aiBrain='..aiBrain.Nickname..' at gametime='..GetGameTimeSeconds()..'; Is table of tUnitsOfInterest empty='..tostring(M28Utilities.IsTableEmpty(tUnitsOfInterest))..'; iPlateauWanted='..iPlateauWanted..'; iClosestEnemyBase='..iClosestEnemyBase..'; iSearchRange='..iSearchRange..'; Is table of enemy units with further range empty='..tostring(M28Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(iCategoriesOfInterest, tStartPoint, 1000, 'Enemy')))..'; Is tNeutralMexes empty='..tostring(M28Utilities.IsTableEmpty(tNeutralMexes))) end
    if M28Utilities.IsTableEmpty(tUnitsOfInterest) == false then
        local iCurPlateau, iCurLandZone
        for iUnit, oUnit in tUnitsOfInterest do
            if oUnit:GetFractionComplete() >= 1 then
                --Is it in the same plateua?
                iCurPlateau, iCurLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())

                if bDebugMessages == true then LOG(sFunctionRef..': Considering civilian unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurPlateau='..(iCurPlateau or 'nil')..'; iPlateauWanted='..iPlateauWanted..'; Dist to our base='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tStartPoint)..'; Mod dist='..M28Map.GetModDistanceFromStart(aiBrain, oUnit:GetPosition())) end
                if (iCurLandZone or 0) > 0 and iCurPlateau == iPlateauWanted then
                    --Is it one of the civilian brains we temporarily moved to be our ally?
                    if M28Conditions.IsCivilianBrain(oUnit:GetAIBrain()) then
                        local tNearbyThreats = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryPD + M28UnitInfo.refCategoryFixedT2Arti, oUnit:GetPosition(), 140, 'Enemy')
                        if M28Utilities.IsTableEmpty(tNearbyThreats) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to the table of civilians to capture; unit brain='..(oUnit:GetAIBrain().Nickname or 'nil')..'; is civilian='..tostring(M28Conditions.IsCivilianBrain(oUnit:GetAIBrain()))..'; iCurPlateau='..iCurPlateau..'; iCurLandZone='..iCurLandZone) end
                            local tUnitLZData = M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLandZone]
                            if not(tUnitLZData[M28Map.subreftoUnitsToCapture]) then tUnitLZData[M28Map.subreftoUnitsToCapture] = {} end
                            table.insert(tUnitLZData[M28Map.subreftoUnitsToCapture], oUnit)
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function OverseerManager(aiBrain)
    --ForkThread(DebugCheckProfiling, true) --true if want to only give tick count (to help figure out which tick happens just before the issue)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OverseerManager'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --Make sure map setup will be done
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    while not(M28Map.bMapLandSetupComplete) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Waiting for maplandsetup to be done, time='..GetGameTimeSeconds()) end
    end





    --Initialise main systems
    if bDebugMessages == true then LOG(sFunctionRef..': About to cork of initialization') end
    ForkThread(Initialisation, aiBrain)

    --Wait until we can give orders before doing main logic
    while (GetGameTimeSeconds() <= 4.5) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    --ForkThread(TestCustom, aiBrain)

    local M28Config = import('/mods/M28AI/lua/M28Config.lua')
    local bSetHook = false --Used for debugging
    if M28Config.M28RunMemoryProfiling then ForkThread(M28Profiler.ShowFileMemoryUsage) end
    if bDebugMessages == true then LOG(sFunctionRef..': About to run main overseer loop') end
    while not(aiBrain:IsDefeated()) and not(aiBrain.M28IsDefeated) do
        local bEnabledProfiling = false

        --[[if GetGameTimeSeconds() >= 900 and not(bEnabledProfiling) then
             if not(import('/mods/M28AI/lua/M28Config.lua').M28RunProfiling) then
                 ForkThread(M28Profiler.ProfilerActualTimePerTick)
                 import('/mods/M28AI/lua/M28Config.lua').M28RunProfiling = true
             end
             bEnabledProfiling = true
         end--]]

        --if GetGameTimeSeconds() >= 2700 then import('/mods/M28AI/lua/M28Config.lua').M28ShowUnitNames = true end
        --if GetGameTimeSeconds() >= 90 and GetGameTimeSeconds() <= 91 then TestCustom(aiBrain) end
        --Enable below to help figure out infinite loops
        --[[if GetGameTimeSeconds() >= 173 and not(bSetHook) then
            bSetHook = true
            M28Profiler.bFunctionCallDebugOverride = true
            --M28Profiler.bGlobalDebugOverride = true --Only enable this if want more detail as it will make things really slow
            debug.sethook(M28Profiler.OutputRecentFunctionCalls, "c", 200)
            LOG('Have started the main hook of function calls')
        end--]]
        ForkThread(M28Economy.RefreshEconomyData, aiBrain)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckIfScenarioMap()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckIfScenarioMap'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': ScenarioInfo.type == skirmish='..tostring(ScenarioInfo.type == "skirmish")..'; repru of ScenarioInfo.type='..repru(ScenarioInfo.type)..'; Is table of hunman players empty='..tostring(M28Utilities.IsTableEmpty(ScenarioInfo.HumanPlayers))..'; Is human players nil='..tostring(ScenarioInfo.HumanPlayers == nil)) end
    --Thanks to Hdt80bro for highlighting ScenarioInfo.type as a better way of figuring out if this is a campaign map
    if not(ScenarioInfo.type == "skirmish") then --M28Utilities.IsTableEmpty(ScenarioInfo.HumanPlayers) == false then
        M28Map.bIsCampaignMap = true
        --ForkThread(CheckForScenarioObjectives) --superceded by hook of addobjective
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckForAlliedCampaignUnitsToShareAtGameStart(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckForAlliedCampaignUnitsToShareAtGameStart'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iTeam = aiBrain.M28Team
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; M28Team.tTeamData[iTeam][M28Team.refbAlreadyCheckedForUnitsToShare]='..tostring(M28Team.tTeamData[iTeam][M28Team.refbAlreadyCheckedForUnitsToShare] or false)) end
    if not(M28Team.tTeamData[iTeam][M28Team.refbAlreadyCheckedForUnitsToShare]) then
        M28Team.tTeamData[iTeam][M28Team.refbAlreadyCheckedForUnitsToShare] = true
        local tStartPosition = M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()]
        local tNearbyStructures = {}
        local iWaitCount = 0
        local tHumanBrains = {}
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
            if bDebugMessages == true then LOG(sFunctionRef..': Creating list of human brains, oBrain.Nickanme='..oBrain.Nickname..'; brain type='..oBrain.BrainType) end
            if oBrain.BrainType == 'Human' then
                table.insert(tHumanBrains, oBrain)
            end
        end
        local iCategoriesOfInterest = M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryAllAir + M28UnitInfo.refCategoryAllNavy + M28UnitInfo.refCategoryEngineer - categories.COMMAND - M28UnitInfo.refCategoryMassStorage
        if M28Utilities.IsTableEmpty(tHumanBrains) == false then
            while M28Utilities.IsTableEmpty(tNearbyStructures) do
                if iWaitCount > 0 then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(1)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                end
                iWaitCount = iWaitCount + 1
                if GetGameTimeSeconds() >= 120 and (not(ScenarioInfo.OpEnded) or GetGameTimeSeconds() >= 240) then break end
                for iBrain, oBrain in tHumanBrains do
                    local tPotentialStructures = oBrain:GetListOfUnits(iCategoriesOfInterest, false, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Is table of potential units empty for brain '..oBrain.Nickname..'='..tostring(M28Utilities.IsTableEmpty(tPotentialStructures))) end
                    if M28Utilities.IsTableEmpty(tPotentialStructures) == false then
                        for iUnit, oUnit in tPotentialStructures do
                            table.insert(tNearbyStructures, oUnit)
                        end
                    end
                end
                --tNearbyStructures = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure, tStartPosition, 1000, 'Ally')
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': FInished wait for checking for ally structures to share, Time='..GetGameTimeSeconds()..'; Is tNearbyStructures empty='..tostring(M28Utilities.IsTableEmpty(tNearbyStructures))) end
        if M28Utilities.IsTableEmpty(tNearbyStructures) == false then
            --local tUnitsOfCategoryWanted = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryAllAir + M28UnitInfo.refCategoryAllNavy - categories.COMMAND, tStartPosition, 1000, 'Ally')
            local tUnitsOfCategoryWanted = tNearbyStructures
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of units of category wanted empty='..tostring(M28Utilities.IsTableEmpty(tUnitsOfCategoryWanted))) end
            if M28Utilities.IsTableEmpty(tUnitsOfCategoryWanted) == false then
                local tUnitsToShareByBlueprint = {}
                for iUnit, oUnit in  tUnitsOfCategoryWanted do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to add unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of units to share, Is uint valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Fraction complete='..oUnit:GetFractionComplete()..'; Unit brain nickname='..oUnit:GetAIBrain().Nickname..'; Unit brain type='..oUnit:GetAIBrain().BrainType) end
                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 and oUnit:GetAIBrain().BrainType == "Human" then
                        if not(tUnitsToShareByBlueprint[oUnit.UnitId]) then tUnitsToShareByBlueprint[oUnit.UnitId] = {} end
                        table.insert(tUnitsToShareByBlueprint[oUnit.UnitId], oUnit)
                        if bDebugMessages == true then LOG(sFunctionRef..': Add unit to the table of units to consider sharing') end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Is untis to share empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToShareByBlueprint))) end
                if M28Utilities.IsTableEmpty(tUnitsToShareByBlueprint) == false then
                    local iNthEntryToGive
                    local iHumanBrainCount = 0
                    local iM28BrainCount = 0
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                        if oBrain.M28AI and not(oBrain.CampaignAI) then iM28BrainCount = iM28BrainCount + 1
                        elseif oBrain.BrainType == 'Human' then
                            iHumanBrainCount = iHumanBrainCount + 1
                        end
                    end
                    local iUnitsAlreadyOwnedOfBlueprint

                    iNthEntryToGive = math.ceil((iM28BrainCount + iHumanBrainCount) / iM28BrainCount)
                    local iTotalUnitCount
                    local iCurCycleCount
                    local tUnitsToGive = {}
                    local iCurNthEntryToGive
                    if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through all units to potentially share, iNthEntryToGive='..iNthEntryToGive..'; iM28BrainCount='..iM28BrainCount..'; iHumanBrainCount='..iHumanBrainCount) end
                    for sBlueprint, tUnits in tUnitsToShareByBlueprint do
                        iCurNthEntryToGive = iNthEntryToGive
                        iTotalUnitCount = table.getn(tUnits)
                        if bDebugMessages == true then LOG(sFunctionRef..': sBLueprint='..sBlueprint..'; iTotalUnitCount='..iTotalUnitCount) end
                        if iTotalUnitCount >= iNthEntryToGive then
                            iUnitsAlreadyOwnedOfBlueprint = 0
                            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                iUnitsAlreadyOwnedOfBlueprint = iUnitsAlreadyOwnedOfBlueprint + oBrain:GetCurrentUnits(categories[sBlueprint])
                                if bDebugMessages == true then LOG(sFunctionRef..': oBrain cur units for sBlueprint='..oBrain:GetCurrentUnits(categories[sBlueprint])) end
                            end
                            if iUnitsAlreadyOwnedOfBlueprint > 0 then
                                if iUnitsAlreadyOwnedOfBlueprint >= iTotalUnitCount then
                                    iCurNthEntryToGive = 1000
                                else
                                    iCurNthEntryToGive = iCurNthEntryToGive + (iUnitsAlreadyOwnedOfBlueprint - iTotalUnitCount) * iM28BrainCount
                                end
                            end
                            iCurCycleCount = 0
                            for iUnit, oUnit in tUnits do
                                iCurCycleCount = iCurCycleCount + 1
                                if iCurCycleCount >= iNthEntryToGive then
                                    table.insert(tUnitsToGive, oUnit)
                                    iCurCycleCount = 0
                                end
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tUnitsToGive) == false then
                        local tiM28Brains = {}
                        local iM28BrainCount = 0
                        local oCurBrain
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                if not(oBrain.CampaignAI) then
                                    table.insert(tiM28Brains, oBrain)
                                    iM28BrainCount = iM28BrainCount + 1
                                end
                            end
                        elseif aiBrain.M28AI then
                            table.insert(tiM28Brains, aiBrain)
                            M28Utilities.ErrorHandler('Dont have any activeM28 brains noted despite dealing with an M28Brain')
                        end
                        for iUnit, oUnit in tUnitsToGive do
                            if iM28BrainCount > 1 then
                                oCurBrain = tiM28Brains[math.random(1, iM28BrainCount)]
                            else
                                oCurBrain = tiM28Brains[iM28BrainCount]
                            end
                            --Gift adjacent mass storage if any
                            if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                                M28Team.GiftAdjacentStorageToMexOwner(oUnit, oCurBrain)
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Just about to try and gift unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..' to M28AI brain '..oCurBrain.Nickname) end
                            M28Team.TransferUnitsToPlayer({ oUnit }, oCurBrain:GetArmyIndex(), false)
                        end
                    end
                end
            end
        end

        --Make sure have full energy to cover any energy storage that have transferred over
        local iMaxEnergy, iCurEnergy
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            iMaxEnergy = M28Economy.GetEnergyStorageMaximum(oBrain, true)
            iCurEnergy = oBrain:GetEconomyStored('ENERGY')
            if iCurEnergy < iMaxEnergy then
                oBrain:GiveResource('Energy', iMaxEnergy - iCurEnergy)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SetBuildAndResourceCheatModifiers(aiBrain, iBuildModifier, iResourceModifier, bDontChangeScenarioInfo, iOptionalRecordedUnitResourceAdjust, bDontApplyToUnits, bUpdateCheatValue)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetBuildAndResourceCheatModifiers'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for aiBrain='..aiBrain.Nickname..'; iBuildModifier='..iBuildModifier..'; iResourceModifier='..iResourceModifier) end
    --Note - see also FixUnitResourceCheatModifiers(oUnit) for a function intended to try and fix SACU FAF issue with AIx
    if not(bDontChangeScenarioInfo) then
        ScenarioInfo.Options.CheatMult = tostring(iResourceModifier)
        ScenarioInfo.Options.BuildMult = tostring(iBuildModifier)
    end
    local FAFBuffs = import('/lua/sim/Buff.lua')
    local sCheatBuildRate = 'CheatBuildRate'..aiBrain:GetArmyIndex()
    local sCheatIncome = 'CheatIncome'..aiBrain:GetArmyIndex()
    --local AdjBuffFuncs = import('/lua/sim/adjacencybufffunctions.lua')
    if not Buffs[sCheatBuildRate] then
        BuffBlueprint {
            Name = sCheatBuildRate,
            DisplayName = sCheatBuildRate,
            BuffType = 'BUILDRATECHEAT',
            Stacks = 'ALWAYS',
            Duration = -1,
            Affects = {
                BuildRate = {
                    --BuffCheckFunction = AdjBuffFuncs.BuildRateBuffCheck,
                    Add = 0,
                    Mult = 1,
                },
            },
        }
    end
    if not Buffs[sCheatIncome] then
        BuffBlueprint {
            Name = sCheatIncome,
            DisplayName = sCheatBuildRate,
            BuffType = 'INCOMECHEAT',
            Stacks = 'ALWAYS',
            Duration = -1,
            Affects = {
                EnergyProduction = {
                    --BuffCheckFunction = AdjBuffFuncs.EnergyProductionBuffCheck,
                    Add = 0,
                    Mult = 1,
                },
                MassProduction = {
                    --BuffCheckFunction = AdjBuffFuncs.MassProductionBuffCheck,
                    Add = 0,
                    Mult = 1,
                }
            },
        }
    end
    if bUpdateCheatValue then aiBrain.CheatValue = math.min(iBuildModifier, iResourceModifier) end
    if M28Utilities.bLoudModActive then
        Buffs[sCheatBuildRate].EntityCategory = 'ALLUNITS'
        Buffs[sCheatIncome].EntityCategory = 'ALLUNITS'
        Buffs[sCheatBuildRate].ParsedEntityCategory = categories.ALLUNITS
        Buffs[sCheatIncome].ParsedEntityCategory = categories.ALLUNITS
    end
    Buffs['CheatBuildRate'..aiBrain:GetArmyIndex()].Affects.BuildRate.Mult = iBuildModifier
    Buffs['CheatIncome'..aiBrain:GetArmyIndex()].Affects.EnergyProduction.Mult = iResourceModifier
    Buffs['CheatIncome'..aiBrain:GetArmyIndex()].Affects.MassProduction.Mult = iResourceModifier
    if not(bDontApplyToUnits) then
        local tExistingUnits = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryResourceUnit, false, false)
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of existing units empty='..tostring(M28Utilities.IsTableEmpty(tExistingUnits))) end
        if M28Utilities.IsTableEmpty(tExistingUnits) == false then
            for iUnit, oUnit in tExistingUnits do
                M28UnitInfo.FixUnitResourceCheatModifiers(oUnit)
                --[[if bDebugMessages == true then LOG(sFunctionRef..': Applying buffs to unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' for brain='..aiBrain.Nickname..' with index='..aiBrain:GetArmyIndex()) end
                FAFBuffs.RemoveBuff(oUnit, 'CheatIncome'..aiBrain:GetArmyIndex(), true)
                FAFBuffs.ApplyBuff(oUnit, 'CheatIncome'..aiBrain:GetArmyIndex())
                FAFBuffs.RemoveBuff(oUnit, 'CheatBuildRate'..aiBrain:GetArmyIndex(), true)
                FAFBuffs.ApplyBuff(oUnit, 'CheatBuildRate'..aiBrain:GetArmyIndex())--]]
                if iOptionalRecordedUnitResourceAdjust then
                    ForkThread(UpdateGrossIncomeForUnit, oUnit, false, false, iOptionalRecordedUnitResourceAdjust)
                end
            end
        end
    end
    if not(aiBrain.CheatEnabled) and not(iResourceModifier == 1 and iBuildModifier == 1) then aiBrain.CheatEnabled = true end --redundnacy
    aiBrain[M28Economy.refiBrainResourceMultiplier] = iResourceModifier
    aiBrain[M28Economy.refiBrainBuildRateMultiplier] = iBuildModifier
    if aiBrain.CheatEnabled and aiBrain.M28Team then
        M28Team.tTeamData[aiBrain.M28Team][M28Team.refiHighestBrainResourceMultiplier] = iResourceModifier
        M28Team.tTeamData[aiBrain.M28Team][M28Team.refiHighestBrainBuildMultiplier] = iBuildModifier
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckForScenarioObjectives()
    --NO LONGER USED - use AddObjective hook instead
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckForScenarioObjectives'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    M28Utilities.ErrorHandler('Obsolete function')
    if bDebugMessages == true then LOG(sFunctionRef..': Will start scenario mission checker if not already active, bActiveMissionChecker='..tostring(bActiveMissionChecker)) end
    if not(bActiveMissionChecker) then
        bActiveMissionChecker = true

        while not(M28Map.bMapLandSetupComplete) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if M28Utilities.IsTableEmpty(tAllActiveM28Brains) then break end
        end
        local iTeam

        local tObjectivesConsidered = {}
        local iLastMissionConsidered = 0
        function ConsiderObjective(sMissionRef, iMission, iObjective)
            --Does this objective exist and we havent already considered it?
            if ScenarioInfo[sMissionRef] and not(tObjectivesConsidered[sMissionRef]) then
                tObjectivesConsidered[sMissionRef] = true
                iLastMissionConsidered = math.max(iMission, iLastMissionConsidered)
                if bDebugMessages == true then LOG(sFunctionRef..': Have just recorded a new objective, sMissionRef='..sMissionRef..'; iMission='..iMission..'; iObjective='..iObjective..'; reprs of mission='..reprs(ScenarioInfo[sMissionRef])) end
            end
        end
        local sMissionRef
        if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop, is table of active M28 brains empty='..tostring(M28Utilities.IsTableEmpty(tAllActiveM28Brains))) end
        while M28Utilities.IsTableEmpty(tAllActiveM28Brains) == false do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(60)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            --Check for new objectives
            for iMission = math.max(1, iLastMissionConsidered), iLastMissionConsidered + 1 do
                for iPrimaryObjective = 1, 5 do
                    sMissionRef = 'M'..iMission..'P'..iPrimaryObjective
                    ConsiderObjective(sMissionRef, iMission, iPrimaryObjective)
                end
                for iSecondaryObjective = 1, 5 do
                    sMissionRef = 'M'..iMission..'S'..iSecondaryObjective
                    ConsiderObjective(sMissionRef, iMission, iSecondaryObjective)
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking form issions, iLastMissionConsidered='..iLastMissionConsidered..'; tObjectivesConsidered='..repru(tObjectivesConsidered)) end
        end

        bActiveMissionChecker = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function M28ErisKilled()

    if(not ScenarioInfo.OpEnded) and ScenarioInfo.M4P1.Active then
        local CampaignScript = import('/maps/scca_coop_e03.v0021/SCCA_Coop_E03_script.lua')
        if CampaignScript.ErisKilled then
            LOG('Manually calling Eris killed event')
            CampaignScript.ErisKilled()
        end
        --[[WaitSeconds(20)
        if(not ScenarioInfo.OpEnded) and ScenarioInfo.M4P1.Active then
            local ScenarioFramework = import('/lua/ScenarioFramework.lua')
            ScenarioFramework.EndOperationSafety()
            ScenarioInfo.OpComplete = true

            -- aeon cdr killed
            --    ScenarioFramework.EndOperationCamera(ScenarioInfo.AeonCDR)
            --ScenarioFramework.CDRDeathNISCamera(ScenarioInfo.AeonCDR) --Commander will be dead now/unit invalid

            local OpStrings = import('/maps/scca_coop_e03.v0021/SCCA_Coop_E03_strings.lua')
            ScenarioFramework.Dialogue(OpStrings.E03_M04_070, StartKillGame, true)
        end--]]
    end
end

function DelayedCybranFireBlackSun(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DelayedCybranFireBlackSun'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Will wait a bit then fire black sun') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitSeconds(10)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Has the op ended yet='..tostring(ScenarioInfo.OpEnded or false)..'; OpComplete='..tostring(ScenarioInfo.OpComplete or false)) end
    if not(ScenarioInfo.OpEnded) and not(ScenarioInfo.OpComplete) then
        M28Chat.SendMessage(aiBrain, 'M6End', 'Getting ready to fire black sun...', 0, 100000, false, false)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(5)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': WIll fire black sun') end
        local ScenarioFramework = import('/lua/ScenarioFramework.lua')
        ScenarioFramework.FlushDialogueQueue()
        ScenarioFramework.EndOperationSafety()
        ScenarioInfo.OpComplete = true
        if ScenarioInfo.M3P2 then
            ScenarioInfo.M3P2:ManualResult(true)
        end
        ScenarioFramework.EndOperation(ScenarioInfo.OpComplete, ScenarioInfo.OpComplete, true)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function M1AeonEndMissionBackupMonitor()
    --Every 20s checks if have killed enemy ACU then waits another 20s before ending game (as default is far too long)
    --Call via fork thread
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'M1AeonEndMissionBackupMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': start of code, for time '..GetGameTimeSeconds()..'; bActiveMissionChecker='..tostring(bActiveMissionChecker)..'; Is M7 UEF commander valid='..tostring(M28UnitInfo.IsUnitValid(ScenarioInfo.M7_FauxUEFCommanderUnit))) end
    if not(bActiveMissionChecker) and M28UnitInfo.IsUnitValid(ScenarioInfo.M7_FauxUEFCommanderUnit) then
        bActiveMissionChecker = true
        while M28UnitInfo.IsUnitValid(ScenarioInfo.M7_FauxUEFCommanderUnit) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(20)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Is UEF ACU still valid='..tostring( M28UnitInfo.IsUnitValid(ScenarioInfo.M7_FauxUEFCommanderUnit))) end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': UEF ACU is now dead, will wait 20s then start ending the game') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(20)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Is operation not ending yet via normal logic='..tostring(not(ScenarioInfo.OperationEnding))..'; Time='..GetGameTimeSeconds()) end
        if ScenarioInfo.OperationEnding then
            if bDebugMessages == true then LOG(sFunctionRef..': Will wait another 15s to see if scenario ends') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(15)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end --Wait another 15s to give the main mission a chance to end properly
        if ScenarioInfo.M7P4.ManualResult then
            ScenarioInfo.M7P4.ManualResult(true)
            if bDebugMessages == true then LOG(sFunctionRef..': Will end operation safely, and then wait 10s and end operation') end
            local ScenarioFramework = import('/lua/ScenarioFramework.lua')
            local OpStrings   = import('/maps/scca_coop_a01.v0016/SCCA_Coop_A01_Strings.lua')
            local Objectives = import('/lua/ScenarioFramework.lua').Objectives
            ScenarioFramework.EndOperationSafety()
            ScenarioFramework.Dialogue(OpStrings.A01_M07_116, false, true) -- Rhiza: "Glorious!"
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(5)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            ScenarioInfo.OpComplete = true
            local secondary = Objectives.IsComplete(ScenarioInfo.M7S1) and Objectives.IsComplete(ScenarioInfo.M7S2)
            local bonus = Objectives.IsComplete(ScenarioInfo.M1B1) and Objectives.IsComplete(ScenarioInfo.M1B2) and Objectives.IsComplete(ScenarioInfo.M1B3) and Objectives.IsComplete(ScenarioInfo.M6B1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(5.0)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if bDebugMessages == true then LOG(sFunctionRef..': Will now end operation at time '..GetGameTimeSeconds()) end
            ScenarioFramework.EndOperation(ScenarioInfo.OpComplete, ScenarioInfo.OpComplete, secondary, bonus)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderSpecialCampaignObjectives(Type, Complete, Title, Description, ActionImage, Target, IsLoading, loadedTag, iOptionalWaitInSeconds)
    --NOTE: All of input variables are optional as sometimes we just call this due to a playable area size change
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderSpecialCampaignObjectives'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if iOptionalWaitInSeconds then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(iOptionalWaitInSeconds)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code at time '..GetGameTimeSeconds()..' after iOptionalWaitInSeconds='..(iOptionalWaitInSeconds or 'nil')..'; Is M3P3 active='..tostring(ScenarioInfo.M3P3.Active or false)..'; Is commander gate area empty='..tostring(Scenario.Areas['CDR_Gate_Area'] == nil)..'; CDR_Gate_Area='..repru(Scenario.Areas['CDR_Gate_Area'])..'; ScenarioInfo.M1P3.Active='..tostring(ScenarioInfo.M1P3.Active or false)..'; Is combined table empty='..tostring(M28Utilities.IsTableEmpty(ScenarioInfo.M1_TempleCombinedTable))..'; M1P2 active='..tostring(ScenarioInfo.M1P2.Active)..'; M1P1 active='..tostring(ScenarioInfo.M1P1.Active)) end

    local aiBrain
    for iBrain, oBrain in tAllActiveM28Brains do
        if oBrain.M28AI and not(oBrain.CampaignAI) then aiBrain = oBrain break end
    end
    if aiBrain then
        local iTeam = aiBrain.M28Team
        --UEF Mission 3 - create a special death trigger for Aeon ACU due to flaw with preceding objective
        if bDebugMessages == true then
            LOG(sFunctionRef..': Further logs, ScenarioInfo.M3BaseDamageWarnings='..(ScenarioInfo.M3BaseDamageWarnings or 'nil')..'; ScenarioInfo.MainFrameIsAlive='..tostring(ScenarioInfo.MainFrameIsAlive or false)..'; ScenarioInfo.EMPFired='..tostring(ScenarioInfo.EMPFired or false)..'; ScenarioInfo.M3_Base is empty='..tostring(M28Utilities.IsTableEmpty(ScenarioInfo.M3_Base))..'; bPacifistModeActive='..tostring(bPacifistModeActive)..'; ScenarioInfo.MissionNumber='..(ScenarioInfo.MissionNumber or 'nil')..'; iTeam='..iTeam..'; C M6: ScenarioInfo.ControlCenter is nil='..tostring(ScenarioInfo.ControlCenter == nil)..'; ScenarioInfo.Czar is nil='..tostring(ScenarioInfo.Czar == nil)..'; Is table of czars empty='..tostring(M28Utilities.IsTableEmpty(ScenarioInfo.Czar))..'; Is M3P1 active='..tostring(ScenarioInfo.M3P1.Active)..'; Is M3P2 active='..tostring(ScenarioInfo.M3P2.Active)..'; Is there a valid black sun unit='..tostring(M28UnitInfo.IsUnitValid(ScenarioInfo.BlackSunWeapon))..'; UEF M5: Is ScenarioInfo.M1P2.Active='..tostring(ScenarioInfo.M1P2.Active or false)..'; Is research facility 1 nil='..tostring(ScenarioInfo.ResearchFacility1 == nil)..'; Is research facility 2 nil='..tostring(ScenarioInfo.ResearchFacility2 == nil))
            if M28UnitInfo.IsUnitValid(ScenarioInfo.BlackSunWeapon) then LOG(sFunctionRef..': Have a valid black sun unit, Target[1].UnitId='..(Target[1].UnitId or 'nil')..'; Black sun brain owner='..ScenarioInfo.BlackSunWeapon:GetAIBrain().Nickname..'; Faction index='..ScenarioInfo.BlackSunWeapon:GetAIBrain():GetFactionIndex()) end
            LOG(sFunctionRef..': Sera M3 logs, Is M4P3 active='..tostring(ScenarioInfo.M4P3.Active)..'; Is target category urc1901='..tostring(Target.Requirements[1].Category == categories.urc1901)..'; Target.Area='..(Target.Requirements[1].Area or 'nil')..'; reprs of ScenarioInfo.M2P2='..reprs(ScenarioInfo.M2P2)..'; reprs of Target='..reprs(Target))
            LOG(sFunctionRef..': Aeon M5 check, if ScenarioInfo.M2P1Obj.Active='..tostring(ScenarioInfo.M2P1Obj.Active or false)..'; ScenarioInfo.Ariel==nil='..tostring(ScenarioInfo.Ariel == nil)..'; Colonies is nil='..tostring(ScenarioInfo.Colonies == nil)..'; tbSpecialCodeForMission[21]='..tostring(tbSpecialCodeForMission[21] or false))
        end
        if ScenarioInfo.M4P1 and M28Utilities.IsTableEmpty(Target.Units) and ScenarioInfo.M4P1.Active and M28UnitInfo.IsUnitValid(ScenarioInfo.AeonCDR) then
            if bDebugMessages == true then LOG(sFunctionRef..': Creating manual on death trigger') end
            local ScenarioFramework = import('/lua/ScenarioFramework.lua')
            ScenarioFramework.CreateUnitDeathTrigger(M28ErisKilled, ScenarioInfo.AeonCDR)
            --UEF Mission 5 - send ACU to gateway
        elseif ScenarioInfo.M3P3.Active and Scenario.Areas['CDR_Gate_Area'] and ScenarioInfo.PlayerCDRs then
            --local rRect = import("/lua/sim/scenarioutilities.lua").AreaToRect('CDR_Gate_Area')
            local tRect = import("/lua/sim/scenarioutilities.lua").AreaToRect('CDR_Gate_Area')
            local rRect = {tRect['x0'], tRect['y0'], tRect['x1'], tRect['y1']}
            if bDebugMessages == true then LOG(sFunctionRef..': rRect='..repru(rRect)..'; AreaToRect='..repru(import("/lua/sim/scenarioutilities.lua").AreaToRect('CDR_Gate_Area'))) end
            if rRect then
                local tMidpoint = {(rRect[1] + rRect[3])*0.5, 0, (rRect[2] + rRect[4])*0.5}
                tMidpoint[2] = GetTerrainHeight(tMidpoint[1], tMidpoint[3])
                for iUnit, oUnit in ScenarioInfo.PlayerCDRs do
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        LOG(sFunctionRef..': Considering ACU owned by brain '..oUnit:GetAIBrain().Nickname..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; if M28 then will set objective to tMidpoint='..repru(tMidpoint))
                        if oUnit:GetAIBrain().M28AI and not(oUnit:GetAIBrain().CampaignAI) then
                            oUnit[M28ACU.reftSpecialObjectiveMoveLocation] = {tMidpoint[1], tMidpoint[2], tMidpoint[3]}
                        end
                    end
                end
            end
        elseif ScenarioInfo.M1_TempleCombinedTable and (ScenarioInfo.M1P3.Active or ScenarioInfo.M1P2.Active) then
            if bDebugMessages == true then LOG(sFunctionRef..': Will check if we have Seraphim temples that need manually destroying') end
            if M28Utilities.IsTableEmpty(   ScenarioInfo.M1_TempleCombinedTable) == false and M28Utilities.IsTableEmpty(tAllActiveM28Brains) == false then

                for iUnit, oUnit in ScenarioInfo.M1_TempleCombinedTable do
                    --Add to table of units in the land zone (if it is in a land zone)
                    local iPlateau, iLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
                    if (iLandZone or 0) > 0 then
                        local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                        local bAddToTable = true
                        if not(tLZTeamData[M28Map.reftoGroundFireFriendlyTarget]) then tLZTeamData[M28Map.reftoGroundFireFriendlyTarget] = {}
                        else
                            for iRecordedUnit, oRecordedUnit in tLZTeamData[M28Map.reftoGroundFireFriendlyTarget] do
                                if oRecordedUnit == oUnit then
                                    bAddToTable = false
                                    break
                                end
                            end
                        end
                        if bAddToTable then
                            if bDebugMessages == true then LOG(sFunctionRef..': Added unit to the land zone team table of ground fire targets') end
                            table.insert(tLZTeamData[M28Map.reftoGroundFireFriendlyTarget], oUnit)
                        end
                    end
                end
            end
            --Cybran mission 2 - move to gate
        elseif ScenarioInfo.M3P2.Active and ScenarioInfo.M3Gate and M28UnitInfo.IsUnitValid(ScenarioInfo.M3Gate) then
            for iBrain, oBrain in tAllActiveM28Brains do
                if not(oBrain.CampaignAI) then
                    local tACUs = oBrain:GetListOfUnits(categories.COMMAND, false, true)
                    if M28Utilities.IsTableEmpty(tACUs) == false then
                        for iUnit, oUnit in tACUs do
                            LOG(sFunctionRef..': Considering ACU owned by brain '..oUnit:GetAIBrain().Nickname..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; if M28 then will set objective to gate position='..repru(ScenarioInfo.M3Gate:GetPosition()))
                            oUnit[M28ACU.reftSpecialObjectiveMoveLocation] = ScenarioInfo.M3Gate:GetPosition()
                        end
                    end
                end
            end
            --Cybran mission 4 - play defensively and let human player try and capture the nodes
        elseif ScenarioInfo.M3BaseDamageWarnings and ScenarioInfo.MainFrameIsAlive and not ScenarioInfo.EMPFired and (ScenarioInfo.M3_Base or Scenario.Areas['Aeon_Base_M3']) and not(bPacifistModeActive) then
            --Reset base warnings to help M28 a bit since it can trigger the damage before this objective is even active
            if ScenarioInfo.M3BaseDamageWarnings > 0 then ScenarioInfo.M3BaseDamageWarnings = 0 end
            local tUnitsToConsider = ScenarioInfo.M3_Base
            if not(tUnitsToConsider) then
                local ScenarioFramework = import('/lua/ScenarioFramework.lua')
                tUnitsToConsider = ScenarioFramework.GetCatUnitsInArea(categories.STRUCTURE - categories.WALL, 'Aeon_Base_M3', ArmyBrains[ScenarioInfo.Aeon])
            end
            if M28Utilities.IsTableEmpty(tUnitsToConsider) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to disable attacking parts of the map that could cause us to fail the mission') end
                bPacifistModeActive = true

                tiPacifistZonesByPlateau = {}
                local tbHasPlateauAndZoneBeenRecorded = {}
                local iCurPlateauOrZero, iCurLandOrWaterZone
                for iUnit, oUnit in ScenarioInfo.M3_Base do
                    iCurPlateauOrZero, iCurLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                    if iCurPlateauOrZero and iCurLandOrWaterZone and not(tbHasPlateauAndZoneBeenRecorded[iCurPlateauOrZero][iCurLandOrWaterZone]) then
                        if not(tiPacifistZonesByPlateau[iCurPlateauOrZero]) then tiPacifistZonesByPlateau[iCurPlateauOrZero] = {} end
                        table.insert(tiPacifistZonesByPlateau[iCurPlateauOrZero], iCurLandOrWaterZone)
                        if not(tbHasPlateauAndZoneBeenRecorded[iCurPlateauOrZero]) then tbHasPlateauAndZoneBeenRecorded[iCurPlateauOrZero] = {} end
                        tbHasPlateauAndZoneBeenRecorded[iCurPlateauOrZero][iCurLandOrWaterZone] = true
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished recording the plateaus and zones that units in M3_Base are in, repru of tiPacifistZonesByPlateau='..repru(tiPacifistZonesByPlateau)) end
                if M28Utilities.IsTableEmpty(tiPacifistZonesByPlateau) == false then
                    --Record any adjacent zones
                    local tiAdjacentZonesByPlateau = {}
                    for iPlateauOrZero, tBaseSubtable in tiPacifistZonesByPlateau do
                        for iEntry, iLandOrWaterZone in tBaseSubtable do
                            local tLZOrWZData
                            if iPlateauOrZero == 0 then
                                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                                --Water zone: Adjacent land zones
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering water zone '..iLandOrWaterZone..'; Is table of adjacent land zones empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentLandZones]))) end
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentLandZones]) == false then
                                    for iEntry, tSubtable in tLZOrWZData[M28Map.subrefAdjacentLandZones] do
                                        local iPlateauRef = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                                        local iAdjZoneRef = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjZoneRef='..iAdjZoneRef..'; iPlateauRef='..iPlateauRef) end
                                        if not(tbHasPlateauAndZoneBeenRecorded[iPlateauRef][iAdjZoneRef]) then
                                            tbHasPlateauAndZoneBeenRecorded[iPlateauRef][iAdjZoneRef] = true
                                            if not(tiAdjacentZonesByPlateau[iPlateauRef]) then tiAdjacentZonesByPlateau[iPlateauRef] = {} end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Adding iAdjZoneRef='..iAdjZoneRef..'; to table') end
                                            table.insert(tiAdjacentZonesByPlateau[iPlateauRef], iAdjZoneRef)
                                        end
                                    end
                                end
                                --Water zone: Adjacent water zones:
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefWZAdjacentWaterZones]))) end
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                                    for _, iAdjZoneRef in tLZOrWZData[M28Map.subrefWZAdjacentWaterZones] do
                                        if not(tbHasPlateauAndZoneBeenRecorded[0][iAdjZoneRef]) then
                                            if not(tbHasPlateauAndZoneBeenRecorded[0]) then tbHasPlateauAndZoneBeenRecorded[0] = {} end
                                            tbHasPlateauAndZoneBeenRecorded[0][iAdjZoneRef] = true
                                            if not(tiAdjacentZonesByPlateau[0]) then tiAdjacentZonesByPlateau[0] = {} end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Adding WZ iAdjZoneRef='..iAdjZoneRef..'; to table') end
                                            table.insert(tiAdjacentZonesByPlateau[0], iAdjZoneRef)
                                        end
                                    end
                                end
                            else
                                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                                --Land zone: Adjacent land zones
                                if bDebugMessages == true then LOG(sFunctionRef..': Dealing with land zone, is table of adjacent land zones empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]))) end
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                    for _, iAdjZoneRef in tLZOrWZData[M28Map.subrefLZAdjacentLandZones] do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjZoneRef='..iAdjZoneRef..' in iPlateuOrZero='..iPlateauOrZero) end
                                        if not(tbHasPlateauAndZoneBeenRecorded[iPlateauOrZero][iAdjZoneRef]) then
                                            if not(tbHasPlateauAndZoneBeenRecorded[iPlateauOrZero]) then tbHasPlateauAndZoneBeenRecorded[iPlateauOrZero] = {} end
                                            tbHasPlateauAndZoneBeenRecorded[iPlateauOrZero][iAdjZoneRef] = true
                                            if not(tiAdjacentZonesByPlateau[iPlateauOrZero]) then tiAdjacentZonesByPlateau[iPlateauOrZero] = {} end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Adding LZ iAdjZoneRef='..iAdjZoneRef..'; to table') end
                                            table.insert(tiAdjacentZonesByPlateau[iPlateauOrZero], iAdjZoneRef)
                                        end
                                    end
                                end
                                --Land zone: Adjacent water zone:
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]))) end
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]) == false then
                                    for iEntry, tSubtable in tLZOrWZData[M28Map.subrefAdjacentWaterZones] do
                                        local iAdjZoneRef = tSubtable[M28Map.subrefAWZRef]
                                        if not(tbHasPlateauAndZoneBeenRecorded[0][iAdjZoneRef]) then
                                            if not(tbHasPlateauAndZoneBeenRecorded[0]) then tbHasPlateauAndZoneBeenRecorded[0] = {} end
                                            tbHasPlateauAndZoneBeenRecorded[0][iAdjZoneRef] = true
                                            if not(tiAdjacentZonesByPlateau[0]) then tiAdjacentZonesByPlateau[0] = {} end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Adding WZ iAdjZoneRef='..iAdjZoneRef..'; to table') end
                                            table.insert(tiAdjacentZonesByPlateau[0], iAdjZoneRef)
                                        end
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': About to add adjacent zones to core zone, tiAdjacentZonesByPlateau='..repru(tiAdjacentZonesByPlateau)) end
                    if M28Utilities.IsTableEmpty(tiAdjacentZonesByPlateau) == false then
                        for iPlateauOrZero, tSubtable in tiAdjacentZonesByPlateau do
                            for iEntry, iAdjZoneRef in tSubtable do
                                if not(tiPacifistZonesByPlateau[iPlateauOrZero]) then tiPacifistZonesByPlateau[iPlateauOrZero] = {} end
                                if bDebugMessages == true then LOG(sFunctionRef..': Adding iAdjZoneRef='..iAdjZoneRef..' for iPlateauOrZero='..iPlateauOrZero) end
                                table.insert(tiPacifistZonesByPlateau[iPlateauOrZero], iAdjZoneRef)
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished adding adjacent zones, repru of adjacent zones by plateau='..repru(tiAdjacentZonesByPlateau)) end

                    for iPlateauOrZero, tSubtable in tiPacifistZonesByPlateau do
                        for iEntry, iLandOrWaterZone in tSubtable do
                            local tLZOrWZData
                            if iPlateauOrZero == 0 then
                                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                            else
                                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                            end
                            tLZOrWZData[M28Map.subrefbPacifistArea] = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Set pacifist flag to true for iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone) end
                        end
                    end
                end
            end
        elseif bPacifistModeActive and ScenarioInfo.EMPFired and M28Utilities.IsTableEmpty(tiPacifistZonesByPlateau) == false then
            --Disable pacifist flag
            if bDebugMessages == true then LOG(sFunctionRef..': EMP has been fired so will disable pacifist flag for all recorded zones, tiPacifistZonesByPlateau='..repru(tiPacifistZonesByPlateau)) end
            bPacifistModeActive = false
            for iPlateauOrZero, tSubtable in tiPacifistZonesByPlateau do
                local tLZOrWZData
                for iEntry, iLandOrWaterZone in tSubtable do
                    if iPlateauOrZero == 0 then
                        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                    else
                        tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                    end
                    tLZOrWZData[M28Map.subrefbPacifistArea] = false
                end
            end
            --Cybran mission 6 - activate black sun (below is as a redundancy but doesnt actually trigger - are reliant on the oncapture event instead)
        elseif ScenarioInfo.M3P2.Active and M28UnitInfo.IsUnitValid(ScenarioInfo.BlackSunWeapon) and ScenarioInfo.BlackSunWeapon:GetAIBrain().M28AI and ScenarioInfo.BlackSunWeapon:GetAIBrain():GetFactionIndex() == M28UnitInfo.refFactionCybran then
            if bDebugMessages == true then LOG(sFunctionRef..': Want to fire black sun to complete cybran campaign - will fire in a bit') end
            ForkThread(DelayedCybranFireBlackSun, ScenarioInfo.BlackSunWeapon:GetAIBrain())
            --Cybran mission 6 - kill Czar
        elseif ScenarioInfo.ControlCenter and ScenarioInfo.Czar and M28Utilities.IsTableEmpty(ScenarioInfo.Czar) == false and ScenarioInfo.M1P1.Active then
            function DelayedRecordingOfCzar(tUnits)
                WaitSeconds(15)
                if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting, time='..GetGameTimeSeconds()..' is table of units empty='..tostring(M28Utilities.IsTableEmpty(tUnits))) end
                if M28Utilities.IsTableEmpty(tUnits) == false then
                    for iUnit, oUnit in tUnits do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            if EntityCategoryContains(M28UnitInfo.refCategoryAllAir * categories.EXPERIMENTAL, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will record enemy Czar as a priority enemy air experimental target unless it is alrady recorded') end
                                local bAlreadyIncluded = false
                                if not(M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives]) then M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives] = {}
                                else
                                    for iRecordedUnit, oRecordedUnit in M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives] do
                                        if oRecordedUnit == oUnit then bAlreadyIncluded = true break end
                                    end
                                end
                                if not(bAlreadyIncluded) then
                                    table.insert(M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives], oUnit)
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will wait a while and then look to include enemy Czar as a priority enemy air experimental target unless it is alrady recorded') end
            local tUnits = {}
            --Work whether Czar is a table or a isngle unit
            if M28UnitInfo.IsUnitValid(ScenarioInfo.Czar) and ScenarioInfo.Czar.UnitId then table.insert(tUnits, ScenarioInfo.Czar)
            else tUnits = ScenarioInfo.Czar
            end
            ForkThread(DelayedRecordingOfCzar, tUnits)
            --Cybran M6 - fire black sun if it is owned by M28 and we are on the objective to fire it
        elseif ScenarioInfo.M7_FauxUEFCommanderUnit then
            ForkThread(M1AeonEndMissionBackupMonitor)
        elseif ScenarioInfo.M1P1Obj.Active and Target.MarkArea and Target.Requirements and Target.Category == categories.uab4301 then --Aeon mission 5 - build UEF T3 shield
            M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] = true
            M28Team.tTeamData[iTeam][M28Team.refiEnemyT3ArtiCount] = 1
            if bDebugMessages == true then LOG(sFunctionRef..': Want to build T3 shielding for Aeon M5') end
            local iOurBrainIndex = M28Team.GetFirstActiveM28Brain(iTeam):GetArmyIndex()
            for iTarget, tRequirements in Target.Requirements do
                local tRect = import("/lua/sim/scenarioutilities.lua").AreaToRect(tRequirements.Area)
                local tBaseAreaForRect = {tRect['x0'], tRect['y0'], tRect['x1'], tRect['y1']}
                if bDebugMessages == true then LOG(sFunctionRef..': rRect='..repru(tBaseAreaForRect)..'; tRequirements.Area='..reprs(tRequirements.Area)..'; AreaToRect='..repru(import("/lua/sim/scenarioutilities.lua").AreaToRect(tRequirements.Area))) end
                if tBaseAreaForRect then
                    local iRadiusAdjust = -16
                    local rRect = Rect(tBaseAreaForRect[1] - iRadiusAdjust, tBaseAreaForRect[2] - iRadiusAdjust, tBaseAreaForRect[3] + iRadiusAdjust, tBaseAreaForRect[4] + iRadiusAdjust)
                    if bDebugMessages == true then LOG(sFunctionRef..': rRect to search after adjust='..repru(rRect)) end
                    local tUnitsInRect = GetUnitsInRect(rRect)
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of units in rec empty='..tostring(M28Utilities.IsTableEmpty(tUnitsInRect))) end
                    if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                        local tBuildingsInRect = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tUnitsInRect)
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of tBuildingsInRect empty='..tostring(M28Utilities.IsTableEmpty(tBuildingsInRect))) end
                        if M28Utilities.IsTableEmpty(tBuildingsInRect) == false then
                            for iUnit, oUnit in tBuildingsInRect do
                                if not(IsEnemy(oUnit:GetAIBrain():GetArmyIndex(), iOurBrainIndex)) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Sending unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to function to assign shielding requirement') end
                                    M28Building.CheckIfUnitWantsFixedShield(oUnit, true, 1)
                                end
                            end
                        end
                    end
                    local tMidpoint = {(tBaseAreaForRect[1] + tBaseAreaForRect[3]) * 0.5, 0, (tBaseAreaForRect[2] + tBaseAreaForRect[4]) * 0.5}
                    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tMidpoint)
                    local tMidpointLZData, tMidpointLZTeamData = M28Map.GetLandOrWaterZoneData(tMidpoint, true, iTeam)
                    local iTotalSegments = table.getn(tMidpointLZData[M28Map.subrefLZSegments])
                    local iSegmentStart = (tMidpointLZData[M28Map.subrefiLastSegmentEntryConsideredForBuilding] or 0)
                    if bDebugMessages == true then LOG(sFunctionRef..': Midpoint='..repru(tMidpoint)..'; iLandOrWaterZone='..iLandOrWaterZone..'; iTotalSegments='..iTotalSegments..'; iSegmentStart='..iSegmentStart) end
                    local iCurCycleCount = 0
                    local iWaitCycleCount = 0
                    while iSegmentStart < iTotalSegments * 0.9 do
                        iCurCycleCount = iCurCycleCount + 1
                        iWaitCycleCount = iWaitCycleCount + 1
                        if iWaitCycleCount >= 100 then
                            iWaitCycleCount = 0
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitTicks(1)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        end
                        if iCurCycleCount >= 10000 then break end
                        M28Engineer.SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, math.min(100, math.floor(iTotalSegments * 0.1)))
                        iTotalSegments = table.getn(tMidpointLZData[M28Map.subrefLZSegments])
                        iSegmentStart = (tMidpointLZData[M28Map.subrefiLastSegmentEntryConsideredForBuilding] or 0)
                        if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; iTotalSegments='..iTotalSegments..'; iSegmentStart='..iSegmentStart) end
                    end
                end
            end
            --Aeon Mission 5 - build SMD
        elseif ScenarioInfo.M1P2Obj.Active and Target.MarkArea and Target.Category == categories.uab4302 and Target.Areas then
            local ScenarioUtilities = import("/lua/sim/scenarioutilities.lua")

            for iArea, sArea in Target.Areas do
                local tRect = ScenarioUtilities.AreaToRect(sArea)
                local tBaseAreaForRect = {tRect['x0'], tRect['y0'], tRect['x1'], tRect['y1']}
                if bDebugMessages == true then LOG(sFunctionRef..': tRect='..repru(tRect)..'; tBaseAreaForRect='..repru(tBaseAreaForRect)..'; sArea='..sArea) end
                if tBaseAreaForRect then
                    local tMidpoint = {(tBaseAreaForRect[1] + tBaseAreaForRect[3]) * 0.5, 0, (tBaseAreaForRect[2] + tBaseAreaForRect[4]) * 0.5}
                    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tMidpoint)
                    if iPlateauOrZero > 0 and (iLandOrWaterZone or 0) > 0 then
                        local tMidpointLZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
                        tMidpointLZTeamData[M28Map.reftObjectiveSMDLocation] = {tMidpoint[1], GetSurfaceHeight(tMidpoint[1], tMidpoint[3]), tMidpoint[3]}
                        if bDebugMessages == true then LOG(sFunctionRef..': Set SMD location for iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; Location='..repru(tMidpointLZTeamData[M28Map.reftObjectiveSMDLocation])) end
                    end

                end
            end
            --UEF M5 - build SMD and protect research facilities with heavy shields
        elseif (ScenarioInfo.ResearchFacility1 or ScenarioInfo.ResearchFacility2 or ScenarioInfo.ResearchFacility3) then
            if ScenarioInfo.M1P2.Active then
                local tResearchLocations = {}
                if M28UnitInfo.IsUnitValid(ScenarioInfo.ResearchFacility1) then
                    table.insert(tResearchLocations, ScenarioInfo.ResearchFacility1:GetPosition())
                end
                if M28UnitInfo.IsUnitValid(ScenarioInfo.ResearchFacility2) then
                    table.insert(tResearchLocations, ScenarioInfo.ResearchFacility2:GetPosition())
                end
                if M28UnitInfo.IsUnitValid(ScenarioInfo.ResearchFacility3) then
                    table.insert(tResearchLocations, ScenarioInfo.ResearchFacility3:GetPosition())
                end
                if M28Utilities.IsTableEmpty(tResearchLocations) == false then
                    for iEntry, tLocation in tResearchLocations do
                        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tLocation)
                        if (iLandZone or 0) > 0 then
                            local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                            tLZTeamData[M28Map.reftObjectiveSMDLocation] = {tLocation[1], tLocation[2], tLocation[3]}
                            if bDebugMessages == true then LOG(sFunctionRef..': Added SMD location for Plateau '..iPlateau..'; Zone '..iLandZone) end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': tResearchLocations='..reprs(tResearchLocations)) end
            elseif ScenarioInfo.M1P1.Active then
                --Make sure research centres are added to list of buildings to shield
                local oUnit = ScenarioInfo.ResearchFacility1
                if M28UnitInfo.IsUnitValid(oUnit) then M28Building.CheckIfUnitWantsFixedShield(oUnit, true, 1) end
                oUnit = ScenarioInfo.ResearchFacility2
                if M28UnitInfo.IsUnitValid(oUnit) then M28Building.CheckIfUnitWantsFixedShield(oUnit, true, 1) end
                oUnit = ScenarioInfo.ResearchFacility3
                if M28UnitInfo.IsUnitValid(oUnit) then M28Building.CheckIfUnitWantsFixedShield(oUnit, true, 1) end
            end
        elseif ScenarioInfo.M4P3.Active and Target.Requirements[1].Category == categories.urc1901 and Target.Requirements[1].Area then --Seraphim M3 - protect QAI mainframe (as objective currently has strange way of doing this where it tracks the area rather htan the unit)

            local ScenarioUtilities = import("/lua/sim/scenarioutilities.lua")
            local tRect = ScenarioUtilities.AreaToRect(Target.Requirements[1].Area)
            local tBaseAreaForRect = {tRect['x0'], tRect['y0'], tRect['x1'], tRect['y1']}
            if bDebugMessages == true then LOG(sFunctionRef..': Will add QAI mainframe as a priority defence target, tRect='..repru(tRect)..';tBaseAreaForRect='..repru(tBaseAreaForRect)..'; Target.Requirements[1].Area='..(Target.Requirements[1].Area or 'nil')) end
            local tUnitsInRect = GetUnitsInRect(tRect)
            if bDebugMessages == true then LOG(sFunctionRef..': Is tUnitsInRect empty='..tostring(M28Utilities.IsTableEmpty(tUnitsInRect))) end
            if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                local tQAIMainframes = EntityCategoryFilterDown(Target.Requirements[1].Category, tUnitsInRect)
                if bDebugMessages == true then LOG(sFunctionRef..': Is tQAIMainframes empty='..tostring(M28Utilities.IsTableEmpty(tQAIMainframes))) end
                if M28Utilities.IsTableEmpty(tQAIMainframes) == false then
                    for iUnit, oUnit in tQAIMainframes do
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' as a priority air defence target') end
                        M28Air.AddPriorityAirDefenceTarget(oUnit)
                    end
                end
            end
            --Dawn (FA Mission 2) - add redundancy so upgraidng facotires doesnt break the objective - solved via callback appraoch instead
            --[[elseif M28Utilities.IsTableEmpty(ScenarioInfo.M1P1Units) == false and not(ScenarioInfo.M1P2.Active) and ScenarioInfo.M1P1.Active then
                --Monitor the M1P1 units and remove any that become obsolete
                LOG(sFunctionRef..': Want to monitor ScenarioInfo.M1P1Units units, will list out each unit, is table empty='..tostring(ScenarioInfo.M1P1Units))
                for iUnit, oUnit in ScenarioInfo.M1P1Units do
                    LOG(sFunctionRef..': iUnit='..iUnit..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is valid='..tostring(M28UnitInfo.IsUnitValid(oUnit)))
                end
                ForkThread(MonitorObjectiveUnitsAndRemoveIfDead, ScenarioInfo.M1P1Units, 1, ScenarioInfo.M1P1)
                --]]
            --Dawn (FA Mission 2) - redundancy for case where first objective (kill attack) is done but second (destroy order base) doesnt trigger - commented out as in the particular case this function (i.e. considering special campaign objectives) only triggers when the attack wave is still alive, and doesnt trigger when the units die
        --[[elseif ScenarioInfo.M1P1Units and ScenarioInfo.M1OrderAttack and not(ScenarioInfo.M1P2.Active) then
            --If we have alive units in M1P1Units then are still scenario 1
            local bHaveAliveBaseUnits = false
            local bHaveAliveAttackUnits = false
            for iUnit, oUnit in ScenarioInfo.M1OrderAttack do
                if not(oUnit.Dead) then bHaveAliveAttackUnits = true break end
            end
            for iUnit, oUnit in ScenarioInfo.M1P1Units do
                if not(oUnit.Dead) then
                    bHaveAliveBaseUnits = true
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bHaveAliveAttackUnits='..tostring(bHaveAliveAttackUnits)..'; bHaveAliveBaseUnits='..tostring(bHaveAliveBaseUnits)..'; ScenarioInfo.M1P1.Active='..tostring(ScenarioInfo.M1P1.Active or false)) end
            if not(bHaveAliveAttackUnits) and bHaveAliveBaseUnits then
                if bDebugMessages == true then LOG(sFunctionRef..': Will do delayed check if mission active') end
                WaitSeconds(300)
                if not(ScenarioInfo.M1P2.Active) then
                    ScenarioInfo.M1P1:ManualResult(true)
                end
            end--]]
            --Dawn - update enemy unit tables after brief delay
        elseif ScenarioInfo.QAICommander and ScenarioInfo.M4P1.Active and not(tbSpecialCodeForMission[41]) then
            tbSpecialCodeForMission[41] = true
            --Have had a change in factions, update all unit tables
            if bDebugMessages == true then LOG(sFunctionRef..': ScenarioInfo.OrderAlly='..tostring(ScenarioInfo.OrderAlly or false)..'; Time='..GetGameTimeSeconds()) end
            ForkThread(UpdateAllRecordedUnitsFollowingTeamChange, ScenarioInfo.OrderAlly)
            --FA M6 - Fletcher changing sides
        elseif ScenarioInfo.M2P1.Active and ScenarioInfo.FletcherACU and not(tbSpecialCodeForMission[21]) then
            tbSpecialCodeForMission[21] = true
            --Have had a change in factions, update all unit tables
            if bDebugMessages == true then LOG(sFunctionRef..': Will update recorded units following fletcher changing sides, Time='..GetGameTimeSeconds()) end
            ForkThread(UpdateAllRecordedUnitsFollowingTeamChange)
            --SC Aeon M5 - UEF changing sides
        elseif ScenarioInfo.M2P1Obj.Active and ScenarioInfo.Ariel and ScenarioInfo.Colonies and not(tbSpecialCodeForMission[21]) then
            tbSpecialCodeForMission[21] = true
            --Have had a change in factions, update all unit tables
            if bDebugMessages == true then LOG(sFunctionRef..': Will update recorded units following uef alliance changes so arti is detected, changing sides, Time='..GetGameTimeSeconds()) end
            ForkThread(UpdateAllRecordedUnitsFollowingTeamChange)
            --Operation trident - dont reclaim the civilians
        elseif ScenarioInfo.M1CivilianCity and M28Utilities.IsTableEmpty(ScenarioInfo.M1CivilianCity) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Will flag every unit in civilian city to not be a reclaim target, Time='..GetGameTimeSeconds()) end
            for iUnit, oUnit in ScenarioInfo.M1CivilianCity do
                oUnit[M28UnitInfo.refbIsReclaimTarget] = false
                if M28Utilities.IsTableEmpty(oUnit[M28UnitInfo.refiTeamsWithThisAsReclaimTarget]) == false then
                    for iEntry, iTeam in oUnit[M28UnitInfo.refiTeamsWithThisAsReclaimTarget] do
                        local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoUnitsToReclaim]) == false then
                            for iRecorded, oRecorded in tLZTeamData[M28Map.subreftoUnitsToReclaim] do
                                if oRecorded == oUnit then
                                    table.remove(tLZTeamData[M28Map.subreftoUnitsToReclaim], iRecorded)
                                    break
                                end
                            end
                        end
                    end
                    oUnit[M28UnitInfo.refiTeamsWithThisAsReclaimTarget] = nil
                    if bDebugMessages == true then LOG(sFunctionRef..': Removed unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from table of units wanting reclaiming in this zone for all teams') end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateAllRecordedUnitsFollowingTeamChange(tbOptionalVariableToBeTrue)
    --E.g. for Dawn M2 where order switches from enemy to ally of player team - clears all land and water zone details of enemy and allied units, and then re-records all the units
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateAllRecordedUnitsFollowingTeamChange'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(tbOptionalVariableToBeTrue == nil) then
        while not(tbOptionalVariableToBeTrue) do
            if bDebugMessages == true then LOG(sFunctionRef..': tbOptionalVariableToBeTrue is not nil but not true so will wait 1 tyick') end
            WaitTicks(1)
        end
    end

    local tiTeamsToConsider = {}
    for iTeam = 1, M28Team.iTotalTeamCount do
        if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 1 then
            table.insert(tiTeamsToConsider, iTeam)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': About to check if any units need updating from allies to enemies or vice versa, tiTeamsToConsider='..repru(tiTeamsToConsider)..'; Time='..GetGameTimeSeconds()) end
    function UpdateStatusOfFriendlyAndEnemyUnits(tLZOrWZTeamData, iTeam)
        local iTeamBrainIndex = M28Team.GetFirstActiveM28Brain(iTeam):GetArmyIndex()
        local toFriendlyUnits = {}
        local toEnemyUnits = {}
        local bChangedAlliesOrEnemies = false
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            for iUnit, oUnit in tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do
                if M28UnitInfo.IsUnitValid(oUnit) then
                    if IsAlly(oUnit:GetAIBrain():GetArmyIndex(), iTeamBrainIndex) then
                        table.insert(toFriendlyUnits, oUnit)
                    elseif IsEnemy(oUnit:GetAIBrain():GetArmyIndex(), iTeamBrainIndex) then
                        table.insert(toEnemyUnits, oUnit)
                        bChangedAlliesOrEnemies = true
                    else
                        bChangedAlliesOrEnemies = true
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) == false then
            for iUnit, oUnit in tLZOrWZTeamData[M28Map.subrefTEnemyUnits] do
                if M28UnitInfo.IsUnitValid(oUnit) then
                    if IsEnemy(oUnit:GetAIBrain():GetArmyIndex(), iTeamBrainIndex) then
                        table.insert(toEnemyUnits, oUnit)
                    elseif IsAlly(oUnit:GetAIBrain():GetArmyIndex(), iTeamBrainIndex) then
                        table.insert(toFriendlyUnits, oUnit)
                        bChangedAlliesOrEnemies = true
                    else
                        bChangedAlliesOrEnemies = true
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Updating for team '..iTeam..'; bChangedAlliesOrEnemies='..tostring(bChangedAlliesOrEnemies or false)) end
        if bChangedAlliesOrEnemies then
            if bDebugMessages == true then LOG(sFunctionRef..': Have a zone with units who have an updated ally/enemy status, iTeam='..iTeam) end
            tLZOrWZTeamData[M28Map.subrefTEnemyUnits] = nil
            tLZOrWZTeamData[M28Map.subrefTEnemyUnits] = toEnemyUnits
            tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits] = nil
            tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits] = toFriendlyUnits
        end
    end
    if M28Utilities.IsTableEmpty(tiTeamsToConsider) == false then
        for iPlateau, tPlateauData in M28Map.tAllPlateaus do
            for iLandZone, tLZData in tPlateauData[M28Map.subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if have any units to update status of for iPlateau='..iPlateau..'; iLandZone='..iLandZone) end
                for _, iTeam in tiTeamsToConsider do
                    UpdateStatusOfFriendlyAndEnemyUnits(tLZData[M28Map.subrefLZTeamData][iTeam], iTeam)
                end
            end
        end

        for iPond, tPondSubtable in M28Map.tPondDetails do
            if M28Utilities.IsTableEmpty(tPondSubtable[M28Map.subrefPondWaterZones]) == false then
                for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
                    for _, iTeam in tiTeamsToConsider do
                        UpdateStatusOfFriendlyAndEnemyUnits(tWZData[M28Map.subrefWZTeamData][iTeam], iTeam)
                    end
                end
            end
        end
        --Update neutral units
        for _, iTeam in tiTeamsToConsider do
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoCampaignNeutralUnitsNotRecorded]) == false then
                local oM28Brain
                local oFirstAnyM28Brain
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    if oBrain.M28AI then
                        if not(oFirstAnyM28Brain) then oFirstAnyM28Brain = oBrain end
                        if not(oM28Brain) and not(oBrain.CampaignAI) then oM28Brain = oBrain end
                    end
                end
                if not(oM28Brain) then oM28Brain = oFirstAnyM28Brain end
                if oM28Brain then
                    local iM28Index = oM28Brain:GetArmyIndex()

                    local tiUnitsToRemove = {}
                    for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftoCampaignNeutralUnitsNotRecorded] do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            --Rerecord if this is now an enemy
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is now an enemy to team '..iTeam..'; oM28Brain='..oM28Brain.Nickname..'; Unit brain owner='..oUnit:GetAIBrain().Nickname..'; Is enemy='..tostring(IsEnemy(oUnit:GetAIBrain():GetArmyIndex(), iM28Index))) end
                            if IsEnemy(oUnit:GetAIBrain():GetArmyIndex(), iM28Index) then
                                oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][iTeam] = nil
                                M28Team.AssignUnitToLandZoneOrPond(oM28Brain, oUnit)
                                table.insert(tiUnitsToRemove, iUnit)
                            end
                        else
                            table.insert(tiUnitsToRemove, iUnit)
                        end
                    end
                    if M28Utilities.IsTableEmpty(tiUnitsToRemove) == false then
                        local iToRemoveTotal = table.getn(tiUnitsToRemove)
                        for iCurRemoval = iToRemoveTotal, 1, -1 do
                            table.remove(tiUnitsToRemove, tiUnitsToRemove[iCurRemoval])
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MonitorObjectiveUnitsAndRemoveIfDead(tUnits, iMissionRef, vMissionStatusVariable)
    --Call via forked thread, intended e.g. for M2 Dawn of FA campaign where upgrading/destroying factories before the objective starts breaks the mission
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MonitorObjectiveUnitsAndRemoveIfDead'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if not(bActiveObjectiveUnitValidMonitorByObjective[iMissionRef]) then
        bActiveObjectiveUnitValidMonitorByObjective[iMissionRef] = true
        while vMissionStatusVariable.Active do
            M28Conditions.IsTableOfUnitsStillValid(tUnits)
            WaitTicks(1)
            if bDebugMessages == true then
                LOG(sFunctionRef..': Finished updating tUnits, is table empty='..tostring(M28Utilities.IsTableEmpty(tUnits))..'; Time='..GetGameTimeSeconds())
                if M28Utilities.IsTableEmpty(tUnits) == false then
                    LOG(sFunctionRef..': Size of tUnits='..table.getn(tUnits))
                end
            end
        end
        --Have moved onto next objective now
        if bDebugMessages == true then
            WaitSeconds(60)
            LOG(sFunctionRef..': after waiting a while size of tUnits='..table.getn(tUnits)..'; Will cycle through each unit')
            for iUnit, oUnit in tUnits do
                LOG(sFunctionRef..': oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Is dead='..tostring(oUnit.Dead or false)..'; reprs of unit='..reprs(oUnit))

            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedM27M28BrainCheck(aiBrain)
    WaitSeconds(1)
    LOG('Delayed brain check, brain nickname='..aiBrain.Nickname..'; .M27AI='..tostring(aiBrain.M27AI or false)..'; .M28AI='..tostring(aiBrain.M28AI or false))
    if aiBrain.M27AI and aiBrain.M28AI then aiBrain.M28AI = false end
end

function DecideWhetherToApplyM28ToCampaignAI(aiBrain, planName)
    --Wait a second so hopefully isenemy is more accurate
    WaitSeconds(1) --also need to update references to iTimeOfLatestBrainToCheckForM28Logic if changing this
    if M28Conditions.ApplyM28ToOtherAI(aiBrain) then
        local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
        aiBrain.M28AI = true
        M28Utilities.bM28AIInGame = true
        --LOG('M28 in game 4')
        if ScenarioInfo.Options.CmApplyAIx == 1 then
            aiBrain.CheatEnabled = true
        end
        if ScenarioInfo.Options.CmM28Easy == 1 then
            aiBrain.M28Easy = true
        end
        LOG('Setting AI to use M28, aiBrain.Nickname='..(aiBrain.Nickname or 'nil')..'; aiBrain[M28BrainSetupRun] before being cleared='..tostring(aiBrain['M28BrainSetupRun'] or false)..'; ScenarioInfo.Options.CmApplyAIx='..(ScenarioInfo.Options.CmApplyAIx or 'nil')..'; Brain flagged as cheat enabled='..tostring(aiBrain.CheatEnabled or false)..'; aiBrain.M28Easy='..tostring(aiBrain.M28Easy or false))
        ForkThread(M28Events.OnCreateBrain, aiBrain, planName, false)
    end
end


function RemoveUnitsFromPlatoon(oPlatoon, tUnits, bReturnToBase, oPlatoonToAddTo)
    --Intended to remove a particular unit from a platoon e.g. to avoid campaign AI overriding M28 AI
    --if bReturnToBase is true then units will be told to move to aiBrain's base
    --if tUnits isnt in oPlatoon then does nothing
    --oPlatoonToAddTo - optional, if empty, then will try to assign to army pool instead
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RemoveUnitsFromPlatoon'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if oPlatoon and oPlatoon.GetBrain and oPlatoon.GetPlan and not(oPlatoon.Dead) then
        local aiBrain = oPlatoon:GetBrain()

        if bDebugMessages == true then
            LOG(sFunctionRef..': About to list out every unit that is about to be removed')
            for iUnit, oUnit in tUnits do
                if oUnit.GetUnitId then LOG('iUnit='..iUnit..'; oUnitId='..oUnit.UnitId)
                else LOG('iUnit='..iUnit..'; Unit has no unitId') end
            end
        end
        if not(oPlatoonToAddTo == oPlatoon) then
            local oArmyPool = aiBrain:GetPlatoonUniquelyNamed('ArmyPool')
            local sName
            if oPlatoonToAddTo == nil then
                if bDebugMessages == true then LOG(sFunctionRef..': Will add units to army pool') end
                oPlatoonToAddTo = oArmyPool
                sName = 'ArmyPool'
            else
                if oPlatoonToAddTo == oArmyPool then sName = 'ArmyPool'
                else
                    if oPlatoonToAddTo.GetPlan then
                        sName = oPlatoonToAddTo:GetPlan()
                    end
                    if sName == nil then sName = 'nil' end

                    if bDebugMessages == true then LOG(sFunctionRef..': Adding unit to '..sName) end
                end
            end
            if oPlatoonToAddTo == nil then
                LOG(sFunctionRef..': WARNING: oPlatoonToAddTo is nil')
            else
                local sCurPlatoonName
                if oPlatoon == oArmyPool then
                    sCurPlatoonName = 'ArmyPool'
                else
                    sCurPlatoonName = oPlatoon:GetPlan()
                    if sCurPlatoonName == nil then sCurPlatoonName = 'None' end
                    if bDebugMessages == true then LOG(sFunctionRef..': sCurPlatoonName='..sCurPlatoonName) end
                end

                if not(sCurPlatoonName == sName) then
                    if bDebugMessages == true then
                        if oPlatoon == oArmyPool then
                            M28Utilities.ErrorHandler('ideally shouldnt have any units using armypool platoon now, see if can figure out where this came from')
                            LOG(sFunctionRef..': About to remove units from ArmyPool platoon and add to platoon '..sName)
                        else
                            LOG(sFunctionRef..': About to remove units from platoon '..oPlatoon:GetPlan())
                        end
                    end

                    if bReturnToBase == true then
                        if bDebugMessages == true then LOG(sFunctionRef..': Issuing move command to tUnits') end
                        if bDebugMessages == true then LOG(sFunctionRef..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                        local tBase = M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()]
                        for iUnit, oUnit in tUnits do
                            M28Orders.IssueTrackedClearCommands(oUnit)
                            M28Orders.IssueTrackedMove(oUnit, tBase, 10, false, 'PlatRB', false)
                        end
                    end
                    aiBrain:AssignUnitsToPlatoon(oPlatoonToAddTo, tUnits, 'Support', 'GrowthFormation')
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedCheckOfUnitsAtStartOfGame()
    --Sometimes e.g. in a campaign, the map has units pre-created meaning they dont trigger 'oncreate' logic - do a 1-off check at the start of the game for such units
    if not(bCheckForPrecreatedUnitsActive) then
        bCheckForPrecreatedUnitsActive = true
        while not(M28Map.bWaterZoneInitialCreation) or not(M28Map.bFirstM28TeamHasBeenInitialised) or GetGameTimeSeconds() <= 5 do
            WaitTicks(1)
            if GetGameTimeSeconds() >= 10 then break end
        end
        WaitTicks(1)
        local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
        for iBrain, oBrain in ArmyBrains do
            local tAllUnits = oBrain:GetListOfUnits(categories.ALLUNITS - categories.UNSELECTABLE - categories.UNTARGETABLE, false, true)
            if M28Utilities.IsTableEmpty(tAllUnits) == false then
                for iUnit, oUnit in tAllUnits do
                    if not(oUnit['M28OnCrRn']) and oUnit:GetFractionComplete() == 1 then
                        M28Events.OnCreate(oUnit)
                    end
                end
            end
        end
    end

end

function ConsiderUnpausingAllCreatedNukes(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderUnpausingAllCreatedNukes'

    WaitTicks(1) --to ensure we register the units
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iExistingSML = 0
    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
        iExistingSML = iExistingSML + oBrain:GetCurrentUnits(M28UnitInfo.refCategorySML - categories.EXPERIMENTAL)
        if bDebugMessages == true then LOG(sFunctionRef..': Cumulative SML units after considering brain '..oBrain.Nickname..'='..iExistingSML) end
    end
    if iExistingSML >= 4 then
        local tSMLToUnpause = {}
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            local tSML = oBrain:GetListOfUnits(M28UnitInfo.refCategorySML - categories.EXPERIMENTAL, false, true)
            if M28Utilities.IsTableEmpty(tSML) == false then
                for iSML, oSML in tSML do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oSML='..oSML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSML)..'; Have we registered the construction completion of this='..tostring(oSML.M28OnConstructedCalled or false)..'; Fraction complete='..oSML:GetFractionComplete()..'; Is paused nil='..tostring(oSML[M28UnitInfo.refbPaused] == nil)) end
                    if not(oSML.M28OnConstructedCalled) and oSML:GetFractionComplete() == 1 and oSML[M28UnitInfo.refbPaused] == nil then
                        table.insert(tSMLToUnpause, oSML)
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding SML to table of units to unpause; is SML actually paused='..tostring(oSML:IsPaused())) end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of SML to unpause empty='..tostring(M28Utilities.IsTableEmpty(tSMLToUnpause))) end
        if M28Utilities.IsTableEmpty(tSMLToUnpause) == false then
            ForkThread(DelayedUnpauseOfUnits, tSMLToUnpause, 1)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Have a nuke created with 100% completion but no onconstructed logic run, so will consider unpausing every nuke we have, iTeam='..iTeam..'; have got iExistingSML='..iExistingSML..'; have unpaused every SML we own if we have lots now') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedUnpauseOfUnits(tUnits, iDelayInSeconds)
    WaitSeconds(iDelayInSeconds)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DelayedUnpauseOfUnits'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Conditions.IsTableOfUnitsStillValid(tUnits) then
        local tUnitsForFurtherCheck = {}
        for iUnit, oUnit in tUnits do
            if bDebugMessages == true then LOG(sFunctionRef..': About to unpause unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is paused='..tostring(oUnit:IsPaused())..'; Time='..GetGameTimeSeconds()) end
            M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, false)
            if oUnit.EnableShield and oUnit.MyShield then oUnit:EnableShield() end
            if EntityCategoryContains(M28UnitInfo.refCategoryMobileLandShield, oUnit.UnitId) then
                table.insert(tUnitsForFurtherCheck, oUnit)
            end
        end
        if M28Utilities.IsTableEmpty(tUnitsForFurtherCheck) == false then
            ForkThread(SecondDelayedUnpauseCheckForMobileShields, tUnitsForFurtherCheck, 20)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code at time='..GetGameTimeSeconds()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SecondDelayedUnpauseCheckForMobileShields(tUnits, iDelayInSeconds)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SecondDelayedUnpauseCheckForMobileShields'

    WaitSeconds(iDelayInSeconds)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28Conditions.IsTableOfUnitsStillValid(tUnits) then
        if bDebugMessages == true then LOG(sFunctionRef..': Cycling through mobile shields, size of tUnits='..table.getn(tUnits)) end
        local iCurShield, iMaxShield
        for iUnit, oUnit in tUnits do
            iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, true)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering mobile shield oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iMaxShield='..iMaxShield..'; iCurShield='..iCurShield..'; if cur shield is 0 then will try and unpause, aiBrain owner='..oUnit:GetAIBrain().Nickname) end
            if iMaxShield > 0 and iCurShield == 0 then
                oUnit:EnableShield()
                M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, false)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DecideOnGeneralMapStrategy(aiBrain)
    --Decide if we want to consider ignoring T2 mex upgrading and going all in on T1 spam
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DecideOnGeneralMapStrategy'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --5-10km 1v1 but not winter duel, and can path to enemy by land
    if bDebugMessages == true then LOG(sFunctionRef..': Considering brain '..aiBrain.Nickname..'; Map size='..M28Map.iMapSize..'; Players at start='.. M28Team.iPlayersAtGameStart..'; aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]='..tostring(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand])) end
    if M28Map.iMapSize >= 225 and M28Map.iMapSize <= 512 and M28Team.iPlayersAtGameStart <= 4 and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] then
        --Dont stay at t1 if we have a high AIx modifier or no mexes on map, or a campaign map
        if bDebugMessages == true then LOG(sFunctionRef..': Is low mex map='..tostring(M28Map.bIsLowMexMap)..'; Resource mult='..(aiBrain[M28Economy.refiBrainResourceMultiplier] or 1)..'; Is campaign map='..tostring(M28Map.bIsCampaignMap)) end
        if not(M28Map.bIsLowMexMap) and (aiBrain[M28Economy.refiBrainResourceMultiplier] or 1) <= 1.7 and not(M28Map.bIsCampaignMap) then
            --Are there lots of mexes outside the core bases to fight over, and most are in the core base plateau?
            local iMexesOnMap = table.getn(M28Map.tMassPoints)
            if bDebugMessages == true then LOG(sFunctionRef..': iMexesOnMap='..iMexesOnMap) end
            if iMexesOnMap < 150 then
                local iMexesInStartZones = 0
                local iStartPlateau, iStartZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.GetPlayerStartPosition(aiBrain))
                if iStartPlateau and iStartZone and M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauTotalMexCount] >= 0.8 * iMexesOnMap then
                    local tiStartZones = {}
                    for iBrain, oBrain in tAllAIBrainsByArmyIndex do
                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to include brain start posiiton, oBrain='..oBrain.Nickname..'; Is civilian='..tostring(M28Conditions.IsCivilianBrain(oBrain))) end
                        if not(M28Conditions.IsCivilianBrain(oBrain)) then
                            local iPlateau, iZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.GetPlayerStartPosition(aiBrain))
                            if iPlateau == iStartPlateau then tiStartZones[iZone] = true end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tiStartZones) == false then
                        for iZone, bInclude in tiStartZones do
                            if bDebugMessages == true then LOG(sFunctionRef..': Will include mexes in zone '..iZone..'; Mex count for this zone='..(M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iZone][M28Map.subrefLZMexCount] or 0)) end
                            iMexesInStartZones = iMexesInStartZones + (M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iZone][M28Map.subrefLZMexCount] or 0)
                        end
                    end
                end
                local iMexPercentThreshold = 0.45
                if iMexesOnMap > 80 or M28Team.iPlayersAtGameStart >= 4 then
                    if iMexesOnMap > 130 then iMexPercentThreshold = 0.3
                    else iMexPercentThreshold = 0.375
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iMexesInStartZones='..iMexesInStartZones..'; iMexesOnMap='..iMexesOnMap..'; iMexPercentThreshold='..iMexPercentThreshold..'; M28Team.iPlayersAtGameStart='..M28Team.iPlayersAtGameStart) end
                if iMexesInStartZones < iMexPercentThreshold * iMexesOnMap then
                    M28Team.tTeamData[aiBrain.M28Team][M28Team.refbFocusOnT1Spam] = true
                    ForkThread(M28Team.MonitorLeavingT1SpamMode, aiBrain.M28Team)
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to avoid getting T2 mex upgrade') end
                end
            end
        end

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function ConsiderSlowdownForHighUnitCount()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderSlowdownForHighUnitCount'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if refiRoughTotalUnitsInGame >= 1500 then --in case the rough number isnt accurate
        local iM28Units = 0
        local oFirstM28Brain
        for iBrain, oBrain in ArmyBrains do
            if not(oBrain.M28IsDefeated) then
                iM28Units = iM28Units + (oBrain[refiRoughUnitCount] or 0)
                if (oBrain[refiRoughUnitCount] or 0) > 0 then oFirstM28Brain = oBrain end
            end
        end
        if iM28Units > 1750 or M28Land.iTicksPerLandCycle > 11 or M28Air.iExtraTicksToWaitBetweenAirCycles > 0 then
            M28Land.iTicksPerLandCycle = math.min(11, math.max(11, 11 + (iM28Units-1500) / 200))
            M28Air.iExtraTicksToWaitBetweenAirCycles = math.max(0,M28Land.iTicksPerLandCycle - 11)
            M28Navy.iTicksPerNavyCycle = math.min(40, M28Land.iTicksPerLandCycle) --want to cap at 40 as bombardment logic considers if we have been bombarding in the last 4s
            M28Chat.SendSlowdownModeMessage(oFirstM28Brain)
            if bDebugMessages == true then LOG(sFunctionRef..': Slowdown mode active, M28Land.iTicksPerLandCycle='..M28Land.iTicksPerLandCycle..'; M28Air.iExtraTicksToWaitBetweenAirCycles='..M28Air.iExtraTicksToWaitBetweenAirCycles) end
        else
            --Use default values
            M28Land.iTicksPerLandCycle = 11
            M28Air.iExtraTicksToWaitBetweenAirCycles = 0
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GlobalOverseer()
    --Called once at initial setup if we have an M28 in the game; can be used for tracking things on a global basis (instead of per brain or team)
    local iSlowCycleThreshold = 30
    local iCurSlowCycle = 0
    --ForkThread(DebugCheckProfiling) = true --will  output cur tick each log
    while M28Utilities.bM28AIInGame do
        iCurSlowCycle = iCurSlowCycle + 1
        if iCurSlowCycle >= iSlowCycleThreshold then
            iCurSlowCycle = 0
            ForkThread(ConsiderSlowdownForHighUnitCount)
        end
        WaitSeconds(1) --in case want to add per second logic in the future
    end
end





function DebugCheckProfiling(bJustShowTickCount)
    M28Utilities.ErrorHandler('Debug check profiling is enabled')
    local sFunctionRef = 'DebugCheckProfiling'
    local iTimeInSecondsToStartDetailedDebug = 2307.1999511719 --set to high number if first want to figure out the tick where this happens
    local bSetHook = false --Used for debugging
    if not(bDebugTickCheckerActive) then
        bDebugTickCheckerActive = true
        --Every tick list out the tick - use this function to help identify infinite loops
        while true do
            WaitTicks(1)
            LOG(sFunctionRef..': Cur time='..GetGameTimeSeconds())
            if not(bSetHook) and not(bJustShowTickCount) and GetGameTimeSeconds() >= iTimeInSecondsToStartDetailedDebug then
                bSetHook = true
                M28Profiler.bFunctionCallDebugOverride = true
                --M28Profiler.bGlobalDebugOverride = true --Only enable this if want more detail as it will make things really slow
                debug.sethook(M28Profiler.OutputRecentFunctionCalls, "c", 200)
                LOG(sFunctionRef..': Have started the main hook of function calls')
            end
        end
    end
end