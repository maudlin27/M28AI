---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 16/11/2022 07:20
---

local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Chat = import('/mods/M28AI/lua/AI/M28Chat.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
local NavUtils = M28Utilities.NavUtils


bInitialSetup = false
tAllActiveM28Brains = {} --[x] is just a unique integer starting with 1 (so table.getn works on this), not the armyindex; returns the aiBrain object
tAllAIBrainsByArmyIndex = {} --[x] is the brain army index, returns the aibrain
bDebugTickCheckerActive = false
iTimeOfLatestBrainToCheckForM28Logic = -1
iTimeLastPlayerDefeat = 0 --GetGameTimeSeconds that a player defeat is registered (so can hide error messages)
iT3EngineerUnitCapThresholdCount = 35 --i.e. wont ctrlk T3 engineers if we have fewer than this number

--Special settings - restrictions and norush
bUnitRestrictionsArePresent = false
bAirFactoriesCantBeBuilt = false
bNoRushActive = false
iNoRushRange = 0
iNoRushTimer = 0 --Gametimeseconds that norush should end
reftNoRushCentre = 'M28OverseerNRCtre' --against aiBrain
reftNoRushM28StartPoints = { } --start positions for all norush buildable locations
bActiveMissionChecker = false --true if are actively checking for mission objectives - now used for niche objectives to monitor
bPacifistModeActive = false --true if we have set certain zones to never be attacked (e.g. Cybran mission 4)
bHaveDisabledGunshipWeaponsForPacifism = false --true if we have disabled gunship weapons due to pacifism
tiPacifistZonesByPlateau = {} --[iPlateau], returns iLandOrWaterZone, for any zone flagged as pacificst
bBeginSessionTriggered = false
bCheckForPrecreatedUnitsActive = false
iMassFabRatio = 1 --e.g. some mods can improve mass fab resources given
bNonAISimModsActive = false

--Campaign specific variables
bActiveObjectiveUnitValidMonitorByObjective = {} --True if already are actively monitoring a particular unit
tbSpecialCodeForMission = {} --[x] is the mission reference, true if have run special code already

--aiBrain variables
refbInitialised = 'M28OvInt' --true if brain has started the main initialisation logic
refiDistanceToNearestEnemyBase = 'M28OverseerDistToNearestEnemyBase'
refoNearestEnemyBrain = 'M28OverseerNearestEnemyBrain'
refbCloseToUnitCap = 'M28OverseerCloseToUnitCap'
refiLastUnitCapTimeCheck = 'M28UnitCapChk' --Gametimeseconds that the brain last did a unit cap check
refbWillDoDelayedUnitCapCheck = 'M28UnitCapD' --true if we are already doing a delayed unit cap check
refiExpectedRemainingCap = 'M28OverseerUnitCap' --number of units to be built before we potentially hit the unit cap, i.e. used as a rough guide for when shoudl call the code to check the unit cap
refiUnitCapCategoriesDestroyed = 'M28OverseerLstCatDest' --Last category destroyed by unit cap logic
refiTimeOfLastUnitCapDeath = 'M28OverseerTmLstCpDth' --time we last ctrlkd a unit due to the unit cap
refiTemporarilySetAsAllyForTeam = 'M28TempSetAsAlly' --against brain, e.g. a civilian brain, returns the .M28Team number that the brain has been set as an ally of temporarily (to reveal civilians at start of game)
refiTransferedUnitCount = 'M28OvsrXfUC' --Increases by one each time units are transferred to a player
reftoTransferredUnitMexesAndFactoriesByCount = 'M28OvsrXfUT'
refiCombatLandScoutThreshold = 'M28OvsrCLnS' --number of aeon land scouts to use in a combat role
refbBuiltLongRangeLandUnit = 'M28BultLRU' -- true if we have constructed a long ranged DF land unit like a fatboy, so we prioritise building an omni if we havent already
refbCanBuildExperimentalShields = 'M28BuldExpSh'
refiExperimentalShieldCategory = 'M28ExpShC' --Includes the cheapest 'powerful' shield (so we dont build super-expensive ones that cost as much as a game ender, but also still build one tough enough to justify turtling logic)
reftbExperimentalShieldsConsidered = 'M28ExpShS' --[x] is the blueprint, returns true if we have already included in refiExperimentalShieldCategory
--Brain style variables to affect behaviour - set to true if to apply to the brain
refbPrioritiseLand = 'M28PersLand'
refbPrioritiseAir = 'M28PersAir'
refbPrioritiseNavy = 'M28PersNavy'
refbPrioritiseLowTech = 'M28PesLowTech'
refbPrioritiseHighTech = 'M28PersHighTech'
refbPrioritiseDefence = 'M28PersDef'
--Special strategies:
refbFirstBomber = 'M28FirstB'
refbBomberSnipe = 'M28BombS' --true if want to try and snipe enemy ACU (intended for Cybran and sometimes Seraphim, to try with a T2 bomber snipe)
refbStratsOverGunships = 'M28GtStrt' --true if want to try going heavy on strats instead of gunships first



--Global other variables
refiRoughTotalUnitsInGame = 0 --Very rough count of units in game, so can use more optimised code if this gets high
refiCurGETemplateGlobalCount = 0 --Used to spread out calculations for gameender templates
bLikelyGunUpgrade = false --true if anyone has a gun upgrade


function GetNearestEnemyBrain(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNearestEnemyBrain'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local oNearestBrainThatAreIgnoring
    if aiBrain[refoNearestEnemyBrain][M28Map.refbIgnoreForNearestPlayerIndexByTeam][aiBrain.M28Team] and not(aiBrain[refoNearestEnemyBrain].M28IsDefeated) and not(aiBrain[refoNearestEnemyBrain]:IsDefeated()) then oNearestBrainThatAreIgnoring = aiBrain[refoNearestEnemyBrain] end
    if (aiBrain[refoNearestEnemyBrain] and not(aiBrain[refoNearestEnemyBrain].M28IsDefeated) and not(aiBrain[refoNearestEnemyBrain]:IsDefeated()) and not(aiBrain[refoNearestEnemyBrain][M28Map.refbIgnoreForNearestPlayerIndexByTeam][aiBrain.M28Team])) or aiBrain.M28IsDefeated then
        if bDebugMessages == true then LOG(sFunctionRef..': Previously nearest enemy brain is still valid='..(aiBrain[refoNearestEnemyBrain].Nickname or 'nil')) end
        return aiBrain[refoNearestEnemyBrain]
    else
        if bDebugMessages == true then LOG(sFunctionRef..': aiBrain='..aiBrain.Nickname..'; GameTime='..GetGameTimeSeconds()..'; Is pathing complete='..tostring(M28Map.bMapLandSetupComplete)..'; Dont have a valid nearest enemy already recorded for aiBrain '..(aiBrain.Nickname or 'nil')..' with index '..aiBrain:GetArmyIndex()..' so will get a new one; are all enemies defeated for team '..aiBrain.M28Team..'='..tostring(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated])) end
        local oNearestBrain
        if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated] then
            --All enemies defeated so will consider civilians as enemy brains
            local oCivilianBrain
            if bDebugMessages == true then LOG(sFunctionRef..': All enemies defeated so will consider all brains including civilians') end
            for iCurBrain, oBrain in ArmyBrains do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering obrain '..(oBrain.Nickname or 'nil')..'; is enemy to us='..tostring(IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()))) end
                if IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()) then
                    oNearestBrain = oBrain
                    break
                elseif M28Conditions.IsCivilianBrain(oBrain) then
                    oCivilianBrain = oBrain
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': All normal enemies defeated, oNearestBrain='..(oNearestBrain.Nickname or 'nil')..'; oCivilianBrain='..(oCivilianBrain.Nickname or 'nil')) end

            if not (oNearestBrain) then
                oNearestBrain = oCivilianBrain
            end
        else
            local iCurDist
            local iMinDistToEnemy = 10000000
            if bDebugMessages == true then LOG(sFunctionRef .. ': Start before looping through brains; aiBrain personality=' .. ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality .. '; brain.Name=' .. aiBrain.Name) end

            for iCurBrain, oBrain in ArmyBrains do
                if bDebugMessages == true then LOG(sFunctionRef .. ': Start of brain loop, iCurBrain=' .. iCurBrain .. '; brain personality=' .. ScenarioInfo.ArmySetup[oBrain.Name].AIPersonality .. '; brain Nickname=' .. oBrain.Nickname .. '; Brain index=' .. oBrain:GetArmyIndex() .. '; if brain isnt equal to our AI brain then will get its start position etc. IsCivilian='..tostring(M28Conditions.IsCivilianBrain(oBrain))..'; IsEnemy='..tostring(IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()))..'; Is oBrain a .M28AI brain='..tostring(oBrain.M28AI or false)) end
                if not (oBrain == aiBrain) and (not (M28Conditions.IsCivilianBrain(oBrain)) and IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex())) and not(oBrain[M28Map.refbIgnoreForNearestPlayerIndexByTeam]) then
                    if bDebugMessages == true then LOG(sFunctionRef .. ': Brain is dif to aiBrain and a non civilian enemy so will record its start position number if it doesnt have one already') end

                    if not (oBrain:IsDefeated()) and not (oBrain.M28IsDefeated) then
                        --Redundancy for AI like DD that may not trigger the aibrain hook
                        if not(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()]) then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            M28Map.RecordBrainStartPoint(oBrain, (M28Map.bIsCampaignMap and GetGameTimeSeconds() >= 5 and not(M28Conditions.DoesAINicknameContainM28(oBrain.Nickname)) and oBrain.BrainType == 'AI'))
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

                        end
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Considering nearest enemy for our brain index '..aiBrain:GetArmyIndex()..'; enemy brain with index' .. oBrain:GetArmyIndex() .. ' and nickname '..(oBrain.Nickname or 'nil')..' is not defeated and is an enemy; M28Map.PlayerStartPoints='..repru( M28Map.PlayerStartPoints))
                            local iX, iZ = M28Map.GetPlayerStartPosition(oBrain, true)
                            LOG(sFunctionRef..': Enemy Start iX='..(iX or 'nil')..'; Start iZ+'..(iZ or 'nil'))
                        end
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(M28Map.GetPlayerStartPosition(aiBrain), M28Map.GetPlayerStartPosition(oBrain))
                        if iCurDist < iMinDistToEnemy then
                            iMinDistToEnemy = iCurDist
                            oNearestBrain = oBrain
                        end
                    end

                    --Strange bug where still returns true for empty slot - below line to avoid this:
                    --[[if GetGameTimeSeconds() <= 5 or brain:GetCurrentUnits(categories.ALLUNITS) > 0 then
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': brain has some units')
                        end
                        if M28Map.PlayerStartPoints[brain:GetArmyIndex()] then
                            iDistToCurEnemy = M28Utilities.GetDistanceBetweenPositions(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()], M28Map.PlayerStartPoints[brain:GetArmyIndex()])
                            if bDebugMessages == true then LOG(sFunctionRef..': Dist between brain and aibrain start points='..iDistToCurEnemy) end
                            if iDistToCurEnemy < iMinDistToEnemy then
                                iMinDistToEnemy = iDistToCurEnemy
                                iNearestEnemyIndex = brain:GetArmyIndex()
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': Current nearest enemy index=' .. iNearestEnemyIndex .. '; startp osition of this enemy=' .. repru(M28Map.PlayerStartPoints[iNearestEnemyIndex]))
                                end
                            end
                        else
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Map info doesnt have a start point for brain with index=' .. brain:GetArmyIndex()..' and nickanme='..(brain.Nickname or 'nil')..'; PlayerStartPoints='..repru(M28Map.PlayerStartPoints))
                            end
                        end
                    else
                        --Can have some cases where have an aibrain but no units, e.g. map Africa has ARMY_9 aibrain name, with no personality, that has no units; will flag the brain as being defeated to be safe if getgametimeseonds is more than 1min
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': WARNING: brain isnt defeated but has no units; brain:ArmyIndex=' .. brain:GetArmyIndex())
                        end
                        if GetGameTimeSeconds() >= 60 then brain.M28IsDefeated = true end
                    end--]]
                end
            end
        end
        if oNearestBrainThatAreIgnoring and not(oNearestBrain) then
            if bDebugMessages == true then LOG(sFunctionRef..': Will go with brain that are ignoring afterall') end
            oNearestBrain = oNearestBrainThatAreIgnoring
        end
        if not(oNearestBrain) then
            M28Utilities.ErrorHandler('Couldnt find a nearest brain to aiBrain='..aiBrain.Nickname)
            if GetGameTimeSeconds() <= 10 then M28Chat.SendMessage(aiBrain, 'NoEnemies', 'Unable to identify any enemies for '..(aiBrain.Nickname or 'a brain')..', M28 may not function properly', 0, 10000, false) end
            M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated] = true
            --Set the nearest enemy as the furthest away other brain (even if it isnt an enemy) - i.e. if do as furthest enemy then more likely to have units passing enemy units
            local iFurthestDist = 0
            local iCurDist
            for iBrain, oBrain in ArmyBrains do
                if not(oBrain == aiBrain) then
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(M28Map.GetPlayerStartPosition(aiBrain), M28Map.GetPlayerStartPosition(oBrain))
                    if iCurDist > iFurthestDist then
                        oNearestBrain = oBrain
                        iFurthestDist = iCurDist
                    end
                end
            end
        end
        aiBrain[refoNearestEnemyBrain] = oNearestBrain
    end
    return aiBrain[refoNearestEnemyBrain]
end

function GameSettingWarningsChecksAndInitialChatMessages(aiBrain)
    --Run once (i.e. no matter how many M28 brains are present will run max of one time) at start of the game if an M28 brain is present
    local sFunctionRef = 'GameSettingWarningsChecksAndInitialChatMessages'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Start of compatibility check.  Size of tAllActiveM28Brains=' .. table.getsize(tAllActiveM28Brains))
    end
    local sIncompatibleMessage = ''
    local bIncompatible = false
    local bHaveOtherAIMod = false


    if M28Utilities.IsTableEmpty(ScenarioInfo.Options.RestrictedCategories) == false then
        bIncompatible = true
        bUnitRestrictionsArePresent = true
        sIncompatibleMessage = sIncompatibleMessage .. ' Unit restrictions. '
    end
    --Check if we can build air factories
    local tFriendlyACU = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of friendly ACU empty='..tostring(M28Utilities.IsTableEmpty(tFriendlyACU))) end
    while M28Utilities.IsTableEmpty(tFriendlyACU) and GetGameTimeSeconds() < 20 do --UEF Campaign M1 - ACU spawns just after 10s
        WaitTicks(1)
        tFriendlyACU = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
        if bDebugMessages == true then LOG(sFunctionRef..': Is tFriendlyACU empty='..tostring( M28Utilities.IsTableEmpty(tFriendlyACU))..'; Brain='..aiBrain.Nickname..'; Time='..GetGameTimeSeconds()..'; Is allunits empty='..tostring(M28Utilities.IsTableEmpty(aiBrain:GetListOfUnits(categories.ALLUNITS, false, true)))) end
    end
    if M28Utilities.IsTableEmpty(tFriendlyACU) == false then
        --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition,               oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
        local sBlueprint = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryAirFactory, tFriendlyACU[1])
        if bDebugMessages == true then LOG(sFunctionRef..': If ACU '..tFriendlyACU[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tFriendlyACU[1])..' tries to build an air factory, sBLueprint is '..(sBlueprint or 'nil')) end
        local bCantBuild
        if not(sBlueprint) then
            bCantBuild = true
            if bDebugMessages == true then LOG(sFunctionRef..': Blueprint is nil so will set that cant build') end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Is blueprint '..sBlueprint..' restricted for brain '..aiBrain.Nickname..'='..tostring(M28UnitInfo.IsUnitRestricted(sBlueprint, aiBrain:GetArmyIndex()))) end
            if M28UnitInfo.IsUnitRestricted(sBlueprint, aiBrain:GetArmyIndex()) then
                bCantBuild = true
            end
        end
        if bCantBuild then
            bAirFactoriesCantBeBuilt = true
            if not(bUnitRestrictionsArePresent) then
                bUnitRestrictionsArePresent = true
                sIncompatibleMessage = sIncompatibleMessage .. ' Custom map script or mod preventing air factories'
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Setting bAirFactoriesCantBeBuilt to true, bAirFactoriesCantBeBuilt='..tostring(bAirFactoriesCantBeBuilt)) end
        end
    end
    if not(bUnitRestrictionsArePresent) then
        --Check if campaign or map has any active restrictions
        if M28Utilities.bFAFActive then
            if bDebugMessages == true then LOG(sFunctionRef..': bUnitRestrictionsArePresent='..tostring(bUnitRestrictionsArePresent)..'; Is getrestrictions empty='..tostring(M28Utilities.IsTableEmpty(import("/lua/game.lua").GetRestrictions()))..'; reprs of this='..reprs(import("/lua/game.lua").GetRestrictions())) end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Not in FAF so normal method of checking for unit restrictions wont work') end
        end
        if M28Utilities.bFAFActive and M28Utilities.IsTableEmpty(import("/lua/game.lua").GetRestrictions()) == false then
            bUnitRestrictionsArePresent = true
        end
    end


    if not (ScenarioInfo.Options.NoRushOption == "Off") then
        bIncompatible = true
        sIncompatibleMessage = sIncompatibleMessage .. ' No rush timer. '
    end
    --Check for non-AI sim-mods.  Thanks to Softles for pointing me towards the __active_mods variable
    local tSimMods = __active_mods or {}
    local tAIModNameWhitelist = { 'M27AI', 'AI-Swarm', 'AI-Uveso', 'AI: DilliDalli', 'Dalli AI', 'Dilli AI', 'M20AI', 'Marlo\'s Sorian AI edit', 'RNGAI', 'SACUAI', 'M28AI' }

    local tAIModNameWhereExpectAI = { 'AI-Swarm', 'AI-Uveso', 'AI: DilliDalli', 'Dalli AI', 'Dilli AI', 'M20AI', 'Marlo\'s Sorian AI edit', 'RNGAI', 'M27AI' } --Dont include M28 in this list, i.e. it shoudl be every AI except M28
    local tModIsOk = {}
    local bHaveOtherAI = false
    local sUnnecessaryAIMod
    local iUnnecessaryAIModCount = 0
    for iAI, sAI in tAIModNameWhitelist do
        tModIsOk[sAI] = true
    end

    local iSimModCount = 0
    local bFlyingEngineers
    local bM27InGame = false
    for iMod, tModData in tSimMods do
        if not (tModIsOk[tModData.name]) and tModData.enabled and not (tModData.ui_only) then
            iSimModCount = iSimModCount + 1
            bNonAISimModsActive = true
            if not(M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) then
                bIncompatible = true
                if iSimModCount == 1 then
                    sIncompatibleMessage = sIncompatibleMessage .. ' SIM mods '
                else
                    sIncompatibleMessage = sIncompatibleMessage .. '; '
                end
                sIncompatibleMessage = sIncompatibleMessage .. ' ' .. (tModData.name or 'UnknownName')
                if bDebugMessages == true then
                    LOG('Whitelist of mod names=' .. repru(tModIsOk))
                    LOG(sFunctionRef .. ' About to do reprs of the tModData for mod ' .. (tModData.name or 'nil')..': '..reprs(tModData))
                end

                if string.find(tModData.name, 'Flying engineers') then
                    bFlyingEngineers = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Have flying engineers mod enabled so will adjust engineer categories') end
                end
            end
        elseif tModIsOk[tModData.name] then
            if not(bHaveOtherAIMod) then
                for iAIMod, sAIMod in tAIModNameWhereExpectAI do
                    if sAIMod == tModData.name then
                        bHaveOtherAIMod = true
                        if sAIMod == 'M27AI' then bM27InGame = true end
                        break
                    end
                end
                if bHaveOtherAIMod then
                    --Do we have non-M28 AI?
                    for iBrain, oBrain in ArmyBrains do
                        if bDebugMessages == true then LOG(sFunctionRef..': Have another AI mod enabled. reprs of oBrain='..reprs(oBrain)..'; is BrainType empty='..tostring(oBrain.BrainType == 'nil')..'; is brian type an empty string='..tostring(oBrain.BrainType == '')) end
                        if ((oBrain.BrainType == 'AI' and not(oBrain.M28AI)) or oBrain.DilliDalli) and not(M28Conditions.IsCivilianBrain(oBrain)) then
                            bHaveOtherAI = true
                            if bDebugMessages == true then LOG('Have an AI for a brain') end
                            break
                        end
                    end
                end
            end
            if bHaveOtherAIMod and not(bHaveOtherAI) then
                local bUnnecessaryMod = false
                for iAIMod, sAIMod in tAIModNameWhereExpectAI do
                    if sAIMod == tModData.name then
                        bUnnecessaryMod = true
                        break
                    end
                end
                if bUnnecessaryMod then

                    iUnnecessaryAIModCount = iUnnecessaryAIModCount + 1
                    if iUnnecessaryAIModCount == 1 then
                        sUnnecessaryAIMod = tModData.name
                    else
                        sUnnecessaryAIMod = sUnnecessaryAIMod..', '..tModData.name
                    end
                end
            end
        end
    end

    if iSimModCount > 0 then
        sIncompatibleMessage = sIncompatibleMessage .. '. '
    end
    local bDontPlayWithM27 = false
    local iHumans = 0
    for iBrain, oBrain in ArmyBrains do
        if oBrain.BrainType == 'Human' then
            iHumans = iHumans + 1
        end
    end
    if bM27InGame then
        --Count how many players - if more than 1 then desync risk
        if iHumans > 1 then
            bDontPlayWithM27 = true --Azraeel came across desyncs when playing with M27 and M28 together
            bIncompatible = true
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Finished checking compatibility; compatibility message=' .. sIncompatibleMessage .. '; iSimModCount=' .. iSimModCount)
    end

    if iSimModCount > 0 then
        --Basic compatibiltiy with flying engineers mod - allow air engineers to be treated as engineers; also work on mods with similar effect but different name
        if bDebugMessages == true then LOG(sFunctionRef..': Checking for flying engineer compatibility, is table empty of units for T1 engi='..tostring(M28Utilities.IsTableEmpty(EntityCategoryGetUnitList(M28UnitInfo.refCategoryEngineer * categories.TECH1)))) end
        if not(bFlyingEngineers) and M28Utilities.IsTableEmpty(EntityCategoryGetUnitList(M28UnitInfo.refCategoryEngineer * categories.TECH1)) then bFlyingEngineers = true end
        if bFlyingEngineers then
            M28UnitInfo.refCategoryEngineer = M28UnitInfo.refCategoryEngineer + categories.ENGINEER * categories.AIR * categories.CONSTRUCTION - categories.EXPERIMENTAL
            if bDebugMessages == true then LOG(sFunctionRef..': Including air engineers in the engineer category; is xsl0105 an engineer='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryEngineer, 'xsl0105'))..'; Is it categories.ENGINEER='..tostring(EntityCategoryContains(categories.ENGINEER, 'xsl0105'))..'; is it categories.AIR='..tostring(EntityCategoryContains(categories.AIR, 'xsl0105'))..'; is it categories.construction='..tostring(EntityCategoryContains(categories.CONSTRUCTION, 'xsl0105'))) end
        end
        --BREWLAN compatibility - it adds the TRANSPORTATION category to units that cant transport, leading to errors when M28 tries using them or getting their cargo
        if categories.TORPEDOBOMBER then M28UnitInfo.refCategoryTransport = M28UnitInfo.refCategoryTransport - categories.TORPEDOBOMBER end --thanks to Balthazaar who gave this tip for checking if a custom category exists
    end

    if bIncompatible then
        if bDontPlayWithM27 then
            if sUnnecessaryAIMod and not(bHaveOtherAI) then
                --Disabled as seen a bunch of games with M27 enabled and M28 active with no desync
                --M28Chat.SendMessage(aiBrain, 'SendGameCompatibilityWarning', 'Sorry I don’t like it when M27AI is watching and adults are around - he teases me about how much better he is and sometimes the game desyncs.  Please disable the M27AI mod.', 15, 15)
            else
                --warning based on Az noting there were sometimes desyncs with M27 and M28 playing together
                M28Chat.SendMessage(aiBrain, 'SendGameCompatibilityWarning', 'Sorry I don’t get on well with my brother M27 when adults are around – he teases me about how much better he is and sometimes the game desyncs', 15, 15)
            end
        else
            M28Chat.SendMessage(aiBrain, 'SendGameCompatibilityWarning', 'Detected'..sIncompatibleMessage .. ' (v'..import('/mods/M28AI/mod_info.lua').version..') if you come across M28AI issues with these settings/mods let maudlin27 know via Discord', 0, 10)
        end
    end
    if not(bDontPlayWithM27) and bHaveOtherAIMod and not(bHaveOtherAI) and sUnnecessaryAIMod then
        M28Chat.SendMessage(aiBrain, 'UnnecessaryMods', 'No other AI detected, These AI mods can be disabled: '..sUnnecessaryAIMod, 1, 10)
    end
    if M28Utilities.bSteamActive then
        local bUsingForNormal = false
        local bUsingForEasy = false
        local sMessage
        for iBrain, oBrain in ArmyBrains do
            if oBrain.M28AI then
                if oBrain.M28Easy then
                    bUsingForEasy = true
                else
                    bUsingForNormal = true
                end
            end
        end
        if bUsingForEasy and bUsingForNormal then
            sMessage = 'M28AI active for AI: Normal and M28EasyAI for AI: Easy.'
        elseif bUsingForEasy then
            sMessage = 'M28EasyAI active for AI: Easy.'
        else
            sMessage = 'M28AI active for AI: Normal.'
        end
        sMessage = sMessage..'  See https://github.com/maudlin27/M28AI for the latest version; play M28AI on FAF For the best experience.  If you come across issues playing in steam please send maudlin27 a message on discord along with the replay.'
        M28Chat.SendMessage(aiBrain, 'SteamCompatibility', sMessage, 2, 10)
    elseif M28Utilities.bLoudModActive or M28Utilities.bQuietModActive then
        --Probably done enough testing that can drop the warning now
        --M28Chat.SendMessage(aiBrain, 'LOUDCompatibility', 'M28AI was originally developed for FAF.  It should be compatible with LOUD but less testing has been done - message maudlin27 on discord with the replay if you come across issues', 2, 10)
    end

    --Send log warning if have non-standard game options
    local tsNonStandardSettings = {}
    if not(tonumber(ScenarioInfo.Options.M28OvwR or tostring(0)) == 0) and ScenarioInfo.Options.M28OvwT then
        table.insert(tsNonStandardSettings, 'Overwhelm active, Rate='..tonumber(ScenarioInfo.Options.M28OvwR)..'; Time='..ScenarioInfo.Options.M28OvwT..'; Limit='..ScenarioInfo.Options.M28OvwC)
    end
    if M28Map.bIsCampaignMap then
        if not(ScenarioInfo.Options.CampAI == 4) then table.insert(tsNonStandardSettings, 'Campaign M28 allies/enemies value='.. ScenarioInfo.Options.CampAI..' (1=none,2=allies,3=enemy,4=both)') end
        if not(tonumber(ScenarioInfo.Options.CmpAIDelay) == 300) then table.insert(tsNonStandardSettings, 'Campaign combat delay='..tonumber(ScenarioInfo.Options.CmpAIDelay)) end
        if ScenarioInfo.Options.CmApplyAIx == 1 then  table.insert(tsNonStandardSettings, 'Campaign is using AIx for M28') end
        if not(ScenarioInfo.Options.CmM28CampPers == 2) then table.insert(tsNonStandardSettings, 'Campaign is using custom personality '..ScenarioInfo.Options.CmM28CampPers..' (1=Easy, 2=Adaptive') end
    end
    if tonumber(ScenarioInfo.Options.M28TimeBetweenOrders) > 1 then table.insert(tsNonStandardSettings, 'Time between orders='..tonumber(ScenarioInfo.Options.M28TimeBetweenOrders)) end
    if not(tonumber(ScenarioInfo.Options.M28Aggression or '1.0') == 1) then
        M28UnitInfo.iThreatFactor = tonumber(ScenarioInfo.Options.M28Aggression or '1.0')
        M28UnitInfo.bCustomThreatFactor = true
        table.insert(tsNonStandardSettings, 'M28 is using a custom aggression factor of '..M28UnitInfo.iThreatFactor)
    end
    if ScenarioInfo.Options.M28CPUPerformance == 1 then table.insert(tsNonStandardSettings, 'CPU performance mode active') end
    if ScenarioInfo.Options.M28PrioritiseBPs == 1 then table.insert(tsNonStandardSettings, 'Unit prioritisation disabled') end
    if not((ScenarioInfo.Options.M28DodgeMicro or 1) == 1) then table.insert(tsNonStandardSettings, 'Dodge micro limit='..tonumber(ScenarioInfo.Options.M28DodgeMicro)-2) end
    if not((ScenarioInfo.Options.M28HoverMicro or 1) == 1) then table.insert(tsNonStandardSettings, 'Hover micro limit='..tonumber(ScenarioInfo.Options.M28HoverMicro)-2) end
    if not(ScenarioInfo.Options.M28CombinedArmy == 2) then table.insert(tsNonStandardSettings, 'Combined army setting='..ScenarioInfo.Options.M28CombinedArmy..'; Inherit setting='..ScenarioInfo.Options.M28CAInherit) end
    if ScenarioInfo.Options.M28HoverMicro == 2 then table.insert(tsNonStandardSettings, 'Helpful teammate disabled') end
    if M28Utilities.IsTableEmpty(tsNonStandardSettings) == false then M28Utilities.ErrorHandler('Non standard settings='..reprs(tsNonStandardSettings), true) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function M28BrainCreated(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'M28BrainCreated'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': M28 Brain has just been created for aiBrain '..aiBrain.Nickname..'; Index='..aiBrain:GetArmyIndex()..'; bInitialSetup='..tostring(bInitialSetup or false)..'; Is campaign AI='..tostring(aiBrain.CampaignAI or false)..'; Cheat enabled='..tostring(aiBrain.CheatEnabled or false)..'; Time='..GetGameTimeSeconds()) end

    aiBrain.M28AI = true
    M28Utilities.bM28AIInGame = true
    table.insert(tAllActiveM28Brains, aiBrain)

    --Set cheat mult if this is campaign (which doesnt allow in game options)
    if aiBrain.CheatEnabled then
        if M28Utilities.bLoudModActive or M28Utilities.bQuietModActive or aiBrain.CheatValue then
            if bDebugMessages == true then LOG(sFunctionRef..': Setting build and resource cheat modifiers based on aiBrain.CheatValue='..aiBrain.CheatValue) end
            SetBuildAndResourceCheatModifiers(aiBrain, (aiBrain.CheatValue or 1), (aiBrain.CheatValue or 1), false)
        elseif not(ScenarioInfo.Options.CheatMult) then
            if bDebugMessages == true then LOG(sFunctionRef..': No cheat mult in scenario options so will set to 1.5 for build and resource') end
            SetBuildAndResourceCheatModifiers(aiBrain, 1.5, 1.5)
        elseif aiBrain.CheatEnabled and (aiBrain.CampaignAI or M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) and ScenarioInfo.Options.CmApplyAIx == 1 then
            if bDebugMessages == true then LOG(sFunctionRef..': Will apply AIx modifiers to brain '..aiBrain.Nickname) end
            SetBuildAndResourceCheatModifiers(aiBrain, tonumber(ScenarioInfo.Options.CheatMult), tonumber(ScenarioInfo.Options.BuildMult), true)
        elseif aiBrain.CheatEnabled then
            SetBuildAndResourceCheatModifiers(aiBrain, (aiBrain.CheatValue or tonumber(ScenarioInfo.Options.CheatMult) or 1), (aiBrain.CheatValue or tonumber(ScenarioInfo.Options.CheatMult) or 1), true, nil, true)
        end
    end

    --Set micro levels
    if not((ScenarioInfo.Options.M28DodgeMicro or 1) == 1) then
        local iDodgeMicroLimit
        if ScenarioInfo.Options.M28DodgeMicro == 2 then iDodgeMicroLimit = 0
        else iDodgeMicroLimit = tonumber(ScenarioInfo.Options.M28DodgeMicro) - 2
        end
        aiBrain[M28Micro.refiMaxUnitsToDodgeMicroAtOnce] = iDodgeMicroLimit
        aiBrain[M28Micro.refiCurUnitsDodging] = 0
    end
    if not((ScenarioInfo.Options.M28HoverMicro or 1) == 1) then
        if bDebugMessages == true then LOG(sFunctionRef..': ScenarioInfo.Options.M28HoverMicro='..(ScenarioInfo.Options.M28HoverMicro or 'nil')) end
        local iHoverMicroLimit
        if ScenarioInfo.Options.M28HoverMicro == 2 then iHoverMicroLimit = 0
        else iHoverMicroLimit = tonumber(ScenarioInfo.Options.M28HoverMicro) - 2
        end
        aiBrain[M28Micro.refiMaxUnitsToHoverMicroAtOnce] = iHoverMicroLimit
        aiBrain[M28Micro.refiCurUnitsHoverMicroing] = 0
    end

    --Setup AI personality for this
    M28Chat.AssignAIPersonalityAndRating(aiBrain)
    --Set easy flag
    if ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28aie' or ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28aiecheat' then
        aiBrain.M28Easy = true
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering if dealing with easy AI, M28Easy='..tostring(aiBrain.M28Easy or false)) end


    if not(bInitialSetup) then
        bInitialSetup = true
        local LoudCompatibility = import('/mods/M28AI/lua/AI/LOUD/M28OtherLOUDCompatibility.lua')
        if not(M28Utilities.bFAFActive) or not(_G.reprs) then LoudCompatibility.AddReprCommands() end --If LOUD is active will have already called this
        if bDebugMessages == true then LOG(sFunctionRef..': About to do one-off setup for all brains, will also fork various threads including for overwhelm, Overwhelm rate='..tonumber(ScenarioInfo.Options.M28OvwR or tostring(0))..'; ScenarioInfo.Options.M28OvwT='..(ScenarioInfo.Options.M28OvwT or 'nil')) end
        M28Utilities.bM28AIInGame = true
        --Specify if performance mode enabled
        if ScenarioInfo.Options.M28CPUPerformance == 1 then M28Utilities.bCPUPerformanceMode = true end
        --LOG('M28 in game 3')

        --Get the first non-human M28Brain
        local oChatBrain = aiBrain
        if aiBrain.BrainType == 'Human' then
            for iBrain, oBrain in ArmyBrains do
                if oBrain.M28AI and not(oBrain.BrainType == 'Human') then oChatBrain = oBrain break end
            end
        end

        --Send a message warning players this could take a while
        M28Chat.SendMessage(oChatBrain, 'LoadingMap', 'Analysing map (M28 v'..import('/mods/M28AI/mod_info.lua').version..'), wait a minute', 0, 10000, false)

        ForkThread(GameSettingWarningsChecksAndInitialChatMessages, oChatBrain)
        if bDebugMessages == true then LOG(sFunctionRef..': oChatBrain='..oChatBrain.Nickname..'; ScenarioInfo.Options.M28CombinedArmy='..(ScenarioInfo.Options.M28CombinedArmy or 'nil')..'; PerformanceMode='..tostring(M28Utilities.bCPUPerformanceMode)) end
        ForkThread(M28Map.SetupMap)
        ForkThread(UpdateMaxUnitCapForRelevantBrains)
        ForkThread(M28Building.DetermineBuildingExpectedValues)
        ForkThread(M28UnitInfo.CalculateBlueprintThreatsByType) --Records air and ground threat values for every blueprint
        if not(tonumber(ScenarioInfo.Options.M28OvwR or tostring(0)) == 0) and ScenarioInfo.Options.M28OvwT then
            ForkThread(M28Economy.AdjustAIxOverwhelmRate)
        end
        ForkThread(GlobalOverseer)
        ForkThread(SetM28ActiveFlag)
        if not(tonumber(ScenarioInfo.Options.M28Aggression or '1.0') == 1) then
            M28UnitInfo.iThreatFactor = tonumber(ScenarioInfo.Options.M28Aggression or '1.0')
            M28UnitInfo.bCustomThreatFactor = true
        end
    end
    LOG('Calling overseer manager via a fork')
    ForkThread(OverseerManager, aiBrain)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function SetupNoRushDetails(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupNoRushDetails'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end

    if ScenarioInfo.Options.NoRushOption  and not(ScenarioInfo.Options.NoRushOption == 'Off') then
        if bDebugMessages == true then LOG(sFunctionRef..': No rush isnt active, will record details') end
        if not(bNoRushActive) then --This is the first time for any AI that this is run (redundancy)
            if bDebugMessages == true then LOG(sFunctionRef..': Log of ScenarioInfo='..repru(ScenarioInfo)) end
            bNoRushActive = true
            iNoRushTimer = tonumber(ScenarioInfo.Options.NoRushOption) * 60
            ForkThread(NoRushMonitor)
            if bDebugMessages == true then LOG(sFunctionRef..': First time have run this so ahve set bNoRushActive='..tostring(bNoRushActive)..' and started iNoRushTimer for '..iNoRushTimer..' to change norush back to false') end
        end
        --Setup details of norush range for each M28AI
        if bNoRushActive then
            local tMapInfo = ScenarioInfo
            aiBrain[reftNoRushCentre] = {M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()][1], 0, M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()][3]}
            local sXRef = 'norushoffsetX_ARMY_'..aiBrain:GetArmyIndex()
            local sZRef = 'norushoffsetY_ARMY_'..aiBrain:GetArmyIndex()
            if bDebugMessages == true then LOG(sFunctionRef..': Checking norush adjustments, sXRef='..sXRef..'; sZRef='..sZRef..'; MapInfoX='..(tMapInfo[sXRef] or 'nil')..'; MapInfoZ='..(tMapInfo[sZRef] or 'nil')..'; aiBrain[reftNoRushCentre] before adjustment='..repru(aiBrain[reftNoRushCentre])) end
            if tMapInfo[sXRef] then aiBrain[reftNoRushCentre][1] = aiBrain[reftNoRushCentre][1] + (tMapInfo[sXRef] or 0) end
            if tMapInfo[sZRef] then aiBrain[reftNoRushCentre][3] = aiBrain[reftNoRushCentre][3] + (tMapInfo[sZRef] or 0) end
            aiBrain[reftNoRushCentre][2] = GetTerrainHeight(aiBrain[reftNoRushCentre][1], aiBrain[reftNoRushCentre][3])
            iNoRushRange = tMapInfo.norushradius
            table.insert(reftNoRushM28StartPoints, aiBrain[reftNoRushCentre])
            if bDebugMessages == true then
                LOG(sFunctionRef..': Have recorded key norush details for the ai with index='..aiBrain:GetArmyIndex()..'; iNoRushRange='..iNoRushRange..'; aiBrain[reftNoRushCentre]='..repru(aiBrain[reftNoRushCentre])..'; will draw a circle now in white around the area')
                M28Utilities.DrawCircleAtTarget(aiBrain[reftNoRushCentre], 7, 500, iNoRushRange)
            end

        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': No rush isnt active') end
        bNoRushActive = false --(redundancy)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function NoRushMonitor()
    local sFunctionRef = 'NoRushMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitSeconds(iNoRushTimer)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    bNoRushActive = false
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function TestCustom(aiBrain)
    --LOG('MObile SMD blueprint: '..repru(__blueprints['srl0321']))
    M28Map.DrawSpecificLandZone(22, 34, 3)
    M28Utilities.ErrorHandler('Disable testcustom code for final')
end

function UpdateMaxUnitCapForRelevantBrains()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateMaxUnitCapForRelevantBrains'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    for iBrain, oBrain in tAllAIBrainsByArmyIndex do
        if not(M28Map.bIsCampaignMap) or not(oBrain.BrainType == 'AI') or oBrain.M28AI or oBrain.M27AI then
            if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; About to update max unit cap for brian '..oBrain.Nickname..'; Brain type='..(oBrain.BrainType or 'nil')) end
            RefreshMaxUnitCap(oBrain)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshMaxUnitCap(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshUnitCap'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; About to set max unit cap for brain '..aiBrain.Nickname..'; Unit cap per scenarioInfo='..(ScenarioInfo.Options.UnitCap or 'nil')..'; Unit cap before update='..aiBrain:GetArmyStat("UnitCap_MaxCap", 0).Value) end
    if ScenarioInfo.Options.UnitCap then
        local iUnitCap = tonumber(ScenarioInfo.Options.UnitCap)
        local iIndex = aiBrain:GetArmyIndex()
        --SetIgnoreArmyUnitCap(iIndex, true) --Use this and below commented line to ignore unit cap altogther I think based on usage in base FAF code
        --aiBrain.IgnoreArmyCaps = true
        SetArmyUnitCap(iIndex, iUnitCap)
        if bDebugMessages == true then LOG(sFunctionRef..': Brian unit cap after update='..aiBrain:GetArmyStat("UnitCap_MaxCap", 0).Value) end
    else
        M28Utilities.ErrorHandler('No unit cap specified', true)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function Initialisation(aiBrain)
    --Called after 1 tick has passed so all aibrains should hopefully exist now
    --v24 - delay as want to wait until onbeginsession has started for navmesh to generate properly
    local sFunctionRef = 'Initialisation'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    while not(bBeginSessionTriggered) and GetGameTimeSeconds() <= 4 do
        WaitTicks(1)
    end
    WaitTicks(1) --make sure brain setup will have run
    aiBrain[refbInitialised] = true
    if bDebugMessages == true then LOG('About to proceed with initialisation, aiBrain='..aiBrain.Nickname..'; bBeginSessionTriggered='..tostring(bBeginSessionTriggered or false)) end
    ForkThread(SetupNoRushDetails, aiBrain)
    ForkThread(M28Team.RecordAllPlayers)
    local iWaitCount = 0
    while not(aiBrain.M28Team) do
        if bDebugMessages == true then LOG(sFunctionRef..': Dont have a team assigned yet so will wait 1 tick') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        iWaitCount = iWaitCount + 1
        if iWaitCount >= 10 then
            M28Utilities.ErrorHandler('Dont have a team assigned for brain '..aiBrain.Nickname..'; will create a new team for it as a redundancy')
            M28Team.CreateNewTeam(aiBrain)
        end
    end
    ForkThread(M28Map.CheckIfLowMexMap)
    ForkThread(M28Economy.EconomyInitialisation, aiBrain)
    ForkThread(M28Engineer.EngineerInitialisation, aiBrain)
    ForkThread(M28ACU.ManageACU, aiBrain)
    ForkThread(M28Factory.SetPriorityPreferredUnitsByCategory, aiBrain)
    ForkThread(M28Factory.IdleFactoryMonitor, aiBrain)
    ForkThread(M28Map.RecordPondToExpandTo, aiBrain)
    --ForkThread(RevealCiviliansToAI, aiBrain)
    ForkThread(RevealCivilainsToAIByGivingVision, aiBrain)
    ForkThread(RefreshMaxUnitCap, aiBrain) --This logic is  called from a number of palces to try and ensure it overrides things that might be set elsewhere
    ForkThread(DelayedCheckOfUnitsAtStartOfGame)
    ForkThread(DecideOnGeneralMapStrategy, aiBrain)
    ForkThread(M28Chat.ConsiderPerTeamStartMessage, aiBrain)
    if bDebugMessages == true then LOG(sFunctionRef..': Finished initialisation') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckUnitCap(aiBrain)
    local sFunctionRef = 'CheckUnitCap'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if GetGameTimeSeconds() - (aiBrain[refiLastUnitCapTimeCheck] or -1) >= 0.5 then
        aiBrain[refiLastUnitCapTimeCheck] = GetGameTimeSeconds()
        --local iUnitCap = tonumber(ScenarioInfo.Options.UnitCap)
        --Use below method in case a mod has changed this
        local oArmy = aiBrain:GetArmyIndex()
        local iUnitCap = GetArmyUnitCap(oArmy)
        --local armies = ListArmies()
        --for i, army in armies do
        --end
        local iCurUnits = GetArmyUnitCostTotal(aiBrain:GetArmyIndex()) --aiBrain:GetCurrentUnits(categories.ALLUNITS - M28UnitInfo.refCategoryWall) + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryWall) * 0.25
        local iCurFactories = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory)
        local iThreshold = math.min(30, math.max(math.ceil(iUnitCap * 0.02), 10, iCurFactories * 0.5))
        local iCurUnitsDestroyed = 0
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; iCurUnits='..iCurUnits..'; iUnitCap='..iUnitCap..'; iThreshold='..iThreshold) end
        if iCurUnits > (iUnitCap - iThreshold * 5) then
            aiBrain[refbCloseToUnitCap] = true
            M28Team.tTeamData[aiBrain.M28Team][M28Team.refiTimeLastNearUnitCap] = GetGameTimeSeconds()
            local iMaxToDestroy = math.max(5, math.ceil(iUnitCap * 0.01), math.max(20, iCurFactories) - (iUnitCap - iCurUnits))
            if iUnitCap - iCurUnits < 10 then iMaxToDestroy = math.max(10, iMaxToDestroy) end
            local bReconsiderShortly = false
            if iMaxToDestroy > 10 then
                iMaxToDestroy = 10
                bReconsiderShortly = true
            end
            local tUnitsToDestroy
            local tiCategoryToDestroy = {
                [-2] = M28UnitInfo.refCategoryAllAir * categories.TECH3 + M28UnitInfo.refCategoryStructure * categories.TECH1 + M28UnitInfo.refCategoryStructure * categories.TECH2 - M28UnitInfo.refCategoryMex - categories.EXPERIMENTAL - categories.COMMAND,
                [-1] = M28UnitInfo.refCategoryMobileLand + categories.NAVAL * categories.MOBILE - categories.EXPERIMENTAL - categories.COMMAND - categories.SUBCOMMANDER,
                [0] = categories.TECH1 - categories.COMMAND - M28UnitInfo.refCategoryAirStaging - M28UnitInfo.refCategoryT1Mex + M28UnitInfo.refCategoryAllAir * categories.TECH2 - M28UnitInfo.refCategoryTransport * categories.TECH2 - M28UnitInfo.refCategoryTorpBomber * categories.TECH2 -M28UnitInfo.refCategoryAllHQFactories + categories.TECH2 * M28UnitInfo.refCategoryMobileLandShield - categories.INSIGNIFICANTUNIT,
                [1] = M28UnitInfo.refCategoryAllAir * categories.TECH1 + categories.NAVAL * categories.MOBILE * categories.TECH1 - categories.INSIGNIFICANTUNIT,
                [2] = M28UnitInfo.refCategoryMobileLand * categories.TECH2 - categories.COMMAND - M28UnitInfo.refCategoryMobileLandShield - M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryAirScout * categories.TECH1 + M28UnitInfo.refCategoryAirAA * categories.TECH1 - categories.INSIGNIFICANTUNIT,
                [3] = M28UnitInfo.refCategoryMobileLand * categories.TECH1 - categories.COMMAND - categories.INSIGNIFICANTUNIT,
                [4] = M28UnitInfo.refCategoryWall + M28UnitInfo.refCategoryEngineer - categories.TECH3 + M28UnitInfo.refCategoryMobileLand * categories.TECH1 - categories.COMMAND - M28UnitInfo.refCategoryLandScout - categories.INSIGNIFICANTUNIT,
            }
            --Adjust these categories for special cases
            if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyLandFactoryTech] == 1 and (M28Map.bIsCampaignMap or bUnitRestrictionsArePresent) then
                --exclude T1 land from category 4
                tiCategoryToDestroy[4] =  M28UnitInfo.refCategoryWall + M28UnitInfo.refCategoryEngineer - categories.TECH3 - categories.INSIGNIFICANTUNIT
            end
            if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyFactoryTech] < 3 or ((M28Map.bIsCampaignMap or bUnitRestrictionsArePresent) and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * categories.TECH3) == 0) then
                if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyFactoryTech] == 1 then
                    tiCategoryToDestroy[4] = tiCategoryToDestroy[4] - M28UnitInfo.refCategoryEngineer
                else
                    tiCategoryToDestroy[4] = tiCategoryToDestroy[4] - M28UnitInfo.refCategoryEngineer * categories.TECH2
                end
            end
            if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyLandFactoryTech] == 2 and (M28Map.bIsCampaignMap or bUnitRestrictionsArePresent) and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] then
                --Exclude MML from category 2
                tiCategoryToDestroy[2] = M28UnitInfo.refCategoryMobileLand * categories.TECH2 - categories.COMMAND - M28UnitInfo.refCategoryMAA -M28UnitInfo.refCategoryMML + M28UnitInfo.refCategoryAirScout + M28UnitInfo.refCategoryAirAA * categories.TECH1 - categories.INSIGNIFICANTUNIT
            end
            --If have no T2+ power, then dont include T1 power in units to ctrlK
            if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower - categories.TECH1) == 0 then
                tiCategoryToDestroy[3] = tiCategoryToDestroy[3] - M28UnitInfo.refCategoryPower
            end

            --If have no asfs then exclude inties from cat 2
            if bDebugMessages == true then LOG(sFunctionRef..': Cur T2+ power='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower - categories.TECH1)..'; Cur ASFs='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirAA * categories.TECH3)) end
            if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirAA * categories.TECH3) == 0 then
                tiCategoryToDestroy[2] = tiCategoryToDestroy[2] - M28UnitInfo.refCategoryAirAA
                tiCategoryToDestroy[1] = tiCategoryToDestroy[1] - M28UnitInfo.refCategoryAirAA
                if bDebugMessages == true then LOG(sFunctionRef..': Excluding inties from being ctrlkd from category 1 and 2') end
                if iUnitCap >= 500 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirAA) <= 50 then
                    tiCategoryToDestroy[0] = tiCategoryToDestroy[1] - M28UnitInfo.refCategoryAirAA
                end
            end

            --If exp count is 0 then remove cat -1
            if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to include factories in the -2 category to destroy, Exp count='..M28Team.tTeamData[aiBrain.M28Team][M28Team.refiConstructedExperimentalCount]..'; Lowest unit cap adj level='..(M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] or 'nil')..'; Mass%='..aiBrain:GetEconomyStoredRatio('MASS')..'; Energy%='..aiBrain:GetEconomyStoredRatio('ENERGY')..'; Cur land facs='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory)..'; Current air facs='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory)) end
            if M28Team.tTeamData[aiBrain.M28Team][M28Team.refiConstructedExperimentalCount] == 0 then
                --Include t3 land facs in cat-2 if too many of them (if likely overflowing)
                if M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] < 0 and aiBrain:GetEconomyStoredRatio('MASS') >= 0.95 and aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.99 then
                    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory) >= 30 then
                        tiCategoryToDestroy[-2] = tiCategoryToDestroy[-2] + M28UnitInfo.refCategoryLandFactory
                    end
                    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) >= 40 then
                        tiCategoryToDestroy[-2] = tiCategoryToDestroy[-2] + M28UnitInfo.refCategoryAirFactory
                    end
                end
            else
                --If we have <35 T3 engis then exclude engineers from cat -1
                if (M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] or 1) <= 0 then
                    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer) < iT3EngineerUnitCapThresholdCount then
                        tiCategoryToDestroy[-1] = tiCategoryToDestroy[-1] - M28UnitInfo.refCategoryEngineer * categories.TECH3
                    end
                end
                --Include T3 land factories if we have too many of them
                if M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] < 0 then
                    if aiBrain:GetEconomyStoredRatio('MASS') >= 0.5 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory) >= 16 then
                        tiCategoryToDestroy[-2] = tiCategoryToDestroy[-2] + M28UnitInfo.refCategoryLandFactory
                    end
                    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) >= 20 then
                        tiCategoryToDestroy[-2] = tiCategoryToDestroy[-2] + M28UnitInfo.refCategoryAirFactory
                    end
                end
            end


            if M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] <= 2 then
                --If have no t3 gunships then keep t2 in cat 0
                if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryGunship * categories.TECH3) == 0 then
                    tiCategoryToDestroy[0] = tiCategoryToDestroy[0] - M28UnitInfo.refCategoryGunship
                end
                --Dont exclude T2 tanks if we have no t3 tanks
                if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMobileLand * categories.TECH3) == 0 then
                    tiCategoryToDestroy[2] = M28UnitInfo.refCategoryMobileLand * categories.TECH1 - categories.COMMAND
                    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryGunship) > 0 then
                        tiCategoryToDestroy[2] = M28UnitInfo.refCategoryMobileLand * categories.TECH1 - categories.COMMAND + M28UnitInfo.refCategoryBomber * categories.TECH1
                    end
                else
                    --exclude t2 maa if we have t3 maa
                    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) > 0 then
                        tiCategoryToDestroy[0] = tiCategoryToDestroy[0] + M28UnitInfo.refCategoryMAA * categories.TECH2
                    end
                end
            end

            --Restrict T3 land combat units being built if we have experimental level units and are at the lowest level of unit cap
            if M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] <= 0 and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryExperimentalLevel) > 0 and aiBrain:GetCurrentUnits(tiCategoryToDestroy[0]) <= 10 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandCombat * categories.TECH3 - categories.SUBCOMMANDER) >= 20 then
                tiCategoryToDestroy[0] = tiCategoryToDestroy[0] + M28UnitInfo.refCategoryLandCombat * categories.TECH3 - categories.SUBCOMMANDER
            end



            if bDebugMessages == true then LOG(sFunctionRef..': We are over the threshold for ctrlking units') end
            if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer) > math.max(30, iUnitCap * 0.35) then tiCategoryToDestroy[0] = tiCategoryToDestroy[0] + M28UnitInfo.refCategoryEngineer end
            local iCumulativeCategory = tiCategoryToDestroy[4]
            local bKilledUnit = false
            for iAdjustmentLevel = 4, -2, -1 do
                if iAdjustmentLevel < 4 then
                    iCumulativeCategory = iCumulativeCategory + tiCategoryToDestroy[iAdjustmentLevel]
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iCurUnitsDestroyed so far='..iCurUnitsDestroyed..'; iMaxToDestroy='..iMaxToDestroy..'; iAdjustmentLevel='..iAdjustmentLevel..'; iCurUnits='..iCurUnits..'; Unit cap='..iUnitCap..'; iThreshold='..iThreshold) end
                if tiCategoryToDestroy[iAdjustmentLevel] then
                    if iCurUnits > (iUnitCap - iThreshold * iAdjustmentLevel) or iCurUnitsDestroyed == 0 then
                        tUnitsToDestroy = aiBrain:GetListOfUnits(tiCategoryToDestroy[iAdjustmentLevel], false, false)
                        if M28Utilities.IsTableEmpty(tUnitsToDestroy) == false then
                            M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] = math.min((M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] or 100), iAdjustmentLevel)
                            if iAdjustmentLevel <= 1 then M28Engineer.tiActionCategory.refActionBuildAA = M28UnitInfo.refCategoryStructureAA end --allow experimental AA when close to unit cap
                            --Clear any prioritisation of bombers if we have penetration bombers, and instead prioritise penetration bombers
                            if categories.saa0314 and categories.saa0313 then
                                --We have penetration fighters - prioritise these over normal figheters and bombers
                                if (aiBrain[reftBlueprintPriorityOverride]['saa0314'] or 0) <= 0 or (aiBrain[reftBlueprintPriorityOverride]['saa0313'] or 0) <= 0 then
                                    --Penetration bombers
                                    aiBrain[reftBlueprintPriorityOverride]['saa0314'] = 1
                                    aiBrain[reftBlueprintPriorityOverride]['sea0314'] = 1
                                    aiBrain[reftBlueprintPriorityOverride]['sra0314'] = 1
                                    aiBrain[reftBlueprintPriorityOverride]['ssa0314'] = 1
                                    --Penetration fighters
                                    aiBrain[reftBlueprintPriorityOverride]['saa0313'] = 1
                                    aiBrain[reftBlueprintPriorityOverride]['sea0313'] = 1
                                    aiBrain[reftBlueprintPriorityOverride]['sra0313'] = 1
                                    aiBrain[reftBlueprintPriorityOverride]['ssa0313'] = 1
                                    --Normal bombers
                                    if (aiBrain[reftBlueprintPriorityOverride]['uea0304'] or 0) > 0 then aiBrain[reftBlueprintPriorityOverride]['uea0304'] = nil end
                                    if (aiBrain[reftBlueprintPriorityOverride]['ura0304'] or 0) > 0 then aiBrain[reftBlueprintPriorityOverride]['ura0304'] = nil end
                                    if (aiBrain[reftBlueprintPriorityOverride]['uaa0304'] or 0) > 0 then aiBrain[reftBlueprintPriorityOverride]['uaa0304'] = nil end
                                    if (aiBrain[reftBlueprintPriorityOverride]['xsa0304'] or 0) > 0 then aiBrain[reftBlueprintPriorityOverride]['xsa0304'] = nil end
                                    --Normal asfs
                                    if (aiBrain[reftBlueprintPriorityOverride]['uea0303'] or 0) > 0 then aiBrain[reftBlueprintPriorityOverride]['uea0303'] = nil end
                                    if (aiBrain[reftBlueprintPriorityOverride]['ura0303'] or 0) > 0 then aiBrain[reftBlueprintPriorityOverride]['ura0303'] = nil end
                                    if (aiBrain[reftBlueprintPriorityOverride]['uaa0303'] or 0) > 0 then aiBrain[reftBlueprintPriorityOverride]['uaa0303'] = nil end
                                    if (aiBrain[reftBlueprintPriorityOverride]['xsa0303'] or 0) > 0 then aiBrain[reftBlueprintPriorityOverride]['xsa0303'] = nil end
                                end
                            end
                            local bKillUnit
                            for iUnit, oUnit in tUnitsToDestroy do
                                if oUnit.Kill and (not(oUnit[M28UnitInfo.refbCampaignTriggerAdded]) or not(M28Map.bIsCampaignMap)) and not(oUnit.Parent) then
                                    --Dont kill an engineer that is building, reclaiming, repairing or capturing (unless it is building/repairing and not ap rimary engineer
                                    bKillUnit = true
                                    if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                                        if  oUnit:IsUnitState('Reclaiming') or oUnit:IsUnitState('Capturing') then
                                            bKillUnit = false
                                        elseif oUnit[M28Engineer.refbPrimaryBuilder] and (oUnit:IsUnitState('Building') or oUnit:IsUnitState('Repairing')) then
                                            bKillUnit = false
                                        elseif M28Utilities.IsTableEmpty(oUnit[M28Building.reftArtiTemplateRefs]) == false and not(M28Map.tAllPlateaus[oUnit[M28Building.reftArtiTemplateRefs][1]][M28Map.subrefPlateauLandZones][oUnit[M28Building.reftArtiTemplateRefs][2]][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftActiveGameEnderTemplates][oUnit[M28Building.reftArtiTemplateRefs][3]][M28Map.subrefGEbDontNeedEngineers]) then
                                            bKillUnit = false
                                        end
                                    elseif EntityCategoryContains(M28UnitInfo.refCategoryFactory, oUnit.UnitId) then
                                        if oUnit[M28Factory.refbPrimaryFactoryForIslandOrPond] or (oUnit[M28ACU.refiUpgradeCount] or 0) > 0 then bKillUnit = false end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering destroying a factory, is this a primary factory='..tostring(oUnit[M28Factory.refbPrimaryFactoryForIslandOrPond] or false)..'; Number of factories on team='..M28Conditions.GetCurrentM28UnitsOfCategoryInTeam(M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryAirFactory, aiBrain.M28Team)..'; bKillUnit='..tostring(bKillUnit)) end
                                    end
                                    if bKillUnit then
                                        if bDebugMessages == true then LOG(sFunctionRef..': iCurUnitsDestroyed so far='..iCurUnitsDestroyed..'; Will destroy unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' to avoid going over unit cap'..'; Have we already tried to kill this unit? oUnit[M28UnitInfo.refbTriedToKill]='..tostring(oUnit[M28UnitInfo.refbTriedToKill] or false)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                                        if not(oUnit[M28UnitInfo.refbTriedToKill]) then
                                            if EntityCategoryContains(M28UnitInfo.refCategoryWall, oUnit.UnitId) then
                                                iCurUnitsDestroyed = iCurUnitsDestroyed + 0.25
                                            else
                                                iCurUnitsDestroyed = iCurUnitsDestroyed + 1
                                            end
                                        end
                                        M28Orders.IssueTrackedKillUnit(oUnit)
                                        bKilledUnit = true

                                        if iCurUnitsDestroyed >= iMaxToDestroy then
                                            if iAdjustmentLevel <= 3 and not(M28Map.bIsCampaignMap) and aiBrain.BrainType == 'AI' then
                                                M28Chat.SendUnitCapMessage(aiBrain)
                                            end
                                            break
                                        end
                                    end
                                end
                            end
                        end
                        if iCurUnitsDestroyed >= iMaxToDestroy then break end
                    else
                        break
                    end
                end
            end
            if bKilledUnit then aiBrain[refiTimeOfLastUnitCapDeath] = GetGameTimeSeconds() end
            aiBrain[refiUnitCapCategoriesDestroyed] = iCumulativeCategory
            if bDebugMessages == true then LOG(sFunctionRef..': FInished destroying units, iCurUnitsDestroyed='..iCurUnitsDestroyed) end
            if iCurUnitsDestroyed >= iMaxToDestroy and bReconsiderShortly then
                if bDebugMessages == true then LOG(sFunctionRef..': We wanted to destroy more units, so will reassess in 10 seconds') end
                ForkThread(DelayedUnitCapCheck, aiBrain, 10)
            end
        else
            --Only reset cap if we havent reached the higher ctrlk thresholds, unless we have a massive amount of headroom
            if aiBrain[refbCloseToUnitCap] and (iCurUnits < iUnitCap * 0.5 - 25 or (M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] or 100) > 1) then
                --Only reset cap if we have a bit of leeway
                if iCurUnits < (iUnitCap - iThreshold * 5) - 20 then
                    aiBrain[refbCloseToUnitCap] = false
                end
            end
        end
        aiBrain[refiExpectedRemainingCap] = iUnitCap - iCurUnits + iCurUnitsDestroyed
        if aiBrain[refbCloseToUnitCap] and aiBrain[refiExpectedRemainingCap] <= 25 then
            --Recheck in 30s
            ForkThread(DelayedUnitCapCheck, aiBrain)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': End of code, expected remaining cap='..aiBrain[refiExpectedRemainingCap]) end
    else
        ForkThread(DelayedUnitCapCheck, aiBrain)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedUnitCapCheck(aiBrain, iOptionalSecondsToWait)
    if not(aiBrain[refbWillDoDelayedUnitCapCheck]) then
        aiBrain[refbWillDoDelayedUnitCapCheck] = true
        WaitSeconds(iOptionalSecondsToWait or 30)
        aiBrain[refbWillDoDelayedUnitCapCheck] = false
        CheckUnitCap(aiBrain)
    end
end

function ResetCivilianAllianceForBrain(iOurIndex, iCivilianIndex, sRealState, oCivilianBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ResetCivilianAllianceForBrain'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Call via forkthread
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Time='..GetGameTimeSeconds()..'; iOurIndex='..iOurIndex..'; iCivilianIndex='..iCivilianIndex..'; Is ally='..tostring(IsAlly(iOurIndex, iCivilianIndex))..'; IsEnemy='..tostring(IsEnemy(iOurIndex, iCivilianIndex))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(11)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting for some ticks, iOurIndex='..iOurIndex..'; iCivilianIndex='..iCivilianIndex..'; Is ally='..tostring(IsAlly(iOurIndex, iCivilianIndex))..'; IsEnemy='..tostring(IsEnemy(iOurIndex, iCivilianIndex))) end
    SetAlliance(iOurIndex, iCivilianIndex, sRealState)
    oCivilianBrain[refiTemporarilySetAsAllyForTeam] = nil
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bDebugMessages == true then LOG(sFunctionRef..': Have now set alliance back to real state, Time='..GetGameTimeSeconds()..' Have just set civilian brain '..oCivilianBrain.Nickname..' back to being '..sRealState..' for iOurIndex='..iOurIndex) end
end

function RevealCiviliansToAI(aiBrain)
    --On some maps like burial mounds civilians are revealed to human players but not AI; meanwhile on other maps even if theyre not revealed to humans, the humans will likely know where the buildings are having played the map before
    --Thanks to Relent0r for providing code that I used as a starting point to achieve this

    --SUPERCEDED BY RevealCivilainsToAIByGivingVision
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RevealCiviliansToAI'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    M28Utilities.ErrorHandler('Deprecated function')
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(75) --Waiting only 5 ticks or less resulted in a strange bug where on one map when ahd 2 ACUs on the same team, the code would run for both of htem as expected, but the civilians would only be visible for one of the AI (as though making the civilian an ally had no effect for hte other); This went away when put a delay of 50 ticks; however have compatibility issues with RNG so want to wait a bit longer; waiting 60 meant it worked for M27 but didnt look like it worked for RNG (wiating 50 meant it worked for RNG but not for M27); waiting 70 meant it worked for both; have done 75 for M28 given M27 uses 70
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --if aiBrain:GetArmyIndex() == 3 then
    if bDebugMessages == true then LOG(sFunctionRef..': Have finished waiting, will loop throguh all brians now to look for civilians, aiBrain='..aiBrain.Nickname..' with index ='..aiBrain:GetArmyIndex()..'; M28 team='..(aiBrain.M28Team or 'nil')) end
    local tiCivilianBrains = {}
    local toCivilianBrains = {}
    local iOurIndex = aiBrain:GetArmyIndex()
    local iBrainIndex
    local sRealState
    local iTotalWait = 0

    for i, oBrain in ArmyBrains do
        iBrainIndex = oBrain:GetArmyIndex()
        if bDebugMessages == true then LOG(sFunctionRef..': Considering brain '..(oBrain.Nickname or 'nil')..' with index '..oBrain:GetArmyIndex()..' for aiBrain '..aiBrain.Nickname..'; Is enemy='..tostring(IsEnemy(iOurIndex, iBrainIndex))..'; ArmyIsCivilian(iBrainIndex)='..tostring(ArmyIsCivilian(iBrainIndex))..'; oBrain[refiTemporarilySetAsAllyForTeam]='..(oBrain[refiTemporarilySetAsAllyForTeam] or 'nil')..'; Our team='..aiBrain.M28Team) end
        if ArmyIsCivilian(iBrainIndex) then
            while(oBrain[refiTemporarilySetAsAllyForTeam] and not(oBrain[refiTemporarilySetAsAllyForTeam] == aiBrain.M28Team)) do
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                iTotalWait = iTotalWait + 1
                if iTotalWait >= 12 then
                    break
                end
            end
            if not(oBrain[refiTemporarilySetAsAllyForTeam]) then
                oBrain[refiTemporarilySetAsAllyForTeam] = aiBrain.M28Team
                sRealState = IsAlly(iOurIndex, iBrainIndex) and 'Ally' or IsEnemy(iOurIndex, iBrainIndex) and 'Enemy' or 'Neutral'
                SetAlliance(iOurIndex, iBrainIndex, 'Ally')
                if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Temporarily set the brain as an ally of team '..aiBrain.M28Team..', sRealState='..sRealState) end
                table.insert(tiCivilianBrains, iBrainIndex)
                table.insert(toCivilianBrains, oBrain)
                --Prevent orders being given to these untis by M28
                --[[local tMobileUnits = oBrain:GetListOfUnits(categories.MOBILE, false, true)
                if M28Utilities.IsTableEmpty(tMobileUnits) == false then
                    for iUnit, oUnit in tMobileUnits do
                        M28Micro.TrackTemporaryUnitMicro(oUnit, 30)
                    end
                end--]]
                ForkThread(ResetCivilianAllianceForBrain, iOurIndex, iBrainIndex, sRealState, oBrain)
            elseif oBrain[refiTemporarilySetAsAllyForTeam] == aiBrain.M28Team then
                table.insert(tiCivilianBrains, iBrainIndex)
                table.insert(toCivilianBrains, oBrain)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(8) --When did with just 4 tick delay had issues where getunitsaroundpoint didnt work properly; increasing to 8 tick solved this
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RevealCivilainsToAIByGivingVision(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RevealCivilainsToAIByGivingVision'
    --First wait a couple of seconds to give a chance for units to be created
    local bHaveHumanTeammate = false
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
        for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyHumanAndAIBrains] do
            if oBrain.BrainType == 'Human' then
                bHaveHumanTeammate = true
            end
        end
    end
    if GetGameTimeSeconds() <= 4.4 and not(bHaveHumanTeammate) then
        --Delay time to wait if we have human teammates
        local iTimeToWait = math.min(3, 4.4 - GetGameTimeSeconds())
        WaitSeconds(iTimeToWait)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': About to reveal civilains and then consider capture targets if this is M28Brain, aiBrain.M28AI='..tostring(aiBrain.M28AI or false)..'; nickname='..(aiBrain.Nickname or 'nil')) end
    if aiBrain.M28AI then --redundancy
        local tACU = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
        local iTempVisionOverride
        if bHaveHumanTeammate then iTempVisionOverride = 0.6 end
        for iUnit, oUnit in tACU do
            M28UnitInfo.GiveUnitTemporaryVision(oUnit, 10000, iTempVisionOverride)
            break
        end
        --Consider capture targets
        if bDebugMessages == true then LOG(sFunctionRef..': Will now consider capture targets') end
        ForkThread(GetCivilianCaptureTargets, aiBrain)

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetCivilianCaptureTargets(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetCivilianCaptureTargets'

    WaitTicks(2) --tried 1 tick but not working for civilian mexes
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local tStartPoint = M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()]
    local iPlateauWanted, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tStartPoint)
    local iClosestEnemyBase = M28Map.iMapSize
    local iTeam = aiBrain.M28Team

    if iLandZone > 0 then
        local tLZData = M28Map.tAllPlateaus[iPlateauWanted][M28Map.subrefPlateauLandZones][iLandZone]
        local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
        iClosestEnemyBase = M28Utilities.GetDistanceBetweenPositions(tStartPoint, tLZTeamData[M28Map.reftClosestEnemyBase])
    end
    local iSearchRange = math.min(450, math.max(iClosestEnemyBase * 0.6, 200, math.min(275, iClosestEnemyBase * 0.75)))
    local iCategoriesOfInterest = M28UnitInfo.refCategoryLandCombat * categories.RECLAIMABLE - categories.TECH1
    local tUnitsOfInterest = aiBrain:GetUnitsAroundPoint(iCategoriesOfInterest, tStartPoint, iSearchRange, 'Neutral')
    if not(tUnitsOfInterest) then tUnitsOfInterest = {} end
    local tNeutralMexes = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryHydro, tStartPoint, 10000, 'Neutral')
    if M28Utilities.IsTableEmpty(tNeutralMexes) == false then
        for iMex, oMex in tNeutralMexes do
            table.insert(tUnitsOfInterest, oMex)
        end
    end

    local iMaxPowerSearchRange = math.min(250, iClosestEnemyBase * 0.225)
    local tNearbyPower = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryPower, tStartPoint, iMaxPowerSearchRange, 'Neutral')
    if M28Utilities.IsTableEmpty(tNearbyPower) == false then
        for iPower, oPower in tNearbyPower do
            table.insert(tUnitsOfInterest, oPower)
        end
    end

    --Include much closer civilian units of all categories that are in the same plateau, and havent already been recorded
    local bSearchForLowerPriority = not(M28Utilities.IsTableEmpty(tUnitsOfInterest))
    local tVeryCloseUnits = aiBrain:GetUnitsAroundPoint(categories.RECLAIMABLE - M28UnitInfo.refCategoryAllAir, tStartPoint, math.min(iMaxPowerSearchRange, iSearchRange, iClosestEnemyBase * 0.2, M28Map.iMapSize * 0.25, 125), 'Neutral')
    if M28Utilities.IsTableEmpty(tVeryCloseUnits) == false then
        local sPathing = M28Map.refPathingTypeHover
        local bDoPathingCheck = not(M28Map.bIsLowMexMap)
        local bCheckExistingEntries = false
        local tOrigUnits
        if M28Utilities.IsTableEmpty(tUnitsOfInterest) == false then
            bCheckExistingEntries = true
            tOrigUnits = {}
            for iUnit, oUnit in tUnitsOfInterest do
                table.insert(tOrigUnits, oUnit)
            end
        end
        local bRecordUnit
        for iUnit, oUnit in tVeryCloseUnits do
            bRecordUnit = true
            if bCheckExistingEntries then
                for iRecorded, oRecorded in tOrigUnits do
                    if oRecorded == oUnit then bRecordUnit = false break end
                end
            end
            if bRecordUnit then
                --Check we are in the same plateau
                if not(bDoPathingCheck) or NavUtils.GetLabel(sPathing, oUnit:GetPosition()) == iPlateauWanted then
                    table.insert(tUnitsOfInterest, oUnit)
                end
            end
        end
    end

    if bSearchForLowerPriority then
        local bCheckIfAlreadyRecorded = not(M28Utilities.IsTableEmpty(tUnitsOfInterest))
        --Search for lower priority capture targets, and further away
        iCategoriesOfInterest = iCategoriesOfInterest + (categories.MOBILE * categories.LAND * categories.RECLAIMABLE - categories.TECH1) + M28UnitInfo.refCategoryT1Radar * categories.RECLAIMABLE + (M28UnitInfo.refCategoryStructureAA * categories.RECLAIMABLE - categories.TECH1) + M28UnitInfo.refCategoryPD + M28UnitInfo.refCategoryFixedT2Arti
        iSearchRange = math.max(math.min(350, M28Map.iMapSize * 0.5), iSearchRange + 25)
        if bCheckIfAlreadyRecorded then
            local tOrigUnits = {}
            for iUnit, oUnit in tUnitsOfInterest do
                table.insert(tOrigUnits, oUnit)
            end
            local tPotentialUnits = aiBrain:GetUnitsAroundPoint(iCategoriesOfInterest, tStartPoint, iSearchRange, 'Neutral')
            if M28Utilities.IsTableEmpty(tPotentialUnits) == false then
                local bRecordedAlready = false
                for iUnit, oUnit in tPotentialUnits do
                    bRecordedAlready = false
                    for iRecorded, oRecorded in tOrigUnits do
                        if oRecorded == oUnit then bRecordedAlready = true break end
                    end
                    if not(bRecordedAlready) then
                        table.insert(tUnitsOfInterest, oUnit)
                    end
                end
            end
        else
            tUnitsOfInterest = aiBrain:GetUnitsAroundPoint(iCategoriesOfInterest, tStartPoint, iSearchRange, 'Neutral')
        end
    end


    if bDebugMessages == true then LOG(sFunctionRef..': Running for aiBrain='..aiBrain.Nickname..' at gametime='..GetGameTimeSeconds()..'; Is table of tUnitsOfInterest empty='..tostring(M28Utilities.IsTableEmpty(tUnitsOfInterest))..'; iPlateauWanted='..iPlateauWanted..'; iClosestEnemyBase='..iClosestEnemyBase..'; iSearchRange='..iSearchRange..'; Is table of enemy units with further range empty='..tostring(M28Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(iCategoriesOfInterest, tStartPoint, 1000, 'Enemy')))..'; Is tNeutralMexes empty='..tostring(M28Utilities.IsTableEmpty(tNeutralMexes))) end
    if M28Utilities.IsTableEmpty(tUnitsOfInterest) == false then
        local iCurPlateau, iCurLandZone
        for iUnit, oUnit in tUnitsOfInterest do
            if oUnit:GetFractionComplete() >= 1 then
                --Is it in the same plateua?
                iCurPlateau, iCurLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())

                if bDebugMessages == true then LOG(sFunctionRef..': Considering civilian unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurPlateau='..(iCurPlateau or 'nil')..'; iPlateauWanted='..iPlateauWanted..' (although we no longer check for this for most units), Dist to our base='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tStartPoint)..'; Mod dist='..M28Map.GetModDistanceFromStart(aiBrain, oUnit:GetPosition())) end
                if (iCurLandZone or 0) > 0 and (iCurPlateau or 0) > 0 then
                    --Is it one of the civilian brains we temporarily moved to be our ally?
                    if M28Conditions.IsCivilianBrain(oUnit:GetAIBrain()) then
                        local tNearbyThreats = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryPD + M28UnitInfo.refCategoryFixedT2Arti, oUnit:GetPosition(), 140, 'Enemy')
                        if M28Utilities.IsTableEmpty(tNearbyThreats) then
                            RecordUnitAsCaptureTarget(oUnit, iCurPlateau, iCurLandZone)
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordUnitAsCaptureTarget(oUnit, iPlateau, iLandZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RevealCiviliansToAI'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tUnitLZData
    if iPlateau == 0 then
        tUnitLZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandZone]][M28Map.subrefPondWaterZones][iLandZone]
    else
        tUnitLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    end
    if not(tUnitLZData[M28Map.subreftoUnitsToCapture]) then tUnitLZData[M28Map.subreftoUnitsToCapture] = {} end
    table.insert(tUnitLZData[M28Map.subreftoUnitsToCapture], oUnit)
    oUnit[M28UnitInfo.refbIsCaptureTarget] = true

    if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to the table of civilians to capture; unit brain='..(oUnit:GetAIBrain().Nickname or 'nil')..'; is civilian='..tostring(M28Conditions.IsCivilianBrain(oUnit:GetAIBrain()))..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Island ref='..(tUnitLZData[M28Map.subrefLZIslandRef] or 'nil')..'; Land ref of LZData midpoint='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tUnitLZData[M28Map.subrefMidpoint]) or 'nil')..'; Land ref of the unit='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, oUnit:GetPosition()) or 'nil')) end
    if iPlateau > 0 then
        if not(tUnitLZData[M28Map.subrefLZIslandRef]) then
            local iIslandRef = (NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, oUnit:GetPosition()) or NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tUnitLZData[M28Map.subrefMidpoint]))
            if iIslandRef then
                if bDebugMessages == true then LOG(sFunctionRef..': will record P'..iPlateau..'Z'..iLandZone..' as having iIslandRef='..iIslandRef) end
                M28Map.AddLandZoneToIsland(iPlateau, iLandZone, iIslandRef, tUnitLZData)
            end
        end

        if tUnitLZData[M28Map.subrefLZIslandRef] then
            if not(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandUnitsToCapture][tUnitLZData[M28Map.subrefLZIslandRef]]) then
                if not(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandUnitsToCapture]) then M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandUnitsToCapture] = {} end
                M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandUnitsToCapture][tUnitLZData[M28Map.subrefLZIslandRef]] = {}
            end
            table.insert(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandUnitsToCapture][tUnitLZData[M28Map.subrefLZIslandRef]], oUnit)
            if bDebugMessages == true then LOG(sFunctionRef..': Recording unit against the island '..tUnitLZData[M28Map.subrefLZIslandRef]) end
        end
    end

    --Check not recorded as a reclaim target for any team
    for iTeam = 1, M28Team.iTotalTeamCount do
        if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 0 then
            local tUnitLZTeamData = tUnitLZData[M28Map.subrefLZTeamData][iTeam]
            --Check if unit is recorded to be reclaimed, and if so then remove it
            if M28Utilities.IsTableEmpty(tUnitLZTeamData[M28Map.subreftoUnitsToReclaim]) == false then
                for iCurEntry = table.getn(tUnitLZTeamData[M28Map.subreftoUnitsToReclaim]), 1, -1 do
                    if tUnitLZTeamData[M28Map.subreftoUnitsToReclaim][iCurEntry] == oUnit then
                        table.remove(tUnitLZTeamData[M28Map.subreftoUnitsToReclaim], iCurEntry)
                        if bDebugMessages == true then LOG(sFunctionRef..': Removed unit from the list of units to be reclaimed') end
                    end
                end
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function OverseerManager(aiBrain)
    --ForkThread(DebugCheckProfiling, true) --true if want to only give tick count (to help figure out which tick happens just before the issue)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OverseerManager'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --Make sure map setup will be done
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    while not(M28Map.bMapLandSetupComplete) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Waiting for maplandsetup to be done, time='..GetGameTimeSeconds()) end
    end





    --Initialise main systems
    if bDebugMessages == true then LOG(sFunctionRef..': About to cork of initialization') end
    ForkThread(Initialisation, aiBrain)

    --Wait until we can give orders before doing main logic
    while (GetGameTimeSeconds() <= 4.5) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    --ForkThread(TestCustom, aiBrain)

    local M28Config = import('/mods/M28AI/lua/M28Config.lua')
    local bSetHook = false --Used for debugging
    if M28Config.M28RunMemoryProfiling then ForkThread(M28Profiler.ShowFileMemoryUsage) end
    if bDebugMessages == true then LOG(sFunctionRef..': About to run main overseer loop') end
    while not(aiBrain:IsDefeated()) and not(aiBrain.M28IsDefeated) do
        local bEnabledProfiling = false

        --[[if GetGameTimeSeconds() >= 900 and not(bEnabledProfiling) then
             if not(import('/mods/M28AI/lua/M28Config.lua').M28RunProfiling) then
                 ForkThread(M28Profiler.ProfilerActualTimePerTick)
                 import('/mods/M28AI/lua/M28Config.lua').M28RunProfiling = true
             end
             bEnabledProfiling = true
         end--]]

        --if GetGameTimeSeconds() >= 2700 then import('/mods/M28AI/lua/M28Config.lua').M28ShowUnitNames = true end
        --if GetGameTimeSeconds() >= 90 and GetGameTimeSeconds() <= 91 then TestCustom(aiBrain) end
        --Enable below to help figure out infinite loops
        --[[if GetGameTimeSeconds() >= 173 and not(bSetHook) then
            bSetHook = true
            M28Profiler.bFunctionCallDebugOverride = true
            --M28Profiler.bGlobalDebugOverride = true --Only enable this if want more detail as it will make things really slow
            debug.sethook(M28Profiler.OutputRecentFunctionCalls, "c", 200)
            LOG('Have started the main hook of function calls')
        end--]]
        ForkThread(M28Economy.RefreshEconomyData, aiBrain)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckIfScenarioMap()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckIfScenarioMap'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': ScenarioInfo.type == skirmish='..tostring(ScenarioInfo.type == "skirmish")..'; repru of ScenarioInfo.type='..repru(ScenarioInfo.type)..'; Is table of hunman players empty='..tostring(M28Utilities.IsTableEmpty(ScenarioInfo.HumanPlayers))..'; Is human players nil='..tostring(ScenarioInfo.HumanPlayers == nil)) end
    --Thanks to Hdt80bro for highlighting ScenarioInfo.type as a better way of figuring out if this is a campaign map
    if not(ScenarioInfo.type == "skirmish") then --M28Utilities.IsTableEmpty(ScenarioInfo.HumanPlayers) == false then
        M28Map.bIsCampaignMap = true
        LOG('Are in a campaign map, shared armies setting='..(ScenarioInfo.Options.M28CombinedArmy or 'nil')..'; CampAI='..(ScenarioInfo.Options.CampAI or 'nil')..'; Apply M28AI Easy to campaign AI='..(ScenarioInfo.Options.CmM28CampPers or 'nil')..'; CmApplyAIx='..(ScenarioInfo.Options.CmApplyAIx or 'nil')..'; Hostile delay='..(ScenarioInfo.Options.CmpAIDelay or 'nil'))
        --ForkThread(CheckForScenarioObjectives) --superceded by hook of addobjective
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckForAlliedCampaignUnitsToShareAtGameStart(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckForAlliedCampaignUnitsToShareAtGameStart'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iTeam = aiBrain.M28Team
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; M28Team.tTeamData[iTeam][M28Team.refbAlreadyCheckedForUnitsToShare]='..tostring(M28Team.tTeamData[iTeam][M28Team.refbAlreadyCheckedForUnitsToShare] or false)) end
    if not(M28Team.tTeamData[iTeam][M28Team.refbAlreadyCheckedForUnitsToShare]) then
        M28Team.tTeamData[iTeam][M28Team.refbAlreadyCheckedForUnitsToShare] = true
        while ScenarioInfo.OpEnded do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting for ScenarioInfo.OpEnded to finish, time='..GetGameTimeSeconds()) end
        local tStartPosition = M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()]
        local tNearbyStructures = {}
        local iWaitCount = 0
        local tHumanBrains = {}
        local iM28SeparatePlayerCount = 0
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
            if bDebugMessages == true then LOG(sFunctionRef..': Creating list of human brains, oBrain.Nickanme='..oBrain.Nickname..'; brain type='..oBrain.BrainType) end
            if oBrain.BrainType == 'Human' then
                table.insert(tHumanBrains, oBrain)
            elseif oBrain.M28AI and not(oBrain.CampaignAI) then
                iM28SeparatePlayerCount = iM28SeparatePlayerCount + 1
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iM28SeparatePlayerCount='..iM28SeparatePlayerCount..'; Is table of human brains empty='..tostring(M28Utilities.IsTableEmpty(tHumanBrains))) end
        local iCategoriesOfInterest = M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryAllAir + M28UnitInfo.refCategoryAllNavy + M28UnitInfo.refCategoryEngineer - categories.COMMAND - M28UnitInfo.refCategoryMassStorage
        if iM28SeparatePlayerCount > 0 and M28Utilities.IsTableEmpty(tHumanBrains) == false then
            while M28Utilities.IsTableEmpty(tNearbyStructures) do
                if iWaitCount > 0 then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(1)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                end
                iWaitCount = iWaitCount + 1
                if GetGameTimeSeconds() >= 120 and (not(ScenarioInfo.OpEnded) or GetGameTimeSeconds() >= 240) then break end
                for iBrain, oBrain in tHumanBrains do
                    local tPotentialStructures = oBrain:GetListOfUnits(iCategoriesOfInterest, false, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Is table of potential units empty for brain '..oBrain.Nickname..'='..tostring(M28Utilities.IsTableEmpty(tPotentialStructures))) end
                    if M28Utilities.IsTableEmpty(tPotentialStructures) == false then
                        for iUnit, oUnit in tPotentialStructures do
                            table.insert(tNearbyStructures, oUnit)
                        end
                    end
                end
                --tNearbyStructures = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure, tStartPosition, 1000, 'Ally')
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': FInished wait for checking for ally structures to share, Time='..GetGameTimeSeconds()..'; Is tNearbyStructures empty='..tostring(M28Utilities.IsTableEmpty(tNearbyStructures))) end
        if M28Utilities.IsTableEmpty(tNearbyStructures) == false then
            --local tUnitsOfCategoryWanted = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryAllAir + M28UnitInfo.refCategoryAllNavy - categories.COMMAND, tStartPosition, 1000, 'Ally')
            local tUnitsOfCategoryWanted = tNearbyStructures
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of units of category wanted empty='..tostring(M28Utilities.IsTableEmpty(tUnitsOfCategoryWanted))) end
            if M28Utilities.IsTableEmpty(tUnitsOfCategoryWanted) == false then
                local tUnitsToShareByBlueprint = {}
                for iUnit, oUnit in  tUnitsOfCategoryWanted do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to add unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of units to share, Is uint valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Fraction complete='..oUnit:GetFractionComplete()..'; Unit brain nickname='..oUnit:GetAIBrain().Nickname..'; Unit brain type='..oUnit:GetAIBrain().BrainType) end
                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 and oUnit:GetAIBrain().BrainType == "Human" then
                        if not(tUnitsToShareByBlueprint[oUnit.UnitId]) then tUnitsToShareByBlueprint[oUnit.UnitId] = {} end
                        table.insert(tUnitsToShareByBlueprint[oUnit.UnitId], oUnit)
                        if bDebugMessages == true then LOG(sFunctionRef..': Add unit to the table of units to consider sharing') end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Is untis to share empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToShareByBlueprint))) end
                if M28Utilities.IsTableEmpty(tUnitsToShareByBlueprint) == false then
                    local iNthEntryToGive
                    local iHumanBrainCount = 0
                    local iM28BrainCount = 0
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                        if oBrain.M28AI and not(oBrain.CampaignAI) and not(oBrain.BrainType == 'Human') then iM28BrainCount = iM28BrainCount + 1
                        elseif oBrain.BrainType == 'Human' then
                            iHumanBrainCount = iHumanBrainCount + 1
                        end
                    end
                    if iM28BrainCount >= 1 and iM28BrainCount + iHumanBrainCount > 1 then
                        local iUnitsAlreadyOwnedOfBlueprint
                        iNthEntryToGive = math.ceil((iM28BrainCount + iHumanBrainCount) / iM28BrainCount)
                        local iTotalUnitCount
                        local iCurCycleCount
                        local tUnitsToGive = {}
                        local iCurNthEntryToGive
                        if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through all units to potentially share, iNthEntryToGive='..iNthEntryToGive..'; iM28BrainCount='..iM28BrainCount..'; iHumanBrainCount='..iHumanBrainCount) end
                        for sBlueprint, tUnits in tUnitsToShareByBlueprint do
                            iCurNthEntryToGive = iNthEntryToGive
                            iTotalUnitCount = table.getn(tUnits)
                            if bDebugMessages == true then LOG(sFunctionRef..': sBLueprint='..sBlueprint..'; iTotalUnitCount='..iTotalUnitCount) end
                            if iTotalUnitCount >= iNthEntryToGive then
                                iUnitsAlreadyOwnedOfBlueprint = 0
                                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                    iUnitsAlreadyOwnedOfBlueprint = iUnitsAlreadyOwnedOfBlueprint + oBrain:GetCurrentUnits(categories[sBlueprint])
                                    if bDebugMessages == true then LOG(sFunctionRef..': oBrain cur units for sBlueprint='..oBrain:GetCurrentUnits(categories[sBlueprint])) end
                                end
                                if iUnitsAlreadyOwnedOfBlueprint > 0 then
                                    if iUnitsAlreadyOwnedOfBlueprint >= iTotalUnitCount then
                                        iCurNthEntryToGive = 1000
                                    else
                                        iCurNthEntryToGive = iCurNthEntryToGive + (iUnitsAlreadyOwnedOfBlueprint - iTotalUnitCount) * iM28BrainCount
                                    end
                                end
                                iCurCycleCount = 0
                                for iUnit, oUnit in tUnits do
                                    iCurCycleCount = iCurCycleCount + 1
                                    if iCurCycleCount >= iNthEntryToGive then
                                        table.insert(tUnitsToGive, oUnit)
                                        iCurCycleCount = 0
                                    end
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(tUnitsToGive) == false then
                            local tiM28Brains = {}
                            local iM28BrainCount = 0
                            local oCurBrain
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                    if not(oBrain.CampaignAI) then
                                        table.insert(tiM28Brains, oBrain)
                                        iM28BrainCount = iM28BrainCount + 1
                                    end
                                end
                            elseif aiBrain.M28AI then
                                table.insert(tiM28Brains, aiBrain)
                                M28Utilities.ErrorHandler('Dont have any activeM28 brains noted despite dealing with an M28Brain')
                            end
                            for iUnit, oUnit in tUnitsToGive do
                                if iM28BrainCount > 1 then
                                    oCurBrain = tiM28Brains[math.random(1, iM28BrainCount)]
                                else
                                    oCurBrain = tiM28Brains[iM28BrainCount]
                                end
                                --Gift adjacent mass storage if any
                                if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                                    M28Team.GiftAdjacentStorageToMexOwner(oUnit, oCurBrain)
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Just about to try and gift unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..' to M28AI brain '..oCurBrain.Nickname) end
                                M28Team.TransferUnitsToPlayer({ oUnit }, oCurBrain:GetArmyIndex(), false)
                            end
                        end
                    end
                end
            end
        end

        --Make sure have full energy to cover any energy storage that have transferred over
        local iMaxEnergy, iCurEnergy
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            iMaxEnergy = M28Economy.GetEnergyStorageMaximum(oBrain, true)
            iCurEnergy = oBrain:GetEconomyStored('ENERGY')
            if iCurEnergy < iMaxEnergy then
                oBrain:GiveResource('Energy', iMaxEnergy - iCurEnergy)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SetBuildAndResourceCheatModifiers(aiBrain, iBuildModifier, iResourceModifier, bDontChangeScenarioInfo, iOptionalRecordedUnitResourceAdjust, bDontApplyToUnits, bUpdateCheatValue)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetBuildAndResourceCheatModifiers'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for aiBrain='..aiBrain.Nickname..'; iBuildModifier='..iBuildModifier..'; iResourceModifier='..iResourceModifier) end
    --Force build modifier and resource modifier to be numeric
    iBuildModifier = tonumber(iBuildModifier)
    iResourceModifier = tonumber(iResourceModifier)
    --Note - see also FixUnitResourceCheatModifiers(oUnit) for a function intended to try and fix SACU FAF issue with AIx
    if not(bDontChangeScenarioInfo) then
        ScenarioInfo.Options.CheatMult = tostring(iResourceModifier)
        ScenarioInfo.Options.BuildMult = tostring(iBuildModifier)
    end
    --local FAFBuffs = import('/lua/sim/Buff.lua')
    local sCheatBuildRate = 'CheatBuildRate'..aiBrain:GetArmyIndex()
    local sCheatIncome = 'CheatIncome'..aiBrain:GetArmyIndex()
    --local AdjBuffFuncs = import('/lua/sim/adjacencybufffunctions.lua')
    if not Buffs[sCheatBuildRate] then
        BuffBlueprint {
            Name = sCheatBuildRate,
            DisplayName = sCheatBuildRate,
            BuffType = 'BUILDRATECHEAT',
            Stacks = 'ALWAYS',
            Duration = -1,
            Affects = {
                BuildRate = {
                    --BuffCheckFunction = AdjBuffFuncs.BuildRateBuffCheck,
                    Add = 0,
                    Mult = 1,
                },
            },
        }
    end
    if not Buffs[sCheatIncome] then
        BuffBlueprint {
            Name = sCheatIncome,
            DisplayName = sCheatBuildRate,
            BuffType = 'INCOMECHEAT',
            Stacks = 'ALWAYS',
            Duration = -1,
            Affects = {
                EnergyProduction = {
                    --BuffCheckFunction = AdjBuffFuncs.EnergyProductionBuffCheck,
                    Add = 0,
                    Mult = 1,
                },
                MassProduction = {
                    --BuffCheckFunction = AdjBuffFuncs.MassProductionBuffCheck,
                    Add = 0,
                    Mult = 1,
                }
            },
        }
    end
    if bUpdateCheatValue then aiBrain.CheatValue = math.min(iBuildModifier, iResourceModifier) end
    if M28Utilities.bLoudModActive or M28Utilities.bQuietModActive then
        Buffs[sCheatBuildRate].EntityCategory = 'ALLUNITS'
        Buffs[sCheatIncome].EntityCategory = 'ALLUNITS'
        Buffs[sCheatBuildRate].ParsedEntityCategory = categories.ALLUNITS
        Buffs[sCheatIncome].ParsedEntityCategory = categories.ALLUNITS
    end
    Buffs['CheatBuildRate'..aiBrain:GetArmyIndex()].Affects.BuildRate.Mult = iBuildModifier
    Buffs['CheatIncome'..aiBrain:GetArmyIndex()].Affects.EnergyProduction.Mult = iResourceModifier
    Buffs['CheatIncome'..aiBrain:GetArmyIndex()].Affects.MassProduction.Mult = iResourceModifier
    if not(bDontApplyToUnits) then
        --Want both resource producing units, and units that can be upgraded
        local tExistingUnits = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryResourceUnit + M28UnitInfo.refCategoryProductionUnit, false, false)
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of existing units empty='..tostring(M28Utilities.IsTableEmpty(tExistingUnits))..'; Brain='..aiBrain.Nickname..'; Buffs[\'CheatBuildRate\'..aiBrain:GetArmyIndex()].Affects.BuildRate.Mult='..(Buffs['CheatBuildRate'..aiBrain:GetArmyIndex()].Affects.BuildRate.Mult or 'nil')..'; Time='..GetGameTimeSeconds()) end
        if M28Utilities.IsTableEmpty(tExistingUnits) == false then
            for iUnit, oUnit in tExistingUnits do
                M28UnitInfo.FixUnitResourceCheatModifiers(oUnit)
                --[[if bDebugMessages == true then LOG(sFunctionRef..': Applying buffs to unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' for brain='..aiBrain.Nickname..' with index='..aiBrain:GetArmyIndex()) end
                FAFBuffs.RemoveBuff(oUnit, 'CheatIncome'..aiBrain:GetArmyIndex(), true)
                FAFBuffs.ApplyBuff(oUnit, 'CheatIncome'..aiBrain:GetArmyIndex())
                FAFBuffs.RemoveBuff(oUnit, 'CheatBuildRate'..aiBrain:GetArmyIndex(), true)
                FAFBuffs.ApplyBuff(oUnit, 'CheatBuildRate'..aiBrain:GetArmyIndex())--]]
                if iOptionalRecordedUnitResourceAdjust then
                    ForkThread(UpdateGrossIncomeForUnit, oUnit, false, false, iOptionalRecordedUnitResourceAdjust)
                end
            end
        end
    end
    if not(aiBrain.CheatEnabled) and not(iResourceModifier == 1 and iBuildModifier == 1) then aiBrain.CheatEnabled = true end --redundnacy
    aiBrain[M28Economy.refiBrainResourceMultiplier] = iResourceModifier
    aiBrain[M28Economy.refiBrainBuildRateMultiplier] = iBuildModifier
    if aiBrain.CheatEnabled and aiBrain.M28Team then
        M28Team.tTeamData[aiBrain.M28Team][M28Team.refiHighestBrainResourceMultiplier] = iResourceModifier
        M28Team.tTeamData[aiBrain.M28Team][M28Team.refiHighestBrainBuildMultiplier] = iBuildModifier
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckForScenarioObjectives()
    --NO LONGER USED - use AddObjective hook instead
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckForScenarioObjectives'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    M28Utilities.ErrorHandler('Obsolete function')
    if bDebugMessages == true then LOG(sFunctionRef..': Will start scenario mission checker if not already active, bActiveMissionChecker='..tostring(bActiveMissionChecker)) end
    if not(bActiveMissionChecker) then
        bActiveMissionChecker = true

        while not(M28Map.bMapLandSetupComplete) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if M28Utilities.IsTableEmpty(tAllActiveM28Brains) then break end
        end
        local iTeam

        local tObjectivesConsidered = {}
        local iLastMissionConsidered = 0
        function ConsiderObjective(sMissionRef, iMission, iObjective)
            --Does this objective exist and we havent already considered it?
            if ScenarioInfo[sMissionRef] and not(tObjectivesConsidered[sMissionRef]) then
                tObjectivesConsidered[sMissionRef] = true
                iLastMissionConsidered = math.max(iMission, iLastMissionConsidered)
                if bDebugMessages == true then LOG(sFunctionRef..': Have just recorded a new objective, sMissionRef='..sMissionRef..'; iMission='..iMission..'; iObjective='..iObjective..'; reprs of mission='..reprs(ScenarioInfo[sMissionRef])) end
            end
        end
        local sMissionRef
        if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop, is table of active M28 brains empty='..tostring(M28Utilities.IsTableEmpty(tAllActiveM28Brains))) end
        while M28Utilities.IsTableEmpty(tAllActiveM28Brains) == false do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(60)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            --Check for new objectives
            for iMission = math.max(1, iLastMissionConsidered), iLastMissionConsidered + 1 do
                for iPrimaryObjective = 1, 5 do
                    sMissionRef = 'M'..iMission..'P'..iPrimaryObjective
                    ConsiderObjective(sMissionRef, iMission, iPrimaryObjective)
                end
                for iSecondaryObjective = 1, 5 do
                    sMissionRef = 'M'..iMission..'S'..iSecondaryObjective
                    ConsiderObjective(sMissionRef, iMission, iSecondaryObjective)
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking form issions, iLastMissionConsidered='..iLastMissionConsidered..'; tObjectivesConsidered='..repru(tObjectivesConsidered)) end
        end

        bActiveMissionChecker = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function M28ErisKilled()

    if(not ScenarioInfo.OpEnded) and ScenarioInfo.M4P1.Active then
        local CampaignScript = import('/maps/scca_coop_e03.v0021/SCCA_Coop_E03_script.lua')
        if CampaignScript.ErisKilled then
            LOG('Manually calling Eris killed event')
            CampaignScript.ErisKilled()
        end
        --[[WaitSeconds(20)
        if(not ScenarioInfo.OpEnded) and ScenarioInfo.M4P1.Active then
            local ScenarioFramework = import('/lua/ScenarioFramework.lua')
            ScenarioFramework.EndOperationSafety()
            ScenarioInfo.OpComplete = true

            -- aeon cdr killed
            --    ScenarioFramework.EndOperationCamera(ScenarioInfo.AeonCDR)
            --ScenarioFramework.CDRDeathNISCamera(ScenarioInfo.AeonCDR) --Commander will be dead now/unit invalid

            local OpStrings = import('/maps/scca_coop_e03.v0021/SCCA_Coop_E03_strings.lua')
            ScenarioFramework.Dialogue(OpStrings.E03_M04_070, StartKillGame, true)
        end--]]
    end
end

function DelayedCybranFireBlackSun(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DelayedCybranFireBlackSun'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Will wait a bit then fire black sun') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitSeconds(10)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Has the op ended yet='..tostring(ScenarioInfo.OpEnded or false)..'; OpComplete='..tostring(ScenarioInfo.OpComplete or false)) end
    if not(ScenarioInfo.OpEnded) and not(ScenarioInfo.OpComplete) then
        M28Chat.SendMessage(aiBrain, 'M6End', 'Getting ready to fire black sun...', 0, 100000, false, false)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(5)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': WIll fire black sun') end
        local ScenarioFramework = import('/lua/ScenarioFramework.lua')
        ScenarioFramework.FlushDialogueQueue()
        ScenarioFramework.EndOperationSafety()
        ScenarioInfo.OpComplete = true
        if ScenarioInfo.M3P2 then
            ScenarioInfo.M3P2:ManualResult(true)
        end
        ScenarioFramework.EndOperation(ScenarioInfo.OpComplete, ScenarioInfo.OpComplete, true)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function M1AeonEndMissionBackupMonitor()
    --Every 20s checks if have killed enemy ACU then waits another 20s before ending game (as default is far too long)
    --Call via fork thread
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'M1AeonEndMissionBackupMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': start of code, for time '..GetGameTimeSeconds()..'; bActiveMissionChecker='..tostring(bActiveMissionChecker)..'; Is M7 UEF commander valid='..tostring(M28UnitInfo.IsUnitValid(ScenarioInfo.M7_FauxUEFCommanderUnit))) end
    if not(bActiveMissionChecker) and M28UnitInfo.IsUnitValid(ScenarioInfo.M7_FauxUEFCommanderUnit) then
        bActiveMissionChecker = true
        while M28UnitInfo.IsUnitValid(ScenarioInfo.M7_FauxUEFCommanderUnit) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(20)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Is UEF ACU still valid='..tostring( M28UnitInfo.IsUnitValid(ScenarioInfo.M7_FauxUEFCommanderUnit))) end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': UEF ACU is now dead, will wait 20s then start ending the game') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(20)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Is operation not ending yet via normal logic='..tostring(not(ScenarioInfo.OperationEnding))..'; Time='..GetGameTimeSeconds()) end
        if ScenarioInfo.OperationEnding then
            if bDebugMessages == true then LOG(sFunctionRef..': Will wait another 15s to see if scenario ends') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(15)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end --Wait another 15s to give the main mission a chance to end properly
        if ScenarioInfo.M7P4.ManualResult then
            ScenarioInfo.M7P4.ManualResult(true)
            if bDebugMessages == true then LOG(sFunctionRef..': Will end operation safely, and then wait 10s and end operation') end
            local ScenarioFramework = import('/lua/ScenarioFramework.lua')
            local OpStrings   = import('/maps/scca_coop_a01.v0016/SCCA_Coop_A01_Strings.lua')
            local Objectives = import('/lua/ScenarioFramework.lua').Objectives
            ScenarioFramework.EndOperationSafety()
            ScenarioFramework.Dialogue(OpStrings.A01_M07_116, false, true) -- Rhiza: "Glorious!"
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(5)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            ScenarioInfo.OpComplete = true
            local secondary = Objectives.IsComplete(ScenarioInfo.M7S1) and Objectives.IsComplete(ScenarioInfo.M7S2)
            local bonus = Objectives.IsComplete(ScenarioInfo.M1B1) and Objectives.IsComplete(ScenarioInfo.M1B2) and Objectives.IsComplete(ScenarioInfo.M1B3) and Objectives.IsComplete(ScenarioInfo.M6B1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(5.0)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if bDebugMessages == true then LOG(sFunctionRef..': Will now end operation at time '..GetGameTimeSeconds()) end
            ScenarioFramework.EndOperation(ScenarioInfo.OpComplete, ScenarioInfo.OpComplete, secondary, bonus)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderSpecialCampaignObjectives(Type, Complete, Title, Description, ActionImage, Target, IsLoading, loadedTag, iOptionalWaitInSeconds)
    --NOTE: All of input variables are optional as sometimes we just call this due to a playable area size change
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderSpecialCampaignObjectives'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if iOptionalWaitInSeconds then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(iOptionalWaitInSeconds)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code at time '..GetGameTimeSeconds()..' after iOptionalWaitInSeconds='..(iOptionalWaitInSeconds or 'nil')..'; Is M3P3 active='..tostring(ScenarioInfo.M3P3.Active or false)..'; Is commander gate area empty='..tostring(Scenario.Areas['CDR_Gate_Area'] == nil)..'; CDR_Gate_Area='..repru(Scenario.Areas['CDR_Gate_Area'])..'; ScenarioInfo.M1P3.Active='..tostring(ScenarioInfo.M1P3.Active or false)..'; Is combined table empty='..tostring(M28Utilities.IsTableEmpty(ScenarioInfo.M1_TempleCombinedTable))..'; M1P2 active='..tostring(ScenarioInfo.M1P2.Active)..'; M1P1 active='..tostring(ScenarioInfo.M1P1.Active)) end

    local aiBrain
    for iBrain, oBrain in tAllActiveM28Brains do
        if oBrain.M28AI and not(oBrain.CampaignAI) then aiBrain = oBrain break end
    end
    if not(aiBrain) then
        --Get first player
        local oFirstPlayer
        for iBrain, oBrain in ArmyBrains do
            if oBrain.Human then oFirstPlayer = oBrain break end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': oFirstPlayer nickname='..(oFirstPlayer.Nickname or 'nil')) end
        if oFirstPlayer then
            local oNonHostileBrain
            local oHostileBrain

            for iBrain, oBrain in ArmyBrains do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering backup M28 brain, oBrain='..(oBrain.Nickname)..'; IsAlly='..tostring(IsAlly(oBrain:GetArmyIndex(), oFirstPlayer:GetArmyIndex()))..'; .M28AI='..tostring(oBrain.M28AI or false)..'; Is enemy='..tostring(IsEnemy(oBrain:GetArmyIndex(), oFirstPlayer:GetArmyIndex()))) end
                if oBrain.M28AI and IsAlly(oBrain:GetArmyIndex(), oFirstPlayer:GetArmyIndex()) then
                    aiBrain = oBrain
                    break
                elseif not(oNonHostileBrain) and oBrain.M28AI and not(IsEnemy(oBrain:GetArmyIndex(), oFirstPlayer:GetArmyIndex())) then
                    oNonHostileBrain = oBrain
                elseif not(oHostileBrain) and oBrain.M28AI and IsEnemy(oBrain:GetArmyIndex(), oFirstPlayer:GetArmyIndex()) then
                    oHostileBrain = oBrain
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for backup brain, aiBrain='..(aiBrain.Nickname or 'nil')..'; oNonHostileBrain='..(oNonHostileBrain.Nickname or 'nil')) end
            if not(aiBrain) then aiBrain = oNonHostileBrain or oHostileBrain end
        end
    end
    if aiBrain then
        local iTeam = aiBrain.M28Team
        --UEF Mission 3 - create a special death trigger for Aeon ACU due to flaw with preceding objective
        if bDebugMessages == true then
            LOG(sFunctionRef..': Further logs, ScenarioInfo.M3BaseDamageWarnings='..(ScenarioInfo.M3BaseDamageWarnings or 'nil')..'; ScenarioInfo.MainFrameIsAlive='..tostring(ScenarioInfo.MainFrameIsAlive or false)..'; ScenarioInfo.EMPFired='..tostring(ScenarioInfo.EMPFired or false)..'; ScenarioInfo.M3_Base is empty='..tostring(M28Utilities.IsTableEmpty(ScenarioInfo.M3_Base))..'; bPacifistModeActive='..tostring(bPacifistModeActive)..'; ScenarioInfo.MissionNumber='..(ScenarioInfo.MissionNumber or 'nil')..'; iTeam='..iTeam..'; C M6: ScenarioInfo.ControlCenter is nil='..tostring(ScenarioInfo.ControlCenter == nil)..'; ScenarioInfo.Czar is nil='..tostring(ScenarioInfo.Czar == nil)..'; Is table of czars empty='..tostring(M28Utilities.IsTableEmpty(ScenarioInfo.Czar))..'; Is M3P1 active='..tostring(ScenarioInfo.M3P1.Active)..'; Is M3P2 active='..tostring(ScenarioInfo.M3P2.Active)..'; Is there a valid black sun unit='..tostring(M28UnitInfo.IsUnitValid(ScenarioInfo.BlackSunWeapon))..'; UEF M5: Is ScenarioInfo.M1P2.Active='..tostring(ScenarioInfo.M1P2.Active or false)..'; Is research facility 1 nil='..tostring(ScenarioInfo.ResearchFacility1 == nil)..'; Is research facility 2 nil='..tostring(ScenarioInfo.ResearchFacility2 == nil))
            if M28UnitInfo.IsUnitValid(ScenarioInfo.BlackSunWeapon) then LOG(sFunctionRef..': Have a valid black sun unit, Target[1].UnitId='..(Target[1].UnitId or 'nil')..'; Black sun brain owner='..ScenarioInfo.BlackSunWeapon:GetAIBrain().Nickname..'; Faction index='..ScenarioInfo.BlackSunWeapon:GetAIBrain():GetFactionIndex()) end
            LOG(sFunctionRef..': Sera M3 logs, Is M4P3 active='..tostring(ScenarioInfo.M4P3.Active)..'; Is target category urc1901='..tostring(Target.Requirements[1].Category == categories.urc1901)..'; Target.Area='..(Target.Requirements[1].Area or 'nil')..'; reprs of ScenarioInfo.M2P2='..reprs(ScenarioInfo.M2P2)..'; reprs of Target='..reprs(Target))
            LOG(sFunctionRef..': Aeon M5 check, if ScenarioInfo.M2P1Obj.Active='..tostring(ScenarioInfo.M2P1Obj.Active or false)..'; ScenarioInfo.Ariel==nil='..tostring(ScenarioInfo.Ariel == nil)..'; Colonies is nil='..tostring(ScenarioInfo.Colonies == nil)..'; tbSpecialCodeForMission[21]='..tostring(tbSpecialCodeForMission[21] or false))
        end
        if ScenarioInfo.M4P1 and M28Utilities.IsTableEmpty(Target.Units) and ScenarioInfo.M4P1.Active and M28UnitInfo.IsUnitValid(ScenarioInfo.AeonCDR) then
            if bDebugMessages == true then LOG(sFunctionRef..': Creating manual on death trigger') end
            local ScenarioFramework = import('/lua/ScenarioFramework.lua')
            ScenarioFramework.CreateUnitDeathTrigger(M28ErisKilled, ScenarioInfo.AeonCDR)
            --UEF Mission 5 - send ACU to gateway
        elseif ScenarioInfo.M3P3.Active and Scenario.Areas['CDR_Gate_Area'] and ScenarioInfo.PlayerCDRs then
            --local rRect = import("/lua/sim/scenarioutilities.lua").AreaToRect('CDR_Gate_Area')
            local tRect = import("/lua/sim/scenarioutilities.lua").AreaToRect('CDR_Gate_Area')
            local rRect = {tRect['x0'], tRect['y0'], tRect['x1'], tRect['y1']}
            if bDebugMessages == true then LOG(sFunctionRef..': rRect='..repru(rRect)..'; AreaToRect='..repru(import("/lua/sim/scenarioutilities.lua").AreaToRect('CDR_Gate_Area'))) end
            if rRect then
                local tMidpoint = {(rRect[1] + rRect[3])*0.5, 0, (rRect[2] + rRect[4])*0.5}
                tMidpoint[2] = GetTerrainHeight(tMidpoint[1], tMidpoint[3])
                for iUnit, oUnit in ScenarioInfo.PlayerCDRs do
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        LOG(sFunctionRef..': Considering ACU owned by brain '..oUnit:GetAIBrain().Nickname..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; if M28 then will set objective to tMidpoint='..repru(tMidpoint))
                        if oUnit:GetAIBrain().M28AI and not(oUnit:GetAIBrain().CampaignAI) then
                            oUnit[M28ACU.reftSpecialObjectiveMoveLocation] = {tMidpoint[1], tMidpoint[2], tMidpoint[3]}
                        end
                    end
                end
            end
        elseif ScenarioInfo.M1_TempleCombinedTable and (ScenarioInfo.M1P3.Active or ScenarioInfo.M1P2.Active) then
            if bDebugMessages == true then LOG(sFunctionRef..': Will check if we have Seraphim temples that need manually destroying') end
            if M28Utilities.IsTableEmpty(   ScenarioInfo.M1_TempleCombinedTable) == false and M28Utilities.IsTableEmpty(tAllActiveM28Brains) == false then

                for iUnit, oUnit in ScenarioInfo.M1_TempleCombinedTable do
                    --Add to table of units in the land zone (if it is in a land zone)
                    local iPlateau, iLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
                    if (iLandZone or 0) > 0 then
                        local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                        local bAddToTable = true
                        if not(tLZTeamData[M28Map.reftoGroundFireFriendlyTarget]) then tLZTeamData[M28Map.reftoGroundFireFriendlyTarget] = {}
                        else
                            for iRecordedUnit, oRecordedUnit in tLZTeamData[M28Map.reftoGroundFireFriendlyTarget] do
                                if oRecordedUnit == oUnit then
                                    bAddToTable = false
                                    break
                                end
                            end
                        end
                        if bAddToTable then
                            if bDebugMessages == true then LOG(sFunctionRef..': Added unit to the land zone team table of ground fire targets') end
                            table.insert(tLZTeamData[M28Map.reftoGroundFireFriendlyTarget], oUnit)
                        end
                    end
                end
            end
            --Cybran mission 2 - move to gate
        elseif ScenarioInfo.M3P2.Active and ScenarioInfo.M3Gate and M28UnitInfo.IsUnitValid(ScenarioInfo.M3Gate) then
            for iBrain, oBrain in tAllActiveM28Brains do
                if not(oBrain.CampaignAI) then
                    local tACUs = oBrain:GetListOfUnits(categories.COMMAND, false, true)
                    if M28Utilities.IsTableEmpty(tACUs) == false then
                        for iUnit, oUnit in tACUs do
                            LOG(sFunctionRef..': Considering ACU owned by brain '..oUnit:GetAIBrain().Nickname..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; if M28 then will set objective to gate position='..repru(ScenarioInfo.M3Gate:GetPosition()))
                            oUnit[M28ACU.reftSpecialObjectiveMoveLocation] = ScenarioInfo.M3Gate:GetPosition()
                        end
                    end
                end
            end
            --Cybran mission 4 - play defensively and let human player try and capture the nodes
        elseif ScenarioInfo.M3BaseDamageWarnings and ScenarioInfo.MainFrameIsAlive and not ScenarioInfo.EMPFired and (ScenarioInfo.M3_Base or Scenario.Areas['Aeon_Base_M3']) and not(bPacifistModeActive) then
            --Reset base warnings to help M28 a bit since it can trigger the damage before this objective is even active
            if ScenarioInfo.M3BaseDamageWarnings > 0 then ScenarioInfo.M3BaseDamageWarnings = 0 end
            local tUnitsToConsider = ScenarioInfo.M3_Base
            if not(tUnitsToConsider) then
                local ScenarioFramework = import('/lua/ScenarioFramework.lua')
                tUnitsToConsider = ScenarioFramework.GetCatUnitsInArea(categories.STRUCTURE - categories.WALL, 'Aeon_Base_M3', ArmyBrains[ScenarioInfo.Aeon])
            end
            if M28Utilities.IsTableEmpty(tUnitsToConsider) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to disable attacking parts of the map that could cause us to fail the mission') end
                bPacifistModeActive = true

                tiPacifistZonesByPlateau = {}
                local tbHasPlateauAndZoneBeenRecorded = {}
                local iCurPlateauOrZero, iCurLandOrWaterZone
                for iUnit, oUnit in ScenarioInfo.M3_Base do
                    iCurPlateauOrZero, iCurLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                    if iCurPlateauOrZero and iCurLandOrWaterZone and not(tbHasPlateauAndZoneBeenRecorded[iCurPlateauOrZero][iCurLandOrWaterZone]) then
                        if not(tiPacifistZonesByPlateau[iCurPlateauOrZero]) then tiPacifistZonesByPlateau[iCurPlateauOrZero] = {} end
                        table.insert(tiPacifistZonesByPlateau[iCurPlateauOrZero], iCurLandOrWaterZone)
                        if not(tbHasPlateauAndZoneBeenRecorded[iCurPlateauOrZero]) then tbHasPlateauAndZoneBeenRecorded[iCurPlateauOrZero] = {} end
                        tbHasPlateauAndZoneBeenRecorded[iCurPlateauOrZero][iCurLandOrWaterZone] = true
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished recording the plateaus and zones that units in M3_Base are in, repru of tiPacifistZonesByPlateau='..repru(tiPacifistZonesByPlateau)) end
                if M28Utilities.IsTableEmpty(tiPacifistZonesByPlateau) == false then
                    --Record any adjacent zones
                    local tiAdjacentZonesByPlateau = {}
                    for iPlateauOrZero, tBaseSubtable in tiPacifistZonesByPlateau do
                        for iEntry, iLandOrWaterZone in tBaseSubtable do
                            local tLZOrWZData
                            if iPlateauOrZero == 0 then
                                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                                --Water zone: Adjacent land zones
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering water zone '..iLandOrWaterZone..'; Is table of adjacent land zones empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentLandZones]))) end
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentLandZones]) == false then
                                    for iEntry, tSubtable in tLZOrWZData[M28Map.subrefAdjacentLandZones] do
                                        local iPlateauRef = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                                        local iAdjZoneRef = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjZoneRef='..iAdjZoneRef..'; iPlateauRef='..iPlateauRef) end
                                        if not(tbHasPlateauAndZoneBeenRecorded[iPlateauRef][iAdjZoneRef]) then
                                            tbHasPlateauAndZoneBeenRecorded[iPlateauRef][iAdjZoneRef] = true
                                            if not(tiAdjacentZonesByPlateau[iPlateauRef]) then tiAdjacentZonesByPlateau[iPlateauRef] = {} end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Adding iAdjZoneRef='..iAdjZoneRef..'; to table') end
                                            table.insert(tiAdjacentZonesByPlateau[iPlateauRef], iAdjZoneRef)
                                        end
                                    end
                                end
                                --Water zone: Adjacent water zones:
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefWZAdjacentWaterZones]))) end
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                                    for _, iAdjZoneRef in tLZOrWZData[M28Map.subrefWZAdjacentWaterZones] do
                                        if not(tbHasPlateauAndZoneBeenRecorded[0][iAdjZoneRef]) then
                                            if not(tbHasPlateauAndZoneBeenRecorded[0]) then tbHasPlateauAndZoneBeenRecorded[0] = {} end
                                            tbHasPlateauAndZoneBeenRecorded[0][iAdjZoneRef] = true
                                            if not(tiAdjacentZonesByPlateau[0]) then tiAdjacentZonesByPlateau[0] = {} end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Adding WZ iAdjZoneRef='..iAdjZoneRef..'; to table') end
                                            table.insert(tiAdjacentZonesByPlateau[0], iAdjZoneRef)
                                        end
                                    end
                                end
                            else
                                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                                --Land zone: Adjacent land zones
                                if bDebugMessages == true then LOG(sFunctionRef..': Dealing with land zone, is table of adjacent land zones empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]))) end
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                    for _, iAdjZoneRef in tLZOrWZData[M28Map.subrefLZAdjacentLandZones] do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjZoneRef='..iAdjZoneRef..' in iPlateuOrZero='..iPlateauOrZero) end
                                        if not(tbHasPlateauAndZoneBeenRecorded[iPlateauOrZero][iAdjZoneRef]) then
                                            if not(tbHasPlateauAndZoneBeenRecorded[iPlateauOrZero]) then tbHasPlateauAndZoneBeenRecorded[iPlateauOrZero] = {} end
                                            tbHasPlateauAndZoneBeenRecorded[iPlateauOrZero][iAdjZoneRef] = true
                                            if not(tiAdjacentZonesByPlateau[iPlateauOrZero]) then tiAdjacentZonesByPlateau[iPlateauOrZero] = {} end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Adding LZ iAdjZoneRef='..iAdjZoneRef..'; to table') end
                                            table.insert(tiAdjacentZonesByPlateau[iPlateauOrZero], iAdjZoneRef)
                                        end
                                    end
                                end
                                --Land zone: Adjacent water zone:
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]))) end
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]) == false then
                                    for iEntry, tSubtable in tLZOrWZData[M28Map.subrefAdjacentWaterZones] do
                                        local iAdjZoneRef = tSubtable[M28Map.subrefAWZRef]
                                        if not(tbHasPlateauAndZoneBeenRecorded[0][iAdjZoneRef]) then
                                            if not(tbHasPlateauAndZoneBeenRecorded[0]) then tbHasPlateauAndZoneBeenRecorded[0] = {} end
                                            tbHasPlateauAndZoneBeenRecorded[0][iAdjZoneRef] = true
                                            if not(tiAdjacentZonesByPlateau[0]) then tiAdjacentZonesByPlateau[0] = {} end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Adding WZ iAdjZoneRef='..iAdjZoneRef..'; to table') end
                                            table.insert(tiAdjacentZonesByPlateau[0], iAdjZoneRef)
                                        end
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': About to add adjacent zones to core zone, tiAdjacentZonesByPlateau='..repru(tiAdjacentZonesByPlateau)) end
                    if M28Utilities.IsTableEmpty(tiAdjacentZonesByPlateau) == false then
                        for iPlateauOrZero, tSubtable in tiAdjacentZonesByPlateau do
                            for iEntry, iAdjZoneRef in tSubtable do
                                if not(tiPacifistZonesByPlateau[iPlateauOrZero]) then tiPacifistZonesByPlateau[iPlateauOrZero] = {} end
                                if bDebugMessages == true then LOG(sFunctionRef..': Adding iAdjZoneRef='..iAdjZoneRef..' for iPlateauOrZero='..iPlateauOrZero) end
                                table.insert(tiPacifistZonesByPlateau[iPlateauOrZero], iAdjZoneRef)
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished adding adjacent zones, repru of adjacent zones by plateau='..repru(tiAdjacentZonesByPlateau)) end

                    for iPlateauOrZero, tSubtable in tiPacifistZonesByPlateau do
                        for iEntry, iLandOrWaterZone in tSubtable do
                            local tLZOrWZData
                            if iPlateauOrZero == 0 then
                                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                            else
                                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                            end
                            tLZOrWZData[M28Map.subrefbPacifistArea] = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Set pacifist flag to true for iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone) end
                        end
                    end
                end
            end
        elseif bPacifistModeActive and ScenarioInfo.EMPFired and M28Utilities.IsTableEmpty(tiPacifistZonesByPlateau) == false then
            --Disable pacifist flag
            if bDebugMessages == true then LOG(sFunctionRef..': EMP has been fired so will disable pacifist flag for all recorded zones, tiPacifistZonesByPlateau='..repru(tiPacifistZonesByPlateau)) end
            bPacifistModeActive = false
            for iPlateauOrZero, tSubtable in tiPacifistZonesByPlateau do
                local tLZOrWZData
                for iEntry, iLandOrWaterZone in tSubtable do
                    if iPlateauOrZero == 0 then
                        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                    else
                        tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                    end
                    tLZOrWZData[M28Map.subrefbPacifistArea] = false
                end
            end
            --Cybran mission 6 - activate black sun (below is as a redundancy but doesnt actually trigger - are reliant on the oncapture event instead)
        elseif ScenarioInfo.M3P2.Active and M28UnitInfo.IsUnitValid(ScenarioInfo.BlackSunWeapon) and ScenarioInfo.BlackSunWeapon:GetAIBrain().M28AI and ScenarioInfo.BlackSunWeapon:GetAIBrain():GetFactionIndex() == M28UnitInfo.refFactionCybran then
            if bDebugMessages == true then LOG(sFunctionRef..': Want to fire black sun to complete cybran campaign - will fire in a bit') end
            ForkThread(DelayedCybranFireBlackSun, ScenarioInfo.BlackSunWeapon:GetAIBrain())
            --Cybran mission 6 - kill Czar
        elseif ScenarioInfo.ControlCenter and ScenarioInfo.Czar and M28Utilities.IsTableEmpty(ScenarioInfo.Czar) == false and ScenarioInfo.M1P1.Active then
            function DelayedRecordingOfCzar(tUnits)
                WaitSeconds(15)
                if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting, time='..GetGameTimeSeconds()..' is table of units empty='..tostring(M28Utilities.IsTableEmpty(tUnits))) end
                if M28Utilities.IsTableEmpty(tUnits) == false then
                    for iUnit, oUnit in tUnits do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            if EntityCategoryContains(M28UnitInfo.refCategoryAllAir * categories.EXPERIMENTAL, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will record enemy Czar as a priority enemy air experimental target unless it is alrady recorded') end
                                local bAlreadyIncluded = false
                                if not(M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives]) then M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives] = {}
                                else
                                    for iRecordedUnit, oRecordedUnit in M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives] do
                                        if oRecordedUnit == oUnit then bAlreadyIncluded = true break end
                                    end
                                end
                                if not(bAlreadyIncluded) then
                                    table.insert(M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives], oUnit)
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will wait a while and then look to include enemy Czar as a priority enemy air experimental target unless it is alrady recorded') end
            local tUnits = {}
            --Work whether Czar is a table or a isngle unit
            if M28UnitInfo.IsUnitValid(ScenarioInfo.Czar) and ScenarioInfo.Czar.UnitId then table.insert(tUnits, ScenarioInfo.Czar)
            else tUnits = ScenarioInfo.Czar
            end
            ForkThread(DelayedRecordingOfCzar, tUnits)
            --Cybran M6 - fire black sun if it is owned by M28 and we are on the objective to fire it
        elseif ScenarioInfo.M7_FauxUEFCommanderUnit then
            ForkThread(M1AeonEndMissionBackupMonitor)
        elseif ScenarioInfo.M1P1Obj.Active and Target.MarkArea and Target.Requirements and Target.Category == categories.uab4301 then --Aeon mission 5 - build UEF T3 shield
            M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] = true
            M28Team.tTeamData[iTeam][M28Team.refiEnemyT3ArtiCount] = 1
            if bDebugMessages == true then LOG(sFunctionRef..': Want to build T3 shielding for Aeon M5') end
            local iOurBrainIndex = M28Team.GetFirstActiveM28Brain(iTeam):GetArmyIndex()
            for iTarget, tRequirements in Target.Requirements do
                local tRect = import("/lua/sim/scenarioutilities.lua").AreaToRect(tRequirements.Area)
                local tBaseAreaForRect = {tRect['x0'], tRect['y0'], tRect['x1'], tRect['y1']}
                if bDebugMessages == true then LOG(sFunctionRef..': rRect='..repru(tBaseAreaForRect)..'; tRequirements.Area='..reprs(tRequirements.Area)..'; AreaToRect='..repru(import("/lua/sim/scenarioutilities.lua").AreaToRect(tRequirements.Area))) end
                if tBaseAreaForRect then
                    local iRadiusAdjust = -16
                    local rRect = Rect(tBaseAreaForRect[1] - iRadiusAdjust, tBaseAreaForRect[2] - iRadiusAdjust, tBaseAreaForRect[3] + iRadiusAdjust, tBaseAreaForRect[4] + iRadiusAdjust)
                    if bDebugMessages == true then LOG(sFunctionRef..': rRect to search after adjust='..repru(rRect)) end
                    local tUnitsInRect = GetUnitsInRect(rRect)
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of units in rec empty='..tostring(M28Utilities.IsTableEmpty(tUnitsInRect))) end
                    if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                        local tBuildingsInRect = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tUnitsInRect)
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of tBuildingsInRect empty='..tostring(M28Utilities.IsTableEmpty(tBuildingsInRect))) end
                        if M28Utilities.IsTableEmpty(tBuildingsInRect) == false then
                            for iUnit, oUnit in tBuildingsInRect do
                                if not(IsEnemy(oUnit:GetAIBrain():GetArmyIndex(), iOurBrainIndex)) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Sending unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to function to assign shielding requirement') end
                                    M28Building.CheckIfUnitWantsFixedShield(oUnit, true, 1)
                                end
                            end
                        end
                    end
                    local tMidpoint = {(tBaseAreaForRect[1] + tBaseAreaForRect[3]) * 0.5, 0, (tBaseAreaForRect[2] + tBaseAreaForRect[4]) * 0.5}
                    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tMidpoint)
                    local tMidpointLZData, tMidpointLZTeamData = M28Map.GetLandOrWaterZoneData(tMidpoint, true, iTeam)
                    local iTotalSegments = table.getn(tMidpointLZData[M28Map.subrefLZSegments])
                    local iSegmentStart = (tMidpointLZData[M28Map.subrefiLastSegmentEntryConsideredForBuilding] or 0)
                    if bDebugMessages == true then LOG(sFunctionRef..': Midpoint='..repru(tMidpoint)..'; iLandOrWaterZone='..iLandOrWaterZone..'; iTotalSegments='..iTotalSegments..'; iSegmentStart='..iSegmentStart) end
                    local iCurCycleCount = 0
                    local iWaitCycleCount = 0
                    while iSegmentStart < iTotalSegments * 0.9 do
                        iCurCycleCount = iCurCycleCount + 1
                        iWaitCycleCount = iWaitCycleCount + 1
                        if iWaitCycleCount >= 100 then
                            iWaitCycleCount = 0
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitTicks(1)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        end
                        if iCurCycleCount >= 10000 then break end
                        M28Engineer.SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, math.min(100, math.floor(iTotalSegments * 0.1)))
                        iTotalSegments = table.getn(tMidpointLZData[M28Map.subrefLZSegments])
                        iSegmentStart = (tMidpointLZData[M28Map.subrefiLastSegmentEntryConsideredForBuilding] or 0)
                        if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; iTotalSegments='..iTotalSegments..'; iSegmentStart='..iSegmentStart) end
                    end
                end
            end
            --Aeon Mission 5 - build SMD
        elseif ScenarioInfo.M1P2Obj.Active and Target.MarkArea and Target.Category == categories.uab4302 and Target.Areas then
            local ScenarioUtilities = import("/lua/sim/scenarioutilities.lua")

            for iArea, sArea in Target.Areas do
                local tRect = ScenarioUtilities.AreaToRect(sArea)
                local tBaseAreaForRect = {tRect['x0'], tRect['y0'], tRect['x1'], tRect['y1']}
                if bDebugMessages == true then LOG(sFunctionRef..': tRect='..repru(tRect)..'; tBaseAreaForRect='..repru(tBaseAreaForRect)..'; sArea='..sArea) end
                if tBaseAreaForRect then
                    local tMidpoint = {(tBaseAreaForRect[1] + tBaseAreaForRect[3]) * 0.5, 0, (tBaseAreaForRect[2] + tBaseAreaForRect[4]) * 0.5}
                    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tMidpoint)
                    if iPlateauOrZero > 0 and (iLandOrWaterZone or 0) > 0 then
                        local tMidpointLZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
                        tMidpointLZTeamData[M28Map.reftObjectiveSMDLocation] = {tMidpoint[1], GetSurfaceHeight(tMidpoint[1], tMidpoint[3]), tMidpoint[3]}
                        if bDebugMessages == true then LOG(sFunctionRef..': Set SMD location for iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; Location='..repru(tMidpointLZTeamData[M28Map.reftObjectiveSMDLocation])) end
                    end

                end
            end
            --UEF M5 - build SMD and protect research facilities with heavy shields
        elseif (ScenarioInfo.ResearchFacility1 or ScenarioInfo.ResearchFacility2 or ScenarioInfo.ResearchFacility3) then
            if ScenarioInfo.M1P2.Active then
                local tResearchLocations = {}
                if M28UnitInfo.IsUnitValid(ScenarioInfo.ResearchFacility1) then
                    table.insert(tResearchLocations, ScenarioInfo.ResearchFacility1:GetPosition())
                end
                if M28UnitInfo.IsUnitValid(ScenarioInfo.ResearchFacility2) then
                    table.insert(tResearchLocations, ScenarioInfo.ResearchFacility2:GetPosition())
                end
                if M28UnitInfo.IsUnitValid(ScenarioInfo.ResearchFacility3) then
                    table.insert(tResearchLocations, ScenarioInfo.ResearchFacility3:GetPosition())
                end
                if M28Utilities.IsTableEmpty(tResearchLocations) == false then
                    for iEntry, tLocation in tResearchLocations do
                        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tLocation)
                        if (iLandZone or 0) > 0 then
                            local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                            tLZTeamData[M28Map.reftObjectiveSMDLocation] = {tLocation[1], tLocation[2], tLocation[3]}
                            if bDebugMessages == true then LOG(sFunctionRef..': Added SMD location for Plateau '..iPlateau..'; Zone '..iLandZone) end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': tResearchLocations='..reprs(tResearchLocations)) end
            elseif ScenarioInfo.M1P1.Active then
                --Make sure research centres are added to list of buildings to shield
                local oUnit = ScenarioInfo.ResearchFacility1
                if M28UnitInfo.IsUnitValid(oUnit) then M28Building.CheckIfUnitWantsFixedShield(oUnit, true, 1) end
                oUnit = ScenarioInfo.ResearchFacility2
                if M28UnitInfo.IsUnitValid(oUnit) then M28Building.CheckIfUnitWantsFixedShield(oUnit, true, 1) end
                oUnit = ScenarioInfo.ResearchFacility3
                if M28UnitInfo.IsUnitValid(oUnit) then M28Building.CheckIfUnitWantsFixedShield(oUnit, true, 1) end
            end
        elseif ScenarioInfo.M4P3.Active and Target.Requirements[1].Category == categories.urc1901 and Target.Requirements[1].Area then --Seraphim M3 - protect QAI mainframe (as objective currently has strange way of doing this where it tracks the area rather htan the unit)

            local ScenarioUtilities = import("/lua/sim/scenarioutilities.lua")
            local tRect = ScenarioUtilities.AreaToRect(Target.Requirements[1].Area)
            local tBaseAreaForRect = {tRect['x0'], tRect['y0'], tRect['x1'], tRect['y1']}
            if bDebugMessages == true then LOG(sFunctionRef..': Will add QAI mainframe as a priority defence target, tRect='..repru(tRect)..';tBaseAreaForRect='..repru(tBaseAreaForRect)..'; Target.Requirements[1].Area='..(Target.Requirements[1].Area or 'nil')) end
            local tUnitsInRect = GetUnitsInRect(tRect)
            if bDebugMessages == true then LOG(sFunctionRef..': Is tUnitsInRect empty='..tostring(M28Utilities.IsTableEmpty(tUnitsInRect))) end
            if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                local tQAIMainframes = EntityCategoryFilterDown(Target.Requirements[1].Category, tUnitsInRect)
                if bDebugMessages == true then LOG(sFunctionRef..': Is tQAIMainframes empty='..tostring(M28Utilities.IsTableEmpty(tQAIMainframes))) end
                if M28Utilities.IsTableEmpty(tQAIMainframes) == false then
                    for iUnit, oUnit in tQAIMainframes do
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' as a priority air defence target') end
                        M28Air.AddPriorityAirDefenceTarget(oUnit)
                    end
                end
            end
            --Dawn (FA Mission 2) - add redundancy so upgraidng facotires doesnt break the objective - solved via callback appraoch instead
            --[[elseif M28Utilities.IsTableEmpty(ScenarioInfo.M1P1Units) == false and not(ScenarioInfo.M1P2.Active) and ScenarioInfo.M1P1.Active then
                --Monitor the M1P1 units and remove any that become obsolete
                LOG(sFunctionRef..': Want to monitor ScenarioInfo.M1P1Units units, will list out each unit, is table empty='..tostring(ScenarioInfo.M1P1Units))
                for iUnit, oUnit in ScenarioInfo.M1P1Units do
                    LOG(sFunctionRef..': iUnit='..iUnit..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is valid='..tostring(M28UnitInfo.IsUnitValid(oUnit)))
                end
                ForkThread(MonitorObjectiveUnitsAndRemoveIfDead, ScenarioInfo.M1P1Units, 1, ScenarioInfo.M1P1)
                --]]
            --Dawn (FA Mission 2) - redundancy for case where first objective (kill attack) is done but second (destroy order base) doesnt trigger - commented out as in the particular case this function (i.e. considering special campaign objectives) only triggers when the attack wave is still alive, and doesnt trigger when the units die
            --[[elseif ScenarioInfo.M1P1Units and ScenarioInfo.M1OrderAttack and not(ScenarioInfo.M1P2.Active) then
                --If we have alive units in M1P1Units then are still scenario 1
                local bHaveAliveBaseUnits = false
                local bHaveAliveAttackUnits = false
                for iUnit, oUnit in ScenarioInfo.M1OrderAttack do
                    if not(oUnit.Dead) then bHaveAliveAttackUnits = true break end
                end
                for iUnit, oUnit in ScenarioInfo.M1P1Units do
                    if not(oUnit.Dead) then
                        bHaveAliveBaseUnits = true
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': bHaveAliveAttackUnits='..tostring(bHaveAliveAttackUnits)..'; bHaveAliveBaseUnits='..tostring(bHaveAliveBaseUnits)..'; ScenarioInfo.M1P1.Active='..tostring(ScenarioInfo.M1P1.Active or false)) end
                if not(bHaveAliveAttackUnits) and bHaveAliveBaseUnits then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will do delayed check if mission active') end
                    WaitSeconds(300)
                    if not(ScenarioInfo.M1P2.Active) then
                        ScenarioInfo.M1P1:ManualResult(true)
                    end
                end--]]
            --Dawn - update enemy unit tables after brief delay
        elseif ScenarioInfo.QAICommander and ScenarioInfo.M4P1.Active and not(tbSpecialCodeForMission[41]) then
            tbSpecialCodeForMission[41] = true
            --Have had a change in factions, update all unit tables
            if bDebugMessages == true then LOG(sFunctionRef..': ScenarioInfo.OrderAlly='..tostring(ScenarioInfo.OrderAlly or false)..'; Time='..GetGameTimeSeconds()) end
            ForkThread(UpdateAllRecordedUnitsFollowingTeamChange, ScenarioInfo.OrderAlly)
            --FA M6 - Fletcher changing sides
        elseif ScenarioInfo.M2P1.Active and ScenarioInfo.FletcherACU and not(tbSpecialCodeForMission[21]) then
            tbSpecialCodeForMission[21] = true
            --Have had a change in factions, update all unit tables
            if bDebugMessages == true then LOG(sFunctionRef..': Will update recorded units following fletcher changing sides, Time='..GetGameTimeSeconds()) end
            ForkThread(UpdateAllRecordedUnitsFollowingTeamChange)
            --SC Aeon M5 - UEF changing sides
        elseif ScenarioInfo.M2P1Obj.Active and ScenarioInfo.Ariel and ScenarioInfo.Colonies and not(tbSpecialCodeForMission[21]) then
            tbSpecialCodeForMission[21] = true
            --Have had a change in factions, update all unit tables
            if bDebugMessages == true then LOG(sFunctionRef..': Will update recorded units following uef alliance changes so arti is detected, changing sides, Time='..GetGameTimeSeconds()) end
            ForkThread(UpdateAllRecordedUnitsFollowingTeamChange)
            --Operation trident - dont reclaim the civilians
        elseif ScenarioInfo.M1CivilianCity and M28Utilities.IsTableEmpty(ScenarioInfo.M1CivilianCity) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Will flag every unit in civilian city to not be a reclaim target, Time='..GetGameTimeSeconds()) end
            for iUnit, oUnit in ScenarioInfo.M1CivilianCity do
                oUnit[M28UnitInfo.refbIsReclaimTarget] = false
                if M28Utilities.IsTableEmpty(oUnit[M28UnitInfo.refiTeamsWithThisAsReclaimTarget]) == false then
                    for iEntry, iTeam in oUnit[M28UnitInfo.refiTeamsWithThisAsReclaimTarget] do
                        local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoUnitsToReclaim]) == false then
                            for iRecorded, oRecorded in tLZTeamData[M28Map.subreftoUnitsToReclaim] do
                                if oRecorded == oUnit then
                                    table.remove(tLZTeamData[M28Map.subreftoUnitsToReclaim], iRecorded)
                                    break
                                end
                            end
                        end
                    end
                    oUnit[M28UnitInfo.refiTeamsWithThisAsReclaimTarget] = nil
                    if bDebugMessages == true then LOG(sFunctionRef..': Removed unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from table of units wanting reclaiming in this zone for all teams') end
                end
            end
            --Fort clarke assault - dont control seraphim bombers in the short period after cutscene ends and the main game starts if we have M28 taking control of allies
        elseif ScenarioInfo.Seraphim and ScenarioInfo.CoopCDR and ScenarioInfo.UnitNames[ScenarioInfo.Seraphim]['NIS_Bomber_1'] and (ScenarioInfo.Options.CampAI == 2 or ScenarioInfo.Options.CampAI == 4) then
            if bDebugMessages == true then LOG(sFunctionRef..': Will disable orders for the experimental bombers') end
            for iBomber = 1, 3 do
                local oUnit = ScenarioInfo.UnitNames[ScenarioInfo.Seraphim]['NIS_Bomber_'..iBomber]
                if oUnit then
                    if bDebugMessages == true then LOG(sFunctionRef..': Setting micro flag for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                    M28Micro.TrackTemporaryUnitMicro(oUnit, 90, nil, false)
                end
            end
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': No active M28 brains so aborting') end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateAllRecordedUnitsFollowingTeamChange(tbOptionalVariableToBeTrue)
    --E.g. for Dawn M2 where order switches from enemy to ally of player team - clears all land and water zone details of enemy and allied units, and then re-records all the units
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateAllRecordedUnitsFollowingTeamChange'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(tbOptionalVariableToBeTrue == nil) then
        while not(tbOptionalVariableToBeTrue) do
            if bDebugMessages == true then LOG(sFunctionRef..': tbOptionalVariableToBeTrue is not nil but not true so will wait 1 tyick') end
            WaitTicks(1)
        end
    end

    local tiTeamsToConsider = {}
    for iTeam = 1, M28Team.iTotalTeamCount do
        if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 1 then
            table.insert(tiTeamsToConsider, iTeam)
        end
    end
    local bChangedAlliesOrEnemiesForZone = false
    if bDebugMessages == true then LOG(sFunctionRef..': About to check if any units need updating from allies to enemies or vice versa, tiTeamsToConsider='..repru(tiTeamsToConsider)..'; Time='..GetGameTimeSeconds()) end

    --A player has changed from ally to enemy or vice versa; if M28AI is only applying to one of the two (but not neither, and not both), then will need to update flag
    --e.g. Celene in Dawn
    local oFirstHuman
    for iBrain, oBrain in ArmyBrains do
        if oBrain.Human then
            oFirstHuman = oBrain
            break
        end
    end

    --First consider if we need to create/change team composition
    for iBrain, oBrain in ArmyBrains do
        local bApplyM28AI = M28Conditions.ApplyM28ToOtherAI(oBrain)
        if bDebugMessages == true then LOG(sFunctionRef..': Considering iBrain '..iBrain..' oBrain='..oBrain.Nickname..'; bApplyM28AI='..tostring(bApplyM28AI or false)..'; oBrain.M28AI='..tostring(oBrain.M28AI or false)) end
        if bApplyM28AI and not(oBrain.M28AI) then
            if bDebugMessages == true then LOG(sFunctionRef..': Starting applying M28AI to brain '..oBrain.Nickname) end
            oBrain.M28AI = true --redundancy, below should do this as well
            oBrain['M28BrainSetupRun'] = nil
            DecideWhetherToApplyM28ToCampaignAI(oBrain, nil, true)
            --Make sure we are added to player team if we are an ally
            if IsAlly(oFirstHuman:GetArmyIndex(), oBrain:GetArmyIndex()) then
                local iTeam = oFirstHuman.M28Team
                oBrain.M28Team = iTeam
                if not(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) then
                    M28Utilities.ErrorHandler('Need to add code to handle this scenario - need to run some but not all of the logic for a new team, or just move all players into a brand new team')
                else
                    table.insert(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains], oBrain)
                    table.insert(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains], oBrain)
                    M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] = (M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or 0) + 1
                end
                --Set air subteam
                oBrain.M28AirSubteam = nil
                M28Team.CreateNewAirSubteam(oBrain)
                oBrain.M28LandSubteam = nil
                ForkThread(M28Team.CheckForBrainsWithoutLandSubteam, iTeam, nil, true)
                if bDebugMessages == true then LOG(sFunctionRef..': Finsihed reocrding brain '..oBrain.Nickname..' as a new teammate for team '..iTeam) end
            elseif IsEnemy(oFirstHuman:GetArmyIndex(), oBrain:GetArmyIndex()) then
                local iTeam = oFirstHuman.M28Team
                if (M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or 0) > 0 then
                    table.insert(M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains], oBrain)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': About to reset and create new team for brain '..oBrain.Nickname) end
                oBrain.M28Team = nil
                oBrain.M28LandSubteam = nil
                oBrain.M28AirSubteam = nil
                M28Team.CreateNewTeam(oBrain)
                if oBrain.M28Team then M28Team.CheckForBrainsWithoutLandSubteam(oBrain.M28Team, nil, true) end
                if bDebugMessages == true then LOG(sFunctionRef..': Finsihed creating a new team for brain '..oBrain.Nickname..'; New team='..(oBrain.M28Team or 'nil')..'; Land subteam='..(oBrain.M28LandSubteam or 'nil')..'; Air subteam='..(oBrain.M28AirSubteam or 'nil')..'; Time='..GetGameTimeSeconds()) end
            end
            --Figure out what zone to treat as core base
            WaitTicks(1)
            local tFriendlyFactories = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandHQ + M28UnitInfo.refCategoryAirHQ, false, true)
            if bDebugMessages == true then LOG(sFunctionRef..': Is tFriendlyFactories empty='..tostring(M28Utilities.IsTableEmpty(tFriendlyFactories))) end
            if M28Utilities.IsTableEmpty(tFriendlyFactories) == false then
                local tiFactoriesByPlateauAndZone = {}
                local iCurPlateau, iCurZone
                for iFactory, oFactory in tFriendlyFactories do
                    iCurPlateau, iCurZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oFactory:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oFactory='..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..' in P'..iCurPlateau..'Z'..iCurZone) end
                    if iCurPlateau and iCurZone and iCurPlateau > 0 then
                        if not(tiFactoriesByPlateauAndZone[iCurPlateau][iCurZone]) then
                            if not(tiFactoriesByPlateauAndZone[iCurPlateau]) then tiFactoriesByPlateauAndZone[iCurPlateau] = {} end
                            tiFactoriesByPlateauAndZone[iCurPlateau][iCurZone] = 0
                        end
                    end
                    tiFactoriesByPlateauAndZone[iCurPlateau][iCurZone] = tiFactoriesByPlateauAndZone[iCurPlateau][iCurZone] + M28UnitInfo.GetUnitTechLevel(oFactory)
                end
                local iHighestPlateau, iHighestZone
                local iHighestCount = 0
                if M28Utilities.IsTableEmpty(tiFactoriesByPlateauAndZone) == false then
                    for iPlateau, tZones in tiFactoriesByPlateauAndZone do
                        for iZone, iCount in tZones do
                            if iCount > iHighestCount then
                                iHighestCount = iCount
                                iHighestPlateau = iPlateau
                                iHighestZone = iZone
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iHighestCount='..iHighestCount..'; iHighestPlateau='..iHighestPlateau..'; iHighestZone='..iHighestZone..'; will now flag core base override to true, iTeam='..oBrain.M28Team..'; Brain nickname='..oBrain.Nickname) end
                    if iHighestCount > 0 then
                        local tLZTeamData = M28Map.tAllPlateaus[iHighestPlateau][M28Map.subrefPlateauLandZones][iHighestZone][M28Map.subrefLZTeamData][oBrain.M28Team]
                        tLZTeamData[M28Map.subrefbCoreBaseOverride] = true
                    end
                end
            end


        elseif not(bApplyM28AI) and oBrain.M28AI then
            oBrain.M28AI = false
            oBrain.M28Team = nil
            M28Team.CreateNewTeam(oBrain)
            if bDebugMessages == true then LOG(sFunctionRef..': No longer applying M28AI to brain '..oBrain.Nickname..'; assigned it to the team '..(oBrain.M28Team or 'nil')) end
        end
    end

    --Give time for any brain changes to take effect
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(2)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    function UpdateStatusOfFriendlyAndEnemyUnits(tLZOrWZTeamData, iTeam)
        local iTeamBrainIndex = M28Team.GetFirstActiveM28Brain(iTeam):GetArmyIndex()
        local toFriendlyUnits = {}
        local toEnemyUnits = {}
        local bChangedAlliesOrEnemies = false
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            for iUnit, oUnit in tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do
                if M28UnitInfo.IsUnitValid(oUnit) then
                    if IsAlly(oUnit:GetAIBrain():GetArmyIndex(), iTeamBrainIndex) then
                        table.insert(toFriendlyUnits, oUnit)
                    elseif IsEnemy(oUnit:GetAIBrain():GetArmyIndex(), iTeamBrainIndex) then
                        table.insert(toEnemyUnits, oUnit)
                        bChangedAlliesOrEnemies = true
                    else
                        bChangedAlliesOrEnemies = true
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) == false then
            for iUnit, oUnit in tLZOrWZTeamData[M28Map.subrefTEnemyUnits] do
                if M28UnitInfo.IsUnitValid(oUnit) then
                    if IsEnemy(oUnit:GetAIBrain():GetArmyIndex(), iTeamBrainIndex) then
                        table.insert(toEnemyUnits, oUnit)
                    elseif IsAlly(oUnit:GetAIBrain():GetArmyIndex(), iTeamBrainIndex) then
                        table.insert(toFriendlyUnits, oUnit)
                        bChangedAlliesOrEnemies = true
                    else
                        bChangedAlliesOrEnemies = true
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Updating for team '..iTeam..'; bChangedAlliesOrEnemies='..tostring(bChangedAlliesOrEnemies or false)) end
        if bChangedAlliesOrEnemies then
            bChangedAlliesOrEnemiesForZone = true
            if bDebugMessages == true then LOG(sFunctionRef..': Have a zone with units who have an updated ally/enemy status, iTeam='..iTeam) end
            tLZOrWZTeamData[M28Map.subrefTEnemyUnits] = nil
            tLZOrWZTeamData[M28Map.subrefTEnemyUnits] = toEnemyUnits
            tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits] = nil
            tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits] = toFriendlyUnits
        end
    end
    if M28Utilities.IsTableEmpty(tiTeamsToConsider) == false then
        for iPlateau, tPlateauData in M28Map.tAllPlateaus do
            for iLandZone, tLZData in tPlateauData[M28Map.subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if have any units to update status of for iPlateau='..iPlateau..'; iLandZone='..iLandZone) end
                for _, iTeam in tiTeamsToConsider do
                    UpdateStatusOfFriendlyAndEnemyUnits(tLZData[M28Map.subrefLZTeamData][iTeam], iTeam)
                end
            end
        end

        for iPond, tPondSubtable in M28Map.tPondDetails do
            if M28Utilities.IsTableEmpty(tPondSubtable[M28Map.subrefPondWaterZones]) == false then
                for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
                    for _, iTeam in tiTeamsToConsider do
                        UpdateStatusOfFriendlyAndEnemyUnits(tWZData[M28Map.subrefWZTeamData][iTeam], iTeam)
                    end
                end
            end
        end
        --Update neutral units
        for _, iTeam in tiTeamsToConsider do
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoCampaignNeutralUnitsNotRecorded]) == false then
                local oM28Brain
                local oFirstAnyM28Brain
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    if oBrain.M28AI then
                        if not(oFirstAnyM28Brain) then oFirstAnyM28Brain = oBrain end
                        if not(oM28Brain) and not(oBrain.CampaignAI) then oM28Brain = oBrain end
                    end
                end
                if not(oM28Brain) then oM28Brain = oFirstAnyM28Brain end
                if oM28Brain then
                    local iM28Index = oM28Brain:GetArmyIndex()

                    local tiUnitsToRemove = {}
                    for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftoCampaignNeutralUnitsNotRecorded] do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            --Rerecord if this is now an enemy
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is now an enemy to team '..iTeam..'; oM28Brain='..oM28Brain.Nickname..'; Unit brain owner='..oUnit:GetAIBrain().Nickname..'; Is enemy='..tostring(IsEnemy(oUnit:GetAIBrain():GetArmyIndex(), iM28Index))) end
                            if IsEnemy(oUnit:GetAIBrain():GetArmyIndex(), iM28Index) then
                                oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][iTeam] = nil
                                M28Team.AssignUnitToLandZoneOrPond(oM28Brain, oUnit)
                                table.insert(tiUnitsToRemove, iUnit)
                            end
                        else
                            table.insert(tiUnitsToRemove, iUnit)
                        end
                    end
                    if M28Utilities.IsTableEmpty(tiUnitsToRemove) == false then
                        local iToRemoveTotal = table.getn(tiUnitsToRemove)
                        for iCurRemoval = iToRemoveTotal, 1, -1 do
                            table.remove(tiUnitsToRemove, tiUnitsToRemove[iCurRemoval])
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MonitorObjectiveUnitsAndRemoveIfDead(tUnits, iMissionRef, vMissionStatusVariable)
    --Call via forked thread, intended e.g. for M2 Dawn of FA campaign where upgrading/destroying factories before the objective starts breaks the mission
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MonitorObjectiveUnitsAndRemoveIfDead'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if not(bActiveObjectiveUnitValidMonitorByObjective[iMissionRef]) then
        bActiveObjectiveUnitValidMonitorByObjective[iMissionRef] = true
        while vMissionStatusVariable.Active do
            M28Conditions.IsTableOfUnitsStillValid(tUnits)
            WaitTicks(1)
            if bDebugMessages == true then
                LOG(sFunctionRef..': Finished updating tUnits, is table empty='..tostring(M28Utilities.IsTableEmpty(tUnits))..'; Time='..GetGameTimeSeconds())
                if M28Utilities.IsTableEmpty(tUnits) == false then
                    LOG(sFunctionRef..': Size of tUnits='..table.getn(tUnits))
                end
            end
        end
        --Have moved onto next objective now
        if bDebugMessages == true then
            WaitSeconds(60)
            LOG(sFunctionRef..': after waiting a while size of tUnits='..table.getn(tUnits)..'; Will cycle through each unit')
            for iUnit, oUnit in tUnits do
                LOG(sFunctionRef..': oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Is dead='..tostring(oUnit.Dead or false)..'; reprs of unit='..reprs(oUnit))

            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedM27M28BrainCheck(aiBrain)
    WaitSeconds(1)
    --LOG('Delayed brain check, brain nickname='..aiBrain.Nickname..'; .M27AI='..tostring(aiBrain.M27AI or false)..'; .M28AI='..tostring(aiBrain.M28AI or false))
    if aiBrain.M27AI and aiBrain.M28AI then aiBrain.M28AI = false end
end

function DecideWhetherToApplyM28ToCampaignAI(aiBrain, planName, bDontWait)
    --Wait a second so hopefully isenemy is more accurate
    if not(bDontWait) then WaitSeconds(1) end --also need to update references to iTimeOfLatestBrainToCheckForM28Logic if changing this
    if M28Conditions.ApplyM28ToOtherAI(aiBrain) then
        local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
        aiBrain.M28AI = true
        M28Utilities.bM28AIInGame = true
        --LOG('M28 in game 4')
        if ScenarioInfo.Options.CmApplyAIx == 1 then
            aiBrain.CheatEnabled = true
        end
        if ScenarioInfo.Options.CmM28CampPers == 1 then
            aiBrain.M28Easy = true
        end
        LOG('Setting AI to use M28, aiBrain.Nickname='..(aiBrain.Nickname or 'nil')..'; aiBrain[M28BrainSetupRun] before being cleared='..tostring(aiBrain['M28BrainSetupRun'] or false)..'; ScenarioInfo.Options.CmApplyAIx='..(ScenarioInfo.Options.CmApplyAIx or 'nil')..'; Brain flagged as cheat enabled='..tostring(aiBrain.CheatEnabled or false)..'; aiBrain.M28Easy='..tostring(aiBrain.M28Easy or false))
        ForkThread(M28Events.OnCreateBrain, aiBrain, planName, false)
    end
end


function RemoveUnitsFromPlatoon(oPlatoon, tUnits, bReturnToBase, oPlatoonToAddTo)
    --Intended to remove a particular unit from a platoon e.g. to avoid campaign AI overriding M28 AI
    --if bReturnToBase is true then units will be told to move to aiBrain's base
    --if tUnits isnt in oPlatoon then does nothing
    --oPlatoonToAddTo - optional, if empty, then will try to assign to army pool instead
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RemoveUnitsFromPlatoon'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if oPlatoon and oPlatoon.GetBrain and oPlatoon.GetPlan and not(oPlatoon.Dead) then
        local aiBrain = oPlatoon:GetBrain()

        if bDebugMessages == true then
            LOG(sFunctionRef..': About to list out every unit that is about to be removed')
            for iUnit, oUnit in tUnits do
                if oUnit.GetUnitId then LOG('iUnit='..iUnit..'; oUnitId='..oUnit.UnitId)
                else LOG('iUnit='..iUnit..'; Unit has no unitId') end
            end
        end
        if not(oPlatoonToAddTo == oPlatoon) then
            local oArmyPool = aiBrain:GetPlatoonUniquelyNamed('ArmyPool')
            local sName
            if oPlatoonToAddTo == nil then
                if bDebugMessages == true then LOG(sFunctionRef..': Will add units to army pool') end
                oPlatoonToAddTo = oArmyPool
                sName = 'ArmyPool'
            else
                if oPlatoonToAddTo == oArmyPool then sName = 'ArmyPool'
                else
                    if oPlatoonToAddTo.GetPlan then
                        sName = oPlatoonToAddTo:GetPlan()
                    end
                    if sName == nil then sName = 'nil' end

                    if bDebugMessages == true then LOG(sFunctionRef..': Adding unit to '..sName) end
                end
            end
            if oPlatoonToAddTo == nil then
                LOG(sFunctionRef..': WARNING: oPlatoonToAddTo is nil')
            else
                local sCurPlatoonName
                if oPlatoon == oArmyPool then
                    sCurPlatoonName = 'ArmyPool'
                else
                    sCurPlatoonName = oPlatoon:GetPlan()
                    if sCurPlatoonName == nil then sCurPlatoonName = 'None' end
                    if bDebugMessages == true then LOG(sFunctionRef..': sCurPlatoonName='..sCurPlatoonName) end
                end

                if not(sCurPlatoonName == sName) then
                    if bDebugMessages == true then
                        if oPlatoon == oArmyPool then
                            M28Utilities.ErrorHandler('ideally shouldnt have any units using armypool platoon now, see if can figure out where this came from')
                            LOG(sFunctionRef..': About to remove units from ArmyPool platoon and add to platoon '..sName)
                        else
                            LOG(sFunctionRef..': About to remove units from platoon '..oPlatoon:GetPlan())
                        end
                    end

                    if bReturnToBase == true then
                        if bDebugMessages == true then LOG(sFunctionRef..': Issuing move command to tUnits') end
                        if bDebugMessages == true then LOG(sFunctionRef..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                        local tBase = M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()]
                        for iUnit, oUnit in tUnits do
                            M28Orders.IssueTrackedClearCommands(oUnit)
                            M28Orders.IssueTrackedMove(oUnit, tBase, 10, false, 'PlatRB', false)
                        end
                    end
                    aiBrain:AssignUnitsToPlatoon(oPlatoonToAddTo, tUnits, 'Support', 'GrowthFormation')
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedCheckOfUnitsAtStartOfGame()
    --Sometimes e.g. in a campaign, the map has units pre-created meaning they dont trigger 'oncreate' logic - do a 1-off check at the start of the game for such units
    if not(bCheckForPrecreatedUnitsActive) then
        bCheckForPrecreatedUnitsActive = true
        while not(M28Map.bWaterZoneInitialCreation) or not(M28Map.bFirstM28TeamHasBeenInitialised) or GetGameTimeSeconds() <= 5 do
            WaitTicks(1)
            if GetGameTimeSeconds() >= 10 then break end
        end
        WaitTicks(1)
        local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
        for iBrain, oBrain in ArmyBrains do
            local tAllUnits = oBrain:GetListOfUnits(categories.ALLUNITS - categories.UNSELECTABLE - categories.UNTARGETABLE, false, true)
            if M28Utilities.IsTableEmpty(tAllUnits) == false then
                for iUnit, oUnit in tAllUnits do
                    if not(oUnit['M28OnCrRn']) and oUnit:GetFractionComplete() == 1 then
                        M28Events.OnCreate(oUnit)
                    end
                end
            end
        end
    end

end

function ConsiderUnpausingAllCreatedNukes(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderUnpausingAllCreatedNukes'

    WaitTicks(1) --to ensure we register the units
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iExistingSML = 0
    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
        iExistingSML = iExistingSML + oBrain:GetCurrentUnits(M28UnitInfo.refCategorySML - categories.EXPERIMENTAL)
        if bDebugMessages == true then LOG(sFunctionRef..': Cumulative SML units after considering brain '..oBrain.Nickname..'='..iExistingSML) end
    end
    if iExistingSML >= 4 then
        local tSMLToUnpause = {}
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            local tSML = oBrain:GetListOfUnits(M28UnitInfo.refCategorySML - categories.EXPERIMENTAL, false, true)
            if M28Utilities.IsTableEmpty(tSML) == false then
                for iSML, oSML in tSML do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oSML='..oSML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSML)..'; Have we registered the construction completion of this='..tostring(oSML.M28OnConstructedCalled or false)..'; Fraction complete='..oSML:GetFractionComplete()..'; Is paused nil='..tostring(oSML[M28UnitInfo.refbPaused] == nil)) end
                    if not(oSML.M28OnConstructedCalled) and oSML:GetFractionComplete() == 1 and oSML[M28UnitInfo.refbPaused] == nil then
                        table.insert(tSMLToUnpause, oSML)
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding SML to table of units to unpause; is SML actually paused='..tostring(oSML:IsPaused())) end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of SML to unpause empty='..tostring(M28Utilities.IsTableEmpty(tSMLToUnpause))) end
        if M28Utilities.IsTableEmpty(tSMLToUnpause) == false then
            ForkThread(DelayedUnpauseOfUnits, tSMLToUnpause, 1)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Have a nuke created with 100% completion but no onconstructed logic run, so will consider unpausing every nuke we have, iTeam='..iTeam..'; have got iExistingSML='..iExistingSML..'; have unpaused every SML we own if we have lots now') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedUnpauseOfUnits(tUnits, iDelayInSeconds)
    WaitSeconds(iDelayInSeconds)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DelayedUnpauseOfUnits'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Conditions.IsTableOfUnitsStillValid(tUnits) then
        local tUnitsForFurtherCheck = {}
        for iUnit, oUnit in tUnits do
            if bDebugMessages == true then LOG(sFunctionRef..': About to unpause unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is paused='..tostring(oUnit:IsPaused())..'; Time='..GetGameTimeSeconds()) end
            M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, false)
            if oUnit.EnableShield and oUnit.MyShield then oUnit:EnableShield() end
            if EntityCategoryContains(M28UnitInfo.refCategoryMobileLandShield, oUnit.UnitId) then
                table.insert(tUnitsForFurtherCheck, oUnit)
            end
        end
        if M28Utilities.IsTableEmpty(tUnitsForFurtherCheck) == false then
            ForkThread(SecondDelayedUnpauseCheckForMobileShields, tUnitsForFurtherCheck, 20)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code at time='..GetGameTimeSeconds()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SecondDelayedUnpauseCheckForMobileShields(tUnits, iDelayInSeconds)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SecondDelayedUnpauseCheckForMobileShields'

    WaitSeconds(iDelayInSeconds)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28Conditions.IsTableOfUnitsStillValid(tUnits) then
        if bDebugMessages == true then LOG(sFunctionRef..': Cycling through mobile shields, size of tUnits='..table.getn(tUnits)) end
        local iCurShield, iMaxShield
        for iUnit, oUnit in tUnits do
            iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, true)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering mobile shield oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iMaxShield='..iMaxShield..'; iCurShield='..iCurShield..'; if cur shield is 0 then will try and unpause, aiBrain owner='..oUnit:GetAIBrain().Nickname) end
            if iMaxShield > 0 and iCurShield == 0 then
                oUnit:EnableShield()
                M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, false)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DecideOnGeneralMapStrategy(aiBrain)
    --Decide if we want to consider ignoring T2 mex upgrading and going all in on T1 spam, along with certain other factors such as combat land scouts
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DecideOnGeneralMapStrategy'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --5-10km 1v1 but not winter duel, and can path to enemy by land
    if bDebugMessages == true then LOG(sFunctionRef..': Considering brain '..aiBrain.Nickname..'; Map size='..M28Map.iMapSize..'; Players at start='.. M28Team.iPlayersAtGameStart..'; aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]='..tostring(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand])) end
    if M28Map.iMapSize >= 225 and M28Map.iMapSize <= 512 and M28Team.iPlayersAtGameStart <= 4 and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] then
        --Dont stay at t1 if we have a high AIx modifier or no mexes on map, or a campaign map
        if bDebugMessages == true then LOG(sFunctionRef..': Is low mex map='..tostring(M28Map.bIsLowMexMap)..'; Resource mult='..(aiBrain[M28Economy.refiBrainResourceMultiplier] or 1)..'; Is campaign map='..tostring(M28Map.bIsCampaignMap)) end
        if not(M28Map.bIsLowMexMap) and (aiBrain[M28Economy.refiBrainResourceMultiplier] or 1) <= 1.7 and not(M28Map.bIsCampaignMap) then
            --Are there lots of mexes outside the core bases to fight over, and most are in the core base plateau?
            local iMexesOnMap = table.getn(M28Map.tMassPoints)
            if bDebugMessages == true then LOG(sFunctionRef..': iMexesOnMap='..iMexesOnMap) end
            if iMexesOnMap < 150 then
                local iMexesInStartZones = 0
                local iStartPlateau, iStartZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.GetPlayerStartPosition(aiBrain))
                if iStartPlateau and iStartZone and M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauTotalMexCount] >= 0.8 * iMexesOnMap then
                    local tiStartZones = {}
                    for iBrain, oBrain in tAllAIBrainsByArmyIndex do
                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to include brain start posiiton, oBrain='..oBrain.Nickname..'; Is civilian='..tostring(M28Conditions.IsCivilianBrain(oBrain))) end
                        if not(M28Conditions.IsCivilianBrain(oBrain)) then
                            local iPlateau, iZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.GetPlayerStartPosition(aiBrain))
                            if iPlateau == iStartPlateau then tiStartZones[iZone] = true end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tiStartZones) == false then
                        for iZone, bInclude in tiStartZones do
                            if bDebugMessages == true then LOG(sFunctionRef..': Will include mexes in zone '..iZone..'; Mex count for this zone='..(M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iZone][M28Map.subrefLZMexCount] or 0)) end
                            iMexesInStartZones = iMexesInStartZones + (M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iZone][M28Map.subrefLZMexCount] or 0)
                        end
                    end
                end
                local iMexPercentThreshold = 0.45
                if iMexesOnMap > 80 or M28Team.iPlayersAtGameStart >= 4 then
                    if iMexesOnMap > 130 then iMexPercentThreshold = 0.3
                    else iMexPercentThreshold = 0.375
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iMexesInStartZones='..iMexesInStartZones..'; iMexesOnMap='..iMexesOnMap..'; iMexPercentThreshold='..iMexPercentThreshold..'; M28Team.iPlayersAtGameStart='..M28Team.iPlayersAtGameStart) end
                if iMexesInStartZones < iMexPercentThreshold * iMexesOnMap then
                    M28Team.tTeamData[aiBrain.M28Team][M28Team.refbFocusOnT1Spam] = true
                    ForkThread(M28Team.MonitorLeavingT1SpamMode, aiBrain.M28Team)
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to avoid getting T2 mex upgrade') end
                end
            end
        end

    end

    --Combat land scouts - do if can path to enemy base
    local tStartPosition = M28Map.GetPlayerStartPosition(aiBrain)
    local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(tStartPosition, true, aiBrain.M28Team)
    if tLZData[M28Map.subrefLZIslandRef] == M28Utilities.NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) then
        --We can path to enemy with land
        --if brain is UEF then reduce the threshold, and eliminate entirely if enemy has aeon (as aurora have same range as snoops)
        if aiBrain:GetFactionIndex() == M28UnitInfo.refFactionAeon then
            aiBrain[refiCombatLandScoutThreshold] = 15 --spirits only have 1 dps so this only gives a slight long term benefit in t1 land combat
        elseif not(aiBrain[refiCombatLandScoutThreshold]) then
            if aiBrain:GetFactionIndex() == M28UnitInfo.refFactionUEF then
                for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains] do
                    if oBrain:GetFactionIndex() == M28UnitInfo.refFactionAeon then
                        aiBrain[refiCombatLandScoutThreshold] = 0
                        break
                    end
                end
                if not(aiBrain[refiCombatLandScoutThreshold]) then
                    --We havent considered this before, so can do a random % chance
                    local iRandom = math.random(1, 10)
                    if iRandom >= 8 then
                        aiBrain[refiCombatLandScoutThreshold] = 10
                    elseif iRandom >= 5 then
                        aiBrain[refiCombatLandScoutThreshold] = 5
                    else
                        aiBrain[refiCombatLandScoutThreshold] = 0
                    end
                end
            else
                --Non aeon non-UEF - dont try and build scouts for their combat value
                aiBrain[refiCombatLandScoutThreshold] = 0
            end
        end
    end
    if not(aiBrain[refiCombatLandScoutThreshold]) then aiBrain[refiCombatLandScoutThreshold] = 0 end --redundancy
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function ConsiderSlowdownForHighUnitCount()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderSlowdownForHighUnitCount'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if refiRoughTotalUnitsInGame >= 1500 then --in case the rough number isnt accurate
        local iM28Units = 0
        local oFirstM28Brain
        for iBrain, oBrain in ArmyBrains do
            if not(oBrain.M28IsDefeated) then
                iM28Units = iM28Units + GetArmyUnitCostTotal(oBrain:GetArmyIndex())
                if oBrain.M28AI then oFirstM28Brain = oBrain end
            end
        end
        if iM28Units > 1750 or M28Land.iTicksPerLandCycle > 11 or M28Air.iExtraTicksToWaitBetweenAirCycles > 0 then
            local iOrigTicksPerLandCycle = M28Land.iTicksPerLandCycle
            M28Land.iTicksPerLandCycle = math.min(11, math.max(11, 11 + (iM28Units-1500) / 200, tonumber((ScenarioInfo.Options.M28TimeBetweenOrders or 1))*10+1))
            M28Air.iExtraTicksToWaitBetweenAirCycles = math.max(0,M28Land.iTicksPerLandCycle - 11)
            M28Navy.iTicksPerNavyCycle = math.min(40, M28Land.iTicksPerLandCycle) --want to cap at 40 as bombardment logic considers if we have been bombarding in the last 4s
            if M28Land.iTicksPerLandCycle > iOrigTicksPerLandCycle then
                if oFirstM28Brain.BrainType == 'AI' then
                    M28Chat.SendSlowdownModeMessage(oFirstM28Brain)
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Slowdown mode active, M28Land.iTicksPerLandCycle='..M28Land.iTicksPerLandCycle..'; iOrigTicksPerLandCycle='..iOrigTicksPerLandCycle..'; M28Air.iExtraTicksToWaitBetweenAirCycles='..M28Air.iExtraTicksToWaitBetweenAirCycles) end
        else
            --Use default values
            M28Land.iTicksPerLandCycle = tonumber((ScenarioInfo.Options.M28TimeBetweenOrders or 1))*10+1
            M28Air.iExtraTicksToWaitBetweenAirCycles = 0
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GlobalOverseer()
    --Called once at initial setup if we have an M28 in the game; can be used for tracking things on a global basis (instead of per brain or team)
    local iSlowCycleThreshold = 30
    local iCurSlowCycle = 0

    --Set time between refreshing
    M28Land.iTicksPerLandCycle = tonumber((ScenarioInfo.Options.M28TimeBetweenOrders or 1))*10+1
    M28Air.iExtraTicksToWaitBetweenAirCycles = math.max(0,tonumber((ScenarioInfo.Options.M28TimeBetweenOrders or 1))*10+1 - 11)
    M28Navy.iTicksPerNavyCycle = math.min(40, M28Land.iTicksPerLandCycle) --want to cap at 40 as bombardment logic considers if we have been bombarding in the last 4s

    --ForkThread(DebugCheckProfiling) = true --will  output cur tick each log
    while M28Utilities.bM28AIInGame do
        iCurSlowCycle = iCurSlowCycle + 1
        if iCurSlowCycle >= iSlowCycleThreshold then
            iCurSlowCycle = 0
            ForkThread(ConsiderSlowdownForHighUnitCount)
        end
        WaitSeconds(1) --in case want to add per second logic in the future
    end
end



function DebugCheckProfiling(bJustShowTickCount)
    M28Utilities.ErrorHandler('Debug check profiling is enabled')
    local sFunctionRef = 'DebugCheckProfiling'
    local iTimeInSecondsToStartDetailedDebug = 2278.4 --set to high number if first want to figure out the tick where this happens
    local bSetHook = false --Used for debugging
    if not(bDebugTickCheckerActive) then
        bDebugTickCheckerActive = true
        --Every tick list out the tick - use this function to help identify infinite loops
        while true do
            WaitTicks(1)
            LOG(sFunctionRef..': Cur time='..GetGameTimeSeconds())
            if not(bSetHook) and not(bJustShowTickCount) and GetGameTimeSeconds() >= iTimeInSecondsToStartDetailedDebug then
                bSetHook = true
                M28Profiler.bFunctionCallDebugOverride = true
                --M28Profiler.bGlobalDebugOverride = true --Only enable this if want more detail as it will make things really slow
                debug.sethook(M28Profiler.OutputRecentFunctionCalls, "c", 200)
                LOG(sFunctionRef..': Have started the main hook of function calls')
            end
        end
    end
end

function ConsiderSteamMessageIfNoM28()
    if M28Utilities.bSteamActive then
        WaitSeconds(1)
        local bHaveM28InGame = false
        local oFirstBrain
        for iBrain, oBrain in ArmyBrains do
            if not(oFirstBrain) then oFirstBrain = oBrain end
            if oBrain.M28AI then bHaveM28InGame = true break end
        end
        if not(bHaveM28InGame) and oFirstBrain then
            M28Chat.SendMessage(oFirstBrain, 'SteamAIIssue', 'M28AI mod is active, but no AI have been selected that use M28AI.  Please use either the AI: Easy or AI: Normal AI to apply M28EasyAI or M28AI respectively', 1, 1000, false, false)
        end
    end
end

function SetM28ActiveFlag()
    --Global flag referenced by other orders
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetM28ActiveFlag'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': ScenarioInfo.Options.M28CombinedArmy='..(ScenarioInfo.Options.M28CombinedArmy or 'nil')..'; Time='..GetGameTimeSeconds()) end
    if not(M28Orders.bDontConsiderCombinedArmy == false) and not(tonumber(ScenarioInfo.Options.M28CombinedArmy or 2) == 2) and not(ScenarioInfo.Options.M28CombinedArmy == 4) then
        M28Orders.bDontConsiderCombinedArmy = false
        M28UnitInfo.bDontConsiderCombinedArmy = false
        --Go through every human brain and treat it as an M28AI brain
        for iBrain, oBrain in ArmyBrains do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering oBrain='..oBrain.Nickname) end
            if oBrain.BrainType == 'Human' and not(oBrain.M28AI) then
                LOG('Running M28BrainCreated for brain '..oBrain.Nickname)
                M28BrainCreated(oBrain)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetFirstActiveBrain()
    for iBrain, oBrain in tAllActiveM28Brains do
        if oBrain.IsDefeated and not(oBrain:IsDefeated()) then
            return oBrain
        end
    end
    for iBrain, oBrain in ArmyBrains do
        if oBrain.IsDefeated and not(oBrain:IsDefeated()) then
            return oBrain
        end
    end
    M28Utilities.ErrorHandler('Dont appear to have any active brains')
end

function ReviewTreatingOldBaseAsCoreBase(aiBrain)
    --Claled when aibrain is defeated - if have teammates then will consider treating its old base as a core base once enemy threats dealt with and we have sufficient tech/mexes in the zone, but will also consider turning the flag off
    local sFunctionRef = 'ReviewTreatingOldBaseAsCoreBase'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTeam = aiBrain.M28Team
    local tStartPosition = M28Map.GetPlayerStartPosition(aiBrain)
    local iStartPlateau, iStartZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tStartPosition)

    if iStartPlateau and iStartZone and iStartPlateau > 0 then
        local tLZData = M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iStartZone]
        local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
        --Only consider this for 4+ mex zones and mod dist is <=0.3
        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether we want to monitor resetting core base flag, iStartPlateau='..iStartPlateau..'; iStartZone='..iStartZone..'; LZ mex c ount='..tLZData[M28Map.subrefLZMexCount]..'; Mod dist%='..tLZTeamData[M28Map.refiModDistancePercent]..'; Brain nickname='..(aiBrain.Nickname or 'nil')) end
        if tLZData[M28Map.subrefLZMexCount] >= 4 and tLZTeamData[M28Map.refiModDistancePercent] <= 0.3 then
            while M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false do
                if bDebugMessages == true then LOG(sFunctionRef..': Start of loop for assessing if we want to change this zone core zone flag, tLZTeamData[M28Map.subrefbCoreBaseOverride]='..tostring(tLZTeamData[M28Map.subrefbCoreBaseOverride] or false)..'; tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Enemy air to ground='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Enemies in this or adj zone='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or false)..'; T2 mexes in zone='..tLZTeamData[M28Map.subrefMexCountByTech][2]..'; T3 mexes in zone='..tLZTeamData[M28Map.subrefMexCountByTech][3]..'; Total mexes in zone='..tLZData[M28Map.subrefLZMexCount]..'; Time='..GetGameTimeSeconds()) end
                --If this is already a core zone, then only abort if dangerous enemies in the zone, and we lack a factory HQ
                if tLZTeamData[M28Map.subrefbCoreBaseOverride] then
                    --We are a core zone, only change if significant change in position
                    if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 100 or tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) then
                            tLZTeamData[M28Map.subrefbCoreBaseOverride] = false
                            if bDebugMessages == true then LOG(sFunctionRef..': No friendly units so not a core base') end
                        else
                            local tFriendlyT2PlusHQs = EntityCategoryFilterDown(M28UnitInfo.refCategoryAllHQFactories - categories.TECH1, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                            if M28Utilities.IsTableEmpty(tFriendlyT2PlusHQs) then
                                if bDebugMessages == true then LOG(sFunctionRef..': No friendly HQ so not a core base anymore') end
                                tLZTeamData[M28Map.subrefbCoreBaseOverride] = false
                            end
                        end
                    end
                else
                    --We arent a core zone, consider if we want to become one - consider if all mexes are T2+, at least one is T3+, and there are no enemies in an adjacent zone
                    if not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] >= tLZData[M28Map.subrefLZMexCount] and (tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][2] >= 6) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will treat this as a core zone again') end
                        tLZTeamData[M28Map.subrefbCoreBaseOverride] = true
                    end
                end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitSeconds(10)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)


    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end