---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 16/11/2022 07:20
---

local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Chat = import('/mods/M28AI/lua/AI/M28Chat.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')


bInitialSetup = false
tAllActiveM28Brains = {} --[x] is just a unique integer starting with 1 (so table.getn works on this), not the armyindex; returns the aiBrain object
tAllAIBrainsByArmyIndex = {} --[x] is the brain army index, returns the aibrain
bDebugTickCheckerActive = false

--Special settings - restrictions and norush
bUnitRestrictionsArePresent = false
bAirFactoriesCantBeBuilt = false
bNoRushActive = false
iNoRushRange = 0
iNoRushTimer = 0 --Gametimeseconds that norush should end
reftNoRushCentre = 'M28OverseerNRCtre' --against aiBrain
reftNoRushM28StartPoints = { } --start positions for all norush buildable locations
bActiveMissionChecker = false --true if are actively checking for mission objectives - now used for niche objectives to monitor
bPacifistModeActive = false --true if we have set certain zones to never be attacked (e.g. Cybran mission 4)
bHaveDisabledGunshipWeaponsForPacifism = false --true if we have disabled gunship weapons due to pacifism
tiPacifistZonesByPlateau = {} --[iPlateau], returns iLandOrWaterZone, for any zone flagged as pacificst

--aiBrain variables
refiDistanceToNearestEnemyBase = 'M28OverseerDistToNearestEnemyBase'
refoNearestEnemyBrain = 'M28OverseerNearestEnemyBrain'
refbCloseToUnitCap = 'M28OverseerCloseToUnitCap'
refiExpectedRemainingCap = 'M28OverseerUnitCap' --number of units to be built before we potentially hit the unit cap, i.e. used as a rough guide for when shoudl call the code to check the unit cap
refiUnitCapCategoriesDestroyed = 'M28OverseerLstCatDest' --Last category destroyed by unit cap logic
refiTemporarilySetAsAllyForTeam = 'M28TempSetAsAlly' --against brain, e.g. a civilian brain, returns the .M28Team number that the brain has been set as an ally of temporarily (to reveal civilians at start of game)


refiRoughTotalUnitsInGame = 0 --Very rough count of units in game, so can use more optimised code if this gets high

function GetNearestEnemyBrain(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNearestEnemyBrain'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if (aiBrain[refoNearestEnemyBrain] and not(aiBrain[refoNearestEnemyBrain].M28IsDefeated) and not(aiBrain[refoNearestEnemyBrain]:IsDefeated())) or aiBrain.M28IsDefeated then
        if bDebugMessages == true then LOG(sFunctionRef..': Previously nearest enemy brain is still valid='..(aiBrain[refoNearestEnemyBrain].Nickname or 'nil')) end
        return aiBrain[refoNearestEnemyBrain]
    else
        if bDebugMessages == true then LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..'; Is pathing complete='..tostring(M28Map.bMapLandSetupComplete)..'; Dont have a valid nearest enemy already recorded for aiBrain '..(aiBrain.Nickname or 'nil')..' with index '..aiBrain:GetArmyIndex()..' so will get a new one; are all enemies defeated for team '..aiBrain.M28Team..'='..tostring(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated])) end
        local oNearestBrain
        if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated] then
            --All enemies defeated so will consider civilians as enemy brains
            local oCivilianBrain
            for iCurBrain, oBrain in ArmyBrains do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering obrain '..(oBrain.Nickname or 'nil')..'; is enemy to us='..tostring(IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()))) end
                if IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()) then
                    oNearestBrain = oBrain
                    break
                elseif M28Conditions.IsCivilianBrain(oBrain) then
                    oCivilianBrain = oBrain
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': All normal enemies defeated, oNearestBrain='..(oNearestBrain.Nickname or 'nil')..'; oCivilianBrain='..(oCivilianBrain.Nickname or 'nil')) end

            if not (oNearestBrain) then
                oNearestBrain = oCivilianBrain
            end
        else
            local iCurDist
            local iMinDistToEnemy = 10000000

            if bDebugMessages == true then LOG(sFunctionRef .. ': Start before looping through brains; aiBrain personality=' .. ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality .. '; brain.Name=' .. aiBrain.Name) end

            for iCurBrain, oBrain in ArmyBrains do
                if bDebugMessages == true then LOG(sFunctionRef .. ': Start of brain loop, iCurBrain=' .. iCurBrain .. '; brain personality=' .. ScenarioInfo.ArmySetup[oBrain.Name].AIPersonality .. '; brain Nickname=' .. oBrain.Nickname .. '; Brain index=' .. oBrain:GetArmyIndex() .. '; if brain isnt equal to our AI brain then will get its start position etc. IsCivilian='..tostring(M28Conditions.IsCivilianBrain(oBrain))..'; IsEnemy='..tostring(IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()))) end
                if not (oBrain == aiBrain) and (not (M28Conditions.IsCivilianBrain(oBrain)) and IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex())) then
                    if bDebugMessages == true then LOG(sFunctionRef .. ': Brain is dif to aiBrain and a non civilian enemy so will record its start position number if it doesnt have one already') end

                    if not (oBrain:IsDefeated()) and not (oBrain.M28IsDefeated) then
                        --Redundancy for AI like DD that may not trigger the aibrain hook
                        if not(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()]) then
                            M28Map.RecordBrainStartPoint(oBrain)

                        end
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Considering nearest enemy for our brain index '..aiBrain:GetArmyIndex()..'; enemy brain with index' .. oBrain:GetArmyIndex() .. ' and nickname '..(oBrain.Nickname or 'nil')..' is not defeated and is an enemy; M28Map.PlayerStartPoints='..repru( M28Map.PlayerStartPoints))
                            local iX, iZ = oBrain:GetArmyStartPos()
                            LOG(sFunctionRef..': Enemy Start iX='..(iX or 'nil')..'; Start iZ+'..(iZ or 'nil'))
                        end
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()], M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                        if iCurDist < iMinDistToEnemy then
                            iMinDistToEnemy = iCurDist
                            oNearestBrain = oBrain
                        end
                    end

                    --Strange bug where still returns true for empty slot - below line to avoid this:
                    --[[if GetGameTimeSeconds() <= 5 or brain:GetCurrentUnits(categories.ALLUNITS) > 0 then
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': brain has some units')
                        end
                        if M28Map.PlayerStartPoints[brain:GetArmyIndex()] then
                            iDistToCurEnemy = M28Utilities.GetDistanceBetweenPositions(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()], M28Map.PlayerStartPoints[brain:GetArmyIndex()])
                            if bDebugMessages == true then LOG(sFunctionRef..': Dist between brain and aibrain start points='..iDistToCurEnemy) end
                            if iDistToCurEnemy < iMinDistToEnemy then
                                iMinDistToEnemy = iDistToCurEnemy
                                iNearestEnemyIndex = brain:GetArmyIndex()
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': Current nearest enemy index=' .. iNearestEnemyIndex .. '; startp osition of this enemy=' .. repru(M28Map.PlayerStartPoints[iNearestEnemyIndex]))
                                end
                            end
                        else
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Map info doesnt have a start point for brain with index=' .. brain:GetArmyIndex()..' and nickanme='..(brain.Nickname or 'nil')..'; PlayerStartPoints='..repru(M28Map.PlayerStartPoints))
                            end
                        end
                    else
                        --Can have some cases where have an aibrain but no units, e.g. map Africa has ARMY_9 aibrain name, with no personality, that has no units; will flag the brain as being defeated to be safe if getgametimeseonds is more than 1min
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': WARNING: brain isnt defeated but has no units; brain:ArmyIndex=' .. brain:GetArmyIndex())
                        end
                        if GetGameTimeSeconds() >= 60 then brain.M28IsDefeated = true end
                    end--]]
                end
            end
        end
        if not(oNearestBrain) then
            M28Utilities.ErrorHandler('Couldnt find a nearest brain to aiBrain='..aiBrain.Nickname)
            if GetGameTimeSeconds() <= 10 then M28Chat.SendForkedMessage(aiBrain, 'NoEnemies', 'Unable to identify any enemies, M28 may not function properly', 0, 10000, false) end
            M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated] = true
            --Set the nearest enemy as the furthest away other brain (even if it isnt an enemy) - i.e. if do as furthest enemy then more likely to have units passing enemy units
            local iFurthestDist = 0
            local iCurDist
            for iBrain, oBrain in ArmyBrains do
                if not(oBrain == aiBrain) then
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()], M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                    if iCurDist > iFurthestDist then
                        oNearestBrain = oBrain
                        iFurthestDist = iCurDist
                    end
                end
            end
        end
        aiBrain[refoNearestEnemyBrain] = oNearestBrain
    end
    return aiBrain[refoNearestEnemyBrain]
end

function GameSettingWarningsChecksAndInitialChatMessages(aiBrain)
    --One once at start of the game if an M28 brain is present
    local sFunctionRef = 'GameSettingWarningsChecksAndInitialChatMessages'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Start of compatibility check.  Size of tAllActiveM28Brains=' .. table.getsize(tAllActiveM28Brains))
    end
    local sIncompatibleMessage = ''
    local bIncompatible = false
    local bHaveOtherAIMod = false


    if M28Utilities.IsTableEmpty(ScenarioInfo.Options.RestrictedCategories) == false then
        bIncompatible = true
        bUnitRestrictionsArePresent = true
        sIncompatibleMessage = sIncompatibleMessage .. ' Unit restrictions. '
    end
    --Check if we can build air factories
    local tFriendlyACU = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of friendly ACU empty='..tostring(M28Utilities.IsTableEmpty(tFriendlyACU))) end
    if M28Utilities.IsTableEmpty(tFriendlyACU) == false then
        local sBlueprint = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryAirFactory, tFriendlyACU[1])
        if bDebugMessages == true then LOG(sFunctionRef..': If ACU '..tFriendlyACU[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tFriendlyACU[1])..' tries to build an air factory, sBLueprint is '..(sBlueprint or 'nil')) end
        if not(sBlueprint) then
            bAirFactoriesCantBeBuilt = true
            if not(bUnitRestrictionsArePresent) then
                bUnitRestrictionsArePresent = true
                sIncompatibleMessage = sIncompatibleMessage .. ' Custom map script or mod preventing air factories'
            end
        end
    end
    if not(bUnitRestrictionsArePresent) then
        --Check if campaign or map has any active restrictions
        if bDebugMessages == true then LOG(sFunctionRef..': bUnitRestrictionsArePresent='..tostring(bUnitRestrictionsArePresent)..'; Is getrestrictions empty='..tostring(M28Utilities.IsTableEmpty(import("/lua/game.lua").GetRestrictions()))..'; reprs of this='..reprs(import("/lua/game.lua").GetRestrictions())) end
        if M28Utilities.IsTableEmpty(import("/lua/game.lua").GetRestrictions()) == false then
            bUnitRestrictionsArePresent = true
        end
    end


    if not (ScenarioInfo.Options.NoRushOption == "Off") then
        bIncompatible = true
        sIncompatibleMessage = sIncompatibleMessage .. ' No rush timer. '
    end
    --Check for non-AI sim-mods.  Thanks to Softles for pointing me towards the __active_mods variable
    local tSimMods = __active_mods or {}
    local tAIModNameWhitelist = { 'M27AI', 'AI-Swarm', 'AI-Uveso', 'AI: DilliDalli', 'Dalli AI', 'Dilli AI', 'M20AI', 'Marlo\'s Sorian AI edit', 'RNGAI', 'SACUAI', 'M28AI' }

    local tAIModNameWhereExpectAI = { 'AI-Swarm', 'AI-Uveso', 'AI: DilliDalli', 'Dalli AI', 'Dilli AI', 'M20AI', 'Marlo\'s Sorian AI edit', 'RNGAI', 'M27AI' } --Dont include M28 in this list, i.e. it shoudl be every AI except M28
    local tModIsOk = {}
    local bHaveOtherAI = false
    local sUnnecessaryAIMod
    local iUnnecessaryAIModCount = 0
    for iAI, sAI in tAIModNameWhitelist do
        tModIsOk[sAI] = true
    end

    local iSimModCount = 0
    local bFlyingEngineers
    local bM27InGame = false
    for iMod, tModData in tSimMods do
        if not (tModIsOk[tModData.name]) and tModData.enabled and not (tModData.ui_only) then
            iSimModCount = iSimModCount + 1
            bIncompatible = true
            if iSimModCount == 1 then
                sIncompatibleMessage = sIncompatibleMessage .. ' SIM mods '
            else
                sIncompatibleMessage = sIncompatibleMessage .. '; '
            end
            sIncompatibleMessage = sIncompatibleMessage .. ' ' .. (tModData.name or 'UnknownName')
            if bDebugMessages == true then
                LOG('Whitelist of mod names=' .. repru(tModIsOk))
                LOG(sFunctionRef .. ' About to do reprs of the tModData for mod ' .. (tModData.name or 'nil')..': '..reprs(tModData))
            end

            if string.find(tModData.name, 'Flying engineers') then
                bFlyingEngineers = true
                if bDebugMessages == true then LOG(sFunctionRef..': Have flying engineers mod enabled so will adjust engineer categories') end
            end
        elseif tModIsOk[tModData.name] then
            if not(bHaveOtherAIMod) then
                for iAIMod, sAIMod in tAIModNameWhereExpectAI do
                    if sAIMod == tModData.name then
                        bHaveOtherAIMod = true
                        if sAIMod == 'M27AI' then bM27InGame = true end
                        break
                    end
                end
                if bHaveOtherAIMod then
                    --Do we have non-M28 AI?
                    for iBrain, oBrain in ArmyBrains do
                        if bDebugMessages == true then LOG(sFunctionRef..': Have another AI mod enabled. reprs of oBrain='..reprs(oBrain)..'; is BrainType empty='..tostring(oBrain.BrainType == 'nil')..'; is brian type an empty string='..tostring(oBrain.BrainType == '')) end
                        if ((oBrain.BrainType == 'AI' and not(oBrain.M28AI)) or oBrain.DilliDalli) and not(M28Conditions.IsCivilianBrain(oBrain)) then
                            bHaveOtherAI = true
                            if bDebugMessages == true then LOG('Have an AI for a brain') end
                            break
                        end
                    end
                end
            end
            if bHaveOtherAIMod and not(bHaveOtherAI) then
                local bUnnecessaryMod = false
                for iAIMod, sAIMod in tAIModNameWhereExpectAI do
                    if sAIMod == tModData.name then
                        bUnnecessaryMod = true
                        break
                    end
                end
                if bUnnecessaryMod then

                    iUnnecessaryAIModCount = iUnnecessaryAIModCount + 1
                    if iUnnecessaryAIModCount == 1 then
                        sUnnecessaryAIMod = tModData.name
                    else
                        sUnnecessaryAIMod = sUnnecessaryAIMod..', '..tModData.name
                    end
                end
            end
        end
    end

    if iSimModCount > 0 then
        sIncompatibleMessage = sIncompatibleMessage .. '. '
    end
    local bDontPlayWithM27 = false
    local iHumans = 0
    for iBrain, oBrain in ArmyBrains do
        if oBrain.BrainType == 'Human' then
            iHumans = iHumans + 1
        end
    end
    if bM27InGame then
        --Count how many players - if more than 1 then desync risk
        if iHumans >= 1 then
            bDontPlayWithM27 = true --Azraeel came across desyncs when playing with M27 and M28 together
            bIncompatible = true
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Finished checking compatibility; compatibility message=' .. sIncompatibleMessage .. '; iSimModCount=' .. iSimModCount)
    end

    if iSimModCount > 0 then
        --Basic compatibiltiy with flying engineers mod - allow air engineers to be treated as engineers; also work on mods with similar effect but different name
        if not(bFlyingEngineers) and M28Utilities.IsTableEmpty(EntityCategoryGetUnitList(M28UnitInfo.refCategoryEngineer * categories.TECH1)) then bFlyingEngineers = true end
        if bFlyingEngineers then
            M28UnitInfo.refCategoryEngineer = M28UnitInfo.refCategoryEngineer + categories.ENGINEER * categories.AIR * categories.CONSTRUCTION - categories.EXPERIMENTAL
        end
        --BREWLAN compatibility - it adds the TRANSPORTATION category to units that cant transport, leading to errors when M28 tries using them or getting their cargo
        if categories.TORPEDOBOMBER then M28UnitInfo.refCategoryTransport = M28UnitInfo.refCategoryTransport - categories.TORPEDOBOMBER end --thanks to Balthazaar who gave this tip for checking if a custom category exists
    end

    if bIncompatible then
        if bDontPlayWithM27 then
            if sUnnecessaryAIMod and not(bHaveOtherAI) then
                --Disabled as seen a bunch of games with M27 enabled and M28 active with no desync
                --M28Chat.SendMessage(aiBrain, 'SendGameCompatibilityWarning', 'Sorry I don’t like it when M27AI is watching and adults are around - he teases me about how much better he is and sometimes the game desyncs.  Please disable the M27AI mod.', 15, 15)
            else
                --warning based on Az noting there were sometimes desyncs with M27 and M28 playing together
                M28Chat.SendMessage(aiBrain, 'SendGameCompatibilityWarning', 'Sorry I don’t get on well with my brother M27 when adults are around – he teases me about how much better he is and sometimes the game desyncs', 15, 15)
            end
        else
            M28Chat.SendMessage(aiBrain, 'SendGameCompatibilityWarning', 'Detected '..sIncompatibleMessage .. ' if you come across M28AI issues with these settings/mods let maudlin27 know via Discord', 0, 10)
        end
    end
    if not(bDontPlayWithM27) and bHaveOtherAIMod and not(bHaveOtherAI) and sUnnecessaryAIMod then
        M28Chat.SendMessage(aiBrain, 'UnnecessaryMods', 'No other AI detected, These AI mods can be disabled: '..sUnnecessaryAIMod, 1, 10)
    end

    if not(bDontPlayWithM27) then
        local sStartMessage

        if M28Map.bIsCampaignMap then
            local iRand = math.random(1,8)
            if iRand == 1 then sStartMessage = 'Lets do this!'
            elseif iRand == 2 then sStartMessage = 'Time to foil their plans'
            elseif iRand == 3 then sStartMessage = 'I didnt ask for this...'
            elseif iRand == 4 then sStartMessage = 'Its time to end this'
            elseif iRand == 5 then sStartMessage = 'I hope youve got my back commander'
            elseif iRand == 6 then sStartMessage = 'So...I just need to eco right?'
            elseif iRand == 7 then sStartMessage = 'This doesnt look as easy as the simulation...'
            else
                --Faction specific message
                if aiBrain:GetFactionIndex() == M28UnitInfo.refFactionUEF then
                    sStartMessage = 'They will not stop the UEF'
                elseif aiBrain:GetFactionIndex() == M28UnitInfo.refFactionAeon then
                    sStartMessage = 'For the Aeon!'
                elseif aiBrain:GetFactionIndex() == M28UnitInfo.refFactionCybran then
                    sStartMessage = 'Their defeat can be the only outcome'
                else
                    sStartMessage = 'They will perish at my hand'
                end
            end
        else
            local iRand = math.random(1,3)
            if iRand == 1 then sStartMessage = 'gl hf'
            elseif iRand == 2 then sStartMessage = 'gl'
            elseif iRand == 3 then
                if iHumans > 1 and math.random(1,2) == 1 then
                    sStartMessage = 'Time to separate the wheat from the chaff'
                else
                    sStartMessage = '/82' -- QAI: If you destroy this ACU, another shall rise in its place. I am endless.
                end
            end
        end
        --SendMessage(aiBrain, sMessageType, sMessage, iOptionalDelayBeforeSending, iOptionalTimeBetweenMessageType, bOnlySendToTeam, bWaitUntilHaveACU)
        M28Chat.SendMessage(aiBrain, 'Start', sStartMessage, 40,                     60,                                false,          M28Map.bIsCampaignMap)
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function M28BrainCreated(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'M28BrainCreated'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': M28 Brain has just been created for aiBrain '..aiBrain.Nickname..'; Index='..aiBrain:GetArmyIndex()) end

    aiBrain.M28AI = true
    table.insert(tAllActiveM28Brains, aiBrain)

    --Set cheat mult if this is campaign (which doesnt allow in game options)
    if aiBrain.CheatEnabled and not(ScenarioInfo.Options.CheatMult) then
        if bDebugMessages == true then LOG(sFunctionRef..': No cheat mult in scenario options so will set to 1.5 for build and resource') end
        SetBuildAndResourceCheatModifiers(aiBrain, 1.5, 1.5)
    end

    if not(bInitialSetup) then
        bInitialSetup = true
        _G.repru = rawget(_G, 'repru') or repr --With thanks to Balthazar for suggesting this for where e.g. FAF develop has a function that isnt yet in FAF main
        if bDebugMessages == true then LOG(sFunctionRef..': About to do one-off setup for all brains') end
        M28Utilities.bM28AIInGame = true

        --Send a message warning players this could take a while
        M28Chat.SendForkedMessage(aiBrain, 'LoadingMap', 'Analysing map, this will freeze the game for a while.  Contact maudlin27 on discord if the freeze lasts more than 2 minutes', 0, 10000, false)
        ForkThread(GameSettingWarningsChecksAndInitialChatMessages, aiBrain)
        ForkThread(M28Map.SetupMap)
        ForkThread(UpdateMaxUnitCapForRelevantBrains)
        ForkThread(M28Building.DetermineBuildingExpectedValues)
    end

    ForkThread(OverseerManager, aiBrain)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function SetupNoRushDetails(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupNoRushDetails'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end

    if ScenarioInfo.Options.NoRushOption  and not(ScenarioInfo.Options.NoRushOption == 'Off') then
        if bDebugMessages == true then LOG(sFunctionRef..': No rush isnt active, will record details') end
        if not(bNoRushActive) then --This is the first time for any AI that this is run (redundancy)
            if bDebugMessages == true then LOG(sFunctionRef..': Log of ScenarioInfo='..repru(ScenarioInfo)) end
            bNoRushActive = true
            iNoRushTimer = tonumber(ScenarioInfo.Options.NoRushOption) * 60
            ForkThread(NoRushMonitor)
            if bDebugMessages == true then LOG(sFunctionRef..': First time have run this so ahve set bNoRushActive='..tostring(bNoRushActive)..' and started iNoRushTimer for '..iNoRushTimer..' to change norush back to false') end
        end
        --Setup details of norush range for each M28AI
        if bNoRushActive then
            local tMapInfo = ScenarioInfo
            aiBrain[reftNoRushCentre] = {M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()][1], 0, M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()][3]}
            local sXRef = 'norushoffsetX_ARMY_'..aiBrain:GetArmyIndex()
            local sZRef = 'norushoffsetY_ARMY_'..aiBrain:GetArmyIndex()
            if bDebugMessages == true then LOG(sFunctionRef..': Checking norush adjustments, sXRef='..sXRef..'; sZRef='..sZRef..'; MapInfoX='..(tMapInfo[sXRef] or 'nil')..'; MapInfoZ='..(tMapInfo[sZRef] or 'nil')..'; aiBrain[reftNoRushCentre] before adjustment='..repru(aiBrain[reftNoRushCentre])) end
            if tMapInfo[sXRef] then aiBrain[reftNoRushCentre][1] = aiBrain[reftNoRushCentre][1] + (tMapInfo[sXRef] or 0) end
            if tMapInfo[sZRef] then aiBrain[reftNoRushCentre][3] = aiBrain[reftNoRushCentre][3] + (tMapInfo[sZRef] or 0) end
            aiBrain[reftNoRushCentre][2] = GetTerrainHeight(aiBrain[reftNoRushCentre][1], aiBrain[reftNoRushCentre][3])
            iNoRushRange = tMapInfo.norushradius
            table.insert(reftNoRushM28StartPoints, aiBrain[reftNoRushCentre])
            if bDebugMessages == true then
                LOG(sFunctionRef..': Have recorded key norush details for the ai with index='..aiBrain:GetArmyIndex()..'; iNoRushRange='..iNoRushRange..'; aiBrain[reftNoRushCentre]='..repru(aiBrain[reftNoRushCentre])..'; will draw a circle now in white around the area')
                M28Utilities.DrawCircleAtTarget(aiBrain[reftNoRushCentre], 7, 500, iNoRushRange)
            end

        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': No rush isnt active') end
        bNoRushActive = false --(redundancy)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function NoRushMonitor()
    local sFunctionRef = 'NoRushMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitSeconds(iNoRushTimer)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    bNoRushActive = false
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TestCustom(aiBrain)
    M28Map.DrawSpecificWaterZone(2)
    --M28Map.DrawWaterZones()
    --[[if GetGameTimeSeconds() <= 20 then M28Map.DrawSpecificWaterZone(5)
    else M28Map.DrawSpecificWaterZone(7)
    end--]]
    --AiX 10.0
    --ScenarioInfo.Options.CheatMult = tostring(10.0)
    --ScenarioInfo.Options.BuildMult = tostring(10.0)

    --Four corners - draw buildable locations in bottom-right with plateau 7 LZ2
    --Island zero - P218 LZ1
    --Twin rivers - bottomright core base: P117LZ3
    --[[while true do
        WaitSeconds(20)
        local iTeam = aiBrain.M28Team
        if GetGameTimeSeconds() >= 240 then
            local tLZData = M28Map.tAllPlateaus[218][M28Map.subrefPlateauLandZones][3]
            M28Engineer.DrawBuildableLocations(tLZData, 1)
            LOG('TestCustom - about to do repru of segmentcount by size='..repru(tLZData[M28Map.subrefBuildLocationSegmentCountBySize]))
        end
    end--]]

    --Hook assist order
    --[[local M28OldIssueGuard = _G.IssueGuard
    _G.IssueGuard = function(units, target)
        LOG('IssueGuard hook - will give trail if hooked factory')
        for iUnit, oUnit in units do
            if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oUnit.UnitId) then M28Utilities.ErrorHandler('Audit trail', true, true) end
        end
        M28OldIssueGuard(units, target)
    end,
    LOG('Have attempted to hook issueguard')
    local M28OldIssueFactoryAssist = _G.IssueFactoryAssist
    _G.IssueFactoryAssist = function(units, target)
        LOG('IssueFactoryAssist hook - will give trail if hooked factory')
        for iUnit, oUnit in units do
            if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oUnit.UnitId) then
                if oUnit:GetAIBrain().M28AI then
                    M28Utilities.ErrorHandler('Audit trail', true, true)
                end
            end
        end
        M28OldIssueFactoryAssist(units, target)
    end,--]]



    --Scenario data
    --WaitSeconds(10)
    --LOG('WIll do reprs of ScenarioFramework')
    --LOG('reprs='..reprs(ScenarioFramework))


    --[[LOG('WIll do reprs of just options'..reprs(ScenarioInfo.Options))
    LOG('Will now try cycling through each entry in ScenarioInfo and note the iEntry value')
    for iEntry, vValue in ScenarioInfo do
        LOG('iEntry='..iEntry)
    end--]]

    --local tWZTeamData = M28Map.tPondDetails[552][M28Map.subrefPondWaterZones][25][M28Map.subrefWZTeamData][aiBrain.M28Team]
    --LOG('WZ25 pond 552 closest friendly base='..repru(tWZTeamData[M28Map.reftClosestFriendlyBase]))
    --WaitSeconds(5)
    --M28Air.CalculateAirTravelPath(0, 18, 0, 22)
    --[[M28Utilities.DrawLocation({10,GetTerrainHeight(10,10),10}, 3)
    M28Utilities.DrawLocation({12,GetTerrainHeight(12,12),10}, 4)
    M28Utilities.DrawLocation({14,GetTerrainHeight(14,14),14}, 5)--]]


    --Destroy a T3 fixed shield to see if we rebuild it
    --[[if GetGameTimeSeconds() >= 1200 and GetGameTimeSeconds() <= 1201 then
        local tFixedShields = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryFixedShield)
        if M28Utilities.IsTableEmpty(tFixedShields) == false then
            for iUnit, oUnit in tFixedShields do
                oUnit:Kill()
                break
            end
        end
    end--]]

    --Detail rally point info for a land zone - Forbidden pass - do we detect that the ridge is pathable?
    --[[local NavUtils = import("/lua/sim/navutils.lua")
    local tPosition = { 260.06228637695, 67.514915466309, 148.83508300781 }
    M28Utilities.DrawLocation(tPosition)
    LOG('NavUtils for tPosition='..(NavUtils.GetLabel('Land', tPosition) or 'nil'))--]]

    --[[local tLZData = M28Map.tAllPlateaus[27][M28Map.subrefPlateauLandZones][20]
    local tStartMidpoint = tLZData[M28Map.subrefMidpoint]
    local tRallyPoint = M28Land.GetNearestLandRallyPoint(tLZData, 1, 27, 20, 3)--]]
    --LOG('tStartMidpoint='..repru(tStartMidpoint)..'; tRallyPoint='..repru(tRallyPoint)..'; Path from LZ20 to LZ5='..repru(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][5]]))

    --Draw specific land zones
    --M28Map.DrawSpecificLandZone(27, 33, 2)
    --M28Map.DrawSpecificLandZone(27, 34, 1)

    --Test alternative to table.remove for sequentially indexed numerical keys
    --[[local tTestArray = {[1] = 'Test1', [2] = 'Test2', [3] = 'Test3', [4] = 'Test4'}
    local function WantToKeep(tArray, i, j)
        if tArray[i] == 'Test2' then return false else return true end
    end
    M28Utilities.RemoveEntriesFromArrayBasedOnCondition(tTestArray, WantToKeep)
    LOG('Finished updating array, tTestArray='..repru(tTestArray))--]]


    --Check for sparky and how many orders it has
    --[[local tOurSparkies = aiBrain:GetListOfUnits(categories.FIELDENGINEER, false, true)
    if M28Utilities.IsTableEmpty(tOurSparkies) == false then
        for iUnit, oUnit in tOurSparkies do
            local tQueue = oUnit:GetCommandQueue()
            LOG('Considering sparky '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..': About to list out command queue details. Is queue empty='..tostring(M28Utilities.IsTableEmpty(tQueue)))

            if M28Utilities.IsTableEmpty(tQueue) == false then
                LOG('Total commands='..table.getn(tQueue))
                for iCommand, tOrder in ipairs(tQueue) do
                    LOG('iCommand='..iCommand..'; tOrder='..repru(tOrder)..'; position='..repru(tOrder.position)..'; Type='..repru(tOrder.type))
                end
            end
        end
    end--]]

    M28Utilities.ErrorHandler('Disable testcustom code for final')
end

function UpdateMaxUnitCapForRelevantBrains()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateMaxUnitCapForRelevantBrains'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    for iBrain, oBrain in tAllAIBrainsByArmyIndex do
        if not(M28Map.bIsCampaignMap) or not(oBrain.BrainType == 'AI') or oBrain.M28AI or oBrain.M27AI then
            if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; About to update max unit cap for brian '..oBrain.Nickname..'; Brain type='..(oBrain.BrainType or 'nil')) end
            RefreshMaxUnitCap(oBrain)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshMaxUnitCap(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshUnitCap'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; About to set max unit cap for brain '..aiBrain.Nickname..'; Unit cap per scenarioInfo='..(ScenarioInfo.Options.UnitCap or 'nil')..'; Unit cap before update='..aiBrain:GetArmyStat("UnitCap_MaxCap", 0).Value) end
    if ScenarioInfo.Options.UnitCap then
        local iUnitCap = tonumber(ScenarioInfo.Options.UnitCap)
        local iIndex = aiBrain:GetArmyIndex()
        --SetIgnoreArmyUnitCap(iIndex, true) --Use this and below commented line to ignore unit cap altogther I think based on usage in base FAF code
        --aiBrain.IgnoreArmyCaps = true
        SetArmyUnitCap(iIndex, iUnitCap)
        if bDebugMessages == true then LOG(sFunctionRef..': Brian unit cap after update='..aiBrain:GetArmyStat("UnitCap_MaxCap", 0).Value) end
    else
        M28Utilities.ErrorHandler('No unit cap specified', true)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function Initialisation(aiBrain)
    --Called after 1 tick has passed so all aibrains should hopefully exist now
    ForkThread(SetupNoRushDetails, aiBrain)
    ForkThread(M28UnitInfo.CalculateBlueprintThreatsByType) --Records air and ground threat values for every blueprint
    ForkThread(M28Team.RecordAllPlayers, aiBrain)
    ForkThread(M28Economy.EconomyInitialisation, aiBrain)
    ForkThread(M28Engineer.EngineerInitialisation, aiBrain)
    ForkThread(M28ACU.ManageACU, aiBrain)
    ForkThread(M28Factory.SetPreferredUnitsByCategory, aiBrain)
    ForkThread(M28Factory.IdleFactoryMonitor, aiBrain)
    ForkThread(M28Map.RecordPondToExpandTo, aiBrain)
    --ForkThread(RevealCiviliansToAI, aiBrain)
    ForkThread(RevealCivilainsToAIByGivingVision, aiBrain)
    ForkThread(RefreshMaxUnitCap, aiBrain) --This logic is  called from a number of palces to try and ensure it overrides things that might be set elsewhere

end

function CheckUnitCap(aiBrain)
    local sFunctionRef = 'CheckUnitCap'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --local iUnitCap = tonumber(ScenarioInfo.Options.UnitCap)
    --Use below method in case a mod has changed this
    local oArmy = aiBrain:GetArmyIndex()
    local iUnitCap = GetArmyUnitCap(oArmy)
    --local armies = ListArmies()
    --for i, army in armies do
    --end
    local iCurUnits = aiBrain:GetCurrentUnits(categories.ALLUNITS - M28UnitInfo.refCategoryWall) + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryWall) * 0.25
    local iThreshold = math.max(math.ceil(iUnitCap * 0.02), 10)
    local iCurUnitsDestroyed = 0
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; iCurUnits='..iCurUnits..'; iUnitCap='..iUnitCap..'; iThreshold='..iThreshold) end
    if iCurUnits > (iUnitCap - iThreshold * 5) then
        aiBrain[refbCloseToUnitCap] = true
        M28Team.tTeamData[aiBrain.M28Team][M28Team.refiTimeLastNearUnitCap] = GetGameTimeSeconds()
        local iMaxToDestroy = math.max(5, math.ceil(iUnitCap * 0.01), 20 - (iUnitCap - iCurUnits))
        if iUnitCap - iCurUnits < 10 then iMaxToDestroy = math.max(10, iMaxToDestroy) end
        local tUnitsToDestroy
        local tiCategoryToDestroy = {
            [0] = categories.TECH1 - categories.COMMAND - M28UnitInfo.refCategoryAirStaging - M28UnitInfo.refCategoryT1Mex + M28UnitInfo.refCategoryAllAir * categories.TECH2 - M28UnitInfo.refCategoryTransport * categories.TECH2 - M28UnitInfo.refCategoryTorpBomber * categories.TECH2,
            [1] = M28UnitInfo.refCategoryAllAir * categories.TECH1 + categories.NAVAL * categories.MOBILE * categories.TECH1,
            [2] = M28UnitInfo.refCategoryMobileLand * categories.TECH2 - categories.COMMAND - M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryAirScout + M28UnitInfo.refCategoryAirAA * categories.TECH1,
            [3] = M28UnitInfo.refCategoryMobileLand * categories.TECH1 - categories.COMMAND,
            [4] = M28UnitInfo.refCategoryWall + M28UnitInfo.refCategoryEngineer - categories.TECH3 + M28UnitInfo.refCategoryMobileLand * categories.TECH1 - categories.COMMAND - M28UnitInfo.refCategoryLandScout,
        }
        --Adjust these categories for special cases
        if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyLandFactoryTech] == 1 and (M28Map.bIsCampaignMap or bUnitRestrictionsArePresent) then
            --exclude T1 land from category 4
            tiCategoryToDestroy[4] =  M28UnitInfo.refCategoryWall + M28UnitInfo.refCategoryEngineer - categories.TECH3
        end
        if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyFactoryTech] < 3 or ((M28Map.bIsCampaignMap or bUnitRestrictionsArePresent) and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * categories.TECH3) == 0) then
            if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyFactoryTech] == 1 then
                tiCategoryToDestroy[4] = tiCategoryToDestroy[4] - M28UnitInfo.refCategoryEngineer
            else
                tiCategoryToDestroy[4] = tiCategoryToDestroy[4] - M28UnitInfo.refCategoryEngineer * categories.TECH2
            end
        end
        if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyLandFactoryTech] == 2 and (M28Map.bIsCampaignMap or bUnitRestrictionsArePresent) and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] then
            --Exclude MML from category 2
            tiCategoryToDestroy[2] = M28UnitInfo.refCategoryMobileLand * categories.TECH2 - categories.COMMAND - M28UnitInfo.refCategoryMAA -M28UnitInfo.refCategoryMML + M28UnitInfo.refCategoryAirScout + M28UnitInfo.refCategoryAirAA * categories.TECH1
        end
        --If have no T2+ power, then dont include T1 power in units to ctrlK
        if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower - categories.TECH1) == 0 then
            tiCategoryToDestroy[3] = tiCategoryToDestroy[3] - M28UnitInfo.refCategoryPower
        end

        if bDebugMessages == true then LOG(sFunctionRef..': We are over the threshold for ctrlking units') end
        if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer) > iUnitCap * 0.35 then tiCategoryToDestroy[0] = tiCategoryToDestroy[0] + M28UnitInfo.refCategoryEngineer end
        local iCumulativeCategory = tiCategoryToDestroy[4]
        for iAdjustmentLevel = 4, 0, -1 do
            if iAdjustmentLevel < 4 then
                iCumulativeCategory = iCumulativeCategory + tiCategoryToDestroy[iAdjustmentLevel]
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iCurUnitsDestroyed so far='..iCurUnitsDestroyed..'; iMaxToDestroy='..iMaxToDestroy..'; iAdjustmentLevel='..iAdjustmentLevel..'; iCurUnits='..iCurUnits..'; Unit cap='..iUnitCap..'; iThreshold='..iThreshold) end
            if iCurUnits > (iUnitCap - iThreshold * iAdjustmentLevel) or iCurUnitsDestroyed == 0 then
                tUnitsToDestroy = aiBrain:GetListOfUnits(tiCategoryToDestroy[iAdjustmentLevel], false, false)
                if M28Utilities.IsTableEmpty(tUnitsToDestroy) == false then
                    M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] = math.min((M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] or 100), iAdjustmentLevel)
                    for iUnit, oUnit in tUnitsToDestroy do
                        if oUnit.Kill then
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurUnitsDestroyed so far='..iCurUnitsDestroyed..'; Will destroy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to avoid going over unit cap') end
                            M28Orders.IssueTrackedKillUnit(oUnit)
                            if EntityCategoryContains(M28UnitInfo.refCategoryWall, oUnit.UnitId) then
                                iCurUnitsDestroyed = iCurUnitsDestroyed + 0.25
                            else
                                iCurUnitsDestroyed = iCurUnitsDestroyed + 1
                            end
                            if iCurUnitsDestroyed >= iMaxToDestroy then break end
                        end
                    end
                end
                if iCurUnitsDestroyed >= iMaxToDestroy then break end
            else
                break
            end
        end
        aiBrain[refiUnitCapCategoriesDestroyed] = iCumulativeCategory
        if bDebugMessages == true then LOG(sFunctionRef..': FInished destroying units, iCurUnitsDestroyed='..iCurUnitsDestroyed) end
    else
        --Only reset cap if we havent reached the higher ctrlk thresholds, unless we have a massive amount of headroom
        if aiBrain[refbCloseToUnitCap] and (iCurUnits < iUnitCap * 0.5 - 25 or (M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] or 100) > 1) then
            --Only reset cap if we have a bit of leeway
            if iCurUnits < (iUnitCap - iThreshold * 5) - 20 then
                aiBrain[refbCloseToUnitCap] = false
            end
        end
    end
    aiBrain[refiExpectedRemainingCap] = iUnitCap - iCurUnits + iCurUnitsDestroyed
    if aiBrain[refbCloseToUnitCap] and aiBrain[refiExpectedRemainingCap] <= 25 then
        --Recheck in 30s
        ForkThread(DelayedUnitCapCheck, aiBrain)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, expected remaining cap='..aiBrain[refiExpectedRemainingCap]) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedUnitCapCheck(aiBrain)
    WaitSeconds(30)
    CheckUnitCap(aiBrain)
end

function ResetCivilianAllianceForBrain(iOurIndex, iCivilianIndex, sRealState, oCivilianBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ResetCivilianAllianceForBrain'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Call via forkthread
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Time='..GetGameTimeSeconds()..'; iOurIndex='..iOurIndex..'; iCivilianIndex='..iCivilianIndex..'; Is ally='..tostring(IsAlly(iOurIndex, iCivilianIndex))..'; IsEnemy='..tostring(IsEnemy(iOurIndex, iCivilianIndex))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(11)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting for some ticks, iOurIndex='..iOurIndex..'; iCivilianIndex='..iCivilianIndex..'; Is ally='..tostring(IsAlly(iOurIndex, iCivilianIndex))..'; IsEnemy='..tostring(IsEnemy(iOurIndex, iCivilianIndex))) end
    SetAlliance(iOurIndex, iCivilianIndex, sRealState)
    oCivilianBrain[refiTemporarilySetAsAllyForTeam] = nil
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bDebugMessages == true then LOG(sFunctionRef..': Have now set alliance back to real state, Time='..GetGameTimeSeconds()..' Have just set civilian brain '..oCivilianBrain.Nickname..' back to being '..sRealState..' for iOurIndex='..iOurIndex) end
end

function RevealCiviliansToAI(aiBrain)
    --On some maps like burial mounds civilians are revealed to human players but not AI; meanwhile on other maps even if theyre not revealed to humans, the humans will likely know where the buildings are having played the map before
    --Thanks to Relent0r for providing code that I used as a starting point to achieve this

    --SUPERCEDED BY RevealCivilainsToAIByGivingVision
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RevealCiviliansToAI'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    M28Utilities.ErrorHandler('Deprecated function')
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(75) --Waiting only 5 ticks or less resulted in a strange bug where on one map when ahd 2 ACUs on the same team, the code would run for both of htem as expected, but the civilians would only be visible for one of the AI (as though making the civilian an ally had no effect for hte other); This went away when put a delay of 50 ticks; however have compatibility issues with RNG so want to wait a bit longer; waiting 60 meant it worked for M27 but didnt look like it worked for RNG (wiating 50 meant it worked for RNG but not for M27); waiting 70 meant it worked for both; have done 75 for M28 given M27 uses 70
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --if aiBrain:GetArmyIndex() == 3 then
    if bDebugMessages == true then LOG(sFunctionRef..': Have finished waiting, will loop throguh all brians now to look for civilians, aiBrain='..aiBrain.Nickname..' with index ='..aiBrain:GetArmyIndex()..'; M28 team='..(aiBrain.M28Team or 'nil')) end
    local tiCivilianBrains = {}
    local toCivilianBrains = {}
    local iOurIndex = aiBrain:GetArmyIndex()
    local iBrainIndex
    local sRealState
    local iTotalWait = 0

    for i, oBrain in ArmyBrains do
        iBrainIndex = oBrain:GetArmyIndex()
        if bDebugMessages == true then LOG(sFunctionRef..': Considering brain '..(oBrain.Nickname or 'nil')..' with index '..oBrain:GetArmyIndex()..' for aiBrain '..aiBrain.Nickname..'; Is enemy='..tostring(IsEnemy(iOurIndex, iBrainIndex))..'; ArmyIsCivilian(iBrainIndex)='..tostring(ArmyIsCivilian(iBrainIndex))..'; oBrain[refiTemporarilySetAsAllyForTeam]='..(oBrain[refiTemporarilySetAsAllyForTeam] or 'nil')..'; Our team='..aiBrain.M28Team) end
        if ArmyIsCivilian(iBrainIndex) then
            while(oBrain[refiTemporarilySetAsAllyForTeam] and not(oBrain[refiTemporarilySetAsAllyForTeam] == aiBrain.M28Team)) do
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                iTotalWait = iTotalWait + 1
                if iTotalWait >= 12 then
                    break
                end
            end
            if not(oBrain[refiTemporarilySetAsAllyForTeam]) then
                oBrain[refiTemporarilySetAsAllyForTeam] = aiBrain.M28Team
                sRealState = IsAlly(iOurIndex, iBrainIndex) and 'Ally' or IsEnemy(iOurIndex, iBrainIndex) and 'Enemy' or 'Neutral'
                SetAlliance(iOurIndex, iBrainIndex, 'Ally')
                if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Temporarily set the brain as an ally of team '..aiBrain.M28Team..', sRealState='..sRealState) end
                table.insert(tiCivilianBrains, iBrainIndex)
                table.insert(toCivilianBrains, oBrain)
                --Prevent orders being given to these untis by M28
                --[[local tMobileUnits = oBrain:GetListOfUnits(categories.MOBILE, false, true)
                if M28Utilities.IsTableEmpty(tMobileUnits) == false then
                    for iUnit, oUnit in tMobileUnits do
                        M28Micro.TrackTemporaryUnitMicro(oUnit, 30)
                    end
                end--]]
                ForkThread(ResetCivilianAllianceForBrain, iOurIndex, iBrainIndex, sRealState, oBrain)
            elseif oBrain[refiTemporarilySetAsAllyForTeam] == aiBrain.M28Team then
                table.insert(tiCivilianBrains, iBrainIndex)
                table.insert(toCivilianBrains, oBrain)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(8) --When did with just 4 tick delay had issues where getunitsaroundpoint didnt work properly; increasing to 8 tick solved this
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RevealCivilainsToAIByGivingVision(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RevealCivilainsToAIByGivingVision'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': About to reveal civilains and then consider capture targets if this is M28Brain, aiBrain.M28AI='..tostring(aiBrain.M28AI or false)..'; nickname='..(aiBrain.Nickname or 'nil')) end
    if aiBrain.M28AI then --redundancy
        local tACU = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
        for iUnit, oUnit in tACU do
            M28UnitInfo.GiveUnitTemporaryVision(oUnit, 1000)
            break
        end
        --Consider capture targets
        if bDebugMessages == true then LOG(sFunctionRef..': Will now consider capture targets') end
        ForkThread(GetCivilianCaptureTargets, aiBrain)

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetCivilianCaptureTargets(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetCivilianCaptureTargets'

    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local tStartPoint = M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()]
    local iPlateauWanted, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tStartPoint)
    local iClosestEnemyBase = M28Map.iMapSize
    local iTeam = aiBrain.M28Team

    if iLandZone > 0 then
        local tLZData = M28Map.tAllPlateaus[iPlateauWanted][M28Map.subrefPlateauLandZones][iLandZone]
        local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
        iClosestEnemyBase = M28Utilities.GetDistanceBetweenPositions(tStartPoint, tLZTeamData[M28Map.reftClosestEnemyBase])
    end
    local iSearchRange = math.min(450, math.max(iClosestEnemyBase * 0.6, 200, math.min(275, iClosestEnemyBase * 0.75)))
    local iCategoriesOfInterest = M28UnitInfo.refCategoryLandCombat * categories.RECLAIMABLE - categories.TECH1
    local tUnitsOfInterest = aiBrain:GetUnitsAroundPoint(iCategoriesOfInterest, tStartPoint, iSearchRange, 'Neutral')
    --local sPathing = M28Map.refPathingTypeAmphibious


    if bDebugMessages == true then LOG(sFunctionRef..': Running for aiBrain='..aiBrain.Nickname..' at gametime='..GetGameTimeSeconds()..'; Is table of tUnitsOfInterest empty='..tostring(M28Utilities.IsTableEmpty(tUnitsOfInterest))..'; iPlateauWanted='..iPlateauWanted..'; iClosestEnemyBase='..iClosestEnemyBase..'; iSearchRange='..iSearchRange..'; Is table of enemy units with further range empty='..tostring(M28Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(iCategoriesOfInterest, tStartPoint, 1000, 'Enemy')))) end
    if M28Utilities.IsTableEmpty(tUnitsOfInterest) == false then
        local iCurPlateau, iCurLandZone
        for iUnit, oUnit in tUnitsOfInterest do
            if oUnit:GetFractionComplete() >= 1 then
                --Is it in the same plateua?
                iCurPlateau, iCurLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())

                if bDebugMessages == true then LOG(sFunctionRef..': Considering civilian unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurPlateau='..(iCurPlateau or 'nil')..'; iPlateauWanted='..iPlateauWanted..'; Dist to our base='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tStartPoint)..'; Mod dist='..M28Map.GetModDistanceFromStart(aiBrain, oUnit:GetPosition())) end
                if (iCurLandZone or 0) > 0 and iCurPlateau == iPlateauWanted then
                    --Is it one of the civilian brains we temporarily moved to be our ally?
                    if M28Conditions.IsCivilianBrain(oUnit:GetAIBrain()) then
                        local tNearbyThreats = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryPD + M28UnitInfo.refCategoryFixedT2Arti, oUnit:GetPosition(), 140, 'Enemy')
                        if M28Utilities.IsTableEmpty(tNearbyThreats) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to the table of civilians to capture; unit brain='..(oUnit:GetAIBrain().Nickname or 'nil')..'; is civilian='..tostring(M28Conditions.IsCivilianBrain(oUnit:GetAIBrain()))..'; iCurPlateau='..iCurPlateau..'; iCurLandZone='..iCurLandZone) end
                            local tUnitLZData = M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLandZone]
                            if not(tUnitLZData[M28Map.subreftoUnitsToCapture]) then tUnitLZData[M28Map.subreftoUnitsToCapture] = {} end
                            table.insert(tUnitLZData[M28Map.subreftoUnitsToCapture], oUnit)
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DebugCheck(aiBrain)
    local sFunctionRef = 'DebugCheck'
    local iTickTimeToStartDetailedDebug = 833.7 --set to high number if first want to figure out the tick where this happens
    local bSetHook = false --Used for debugging
    if not(bDebugTickCheckerActive) then
        bDebugTickCheckerActive = true
        --Every tick list out the tick - use this function to help identify infinite loops
        while true do
            WaitTicks(1)
            LOG(sFunctionRef..': Cur time='..GetGameTimeSeconds())
            if GetGameTimeSeconds() >= iTickTimeToStartDetailedDebug then
                if not(bSetHook) then
                    bSetHook = true
                    M28Profiler.bFunctionCallDebugOverride = true
                    --M28Profiler.bGlobalDebugOverride = true --Only enable this if want more detail as it will make things really slow
                    debug.sethook(M28Profiler.OutputRecentFunctionCalls, "c", 200)
                    LOG(sFunctionRef..': Have started the main hook of function calls')
                end
            end
        end
    end
end

function OverseerManager(aiBrain)
    --ForkThread(DebugCheck,aiBrain)

    --Make sure map setup will be done
    WaitTicks(1)
    while not(M28Map.bMapLandSetupComplete) do
        WaitTicks(1)
    end

    --ForkThread(TestCustom, aiBrain)

    --Initialise main systems
    ForkThread(Initialisation, aiBrain)

    --Wait until we can give orders before doing main logic
    while (GetGameTimeSeconds() <= 4.5) do
        WaitTicks(1)
    end
    local bSetHook = false --Used for debugging
    while not(aiBrain:IsDefeated()) and not(aiBrain.M28IsDefeated) do
        local bEnabledProfiling = false
        --[[ if GetGameTimeSeconds() >= 2100 and not(bEnabledProfiling) then
             if not(import('/mods/M28AI/lua/M28Config.lua').M28RunProfiling) then
                 ForkThread(M28Profiler.ProfilerActualTimePerTick)
                 import('/mods/M28AI/lua/M28Config.lua').M28RunProfiling = true
             end
             bEnabledProfiling = true
         end--]]

        --if GetGameTimeSeconds() >= 2700 then import('/mods/M28AI/lua/M28Config.lua').M28ShowUnitNames = true end
        --if GetGameTimeSeconds() >= 120 and GetGameTimeSeconds() <= 125 then TestCustom(aiBrain) end
        --Enable below to help figure out infinite loops
        --[[if GetGameTimeSeconds() >= 173 and not(bSetHook) then
            bSetHook = true
            M28Profiler.bFunctionCallDebugOverride = true
            --M28Profiler.bGlobalDebugOverride = true --Only enable this if want more detail as it will make things really slow
            debug.sethook(M28Profiler.OutputRecentFunctionCalls, "c", 200)
            LOG('Have started the main hook of function calls')
        end--]]
        ForkThread(M28Economy.RefreshEconomyData, aiBrain)
        WaitSeconds(1)
    end
end

function CheckIfScenarioMap()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckIfScenarioMap'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': ScenarioInfo.type == skirmish='..tostring(ScenarioInfo.type == "skirmish")..'; repru of ScenarioInfo.type='..repru(ScenarioInfo.type)..'; Is table of hunman players empty='..tostring(M28Utilities.IsTableEmpty(ScenarioInfo.HumanPlayers))..'; Is human players nil='..tostring(ScenarioInfo.HumanPlayers == nil)) end
    --Thanks to Hdt80bro for highlighting ScenarioInfo.type as a better way of figuring out if this is a campaign map
    if not(ScenarioInfo.type == "skirmish") then --M28Utilities.IsTableEmpty(ScenarioInfo.HumanPlayers) == false then
        M28Map.bIsCampaignMap = true
        --ForkThread(CheckForScenarioObjectives) --superceded by hook of addobjective
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckForAlliedCampaignUnitsToShareAtGameStart(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckForAlliedCampaignUnitsToShareAtGameStart'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iTeam = aiBrain.M28Team
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; M28Team.tTeamData[iTeam][M28Team.refbAlreadyCheckedForUnitsToShare]='..tostring(M28Team.tTeamData[iTeam][M28Team.refbAlreadyCheckedForUnitsToShare] or false)) end
    if not(M28Team.tTeamData[iTeam][M28Team.refbAlreadyCheckedForUnitsToShare]) then
        M28Team.tTeamData[iTeam][M28Team.refbAlreadyCheckedForUnitsToShare] = true
        local tStartPosition = M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()]
        local tNearbyStructures = {}
        local iWaitCount = 0
        local tHumanBrains = {}
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveBrains] do
            if bDebugMessages == true then LOG(sFunctionRef..': Creating list of human brains, oBrain.Nickanme='..oBrain.Nickname..'; brain type='..oBrain.BrainType) end
            if oBrain.BrainType == 'Human' then
                table.insert(tHumanBrains, oBrain)
            end
        end
        local iCategoriesOfInterest = M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryAllAir + M28UnitInfo.refCategoryAllNavy + M28UnitInfo.refCategoryEngineer - categories.COMMAND - M28UnitInfo.refCategoryMassStorage
        if M28Utilities.IsTableEmpty(tHumanBrains) == false then
            while M28Utilities.IsTableEmpty(tNearbyStructures) do
                if iWaitCount > 0 then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(1)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                end
                iWaitCount = iWaitCount + 1
                for iBrain, oBrain in tHumanBrains do
                    local tPotentialStructures = oBrain:GetListOfUnits(iCategoriesOfInterest, false, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Is table of potential units empty for brain '..oBrain.Nickname..'='..tostring(M28Utilities.IsTableEmpty(tPotentialStructures))) end
                    if M28Utilities.IsTableEmpty(tPotentialStructures) == false then
                        for iUnit, oUnit in tPotentialStructures do
                            table.insert(tNearbyStructures, oUnit)
                        end
                    end
                end
                --tNearbyStructures = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure, tStartPosition, 1000, 'Ally')
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': FInished wait for checking for ally structures to share, Time='..GetGameTimeSeconds()..'; Is tNearbyStructures empty='..tostring(M28Utilities.IsTableEmpty(tNearbyStructures))) end
        if M28Utilities.IsTableEmpty(tNearbyStructures) == false then
            --local tUnitsOfCategoryWanted = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryAllAir + M28UnitInfo.refCategoryAllNavy - categories.COMMAND, tStartPosition, 1000, 'Ally')
            local tUnitsOfCategoryWanted = tNearbyStructures
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of units of category wanted empty='..tostring(M28Utilities.IsTableEmpty(tUnitsOfCategoryWanted))) end
            if M28Utilities.IsTableEmpty(tUnitsOfCategoryWanted) == false then
                local tUnitsToShareByBlueprint = {}
                for iUnit, oUnit in  tUnitsOfCategoryWanted do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to add unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of units to share, Is uint valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Fraction complete='..oUnit:GetFractionComplete()..'; Unit brain nickname='..oUnit:GetAIBrain().Nickname..'; Unit brain type='..oUnit:GetAIBrain().BrainType) end
                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 and oUnit:GetAIBrain().BrainType == "Human" then
                        if not(tUnitsToShareByBlueprint[oUnit.UnitId]) then tUnitsToShareByBlueprint[oUnit.UnitId] = {} end
                        table.insert(tUnitsToShareByBlueprint[oUnit.UnitId], oUnit)
                        if bDebugMessages == true then LOG(sFunctionRef..': Add unit to the table of units to consider sharing') end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Is untis to share empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToShareByBlueprint))) end
                if M28Utilities.IsTableEmpty(tUnitsToShareByBlueprint) == false then
                    local iNthEntryToGive
                    local iHumanBrainCount = 0
                    local iM28BrainCount = 0
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveBrains] do
                        if oBrain.M28AI then iM28BrainCount = iM28BrainCount + 1
                        elseif oBrain.BrainType == 'Human' then
                            iHumanBrainCount = iHumanBrainCount + 1
                        end
                    end
                    iNthEntryToGive = math.ceil((iM28BrainCount + iHumanBrainCount) / iM28BrainCount)
                    local iTotalUnitCount
                    local iCurCycleCount
                    local tUnitsToGive = {}
                    if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through all units to potentially share, iNthEntryToGive='..iNthEntryToGive..'; iM28BrainCount='..iM28BrainCount..'; iHumanBrainCount='..iHumanBrainCount) end
                    for sBlueprint, tUnits in tUnitsToShareByBlueprint do
                        iTotalUnitCount = table.getn(tUnits)
                        if bDebugMessages == true then LOG(sFunctionRef..': sBLueprint='..sBlueprint..'; iTotalUnitCount='..iTotalUnitCount) end
                        if iTotalUnitCount >= iNthEntryToGive then
                            iCurCycleCount = 0
                            for iUnit, oUnit in tUnits do
                                iCurCycleCount = iCurCycleCount + 1
                                if iCurCycleCount >= iNthEntryToGive then
                                    table.insert(tUnitsToGive, oUnit)
                                    iCurCycleCount = 0
                                end
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tUnitsToGive) == false then
                        local tiM28Brains = {}
                        local iM28BrainCount = 0
                        local oCurBrain
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                table.insert(tiM28Brains, oBrain)
                                iM28BrainCount = iM28BrainCount + 1
                            end
                        elseif aiBrain.M28AI then
                            table.insert(tiM28Brains, aiBrain)
                            M28Utilities.ErrorHandler('Dont have any activeM28 brains noted despite dealing with an M28Brain')
                        end
                        for iUnit, oUnit in tUnitsToGive do
                            if iM28BrainCount > 1 then
                                oCurBrain = tiM28Brains[math.random(1, iM28BrainCount)]
                            else
                                oCurBrain = tiM28Brains[iM28BrainCount]
                            end
                            --Gift adjacent mass storage if any
                            if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                                M28Team.GiftAdjacentStorageToMexOwner(oUnit, oCurBrain)
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Just about to try and gift unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..' to M28AI brain '..oCurBrain.Nickname) end
                            M28Team.TransferUnitsToPlayer({ oUnit }, oCurBrain:GetArmyIndex(), false)
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SetBuildAndResourceCheatModifiers(aiBrain, iBuildModifier, iResourceModifier)
    --Note - see also FixUnitResourceCheatModifiers(oUnit) for a function intended to try and fix SACU FAF issue with AiX
    ScenarioInfo.Options.CheatMult = tostring(iResourceModifier)
    ScenarioInfo.Options.BuildMult = tostring(iBuildModifier)
    local FAFBuffs = import('/lua/sim/Buff.lua')
    Buffs['CheatBuildRate'].Affects.BuildRate.Mult = iBuildModifier
    Buffs['CheatIncome'].Affects.EnergyProduction.Mult = iResourceModifier
    Buffs['CheatIncome'].Affects.MassProduction.Mult = iResourceModifier

    local tExistingUnits = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryResourceUnit, false, false)
    if M28Utilities.IsTableEmpty(tExistingUnits) == false then
        for iUnit, oUnit in tExistingUnits do
            FAFBuffs.RemoveBuff(oUnit, 'CheatIncome', true)
            FAFBuffs.ApplyBuff(oUnit, 'CheatIncome')
            FAFBuffs.RemoveBuff(oUnit, 'CheatBuildRate', true)
            FAFBuffs.ApplyBuff(oUnit, 'CheatBuildRate')
        end
    end

end

function CheckForScenarioObjectives()
    --NO LONGER USED - use AddObjective hook instead
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckForScenarioObjectives'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    M28Utilities.ErrorHandler('Obsolete function')
    if bDebugMessages == true then LOG(sFunctionRef..': Will start scenario mission checker if not already active, bActiveMissionChecker='..tostring(bActiveMissionChecker)) end
    if not(bActiveMissionChecker) then
        bActiveMissionChecker = true

        while not(M28Map.bMapLandSetupComplete) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if M28Utilities.IsTableEmpty(tAllActiveM28Brains) then break end
        end
        local iTeam

        local tObjectivesConsidered = {}
        local iLastMissionConsidered = 0
        function ConsiderObjective(sMissionRef, iMission, iObjective)
            --Does this objective exist and we havent already considered it?
            if ScenarioInfo[sMissionRef] and not(tObjectivesConsidered[sMissionRef]) then
                tObjectivesConsidered[sMissionRef] = true
                iLastMissionConsidered = math.max(iMission, iLastMissionConsidered)
                if bDebugMessages == true then LOG(sFunctionRef..': Have just recorded a new objective, sMissionRef='..sMissionRef..'; iMission='..iMission..'; iObjective='..iObjective..'; reprs of mission='..reprs(ScenarioInfo[sMissionRef])) end
            end
        end
        local sMissionRef
        if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop, is table of active M28 brains empty='..tostring(M28Utilities.IsTableEmpty(tAllActiveM28Brains))) end
        while M28Utilities.IsTableEmpty(tAllActiveM28Brains) == false do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(60)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            --Check for new objectives
            for iMission = math.max(1, iLastMissionConsidered), iLastMissionConsidered + 1 do
                for iPrimaryObjective = 1, 5 do
                    sMissionRef = 'M'..iMission..'P'..iPrimaryObjective
                    ConsiderObjective(sMissionRef, iMission, iPrimaryObjective)
                end
                for iSecondaryObjective = 1, 5 do
                    sMissionRef = 'M'..iMission..'S'..iSecondaryObjective
                    ConsiderObjective(sMissionRef, iMission, iSecondaryObjective)
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking form issions, iLastMissionConsidered='..iLastMissionConsidered..'; tObjectivesConsidered='..repru(tObjectivesConsidered)) end
        end

        bActiveMissionChecker = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function M28ErisKilled()

    if(not ScenarioInfo.OpEnded) and ScenarioInfo.M4P1.Active then
        local CampaignScript = import('/maps/scca_coop_e03.v0021/SCCA_Coop_E03_script.lua')
        if CampaignScript.ErisKilled then
            LOG('Manually calling Eris killed event')
            CampaignScript.ErisKilled()
        end
        --[[WaitSeconds(20)
        if(not ScenarioInfo.OpEnded) and ScenarioInfo.M4P1.Active then
            local ScenarioFramework = import('/lua/ScenarioFramework.lua')
            ScenarioFramework.EndOperationSafety()
            ScenarioInfo.OpComplete = true

            -- aeon cdr killed
            --    ScenarioFramework.EndOperationCamera(ScenarioInfo.AeonCDR)
            --ScenarioFramework.CDRDeathNISCamera(ScenarioInfo.AeonCDR) --Commander will be dead now/unit invalid

            local OpStrings = import('/maps/scca_coop_e03.v0021/SCCA_Coop_E03_strings.lua')
            ScenarioFramework.Dialogue(OpStrings.E03_M04_070, StartKillGame, true)
        end--]]
    end
end

function DelayedCybranFireBlackSun(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DelayedCybranFireBlackSun'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Will wait a bit then fire black sun') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitSeconds(10)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Has the op ended yet='..tostring(ScenarioInfo.OpEnded or false)..'; OpComplete='..tostring(ScenarioInfo.OpComplete or false)) end
    if not(ScenarioInfo.OpEnded) and not(ScenarioInfo.OpComplete) then
        M28Chat.SendMessage(aiBrain, 'M6End', 'Getting ready to fire black sun...', 0, 100000, false, false)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(5)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': WIll fire black sun') end
        local ScenarioFramework = import('/lua/ScenarioFramework.lua')
        ScenarioFramework.FlushDialogueQueue()
        ScenarioFramework.EndOperationSafety()
        ScenarioInfo.OpComplete = true
        if ScenarioInfo.M3P2 then
            ScenarioInfo.M3P2:ManualResult(true)
        end
        ScenarioFramework.EndOperation(ScenarioInfo.OpComplete, ScenarioInfo.OpComplete, true)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function M1AeonEndMissionBackupMonitor()
    --Every 20s checks if have killed enemy ACU then waits another 20s before ending game (as default is far too long)
    --Call via fork thread
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'M1AeonEndMissionBackupMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': start of code, for time '..GetGameTimeSeconds()..'; bActiveMissionChecker='..tostring(bActiveMissionChecker)..'; Is M7 UEF commander valid='..tostring(M28UnitInfo.IsUnitValid(ScenarioInfo.M7_FauxUEFCommanderUnit))) end
    if not(bActiveMissionChecker) and M28UnitInfo.IsUnitValid(ScenarioInfo.M7_FauxUEFCommanderUnit) then
        bActiveMissionChecker = true
        while M28UnitInfo.IsUnitValid(ScenarioInfo.M7_FauxUEFCommanderUnit) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(20)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Is UEF ACU still valid='..tostring( M28UnitInfo.IsUnitValid(ScenarioInfo.M7_FauxUEFCommanderUnit))) end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': UEF ACU is now dead, will wait 20s then start ending the game') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(20)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Is operation not ending yet via normal logic='..tostring(not(ScenarioInfo.OperationEnding))..'; Time='..GetGameTimeSeconds()) end
        if ScenarioInfo.OperationEnding then
            if bDebugMessages == true then LOG(sFunctionRef..': Will wait another 15s to see if scenario ends') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(15)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end --Wait another 15s to give the main mission a chance to end properly
        ScenarioInfo.M7P4:ManualResult(true)
        if bDebugMessages == true then LOG(sFunctionRef..': Will end operation safely, and then wait 10s and end operation') end
        local ScenarioFramework = import('/lua/ScenarioFramework.lua')
        local OpStrings   = import('/maps/scca_coop_a01.v0016/SCCA_Coop_A01_Strings.lua')
        local Objectives = import('/lua/ScenarioFramework.lua').Objectives
        ScenarioFramework.EndOperationSafety()
        ScenarioFramework.Dialogue(OpStrings.A01_M07_116, false, true) -- Rhiza: "Glorious!"
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(5)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        ScenarioInfo.OpComplete = true
        local secondary = Objectives.IsComplete(ScenarioInfo.M7S1) and Objectives.IsComplete(ScenarioInfo.M7S2)
        local bonus = Objectives.IsComplete(ScenarioInfo.M1B1) and Objectives.IsComplete(ScenarioInfo.M1B2) and Objectives.IsComplete(ScenarioInfo.M1B3) and Objectives.IsComplete(ScenarioInfo.M6B1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(5.0)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Will now end operation at time '..GetGameTimeSeconds()) end
        ScenarioFramework.EndOperation(ScenarioInfo.OpComplete, ScenarioInfo.OpComplete, secondary, bonus)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderSpecialCampaignObjectives(Type, Complete, Title, Description, ActionImage, Target, IsLoading, loadedTag, iOptionalWaitInSeconds)
    --NOTE: All of input variables are optional as sometimes we just call this due to a playable area size change
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderSpecialCampaignObjectives'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if iOptionalWaitInSeconds then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(iOptionalWaitInSeconds)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code at time '..GetGameTimeSeconds()..' after iOptionalWaitInSeconds='..(iOptionalWaitInSeconds or 'nil')..'; Is M3P3 active='..tostring(ScenarioInfo.M3P3.Active or false)..'; Is commander gate area empty='..tostring(Scenario.Areas['CDR_Gate_Area'] == nil)..'; CDR_Gate_Area='..repru(Scenario.Areas['CDR_Gate_Area'])..'; ScenarioInfo.M1P3.Active='..tostring(ScenarioInfo.M1P3.Active or false)..'; Is combined table empty='..tostring(M28Utilities.IsTableEmpty(ScenarioInfo.M1_TempleCombinedTable))..'; M1P2 active='..tostring(ScenarioInfo.M1P2.Active)..'; M1P1 active='..tostring(ScenarioInfo.M1P1.Active)) end

    local aiBrain
    for iBrain, oBrain in tAllActiveM28Brains do
        if oBrain.M28AI then aiBrain = oBrain break end
    end
    if aiBrain then
        local iTeam = aiBrain.M28Team
        --UEF Mission 3 - create a special death trigger for Aeon ACU due to flaw with preceding objective
        if bDebugMessages == true then
            LOG(sFunctionRef..': Further logs, ScenarioInfo.M3BaseDamageWarnings='..(ScenarioInfo.M3BaseDamageWarnings or 'nil')..'; ScenarioInfo.MainFrameIsAlive='..tostring(ScenarioInfo.MainFrameIsAlive or false)..'; ScenarioInfo.EMPFired='..tostring(ScenarioInfo.EMPFired or false)..'; ScenarioInfo.M3_Base is empty='..tostring(M28Utilities.IsTableEmpty(ScenarioInfo.M3_Base))..'; bPacifistModeActive='..tostring(bPacifistModeActive)..'; ScenarioInfo.MissionNumber='..(ScenarioInfo.MissionNumber or 'nil')..'; iTeam='..iTeam..'; C M6: ScenarioInfo.ControlCenter is nil='..tostring(ScenarioInfo.ControlCenter == nil)..'; ScenarioInfo.Czar is nil='..tostring(ScenarioInfo.Czar == nil)..'; Is table of czars empty='..tostring(M28Utilities.IsTableEmpty(ScenarioInfo.Czar))..'; Is M3P1 active='..tostring(ScenarioInfo.M3P1.Active)..'; Is M3P2 active='..tostring(ScenarioInfo.M3P2.Active)..'; Is there a valid black sun unit='..tostring(M28UnitInfo.IsUnitValid(ScenarioInfo.BlackSunWeapon)))
            if M28UnitInfo.IsUnitValid(ScenarioInfo.BlackSunWeapon) then LOG(sFunctionRef..': Have a valid black sun unit, Target[1].UnitId='..(Target[1].UnitId or 'nil')..'; Black sun brain owner='..ScenarioInfo.BlackSunWeapon:GetAIBrain().Nickname..'; Faction index='..ScenarioInfo.BlackSunWeapon:GetAIBrain():GetFactionIndex()) end
        end
        if ScenarioInfo.M4P1 and M28Utilities.IsTableEmpty(Target.Units) and ScenarioInfo.M4P1.Active and M28UnitInfo.IsUnitValid(ScenarioInfo.AeonCDR) then
            if bDebugMessages == true then LOG(sFunctionRef..': Creating manual on death trigger') end
            local ScenarioFramework = import('/lua/ScenarioFramework.lua')
            ScenarioFramework.CreateUnitDeathTrigger(M28ErisKilled, ScenarioInfo.AeonCDR)
            --UEF Mission 5 - send ACU to gateway
        elseif ScenarioInfo.M3P3.Active and Scenario.Areas['CDR_Gate_Area'] and ScenarioInfo.PlayerCDRs then
            --local rRect = import("/lua/sim/scenarioutilities.lua").AreaToRect('CDR_Gate_Area')
            local tRect = import("/lua/sim/scenarioutilities.lua").AreaToRect('CDR_Gate_Area')
            local rRect = {tRect['x0'], tRect['y0'], tRect['x1'], tRect['y1']}
            if bDebugMessages == true then LOG(sFunctionRef..': rRect='..repru(rRect)..'; AreaToRect='..repru(import("/lua/sim/scenarioutilities.lua").AreaToRect('CDR_Gate_Area'))) end
            if rRect then
                local tMidpoint = {(rRect[1] + rRect[3])*0.5, 0, (rRect[2] + rRect[4])*0.5}
                tMidpoint[2] = GetTerrainHeight(tMidpoint[1], tMidpoint[3])
                for iUnit, oUnit in ScenarioInfo.PlayerCDRs do
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        LOG(sFunctionRef..': Considering ACU owned by brain '..oUnit:GetAIBrain().Nickname..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; if M28 then will set objective to tMidpoint='..repru(tMidpoint))
                        if oUnit:GetAIBrain().M28AI then
                            oUnit[M28ACU.reftSpecialObjectiveMoveLocation] = {tMidpoint[1], tMidpoint[2], tMidpoint[3]}
                        end
                    end
                end
            end
        elseif ScenarioInfo.M1_TempleCombinedTable and (ScenarioInfo.M1P3.Active or ScenarioInfo.M1P2.Active) then
            if bDebugMessages == true then LOG(sFunctionRef..': Will check if we have Seraphim temples that need manually destroying') end
            if M28Utilities.IsTableEmpty(   ScenarioInfo.M1_TempleCombinedTable) == false and M28Utilities.IsTableEmpty(tAllActiveM28Brains) == false then

                for iUnit, oUnit in ScenarioInfo.M1_TempleCombinedTable do
                    --Add to table of units in the land zone (if it is in a land zone)
                    local iPlateau, iLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
                    if (iLandZone or 0) > 0 then
                        local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                        local bAddToTable = true
                        if not(tLZTeamData[M28Map.reftoGroundFireFriendlyTarget]) then tLZTeamData[M28Map.reftoGroundFireFriendlyTarget] = {}
                        else
                            for iRecordedUnit, oRecordedUnit in tLZTeamData[M28Map.reftoGroundFireFriendlyTarget] do
                                if oRecordedUnit == oUnit then
                                    bAddToTable = false
                                    break
                                end
                            end
                        end
                        if bAddToTable then
                            if bDebugMessages == true then LOG(sFunctionRef..': Added unit to the land zone team table of ground fire targets') end
                            table.insert(tLZTeamData[M28Map.reftoGroundFireFriendlyTarget], oUnit)
                        end
                    end
                end
            end
            --Cybran mission 2 - move to gate
        elseif ScenarioInfo.M3P2.Active and ScenarioInfo.M3Gate and M28UnitInfo.IsUnitValid(ScenarioInfo.M3Gate) then
            for iBrain, oBrain in tAllActiveM28Brains do
                local tACUs = oBrain:GetListOfUnits(categories.COMMAND, false, true)
                if M28Utilities.IsTableEmpty(tACUs) == false then
                    for iUnit, oUnit in tACUs do
                        LOG(sFunctionRef..': Considering ACU owned by brain '..oUnit:GetAIBrain().Nickname..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; if M28 then will set objective to gate position='..repru(ScenarioInfo.M3Gate:GetPosition()))
                        oUnit[M28ACU.reftSpecialObjectiveMoveLocation] = ScenarioInfo.M3Gate:GetPosition()
                    end
                end
            end
            --Cybran mission 4 - play defensively and let human player try and capture the nodes
        elseif ScenarioInfo.M3BaseDamageWarnings and ScenarioInfo.MainFrameIsAlive and not ScenarioInfo.EMPFired and (ScenarioInfo.M3_Base or Scenario.Areas['Aeon_Base_M3']) and not(bPacifistModeActive) then
            --Reset base warnings to help M28 a bit since it can trigger the damage before this objective is even active
            if ScenarioInfo.M3BaseDamageWarnings > 0 then ScenarioInfo.M3BaseDamageWarnings = 0 end
            local tUnitsToConsider = ScenarioInfo.M3_Base
            if not(tUnitsToConsider) then
                local ScenarioFramework = import('/lua/ScenarioFramework.lua')
                tUnitsToConsider = ScenarioFramework.GetCatUnitsInArea(categories.STRUCTURE - categories.WALL, 'Aeon_Base_M3', ArmyBrains[ScenarioInfo.Aeon])
            end
            if M28Utilities.IsTableEmpty(tUnitsToConsider) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to disable attacking parts of the map that could cause us to fail the mission') end
                bPacifistModeActive = true

                tiPacifistZonesByPlateau = {}
                local tbHasPlateauAndZoneBeenRecorded = {}
                local iCurPlateauOrZero, iCurLandOrWaterZone
                for iUnit, oUnit in ScenarioInfo.M3_Base do
                    iCurPlateauOrZero, iCurLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                    if iCurPlateauOrZero and iCurLandOrWaterZone and not(tbHasPlateauAndZoneBeenRecorded[iCurPlateauOrZero][iCurLandOrWaterZone]) then
                        if not(tiPacifistZonesByPlateau[iCurPlateauOrZero]) then tiPacifistZonesByPlateau[iCurPlateauOrZero] = {} end
                        table.insert(tiPacifistZonesByPlateau[iCurPlateauOrZero], iCurLandOrWaterZone)
                        if not(tbHasPlateauAndZoneBeenRecorded[iCurPlateauOrZero]) then tbHasPlateauAndZoneBeenRecorded[iCurPlateauOrZero] = {} end
                        tbHasPlateauAndZoneBeenRecorded[iCurPlateauOrZero][iCurLandOrWaterZone] = true
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished recording the plateaus and zones that units in M3_Base are in, repru of tiPacifistZonesByPlateau='..repru(tiPacifistZonesByPlateau)) end
                if M28Utilities.IsTableEmpty(tiPacifistZonesByPlateau) == false then
                    --Record any adjacent zones
                    local tiAdjacentZonesByPlateau = {}
                    for iPlateauOrZero, tBaseSubtable in tiPacifistZonesByPlateau do
                        for iEntry, iLandOrWaterZone in tBaseSubtable do
                            local tLZOrWZData
                            if iPlateauOrZero == 0 then
                                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                                --Water zone: Adjacent land zones
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering water zone '..iLandOrWaterZone..'; Is table of adjacent land zones empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentLandZones]))) end
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentLandZones]) == false then
                                    for iEntry, tSubtable in tLZOrWZData[M28Map.subrefAdjacentLandZones] do
                                        local iPlateauRef = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                                        local iAdjZoneRef = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjZoneRef='..iAdjZoneRef..'; iPlateauRef='..iPlateauRef) end
                                        if not(tbHasPlateauAndZoneBeenRecorded[iPlateauRef][iAdjZoneRef]) then
                                            tbHasPlateauAndZoneBeenRecorded[iPlateauRef][iAdjZoneRef] = true
                                            if not(tiAdjacentZonesByPlateau[iPlateauRef]) then tiAdjacentZonesByPlateau[iPlateauRef] = {} end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Adding iAdjZoneRef='..iAdjZoneRef..'; to table') end
                                            table.insert(tiAdjacentZonesByPlateau[iPlateauRef], iAdjZoneRef)
                                        end
                                    end
                                end
                                --Water zone: Adjacent water zones:
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefWZAdjacentWaterZones]))) end
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                                    for _, iAdjZoneRef in tLZOrWZData[M28Map.subrefWZAdjacentWaterZones] do
                                        if not(tbHasPlateauAndZoneBeenRecorded[0][iAdjZoneRef]) then
                                            tbHasPlateauAndZoneBeenRecorded[0][iAdjZoneRef] = true
                                            if not(tiAdjacentZonesByPlateau[0]) then tiAdjacentZonesByPlateau[0] = {} end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Adding WZ iAdjZoneRef='..iAdjZoneRef..'; to table') end
                                            table.insert(tiAdjacentZonesByPlateau[0], iAdjZoneRef)
                                        end
                                    end
                                end
                            else
                                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                                --Land zone: Adjacent land zones
                                if bDebugMessages == true then LOG(sFunctionRef..': Dealing with land zone, is table of adjacent land zones empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]))) end
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                    for _, iAdjZoneRef in tLZOrWZData[M28Map.subrefLZAdjacentLandZones] do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjZoneRef='..iAdjZoneRef..' in iPlateuOrZero='..iPlateauOrZero) end
                                        if not(tbHasPlateauAndZoneBeenRecorded[iPlateauOrZero][iAdjZoneRef]) then
                                            tbHasPlateauAndZoneBeenRecorded[iPlateauOrZero][iAdjZoneRef] = true
                                            if not(tiAdjacentZonesByPlateau[iPlateauOrZero]) then tiAdjacentZonesByPlateau[iPlateauOrZero] = {} end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Adding LZ iAdjZoneRef='..iAdjZoneRef..'; to table') end
                                            table.insert(tiAdjacentZonesByPlateau[iPlateauOrZero], iAdjZoneRef)
                                        end
                                    end
                                end
                                --Land zone: Adjacent water zone:
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]))) end
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]) == false then
                                    for iEntry, tSubtable in tLZOrWZData[M28Map.subrefAdjacentWaterZones] do
                                        local iAdjZoneRef = tSubtable[M28Map.subrefAWZRef]
                                        if not(tbHasPlateauAndZoneBeenRecorded[0][iAdjZoneRef]) then
                                            tbHasPlateauAndZoneBeenRecorded[0][iAdjZoneRef] = true
                                            if not(tiAdjacentZonesByPlateau[0]) then tiAdjacentZonesByPlateau[0] = {} end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Adding WZ iAdjZoneRef='..iAdjZoneRef..'; to table') end
                                            table.insert(tiAdjacentZonesByPlateau[0], iAdjZoneRef)
                                        end
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': About to add adjacent zones to core zone, tiAdjacentZonesByPlateau='..repru(tiAdjacentZonesByPlateau)) end
                    if M28Utilities.IsTableEmpty(tiAdjacentZonesByPlateau) == false then
                        for iPlateauOrZero, tSubtable in tiAdjacentZonesByPlateau do
                            for iEntry, iAdjZoneRef in tSubtable do
                                if not(tiPacifistZonesByPlateau[iPlateauOrZero]) then tiPacifistZonesByPlateau[iPlateauOrZero] = {} end
                                if bDebugMessages == true then LOG(sFunctionRef..': Adding iAdjZoneRef='..iAdjZoneRef..' for iPlateauOrZero='..iPlateauOrZero) end
                                table.insert(tiPacifistZonesByPlateau[iPlateauOrZero], iAdjZoneRef)
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished adding adjacent zones, repru of adjacent zones by plateau='..repru(tiAdjacentZonesByPlateau)) end

                    for iPlateauOrZero, tSubtable in tiPacifistZonesByPlateau do
                        for iEntry, iLandOrWaterZone in tSubtable do
                            local tLZOrWZData
                            if iPlateauOrZero == 0 then
                                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                            else
                                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                            end
                            tLZOrWZData[M28Map.subrefbPacifistArea] = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Set pacifist flag to true for iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone) end
                        end
                    end
                end
            end
        elseif bPacifistModeActive and ScenarioInfo.EMPFired and M28Utilities.IsTableEmpty(tiPacifistZonesByPlateau) == false then
            --Disable pacifist flag
            if bDebugMessages == true then LOG(sFunctionRef..': EMP has been fired so will disable pacifist flag for all recorded zones, tiPacifistZonesByPlateau='..repru(tiPacifistZonesByPlateau)) end
            bPacifistModeActive = false
            for iPlateauOrZero, tSubtable in tiPacifistZonesByPlateau do
                local tLZOrWZData
                for iEntry, iLandOrWaterZone in tSubtable do
                    if iPlateauOrZero == 0 then
                        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                    else
                        tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                    end
                    tLZOrWZData[M28Map.subrefbPacifistArea] = false
                end
            end
            --Cybran mission 6 - activate black sun (below is as a redundancy but doesnt actually trigger - are reliant on the oncapture event instead)
        elseif ScenarioInfo.M3P2.Active and M28UnitInfo.IsUnitValid(ScenarioInfo.BlackSunWeapon) and ScenarioInfo.BlackSunWeapon:GetAIBrain().M28AI and ScenarioInfo.BlackSunWeapon:GetAIBrain():GetFactionIndex() == M28UnitInfo.refFactionCybran then
            if bDebugMessages == true then LOG(sFunctionRef..': Want to fire black sun to complete cybran campaign - will fire in a bit') end
            ForkThread(DelayedCybranFireBlackSun, ScenarioInfo.BlackSunWeapon:GetAIBrain())
            --Cybran mission 6 - kill Czar
        elseif ScenarioInfo.ControlCenter and ScenarioInfo.Czar and M28Utilities.IsTableEmpty(ScenarioInfo.Czar) == false and ScenarioInfo.M1P1.Active then
            function DelayedRecordingOfCzar(tUnits)
                WaitSeconds(15)
                if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting, time='..GetGameTimeSeconds()..' is table of units empty='..tostring(M28Utilities.IsTableEmpty(tUnits))) end
                if M28Utilities.IsTableEmpty(tUnits) == false then
                    for iUnit, oUnit in tUnits do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            if EntityCategoryContains(M28UnitInfo.refCategoryAllAir * categories.EXPERIMENTAL, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will record enemy Czar as a priority enemy air experimental target unless it is alrady recorded') end
                                local bAlreadyIncluded = false
                                if not(M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives]) then M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives] = {}
                                else
                                    for iRecordedUnit, oRecordedUnit in M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives] do
                                        if oRecordedUnit == oUnit then bAlreadyIncluded = true break end
                                    end
                                end
                                if not(bAlreadyIncluded) then
                                    table.insert(M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives], oUnit)
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will wait a while and then look to include enemy Czar as a priority enemy air experimental target unless it is alrady recorded') end
            ForkThread(DelayedRecordingOfCzar, ScenarioInfo.Czar)
            --Cybran M6 - fire black sun if it is owned by M28 and we are on the objective to fire it
        elseif ScenarioInfo.M7_FauxUEFCommanderUnit then
            ForkThread(M1AeonEndMissionBackupMonitor)
        end
    end
end