---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 08:37
---

local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local NavUtils = import("/lua/sim/navutils.lua")

--Variables against aiBrain:
--ECONOMY VARIABLES - below 4 are to track values based on base production, ignoring reclaim. Provide per tick values so 10% of per second)
refiGrossEnergyBaseIncome = 'M28EnergyGrossIncome' --against aiBrain
refiNetEnergyBaseIncome = 'M28EnergyNetIncome' --against aiBrain
refiGrossMassBaseIncome = 'M28MassGrossIncome' --against aiBrain
refiNetMassBaseIncome = 'M28MassNetIncome' --against aiBrain
refiBrainResourceMultiplier = 'M28ResourceMod' --Against aiBrain, e.g. 1.5 if AiX 1.5
refiBrainBuildRateMultiplier = 'M28BuildMod' --against aiBrain

refiMaxMassStorage = 'M28MaxMassStorage' --against aiBrain
refiMaxEnergyStorage = 'M28MaxEnergyStorage' --against aiBrain

--Factory tech variables
refiOurHighestFactoryTechLevel = 'M28EOurHighestFactoryTech' --against aiBrain
refiOurHighestAirFactoryTech = 'M28EOurHighestAirFactoryTech' --against aiBrain
refiOurHighestLandFactoryTech = 'M28EOurHighestLandFactoryTech' --against aiBrain
refiOurHighestNavalFactoryTech = 'M28EOurHighestNavalFactoryTech' --against aiBrain

reftPausedUnits = 'M28EconomyPausedUnits' --against aibrain, table of paused units for this brain

--Against unit variables:
refoBrainRecordedForEconomy = 'M28EconomyBrainRecordedUnit' --Stores the M28 brain that has factored in this unit's mass and energy income
refiLastEnergyUsage = 'M28EconomyLastEnergyUsage' --per tick energy usage of the unit (set when the unit is paused)
refiLastMassUsage = 'M28EconomyLastMassUsage' --per tick massu sage of the unit set when unit is paused
refiStorageMassAdjacencyBonus = 'M28EMassStorAdj' --Adjacency bonus from a mass storage

--global variables
tiMinEnergyPerTech = {[1]=16,[2]=55,[3]=150,[3]=150}
iSpecialHQCategory = 'M28EconomyFactoryHQ' --Used as a way of choosing to pause HQ
iSpecialSurplusUpgradeCategory = 'M28EconomySurplusUpgrade' --used as a way of choosing to pause excess upgrades

function UpgradeUnit(oUnitToUpgrade, bUpdateUpgradeTracker)
    --Work out the upgrade ID wanted; if bUpdateUpgradeTracker is true then records upgrade against unit's aiBrain
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpgradeUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, reprs of oUnitToUpgrade='..reprs(oUnitToUpgrade)..'; GetUnitUpgradeBlueprint='..reprs((M28UnitInfo.GetUnitUpgradeBlueprint(oUnitToUpgrade, true) or 'nil'))..'; bUpdateUpgradeTracker='..tostring((bUpdateUpgradeTracker or false))) end

    --Do we have any HQs of the same factory type of a higher tech level?
    local sUpgradeID = M28UnitInfo.GetUnitUpgradeBlueprint(oUnitToUpgrade, true) --If not a factory or dont recognise the faction then just returns the normal unit ID


    if sUpgradeID and M28UnitInfo.IsUnitValid(oUnitToUpgrade) then
        local aiBrain = oUnitToUpgrade:GetAIBrain()
        if bDebugMessages == true then LOG(sFunctionRef..': About to issue ugprade to unit '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)..'; Current state='..M28UnitInfo.GetUnitState(oUnitToUpgrade)..'; Work progress='..(oUnitToUpgrade:GetWorkProgress() or 'nil')..'; Is unit upgrading='..tostring(oUnitToUpgrade:IsUnitState('Upgrading'))) end

        if not(oUnitToUpgrade:IsUnitState('Upgrading')) then
            local bAddToExistingQueue = true



            --Factory specific - if work progress is <=5% then cancel so can do the upgrade
            if EntityCategoryContains(M28UnitInfo.refCategoryFactory, oUnitToUpgrade.UnitId) then
                if bDebugMessages == true then LOG(sFunctionRef..': Are upgrading a factory '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)..'; work progress='..oUnitToUpgrade:GetWorkProgress()) end
                if oUnitToUpgrade.GetWorkProgress and oUnitToUpgrade:GetWorkProgress() <= 0.05 then
                    --Are we building an engineer or transport?
                    local oUnitThatAreBuilding = oUnitToUpgrade:GetFocusUnit()
                    if not(M28UnitInfo.IsUnitValid(oUnitThatAreBuilding) and EntityCategoryContains(M28UnitInfo.refCategoryTransport + M28UnitInfo.refCategoryEngineer, oUnitThatAreBuilding.UnitId)) then
                        bAddToExistingQueue = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Have barely started with current construction so will cancel so can get upgrade sooner') end
                    end
                end
            end

            --Air factory upgrades - if we are upgrading from T1 to T2 and havent build a transport, and have plateaus, then want to get a transport first
            if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory * categories.TECH1, oUnitToUpgrade.UnitId) and aiBrain[refiOurHighestAirFactoryTech] == 1 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory * categories.TECH1) == 1 then
                --Do we have locations for transports to drop?

                if (M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftTransportIslandDropShortlist]) == false or M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftTransportFarAwaySameIslandPlateauLandZoneDropShortlist] == false)) and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryTransport) == 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have already queued up transport for this unit='..tostring(oUnitToUpgrade[refsQueuedTransport] or false)) end
                    local refsQueuedTransport = 'M28QueuedTransport'
                    if not(oUnitToUpgrade[refsQueuedTransport]) then
                        --Havent built any transports yet so build a T1 transport before we upgrade to T2 air

                        local sTransportID = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryTransport, oUnitToUpgrade)
                        if sTransportID then
                            oUnitToUpgrade[refsQueuedTransport] = true
                            M28Orders.IssueTrackedFactoryBuild(oUnitToUpgrade, sTransportID, false, 'PreUp')
                            if bDebugMessages == true then LOG(sFunctionRef..': Will queue up a transport for factory '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)) end
                        end
                    end
                end
            elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory * categories.TECH2 + M28UnitInfo.refCategoryAirFactory * categories.TECH2, oUnitToUpgrade.UnitId) and aiBrain[refiOurHighestFactoryTechLevel] <= 2 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer - categories.TECH1) <= 5 then
                --About to go for T3 factory but have hardl yany engineers so queue up an extra one
                local sEngiID = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryEngineer, oUnitToUpgrade)
                if sEngiID then
                    M28Orders.IssueTrackedFactoryBuild(oUnitToUpgrade, sEngiID, false, 'PreUp')
                end
                if bDebugMessages == true then LOG(sFunctionRef..': About to go to T3 on factory '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)..' but only have '..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer - categories.TECH1)..' T2 plus engis so will queue up another engi before the upgrade. sEngiID='..(sEngiID or 'nil')) end
            end

            --Issue upgrade
            M28Orders.IssueTrackedUpgrade(oUnitToUpgrade, sUpgradeID, bAddToExistingQueue)
        end

        --Clear any pausing of the unit
        oUnitToUpgrade:SetPaused(false)
        oUnitToUpgrade[M28UnitInfo.refbPaused] = false
        if bDebugMessages == true then LOG(sFunctionRef..': Just set paused to false for unit '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)) end

        if bUpdateUpgradeTracker then
            M28Team.UpdateUpgradeTrackingOfUnit(oUnitToUpgrade, false, sUpgradeID)
        end

        --T1 mexes - if start upgrading, then flag for TML protection --TODO in a future version (is on todo list)
    else
        M28Utilities.ErrorHandler('Dont have a valid upgrade ID; UnitID=' .. (oUnitToUpgrade.UnitId or 'nil'))
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetBestUnitToUpgrade(toPotentialUnits, bPrioritiseFactoryHQ)
    --Assumes have already checked units are valid/not upgrading and factored in whether safe or not already, so just need to do distance type check
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBestUnitToUpgrade'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iClosestUnitToBase = 100000
    local oClosestUnitToBase
    local iCurModDist
    for iUnit, oUnit in toPotentialUnits do
        iCurModDist = M28Map.GetModDistanceFromStart(oUnit:GetAIBrain(), oUnit:GetPosition(), false)
        if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurModDist before adjust='..iCurModDist..'; iClosestUnitToBase='..iClosestUnitToBase..'; bPrioritiseFactoryHQ='..tostring(bPrioritiseFactoryHQ or false)) end
        if bPrioritiseFactoryHQ and not(EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnit.UnitId)) then iCurModDist = iCurModDist + 1000 end
        if iCurModDist < iClosestUnitToBase then
            iClosestUnitToBase = iCurModDist
            oClosestUnitToBase = oUnit
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Best unit to upgrade was '..(oClosestUnitToBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestUnitToBase) or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oClosestUnitToBase
end

function UpdateLandZoneM28AllMexByTech(aiBrain, iPlateau, iLandZone, oOptionalUnitThatDied, iOptionalWait)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateLandZoneM28AllMexByTech'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team]
    if iOptionalWait then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(iOptionalWait)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    tLZTeamData[M28Map.subrefMexCountByTech] = {[1]=0,[2]=0,[3]=0} --starting point
    if bDebugMessages == true then LOG(sFunctionRef..': Time of game='..GetGameTimeSeconds()..'; Is table of allied units for iPlateau '..iPlateau..' iLandZone '..iLandZone..' empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
        local tAllMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        --Update list of units in this LZ in case some of the mexes are dead now
        M28Land.UpdateUnitPositionsAndLandZone(aiBrain, tAllMexes, aiBrain.M28Team, iPlateau, iLandZone, false)

        local tMexesByTech = {}
        local iMexCount = 0
        tMexesByTech[1] = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex * categories.TECH1, tAllMexes)
        tMexesByTech[2] = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex * categories.TECH2, tAllMexes)
        tMexesByTech[3] = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex * categories.TECH3, tAllMexes)
        if bDebugMessages == true then LOG(sFunctionRef..': oOptionalUnitThatDied='..(oOptionalUnitThatDied.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oOptionalUnitThatDied) or 'nil')..'; Is tAllMexes empty='..tostring(M28Utilities.IsTableEmpty(tAllMexes))) end

        for iTech = 1, 3 do
            if M28Utilities.IsTableEmpty(tMexesByTech[iTech]) == false then
                for iMex, oCurMex in tMexesByTech[iTech] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Plateau='..iPlateau..'; iLandZone='..iLandZone..'; oCurMex='..oCurMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oCurMex)..'; Unit state='..M28UnitInfo.GetUnitState(oCurMex)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oCurMex))..'; Position='..repru(oCurMex:GetPosition())..'; iTech='..iTech..'; iMexCount pre increase='..iMexCount..'; tLZTeamData[M28Map.subrefMexCountByTech] pre increase='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
                    if oCurMex:GetAIBrain().M28AI and M28UnitInfo.IsUnitValid(oCurMex) and oCurMex:GetFractionComplete() == 1 and not(oOptionalUnitThatDied == oCurMex) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding iMex '..iMex..'; oCurMex='..oCurMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oCurMex)..' to mex count. reprs of mex='..reprs(oCurMex)) end
                        tLZTeamData[M28Map.subrefMexCountByTech][iTech] = tLZTeamData[M28Map.subrefMexCountByTech][iTech] + 1
                        iMexCount = iMexCount + 1
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished updating mex count, tLZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; iMexCount='..iMexCount..'; Table size of mex locations for this LZ='..table.getn( M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations])) end
        --If have somehow ended up with more mexes than there are locations, then redo the check in 1 second
        if iMexCount > table.getn( M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]) then
            if (iOptionalWait or 0) >= 10 then
                M28Utilities.ErrorHandler('Somehow we have more mexes than we should even after waiting '..iOptionalWait..' first, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iMexCount='..iMexCount..'; tLZTeamData[M28Map.subrefMexCountByTech]='..reprs(tLZTeamData[M28Map.subrefMexCountByTech]))
            end
            ForkThread(UpdateLandZoneM28AllMexByTech, aiBrain, iPlateau, iLandZone, oOptionalUnitThatDied, 15)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateLandZoneM28MexByTechCount(oMexJustBuiltOrDied, bJustDied, iOptionalWait)
    --Call via fork thread on mex creation due to potential timing issue with an upgrading mex being destroyed and replaced with the new (upgraded) mex
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateLandZoneM28MexByTechCount'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if oMexJustBuiltOrDied.GetAIBrain then
        local aiBrain = oMexJustBuiltOrDied:GetAIBrain()
        if aiBrain.M28AI then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oMexJustBuiltOrDied:GetPosition())
            --should be called whenever a mex is created or destroyed in a land zone; ideally call via fork thread so reduced risk of it being called inbetween a mex say upgrading from one to another and being claled before both the creation and destroy events have happened
            if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; oMexJustBuiltOrDied='..(oMexJustBuiltOrDied.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oMexJustBuiltOrDied) or 'nil')..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; Mex position='..repru(oMexJustBuiltOrDied:GetPosition())..'; iMapWaterHeight='..M28Map.iMapWaterHeight..'; iOptionalWait='..(iOptionalWait or 'nil')..'; bJustDied='..tostring(bJustDied or false)) end
            if (iLandZone or 0) > 0 then
                if not(iOptionalWait) then
                    if bJustDied then
                        UpdateLandZoneM28AllMexByTech(aiBrain, iPlateau, iLandZone, oMexJustBuiltOrDied)
                    else
                        UpdateLandZoneM28AllMexByTech(aiBrain, iPlateau, iLandZone, nil)
                    end
                else
                    if bJustDied then
                        ForkThread(UpdateLandZoneM28AllMexByTech, aiBrain, iPlateau, iLandZone, oMexJustBuiltOrDied, iOptionalWait)
                    else
                        ForkThread(UpdateLandZoneM28AllMexByTech, aiBrain, iPlateau, iLandZone, nil, iOptionalWait)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function FindAndUpgradeUnitOfCategory(aiBrain, iCategoryWanted)
    --e.g. intended for upgrading factory HQs
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'FindAndUpgradeUnitOfCategory'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local tUnitsOfCategory = aiBrain:GetListOfUnits(iCategoryWanted, false, true)
    if M28Utilities.IsTableEmpty(tUnitsOfCategory) == false then
        local tUnitsToSearch = {}
        local tUnsafeUnitsOfCategory = {}
        local iCurPlateau, iCurLZ
        for iUnit, oUnit in tUnitsOfCategory do
            if oUnit:GetFractionComplete() == 1 and not(oUnit:IsUnitState('Upgrading')) and not(oUnit.Dead) then
                --Are we in a safe land zone?
                iCurPlateau, iCurLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                local tLZTeamData = M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLZ][M28Map.subrefLZTeamData][aiBrain.M28Team]
                if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] then
                    table.insert(tUnsafeUnitsOfCategory, oUnit)
                else
                    table.insert(tUnitsToSearch, oUnit)
                end
            end
        end
        if M28Utilities.IsTableEmpty(tUnitsToSearch) then tUnitsToSearch = tUnsafeUnitsOfCategory end
        if M28Utilities.IsTableEmpty(tUnitsToSearch) == false then
            local iCurDist
            local iClosestDist = 100000
            local oClosestUnit
            if bDebugMessages == true then LOG(sFunctionRef..': About to consider '..table.getn(tUnitsToSearch)..' potential units to upgrade, will pick the closest one') end
            for iUnit, oUnit in tUnitsToSearch do
                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()])
                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..(oUnit.UnitId or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; iCurDist='..iCurDist) end
                if iCurDist < iClosestDist then
                    iClosestDist = iCurDist
                    oClosestUnit = oUnit
                end
            end
            if oClosestUnit then
                if bDebugMessages == true then LOG(sFunctionRef..': WIll try and upgrade oClosestUnit '..oClosestUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestUnit)..'; Fraction complete='..oClosestUnit:GetFractionComplete()..'; Unit state='..M28UnitInfo.GetUnitState(oClosestUnit)) end
                UpgradeUnit(oClosestUnit, true) --Will queue up transport or engineer for factories as well as figuring out whether to upgrade a support factory or an HQ
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateFactoryCountForFactoryKilledOrBuilt(oFactory, bIsDead)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateFactoryCountForFactoryKilledOrBuilt'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iAdjust = 0
    local sTrackerRef = 'M28RecordedCount'
    if bIsDead then
        if oFactory[sTrackerRef] then
            iAdjust = -1
            oFactory[sTrackerRef] = false
        end
    else
        if not(oFactory[sTrackerRef]) then
            iAdjust = 1
            oFactory[sTrackerRef] = true
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Near start, Time='..GetGameTimeSeconds()..'; iAdjust='..iAdjust..'; bIsDead='..tostring(bIsDead or false)..'; oFactory='..(oFactory.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oFactory) or 'nil')) end
    if not(iAdjust == 0) then
        local iFactoryType, iFactoryCategory = M28UnitInfo.GetFactoryType(oFactory)
        if bDebugMessages == true then LOG(sFunctionRef..': iFactoryType='..iFactoryType..'; iTeam='..oFactory:GetAIBrain().M28Team..'; Brain='..oFactory:GetAIBrain().Nickname..'; Team factory count by type before update='..(M28Team.tTeamData[oFactory:GetAIBrain().M28Team][M28Team.subrefiTotalFactoryCountByType][iFactoryType] or 'nil')) end
        M28Team.tTeamData[oFactory:GetAIBrain().M28Team][M28Team.subrefiTotalFactoryCountByType][iFactoryType] = math.max(0, M28Team.tTeamData[oFactory:GetAIBrain().M28Team][M28Team.subrefiTotalFactoryCountByType][iFactoryType] + iAdjust)
        if bDebugMessages == true then LOG(sFunctionRef..': Factory count after update='..M28Team.tTeamData[oFactory:GetAIBrain().M28Team][M28Team.subrefiTotalFactoryCountByType][iFactoryType]) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateHighestFactoryTechLevelForBuiltUnit(oUnitJustBuilt)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateHighestFactoryTechLevelForBuiltUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Checking if just built a factory HQ, Have just built unit '..oUnitJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitJustBuilt)..'; Fraction complete='..oUnitJustBuilt:GetFractionComplete()..'; Is it a factory HQ='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnitJustBuilt.UnitId))) end

    --Update total factory count


    if oUnitJustBuilt:GetFractionComplete() == 1 and EntityCategoryContains(M28UnitInfo.refCategoryFactory, oUnitJustBuilt.UnitId) then
        --Update factory count
        UpdateFactoryCountForFactoryKilledOrBuilt(oUnitJustBuilt, false)
        if EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnitJustBuilt.UnitId) then
            local iUnitTechLevel = M28UnitInfo.GetUnitTechLevel(oUnitJustBuilt)
            local sFactoryRef
            if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnitJustBuilt.UnitId) then sFactoryRef = refiOurHighestLandFactoryTech
            elseif EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oUnitJustBuilt.UnitId) then sFactoryRef = refiOurHighestAirFactoryTech
            elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oUnitJustBuilt.UnitId) then sFactoryRef = refiOurHighestNavalFactoryTech
            else M28Utilities.ErrorHandler('Unrecognised factory type')
            end
            local aiBrain = oUnitJustBuilt:GetAIBrain()
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if factory HQ is a higher tech than we already have, sFactoryRef='..sFactoryRef..'; iUnitTechLevel='..iUnitTechLevel..'; aiBrain[sFactoryRef]='..aiBrain[sFactoryRef]) end
            if iUnitTechLevel > aiBrain[sFactoryRef] then
                aiBrain[sFactoryRef] = math.max(aiBrain[sFactoryRef], iUnitTechLevel)
                aiBrain[refiOurHighestFactoryTechLevel] = math.max(iUnitTechLevel, aiBrain[refiOurHighestFactoryTechLevel])
                --Update team details
                M28Team.UpdateTeamHighestAndLowestFactories(aiBrain.M28Team)
                M28Team.CheckForSubteamFactoryChange(oUnitJustBuilt, true)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateHighestFactoryTechLevelForDestroyedUnit(oUnitJustDestroyed)
    --Dont call via forkthread as causes issues with the unit being removed
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateHighestFactoryTechLevelForDestroyedUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if EntityCategoryContains(M28UnitInfo.refCategoryFactory, oUnitJustDestroyed.UnitId) then
        UpdateFactoryCountForFactoryKilledOrBuilt(oUnitJustDestroyed, true)
        if bDebugMessages == true then LOG(sFunctionRef..': Factory was destroyed, oUnitJustDestroyed='..oUnitJustDestroyed.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitJustDestroyed)..'; is this an HQ factory='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnitJustDestroyed.UnitId))) end
        if EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnitJustDestroyed.UnitId) then
            local aiBrain = oUnitJustDestroyed:GetAIBrain()
            local iUnitTechLevel = M28UnitInfo.GetUnitTechLevel(oUnitJustDestroyed)
            if bDebugMessages == true then LOG(sFunctionRef..': iUnitTechLevel='..iUnitTechLevel..'; owned by brain '..aiBrain.Nickname) end
            function UnitsStillValid(iCategory)
                local tUnitsOfType = aiBrain:GetListOfUnits(iCategory, false, true)
                if M28Utilities.IsTableEmpty(tUnitsOfType) == false then
                    for iUnit, oUnit in tUnitsOfType do
                        if not(oUnit == oUnitJustDestroyed) and M28UnitInfo.IsUnitValid(oUnit) then
                            return true
                        end
                    end
                end
                return false
            end
            local iCategoryBeingConsidered
            if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnitJustDestroyed.UnitId) then
                if iUnitTechLevel >= (aiBrain[refiOurHighestLandFactoryTech] or 0) then
                    aiBrain[refiOurHighestLandFactoryTech] = 0
                    for iTechLevel = 3, 1, -1 do
                        iCategoryBeingConsidered = M28UnitInfo.refCategoryLandFactory * M28UnitInfo.ConvertTechLevelToCategory(iTechLevel) - categories.SUPPORTFACTORY
                        if aiBrain:GetCurrentUnits(iCategoryBeingConsidered) > 0 and UnitsStillValid(iCategoryBeingConsidered) then
                            --Check these units are all still valid
                            aiBrain[refiOurHighestLandFactoryTech] = iTechLevel
                            break
                        end
                    end
                end
            elseif EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oUnitJustDestroyed.UnitId) then
                if bDebugMessages == true then LOG(sFunctionRef..': Air fac was destroyed, aiBrain[refiOurHighestAirFactoryTech]='..(aiBrain[refiOurHighestAirFactoryTech] or 'nil')..'; iUnitTechLevel='..iUnitTechLevel) end
                if iUnitTechLevel >= aiBrain[refiOurHighestAirFactoryTech] then
                    aiBrain[refiOurHighestAirFactoryTech] = 0
                    for iTechLevel = 3, 1, -1 do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iTechLevel='..iTechLevel..'; Cur units owned by this brain of that tech level excl support factory='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory * M28UnitInfo.ConvertTechLevelToCategory(iTechLevel) - categories.SUPPORTFACTORY)) end
                        iCategoryBeingConsidered = M28UnitInfo.refCategoryAirFactory * M28UnitInfo.ConvertTechLevelToCategory(iTechLevel) - categories.SUPPORTFACTORY
                        if aiBrain:GetCurrentUnits(iCategoryBeingConsidered) > 0 and UnitsStillValid(iCategoryBeingConsidered) then
                            aiBrain[refiOurHighestAirFactoryTech] = iTechLevel
                            break
                        end
                    end
                end
            elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oUnitJustDestroyed.UnitId) then
                if iUnitTechLevel >= aiBrain[refiOurHighestNavalFactoryTech] then
                    aiBrain[refiOurHighestNavalFactoryTech] = 0
                    for iTechLevel = 3, 1, -1 do
                        iCategoryBeingConsidered = M28UnitInfo.refCategoryNavalFactory * M28UnitInfo.ConvertTechLevelToCategory(iTechLevel) - categories.SUPPORTFACTORY
                        if aiBrain:GetCurrentUnits(iCategoryBeingConsidered) > 0 and UnitsStillValid(iCategoryBeingConsidered) then
                            aiBrain[refiOurHighestNavalFactoryTech] = iTechLevel
                            break
                        end
                    end
                end
            else M28Utilities.ErrorHandler('Unrecognised factory type')
            end

            --Updated highest factory type across all types
            aiBrain[refiOurHighestFactoryTechLevel] = math.max(aiBrain[refiOurHighestLandFactoryTech], aiBrain[refiOurHighestAirFactoryTech], aiBrain[refiOurHighestNavalFactoryTech])

            --Update team details
            M28Team.UpdateTeamHighestAndLowestFactories(aiBrain.M28Team)
            M28Team.CheckForSubteamFactoryChange(oUnitJustDestroyed, false)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Near end of code, aiBrain[refiOurHighestAirFactoryTech]='..oUnitJustDestroyed:GetAIBrain()[refiOurHighestAirFactoryTech]..'; aiBrain[refiOurHighestLandFactoryTech]='..oUnitJustDestroyed:GetAIBrain()[refiOurHighestLandFactoryTech]..'; aiBrain[refiOurHighestNavalFactoryTech]='..oUnitJustDestroyed:GetAIBrain()[refiOurHighestNavalFactoryTech]..'; aiBrain[refiOurHighestFactoryTechLevel]='..oUnitJustDestroyed:GetAIBrain()[refiOurHighestFactoryTechLevel]) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateMassStorageAdjacencyValues(oStorage, bDestroyed)
    --Updates gross income for the mass storage
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateMassStorageAdjacencyValues'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iMassChange = -(oStorage[refiStorageMassAdjacencyBonus] or 0)
    local aiBrain = oStorage:GetAIBrain()

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Time='..GetGameTimeSeconds()..'; About to update for oStorage='..oStorage.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStorage)..' owned by brain '..aiBrain.Nickname..'; bDestroyed='..tostring(bDestroyed or false)..'; oStorage[refiStorageMassAdjacencyBonus]='..(oStorage[refiStorageMassAdjacencyBonus] or 'nil')..'; aiBrain[refiGrossMassBaseIncome]='..(aiBrain[refiGrossMassBaseIncome] or 'nil')) end
    if not(bDestroyed) then
        oStorage[refiStorageMassAdjacencyBonus] = 0
        if oStorage:GetFractionComplete() >= 1 then
            local iBaseMassGen
            local iAiXMod = 1
            local iAdjacencyMassGen
            local oGenBP
            local iBPMassGen
            local iGenUnitSize
            local iStorageSize = M28UnitInfo.GetBuildingSize(oStorage.UnitId)
            --Adjust for AiX
            if aiBrain.CheatEnabled then
                iAiXMod = tonumber(ScenarioInfo.Options.CheatMult or 1.5)
            end
            oStorage[refiStorageMassAdjacencyBonus] = 0
            --Get all adjacent mexes
            if bDebugMessages == true then LOG(sFunctionRef..': iAiXMod='..iAiXMod..'; Is table of adjacent units empty='..tostring(M28Utilities.IsTableEmpty(oStorage.AdjacentUnits))) end
            if M28Utilities.IsTableEmpty(oStorage.AdjacentUnits) == false then
                --Cant use filterdown a doesnt work with .adjacentunits
                for iMassGenUnit, oMassGenUnit in oStorage.AdjacentUnits do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oMassGenUnit='..oMassGenUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMassGenUnit)..' owned by '..oMassGenUnit:GetAIBrain().Nickname) end
                    if EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryMassFab, oMassGenUnit.UnitId) and oMassGenUnit:GetAIBrain() == aiBrain and M28UnitInfo.IsUnitValid(oMassGenUnit) then --Wont get adjacency unless are on the same team
                        oGenBP = oMassGenUnit:GetBlueprint()
                        iBaseMassGen = (oGenBP.Economy.ProductionPerSecondMass or 0)
                        if iBaseMassGen > 0 then
                            iGenUnitSize = M28UnitInfo.GetBuildingSize(oMassGenUnit.UnitId)
                            --Mass storage adjacency - if covers all of the resource generation on all 4 sides, gives a 50% boost, so is giving 12.5% boost for each side fully covered
                            --Also want to measure in mass per tick not per second, so *0.0125
                            iAdjacencyMassGen = iBaseMassGen * iAiXMod * 0.0125 * math.min(1, iStorageSize / iGenUnitSize)
                            oStorage[refiStorageMassAdjacencyBonus] = oStorage[refiStorageMassAdjacencyBonus] + iAdjacencyMassGen
                            iMassChange = iMassChange + iAdjacencyMassGen
                            if bDebugMessages == true then LOG(sFunctionRef..': Are adjacent to oMassGenUnit='..(oMassGenUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMassGenUnit)..'; iAdjacencyMassGen for this unit='..(iAdjacencyMassGen or 'nil'))) end
                        end
                    end
                end
            end
        end
    end

    aiBrain[refiGrossMassBaseIncome] = (aiBrain[refiGrossMassBaseIncome] or 0) + iMassChange
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iMassChange='..iMassChange..'; aiBrain[refiGrossMassBaseIncome]='..aiBrain[refiGrossMassBaseIncome]) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateGrossIncomeForUnit(oUnit, bDestroyed, bIgnoreEnhancements)
    --Logs are enabled below
    if oUnit.GetAIBrain and EntityCategoryContains(M28UnitInfo.refCategoryResourceUnit + M28UnitInfo.refCategoryMassStorage, oUnit.UnitId) then
        --Does the unit have an M28 aiBrain?
        local aiBrain = oUnit:GetAIBrain()
        if aiBrain.M28AI then
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            local sFunctionRef = 'UpdateGrossIncomeForUnit'
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


            if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..' oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bDestroyed='..tostring(bDestroyed or false)..': Unit aiBrain='..oUnit:GetAIBrain().Nickname..'; Brain recorded for economy='..((oUnit[refoBrainRecordedForEconomy] or {'nil'}).Nickname or 'nil')..'; Fraction complete='..oUnit:GetFractionComplete()) end
            if oUnit:GetFractionComplete() < 1 then M28Utilities.ErrorHandler('Trying to update income for unit whose fraction isnt complete') end

            if (bDestroyed and oUnit[refoBrainRecordedForEconomy] == aiBrain) or (not(bDestroyed) and not(oUnit[refoBrainRecordedForEconomy] == aiBrain)) then
                local iMassGen
                local iEnergyGen
                if EntityCategoryContains(M28UnitInfo.refCategoryParagon, oUnit.UnitId) then
                    iMassGen = 10000
                    iEnergyGen = 1000000
                else
                    local oBP = oUnit:GetBlueprint()
                    iMassGen = math.max(oBP.Economy.ProductionPerSecondMass or 0) * 0.1
                    iEnergyGen = math.max(oBP.Economy.ProductionPerSecondEnergy or 0) * 0.1
                    --Adjust for RAS upgrade
                    if bDebugMessages == true then LOG(sFunctionRef..': Is this an ACU or SACU='..tostring(EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oUnit.UnitId))) end
                    if not(bIgnoreEnhancements) and EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oUnit.UnitId) then
                        local iUpgradeMassPerSec = 0
                        local iUpgradeEnergyPerSec = 0

                        local tPossibleUpgrades = oBP.Enhancements
                        if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; is tPossibleUpgrades empty='..tostring(M28Utilities.IsTableEmpty(tPossibleUpgrades))) end
                        if M28Utilities.IsTableEmpty(tPossibleUpgrades) == false then
                            local tbIncludedUpgrade = {}
                            for sCurUpgrade, tUpgrade in tPossibleUpgrades do
                                if oUnit:HasEnhancement(sCurUpgrade) then
                                    tbIncludedUpgrade[sCurUpgrade] = true
                                    iUpgradeMassPerSec = iUpgradeMassPerSec + (tUpgrade.ProductionPerSecondMass or 0)
                                    iUpgradeEnergyPerSec = iUpgradeEnergyPerSec + (tUpgrade.ProductionPerSecondEnergy or 0)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Unit has enhancement '..sCurUpgrade..'; tUpgrade.ProductionPerSecondMass='..(tUpgrade.ProductionPerSecondMass or 'nil')) end
                                end
                            end


                            --Include built in enhancements (i.e. RAS presets) as there is a delay with onbuilt units showing as having active enhancements
                            if oBP.EnhancementPresetAssigned.Enhancements then
                                for iCurUpgrade, sCurUpgrade in oBP.EnhancementPresetAssigned.Enhancements do
                                    if not(tbIncludedUpgrade[sCurUpgrade]) then
                                        iUpgradeMassPerSec = iUpgradeMassPerSec + (tPossibleUpgrades[sCurUpgrade].ProductionPerSecondMass or 0)
                                        iUpgradeEnergyPerSec = iUpgradeEnergyPerSec + (tPossibleUpgrades[sCurUpgrade].ProductionPerSecondEnergy or 0)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Unit has preset enhancement '..sCurUpgrade..'; tUpgrade.ProductionPerSecondMass='..(tPossibleUpgrades[sCurUpgrade].ProductionPerSecondMass or 'nil')..'; reprs='..reprs(tPossibleUpgrades[sCurUpgrade])) end
                                    end
                                end
                            end
                            --[[local activeEnhancements = SimUnitEnhancements[oUnit.EntityId]
                            if bDebugMessages == true then LOG(sFunctionRef..': Is activeEnhancements nil='..tostring(activeEnhancements == nil)) end
                            if activeEnhancements then
                                local presetEnhancements = oBP.EnhancementPresetAssigned.Enhancements
                                for _, enhName in activeEnhancements do
                                    if not(tbIncludedUpgrade[enhName]) then
                                        tbIncludedUpgrade[enhName] = true
                                        local enh = tPossibleUpgrades[enhName]
                                        iUpgradeMassPerSec = iUpgradeMassPerSec + (enh.ProductionPerSecondMass or 0)
                                        iUpgradeEnergyPerSec = iUpgradeEnergyPerSec + (enh.ProductionPerSecondEnergy or 0)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Unit has preset enhancement '..enhName..'; enh.ProductionPerSecondMass='..(enh.ProductionPerSecondMass or 'nil')) end
                                    end
                                end
                            end--]]
                        end
                        iMassGen = iMassGen + iUpgradeMassPerSec * 0.1
                        iEnergyGen = iEnergyGen + iUpgradeEnergyPerSec * 0.1
                        if bDebugMessages == true then LOG(sFunctionRef..': iUpgradeMassPerSec='..iUpgradeMassPerSec..'; iMassGen per tick='..iMassGen) end
                    end

                    --Mass storage - assume we are adjacent to a T2 mex as a basic approximation
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to check for mass storage, iMassGen='..iMassGen..'; iEnergyGen='..iEnergyGen..'; Does unit contain mass storage='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryMassStorage, oUnit.UnitId))) end
                    if iMassGen == 0 and iEnergyGen == 0 and EntityCategoryContains(M28UnitInfo.refCategoryMassStorage, oUnit.UnitId) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Dealing with mass storage so will update for adjacency value gained or lost') end
                        UpdateMassStorageAdjacencyValues(oUnit, bDestroyed) --Will update mass income values as part of this function
                    elseif iMassGen > 0 then
                        --Update adjacency values for any nearby mass storage
                        local tMexLocation = oUnit:GetPosition()
                        local rSearchRectangle = M28Utilities.GetRectAroundLocation(tMexLocation, 2.749) --If changing this also change M28Events and M28Engineer similar value
                        local tNearbyUnits = GetUnitsInRect(rSearchRectangle) --at 1.5 end up with storage thats not adjacent being gifted in some cases but not in others; at 1 none of it gets gifted; the mass storage should be exactly 2 from the mex; however even at 2.1, 2.25 and 2.499 had cases where the mex wasnt identified so will try 2.75 since distances can vary/be snapped to the nearest 0.5 I think
                        if bDebugMessages == true then LOG(sFunctionRef..': Checking if have any nearby units in a rectangle to this mex/mass fab, is tNearbyUnits empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnits))) end
                        if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                            local tNearbyStorage = EntityCategoryFilterDown(M28UnitInfo.refCategoryMassStorage, tNearbyUnits)
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby storage empty='..tostring(M28Utilities.IsTableEmpty(tNearbyStorage))) end
                            if M28Utilities.IsTableEmpty(tNearbyStorage) == false then
                                for iStorage, oStorage in tNearbyStorage do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have oStorage='..oStorage.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStorage)..'; will update if it is close to here, distance='..M28Utilities.GetDistanceBetweenPositions(oStorage:GetPosition(), tMexLocation)) end
                                    if M28Utilities.GetDistanceBetweenPositions(oStorage:GetPosition(), tMexLocation) <= 2.25 then
                                        --Cant fork thread or else lose the aiBrain info if were just destroyed
                                        UpdateMassStorageAdjacencyValues(oStorage, false)
                                    end
                                end
                            end
                        end
                    end

                    --Adjust for AiX
                    if aiBrain.CheatEnabled then
                        local iAiXMod = tonumber(ScenarioInfo.Options.CheatMult or 1.5)
                        iMassGen = iMassGen * iAiXMod
                        iEnergyGen = iEnergyGen * iAiXMod
                    end
                end
                if bDestroyed then
                    iMassGen = iMassGen * -1
                    iEnergyGen = iEnergyGen * -1
                    oUnit[refoBrainRecordedForEconomy] = nil
                else
                    oUnit[refoBrainRecordedForEconomy] = aiBrain
                    --Set temporary flag that we have just built a lot of power (if we have)
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if should temporarily say we have enough power; iEnergyGen='..iEnergyGen..'; Gross energy='..(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossEnergy] or 'nil')..'; Net energy='..(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamNetEnergy] or 'nil')..'; Flag for lots of power='..tostring(M28Team.tTeamData[aiBrain.M28Team][M28Team.refbJustBuiltLotsOfPower] or false)) end
                    if iEnergyGen >= math.max(20, (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossEnergy] or 0) * 0.15, -(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamNetEnergy] or 0)) and not(M28Team.tTeamData[aiBrain.M28Team][M28Team.refbJustBuiltLotsOfPower]) then
                        M28Team.tTeamData[aiBrain.M28Team][M28Team.refbJustBuiltLotsOfPower] = true
                        M28Utilities.DelayChangeVariable(M28Team.tTeamData[aiBrain.M28Team], M28Team.refbJustBuiltLotsOfPower, false, 6)
                        if bDebugMessages == true then LOG(sFunctionRef..': Just built a lot of power so will temporarily say we dont need more power') end
                    end
                    --Update team eco values to factor in impact of this on any decisions made before the next team eco refresh
                    M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] = (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] or 0) + iMassGen
                    M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamNetMass] = (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamNetMass] or 0) + iMassGen
                    M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossEnergy] = (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossEnergy] or 0) + iEnergyGen
                    M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamNetEnergy] = (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamNetEnergy] or 0) + iEnergyGen
                end
                aiBrain[refiGrossEnergyBaseIncome] = aiBrain[refiGrossEnergyBaseIncome] + iEnergyGen
                aiBrain[refiNetEnergyBaseIncome] = aiBrain[refiNetEnergyBaseIncome] + iEnergyGen
                aiBrain[refiGrossMassBaseIncome] = aiBrain[refiGrossMassBaseIncome] + iMassGen
                aiBrain[refiNetMassBaseIncome] = aiBrain[refiNetMassBaseIncome] + iMassGen

                if iEnergyGen >= 25 then
                    ForkThread(ConsiderReclaimingPower, aiBrain.M28Team, oUnit)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Updated gross and net resources for iMassGen='..iMassGen..'; iEnergyGen='..iEnergyGen..'; aiBrain[refiNetMassBaseIncome]='..aiBrain[refiNetMassBaseIncome]..'; aiBrain[refiGrossMassBaseIncome]='..aiBrain[refiGrossMassBaseIncome]) end
            end


            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        end
    end
end

function RefreshEconomyGrossValues(aiBrain)
    --Updates recorded gross mass and energy for each unit
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshEconomyGrossValues'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tEconomyUnits = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryResourceUnit, false, true)
    if bDebugMessages == true then LOG(sFunctionRef..': refreshing gross income for every unit we own time='..GetGameTimeSeconds()..'; size of tEconomyUnits='..table.getn(tEconomyUnits)) end
    for iUnit, oUnit in tEconomyUnits do
        if oUnit:GetFractionComplete() == 1 then
            UpdateGrossIncomeForUnit(oUnit) --Redundancy
        end
    end

    --Update storage capacity
    GetMassStorageMaximum(aiBrain, true)

    GetEnergyStorageMaximum(aiBrain, true)

end

function RefreshEconomyData(aiBrain)
   local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshEconomyData'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    aiBrain[refiNetEnergyBaseIncome] = math.min(aiBrain[refiGrossEnergyBaseIncome] - aiBrain:GetEconomyRequested('ENERGY'), aiBrain:GetEconomyTrend('ENERGY'))
    aiBrain[refiNetMassBaseIncome] = math.min(aiBrain[refiGrossMassBaseIncome] - aiBrain:GetEconomyRequested('MASS'), aiBrain:GetEconomyTrend('MASS'))

    if bDebugMessages == true then LOG(sFunctionRef..': Finished refreshing economy data, time='..GetGameTimeSeconds()..'; Energy gross='..aiBrain[refiGrossEnergyBaseIncome]..'; Energy net='..aiBrain[refiNetEnergyBaseIncome]..'; Mass gross='..aiBrain[refiGrossMassBaseIncome]..'; Mass net='..aiBrain[refiNetMassBaseIncome]..'; aiBrain:GetEconomyRequested(\'MASS\')='..aiBrain:GetEconomyRequested('MASS')..'; aiBrain:GetEconomyTrend(\'MASS\')='..aiBrain:GetEconomyTrend('MASS')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function EconomyMainLoop(aiBrain)
    local iSlowRefreshCount = 0

    while not(aiBrain.M28IsDefeated) do
        --Slow refresh logic - every 30s update economy values for every unit as redundancy
        if iSlowRefreshCount == 0 then
            ForkThread(RefreshEconomyGrossValues, aiBrain)
        end
        iSlowRefreshCount = iSlowRefreshCount + 1
        if iSlowRefreshCount >= 30 then iSlowRefreshCount = 0 end

        --Frequent refresh logic:
        ForkThread(RefreshEconomyData, aiBrain)
        WaitSeconds(1)
    end
end

function EconomyInitialisation(aiBrain)
    if not(aiBrain[refiGrossEnergyBaseIncome]) then aiBrain[refiGrossEnergyBaseIncome] = 0 end
    if not(aiBrain[refiNetEnergyBaseIncome]) then aiBrain[refiNetEnergyBaseIncome] = 0 end
    if not(aiBrain[refiGrossMassBaseIncome]) then aiBrain[refiGrossMassBaseIncome] = 0 end
    if not(aiBrain[refiNetMassBaseIncome]) then aiBrain[refiNetMassBaseIncome] = 0 end
    aiBrain[reftPausedUnits] = {}

    --Some values are set when creating a team to avoid errors

    ForkThread(EconomyMainLoop, aiBrain)
end

function RecordUnitsOfCategoryToBeReclaimed(iTeam, iCategory)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordUnitsOfCategoryToBeReclaimed'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bAddCurUnit
    local bCheckForExistingUnits
    for iPlateau, tPlateauData in M28Map.tAllPlateaus do
        if M28Utilities.IsTableEmpty(tPlateauData[M28Map.subrefPlateauLandZones]) == false then
            for iLandZone, tLZData in tPlateauData[M28Map.subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if iPlateau-LZ '..iPlateau..'-'..iLandZone..' has units of the category wanted') end
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTAlliedUnits]) == false then
                    if not(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftoUnitsToReclaim]) then
                        bCheckForExistingUnits = false
                        tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftoUnitsToReclaim] = {}
                    else
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftoUnitsToReclaim]) == false then
                            bCheckForExistingUnits = true
                        end
                    end
                    local tUnitsToReclaim = EntityCategoryFilterDown(iCategory, tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTAlliedUnits])
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of untis of category wanted empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToReclaim))) end
                    if M28Utilities.IsTableEmpty(tUnitsToReclaim) == false then
                        for iUnit, oUnit in tUnitsToReclaim do
                            if bDebugMessages == true then LOG(sFunctionRef..': Will add unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of units to be reclaimed unless it is already in the table') end
                            bAddCurUnit = true
                            if bCheckForExistingUnits then
                                for iExistingUnit, oExistingUnit in tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftoUnitsToReclaim] do
                                    if oUnit == oExistingUnit then
                                        bAddCurUnit = false
                                        break
                                    end
                                end
                            end
                            if bAddCurUnit then table.insert(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftoUnitsToReclaim], oUnit) end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshUnitsToReclaim(iTeam, iPlateau, iLandZone)
    --Removes any dead units
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshUnitsToReclaim'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tUnitsToReclaim = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subreftoUnitsToReclaim]
    if bDebugMessages == true then
        LOG(sFunctionRef..': About to remove any dead units from tUnitsToReclaim for iPlateau-iLandZone='..iPlateau..'-'..iLandZone..', is table empty at start='..tostring(M28Utilities.IsTableEmpty(tUnitsToReclaim)))
        if M28Utilities.IsTableEmpty(tUnitsToReclaim) == false then
            LOG(sFunctionRef..': Size of tUnitsToReclaim='..table.getn(tUnitsToReclaim))
        end
    end

    function KeepCurEntry(tArray, iEntry)
        return M28UnitInfo.IsUnitValid(tArray[iEntry])
    end
    M28Utilities.RemoveEntriesFromArrayBasedOnCondition(tUnitsToReclaim, KeepCurEntry)
    if bDebugMessages == true then LOG(sFunctionRef..': Is table empty after removing dead units='..tostring(M28Utilities.IsTableEmpty(tUnitsToReclaim))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckForUnitsToReclaimOfCategory(iTeam, iCategory, sTeamSubrefFlag)
    --Checks if we have any units of iCategory, and if so then checks if we have low enough mass to reclaim them; if we have enough mass then starts a while loop and only aborts once we no longer have any units of the category
    --CheckForUnitsToReclaimOfCategory - e.g. subrefbActiveT2PowerReclaimer
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckForUnitsToReclaimOfCategory'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    M28Team.tTeamData[iTeam][sTeamSubrefFlag] = true
    local bDontCheckForPower = true
    if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryPower, iCategory, false) then bDontCheckForPower = false end
    if bDebugMessages == true then LOG(sFunctionRef..': Checking to see if we have any units to reclaim for the specified category.  bDontCheckForPower='..tostring(bDontCheckForPower)) end
    while M28Team.GetCurrentUnitsOfCategory(iTeam, iCategory) > 0 do
        --Are we low on mass and not low on power?
        if bDebugMessages == true then LOG(sFunctionRef..': Will only add units to be reclaimed if we have low mass, and have power (if checking for power). Has low mass='..tostring(M28Conditions.TeamHasLowMass(iTeam))..'; Have low power='..tostring(M28Conditions.HaveLowPower(iTeam))) end
        if M28Conditions.TeamHasLowMass(iTeam) and (bDontCheckForPower or not(M28Conditions.HaveLowPower(iTeam))) then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            RecordUnitsOfCategoryToBeReclaimed(iTeam, iCategory) --this can sometimes have waitticks in it
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if bDebugMessages == true then LOG(sFunctionRef..': Have added any units to be reclaimed, will stop looping now') end
            break
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    M28Team.tTeamData[iTeam][sTeamSubrefFlag] = false
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderReclaimingPower(iTeam, oPowerJustBuilt)
    --Intended to be called whenever we build a PGen
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderReclaimingPower'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iPowerTechLevel = M28UnitInfo.GetUnitTechLevel(oPowerJustBuilt)
    if bDebugMessages == true then LOG(sFunctionRef..': Just built power='..oPowerJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPowerJustBuilt)..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Do we have active reclaimer logic for T1='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbActiveT1PowerReclaimer] or false)..'; Do we ahve active t2 reclaimer='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbActiveT2PowerReclaimer])) end
    if iPowerTechLevel == 2 then
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 100 and not(M28Team.tTeamData[iTeam][M28Team.subrefbActiveT1PowerReclaimer]) and not(M28Team.tTeamData[iTeam][M28Team.subrefbActiveT2PowerReclaimer]) then
            if bDebugMessages == true then LOG(sFunctionRef..': Will check for t1 power that we can reclaim') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            CheckForUnitsToReclaimOfCategory(iTeam, M28UnitInfo.refCategoryT1Power, M28Team.subrefbActiveT1PowerReclaimer)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    elseif iPowerTechLevel == 3 then
        if not(M28Team.tTeamData[iTeam][M28Team.subrefbActiveT2PowerReclaimer]) then
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 600 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                CheckForUnitsToReclaimOfCategory(iTeam, M28UnitInfo.refCategoryT1Power + M28UnitInfo.refCategoryT2Power, M28Team.subrefbActiveT2PowerReclaimer)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            elseif not(M28Team.tTeamData[iTeam][M28Team.subrefbActiveT1PowerReclaimer]) then
                if bDebugMessages == true then LOG(sFunctionRef..': Built T3 PGen, but sitll low gross energy, Will check for t1 power that we can reclaim') end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                CheckForUnitsToReclaimOfCategory(iTeam, M28UnitInfo.refCategoryT1Power, M28Team.subrefbActiveT1PowerReclaimer)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function GetCategoriesAndActionsToPause(iTeam, bStallingMass, bPauseNotUnpause)
    local tCategoriesByPriority, tEngineerActionsByPriority

    --Are there enemies adjacent to a core base? If so then dont want to pause T2+ air factories except as a near last resort
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        local bImminentThreat = false
        local iPlateauOrZero, iLandOrWaterZone
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
            local tLZOrWZData
            local tLZOrWZTeamData
            if iPlateauOrZero == 0 then
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
            else
                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
            end
            if tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] then
                bImminentThreat = true
                break
            end
        end

        if bStallingMass then
            if not(bImminentThreat) then
                tCategoriesByPriority = { M28UnitInfo.refCategorySMD, M28UnitInfo.refCategoryEngineerStation, iSpecialSurplusUpgradeCategory, M28UnitInfo.refCategoryLandFactory * categories.TECH1, M28UnitInfo.refCategoryLandFactory * categories.TECH2, M28UnitInfo.refCategoryLandFactory * categories.TECH3, M28UnitInfo.refCategoryRASSACU, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategoryAirFactory, M28UnitInfo.refCategoryT2Mex, categories.COMMAND, M28UnitInfo.refCategoryT1Mex, M28UnitInfo.refCategoryTML, iSpecialHQCategory, M28UnitInfo.refCategoryEngineer }

                tEngineerActionsByPriority = { { M28Engineer.refActionBuildQuantumOptics, M28Engineer.refActionBuildHive, M28Engineer.refActionBuildT3Radar, M28Engineer.refActionBuildSecondExperimental, M28Engineer.refActionNavalSpareAction, M28Engineer.refActionBuildT2Sonar, M28Engineer.refActionBuildThirdPower, M28Engineer.refActionBuildSecondAirFactory, M28Engineer.refActionBuildSecondLandFactory, M28Engineer.refActionBuildLandFactory, M28Engineer.refActionSAMCreep, M28Engineer.refActionBuildNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionBuildAirFactory, M28Engineer.refActionBuildT1Sonar, M28Engineer.refActionBuildT2Radar, M28Engineer.refActionBuildT1Radar, M28Engineer.refActionBuildSecondPower, M28Engineer.refActionBuildTML, M28Engineer.refActionBuildEnergyStorage, M28Engineer.refActionBuildAirStaging, M28Engineer.refActionBuildShield, M28Engineer.refActionBuildSecondShield, M28Engineer.refActionBuildExperimental, M28Engineer.refActionAssistAirFactory, M28Engineer.refActionUpgradeBuilding, M28Engineer.refActionBuildPower },
                                               { M28Engineer.refActionFortifyFirebase, M28Engineer.refActionBuildMassStorage, M28Engineer.refActionAssistMexUpgrade, M28Engineer.refActionSpare, M28Engineer.refActionBuildSMD, M28Engineer.refActionBuildEmergencyArti }}

                --Campaign specific - dont pause T1 mex upgrades if we have at least 10 gross mass
                if M28Map.bIsCampaignMap and bPauseNotUnpause and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1 then
                    for iEntry, iCategory in tCategoriesByPriority do
                        if iCategory == M28UnitInfo.refCategoryT1Mex then
                            table.remove(tCategoriesByPriority, iEntry)
                            break
                        end
                    end
                end
            else
                --As above but air fac isnt paused at all and HQs are v.unlikely to be paused
                tCategoriesByPriority = { M28UnitInfo.refCategorySMD, M28UnitInfo.refCategoryEngineerStation, iSpecialSurplusUpgradeCategory, M28UnitInfo.refCategoryLandFactory * categories.TECH1, M28UnitInfo.refCategoryLandFactory * categories.TECH2, M28UnitInfo.refCategoryLandFactory * categories.TECH3, M28UnitInfo.refCategoryRASSACU, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategoryT2Mex, categories.COMMAND, M28UnitInfo.refCategoryT1Mex, M28UnitInfo.refCategoryTML, M28UnitInfo.refCategoryEngineer, iSpecialHQCategory }

                tEngineerActionsByPriority = { { M28Engineer.refActionBuildQuantumOptics, M28Engineer.refActionBuildHive, M28Engineer.refActionBuildT3Radar, M28Engineer.refActionBuildSecondExperimental, M28Engineer.refActionNavalSpareAction, M28Engineer.refActionBuildT2Sonar, M28Engineer.refActionBuildThirdPower, M28Engineer.refActionBuildSecondAirFactory, M28Engineer.refActionBuildSecondLandFactory, M28Engineer.refActionBuildLandFactory, M28Engineer.refActionSAMCreep, M28Engineer.refActionBuildNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionBuildAirFactory, M28Engineer.refActionBuildT1Sonar, M28Engineer.refActionBuildT2Radar, M28Engineer.refActionBuildT1Radar, M28Engineer.refActionBuildSecondPower, M28Engineer.refActionBuildTML, M28Engineer.refActionBuildEnergyStorage, M28Engineer.refActionBuildAirStaging, M28Engineer.refActionBuildShield, M28Engineer.refActionBuildSecondShield, M28Engineer.refActionBuildExperimental, M28Engineer.refActionAssistAirFactory, M28Engineer.refActionUpgradeBuilding, M28Engineer.refActionBuildPower },
                                               { M28Engineer.refActionFortifyFirebase, M28Engineer.refActionBuildMassStorage, M28Engineer.refActionAssistMexUpgrade, M28Engineer.refActionSpare, M28Engineer.refActionBuildSMD, M28Engineer.refActionBuildEmergencyArti }}
            end
        else
            --Power stall
            if not(bImminentThreat) then
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 200 then
                    --Dont pause land facs
                    tCategoriesByPriority = { M28UnitInfo.refCategoryQuantumOptics, M28UnitInfo.refCategorySMD, M28UnitInfo.refCategoryEngineerStation, M28UnitInfo.refCategoryQuantumOptics, iSpecialSurplusUpgradeCategory, M28UnitInfo.refCategoryTML, M28UnitInfo.refCategoryAirFactory, M28UnitInfo.refCategoryRASSACU, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategoryT3Radar, M28UnitInfo.refCategoryT2Mex, M28UnitInfo.refCategoryT1Mex, categories.COMMAND, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategorySML - categories.EXPERIMENTAL, iSpecialHQCategory, M28UnitInfo.refCategoryStealthGenerator, M28UnitInfo.refCategoryStealthAndCloakPersonal, M28UnitInfo.refCategoryRadar, M28UnitInfo.refCategoryPersonalShield, M28UnitInfo.refCategoryFixedShield, M28UnitInfo.refCategoryMobileLandShield, M28UnitInfo.refCategoryEngineer }
                    tEngineerActionsByPriority = { { M28Engineer.refActionBuildQuantumOptics, M28Engineer.refActionBuildHive, M28Engineer.refActionBuildT3Radar, M28Engineer.refActionBuildSecondExperimental, M28Engineer.refActionNavalSpareAction, M28Engineer.refActionBuildT2Sonar, M28Engineer.refActionBuildT1Sonar, M28Engineer.refActionBuildT2Radar, M28Engineer.refActionBuildT1Radar, M28Engineer.refActionBuildExperimental, M28Engineer.refActionBuildTML, M28Engineer.refActionBuildEnergyStorage, M28Engineer.refActionBuildAirStaging, M28Engineer.refActionBuildShield, M28Engineer.refActionBuildSecondShield, M28Engineer.refActionBuildThirdPower, M28Engineer.refActionBuildSecondAirFactory, M28Engineer.refActionBuildAirFactory, M28Engineer.refActionBuildSecondLandFactory, M28Engineer.refActionSAMCreep, M28Engineer.refActionBuildLandFactory, M28Engineer.refActionBuildNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionBuildMassStorage,M28Engineer.refActionAssistMexUpgrade, M28Engineer.refActionUpgradeBuilding },
                                                   { M28Engineer.refActionAssistAirFactory, M28Engineer.refActionSpare, M28Engineer.refActionBuildSecondPower, M28Engineer.refActionFortifyFirebase },
                                                   { M28Engineer.refActionBuildSMD, M28Engineer.refActionBuildEmergencyArti } }
                else
                    tCategoriesByPriority = { M28UnitInfo.refCategoryQuantumOptics, M28UnitInfo.refCategorySMD, M28UnitInfo.refCategoryEngineerStation, M28UnitInfo.refCategoryQuantumOptics, iSpecialSurplusUpgradeCategory, M28UnitInfo.refCategoryTML, M28UnitInfo.refCategoryAirFactory, M28UnitInfo.refCategoryRASSACU, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategoryT3Radar, M28UnitInfo.refCategoryT2Mex, M28UnitInfo.refCategoryT1Mex, categories.COMMAND, M28UnitInfo.refCategoryLandFactory * categories.TECH1, M28UnitInfo.refCategoryLandFactory * categories.TECH2, M28UnitInfo.refCategoryLandFactory * categories.TECH3, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategorySML - categories.EXPERIMENTAL, iSpecialHQCategory, M28UnitInfo.refCategoryStealthGenerator, M28UnitInfo.refCategoryStealthAndCloakPersonal, M28UnitInfo.refCategoryRadar, M28UnitInfo.refCategoryPersonalShield, M28UnitInfo.refCategoryFixedShield, M28UnitInfo.refCategoryMobileLandShield, M28UnitInfo.refCategoryEngineer }
                    tEngineerActionsByPriority = { { M28Engineer.refActionBuildQuantumOptics, M28Engineer.refActionBuildHive, M28Engineer.refActionBuildT3Radar, M28Engineer.refActionBuildSecondExperimental, M28Engineer.refActionNavalSpareAction, M28Engineer.refActionBuildT2Sonar, M28Engineer.refActionBuildT1Sonar, M28Engineer.refActionBuildT2Radar, M28Engineer.refActionBuildT1Radar, M28Engineer.refActionBuildExperimental, M28Engineer.refActionBuildTML, M28Engineer.refActionBuildEnergyStorage, M28Engineer.refActionBuildAirStaging, M28Engineer.refActionBuildShield, M28Engineer.refActionBuildSecondShield, M28Engineer.refActionBuildThirdPower, M28Engineer.refActionBuildSecondAirFactory, M28Engineer.refActionBuildAirFactory, M28Engineer.refActionBuildSecondLandFactory, M28Engineer.refActionSAMCreep, M28Engineer.refActionBuildLandFactory, M28Engineer.refActionBuildNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionBuildMassStorage,M28Engineer.refActionAssistMexUpgrade, M28Engineer.refActionUpgradeBuilding },
                                                   { M28Engineer.refActionAssistAirFactory, M28Engineer.refActionSpare, M28Engineer.refActionBuildSecondPower, M28Engineer.refActionFortifyFirebase },
                                                   { M28Engineer.refActionBuildSMD, M28Engineer.refActionBuildEmergencyArti } }
                end
            else
                --As above but air fac paused as lower priority and no land factory pausing
                tCategoriesByPriority = { M28UnitInfo.refCategoryQuantumOptics, M28UnitInfo.refCategorySMD, M28UnitInfo.refCategoryEngineerStation, M28UnitInfo.refCategoryQuantumOptics, iSpecialSurplusUpgradeCategory, M28UnitInfo.refCategoryTML, M28UnitInfo.refCategoryRASSACU, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategoryAirFactory, M28UnitInfo.refCategoryT3Radar, M28UnitInfo.refCategoryT2Mex, M28UnitInfo.refCategoryT1Mex, categories.COMMAND, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategorySML - categories.EXPERIMENTAL, iSpecialHQCategory, M28UnitInfo.refCategoryStealthGenerator, M28UnitInfo.refCategoryStealthAndCloakPersonal, M28UnitInfo.refCategoryRadar, M28UnitInfo.refCategoryPersonalShield, M28UnitInfo.refCategoryFixedShield, M28UnitInfo.refCategoryMobileLandShield, M28UnitInfo.refCategoryEngineer }
                tEngineerActionsByPriority = { { M28Engineer.refActionBuildQuantumOptics, M28Engineer.refActionBuildHive, M28Engineer.refActionBuildT3Radar, M28Engineer.refActionBuildSecondExperimental, M28Engineer.refActionNavalSpareAction, M28Engineer.refActionBuildT2Sonar, M28Engineer.refActionBuildT1Sonar, M28Engineer.refActionBuildT2Radar, M28Engineer.refActionBuildT1Radar, M28Engineer.refActionBuildExperimental, M28Engineer.refActionBuildTML, M28Engineer.refActionBuildEnergyStorage, M28Engineer.refActionBuildAirStaging, M28Engineer.refActionBuildShield, M28Engineer.refActionBuildSecondShield, M28Engineer.refActionBuildThirdPower, M28Engineer.refActionBuildSecondAirFactory, M28Engineer.refActionBuildAirFactory, M28Engineer.refActionBuildSecondLandFactory, M28Engineer.refActionSAMCreep, M28Engineer.refActionBuildLandFactory, M28Engineer.refActionBuildNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionBuildMassStorage,M28Engineer.refActionAssistMexUpgrade, M28Engineer.refActionUpgradeBuilding },
                                               { M28Engineer.refActionAssistAirFactory, M28Engineer.refActionSpare, M28Engineer.refActionBuildSecondPower, M28Engineer.refActionFortifyFirebase },
                                               { M28Engineer.refActionBuildSMD, M28Engineer.refActionBuildEmergencyArti } }

            end
        end

        return tCategoriesByPriority, tEngineerActionsByPriority
    else
        M28Utilities.ErrorHandler('No active M28 brains')
    end
end

function ManageMassStalls(iTeam)
    --For now focus is on if we are trying to build a missile for an SML, or we are massively mass stalling
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMassStalls'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start at time'..GetGameTimeSeconds()..'; Is table of active M28 brains empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then

        local bPauseNotUnpause = true
        local bChangeRequired = false
        local iUnitsAdjusted = 0
        local iMassStallPercentAdjust = 0
        if M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] then iMassStallPercentAdjust = 0.02 end
        --Dont consider pausing or unpausing if are stalling energy or early game, as our energy stall manager is likely to be operating
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, GetGameTimeSeconds='..GetGameTimeSeconds()..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Team stalling mass already='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass])..'; Team stalling energy='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])) end
        if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] or (GetGameTimeSeconds() >= 120 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 3 and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or -100) >= 10 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] >= 0.99) then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': About to consider if we have a mass stall or not. Team lowest mass percent stored=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] .. '; M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] .. '; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]))
            end
            --First consider unpausing
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': If we have flagged that we are stalling mass then will check if we have enough to start unpausing things. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; iMassStallPercentAdjust='..iMassStallPercentAdjust)
            end

            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > (0.005 + iMassStallPercentAdjust) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 2000 then
                --aiBrain[refbStallingEnergy] = false
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Have enough mass stored or income to start unpausing things')
                end
                bPauseNotUnpause = false
                if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] then bChangeRequired = true end
            end
            if bDebugMessages == true then LOG(sFunctionRef .. ': Checking if we shoudl flag that we are mass stalling. bChangeRequired='..tostring(bChangeRequired)..'; Mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Need resources for missile='..tostring((M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] or false))..'; Gross mass income='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]) end
            --Check if should manage mass stall
            if bChangeRequired == false and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= (0.001 + iMassStallPercentAdjust) and (M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] < -1 and (-M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] / M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 0.2))) then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': We are stalling mass, will look for units to pause')
                end
                bChangeRequired = true
                bPauseNotUnpause = true
                M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] = true
                M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] = GetGameTimeSeconds()
            end

            if bDebugMessages == true then LOG(sFunctionRef..': bChangeRequired='..tostring(bChangeRequired)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)) end

            if bChangeRequired then
                --Decide on order to pause/unpause

                local tCategoriesByPriority, tEngineerActionsByPriority = GetCategoriesAndActionsToPause(iTeam, true, bPauseNotUnpause)

                local iMassPerTickSavingNeeded
                if bPauseNotUnpause then
                    if M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] then iMassPerTickSavingNeeded = math.max(1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass])
                    else
                        iMassPerTickSavingNeeded = math.max(1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] * 0.8)
                    end
                else
                    if M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] then iMassPerTickSavingNeeded = math.min(-1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass], -M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] / 30)
                    else
                        iMassPerTickSavingNeeded = math.min(-1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] * 1.2, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] / 20)
                    end
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.15 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 4000 then
                        iMassPerTickSavingNeeded = iMassPerTickSavingNeeded * 1.2 - 0.5
                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 4000 then iMassPerTickSavingNeeded = iMassPerTickSavingNeeded - 1 end
                    end
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 2000 then iMassPerTickSavingNeeded = iMassPerTickSavingNeeded - 1 end
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to unpause units, iMassPerTickSavingNeeded (negative means unpausing units)='..iMassPerTickSavingNeeded) end
                end

                local iMassSavingManaged = 0
                local iEngineerSubtableCount = 0
                local tEngineerActionSubtable
                local tRelevantUnits, oUnit

                local bAbort = false
                local iTotalUnits = 0
                local iCategoryStartPoint, iIntervalChange, iCategoryEndPoint, iCategoryRef
                local bWasUnitAlreadyPaused
                local bConsiderReclaimingEngineer = false
                local iKillCount = 0
                local iCurPlateau, iCurLandZone
                local bPausedUnitsTableIsEmptyForAllBrains = true
                local iBuildRateMod

                if bPauseNotUnpause then
                    iCategoryStartPoint = 1
                    iIntervalChange = 1
                    iCategoryEndPoint = table.getn(tCategoriesByPriority)
                    if GetGameTimeSeconds() - M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEngiSelfDestruct] > 0.99 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                        local iEngiCategoryWanted
                        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer * categories.TECH3
                        elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 2 then iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer - categories.TECH1
                        else iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer
                        end
                        local iCurEngis = 0
                        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                            iCurEngis = iCurEngis + oBrain:GetCurrentUnits(iEngiCategoryWanted)
                        end

                        if iCurEngis >= 10 then
                            --If are defending against arti then want a lot more engineers before start considering ctrl-king any
                            if not(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) or iCurEngis >= 70 then
                                bConsiderReclaimingEngineer = true
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Time of last engi self destruct='..M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEngiSelfDestruct]..'; bConsiderReclaimingEngineer='..tostring(bConsiderReclaimingEngineer)) end
                else
                    iCategoryStartPoint = table.getn(tCategoriesByPriority)
                    iIntervalChange = -1
                    iCategoryEndPoint = 1
                end

                local bConsideringHQ
                local bConsideringTeamWideUnits = false
                local bNoRelevantUnits = true

                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': About to cycle through every category, bPauseNotUnpause=' .. tostring(bPauseNotUnpause) .. '; iCategoryStartPoint=' .. iCategoryStartPoint .. '; iCategoryEndPoint=' .. iCategoryEndPoint)
                end
                for iCategoryCount = iCategoryStartPoint, iCategoryEndPoint, iIntervalChange do
                    iCategoryRef = tCategoriesByPriority[iCategoryCount]

                    --Are we considering upgrading factory HQs?
                    if iCategoryRef == iSpecialHQCategory then
                        iCategoryRef = M28UnitInfo.refCategoryAllHQFactories
                        bConsideringHQ = true
                        bConsideringTeamWideUnits = false
                    else
                        if iCategoryRef == iSpecialSurplusUpgradeCategory then
                            bConsideringTeamWideUnits = true
                        else
                            bConsideringTeamWideUnits = false
                        end
                        bConsideringHQ = false
                    end

                    local iCurUnitMassUsage
                    local bApplyActionToUnit
                    local oBP
                    local oFocusUnitBP
                    local bFirstEngiCategoryRefBrain = true

                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        if oBrain.CheatEnabled then iBuildRateMod = M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier]
                        else iBuildRateMod = 1
                        end

                        if iCategoryRef == iSpecialSurplusUpgradeCategory then
                            --Pause all but 1 upgrade per brain, pausing the lowest progress first, if we have multiple upgrades
                            tRelevantUnits = {}
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[oBrain.M28Team][M28Team.subreftTeamUpgradingMexes]) == false then
                                local iMexesToPause = math.max(0, table.getn(M28Team.tTeamData[oBrain.M28Team][M28Team.subreftTeamUpgradingMexes]) - M28Team.tTeamData[oBrain.M28Team][M28Team.subrefiActiveM28BrainCount])
                                while iMexesToPause > 0 do
                                    local iLowestProgress = 1
                                    local oLowestProgress
                                    local bAlreadyIncluded
                                    for iUnit, oUnit in M28Team.tTeamData[oBrain.M28Team][M28Team.subreftTeamUpgradingMexes] do
                                        if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetWorkProgress() < iLowestProgress then
                                            bAlreadyIncluded = false
                                            --Is the unit already in the table of relevant units?
                                            if M28Utilities.IsTableEmpty(tRelevantUnits) == false then
                                                for iRecordedUnit, oRecordedUnit in tRelevantUnits do
                                                    if oRecordedUnit == oUnit then bAlreadyIncluded = true break end
                                                end
                                            end
                                            if not(bAlreadyIncluded) then
                                                oLowestProgress = oUnit
                                                iLowestProgress = oUnit:GetWorkProgress()
                                            end
                                        end
                                    end
                                    table.insert(tRelevantUnits, oLowestProgress)
                                    iMexesToPause = iMexesToPause - 1
                                end
                            end
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[oBrain.M28Team][M28Team.subreftTeamUpgradingOther]) == false then
                                for iUnit, oUnit in M28Team.tTeamData[oBrain.M28Team][M28Team.subreftTeamUpgradingOther] do
                                    table.insert(tRelevantUnits, oUnit)
                                end
                            end
                        else
                            if bPauseNotUnpause then
                                tRelevantUnits = oBrain:GetListOfUnits(iCategoryRef, false, true)
                            else
                                tRelevantUnits = EntityCategoryFilterDown(iCategoryRef, oBrain[reftPausedUnits])
                            end
                        end


                        if M28Utilities.IsTableEmpty(tRelevantUnits) == false then
                            bNoRelevantUnits = false
                            iTotalUnits = table.getn(tRelevantUnits)
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': iCategoryCount=' .. iCategoryCount .. '; iTotalUnits=' .. iTotalUnits .. '; bPauseNotUnpause=' .. tostring(bPauseNotUnpause))
                            end
                            if iCategoryRef == M28UnitInfo.refCategoryEngineer then
                                if bFirstEngiCategoryRefBrain then
                                    iEngineerSubtableCount = iEngineerSubtableCount + 1
                                    bFirstEngiCategoryRefBrain = false
                                end
                                tEngineerActionSubtable = tEngineerActionsByPriority[iEngineerSubtableCount]
                            end
                            for iUnit = iTotalUnits, 1, -1 do
                                oUnit = tRelevantUnits[iUnit]
                                --for iUnit, oUnit in tRelevantUnits do
                                bApplyActionToUnit = false
                                iCurUnitMassUsage = 0
                                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then --Only consider unit if it has been constructed
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': About to consider pausing/unpausingunit ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. '; will first check category specific logic for if we want to go ahead with pausing4')
                                    end


                                    --Do we actually want to pause the unit? check any category specific logic
                                    bApplyActionToUnit = true
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': UnitState=' .. M28UnitInfo.GetUnitState(oUnit) .. '; Is ActiveHQUpgrades Empty=' .. tostring(M28Utilities.IsTableEmpty(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]))))
                                    end
                                    --Factories, ACU and engineers - dont pause if >=85% done, or if is land factory that hasn't built many units (so e.g. if have just placed a land factory on a core expansion we dont immediately pause it)
                                    if bPauseNotUnpause and oUnit.GetWorkProgress and EntityCategoryContains(M28UnitInfo.refCategoryEngineer + categories.COMMAND + M28UnitInfo.refCategoryFactory, oUnit.UnitId) and ((oUnit:GetWorkProgress() or 0) >= 0.85 or (EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) and (oUnit[M28Factory.refiTotalBuildCount] or 0) <= 5)) then
                                        bApplyActionToUnit = false
                                        --Air HQ - dont pause first ever unit or transport
                                    elseif bPauseNotUnpause and EntityCategoryContains(M28UnitInfo.refCategoryAirHQ, oUnit.UnitId) and (oUnit[M28Factory.refiTotalBuildCount] == 0 or EntityCategoryContains(M28UnitInfo.refCategoryTransport, (oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] or 'ueb1105'))) then
                                        bApplyActionToUnit = false
                                    elseif bPauseNotUnpause and EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) and oUnit[M28Factory.refiTotalBuildCount] <= 10 then
                                        --Is this on a dif island to closest enemy base?
                                        local tUnitLZData, tUnitLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                        if tUnitLZTeamData and not(NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition()) == NavUtils.GetLabel(M28Map.refPathingTypeLand, tUnitLZTeamData[M28Map.reftClosestEnemyBase])) then
                                            bApplyActionToUnit = true
                                        end
                                        --SMD LOGIC - Check if already have 1 missile loaded before pausing
                                    elseif iCategoryRef == M28UnitInfo.refCategorySMD and oUnit.GetTacticalSiloAmmoCount and oUnit:GetTacticalSiloAmmoCount() >= 1 then
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Have SMD with at least 1 missile so will pause it')
                                        end
                                        bApplyActionToUnit = false
                                    elseif iCategoryRef == M28UnitInfo.refCategoryEngineer then
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Have an engineer with action=' .. (oUnit[M28Engineer.refiAssignedAction] or 'nil') .. '; tEngineerActionSubtable=' .. repru(tEngineerActionSubtable))
                                        end
                                        bApplyActionToUnit = false
                                        if not(bPauseNotUnpause) or not(oUnit:IsUnitState('Attached')) then
                                            for iActionCount, iActionRef in tEngineerActionSubtable do
                                                if iActionRef == oUnit[M28Engineer.refiAssignedAction] then
                                                    bApplyActionToUnit = true
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Have an action match, iActionRef='..iActionRef..'; will apply action to unitunless have an override such as priamry power builder, oUnit[M28Engineer.refbPrimaryBuilder]='..tostring(oUnit[M28Engineer.refbPrimaryBuilder])) end
                                                    --Dont pause the last engi building power, and also dont pause if are building PD/T2 Arti/Shield/Experimental and have a fraction complete of at least 70%
                                                    if bPauseNotUnpause and (iActionRef == M28Engineer.refActionBuildPower or iActionRef == M28Engineer.refActionBuildSecondPower) and oUnit[M28Engineer.refbPrimaryBuilder] then
                                                        bApplyActionToUnit = false
                                                    elseif bPauseNotUnpause and oUnit.GetFocusUnit then
                                                        local oFocusUnit = oUnit:GetFocusUnit()
                                                        if bDebugMessages == true then
                                                            if M28UnitInfo.IsUnitValid(oFocusUnit) then
                                                                LOG(sFunctionRef..': Considering engineer '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; UC='..M28Engineer.GetEngineerUniqueCount(oUnit)..'; Focus unit='..oFocusUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFocusUnit)..'; Fraction complete='..oFocusUnit:GetFractionComplete())
                                                            else LOG(sFunctionRef..': Focus unit for engineer '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; UC='..M28Engineer.GetEngineerUniqueCount(oUnit)..' isnt valid') end
                                                        end
                                                        if M28UnitInfo.IsUnitValid(oFocusUnit) and oFocusUnit:GetFractionComplete() >= 0.7 and oFocusUnit:GetFractionComplete() < 1 then
                                                            if EntityCategoryContains(M28UnitInfo.refCategoryPD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryExperimentalLevel, oFocusUnit.UnitId) then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Wont apply action to unit as it is PD/Arti/Experimental') end
                                                                bApplyActionToUnit = false
                                                            elseif bDebugMessages == true then LOG(sFunctionRef..': Will apply action to focus unit as it isnt PD/Experimental level')
                                                            end
                                                        end
                                                    end
                                                    if bApplyActionToUnit and bConsiderReclaimingEngineer and not(oUnit[M28Engineer.refbPrimaryBuilder]) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), M28Map.PlayerStartPoints[oBrain:GetArmyIndex()]) <= 90 then
                                                        --Is there reclaim near the engineer? If so clear its orders and have it reclaim, otherwise kill it
                                                        local oBP = oUnit:GetBlueprint()
                                                        if oBP.Economy.BuildCostMass < 500 and oBP.Economy.MaxBuildDistance then --redundancy so we dont ctrl-K SACUs or a unit with no build radius
                                                            bApplyActionToUnit = false


                                                            function KillEngineer(oUnit)
                                                                if bDebugMessages == true then LOG(sFunctionRef..': About to kill engineer '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                                                M28Orders.IssueTrackedKillUnit(oUnit)
                                                                iKillCount = iKillCount + 1
                                                                if iKillCount >= 2 then
                                                                    bConsiderReclaimingEngineer = false
                                                                end
                                                                M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEngiSelfDestruct] = GetGameTimeSeconds()
                                                            end
                                                            iCurPlateau, iCurLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                                                            if (iCurPlateau or 0) > 0 and (iCurLandZone or 0) > 0 then
                                                                if M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefTotalMassReclaim] > 30 then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': About to tell unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to reclaim nearby area due to mass stall') end
                                                                    M28Engineer.GetEngineerToReclaimNearbyArea(oUnit, 1, M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefLZTeamData][iTeam], iCurPlateau, iCurLandZone, false, true)
                                                                    --Kill engineers if htey are in a core LZ
                                                                elseif M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] then
                                                                    KillEngineer(oUnit)
                                                                end
                                                            end
                                                        end
                                                    end
                                                    break
                                                end
                                            end
                                        end
                                    elseif iCategoryRef == M28UnitInfo.refCategoryPersonalShield or iCategoryRef == M28UnitInfo.refCategoryFixedShield or iCategoryRef == M28UnitInfo.refCategoryMobileLandShield then
                                        --Mass stalling so pausing shield not expected to do anything
                                        if bPauseNotUnpause then bApplyActionToUnit = false end
                                    elseif not(bPauseNotUnpause) and (oUnit.GetTacticalSiloAmmoCount or oUnit.GetTacticalSiloAmmoCount) and M28UnitInfo.GetMissileCount(oUnit) >= 2 then
                                        --Dont unpause TML, SML and SMD that have 2+ missiles loaded already
                                        bApplyActionToUnit = false
                                    elseif bPauseNotUnpause and iCategoryRef == M28UnitInfo.refCategoryTML and M28UnitInfo.GetMissileCount(oUnit) == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1.2 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Dealing with TML that has no missile so dont want to pause it') end
                                        bApplyActionToUnit = false
                                    end



                                    if iCategoryRef == categories.COMMAND then
                                    --want in addition to above as ACU might have personal shield
                                    if bPauseNotUnpause then
                                    if oUnit:IsUnitState('Upgrading') then
                                    bApplyActionToUnit = false
                                    elseif oUnit.GetWorkProgress then
                                    --if oUnit:GetWorkProgress() >= 0.85 then
                                    bApplyActionToUnit = false
                                    --dont pause t1 mex construction
                                    if oUnit.GetFocusUnit and oUnit:GetFocusUnit() and oUnit:GetFocusUnit().UnitId and EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oUnit:GetFocusUnit().UnitId) then
                                    bApplyActionToUnit = false
                                    end
                                    end
                                    end
                                    end


                                    --Pause the unit

                                    if bApplyActionToUnit then
                                    bWasUnitAlreadyPaused = oUnit[M28UnitInfo.refbPaused] --Means we will ignore the mass usage when calculating how much we have saved
                                    oBP = oUnit:GetBlueprint()
                                    iCurUnitMassUsage = oBP.Economy.MaintenanceConsumptionPerSecondMass

                                    if (iCurUnitMassUsage or 0) == 0 or EntityCategoryContains(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryMex + categories.COMMAND, oUnit.UnitId) then
                                    --Approximate mass usage based on build rate as a very rough guide
                                    --examples: Upgrading mex to T3 costs 11E per BP; T3 power is 8.4; T1 power is 6; Guncom is 30; Laser is 178; Strat bomber is 15
                                    local iMassPerBP = 0.25 --e.g. building t1 land factory uses 4; building a titan uses 1.1; divide by 10 as dealing with values per tick
                                    if EntityCategoryContains(categories.SILO, oUnit.UnitId) and oBP.Economy.BuildRate then
                                    --Dealing with a silo so need to calculate mass usage differently
                                    iCurUnitMassUsage = 0
                                    for iWeapon, tWeapon in oBP.Weapon do
                                    if tWeapon.MaxProjectileStorage and tWeapon.ProjectileId then
                                    local oProjectileBP = __blueprints[tWeapon.ProjectileId]
                                    if oProjectileBP.Economy and oProjectileBP.Economy.BuildCostMass and oProjectileBP.Economy.BuildTime > 0 and oBP.Economy.BuildRate > 0 then
                                    iCurUnitMassUsage = oProjectileBP.Economy.BuildCostMass * oBP.Economy.BuildRate * iBuildRateMod / oProjectileBP.Economy.BuildTime
                                    --If are power stalling then assume we only save 80% of this, as might have adjacency
                                    if bPauseNotUnpause then iCurUnitMassUsage = iCurUnitMassUsage * 0.8 end
                                    break
                                    end
                                    end
                                    end
                                    else
                                    if iCategoryRef == categories.COMMAND and oUnit[M28Orders.refiOrderCount] > 0 and oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] == M28Orders.refiOrderEnhancement then
                                    --Determine mass cost per BP
                                    local sUpgradeRef = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint]
                                    if bDebugMessages == true then LOG(sFunctionRef..': aiBrain='..oUnit:GetAIBrain():GetArmyIndex()..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; sUpgradeRef='..(sUpgradeRef or 'nil')..'; Upgrade mass cost='..(M28UnitInfo.GetUpgradeMassCost(oUnit, sUpgradeRef) or 'nil')..'; Upgrade build time='..(M28UnitInfo.GetUpgradeBuildTime(oUnit, sUpgradeRef) or 'nil')) end
                                    iMassPerBP = M28UnitInfo.GetUpgradeMassCost(oUnit, sUpgradeRef) / (M28UnitInfo.GetUpgradeBuildTime(oUnit, sUpgradeRef) or 1)
                                    end

                                    if oBP.Economy.BuildRate then
                                    --Reduce this massively if unit isn't actually building anything
                                    if bPauseNotUnpause then
                                    if (not(oUnit:IsUnitState('Building')) and not(oUnit:IsUnitState('Repairing')) and not(oUnit.GetWorkProgress and oUnit:GetWorkProgress() > 0) and not(oUnit:IsUnitState('Upgrading'))) then
                                    iCurUnitMassUsage = oBP.Economy.BuildRate * iBuildRateMod * 0.01
                                        else
                                        if M28UnitInfo.IsUnitValid(oUnit:GetFocusUnit()) then
                                        oFocusUnitBP = oUnit:GetFocusUnit():GetBlueprint()
                                        iCurUnitMassUsage = oBP.Economy.BuildRate * iBuildRateMod / oFocusUnitBP.Economy.BuildTime * oFocusUnitBP.Economy.BuildCostMass
                                        oUnit[refiLastMassUsage] = iCurUnitMassUsage
                                        if bDebugMessages == true then LOG(sFunctionRef..': Setting unit last mass usage to '..oUnit[refiLastMassUsage]..'; Build rate='..oBP.Economy.BuildRate..'; Focus unit build time='..oFocusUnitBP.Economy.BuildTime..'; Focus unit build cost mass='..oFocusUnitBP.Economy.BuildCostMass..'; Build rate mod='..iBuildRateMod) end
                                        else
                                        iCurUnitMassUsage = oBP.Economy.BuildRate * iBuildRateMod *  iMassPerBP
                                    end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Checking for what the unit is building or upgrading to get more accurate calculation, unit state='..M28UnitInfo.GetUnitState(oUnit)..'; mass usage after check='..iCurUnitMassUsage..'; Is focus unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit:GetFocusUnit()))) end
                                    else
                                    iCurUnitMassUsage = (oUnit[refiLastMassUsage] or oBP.Economy.BuildRate * iBuildRateMod * iMassPerBP)
                                    end
                                    end
                                    end
                                    end
                                    --We're working in ticks so adjust mass usage accordingly
                                    iCurUnitMassUsage = iCurUnitMassUsage * 0.1
                                    if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': Estimated mass usage=' .. iCurUnitMassUsage..'; About to call the function PauseOrUnpauseMassUsage on unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; iUnitsAdjusted before counting this unit='..iUnitsAdjusted)
                                    end

                                    if not((iCurUnitMassUsage or 0) == 0) then iUnitsAdjusted = iUnitsAdjusted + 1 end
                                    M28UnitInfo.PauseOrUnpauseMassUsage(oUnit, bPauseNotUnpause)
                                        --Cant move the below into unitinfo as get a crash if unitinfo tries to refernce the table of paused units
                                        --Have made localised variable which looks to fix the issue
                                        end
                                end
                                if bApplyActionToUnit then
                                    if bPauseNotUnpause and not(bWasUnitAlreadyPaused) then
                                        iMassSavingManaged = iMassSavingManaged + iCurUnitMassUsage
                                    elseif bWasUnitAlreadyPaused and not (bPauseNotUnpause) then
                                        iMassSavingManaged = iMassSavingManaged - iCurUnitMassUsage
                                    end
                                end
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': iMassSavingManaged=' .. iMassSavingManaged .. '; iMassPerTickSavingNeeded=' .. iMassPerTickSavingNeeded .. '; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass])..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; bWasUnitAlreadyPaused='..tostring(bWasUnitAlreadyPaused)..'; bApplyActionToUnit='..tostring(bApplyActionToUnit)..'; iCurUnitMassUsage='..iCurUnitMassUsage)
                                end

                                if bPauseNotUnpause then
                                    if iMassSavingManaged > iMassPerTickSavingNeeded then
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Estimate we have saved ' .. iMassSavingManaged .. ' which is more tahn we wanted so will pause')
                                        end
                                        bAbort = true
                                        break
                                    end
                                else
                                    if iMassSavingManaged < iMassPerTickSavingNeeded then
                                        bAbort = true
                                        break
                                    end
                                end
                            end
                        elseif bDebugMessages == true then
                            LOG(sFunctionRef .. ': We have no units for iCategoryCount=' .. iCategoryCount)
                        end

                        if bPausedUnitsTableIsEmptyForAllBrains and M28Utilities.IsTableEmpty(oBrain[reftPausedUnits]) == false then
                            bPausedUnitsTableIsEmptyForAllBrains = false
                        end

                        if bAbort then
                            break
                        end
                        if bConsideringTeamWideUnits then break end --dont want to consider for more than one brain
                    end
                    if bAbort then
                        break
                    end
                end
                if bDebugMessages == true then
                    LOG(sFunctionRef .. 'If we have no paused units then will set us as not having a mass stall')
                end
                if bPausedUnitsTableIsEmptyForAllBrains then
                    M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] = false
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': We are no longer stalling mass')
                    end
                else
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': About to check if we wanted to unpause units but havent unpaused anything; iUnitsAdjusted=' .. iUnitsAdjusted .. '; bNoRelevantUnits=' .. tostring(bNoRelevantUnits) .. '; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]))
                    end
                    --Backup - sometimes we still have units in the table listed as being paused (e.g. if an engineer changes action to one that isnt listed as needing pausing) - unpause them if we couldnt find via category search
                    if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] and not (bPauseNotUnpause) and (iMassSavingManaged > iMassPerTickSavingNeeded or iUnitsAdjusted == 0 or bNoRelevantUnits) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.03 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] >= 0.9 then
                        --Have a decent amount of mass, are flagged as stalling mass, but couldnt find any categories to unpause
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': werent able to find any units to unpause with normal approach so will unpause all remaining units')
                        end
                        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                            local iLoopCountCheck = 0
                            local iMaxLoop = math.max(20, table.getn(oBrain[reftPausedUnits]) + 1)
                            while M28Utilities.IsTableEmpty(oBrain[reftPausedUnits]) == false do
                                iLoopCountCheck = iLoopCountCheck + 1
                                if iLoopCountCheck >= iMaxLoop then
                                    M28Utilities.ErrorHandler('Infinite loop likely')
                                    break
                                end
                                if M28Utilities.IsTableEmpty(oBrain[reftPausedUnits]) == false then
                                    for iUnit, oUnit in oBrain[reftPausedUnits] do
                                        if bDebugMessages == true then
                                            if M28UnitInfo.IsUnitValid(oUnit) then
                                                LOG(sFunctionRef .. ': About to unpause ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit))
                                            else
                                                LOG('Removing iUnit=' .. iUnit .. ' which is no longer valid')
                                            end
                                            LOG('Size of oBrain[reftPausedUnits] before removal=' .. table.getn(oBrain[reftPausedUnits]) .. '; will double check this size')
                                            local iActualSize = 0
                                            for iAltUnit, oAltUnit in oBrain[reftPausedUnits] do
                                                iActualSize = iActualSize + 1
                                            end
                                            LOG('Actual size=' .. iActualSize)
                                        end
                                        if M28UnitInfo.IsUnitValid(oUnit) then
                                            M28UnitInfo.PauseOrUnpauseMassUsage(oUnit, false)
                                        end
                                        table.remove(oBrain[reftPausedUnits], iUnit)
                                        break
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': FInished unpausing units')
                        end
                    end
                end
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': End of code, M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) .. '; Stalling energy='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; bPauseNotUnpause=' .. tostring(bPauseNotUnpause) .. '; iUnitsAdjusted=' .. iUnitsAdjusted .. '; Game time=' .. GetGameTimeSeconds() .. '; Mass stored %=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] .. '; Net mass income=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] .. '; gross mass income=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass])
            end
        end
    else
        M28Utilities.ErrorHandler('No active M28 brains')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageEnergyStalls(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageEnergyStalls'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then

        local bPauseNotUnpause = true
        local bChangeRequired = false
        local iUnitsAdjusted = 0
        local bHaveWeCappedUnpauseAmount = false
        if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] or (GetGameTimeSeconds() >= 120 or (GetGameTimeSeconds() >= 40 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 15)) then
            --Only consider power stall management after 2m, otherwise risk pausing things such as early microbots when we would probably be ok after a couple of seconds; lower time limit put in as a theroetical possibility due to AIX
            if bDebugMessages == true then LOG(sFunctionRef .. ': About to consider if we have an energy stall or not. Lowest energy % stored=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] .. '; M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] .. '; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])) end
            --First consider unpausing
            if bDebugMessages == true then LOG(sFunctionRef .. ': If we have flagged that we are stalling energy then will check if we have enough to start unpausing things') end
            local iT3Arti = 0
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoT3Arti]) == false then
                iT3Arti = table.getn(M28Team.tTeamData[iTeam][M28Team.subreftoT3Arti])
                -- = oBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti)
            end
            local iPercentMod = 0
            local iNetMod = 0
            if iT3Arti > 0 then
                iPercentMod = 0.1
                --Already factored in to the net income, this gives a further buffer
                iNetMod = 25 + (iT3Arti - 1) * 100
            end
            --Also increase net energy if are at tech 3 and lack 3k power
            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 300 then iNetMod = iNetMod + 25 end

                iPercentMod = math.max(0.05, iPercentMod)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': If are in stall mode will check if want to come out. M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; Gross income='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Stored ratio='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored]..'; Net income='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; iNetMod='..iNetMod..'; iPercentMod='..iPercentMod..'; GameTime='..GetGameTimeSeconds()..'; M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled]='..M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled]..'; Changei n power since then='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] - M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled]) end

            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 800 then iPercentMod = math.max(iPercentMod,  math.min(iPercentMod + 0.2, 0.275)) end

            if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] - M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] >= 45 then
                iPercentMod = iPercentMod -0.3
            end

            if (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 100000 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] > math.min(0.95, (0.8 + iPercentMod)) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] > (0.7 + iPercentMod) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > (1 + iNetMod)) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] > (0.5 + iPercentMod) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > (4 + iNetMod)) or (GetGameTimeSeconds() <= 180 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] >= 0.3 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] > M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] * 1.2)))) then
                --M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] = false
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Have enough energy stored or income to start unpausing things if any are paused')
                end
                bPauseNotUnpause = false
                if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] then bChangeRequired = true end
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Checking if we shoudl flag that we are energy stalling; bChangeRequired='..tostring(bChangeRequired)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]))
            end

            if not(bChangeRequired) and not(bPauseNotUnpause) and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) then
                --We arent stalling so shouldnt have any units that are paused; Cycle thorugh each brain and check that the only units that are paused are missile launchers with loaded missiles
                local bHaveUnexpectedlyPausedUnits = false
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do --This section is a redundancy as came across scenario where had paused factories and launchers when not stalling, and logs indicated we didnt think we were stalling
                    if M28Utilities.IsTableEmpty(oBrain[reftPausedUnits]) == false then
                        for iUnit, oUnit in oBrain[reftPausedUnits] do
                            if M28UnitInfo.IsUnitValid(oUnit) then
                                if not(EntityCategoryContains(categories.SILO * categories.NUKE + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategoryTML, oUnit.UnitId)) then
                                    bHaveUnexpectedlyPausedUnits = true
                                    break
                                else
                                    if M28UnitInfo.GetMissileCount(oUnit) == 0 then
                                        bHaveUnexpectedlyPausedUnits = true
                                        break
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of paused units for brain '..oBrain.Nickname..' empty='..tostring(M28Utilities.IsTableEmpty(oBrain[reftPausedUnits]))..'; bHaveUnexpectedlyPausedUnits='..tostring(bHaveUnexpectedlyPausedUnits)) end
                    if bHaveUnexpectedlyPausedUnits then break end
                end
                if bHaveUnexpectedlyPausedUnits then
                    bChangeRequired = true
                end
            end
            --Check if should manage energy stall
            if bChangeRequired == false and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= (0.08 + iPercentMod) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= (0.6 + iPercentMod) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < (2 + iNetMod)) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= (0.4 + iPercentMod) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < (0.5 + (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] - 1) * 5 + iNetMod))) then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': We are stalling energy, will look for units to pause, subject to early game check')
                end
                --If this is early game then add extra check
                if GetGameTimeSeconds() >= 180 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= 0.04 then
                    M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] = true
                    bChangeRequired = true
                    if not(M28Team.tTeamData[iTeam][M28Team.refbJustBuiltLotsOfPower]) then M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] = M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] end
                    if bDebugMessages == true then LOG(sFunctionRef..': early game check cleared, so are stalling energy') end
                end
            end

            if bChangeRequired then
                if bPauseNotUnpause then
                    if bDebugMessages == true then LOG(sFunctionRef..': Change is required and we want to pause units') end
                    M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] = true
                    if not(M28Team.tTeamData[iTeam][M28Team.refbJustBuiltLotsOfPower]) then M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] = M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] end
                end --redundancy
                M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] = GetGameTimeSeconds() --Have even if unpausing, since we may only unpause some of the units
                --Decide on order to pause/unpause

                local tCategoriesByPriority, tEngineerActionsByPriority = GetCategoriesAndActionsToPause(iTeam)

                local iEnergyPerTickSavingNeeded
                if bPauseNotUnpause then
                    iEnergyPerTickSavingNeeded = math.max(1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] + iNetMod * 0.5 + M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.02)
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= 0.15 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have less than 15% energy stored so increasing the energy saving wanted. iEnergyPerTickSavingNeeded pre increase='..iEnergyPerTickSavingNeeded..'; Gross base income='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Team lowest energy storage units='..M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount]) end
                        local iStorageFactor = 50
                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 1000 then iStorageFactor = 100 end
                        iEnergyPerTickSavingNeeded = math.max(iEnergyPerTickSavingNeeded * 1.3, iEnergyPerTickSavingNeeded + M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.03)
                        iEnergyPerTickSavingNeeded = math.max(iEnergyPerTickSavingNeeded, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.06, math.min(M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] * iStorageFactor, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]*0.15))
                    elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= 0.225 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Less than 22.5% energy stored so increasing energy saving slightly') end
                        iEnergyPerTickSavingNeeded = math.max(iEnergyPerTickSavingNeeded * 1.15, iEnergyPerTickSavingNeeded + M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.015)
                    end
                else
                    iEnergyPerTickSavingNeeded = math.min(-1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy], -M28Team.tTeamData[iTeam][M28Team.subrefiTeamEnergyStored] / 30)
                    iEnergyPerTickSavingNeeded = math.max(iEnergyPerTickSavingNeeded, -300)
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= 0.75 then iEnergyPerTickSavingNeeded = iEnergyPerTickSavingNeeded * 0.75 end
                end

                local iEnergySavingManaged = 0
                local iEngineerSubtableCount = 0
                local tEngineerActionSubtable
                local tRelevantUnits, oUnit
                local iBuildRateMod

                local bAbort = false
                local iTotalUnits = 0
                local iCategoryStartPoint, iIntervalChange, iCategoryEndPoint, iCategoryRef
                local bWasUnitAlreadyPaused
                if bPauseNotUnpause then
                    iCategoryStartPoint = 1
                    iIntervalChange = 1
                    iCategoryEndPoint = table.getn(tCategoriesByPriority)
                else
                    iCategoryStartPoint = table.getn(tCategoriesByPriority)
                    iIntervalChange = -1
                    iCategoryEndPoint = 1
                end

                local bConsideringHQ
                local bConsideringTeamWideUnits = false
                local bNoRelevantUnits = true

                if bDebugMessages == true then LOG(sFunctionRef .. ': About to cycle through every category, bPauseNotUnpause=' .. tostring(bPauseNotUnpause) .. '; iCategoryStartPoint=' .. iCategoryStartPoint .. '; iCategoryEndPoint=' .. iCategoryEndPoint) end

                local bPausedUnitsTableIsEmptyForAllBrains = true
                for iCategoryCount = iCategoryStartPoint, iCategoryEndPoint, iIntervalChange do
                    iCategoryRef = tCategoriesByPriority[iCategoryCount]

                    --Are we considering upgrading factory HQs?
                    if iCategoryRef == iSpecialHQCategory then
                        iCategoryRef = M28UnitInfo.refCategoryAllHQFactories
                        bConsideringHQ = true
                        bConsideringTeamWideUnits = false
                    else
                        if iCategoryRef == iSpecialSurplusUpgradeCategory then
                            bConsideringTeamWideUnits = true
                        else
                            bConsideringTeamWideUnits = false
                        end
                        bConsideringHQ = false
                    end

                    local iCurUnitEnergyUsage
                    local bApplyActionToUnit
                    local oBP
                    local oFocusUnitBP
                    local bFirstEngiCategoryRefBrain = true

                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        if oBrain.CheatEnabled then iBuildRateMod = M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier]
                        else iBuildRateMod = 1
                        end
                        if iCategoryRef == iSpecialSurplusUpgradeCategory then
                            --Pause all but 1 upgrade per brain, pausing the lowest progress first, if we have multiple upgrades
                            tRelevantUnits = {}
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[oBrain.M28Team][M28Team.subreftTeamUpgradingMexes]) == false then
                                local iMexesToPause = math.max(0, table.getn(M28Team.tTeamData[oBrain.M28Team][M28Team.subreftTeamUpgradingMexes]) - M28Team.tTeamData[oBrain.M28Team][M28Team.subrefiActiveM28BrainCount])
                                while iMexesToPause > 0 do
                                    local iLowestProgress = 1
                                    local oLowestProgress
                                    local bAlreadyIncluded
                                    for iUnit, oUnit in M28Team.tTeamData[oBrain.M28Team][M28Team.subreftTeamUpgradingMexes] do
                                        if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetWorkProgress() < iLowestProgress then
                                            bAlreadyIncluded = false
                                            --Is the unit already in the table of relevant units?
                                            if M28Utilities.IsTableEmpty(tRelevantUnits) == false then
                                                for iRecordedUnit, oRecordedUnit in tRelevantUnits do
                                                    if oRecordedUnit == oUnit then bAlreadyIncluded = true break end
                                                end
                                            end
                                            if not(bAlreadyIncluded) then
                                                oLowestProgress = oUnit
                                                iLowestProgress = oUnit:GetWorkProgress()
                                            end
                                        end
                                    end
                                    table.insert(tRelevantUnits, oLowestProgress)
                                    iMexesToPause = iMexesToPause - 1
                                end
                            end
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[oBrain.M28Team][M28Team.subreftTeamUpgradingOther]) == false then
                                for iUnit, oUnit in M28Team.tTeamData[oBrain.M28Team][M28Team.subreftTeamUpgradingOther] do
                                    table.insert(tRelevantUnits, oUnit)
                                end
                            end
                        else
                            if bPauseNotUnpause then
                                tRelevantUnits = oBrain:GetListOfUnits(iCategoryRef, false, true)
                            else
                                tRelevantUnits = EntityCategoryFilterDown(iCategoryRef, oBrain[reftPausedUnits])
                            end
                        end

                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iCategoryCount='..iCategoryCount..' for brain '..oBrain.Nickname..'; Is table of relevant units empty='..tostring(M28Utilities.IsTableEmpty(tRelevantUnits))) end
                        if M28Utilities.IsTableEmpty(tRelevantUnits) == false then
                            bNoRelevantUnits = false
                            iTotalUnits = table.getn(tRelevantUnits)
                            if bDebugMessages == true then LOG(sFunctionRef .. ': iCategoryCount=' .. iCategoryCount .. '; iTotalUnits=' .. iTotalUnits .. '; bPauseNotUnpause=' .. tostring(bPauseNotUnpause)..'; iEngineerSubtableCount before increasing='..iEngineerSubtableCount..'; tEngineerActionsByPriority='..repru(tEngineerActionsByPriority)) end

                            if iCategoryRef == M28UnitInfo.refCategoryEngineer then
                                if bFirstEngiCategoryRefBrain then
                                    iEngineerSubtableCount = iEngineerSubtableCount + 1
                                    bFirstEngiCategoryRefBrain = false
                                end
                                tEngineerActionSubtable = tEngineerActionsByPriority[iEngineerSubtableCount]
                            end

                            for iUnit = iTotalUnits, 1, -1 do
                                oUnit = tRelevantUnits[iUnit]
                                --for iUnit, oUnit in tRelevantUnits do
                                bApplyActionToUnit = false
                                iCurUnitEnergyUsage = 0
                                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then --Only consider unit if it has been constructed
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': About to consider pausing/unpausingunit ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. '; will first check category specific logic for if we want to go ahead with pausing4')
                                    end


                                    --Do we actually want to pause the unit? check any category specific logic
                                    bApplyActionToUnit = true
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': UnitState=' .. M28UnitInfo.GetUnitState(oUnit) .. '; Is ActiveHQUpgrades Empty=' .. tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs])))
                                    end
                                    --SMD LOGIC - Check if already have 1 missile loaded before pausing
                                    if bPauseNotUnpause and iCategoryRef == M28UnitInfo.refCategorySMD and oUnit.GetTacticalSiloAmmoCount and oUnit:GetTacticalSiloAmmoCount() >= 1 then
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Have SMD with at least 1 missile so will pause it')
                                        end
                                        bApplyActionToUnit = false
                                    elseif iCategoryRef == M28UnitInfo.refCategoryEngineer then
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Have an engineer with action=' .. (oUnit[M28Engineer.refiAssignedAction] or 'nil') .. '; tEngineerActionSubtable=' .. repru(tEngineerActionSubtable))
                                        end
                                        bApplyActionToUnit = false
                                        if not(oUnit[M28Engineer.refiAssignedAction]) and not(bPauseNotUnpause) then bApplyActionToUnit = true
                                        else
                                            for iActionCount, iActionRef in tEngineerActionSubtable do
                                                if iActionRef == oUnit[M28Engineer.refiAssignedAction] then
                                                    bApplyActionToUnit = true
                                                    --Dont pause the last engi building power
                                                    if bPauseNotUnpause then
                                                        if iActionRef == M28Engineer.refActionBuildPower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.7 then
                                                            bApplyActionToUnit = false
                                                            --Dont pause T1 factory construction if we have a certain amount of gross energy income
                                                        elseif iActionRef == M28Engineer.refActionBuildLandFactory and EntityCategoryContains(categories.TECH1, oUnit.UnitId) and oBrain[refiGrossEnergyBaseIncome] >= 26 and oUnit[M28Engineer.refbPrimaryBuilder] then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': wont pause primary engineer building t1 land fac') end
                                                            bApplyActionToUnit = false
                                                        end
                                                    end
                                                    break
                                                end
                                            end
                                        end
                                    elseif iCategoryRef == M28UnitInfo.refCategoryPersonalShield or iCategoryRef == M28UnitInfo.refCategoryFixedShield or iCategoryRef == M28UnitInfo.refCategoryMobileLandShield then
                                        --Dont disable shield if unit has enemies nearby
                                        if bPauseNotUnpause and M28UnitInfo.IsUnitShieldEnabled(oUnit) and M28Utilities.IsTableEmpty(oBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryDangerousToLand, oUnit:GetPosition(), 40, 'Enemy')) == false then
                                            bApplyActionToUnit = false
                                        end
                                    elseif iCategoryRef == M28UnitInfo.refCategoryAirFactory or iCategoryRef == M28UnitInfo.refCategoryLandFactory then
                                        --Dont want to pause an HQ upgrade since it will give us better power
                                        if bPauseNotUnpause and not (bConsideringHQ) and oUnit:IsUnitState('Upgrading') and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]) == false and EntityCategoryContains(categories.FACTORY, oUnit) then
                                            for iFactory, oFactory in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs] do
                                                if oUnit == oFactory then
                                                    bApplyActionToUnit = false
                                                    break
                                                end
                                            end
                                        elseif not (bPauseNotUnpause) and bConsideringHQ then
                                            --Only unpause HQs
                                            bApplyActionToUnit = false
                                            if oUnit:IsUnitState('Upgrading') and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]) == false then
                                                for iFactory, oFactory in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs] do
                                                    if oUnit == oFactory then
                                                        bApplyActionToUnit = true
                                                        break
                                                    end
                                                end
                                            end
                                        end
                                        if bApplyActionToUnit and bPauseNotUnpause then
                                            --Dont pause factory that is building an engineer or is an air factory that isnt building an air unit, if its our highest tech level and we dont have at least 5 engis of that tech level
                                            if M28UnitInfo.GetUnitTechLevel(oUnit) >= math.max(2, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) and oBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(M28UnitInfo.GetUnitTechLevel(oUnit))) < 2 then
                                                --Dont pause factory as have too few engis and want to build power with those engis
                                                if bDebugMessages == true then LOG(sFunctionRef .. ': Have too few engineers so wont pause factory') end
                                                bApplyActionToUnit = false
                                            end
                                        end
                                    elseif not(bPauseNotUnpause) and (oUnit.GetTacticalSiloAmmoCount or oUnit.GetTacticalSiloAmmoCount) and M28UnitInfo.GetMissileCount(oUnit) >= 2 then
                                        --Dont unpause TML, SML and SMD that have 2+ missiles loaded already
                                        bApplyActionToUnit = false
                                    elseif bPauseNotUnpause and iCategoryRef == M28UnitInfo.refCategoryTML and M28UnitInfo.GetMissileCount(oUnit) == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 30 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Dealing with TML that has no missile so dont want to pause it') end
                                        bApplyActionToUnit = false
                                    end

                                    if iCategoryRef == categories.COMMAND then
                                        --want in addition to above as ACU might have personal shield
                                        if bPauseNotUnpause then
                                            if not (oUnit:IsUnitState('Upgrading')) then
                                                bApplyActionToUnit = false
                                            elseif oUnit.GetWorkProgress then
                                                if oUnit:GetWorkProgress() >= 0.85 then
                                                    bApplyActionToUnit = false
                                                    --dont pause t1 mex construction
                                                elseif oUnit.GetFocusUnit and oUnit:GetFocusUnit() and oUnit:GetFocusUnit().UnitId and EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oUnit:GetFocusUnit().UnitId) then
                                                    bApplyActionToUnit = false
                                                end
                                            end
                                        else
                                            bApplyActionToUnit = true --redundancy - are unpausing units so want to unpause ACU asap
                                        end
                                    end


                                    --Pause the unit

                                    if bDebugMessages == true then LOG(sFunctionRef..': bApplyActionToUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'='..tostring(bApplyActionToUnit)) end

                                    if bApplyActionToUnit then
                                        bWasUnitAlreadyPaused = oUnit[M28UnitInfo.refbPaused] --Means we will ignore the energy usage when calculating how much we have saved
                                        oBP = oUnit:GetBlueprint()
                                        iCurUnitEnergyUsage = oBP.Economy.MaintenanceConsumptionPerSecondEnergy

                                        if (iCurUnitEnergyUsage or 0) == 0 or EntityCategoryContains(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryMex + categories.COMMAND, oUnit.UnitId) then
                                            --Approximate energy usage based on build rate as a very rough guide
                                            --examples: Upgrading mex to T3 costs 11E per BP; T3 power is 8.4; T1 power is 6; Guncom is 30; Laser is 178; Strat bomber is 15
                                            local iEnergyPerBP = 9
                                            if EntityCategoryContains(categories.SILO, oUnit.UnitId) and oBP.Economy.BuildRate then
                                                --Dealing with a silo so need to calculate energy usage differently
                                                iCurUnitEnergyUsage = 0
                                                for iWeapon, tWeapon in oBP.Weapon do
                                                    if tWeapon.MaxProjectileStorage and tWeapon.ProjectileId then
                                                        local oProjectileBP = __blueprints[tWeapon.ProjectileId]
                                                        if oProjectileBP.Economy and oProjectileBP.Economy.BuildCostEnergy and oProjectileBP.Economy.BuildTime > 0 and oBP.Economy.BuildRate > 0 then
                                                            --(will multiply cost by 10% in later step)
                                                            iCurUnitEnergyUsage = oProjectileBP.Economy.BuildCostEnergy * oBP.Economy.BuildRate * iBuildRateMod / oProjectileBP.Economy.BuildTime
                                                            --If are power stalling then assume we only save 80% of this, as might have adjacency
                                                            if bPauseNotUnpause then iCurUnitEnergyUsage = iCurUnitEnergyUsage * 0.8 end
                                                            break
                                                        end
                                                    end
                                                end
                                            else
                                                if iCategoryRef == categories.COMMAND and oUnit[M28Orders.refiOrderCount] > 0 and oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] == M28Orders.refiOrderEnhancement then
                                                    --Determine energy cost per BP
                                                    local sUpgradeRef = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint]
                                                    iEnergyPerBP = M28UnitInfo.GetUpgradeEnergyCost(oUnit, sUpgradeRef) / (M28UnitInfo.GetUpgradeBuildTime(oUnit, sUpgradeRef) or 1)
                                                    oUnit[refiLastEnergyUsage] = iCurUnitEnergyUsage
                                                else
                                                    --Engineer - adjust energy consumption based on what are building
                                                    iEnergyPerBP = 3
                                                end

                                                if oBP.Economy.BuildRate then
                                                    --iCurUnitEnergyUsage = oBP.Economy.BuildRate * iEnergyPerBP
                                                    --Reduce this massively if unit isn't actually building anything
                                                    if bPauseNotUnpause then
                                                        if (not(oUnit:IsUnitState('Building')) and not(oUnit:IsUnitState('Repairing')) and not(oUnit.GetWorkProgress and oUnit:GetWorkProgress() > 0)) then
                                                            iCurUnitEnergyUsage = oBP.Economy.BuildRate * iBuildRateMod * 0.01
                                                        else
                                                            if M28UnitInfo.IsUnitValid(oUnit:GetFocusUnit()) then
                                                                oFocusUnitBP = oUnit:GetFocusUnit():GetBlueprint()
                                                                iCurUnitEnergyUsage = oBP.Economy.BuildRate * iBuildRateMod / oFocusUnitBP.Economy.BuildTime * oFocusUnitBP.Economy.BuildCostEnergy
                                                                oUnit[refiLastEnergyUsage] = iCurUnitEnergyUsage
                                                            else
                                                                iCurUnitEnergyUsage = oBP.Economy.BuildRate * iBuildRateMod * iEnergyPerBP
                                                            end
                                                        end
                                                    else
                                                        iCurUnitEnergyUsage = (oUnit[refiLastEnergyUsage] or oBP.Economy.BuildRate * iBuildRateMod * iEnergyPerBP)
                                                    end
                                                end
                                            end
                                        end
                                        --We're working in ticks so adjust energy usage accordingly
                                        iCurUnitEnergyUsage = iCurUnitEnergyUsage * 0.1
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Estimated energy usage before factoring in unit state=' .. iCurUnitEnergyUsage..'; About to call the function PauseOrUnpauseEnergyUsage on unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; iUnitsAdjusted where expected to save energy='..iUnitsAdjusted)
                                        end

                                        if not((iCurUnitEnergyUsage or 0) == 0) then
                                            iUnitsAdjusted = iUnitsAdjusted + 1
                                            if bPauseNotUnpause and EntityCategoryContains(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryFactory, oUnit.UnitId) then
                                                if not(oUnit:IsUnitState('Upgrading') or oUnit:IsUnitState('Repairing') or oUnit:IsUnitState('Building')) then
                                                    iCurUnitEnergyUsage = iCurUnitEnergyUsage * 0.01
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Unit state='..M28UnitInfo.GetUnitState(oUnit)..' so will set the amount of energy saved equal to just 1% of the actual value, so it is now '..iCurUnitEnergyUsage) end
                                                end
                                            end
                                        end
                                        M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, bPauseNotUnpause)
                                        --Cant move the below into unitinfo as get a crash if unitinfo tries to refernce the table of paused units
                                        --Managed to avoid the crash by making a localised import of M28Economy into the pauseorunpause function; want it in unitinfo as then m28orders can call the same function when clearing an engineer's orders


                                        --[[if bPauseNotUnpause then
                                            table.insert(oBrain[reftPausedUnits], oUnit)
                                            if bDebugMessages == true then
                                                LOG(sFunctionRef .. ': Added unit to tracker table, size=' .. table.getn(oBrain[reftPausedUnits]))
                                            end
                                        else
                                            if bDebugMessages == true then
                                                LOG(sFunctionRef .. ': Will remove unit from reftPausedUnits. Size of table before removal=' .. table.getn(oBrain[reftPausedUnits]))
                                            end
                                            for iPausedUnit, oPausedUnit in oBrain[reftPausedUnits] do
                                                if oPausedUnit == oUnit then
                                                    table.remove(oBrain[reftPausedUnits], iPausedUnit)
                                                end
                                            end
                                            if bDebugMessages == true then
                                                LOG(sFunctionRef .. ': Size of table after removal =' .. table.getn(oBrain[reftPausedUnits]))
                                            end
                                        end--]]

                                    end
                                elseif bDebugMessages == true then LOG(sFunctionRef..': Unit entry='..iUnit..'; Unit isnt valid')
                                end
                                if not (bWasUnitAlreadyPaused) and bPauseNotUnpause then
                                    iEnergySavingManaged = iEnergySavingManaged + iCurUnitEnergyUsage
                                elseif bWasUnitAlreadyPaused and not (bPauseNotUnpause) then
                                    iEnergySavingManaged = iEnergySavingManaged - iCurUnitEnergyUsage
                                end
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': iEnergySavingManaged=' .. iEnergySavingManaged .. '; iEnergyPerTickSavingNeeded=' .. iEnergyPerTickSavingNeeded .. '; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; bWasUnitAlreadyPaused='..tostring(bWasUnitAlreadyPaused)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; iCurUnitEnergyUsage='..iCurUnitEnergyUsage)
                                end

                                if bPauseNotUnpause then
                                    if iEnergySavingManaged > iEnergyPerTickSavingNeeded then
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Estimate we have saved ' .. iEnergySavingManaged .. ' which is more tahn we wanted so will pause')
                                        end
                                        bAbort = true
                                        break
                                    end
                                else
                                    if iEnergySavingManaged < iEnergyPerTickSavingNeeded then
                                        bAbort = true
                                        break
                                    end
                                end
                            end
                        elseif bDebugMessages == true then
                            LOG(sFunctionRef .. ': We have no units for iCategoryCount=' .. iCategoryCount)
                        end

                        if bPausedUnitsTableIsEmptyForAllBrains and M28Utilities.IsTableEmpty(oBrain[reftPausedUnits]) == false then
                            bPausedUnitsTableIsEmptyForAllBrains = false
                        end

                        if bAbort then
                            break
                        end
                        if bConsideringTeamWideUnits then break end --dont want to consider for more than one brain
                    end
                    if bAbort then
                        break
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef .. 'If we have no paused units then will set us as not having an energy stall; bPausedUnitsTableIsEmptyForAllBrains='..tostring(bPausedUnitsTableIsEmptyForAllBrains)..'; subrefbTeamIsStallingMass ='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass])..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)) end
                if bPausedUnitsTableIsEmptyForAllBrains or (M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] and not(bPauseNotUnpause) and not(bHaveWeCappedUnpauseAmount)) then
                    M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] = false
                    if bDebugMessages == true then LOG(sFunctionRef .. ': We are no longer stalling energy') end
                else
                    if bDebugMessages == true then LOG(sFunctionRef .. ': About to check if we wanted to unpause units but havent unpaused anything; iUnitsAdjusted=' .. iUnitsAdjusted .. '; bNoRelevantUnits=' .. tostring(bNoRelevantUnits) .. '; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])) end
                    --Backup - sometimes we still have units in the table listed as being paused (e.g. if an engineer changes action to one that isnt listed as needing pausing) - unpause them if we couldnt find via category search
                    if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] and not (bPauseNotUnpause) and (iEnergySavingManaged > iEnergyPerTickSavingNeeded or iUnitsAdjusted == 0 or bNoRelevantUnits) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] >= 0.95 then
                        --Have a decent amount of power, are flagged as stalling energy, but couldnt find any categories to unpause
                        if bDebugMessages == true then LOG(sFunctionRef .. ': werent able to find any units to unpause with normal approach so will unpause all remaining units for all M28 brains in the team') end
                        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                            local iLoopCountCheck = 0
                            local iMaxLoop = math.max(20, table.getn(oBrain[reftPausedUnits]) + 1)
                            while M28Utilities.IsTableEmpty(oBrain[reftPausedUnits]) == false do
                                iLoopCountCheck = iLoopCountCheck + 1
                                if iLoopCountCheck >= iMaxLoop then
                                    M28Utilities.ErrorHandler('Infinite loop likely')
                                    break
                                end
                                if M28Utilities.IsTableEmpty(oBrain[reftPausedUnits]) == false then
                                    for iUnit, oUnit in oBrain[reftPausedUnits] do
                                        if bDebugMessages == true then
                                            if M28UnitInfo.IsUnitValid(oUnit) then
                                                LOG(sFunctionRef .. ': About to unpause ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit))
                                            else
                                                LOG('Removing iUnit=' .. iUnit .. ' which is no longer valid')
                                            end
                                            LOG('Size of oBrain[reftPausedUnits] before removal=' .. table.getn(oBrain[reftPausedUnits]) .. '; will double check this size')
                                            local iActualSize = 0
                                            for iAltUnit, oAltUnit in oBrain[reftPausedUnits] do
                                                iActualSize = iActualSize + 1
                                            end
                                            LOG('Actual size=' .. iActualSize)
                                        end
                                        if M28UnitInfo.IsUnitValid(oUnit) then
                                            M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, false)
                                        end
                                        table.remove(oBrain[reftPausedUnits], iUnit)
                                        break
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef .. ': FInished unpausing units') end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef .. ': End of code, M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) .. '; bPauseNotUnpause=' .. tostring(bPauseNotUnpause) .. '; iUnitsAdjusted=' .. iUnitsAdjusted .. '; Game time=' .. GetGameTimeSeconds() .. '; Energy stored %=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] .. '; Net energy income=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] .. '; gross energy income=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]) end
            if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] then
                M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] = GetGameTimeSeconds()
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Will now call manage mass stalls if not stalling energy. M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; bChangeRequired='..tostring(bChangeRequired)) end
        if not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and not(bChangeRequired) then
            ForkThread(ManageMassStalls, iTeam)
        end
    else
        M28Utilities.ErrorHandler('No active M28 brains')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function GetEnergyStorageMaximum(aiBrain, bDetailedUpdate)
    --bDetailedUpdate - called periodically (but not by the every tick team resource sharer)
    if aiBrain:GetEconomyStoredRatio('ENERGY') > 0 then
        aiBrain[refiMaxEnergyStorage] = aiBrain:GetEconomyStored('ENERGY') / aiBrain:GetEconomyStoredRatio('ENERGY')
        return aiBrain[refiMaxEnergyStorage]
    else
        if bDetailedUpdate then
            aiBrain[refiMaxEnergyStorage] = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEnergyStorage) * M28Building.iEnergyStorageExpectedCapacity + aiBrain:GetCurrentUnits(categories.COMMAND) * 3900 + 100
        end
        return aiBrain[refiMaxEnergyStorage]
    end
end

function GetMassStorageMaximum(aiBrain, bDetailedUpdate)
    if aiBrain:GetEconomyStoredRatio('MASS') > 0 then
        aiBrain[refiMaxMassStorage] = aiBrain:GetEconomyStored('MASS') / aiBrain:GetEconomyStoredRatio('MASS')
        return aiBrain[refiMaxMassStorage]
    else
        if bDetailedUpdate then
            aiBrain[refiMaxMassStorage] = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMassStorage) * 500 + aiBrain:GetCurrentUnits(categories.COMMAND) * 650 + 150
        end
        return aiBrain[refiMaxMassStorage]
    end
end


function GiveResourcesToPlayer(oBrainGiver, oBrainReceiver, iMass, iEnergy)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GiveResourcesToPlayer'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Check we have the resources to give:
    if iMass > 0 and oBrainGiver:GetEconomyStored('MASS') >= iMass then
        --Check the person receiving has enough capacity
        if GetMassStorageMaximum(oBrainReceiver) - oBrainReceiver:GetEconomyStored('MASS') >= iMass then
            oBrainReceiver:GiveResource('Mass', iMass)
            oBrainGiver:TakeResource('Mass', iMass)
            if bDebugMessages == true then LOG(sFunctionRef..': Given '..iMass..' Mass from '..oBrainGiver.Nickname..' to '..oBrainReceiver.Nickname) end

        end
    end
    if iEnergy > 0 and oBrainGiver:GetEconomyStored('ENERGY') >= iEnergy then
        if GetEnergyStorageMaximum(oBrainReceiver) - oBrainReceiver:GetEconomyStored('ENERGY') >= iEnergy then
            oBrainReceiver:GiveResource('Energy', iEnergy)
            oBrainGiver:TakeResource('Energy', iEnergy)
            if bDebugMessages == true then LOG(sFunctionRef..': Given '..iEnergy..' Energy from '..oBrainGiver.Nickname..' to '..oBrainReceiver.Nickname) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function ShareResourcesMassAndEnergyBetweenTeam() M28Utilities.ErrorHandler('Using superceded code')  end --Done to make the below easier to find
function AllocateTeamEnergyAndMassResources(iTeam)
    --Smoothes out energy storage for M28 brains on the same team, where % storage is <95%

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AllocateTeamEnergyResources'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then

        local refiResourceEnergy = 1
        local refiResourceMass = 2
        local tDetailsOfBrainsNeedingEnergy = {}
        local tDetailsOfBrainsWithEnergy = {}
        local tDetailsOfBrainsNeedingMass = {}
        local tDetailsOfBrainsWithMass = {}

        local subrefoBrain = 1
        local subrefiRemainingResourceNeeded = 2
        local subrefiResourceToGive = 3

        local iTotalEnergyStored = 0
        local iTotalMassStored = 0

        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            iTotalEnergyStored = iTotalEnergyStored + oBrain:GetEconomyStored('ENERGY')
            iTotalMassStored = iTotalMassStored + oBrain:GetEconomyStored('MASS')
        end
        local iAverageEnergyStored = iTotalEnergyStored / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]
        local iAverageMassStored = iTotalMassStored / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]
        local iCurEnergySpare, iCurMassSpare

        if bDebugMessages == true then LOG(sFunctionRef..': Near start, time='..GetGameTimeSeconds()..'; iAverageEnergyStored='..iAverageEnergyStored..'; iAverageMassStored='..iAverageMassStored) end

        --Sort brains into those that have mass, and those that give mass
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            iCurEnergySpare = oBrain:GetEconomyStored('ENERGY') - iAverageEnergyStored
            if iCurEnergySpare < 0 then
                --Limit Energy to receive to the amount that takes us to 95% storage:
                iCurEnergySpare = math.max(iCurEnergySpare, math.min(0, oBrain:GetEconomyStored('ENERGY') -  GetEnergyStorageMaximum(oBrain) * 0.95))
                if iCurEnergySpare < 0 then
                    table.insert(tDetailsOfBrainsNeedingEnergy, {[subrefoBrain] = oBrain, [subrefiRemainingResourceNeeded] = iCurEnergySpare})
                end
            elseif iCurEnergySpare > 0 then
                table.insert(tDetailsOfBrainsWithEnergy, {[subrefoBrain] = oBrain, [subrefiResourceToGive] = iCurEnergySpare})
            end

            iCurMassSpare = oBrain:GetEconomyStored('MASS') - iAverageMassStored
            if iCurMassSpare < 0 then
                --Limit mass to receive to the amount that takes us to 95% storage:
                iCurMassSpare = math.max(iCurMassSpare, math.min(0, oBrain:GetEconomyStored('MASS') -  GetMassStorageMaximum(oBrain) * 0.95))
                if iCurMassSpare < 0 then
                    table.insert(tDetailsOfBrainsNeedingMass, {[subrefoBrain] = oBrain, [subrefiRemainingResourceNeeded] = iCurMassSpare})
                end
            elseif iCurMassSpare > 0 then
                table.insert(tDetailsOfBrainsWithMass, {[subrefoBrain] = oBrain, [subrefiResourceToGive] = iCurMassSpare})
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering brain '..oBrain.Nickname..': iCurEnergySpare='..iCurEnergySpare..'; iCurMassSpare='..iCurMassSpare..'; Actual mass stored='..oBrain:GetEconomyStored('MASS')..'; Actual energy stored='..oBrain:GetEconomyStored('ENERGY')..'; iAverageMassStored='..iAverageMassStored) end
        end

        --Allocate resources:
        local tBrainsNeedingResource, tBrainsWithResource
        local iResourceToGive
        for iResourceType = 1, 2, 1 do
            if iResourceType == refiResourceEnergy then
                tBrainsNeedingResource = tDetailsOfBrainsNeedingEnergy
                tBrainsWithResource = tDetailsOfBrainsWithEnergy
                if bDebugMessages == true then LOG(sFunctionRef..': Allcoating energy') end
            else
                tBrainsNeedingResource = tDetailsOfBrainsNeedingMass
                tBrainsWithResource = tDetailsOfBrainsWithMass
                if bDebugMessages == true then LOG(sFunctionRef..': Allcoating mass') end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of brains needing this resource empty='..tostring(M28Utilities.IsTableEmpty(tBrainsNeedingResource))..'; Is table of brains with this resource available empty='..tostring(M28Utilities.IsTableEmpty(tBrainsWithResource))) end
            if M28Utilities.IsTableEmpty(tBrainsNeedingResource) == false and M28Utilities.IsTableEmpty(tBrainsWithResource) == false then
                for iBrainWithResource, tBrainWithResourceSubtable in tBrainsWithResource do
                    if bDebugMessages == true then LOG(sFunctionRef..': Deciding which brain '..tBrainWithResourceSubtable[subrefoBrain].Nickname..' should give its resources to') end
                    for iBrainNeedingResource, tBrainNeedingResourceSubtable in tBrainsNeedingResource do
                        iResourceToGive = math.min(-tBrainNeedingResourceSubtable[subrefiRemainingResourceNeeded], tBrainWithResourceSubtable[subrefiResourceToGive])
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to give resources to brain '..tBrainNeedingResourceSubtable[subrefoBrain].Nickname..'; iResourceToGive='..iResourceToGive..'; tBrainNeedingResourceSubtable[subrefiRemainingResourceNeeded]='..tBrainNeedingResourceSubtable[subrefiRemainingResourceNeeded]..'; tBrainWithResourceSubtable[subrefiResourceToGive]='..tBrainWithResourceSubtable[subrefiResourceToGive]) end
                        if iResourceToGive > 0 then
                            if iResourceType == refiResourceEnergy then
                                GiveResourcesToPlayer(tBrainWithResourceSubtable[subrefoBrain], tBrainNeedingResourceSubtable[subrefoBrain], 0, iResourceToGive)
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': About to give '..iResourceToGive..' mass from player '..tBrainWithResourceSubtable[subrefoBrain].Nickname..' to player '..tBrainNeedingResourceSubtable[subrefoBrain].Nickname) end
                                GiveResourcesToPlayer(tBrainWithResourceSubtable[subrefoBrain], tBrainNeedingResourceSubtable[subrefoBrain], iResourceToGive, 0)
                            end
                            tBrainNeedingResourceSubtable[subrefiRemainingResourceNeeded] = tBrainNeedingResourceSubtable[subrefiRemainingResourceNeeded] + iResourceToGive
                            tBrainWithResourceSubtable[subrefiResourceToGive] = tBrainWithResourceSubtable[subrefiResourceToGive] - iResourceToGive
                            if tBrainWithResourceSubtable[subrefiResourceToGive] <= 0 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Remaining resource available for brain '..tBrainWithResourceSubtable[subrefoBrain].Nickname..' to give='..tBrainWithResourceSubtable[subrefiResourceToGive]..' so will break') end
                                break
                            end
                        end
                    end
                end
            end
        end
    else
        M28Utilities.ErrorHandler('No active M28 brains')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TeamResourceSharingMonitor(iTeam)
    --Monitors resources for AI in the team and shares resources
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TeamResourceSharingMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, checking if already running a monitor for iTeam='..iTeam..': Is table of friendl yM28 brains for this team empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(120) --Dont want to share in the first 2m
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        while M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 do
            ForkThread(AllocateTeamEnergyAndMassResources, iTeam)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    end
end

function UpdateTableOfUpgradingMexesForTeam(iTeam)
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) == false then
        local tUpgradingMexes = M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]
        local iEntries = table.getn(tUpgradingMexes)

        for iCurEntry = iEntries, 1, -1 do
            if not(M28UnitInfo.IsUnitValid(tUpgradingMexes[iCurEntry])) then
                table.remove(tUpgradingMexes, iCurEntry)
            end
        end
    end
end

function ManageMassOverflow(iTeam)
    --Stop any engineers that have a reclaim area order
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMassOverflow'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastOverflowEngiCheck] or -100) >= 1 then --Only do this every couple of seconds
            M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastOverflowEngiCheck] = GetGameTimeSeconds()
            local iEngiCycleCount = 0
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do

                local tEngineers = oBrain:GetListOfUnits(M28UnitInfo.refCategoryEngineer, false, true)
                if M28Utilities.IsTableEmpty(tEngineers) == false then
                    for iUnit, oUnit in tEngineers do
                        iEngiCycleCount = iEngiCycleCount + 1
                        if M28UnitInfo.IsUnitValid(oUnit) and (oUnit[M28Engineer.refiAssignedAction] == M28Engineer.refActionReclaimArea or oUnit[M28Engineer.refiAssignedAction] == M28Engineer.refActionReclaimFriendlyUnit) then
                            if bDebugMessages == true then LOG(sFunctionRef..': About to stop engineer '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from reclaiming as have lots of mass now') end
                            M28Orders.IssueTrackedClearCommands(oUnit)
                        end
                        if iEngiCycleCount >= 30 then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitTicks(1)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                            M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastOverflowEngiCheck] = GetGameTimeSeconds()
                            iEngiCycleCount = 0
                        end
                    end
                end
            end
        end
    else
        M28Utilities.ErrorHandler('No M28 brains active')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end