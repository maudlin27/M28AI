---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 08:37
---

local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local NavUtils = M28Utilities.NavUtils
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')

--Variables against aiBrain:
--ECONOMY VARIABLES - below 4 are to track values based on base production, ignoring reclaim. Provide per tick values so 10% of per second)
refiGrossEnergyBaseIncome = 'M28EnergyGrossIncome' --against aiBrain
refiNetEnergyBaseIncome = 'M28EnergyNetIncome' --against aiBrain
refiGrossMassBaseIncome = 'M28MassGrossIncome' --against aiBrain
refiNetMassBaseIncome = 'M28MassNetIncome' --against aiBrain
refiBrainResourceMultiplier = 'M28ResourceMod' --Against aiBrain, e.g. 1.5 if AIx 1.5
refiBrainBuildRateMultiplier = 'M28BuildMod' --against aiBrain
refbBuiltParagon = 'M28EcBltPa' --against aibrain, true if we have an active paragon

refiMaxMassStorage = 'M28MaxMassStorage' --against aiBrain
refiMaxEnergyStorage = 'M28MaxEnergyStorage' --against aiBrain

--Factory tech variables
refiOurHighestFactoryTechLevel = 'M28EOurHighestFactoryTech' --against aiBrain
refiOurHighestAirFactoryTech = 'M28EOurHighestAirFactoryTech' --against aiBrain
refiOurHighestLandFactoryTech = 'M28EOurHighestLandFactoryTech' --against aiBrain
refiOurHighestNavalFactoryTech = 'M28EOurHighestNavalFactoryTech' --against aiBrain



--Against unit variables:
refoBrainRecordedForEconomy = 'M28EconomyBrainRecordedUnit' --Stores the M28 brain that has factored in this unit's mass and energy income
refiLastEnergyUsage = 'M28EconomyLastEnergyUsage' --per tick energy usage of the unit (set when the unit is paused)
refiLastMassUsage = 'M28EconomyLastMassUsage' --per tick massu sage of the unit set when unit is paused
refiStorageMassAdjacencyBonus = 'M28EMassStorAdj' --Adjacency bonus from a mass storage
refbSpecialUpgradeMonitor = 'M28ESpecUM' --true if special upgrade monitor (used for hydros) is active

--global variables
tiMinEnergyPerTech = {[1]=16,[2]=55,[3]=150,[3]=150}
bT3MexCanBeUpgraded = false
iSpecialHQCategory = 'M28EconomyFactoryHQ' --Used as a way of choosing to pause HQ
iSpecialSurplusUpgradeCategory = 'M28EconomySurplusUpgrade' --used as a way of choosing to pause excess upgrades

function UpgradeUnit(oUnitToUpgrade, bUpdateUpgradeTracker)
    --Work out the upgrade ID wanted; if bUpdateUpgradeTracker is true then records upgrade against unit's aiBrain
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpgradeUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, reprs of oUnitToUpgrade='..reprs(oUnitToUpgrade)..'; GetUnitUpgradeBlueprint='..reprs((M28UnitInfo.GetUnitUpgradeBlueprint(oUnitToUpgrade, true) or 'nil'))..'; bUpdateUpgradeTracker='..tostring((bUpdateUpgradeTracker or false))..'; unit brain='..oUnitToUpgrade:GetAIBrain().Nickname..'; Are we in T1 spam mode='..tostring(M28Team.tTeamData[oUnitToUpgrade:GetAIBrain().M28Team][M28Team.refbFocusOnT1Spam])) M28Utilities.ErrorHandler('Audit trail for unit upgrade', true, true) end
    --Do we have any HQs of the same factory type of a higher tech level?
    local sUpgradeID = M28UnitInfo.GetUnitUpgradeBlueprint(oUnitToUpgrade, true) --If not a factory or dont recognise the faction then just returns the normal unit ID


    if sUpgradeID and M28UnitInfo.IsUnitValid(oUnitToUpgrade) then
        local aiBrain = oUnitToUpgrade:GetAIBrain()
        if bDebugMessages == true then LOG(sFunctionRef..': About to issue ugprade to unit '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)..'; Current state='..M28UnitInfo.GetUnitState(oUnitToUpgrade)..'; Work progress='..(oUnitToUpgrade:GetWorkProgress() or 'nil')..'; Is unit upgrading='..tostring(oUnitToUpgrade:IsUnitState('Upgrading'))) end

        if not(oUnitToUpgrade:IsUnitState('Upgrading')) then
            local bAddToExistingQueue = true



            --Factory specific - if work progress is <=5% then cancel so can do the upgrade
            if EntityCategoryContains(M28UnitInfo.refCategoryFactory, oUnitToUpgrade.UnitId) then
                if bDebugMessages == true then LOG(sFunctionRef..': Are upgrading a factory '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)..'; work progress='..oUnitToUpgrade:GetWorkProgress()) end
                if oUnitToUpgrade.GetWorkProgress and oUnitToUpgrade:GetWorkProgress() <= 0.05 then
                    --Are we building an engineer or transport?
                    local oUnitThatAreBuilding = oUnitToUpgrade:GetFocusUnit()
                    if not(M28UnitInfo.IsUnitValid(oUnitThatAreBuilding) and EntityCategoryContains(M28UnitInfo.refCategoryTransport + M28UnitInfo.refCategoryEngineer, oUnitThatAreBuilding.UnitId)) then
                        bAddToExistingQueue = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Have barely started with current construction so will cancel so can get upgrade sooner') end
                    end
                end
            end

            --Air factory upgrades - if we are upgrading from T1 to T2 and havent build a transport, and have plateaus, then want to get a transport first
            if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory * categories.TECH1, oUnitToUpgrade.UnitId) and aiBrain[refiOurHighestAirFactoryTech] == 1 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory * categories.TECH1) == 1 then
                --Do we have locations for transports to drop?
                if bDebugMessages == true then LOG(sFunctionRef..': Is island drop shortlist empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftTransportIslandDropShortlist]))..'; Is table of far away same island zone shortlist empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftTransportFarAwaySameIslandPlateauLandZoneDropShortlist]))..'; Lifetime transport count='..M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryTransport)) end
                if (M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftTransportIslandDropShortlist]) == false or M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftTransportFarAwaySameIslandPlateauLandZoneDropShortlist]) == false) and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryTransport) == 0 then
                    local refbQueuedTransport = 'M28QueuedTransport'
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have already queued up transport for this unit='..tostring(oUnitToUpgrade[refbQueuedTransport] or false)..'; M28Team.tTeamData[aiBrain.M28Team][M28Team.reftTransportIslandDropShortlist]='..repru(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftTransportIslandDropShortlist])..'; M28Team.tTeamData[aiBrain.M28Team][M28Team.reftTransportFarAwaySameIslandPlateauLandZoneDropShortlist]='..repru(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftTransportFarAwaySameIslandPlateauLandZoneDropShortlist])) end

                    if not(oUnitToUpgrade[refbQueuedTransport]) then
                        --Havent built any transports yet so build a T1 transport before we upgrade to T2 air
                        --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition,           oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
                        local sTransportID = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryTransport, oUnitToUpgrade)
                        if sTransportID then
                            oUnitToUpgrade[refbQueuedTransport] = true
                            M28Orders.IssueTrackedFactoryBuild(oUnitToUpgrade, sTransportID, false, 'PreUp')
                            if bDebugMessages == true then LOG(sFunctionRef..': Will queue up a transport for factory '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)) end
                        end
                    end
                end
            elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory * categories.TECH2 + M28UnitInfo.refCategoryAirFactory * categories.TECH2, oUnitToUpgrade.UnitId) and aiBrain[refiOurHighestFactoryTechLevel] <= 2 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer - categories.TECH1) <= 5 then
                --About to go for T3 factory but have hardl yany engineers so queue up an extra one
                --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition,                oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
                local sEngiID = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryEngineer, oUnitToUpgrade)
                if sEngiID then
                    M28Orders.IssueTrackedFactoryBuild(oUnitToUpgrade, sEngiID, false, 'PreUp')
                end
                if bDebugMessages == true then LOG(sFunctionRef..': About to go to T3 on factory '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)..' but only have '..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer - categories.TECH1)..' T2 plus engis so will queue up another engi before the upgrade. sEngiID='..(sEngiID or 'nil')) end
            end

            --Issue upgrade
            M28Orders.IssueTrackedUpgrade(oUnitToUpgrade, sUpgradeID, bAddToExistingQueue)
        end

        --Clear any pausing of the unit
        oUnitToUpgrade:SetPaused(false)
        oUnitToUpgrade[M28UnitInfo.refbPaused] = false
        if bDebugMessages == true then LOG(sFunctionRef..': Just set paused to false for unit '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)) end

        if bUpdateUpgradeTracker then
            M28Team.UpdateUpgradeTrackingOfUnit(oUnitToUpgrade, false, sUpgradeID)
        end
    else
        --Dont have an upgrade ID; if the unit has an UpgradesTo value in the blueprint and that unit is restricted, then dont show an error
        local sExpectedUpgradeID = oUnitToUpgrade:GetBlueprint().General.UpgradesTo
        if sExpectedUpgradeID and M28UnitInfo.IsUnitRestricted(sExpectedUpgradeID, oUnitToUpgrade:GetAIBrain():GetArmyIndex()) then
            --Restricted e.g. due to campaign or other settings
        else
            M28Utilities.ErrorHandler('Dont have a valid upgrade ID; UnitID=' .. (oUnitToUpgrade.UnitId or 'nil')..'; sExpectedUpgradeID='..(sExpectedUpgradeID or 'nil'))
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetBestUnitToUpgrade(toPotentialUnits, bPrioritiseFactoryHQ)
    --Assumes have already checked units are valid/not upgrading and factored in whether safe or not already, so just need to do distance type check
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBestUnitToUpgrade'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iClosestUnitToBase = 100000
    local oClosestUnitToBase
    local iCurModDist
    local sUnitToUpgradeTo
    for iUnit, oUnit in toPotentialUnits do
        iCurModDist = M28Map.GetModDistanceFromStart(oUnit:GetAIBrain(), oUnit:GetPosition(), false)
        if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurModDist before adjust='..iCurModDist..'; iClosestUnitToBase='..iClosestUnitToBase..'; bPrioritiseFactoryHQ='..tostring(bPrioritiseFactoryHQ or false)..'; Unit upgrades to='..(oUnit:GetBlueprint().General.UpgradesTo or 'nil')..'; length of string='..string.len(sUnitToUpgradeTo or '')..'; Is UpgradesTo a blank string='..tostring(sUnitToUpgradeTo == '')) end
        if bPrioritiseFactoryHQ and not(EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnit.UnitId)) then iCurModDist = iCurModDist + 1000 end
        if iCurModDist < iClosestUnitToBase then
            --Check it can upgrade
            sUnitToUpgradeTo = oUnit:GetBlueprint().General.UpgradesTo
            if sUnitToUpgradeTo and not(sUnitToUpgradeTo == '') and not(M28UnitInfo.IsUnitRestricted(sUnitToUpgradeTo, oUnit:GetAIBrain():GetArmyIndex())) then
                if bDebugMessages == true then LOG(sFunctionRef..': Updating oClosestUnitToBase to be this unit') end
                iClosestUnitToBase = iCurModDist
                oClosestUnitToBase = oUnit
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Best unit to upgrade was '..(oClosestUnitToBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestUnitToBase) or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oClosestUnitToBase
end

function UpdateZoneM28AllMexByTech(aiBrain, iPlateauOrZero, iLandOrWaterZone, oOptionalUnitThatDied, iOptionalWait)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateZoneM28AllMexByTech'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tLZOrWZTeamData
    local tLZOrWZData
    if iPlateauOrZero == 0 then
        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][aiBrain.M28Team]
    else
        tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
    end
    if iOptionalWait then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(iOptionalWait)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    tLZOrWZTeamData[M28Map.subrefMexCountByTech] = {[1]=0,[2]=0,[3]=0} --starting point
    if bDebugMessages == true then LOG(sFunctionRef..': Time of game='..GetGameTimeSeconds()..'; Is table of allied units for iPlateauOrZero '..iPlateauOrZero..' iLandOrWaterZone '..iLandOrWaterZone..' empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        local tAllMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        --Update list of allied mex units in this LZ in case some of the mexes are dead now
        --UpdateUnitPositionsAndLandZone(aiBrain, tUnits, iTeam,    iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZOrWZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
        if iPlateauOrZero > 0 then
            M28Land.UpdateUnitPositionsAndLandZone(aiBrain, tAllMexes, aiBrain.M28Team, iPlateauOrZero, iLandOrWaterZone,            false)
        else
            M28Navy.UpdateUnitPositionsAndWaterZone(aiBrain, tAllMexes, aiBrain.M28Team, iLandOrWaterZone, false, false, tLZOrWZTeamData, false, false)
        end

        local tMexesByTech = {}
        local iMexCount = 0
        tMexesByTech[1] = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex * categories.TECH1, tAllMexes)
        tMexesByTech[2] = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex * categories.TECH2, tAllMexes)
        tMexesByTech[3] = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex * categories.TECH3, tAllMexes)
        if bDebugMessages == true then LOG(sFunctionRef..': oOptionalUnitThatDied='..(oOptionalUnitThatDied.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oOptionalUnitThatDied) or 'nil')..'; Is tAllMexes empty='..tostring(M28Utilities.IsTableEmpty(tAllMexes))) end
        local tiRecordedMexPositionsXZ = {} --Finding issues with an upgrading mex that completes having both the original mex and the upgraded mex for a period of time; if are upgrading multiple in a zone at the same time, this can lead to too many mexes being recorded for brief moment
        for iTech = 3, 1, -1 do
            if bDebugMessages == true then LOG(sFunctionRef..': Updating for iTech='..iTech..'; Is table of mexes by tech empty='..tostring(M28Utilities.IsTableEmpty(tMexesByTech[iTech]))) end
            if M28Utilities.IsTableEmpty(tMexesByTech[iTech]) == false then
                for iMex, oCurMex in tMexesByTech[iTech] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Plateau='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; oCurMex='..oCurMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oCurMex)..'; Unit state='..M28UnitInfo.GetUnitState(oCurMex)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oCurMex))..'; Position='..repru(oCurMex:GetPosition())..'; iTech='..iTech..'; iMexCount pre increase='..iMexCount..'; tLZOrWZTeamData[M28Map.subrefMexCountByTech] pre increase='..repru(tLZOrWZTeamData[M28Map.subrefMexCountByTech])) end
                    if oCurMex:GetAIBrain().M28AI and M28UnitInfo.IsUnitValid(oCurMex) and oCurMex:GetFractionComplete() == 1 and not(oOptionalUnitThatDied == oCurMex) then
                        if iTech == 3 or not(tiRecordedMexPositionsXZ[oCurMex:GetPosition()[1]]) or not(tiRecordedMexPositionsXZ[oCurMex:GetPosition()[1]][oCurMex:GetPosition()[3]]) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding iMex '..iMex..'; oCurMex='..oCurMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oCurMex)..' to mex count, Unit state='..M28UnitInfo.GetUnitState(oCurMex)..'; Position='..repru(oCurMex:GetPosition())) end
                            tLZOrWZTeamData[M28Map.subrefMexCountByTech][iTech] = tLZOrWZTeamData[M28Map.subrefMexCountByTech][iTech] + 1
                            if not(tiRecordedMexPositionsXZ[oCurMex:GetPosition()[1]]) then tiRecordedMexPositionsXZ[oCurMex:GetPosition()[1]] = {} end
                            tiRecordedMexPositionsXZ[oCurMex:GetPosition()[1]][oCurMex:GetPosition()[3]] = true
                            iMexCount = iMexCount + 1
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished updating mex count, tLZOrWZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZOrWZTeamData[M28Map.subrefMexCountByTech])..'; iMexCount='..iMexCount..'; Table size of mex locations for this LZ='..table.getn( M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZMexLocations])..'; iMexCount from this function='..iMexCount..'; iOptionalWait='..(iOptionalWait or 'nil')..'; tiRecordedMexPositionsXZ='..repru(tiRecordedMexPositionsXZ)) end
        --If have somehow ended up with more mexes than there are locations, then redo the check in 1 second
        if iMexCount > 0 and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZMexLocations]) == false and iMexCount > table.getn( tLZOrWZData[M28Map.subrefLZMexLocations]) then
            if (iOptionalWait or 0) >= 10 then
                M28Utilities.ErrorHandler('Somehow we have more mexes than we should even after waiting '..iOptionalWait..' first, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; iMexCount='..iMexCount..'; tLZOrWZTeamData[M28Map.subrefMexCountByTech]='..reprs(tLZOrWZTeamData[M28Map.subrefMexCountByTech]))
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Have an inconsistent number of mexes so will call this function again with a wait, time='..GetGameTimeSeconds()) end
            ForkThread(UpdateZoneM28AllMexByTech, aiBrain, iPlateauOrZero, iLandOrWaterZone, oOptionalUnitThatDied, 15)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateZoneM28MexByTechCount(oMexJustBuiltOrDied, bJustDied, iOptionalWait)
    --Call via fork thread on mex creation due to potential timing issue with an upgrading mex being destroyed and replaced with the new (upgraded) mex
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateZoneM28MexByTechCount'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if oMexJustBuiltOrDied.GetAIBrain then
        local aiBrain = oMexJustBuiltOrDied:GetAIBrain()
        if aiBrain.M28AI then
            local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oMexJustBuiltOrDied:GetPosition())
            --should be called whenever a mex is created or destroyed in a land zone; ideally call via fork thread so reduced risk of it being called inbetween a mex say upgrading from one to another and being claled before both the creation and destroy events have happened
            if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; oMexJustBuiltOrDied='..(oMexJustBuiltOrDied.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oMexJustBuiltOrDied) or 'nil')..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Mex position='..repru(oMexJustBuiltOrDied:GetPosition())..'; iMapWaterHeight='..M28Map.iMapWaterHeight..'; iOptionalWait='..(iOptionalWait or 'nil')..'; bJustDied='..tostring(bJustDied or false)) end
            if (iLandOrWaterZone or 0) > 0 then
                if not(iOptionalWait) then
                    if bJustDied then
                        UpdateZoneM28AllMexByTech(aiBrain, iPlateauOrZero, iLandOrWaterZone, oMexJustBuiltOrDied)
                    else
                        UpdateZoneM28AllMexByTech(aiBrain, iPlateauOrZero, iLandOrWaterZone, nil)
                    end
                else
                    if bJustDied then
                        ForkThread(UpdateZoneM28AllMexByTech, aiBrain, iPlateauOrZero, iLandOrWaterZone, oMexJustBuiltOrDied, iOptionalWait)
                    else
                        ForkThread(UpdateZoneM28AllMexByTech, aiBrain, iPlateauOrZero, iLandOrWaterZone, nil, iOptionalWait)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function FindAndUpgradeUnitOfCategory(aiBrain, iCategoryWanted, iOptionalMinUnitsToHaveBuilt)
    --e.g. intended for upgrading factory HQs, subject to CheckIfNeedMoreEngineersOrSnipeUnitsBeforeUpgrading
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'FindAndUpgradeUnitOfCategory'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local tUnitsOfCategory = aiBrain:GetListOfUnits(iCategoryWanted, false, true)
    if M28Utilities.IsTableEmpty(tUnitsOfCategory) == false then
        local tUnitsToSearch = {}
        local tUnsafeUnitsOfCategory = {}
        local iCurPlateau, iCurLZ
        for iUnit, oUnit in tUnitsOfCategory do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by brain '..oUnit:GetAIBrain().Nickname..'; Do we want more engis before upgrading='..tostring(M28Conditions.CheckIfNeedMoreEngineersOrSnipeUnitsBeforeUpgrading(oUnit))) end
            if not(M28Conditions.CheckIfNeedMoreEngineersOrSnipeUnitsBeforeUpgrading(oUnit)) then
                if oUnit:GetFractionComplete() == 1 and not(oUnit:IsUnitState('Upgrading')) and not(oUnit.Dead) then
                    if not(iOptionalMinUnitsToHaveBuilt) or oUnit[M28Factory.refiTotalBuildCount] >= iOptionalMinUnitsToHaveBuilt then
                        --Are we in a safe land zone?
                        iCurPlateau, iCurLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                        local tLZTeamData = M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLZ][M28Map.subrefLZTeamData][aiBrain.M28Team]
                        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] then
                            table.insert(tUnsafeUnitsOfCategory, oUnit)
                        else
                            table.insert(tUnitsToSearch, oUnit)
                        end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tUnitsToSearch) then tUnitsToSearch = tUnsafeUnitsOfCategory end
        if M28Utilities.IsTableEmpty(tUnitsToSearch) == false then
            local iCurDist
            local iClosestDist = 100000
            local oClosestUnit
            if bDebugMessages == true then LOG(sFunctionRef..': About to consider '..table.getn(tUnitsToSearch)..' potential units to upgrade, will pick the closest one') end
            for iUnit, oUnit in tUnitsToSearch do
                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()])
                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..(oUnit.UnitId or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; iCurDist='..iCurDist) end
                if iCurDist < iClosestDist then
                    iClosestDist = iCurDist
                    oClosestUnit = oUnit
                end
            end
            if oClosestUnit then
                if bDebugMessages == true then LOG(sFunctionRef..': WIll try and upgrade oClosestUnit '..oClosestUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestUnit)..'; Fraction complete='..oClosestUnit:GetFractionComplete()..'; Unit state='..M28UnitInfo.GetUnitState(oClosestUnit)) end
                UpgradeUnit(oClosestUnit, true) --Will queue up transport or engineer for factories as well as figuring out whether to upgrade a support factory or an HQ
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateFactoryCountForFactoryKilledOrBuilt(oFactory, bIsDead)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateFactoryCountForFactoryKilledOrBuilt'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iAdjust = 0
    local sTrackerRef = 'M28RecordedCount'
    if bIsDead then
        if oFactory[sTrackerRef] then
            iAdjust = -1
            oFactory[sTrackerRef] = false
        end
    else
        if not(oFactory[sTrackerRef]) then
            iAdjust = 1
            oFactory[sTrackerRef] = true
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Near start, Time='..GetGameTimeSeconds()..'; iAdjust='..iAdjust..'; bIsDead='..tostring(bIsDead or false)..'; oFactory='..(oFactory.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oFactory) or 'nil')) end
    if not(iAdjust == 0) then
        local iFactoryType, iFactoryCategory = M28UnitInfo.GetFactoryType(oFactory)
        if bDebugMessages == true then LOG(sFunctionRef..': iFactoryType='..iFactoryType..'; iTeam='..oFactory:GetAIBrain().M28Team..'; Brain='..oFactory:GetAIBrain().Nickname..'; Team factory count by type before update='..(M28Team.tTeamData[oFactory:GetAIBrain().M28Team][M28Team.subrefiTotalFactoryCountByType][iFactoryType] or 'nil')) end
        M28Team.tTeamData[oFactory:GetAIBrain().M28Team][M28Team.subrefiTotalFactoryCountByType][iFactoryType] = math.max(0, M28Team.tTeamData[oFactory:GetAIBrain().M28Team][M28Team.subrefiTotalFactoryCountByType][iFactoryType] + iAdjust)
        if bDebugMessages == true then LOG(sFunctionRef..': Factory count after update='..M28Team.tTeamData[oFactory:GetAIBrain().M28Team][M28Team.subrefiTotalFactoryCountByType][iFactoryType]) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateHighestFactoryTechLevelForBuiltUnit(oUnitJustBuilt)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateHighestFactoryTechLevelForBuiltUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Checking if just built a factory HQ, Have just built unit '..oUnitJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitJustBuilt)..'; Fraction complete='..oUnitJustBuilt:GetFractionComplete()..'; Is it a factory HQ='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnitJustBuilt.UnitId))) end

    --Update total factory count


    if oUnitJustBuilt:GetFractionComplete() == 1 and EntityCategoryContains(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryQuantumGateway, oUnitJustBuilt.UnitId) then
        --Update factory count
        if bDebugMessages == true then LOG(sFunctionRef..': Just built factory or gateway, if we have built an HQ then will run more code') end
        UpdateFactoryCountForFactoryKilledOrBuilt(oUnitJustBuilt, false)
        --Plateau factory - set flag to not pause if it's the first factory
        if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnitJustBuilt.UnitId) then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnitJustBuilt:GetPosition())
            if iPlateau and iLandZone then
                local aiBrain = oUnitJustBuilt:GetAIBrain()
                local iTeam = aiBrain.M28Team
                local tFactoryLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                local tFactoryLZTeamData = tFactoryLZData[M28Map.subrefLZTeamData][iTeam]
                --Are we in the same island as a friendly start position?
                local bHaveStartInSameIslandOrLOUD = false
                if not(M28Utilities.bLoudModActive) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iPlateau]) == false then
                    for iStartLandZone, _ in M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iPlateau] do
                        local tStartLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iStartLandZone]
                        if tStartLZData[M28Map.subrefLZIslandRef] == tFactoryLZData[M28Map.subrefLZIslandRef] then
                            bHaveStartInSameIslandOrLOUD = true
                            break
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Just built land fac '..oUnitJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitJustBuilt)..' in P'..iPlateau..'Z'..iLandZone..'; bHaveStartInSameIslandOrLOUD='..tostring(bHaveStartInSameIslandOrLOUD)) end
                if not(bHaveStartInSameIslandOrLOUD) then
                    local bHaveOtherFactoriesOfSameTech = false
                    if M28Utilities.IsTableEmpty(tFactoryLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                        local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oUnitJustBuilt)
                        local iSearchCategory
                        if iFactoryTechLevel == 1 then iSearchCategory = M28UnitInfo.refCategoryLandFactory
                        elseif iFactoryTechLevel == 2 then iSearchCategory = M28UnitInfo.refCategoryLandFactory - categories.TECH1
                        else iSearchCategory = M28UnitInfo.refCategoryLandFactory * categories.TECH3
                        end

                        local tFactoriesOfSameTech = EntityCategoryFilterDown(iSearchCategory, tFactoryLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                        if M28Utilities.IsTableEmpty(tFactoriesOfSameTech) == false then
                            for iExistingFactory, oExistingFactory in tFactoriesOfSameTech do
                                if M28UnitInfo.IsUnitValid(oExistingFactory) and not(oExistingFactory == oUnitJustBuilt) and oExistingFactory:GetFractionComplete() == 1 then
                                    bHaveOtherFactoriesOfSameTech = true
                                    break
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': bHaveOtherFactoriesOfSameTech='..tostring(bHaveOtherFactoriesOfSameTech)..'; Mex count for factory island='..(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tFactoryLZData[M28Map.subrefLZIslandRef]] or 0)..'; Mod dist%='..tFactoryLZTeamData[M28Map.refiModDistancePercent]) end
                    if not(bHaveOtherFactoriesOfSameTech) then
                        --Do we have enough mexes to warrant always building from this factory?
                        local bHaveEnoughMexes = false
                        if (tFactoryLZData[M28Map.subrefLZMexCount] or 0) >= 3 or (tFactoryLZData[M28Map.subrefLZIslandRef] and ((M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tFactoryLZData[M28Map.subrefLZIslandRef]] or 0) >= 7 or ((M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tFactoryLZData[M28Map.subrefLZIslandRef]] or 0) >= 5 and tFactoryLZTeamData[M28Map.refiModDistancePercent] >= 0.2))) or M28Utilities.bLoudModActive and (tFactoryLZData[M28Map.subrefLZMexCount] or 0) >= 2 then
                            bHaveEnoughMexes = true
                        elseif M28Utilities.IsTableEmpty(tFactoryLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                            local iNearbyMexCount = (tFactoryLZData[M28Map.subrefLZMexCount] or 0)
                            for _, iAdjLZ in tFactoryLZData[M28Map.subrefLZAdjacentLandZones] do
                                local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                                iNearbyMexCount = iNearbyMexCount + (tAdjLZData[M28Map.subrefLZMexCount] or 0)
                            end
                            if iNearbyMexCount >= 5 then
                                bHaveEnoughMexes = true
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iNearbyMexCount='..iNearbyMexCount..'; bHaveEnoughMexes='..tostring(bHaveEnoughMexes)) end
                        end
                        if bHaveEnoughMexes then
                            --Set flag of any other factories in this zone to false
                            if M28Utilities.IsTableEmpty(tFactoryLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                local tAllLandFacsInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tFactoryLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                if M28Utilities.IsTableEmpty(tAllLandFacsInZone) == false then
                                    for iFactory, oFactory in tAllLandFacsInZone do
                                        if not(oFactory == oUnitJustBuilt) then
                                            oFactory[M28Factory.refbPrimaryHighMexIslandFactory] = false
                                        end
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Just set land factory '..oUnitJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitJustBuilt)..' to be the primary factory for P'..iPlateau..'Z'..iLandZone..'at time='..GetGameTimeSeconds()) end
                            oUnitJustBuilt[M28Factory.refbPrimaryHighMexIslandFactory] = true
                        end
                    end
                end
            end
        end

        if EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnitJustBuilt.UnitId) then
            local iUnitTechLevel = M28UnitInfo.GetUnitTechLevel(oUnitJustBuilt)
            local sFactoryRef
            if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnitJustBuilt.UnitId) then sFactoryRef = refiOurHighestLandFactoryTech
            elseif EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oUnitJustBuilt.UnitId) then sFactoryRef = refiOurHighestAirFactoryTech
            elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oUnitJustBuilt.UnitId) then sFactoryRef = refiOurHighestNavalFactoryTech
            else M28Utilities.ErrorHandler('Unrecognised factory type')
            end
            local aiBrain = oUnitJustBuilt:GetAIBrain()
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if factory HQ is a higher tech than we already have, sFactoryRef='..sFactoryRef..'; iUnitTechLevel='..iUnitTechLevel..'; aiBrain[sFactoryRef]='..aiBrain[sFactoryRef]) end
            if iUnitTechLevel > aiBrain[sFactoryRef] then
                aiBrain[sFactoryRef] = math.max(aiBrain[sFactoryRef], iUnitTechLevel)
                aiBrain[refiOurHighestFactoryTechLevel] = math.max(iUnitTechLevel, aiBrain[refiOurHighestFactoryTechLevel])
                --Update team details
                M28Team.UpdateTeamHighestAndLowestFactories(aiBrain.M28Team)
                M28Team.CheckForSubteamFactoryChange(oUnitJustBuilt, true)
            else
                --Still consider updating subteam, as e.g. we may have T3 UEF HQ and have just built T3 Seraphim HQ
                M28Team.CheckForSubteamFactoryChange(oUnitJustBuilt, true)
            end
        elseif EntityCategoryContains(M28UnitInfo.refCategoryQuantumGateway, oUnitJustBuilt.UnitId) then
            if bDebugMessages == true then LOG(sFunctionRef..': Have built a gateway, will update subteam factory change') end
            M28Team.CheckForSubteamFactoryChange(oUnitJustBuilt, true)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateHighestFactoryTechLevelForDestroyedUnit(oUnitJustDestroyed)
    --Dont call via forkthread as causes issues with the unit being removed
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateHighestFactoryTechLevelForDestroyedUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if EntityCategoryContains(M28UnitInfo.refCategoryFactory, oUnitJustDestroyed.UnitId) then
        UpdateFactoryCountForFactoryKilledOrBuilt(oUnitJustDestroyed, true)
        if bDebugMessages == true then LOG(sFunctionRef..': Factory was destroyed, oUnitJustDestroyed='..oUnitJustDestroyed.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitJustDestroyed)..'; is this an HQ factory='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnitJustDestroyed.UnitId))) end
        if EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnitJustDestroyed.UnitId) then
            local aiBrain = oUnitJustDestroyed:GetAIBrain()
            local iUnitTechLevel = M28UnitInfo.GetUnitTechLevel(oUnitJustDestroyed)
            if bDebugMessages == true then LOG(sFunctionRef..': iUnitTechLevel='..iUnitTechLevel..'; owned by brain '..aiBrain.Nickname) end
            function UnitsStillValid(iCategory)
                local tUnitsOfType = aiBrain:GetListOfUnits(iCategory, false, true)
                if M28Utilities.IsTableEmpty(tUnitsOfType) == false then
                    for iUnit, oUnit in tUnitsOfType do
                        if not(oUnit == oUnitJustDestroyed) and M28UnitInfo.IsUnitValid(oUnit) then
                            return true
                        end
                    end
                end
                return false
            end
            local iCategoryBeingConsidered
            if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnitJustDestroyed.UnitId) then
                if iUnitTechLevel >= (aiBrain[refiOurHighestLandFactoryTech] or 0) then
                    aiBrain[refiOurHighestLandFactoryTech] = 0
                    for iTechLevel = 3, 1, -1 do
                        iCategoryBeingConsidered = M28UnitInfo.refCategoryLandFactory * M28UnitInfo.ConvertTechLevelToCategory(iTechLevel) - categories.SUPPORTFACTORY
                        if aiBrain:GetCurrentUnits(iCategoryBeingConsidered) > 0 and UnitsStillValid(iCategoryBeingConsidered) then
                            --Check these units are all still valid
                            aiBrain[refiOurHighestLandFactoryTech] = iTechLevel
                            break
                        end
                    end
                end
            elseif EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oUnitJustDestroyed.UnitId) then
                if bDebugMessages == true then LOG(sFunctionRef..': Air fac was destroyed, aiBrain[refiOurHighestAirFactoryTech]='..(aiBrain[refiOurHighestAirFactoryTech] or 'nil')..'; iUnitTechLevel='..iUnitTechLevel) end
                if iUnitTechLevel >= aiBrain[refiOurHighestAirFactoryTech] then
                    aiBrain[refiOurHighestAirFactoryTech] = 0
                    for iTechLevel = 3, 1, -1 do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iTechLevel='..iTechLevel..'; Cur units owned by this brain of that tech level excl support factory='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory * M28UnitInfo.ConvertTechLevelToCategory(iTechLevel) - categories.SUPPORTFACTORY)) end
                        iCategoryBeingConsidered = M28UnitInfo.refCategoryAirFactory * M28UnitInfo.ConvertTechLevelToCategory(iTechLevel) - categories.SUPPORTFACTORY
                        if aiBrain:GetCurrentUnits(iCategoryBeingConsidered) > 0 and UnitsStillValid(iCategoryBeingConsidered) then
                            aiBrain[refiOurHighestAirFactoryTech] = iTechLevel
                            break
                        end
                    end
                end
            elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oUnitJustDestroyed.UnitId) then
                if iUnitTechLevel >= aiBrain[refiOurHighestNavalFactoryTech] then
                    aiBrain[refiOurHighestNavalFactoryTech] = 0
                    for iTechLevel = 3, 1, -1 do
                        iCategoryBeingConsidered = M28UnitInfo.refCategoryNavalFactory * M28UnitInfo.ConvertTechLevelToCategory(iTechLevel) - categories.SUPPORTFACTORY
                        if aiBrain:GetCurrentUnits(iCategoryBeingConsidered) > 0 and UnitsStillValid(iCategoryBeingConsidered) then
                            aiBrain[refiOurHighestNavalFactoryTech] = iTechLevel
                            break
                        end
                    end
                end
            else M28Utilities.ErrorHandler('Unrecognised factory type')
            end

            --Updated highest factory type across all types
            aiBrain[refiOurHighestFactoryTechLevel] = math.max(aiBrain[refiOurHighestLandFactoryTech], aiBrain[refiOurHighestAirFactoryTech], aiBrain[refiOurHighestNavalFactoryTech])

            --Update team details
            M28Team.UpdateTeamHighestAndLowestFactories(aiBrain.M28Team)
            M28Team.CheckForSubteamFactoryChange(oUnitJustDestroyed, false)
        elseif EntityCategoryContains(M28UnitInfo.refCategoryQuantumGateway, oUnitJustDestroyed.UnitId) then
            M28Team.CheckForSubteamFactoryChange(oUnitJustDestroyed, false)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Near end of code, aiBrain[refiOurHighestAirFactoryTech]='..oUnitJustDestroyed:GetAIBrain()[refiOurHighestAirFactoryTech]..'; aiBrain[refiOurHighestLandFactoryTech]='..oUnitJustDestroyed:GetAIBrain()[refiOurHighestLandFactoryTech]..'; aiBrain[refiOurHighestNavalFactoryTech]='..oUnitJustDestroyed:GetAIBrain()[refiOurHighestNavalFactoryTech]..'; aiBrain[refiOurHighestFactoryTechLevel]='..oUnitJustDestroyed:GetAIBrain()[refiOurHighestFactoryTechLevel]) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateMassStorageAdjacencyValues(oStorage, bDestroyed)
    --Updates gross income for the mass storage
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateMassStorageAdjacencyValues'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iMassChange = -(oStorage[refiStorageMassAdjacencyBonus] or 0)
    local aiBrain = oStorage:GetAIBrain()

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Time='..GetGameTimeSeconds()..'; About to update for oStorage='..oStorage.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStorage)..' owned by brain '..aiBrain.Nickname..'; bDestroyed='..tostring(bDestroyed or false)..'; oStorage[refiStorageMassAdjacencyBonus]='..(oStorage[refiStorageMassAdjacencyBonus] or 'nil')..'; aiBrain[refiGrossMassBaseIncome]='..(aiBrain[refiGrossMassBaseIncome] or 'nil')) end
    if not(bDestroyed) then
        oStorage[refiStorageMassAdjacencyBonus] = 0
        if oStorage:GetFractionComplete() >= 1 then
            local iBaseMassGen
            local iAIxMod = 1
            local iAdjacencyMassGen
            local oGenBP
            local iBPMassGen
            local iGenUnitSize
            local iStorageSize = M28UnitInfo.GetBuildingSize(oStorage.UnitId)
            --Adjust for AIx
            if aiBrain.CheatEnabled then
                iAIxMod = tonumber(ScenarioInfo.Options.CheatMult or 1.5)
            end
            oStorage[refiStorageMassAdjacencyBonus] = 0
            --Get all adjacent mexes
            if bDebugMessages == true then LOG(sFunctionRef..': iAIxMod='..iAIxMod..'; Is table of adjacent units empty='..tostring(M28Utilities.IsTableEmpty(oStorage.AdjacentUnits))) end
            if M28Utilities.IsTableEmpty(oStorage.AdjacentUnits) == false then
                --Cant use filterdown a doesnt work with .adjacentunits
                for iMassGenUnit, oMassGenUnit in oStorage.AdjacentUnits do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oMassGenUnit='..oMassGenUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMassGenUnit)..' owned by '..oMassGenUnit:GetAIBrain().Nickname) end
                    if EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryMassFab, oMassGenUnit.UnitId) and oMassGenUnit:GetAIBrain() == aiBrain and M28UnitInfo.IsUnitValid(oMassGenUnit) then --Wont get adjacency unless are on the same team
                        oGenBP = oMassGenUnit:GetBlueprint()
                        iBaseMassGen = (oGenBP.Economy.ProductionPerSecondMass or 0)
                        if iBaseMassGen > 0 then
                            iGenUnitSize = M28UnitInfo.GetBuildingSize(oMassGenUnit.UnitId)
                            --Mass storage adjacency - if covers all of the resource generation on all 4 sides, gives a 50% boost, so is giving 12.5% boost for each side fully covered
                            --Also want to measure in mass per tick not per second, so *0.0125
                            iAdjacencyMassGen = iBaseMassGen * iAIxMod * 0.0125 * math.min(1, iStorageSize / iGenUnitSize)
                            oStorage[refiStorageMassAdjacencyBonus] = oStorage[refiStorageMassAdjacencyBonus] + iAdjacencyMassGen
                            iMassChange = iMassChange + iAdjacencyMassGen
                            if bDebugMessages == true then LOG(sFunctionRef..': Are adjacent to oMassGenUnit='..(oMassGenUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMassGenUnit)..'; iAdjacencyMassGen for this unit='..(iAdjacencyMassGen or 'nil'))) end
                        end
                    end
                end
            end
        end
    end

    aiBrain[refiGrossMassBaseIncome] = (aiBrain[refiGrossMassBaseIncome] or 0) + iMassChange
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iMassChange='..iMassChange..'; aiBrain[refiGrossMassBaseIncome]='..aiBrain[refiGrossMassBaseIncome]) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderHydroUpgradeLoop(oUnit)
    --Every 10s consider upgrading unit
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderHydroUpgradeLoop'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Special upgrade monitor already active='..tostring(oUnit[refbSpecialUpgradeMonitor] or false)..'; Unit owner='..oUnit:GetAIBrain().Nickname..'; Time='..GetGameTimeSeconds()) end
    if not(oUnit[refbSpecialUpgradeMonitor]) then
        --Does the blueprint have an upgrade option?
        local oBP = oUnit:GetBlueprint()
        if bDebugMessages == true then LOG(sFunctionRef..': Unit upgrades to='..(oBP.General.UpgradesTo or 'nil')..'; Does this equal empty string='..tostring(oBP.General.UpgradesTo == '')) end
        if oBP.General.UpgradesTo and not(oBP.General.UpgradesTo == '') then
            oUnit[refbSpecialUpgradeMonitor] = true
            local aiBrain = oUnit:GetAIBrain()
            local iTeam = aiBrain.M28Team
            local oUpgradedBP = __blueprints[oBP.General.UpgradesTo]
            if oUpgradedBP then
                local iBuildPower = oBP.Economy.BuildRate * aiBrain[refiBrainBuildRateMultiplier]
                local iBrainCount = M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]
                if bDebugMessages == true then LOG(sFunctionRef..': oUpgradedBP='..reprs(oUpgradedBP)) end
                local iMassPerTickWanted = 0.1 * (oUpgradedBP.Economy.BuildCostMass * iBuildPower / oUpgradedBP.Economy.BuildTime) * iBrainCount * 2
                local iEnergyPerTickWanted = 0.1 * (oUpgradedBP.Economy.BuildCostEnergy * iBuildPower / oUpgradedBP.Economy.BuildTime ) * iBrainCount * 2
                local iGrossMassPerTickAlternative = iMassPerTickWanted * 20
                local iGrossEnergyPerTickAlternative = iEnergyPerTickWanted * 20
                local iStoredMassAlternative = oUpgradedBP.Economy.BuildCostMass * 4

                if bDebugMessages == true then LOG(sFunctionRef..': iBuildPower='..iBuildPower..'; iMasPerTickWanted='..iMassPerTickWanted..'; iEnergyPerTickWanted='..iEnergyPerTickWanted) end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitSeconds(10)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                while M28UnitInfo.IsUnitValid(oUnit) do
                    if bDebugMessages == true then LOG(sFunctionRef..': Deciding if want to upgrade at time='..GetGameTimeSeconds()..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Brain='..aiBrain.Nickname..'; Want more power='..tostring(M28Conditions.WantMorePower(iTeam))..'; Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; iEnergyPerTickWanted='..iEnergyPerTickWanted..'; Net mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]..'; iMassPerTickWanted='..iMassPerTickWanted..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) end
                    if M28Conditions.WantMorePower(iTeam) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= iEnergyPerTickWanted or (iEnergyPerTickWanted > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= iGrossEnergyPerTickAlternative) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= iMassPerTickWanted or ((aiBrain:GetEconomyStored('MASS') >= iStoredMassAlternative and (aiBrain:GetEconomyStored('MASS') >= iStoredMassAlternative * 2 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= -1)) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= iGrossMassPerTickAlternative)))) then
                        UpgradeUnit(oUnit, false)
                        break
                    end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitSeconds(10)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                end
            elseif bDebugMessages == true then LOG(sFunctionRef..': Couldnt locate an actual blueprint')
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateGrossIncomeForUnit(oUnit, bDestroyed, bIgnoreEnhancements, iOptionalResourceModAdjustmentOverride)
    --iOptionalResourceModAdjustmentOverride - intended for use with AIX overwhelm where we have already recorded a unit but at the 'wrong' resource rate

    --Logs are enabled below
    if oUnit.GetAIBrain and EntityCategoryContains(M28UnitInfo.refCategoryResourceUnit + M28UnitInfo.refCategoryMassStorage, oUnit.UnitId) then
        --Does the unit have an M28 aiBrain?
        local aiBrain = oUnit:GetAIBrain()
        if aiBrain.M28AI then
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            local sFunctionRef = 'UpdateGrossIncomeForUnit'
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


            if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..' oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bDestroyed='..tostring(bDestroyed or false)..': Unit aiBrain='..oUnit:GetAIBrain().Nickname..'; Brain recorded for economy='..((oUnit[refoBrainRecordedForEconomy] or {'nil'}).Nickname or 'nil')..'; Fraction complete='..oUnit:GetFractionComplete()) end
            if oUnit:GetFractionComplete() < 1 then M28Utilities.ErrorHandler('Trying to update income for unit whose fraction isnt complete') end

            if (bDestroyed and oUnit[refoBrainRecordedForEconomy] == aiBrain) or (not(bDestroyed) and not(oUnit[refoBrainRecordedForEconomy] == aiBrain)) then
                local iMassGen
                local iEnergyGen
                if not(M28Utilities.bLoudModActive) and EntityCategoryContains(M28UnitInfo.refCategoryParagon, oUnit.UnitId) then
                    iMassGen = 10000 * 0.1
                    iEnergyGen = 1000000 * 0.1
                    if iOptionalResourceModAdjustmentOverride then
                        iMassGen = iMassGen * iOptionalResourceModAdjustmentOverride
                        iEnergyGen = iEnergyGen * iOptionalResourceModAdjustmentOverride
                    end
                    local iTeam = oUnit:GetAIBrain().M28Team
                    if bDestroyed then
                        local bRemainingParagon = false
                        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                            local tParagon = oBrain:GetListOfUnits(M28UnitInfo.refCategoryParagon, false, true)
                            if M28Utilities.IsTableEmpty(tParagon) == false then
                                for iParagon, oParagon in tParagon do
                                    if oParagon:GetFractionComplete() == 1 then
                                        bRemainingParagon = true
                                        break
                                    end
                                end
                            end
                            if bRemainingParagon then break end
                        end
                        oUnit:GetAIBrain()[refbBuiltParagon] = bRemainingParagon
                        M28Team.tTeamData[iTeam][M28Team.refbBuiltParagon] = bRemainingParagon
                    else
                        oUnit:GetAIBrain()[refbBuiltParagon] = true
                        M28Team.tTeamData[iTeam][M28Team.refbBuiltParagon] = true
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': We have a paragon that has been built or killed, setting mass gen and energy gen accordingly, iMassGen='..iMassGen) end
                else
                    local oBP = oUnit:GetBlueprint()
                    iMassGen = math.max(oBP.Economy.ProductionPerSecondMass or 0) * 0.1
                    iEnergyGen = math.max(oBP.Economy.ProductionPerSecondEnergy or 0) * 0.1
                    --Adjust for RAS upgrade
                    if bDebugMessages == true then LOG(sFunctionRef..': Is this an ACU or SACU='..tostring(EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oUnit.UnitId))) end
                    if not(bIgnoreEnhancements) and EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oUnit.UnitId) then
                        local iUpgradeMassPerSec = 0
                        local iUpgradeEnergyPerSec = 0

                        local tPossibleUpgrades = oBP.Enhancements
                        if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; is tPossibleUpgrades empty='..tostring(M28Utilities.IsTableEmpty(tPossibleUpgrades))) end
                        if M28Utilities.IsTableEmpty(tPossibleUpgrades) == false and oUnit.HasEnhancement then
                            local tbIncludedUpgrade = {}
                            for sCurUpgrade, tUpgrade in tPossibleUpgrades do
                                if oUnit:HasEnhancement(sCurUpgrade) then
                                    tbIncludedUpgrade[sCurUpgrade] = true
                                    iUpgradeMassPerSec = iUpgradeMassPerSec + (tUpgrade.ProductionPerSecondMass or 0)
                                    iUpgradeEnergyPerSec = iUpgradeEnergyPerSec + (tUpgrade.ProductionPerSecondEnergy or 0)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Unit has enhancement '..sCurUpgrade..'; tUpgrade.ProductionPerSecondMass='..(tUpgrade.ProductionPerSecondMass or 'nil')) end
                                end
                            end


                            --Include built in enhancements (i.e. RAS presets) as there is a delay with onbuilt units showing as having active enhancements
                            if oBP.EnhancementPresetAssigned.Enhancements then
                                for iCurUpgrade, sCurUpgrade in oBP.EnhancementPresetAssigned.Enhancements do
                                    if not(tbIncludedUpgrade[sCurUpgrade]) then
                                        iUpgradeMassPerSec = iUpgradeMassPerSec + (tPossibleUpgrades[sCurUpgrade].ProductionPerSecondMass or 0)
                                        iUpgradeEnergyPerSec = iUpgradeEnergyPerSec + (tPossibleUpgrades[sCurUpgrade].ProductionPerSecondEnergy or 0)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Unit has preset enhancement '..sCurUpgrade..'; tUpgrade.ProductionPerSecondMass='..(tPossibleUpgrades[sCurUpgrade].ProductionPerSecondMass or 'nil')..'; reprs='..reprs(tPossibleUpgrades[sCurUpgrade])) end
                                    end
                                end
                            end
                            --[[local activeEnhancements = SimUnitEnhancements[oUnit.EntityId]
                            if bDebugMessages == true then LOG(sFunctionRef..': Is activeEnhancements nil='..tostring(activeEnhancements == nil)) end
                            if activeEnhancements then
                                local presetEnhancements = oBP.EnhancementPresetAssigned.Enhancements
                                for _, enhName in activeEnhancements do
                                    if not(tbIncludedUpgrade[enhName]) then
                                        tbIncludedUpgrade[enhName] = true
                                        local enh = tPossibleUpgrades[enhName]
                                        iUpgradeMassPerSec = iUpgradeMassPerSec + (enh.ProductionPerSecondMass or 0)
                                        iUpgradeEnergyPerSec = iUpgradeEnergyPerSec + (enh.ProductionPerSecondEnergy or 0)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Unit has preset enhancement '..enhName..'; enh.ProductionPerSecondMass='..(enh.ProductionPerSecondMass or 'nil')) end
                                    end
                                end
                            end--]]
                        end
                        iMassGen = iMassGen + iUpgradeMassPerSec * 0.1
                        iEnergyGen = iEnergyGen + iUpgradeEnergyPerSec * 0.1
                        if bDebugMessages == true then LOG(sFunctionRef..': iUpgradeMassPerSec='..iUpgradeMassPerSec..'; iMassGen per tick='..iMassGen) end
                    end

                    --Mass storage - assume we are adjacent to a T2 mex as a basic approximation
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to check for mass storage, iMassGen='..iMassGen..'; iEnergyGen='..iEnergyGen..'; Does unit contain mass storage='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryMassStorage, oUnit.UnitId))) end
                    if iMassGen == 0 and iEnergyGen == 0 and EntityCategoryContains(M28UnitInfo.refCategoryMassStorage, oUnit.UnitId) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Dealing with mass storage so will update for adjacency value gained or lost') end
                        UpdateMassStorageAdjacencyValues(oUnit, bDestroyed) --Will update mass income values as part of this function
                    elseif iMassGen > 0 then
                        --Update adjacency values for any nearby mass storage
                        local tMexLocation = oUnit:GetPosition()
                        local rSearchRectangle = M28Utilities.GetRectAroundLocation(tMexLocation, 2.749) --If changing this also change M28Events and M28Engineer similar value
                        local tNearbyUnits = GetUnitsInRect(rSearchRectangle) --at 1.5 end up with storage thats not adjacent being gifted in some cases but not in others; at 1 none of it gets gifted; the mass storage should be exactly 2 from the mex; however even at 2.1, 2.25 and 2.499 had cases where the mex wasnt identified so will try 2.75 since distances can vary/be snapped to the nearest 0.5 I think
                        if bDebugMessages == true then LOG(sFunctionRef..': Checking if have any nearby units in a rectangle to this mex/mass fab, is tNearbyUnits empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnits))) end
                        if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                            local tNearbyStorage = EntityCategoryFilterDown(M28UnitInfo.refCategoryMassStorage, tNearbyUnits)
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby storage empty='..tostring(M28Utilities.IsTableEmpty(tNearbyStorage))) end
                            if M28Utilities.IsTableEmpty(tNearbyStorage) == false then
                                for iStorage, oStorage in tNearbyStorage do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have oStorage='..oStorage.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStorage)..'; will update if it is close to here, distance='..M28Utilities.GetDistanceBetweenPositions(oStorage:GetPosition(), tMexLocation)) end
                                    if M28Utilities.GetDistanceBetweenPositions(oStorage:GetPosition(), tMexLocation) <= 2.25 then
                                        --Cant fork thread or else lose the aiBrain info if were just destroyed
                                        UpdateMassStorageAdjacencyValues(oStorage, false)
                                    end
                                end
                            end
                        end
                    end

                    --Adjust for AIx
                    if aiBrain.CheatEnabled then
                        local iAIxMod = iOptionalResourceModAdjustmentOverride or tonumber(ScenarioInfo.Options.CheatMult or tostring(1.5))
                        iMassGen = iMassGen * iAIxMod
                        iEnergyGen = iEnergyGen * iAIxMod
                    end
                end
                if bDestroyed then
                    iMassGen = iMassGen * -1
                    iEnergyGen = iEnergyGen * -1
                    oUnit[refoBrainRecordedForEconomy] = nil
                    if bDebugMessages == true then LOG(sFunctionRef..': Unit destroyed so will reduce mass gen') end
                else
                    oUnit[refoBrainRecordedForEconomy] = aiBrain
                    --Set temporary flag that we have just built a lot of power (if we have)
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if should temporarily say we have enough power; iEnergyGen='..iEnergyGen..'; Gross energy='..(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossEnergy] or 'nil')..'; Net energy='..(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamNetEnergy] or 'nil')..'; Flag for lots of power='..tostring(M28Team.tTeamData[aiBrain.M28Team][M28Team.refbJustBuiltLotsOfPower] or false)) end
                    if iEnergyGen >= math.max(20, (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossEnergy] or 0) * 0.15, -(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamNetEnergy] or 0)) and not(M28Team.tTeamData[aiBrain.M28Team][M28Team.refbJustBuiltLotsOfPower]) then
                        M28Team.tTeamData[aiBrain.M28Team][M28Team.refbJustBuiltLotsOfPower] = true
                        M28Utilities.DelayChangeVariable(M28Team.tTeamData[aiBrain.M28Team], M28Team.refbJustBuiltLotsOfPower, false, 6)
                        if bDebugMessages == true then LOG(sFunctionRef..': Just built a lot of power so will temporarily say we dont need more power') end
                    end
                    --Update team eco values to factor in impact of this on any decisions made before the next team eco refresh
                    M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] = math.max(0, (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] or 0) + iMassGen)
                    M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamNetMass] = (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamNetMass] or 0) + iMassGen
                    M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossEnergy] = math.max(0, (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossEnergy] or 0) + iEnergyGen)
                    M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamNetEnergy] = (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamNetEnergy] or 0) + iEnergyGen
                end
                aiBrain[refiGrossEnergyBaseIncome] = math.max(0, (aiBrain[refiGrossEnergyBaseIncome] or 0) + iEnergyGen)
                aiBrain[refiNetEnergyBaseIncome] = (aiBrain[refiNetEnergyBaseIncome] or 0) + iEnergyGen
                aiBrain[refiGrossMassBaseIncome] = math.max(0, (aiBrain[refiGrossMassBaseIncome] or 0) + iMassGen)
                aiBrain[refiNetMassBaseIncome] = (aiBrain[refiNetMassBaseIncome] or 0) + iMassGen

                if iEnergyGen >= 25 then
                    ForkThread(ConsiderReclaimingPower, aiBrain.M28Team, oUnit)
                end

                --Upgrading hydro
                if not(bDestroyed) and EntityCategoryContains(M28UnitInfo.refCategoryHydro, oUnit.UnitId) then
                    ForkThread(ConsiderHydroUpgradeLoop,oUnit)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Updated gross and net resources for iMassGen='..iMassGen..'; iEnergyGen='..iEnergyGen..'; aiBrain[refiNetMassBaseIncome]='..aiBrain[refiNetMassBaseIncome]..'; aiBrain[refiGrossMassBaseIncome]='..aiBrain[refiGrossMassBaseIncome]) end
            end


            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        end
    end
end

function AdjustAIxOverwhelmRate()
    --Waits the indicated number of seconds and then adjusts the AIx overwhelm rate
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AdjustAIxOverwhelmRate'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iSecondsToWait = tonumber(ScenarioInfo.Options.M28OvwT) * 60
    local iRateAdjustment = tonumber(ScenarioInfo.Options.M28OvwR)
    local iLowerCap = 0.1
    local iUpperCap = 10.0
    if iRateAdjustment > 0 then iUpperCap = tonumber(ScenarioInfo.Options.M28OvwC)
    else iLowerCap = tonumber(ScenarioInfo.Options.M28OvwC)
    end

    if bDebugMessages == true then LOG(sFunctionRef..': near start of code, iSecondsToWait='..iSecondsToWait..'; ScenarioInfo.Options.M28OvwT='..ScenarioInfo.Options.M28OvwT..'; iRateAdjustment='..iRateAdjustment..'; ScenarioInfo.Options.M28OvwR='..ScenarioInfo.Options.M28OvwR..'; iLowerCap='..iLowerCap..'; iUpperCap='..iUpperCap) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitSeconds(iSecondsToWait)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(M28Overseer.tAllActiveM28Brains) == false then
        local bChangedModifier
        local iCurBuildModifier
        local iCurResourceModifier

        local bHaveIndividualAIBrainMods = false
        for iBrian, oBrain in M28Overseer.tAllActiveM28Brains do
            if oBrain.CheatValue then bHaveIndividualAIBrainMods = true break end
        end

        while M28Utilities.bM28AIInGame do
            --Set the new modifier
            bChangedModifier = false
            iCurResourceModifier = tonumber(ScenarioInfo.Options.CheatMult or tostring(1.5))
            iCurBuildModifier = tonumber(ScenarioInfo.Options.BuildMult or tostring(1.5))

            if iRateAdjustment > 0 then
                if iCurResourceModifier < iUpperCap or iCurBuildModifier < iUpperCap then
                    iCurResourceModifier = math.min(iCurResourceModifier + iRateAdjustment, iUpperCap)
                    iCurBuildModifier = math.min(iCurBuildModifier + iRateAdjustment, iUpperCap)
                    ScenarioInfo.Options.CheatMult = tostring(iCurResourceModifier)
                    ScenarioInfo.Options.BuildMult = tostring(iCurBuildModifier)
                    bChangedModifier = true
                end
            else
                if iCurResourceModifier > iLowerCap or iCurBuildModifier > iLowerCap then
                    iCurResourceModifier = math.max(iCurResourceModifier + iRateAdjustment, iLowerCap)
                    iCurBuildModifier = math.max(iCurBuildModifier + iRateAdjustment, iLowerCap)
                    ScenarioInfo.Options.CheatMult = tostring(iCurResourceModifier)
                    ScenarioInfo.Options.BuildMult = tostring(iCurBuildModifier)
                    bChangedModifier = true
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bChangedModifier='..tostring(bChangedModifier)..'; bHaveIndividualAIBrainMods='..tostring(bHaveIndividualAIBrainMods)..'; Time='..GetGameTimeSeconds()) end
            if not(bChangedModifier) and not(bHaveIndividualAIBrainMods) then
                break
            else
                --Adjust each brain (which should also adjust all units owned by them and updates the team modifier)
                local bChangedAnyAI = not(bHaveIndividualAIBrainMods)
                function GetIndividualModifier(oBrain)
                    bChangedModifier = false
                    if iRateAdjustment > 0 then
                        if oBrain.CheatValue < iUpperCap then
                            bChangedModifier = true
                        end
                    else
                        if oBrain.CheatValue > iLowerCap then
                            bChangedModifier = true
                        end
                    end
                    if bChangedModifier then return oBrain.CheatValue + iRateAdjustment end
                end
                local iIndividualModifier
                for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                    if oBrain.CheatEnabled and not(oBrain.M28IsDefeated) then
                        if bHaveIndividualAIBrainMods and oBrain.CheatValue then
                            iIndividualModifier = GetIndividualModifier(oBrain)
                            if bChangedModifier and iIndividualModifier then
                                bChangedAnyAI = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Changing AIx modifier for brain '..oBrain.Nickname..' to '..iIndividualModifier) end
                                --Also change the AI .CheatValue
                                                                            --aiBrain, iBuildModifier, iResourceModifier, bDontChangeScenarioInfo, iOptionalRecordedUnitResourceAdjust, bDontApplyToUnits, bUpdateCheatValue)
                                M28Overseer.SetBuildAndResourceCheatModifiers(oBrain, iIndividualModifier, iIndividualModifier, true,                   nil,                                false,           true)
                            end
                        else
                            M28Overseer.SetBuildAndResourceCheatModifiers(oBrain, iCurBuildModifier, iCurResourceModifier, true)
                        end
                    end
                end
                if bHaveIndividualAIBrainMods and not(bChangedAnyAI) then break end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(iSecondsToWait)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshEconomyGrossValues(aiBrain)
    --Updates recorded gross mass and energy for each unit
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshEconomyGrossValues'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tEconomyUnits = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryResourceUnit, false, true)
    if bDebugMessages == true then LOG(sFunctionRef..': refreshing gross income for every unit we own time='..GetGameTimeSeconds()..'; size of tEconomyUnits='..table.getn(tEconomyUnits)) end
    for iUnit, oUnit in tEconomyUnits do
        if oUnit:GetFractionComplete() == 1 then
            UpdateGrossIncomeForUnit(oUnit) --Redundancy
        end
    end

    --Update storage capacity
    GetMassStorageMaximum(aiBrain, true)

    GetEnergyStorageMaximum(aiBrain, true)

end

function RefreshEconomyData(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshEconomyData'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    aiBrain[refiNetEnergyBaseIncome] = math.min((aiBrain[refiGrossEnergyBaseIncome] or 0) - aiBrain:GetEconomyRequested('ENERGY'), aiBrain:GetEconomyTrend('ENERGY'))
    aiBrain[refiNetMassBaseIncome] = math.min((aiBrain[refiGrossMassBaseIncome] or 0) - aiBrain:GetEconomyRequested('MASS'), aiBrain:GetEconomyTrend('MASS'))

    if bDebugMessages == true then LOG(sFunctionRef..': Finished refreshing economy data, time='..GetGameTimeSeconds()..'; Energy gross='..aiBrain[refiGrossEnergyBaseIncome]..'; Energy net='..aiBrain[refiNetEnergyBaseIncome]..'; Mass gross='..aiBrain[refiGrossMassBaseIncome]..'; Mass net='..aiBrain[refiNetMassBaseIncome]..'; aiBrain:GetEconomyRequested(\'MASS\')='..aiBrain:GetEconomyRequested('MASS')..'; aiBrain:GetEconomyTrend(\'MASS\')='..aiBrain:GetEconomyTrend('MASS')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function EconomyMainLoop(aiBrain)
    local iSlowRefreshCount = 0

    while not(aiBrain.M28IsDefeated) do
        --Slow refresh logic - every 30s update economy values for every unit as redundancy
        if iSlowRefreshCount == 0 then
            ForkThread(RefreshEconomyGrossValues, aiBrain)
        end
        iSlowRefreshCount = iSlowRefreshCount + 1
        if iSlowRefreshCount >= 30 then iSlowRefreshCount = 0 end

        --Frequent refresh logic:
        ForkThread(RefreshEconomyData, aiBrain)
        WaitSeconds(1)
    end
end

function EconomyInitialisation(aiBrain)
    while not(aiBrain[M28Overseer.refbInitialised]) do
        WaitTicks(1)
        if GetGameTimeSeconds() >= 5 then
            M28Utilities.ErrorHandler('Waited 5 seconds and brain '..aiBrain.Nickname..' doesnt seem to have initialised M28 code')
            break
        end
    end
    if not(aiBrain[refiGrossEnergyBaseIncome]) then aiBrain[refiGrossEnergyBaseIncome] = 0 end
    if not(aiBrain[refiNetEnergyBaseIncome]) then aiBrain[refiNetEnergyBaseIncome] = 0 end
    if not(aiBrain[refiGrossMassBaseIncome]) then aiBrain[refiGrossMassBaseIncome] = 0 end
    if not(aiBrain[refiNetMassBaseIncome]) then aiBrain[refiNetMassBaseIncome] = 0 end

    --Some values are set when creating a team to avoid errors

    ForkThread(EconomyMainLoop, aiBrain)
end

function RecordUnitsOfCategoryToBeReclaimed(iTeam, iCategory)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordUnitsOfCategoryToBeReclaimed'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bAddCurUnit
    local bCheckForExistingUnits
    for iPlateau, tPlateauData in M28Map.tAllPlateaus do
        if M28Utilities.IsTableEmpty(tPlateauData[M28Map.subrefPlateauLandZones]) == false then
            for iLandZone, tLZData in tPlateauData[M28Map.subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if iPlateau-LZ '..iPlateau..'-'..iLandZone..' has units of the category wanted') end
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftoLZOrWZAlliedUnits]) == false then
                    if not(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftoUnitsToReclaim]) then
                        bCheckForExistingUnits = false
                        tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftoUnitsToReclaim] = {}
                    else
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftoUnitsToReclaim]) == false then
                            bCheckForExistingUnits = true
                        end
                    end
                    local tUnitsToReclaim = EntityCategoryFilterDown(iCategory, tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftoLZOrWZAlliedUnits])
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of untis of category wanted empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToReclaim))) end
                    if M28Utilities.IsTableEmpty(tUnitsToReclaim) == false then
                        for iUnit, oUnit in tUnitsToReclaim do
                            if bDebugMessages == true then LOG(sFunctionRef..': Will add unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of units to be reclaimed unless it is already in the table') end
                            bAddCurUnit = true
                            if bCheckForExistingUnits then
                                for iExistingUnit, oExistingUnit in tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftoUnitsToReclaim] do
                                    if oUnit == oExistingUnit then
                                        bAddCurUnit = false
                                        break
                                    end
                                end
                            end
                            if bAddCurUnit then
                                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit to table of units to reclaim for iTeam='..iTeam..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                table.insert(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftoUnitsToReclaim], oUnit)
                                oUnit[M28Engineer.refbDontIncludeAsPartCompleteBuildingForConstruction] = true
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshUnitsToReclaim(iTeam, iPlateau, iLandZone)
    --Removes any dead units
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshUnitsToReclaim'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tUnitsToReclaim = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subreftoUnitsToReclaim]
    if bDebugMessages == true then
        LOG(sFunctionRef..': About to remove any dead units from tUnitsToReclaim for iPlateau-iLandZone='..iPlateau..'-'..iLandZone..', is table empty at start='..tostring(M28Utilities.IsTableEmpty(tUnitsToReclaim)))
        if M28Utilities.IsTableEmpty(tUnitsToReclaim) == false then
            LOG(sFunctionRef..': Size of tUnitsToReclaim='..table.getn(tUnitsToReclaim))
        end
    end

    function KeepCurEntry(tArray, iEntry)
        return M28UnitInfo.IsUnitValid(tArray[iEntry])
    end
    if M28Utilities.IsTableEmpty(tUnitsToReclaim) == false then
        M28Utilities.RemoveEntriesFromArrayBasedOnCondition(tUnitsToReclaim, KeepCurEntry)
        if bDebugMessages == true then LOG(sFunctionRef..': Is table empty after removing dead units='..tostring(M28Utilities.IsTableEmpty(tUnitsToReclaim))) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckForUnitsToReclaimOfCategory(iTeam, iCategory, sTeamSubrefFlag)
    --Checks if we have any units of iCategory, and if so then checks if we have low enough mass to reclaim them; if we have enough mass then starts a while loop and only aborts once we no longer have any units of the category
    --CheckForUnitsToReclaimOfCategory - e.g. subrefbActiveT2PowerReclaimer
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckForUnitsToReclaimOfCategory'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    M28Team.tTeamData[iTeam][sTeamSubrefFlag] = true
    local bDontCheckForPower = true
    if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryPower, iCategory, false) then bDontCheckForPower = false end
    if bDebugMessages == true then LOG(sFunctionRef..': Checking to see if we have any units to reclaim for the specified category.  bDontCheckForPower='..tostring(bDontCheckForPower)) end
    while M28Team.GetCurrentUnitsOfCategory(iTeam, iCategory) > 0 do
        --Are we low on mass and not low on power?
        if bDebugMessages == true then LOG(sFunctionRef..': Will only add units to be reclaimed if we have low mass, and have power (if checking for power). Has low mass='..tostring(M28Conditions.TeamHasLowMass(iTeam))..'; Have low power='..tostring(M28Conditions.HaveLowPower(iTeam))) end
        if M28Conditions.TeamHasLowMass(iTeam) and (bDontCheckForPower or not(M28Conditions.HaveLowPower(iTeam))) then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            RecordUnitsOfCategoryToBeReclaimed(iTeam, iCategory) --this can sometimes have waitticks in it
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if bDebugMessages == true then LOG(sFunctionRef..': Have added any units to be reclaimed, will stop looping now') end
            break
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    M28Team.tTeamData[iTeam][sTeamSubrefFlag] = false
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderReclaimingPower(iTeam, oPowerJustBuilt)
    --Intended to be called whenever we build a PGen
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderReclaimingPower'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iPowerTechLevel = M28UnitInfo.GetUnitTechLevel(oPowerJustBuilt)
    if bDebugMessages == true then LOG(sFunctionRef..': Just built power='..oPowerJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPowerJustBuilt)..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Do we have active reclaimer logic for T1='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbActiveT1PowerReclaimer] or false)..'; Do we ahve active t2 reclaimer='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbActiveT2PowerReclaimer])) end
    if iPowerTechLevel == 2 then
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 20 + 80 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier] and not(M28Team.tTeamData[iTeam][M28Team.subrefbActiveT1PowerReclaimer]) and not(M28Team.tTeamData[iTeam][M28Team.subrefbActiveT2PowerReclaimer]) then
            --Check we have 1 T2 power per M28 player
            local iT2PowerEquivalent = 0
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                iT2PowerEquivalent = oBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower * categories.TECH2) + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower * categories.TECH3) * 4
            end
            if iT2PowerEquivalent >= M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] * 0.65 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 1000 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier] then
                if iT2PowerEquivalent >= 2 then M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam] = false end --If game is late enough that we have built multiple t2 pgens then should start ecoing
                if bDebugMessages == true then LOG(sFunctionRef..': Will check for t1 power that we can reclaim') end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                CheckForUnitsToReclaimOfCategory(iTeam, M28UnitInfo.refCategoryT1Power, M28Team.subrefbActiveT1PowerReclaimer)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
        end
    elseif iPowerTechLevel == 3 then
        M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam] = false --redundancy (wouldnt expect to get to this point anyway with t1 spam active)
        if not(M28Team.tTeamData[iTeam][M28Team.subrefbActiveT2PowerReclaimer]) then
            local iT3PowerEquivalent = 0
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                iT3PowerEquivalent = oBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower * categories.TECH3)
            end
            if not(M28Utilities.bLoudModActive) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 600 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] * 0.65 * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier] and (iT3PowerEquivalent >= M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 2000 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier]) then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                CheckForUnitsToReclaimOfCategory(iTeam, M28UnitInfo.refCategoryT1Power + M28UnitInfo.refCategoryT2Power, M28Team.subrefbActiveT2PowerReclaimer)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            elseif not(M28Team.tTeamData[iTeam][M28Team.subrefbActiveT1PowerReclaimer]) then
                if bDebugMessages == true then LOG(sFunctionRef..': Built T3 PGen, but sitll low gross energy, Will check for t1 power that we can reclaim') end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                CheckForUnitsToReclaimOfCategory(iTeam, M28UnitInfo.refCategoryT1Power, M28Team.subrefbActiveT1PowerReclaimer)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function GetCategoryAndActionsToPauseWhenStalling(iTeam, bStallingMass, bPauseNotUnpause)
    --First check if we already have the category tables determiend from when the stall started
    --local tCategoriesByPriority, tEngineerActionsByPriority
    if bStallingMass then
        if M28Team.tTeamData[iTeam][M28Team.refiLastMassStallCategoryAndEngineerTables][1] and M28Team.tTeamData[iTeam][M28Team.refiLastMassStallCategoryAndEngineerTables][2] then
            --LOG('About to return category and engineer tables,  category size='..table.getn(M28Team.tTeamData[iTeam][M28Team.refiLastMassStallCategoryAndEngineerTables][1])..'; Engineer size='..table.getn(M28Team.tTeamData[iTeam][M28Team.refiLastMassStallCategoryAndEngineerTables][2]))
            return M28Team.tTeamData[iTeam][M28Team.refiLastMassStallCategoryAndEngineerTables][1], M28Team.tTeamData[iTeam][M28Team.refiLastMassStallCategoryAndEngineerTables][2]
        end
    else
        if M28Team.tTeamData[iTeam][M28Team.refiLastEnergyStallCategoryAndEngineerTables][1] and M28Team.tTeamData[iTeam][M28Team.refiLastEnergyStallCategoryAndEngineerTables][2] then
            return M28Team.tTeamData[iTeam][M28Team.refiLastEnergyStallCategoryAndEngineerTables][1], M28Team.tTeamData[iTeam][M28Team.refiLastEnergyStallCategoryAndEngineerTables][2]
        end
    end



    --if M28Team.tTeamData[iTeam][refiLastMassStallCategoryAndEngineerTables] = {}
    --tTeamData[iTotalTeamCount][refiLastEnergyStallCategoryAndEngineerTables] = {}
    --Are there enemies adjacent to a core base? If so then dont want to pause T2+ air factories except as a near last resort
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        local tCategoryAndEngineerTables
        if bStallingMass then
            M28Team.tTeamData[iTeam][M28Team.refiLastMassStallCategoryAndEngineerTables] = {[1]=0,[2]=0}
            tCategoryAndEngineerTables = M28Team.tTeamData[iTeam][M28Team.refiLastMassStallCategoryAndEngineerTables]
        else
            M28Team.tTeamData[iTeam][M28Team.refiLastEnergyStallCategoryAndEngineerTables] = {[1]=0,[2]=0}
            tCategoryAndEngineerTables = M28Team.tTeamData[iTeam][M28Team.refiLastEnergyStallCategoryAndEngineerTables]
        end
        local bImminentThreat = false
        local iPlateauOrZero, iLandOrWaterZone
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
            local tLZOrWZData
            local tLZOrWZTeamData
            if iPlateauOrZero == 0 then
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
            else
                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
            end
            if tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] then
                bImminentThreat = true
                break
            elseif M28Team.tLandSubteamData[oBrain.M28LandSubteam][M28Team.refbPrioritiseProduction] then
                bImminentThreat = true
                break
            end
        end

        if bStallingMass then
            if not(bImminentThreat) then
                tCategoryAndEngineerTables[1] = { M28UnitInfo.refCategorySMD, M28UnitInfo.refCategoryEngineerStation, iSpecialSurplusUpgradeCategory, M28UnitInfo.refCategorySpecialFactory, M28UnitInfo.refCategoryLandFactory * categories.TECH1, M28UnitInfo.refCategoryLandFactory * categories.TECH2, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategoryLandFactory * categories.TECH3, M28UnitInfo.refCategoryQuantumGateway, categories.SUBCOMMANDER, M28UnitInfo.refCategoryNavalFactory, M28UnitInfo.refCategoryAirFactory, categories.COMMAND, M28UnitInfo.refCategoryTML, iSpecialHQCategory, M28UnitInfo.refCategoryEngineer }

                tCategoryAndEngineerTables[2] = { { M28Engineer.refActionBuildQuantumOptics, M28Engineer.refActionBuildHive, M28Engineer.refActionBuildT3Radar, M28Engineer.refActionBuildGameEnder, M28Engineer.refActionBuildLandExperimental, M28Engineer.refActionBuildSecondExperimental, M28Engineer.refActionNavalSpareAction, M28Engineer.refActionBuildT2Sonar, M28Engineer.refActionBuildThirdPower, M28Engineer.refActionBuildSecondAirFactory, M28Engineer.refActionBuildSecondLandFactory, M28Engineer.refActionBuildLandFactory, M28Engineer.refActionSAMCreep, M28Engineer.refActionBuildNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionBuildAirFactory, M28Engineer.refActionBuildT1Sonar, M28Engineer.refActionBuildT2Radar, M28Engineer.refActionBuildT1Radar, M28Engineer.refActionBuildQuantumGateway, M28Engineer.refActionBuildSecondPower, M28Engineer.refActionBuildTML, M28Engineer.refActionBuildEnergyStorage, M28Engineer.refActionBuildAirStaging, M28Engineer.refActionManageGameEnderTemplate, M28Engineer.refActionBuildShield, M28Engineer.refActionBuildSecondShield, M28Engineer.refActionBuildExperimental, M28Engineer.refActionAssistAirFactory, M28Engineer.refActionUpgradeBuilding, M28Engineer.refActionBuildPower },
                                               { M28Engineer.refActionBuildSecondMassStorage, M28Engineer.refActionAssistUpgrade, M28Engineer.refActionFortifyFirebase, M28Engineer.refActionBuildT3MassFab, M28Engineer.refActionBuildMassStorage, M28Engineer.refActionAssistMexUpgrade, M28Engineer.refActionSpare, M28Engineer.refActionBuildSMD, M28Engineer.refActionBuildEmergencyArti }}

                --Campaign specific - dont pause T1 mex upgrades if we have at least 10 gross mass (superceded as no longer want to pause mex upgrades directly and instead only pause via iSpecialSurplusUpgradeCategory
                --[[if M28Map.bIsCampaignMap and bPauseNotUnpause and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1 then
                    for iEntry, iCategory in tCategoriesByPriority do
                        if iCategory == M28UnitInfo.refCategoryT1Mex then
                            table.remove(tCategoriesByPriority, iEntry)
                            break
                        end
                    end
                end--]]
            else
                --Simialr to above but air fac isnt paused at all, land facs are less likely to be paused, and HQs are v.unlikely to be paused, while engi actions are split up further
                tCategoryAndEngineerTables[1] = { M28UnitInfo.refCategorySMD, M28UnitInfo.refCategoryEngineerStation, iSpecialSurplusUpgradeCategory, M28UnitInfo.refCategorySpecialFactory, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategoryQuantumGateway, categories.SUBCOMMANDER, M28UnitInfo.refCategoryNavalFactory, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategoryLandFactory * categories.TECH1, M28UnitInfo.refCategoryLandFactory * categories.TECH2, M28UnitInfo.refCategoryLandFactory * categories.TECH3, categories.COMMAND, M28UnitInfo.refCategoryTML, M28UnitInfo.refCategoryEngineer, iSpecialHQCategory }

                tCategoryAndEngineerTables[2] = { { M28Engineer.refActionBuildQuantumOptics, M28Engineer.refActionBuildHive, M28Engineer.refActionBuildT3Radar, M28Engineer.refActionBuildGameEnder, M28Engineer.refActionBuildLandExperimental, M28Engineer.refActionBuildSecondExperimental, M28Engineer.refActionNavalSpareAction, M28Engineer.refActionBuildT2Sonar, M28Engineer.refActionBuildThirdPower, M28Engineer.refActionBuildSecondAirFactory, M28Engineer.refActionBuildSecondLandFactory, M28Engineer.refActionBuildLandFactory, M28Engineer.refActionSAMCreep, M28Engineer.refActionBuildNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionBuildAirFactory, M28Engineer.refActionBuildT1Sonar, M28Engineer.refActionBuildT2Radar, M28Engineer.refActionBuildT1Radar, M28Engineer.refActionBuildQuantumGateway, M28Engineer.refActionBuildSecondPower, M28Engineer.refActionBuildTML, M28Engineer.refActionBuildEnergyStorage, M28Engineer.refActionBuildAirStaging, M28Engineer.refActionManageGameEnderTemplate, M28Engineer.refActionBuildShield, M28Engineer.refActionBuildSecondShield, M28Engineer.refActionBuildExperimental, M28Engineer.refActionAssistAirFactory, M28Engineer.refActionUpgradeBuilding, M28Engineer.refActionBuildPower },
                                                  { M28Engineer.refActionBuildSecondMassStorage, M28Engineer.refActionAssistUpgrade, M28Engineer.refActionBuildT3MassFab, M28Engineer.refActionBuildMassStorage, M28Engineer.refActionAssistMexUpgrade, M28Engineer.refActionSpare },
                                                  { M28Engineer.refActionFortifyFirebase, M28Engineer.refActionBuildSMD, M28Engineer.refActionBuildEmergencyArti }}
            end
        else
            --Power stall
            if not(bImminentThreat) then
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 200 then
                    --Dont pause land facs, and make ACU pause sooner
                    tCategoryAndEngineerTables[1] = { M28UnitInfo.refCategoryQuantumOptics, M28UnitInfo.refCategorySMD, M28UnitInfo.refCategoryMassFab, M28UnitInfo.refCategoryEngineerStation, M28UnitInfo.refCategoryQuantumOptics, iSpecialSurplusUpgradeCategory, M28UnitInfo.refCategoryTML, M28UnitInfo.refCategorySpecialFactory, M28UnitInfo.refCategoryAirFactory, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategoryQuantumGateway, categories.SUBCOMMANDER, M28UnitInfo.refCategoryNavalFactory, categories.COMMAND, M28UnitInfo.refCategoryT3Radar, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategorySML - categories.EXPERIMENTAL, iSpecialHQCategory, M28UnitInfo.refCategoryStealthGenerator, M28UnitInfo.refCategoryStealthAndCloakPersonal, M28UnitInfo.refCategoryRadar, M28UnitInfo.refCategoryPersonalShield, M28UnitInfo.refCategoryFixedShield, M28UnitInfo.refCategoryMobileLandShield, M28UnitInfo.refCategoryEngineer }
                    tCategoryAndEngineerTables[2] = { { M28Engineer.refActionBuildQuantumOptics, M28Engineer.refActionBuildT3MassFab, M28Engineer.refActionBuildHive, M28Engineer.refActionBuildT3Radar, M28Engineer.refActionBuildGameEnder, M28Engineer.refActionBuildLandExperimental, M28Engineer.refActionBuildSecondExperimental, M28Engineer.refActionNavalSpareAction, M28Engineer.refActionBuildT2Sonar, M28Engineer.refActionBuildT1Sonar, M28Engineer.refActionBuildT2Radar, M28Engineer.refActionBuildT1Radar, M28Engineer.refActionBuildExperimental, M28Engineer.refActionBuildQuantumGateway, M28Engineer.refActionBuildTML, M28Engineer.refActionBuildEnergyStorage, M28Engineer.refActionBuildAirStaging, M28Engineer.refActionManageGameEnderTemplate, M28Engineer.refActionBuildShield, M28Engineer.refActionBuildSecondShield, M28Engineer.refActionBuildThirdPower, M28Engineer.refActionBuildSecondAirFactory, M28Engineer.refActionBuildAirFactory, M28Engineer.refActionBuildSecondLandFactory, M28Engineer.refActionSAMCreep, M28Engineer.refActionBuildNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionBuildSecondMassStorage, M28Engineer.refActionBuildMassStorage,M28Engineer.refActionAssistMexUpgrade, M28Engineer.refActionUpgradeBuilding, M28Engineer.refActionAssistUpgrade },
                                                   { M28Engineer.refActionAssistAirFactory, M28Engineer.refActionSpare, M28Engineer.refActionBuildSecondPower, M28Engineer.refActionFortifyFirebase },
                                                   { M28Engineer.refActionBuildLandFactory, M28Engineer.refActionBuildSMD, M28Engineer.refActionBuildEmergencyArti } }
                else
                    tCategoryAndEngineerTables[1] = { M28UnitInfo.refCategoryQuantumOptics, M28UnitInfo.refCategorySMD, M28UnitInfo.refCategoryMassFab, M28UnitInfo.refCategoryEngineerStation, M28UnitInfo.refCategoryQuantumOptics, iSpecialSurplusUpgradeCategory, M28UnitInfo.refCategoryTML, M28UnitInfo.refCategorySpecialFactory, M28UnitInfo.refCategoryAirFactory, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategoryQuantumGateway, categories.SUBCOMMANDER, M28UnitInfo.refCategoryNavalFactory, M28UnitInfo.refCategoryT3Radar, categories.COMMAND, M28UnitInfo.refCategoryLandFactory * categories.TECH1, M28UnitInfo.refCategoryLandFactory * categories.TECH2, M28UnitInfo.refCategoryLandFactory * categories.TECH3, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategorySML - categories.EXPERIMENTAL, iSpecialHQCategory, M28UnitInfo.refCategoryStealthGenerator, M28UnitInfo.refCategoryStealthAndCloakPersonal, M28UnitInfo.refCategoryRadar, M28UnitInfo.refCategoryPersonalShield, M28UnitInfo.refCategoryFixedShield, M28UnitInfo.refCategoryMobileLandShield, M28UnitInfo.refCategoryEngineer }
                    tCategoryAndEngineerTables[2] = { { M28Engineer.refActionBuildQuantumOptics, M28Engineer.refActionBuildT3MassFab, M28Engineer.refActionBuildHive, M28Engineer.refActionBuildT3Radar, M28Engineer.refActionBuildGameEnder, M28Engineer.refActionBuildLandExperimental, M28Engineer.refActionBuildSecondExperimental, M28Engineer.refActionNavalSpareAction, M28Engineer.refActionBuildT2Sonar, M28Engineer.refActionBuildT1Sonar, M28Engineer.refActionBuildT2Radar, M28Engineer.refActionBuildT1Radar, M28Engineer.refActionBuildExperimental, M28Engineer.refActionBuildQuantumGateway, M28Engineer.refActionBuildTML, M28Engineer.refActionBuildEnergyStorage, M28Engineer.refActionBuildAirStaging, M28Engineer.refActionManageGameEnderTemplate, M28Engineer.refActionBuildShield, M28Engineer.refActionBuildSecondShield, M28Engineer.refActionBuildThirdPower, M28Engineer.refActionBuildSecondAirFactory, M28Engineer.refActionBuildAirFactory, M28Engineer.refActionBuildSecondLandFactory, M28Engineer.refActionSAMCreep, M28Engineer.refActionBuildNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionBuildSecondMassStorage, M28Engineer.refActionBuildMassStorage,M28Engineer.refActionAssistMexUpgrade, M28Engineer.refActionUpgradeBuilding, M28Engineer.refActionAssistUpgrade },
                                                   { M28Engineer.refActionAssistAirFactory, M28Engineer.refActionSpare, M28Engineer.refActionBuildSecondPower, M28Engineer.refActionFortifyFirebase },
                                                   { M28Engineer.refActionBuildLandFactory, M28Engineer.refActionBuildSMD, M28Engineer.refActionBuildEmergencyArti } }
                end
            else
                --As above but air fac paused as lower priority and no land factory pausing
                tCategoryAndEngineerTables[1] = { M28UnitInfo.refCategoryQuantumOptics, M28UnitInfo.refCategorySMD, M28UnitInfo.refCategoryMassFab, M28UnitInfo.refCategoryEngineerStation, M28UnitInfo.refCategoryQuantumOptics, iSpecialSurplusUpgradeCategory, M28UnitInfo.refCategoryTML, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategoryQuantumGateway, categories.SUBCOMMANDER, M28UnitInfo.refCategorySpecialFactory, M28UnitInfo.refCategoryAirFactory, M28UnitInfo.refCategoryNavalFactory, M28UnitInfo.refCategoryT3Radar, categories.COMMAND, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategorySML - categories.EXPERIMENTAL, iSpecialHQCategory, M28UnitInfo.refCategoryStealthGenerator, M28UnitInfo.refCategoryStealthAndCloakPersonal, M28UnitInfo.refCategoryRadar, M28UnitInfo.refCategoryPersonalShield, M28UnitInfo.refCategoryFixedShield, M28UnitInfo.refCategoryMobileLandShield, M28UnitInfo.refCategoryEngineer }
                tCategoryAndEngineerTables[2] = { { M28Engineer.refActionBuildQuantumOptics, M28Engineer.refActionBuildT3MassFab, M28Engineer.refActionBuildHive, M28Engineer.refActionBuildT3Radar, M28Engineer.refActionBuildGameEnder, M28Engineer.refActionBuildLandExperimental, M28Engineer.refActionBuildSecondExperimental, M28Engineer.refActionNavalSpareAction, M28Engineer.refActionBuildT2Sonar, M28Engineer.refActionBuildT1Sonar, M28Engineer.refActionBuildT2Radar, M28Engineer.refActionBuildT1Radar, M28Engineer.refActionBuildExperimental, M28Engineer.refActionBuildQuantumGateway, M28Engineer.refActionBuildTML, M28Engineer.refActionBuildEnergyStorage, M28Engineer.refActionBuildAirStaging, M28Engineer.refActionManageGameEnderTemplate, M28Engineer.refActionBuildShield, M28Engineer.refActionBuildSecondShield, M28Engineer.refActionBuildThirdPower, M28Engineer.refActionBuildSecondAirFactory, M28Engineer.refActionBuildAirFactory, M28Engineer.refActionBuildSecondLandFactory, M28Engineer.refActionSAMCreep, M28Engineer.refActionBuildNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionBuildSecondMassStorage, M28Engineer.refActionBuildMassStorage,M28Engineer.refActionAssistMexUpgrade, M28Engineer.refActionUpgradeBuilding, M28Engineer.refActionAssistUpgrade },
                                               { M28Engineer.refActionAssistAirFactory, M28Engineer.refActionSpare, M28Engineer.refActionBuildSecondPower, M28Engineer.refActionFortifyFirebase },
                                               { M28Engineer.refActionBuildLandFactory, M28Engineer.refActionBuildSMD, M28Engineer.refActionBuildEmergencyArti } }

            end
        end
        if not(bPauseNotUnpause) then
            table.insert(tCategoryAndEngineerTables[1], M28UnitInfo.refCategoryT2Mex)
            table.insert(tCategoryAndEngineerTables[1], M28UnitInfo.refCategoryT1Mex)
        end
        --LOG('About to return category and engineer tables,  category size='..table.getn(tCategoryAndEngineerTables[1])..'; Engineer size='..table.getn(tCategoryAndEngineerTables[2]))
        return tCategoryAndEngineerTables[1], tCategoryAndEngineerTables[2]
    else
        M28Utilities.ErrorHandler('No active M28 brains')
    end
end

function ManageMassStalls(iTeam)
    --For now focus is on if we are trying to build a missile for an SML, or we are massively mass stalling
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMassStalls'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start at time'..GetGameTimeSeconds()..'; Is table of active M28 brains empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        local bOnlyParagons = false
        if M28Team.tTeamData[iTeam][M28Team.refbBuiltParagon] then
            bOnlyParagons = true
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                if not(oBrain[refbBuiltParagon]) then
                    bOnlyParagons = false
                    break
                end
            end
        end
        local bPauseNotUnpause = true
        local bChangeRequired = false
        local iUnitsAdjusted = 0
        local iMassStallPercentAdjust = 0
        local iOverspendPercentage = 0.2 --i.e. if sending 20% more than our gross income will consider a mass stall
        local bOnlyEasyBrains = true
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            if not(oBrain.M28Easy) then
                bOnlyEasyBrains = false
                break
            end
        end
        if bOnlyEasyBrains then
            iOverspendPercentage = 0.6
        end
        local bFirstBrain
        if M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] then iMassStallPercentAdjust = 0.015 end
        --Dont consider pausing or unpausing if are stalling energy or early game, as our energy stall manager is likely to be operating
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, GetGameTimeSeconds='..GetGameTimeSeconds()..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Team stalling mass already='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass])..'; Team stalling energy='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])) end
        if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] or ((GetGameTimeSeconds() >= 120 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 3 and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or -100) >= 10 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] >= 0.99)) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] <= 5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 0.5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and GetGameTimeSeconds() >= 80 and GetGameTimeSeconds() <= 180 and not(M28Map.bIsLowMexMap) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 4 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 1 and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryEngineer) >= 2 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
            if bOnlyParagons then bPauseNotUnpause = false end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': About to consider if we have a mass stall or not. Team lowest mass percent stored=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] .. '; M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] .. '; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]))
            end
            --First consider unpausing
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': If we have flagged that we are stalling mass then will check if we have enough to start unpausing things. M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; iMassStallPercentAdjust='..iMassStallPercentAdjust)
            end

            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] > (0.005 + iMassStallPercentAdjust) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 2000 then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Have enough mass stored or income to start unpausing things')
                end
                bPauseNotUnpause = false
                if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] then bChangeRequired = true end
            end
            if bDebugMessages == true then LOG(sFunctionRef .. ': Checking if we shoudl flag that we are mass stalling. bChangeRequired='..tostring(bChangeRequired)..'; Mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Need resources for missile='..tostring((M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] or false))..'; Gross mass income='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]) end
            --Check if should manage mass stall
            if bChangeRequired == false and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= (0.001 + iMassStallPercentAdjust) and (M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] < -1 and (-M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] / M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= iOverspendPercentage))) and not(bOnlyParagons) then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': We are stalling mass, will look for units to pause')
                end
                bChangeRequired = true
                bPauseNotUnpause = true
                M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] = true
                M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] = GetGameTimeSeconds()
            end
            if bPauseNotUnpause and not(bChangeRequired) and not(bOnlyParagons) then
                if M28Team.tTeamData[iTeam][M28Team.subrefbStallingMassFlaggedFromTeamEconomy] then
                    M28Team.tTeamData[iTeam][M28Team.subrefbStallingMassFlaggedFromTeamEconomy] = false
                    bChangeRequired = true
                else
                    if M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount] > 0 then
                        bChangeRequired = true
                    end
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': bChangeRequired='..tostring(bChangeRequired)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)) end
            if bChangeRequired then
                local bDontPauseUpgradingT1LandOrT2Land = false
                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether we want to avoid pausing a t1 factory upgrading to t2, lowest friendly land factory tech='..(M28Team.tTeamData[iTeam][M28Team.subrefiLowestFriendlyLandFactoryTech] or 'nil')..'; Highest='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]..'; Is table of upgrading HQs empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]))) end
                if M28Team.tTeamData[iTeam][M28Team.subrefiLowestFriendlyLandFactoryTech] == 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] < 3 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]) == false then
                    for iFactory, oFactory in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs] do
                        if M28UnitInfo.IsUnitValid(oFactory) and EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oFactory.UnitId) then
                            local tFactoryLZData, tFactoryLZTeamData = M28Map.GetLandOrWaterZoneData(oFactory:GetPosition(), true, iTeam)
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering upgrading factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; Do we want to save mass for MML for firebase for zone this factory is in='..tostring(M28Conditions.SaveMassForMMLForFirebase(tFactoryLZData, tFactoryLZTeamData, iTeam, true))) end
                            if tFactoryLZTeamData and M28Conditions.SaveMassForMMLForFirebase(tFactoryLZData, tFactoryLZTeamData, iTeam, true) then
                                bDontPauseUpgradingT1LandOrT2Land = true
                                break
                            end
                        end
                    end

                end

                local iMinBuildCountBeforePausingHQ = 5
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 0.8 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or bDontPauseUpgradingT1LandOrT2Land then
                    iMinBuildCountBeforePausingHQ = 2
                end

                --Decide on order to pause/unpause

                local tCategoriesByPriority, tEngineerActionsByPriority = GetCategoryAndActionsToPauseWhenStalling(iTeam, true, bPauseNotUnpause)

                local iMassPerTickSavingNeeded
                if bPauseNotUnpause then
                    if M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] then iMassPerTickSavingNeeded = math.max(1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass])
                    else
                        iMassPerTickSavingNeeded = math.max(1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] * 0.8)
                    end
                else
                    if M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] then iMassPerTickSavingNeeded = math.min(-1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass], -M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] / 30)
                    else
                        iMassPerTickSavingNeeded = math.min(-1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] * 1.2, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] / 20)
                    end
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.15 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 4000 then
                        iMassPerTickSavingNeeded = iMassPerTickSavingNeeded * 1.2 - 0.5
                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 4000 then iMassPerTickSavingNeeded = iMassPerTickSavingNeeded - 1 end
                    end
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 2000 then iMassPerTickSavingNeeded = iMassPerTickSavingNeeded - 1 end
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to unpause units, iMassPerTickSavingNeeded (negative means unpausing units)='..iMassPerTickSavingNeeded) end
                end

                local iMassSavingManaged = 0
                local iEngineerSubtableCount = 0
                local tEngineerActionSubtable
                local oUnit

                local bAbort = false
                local iTotalUnits = 0
                local iCategoryStartPoint, iIntervalChange, iCategoryEndPoint, iCategoryRef
                local bWasUnitAlreadyPaused
                local bConsiderReclaimingEngineer = false
                local iKillCount = 0
                local iCurPlateau, iCurLandZone
                local iBuildRateMod

                if bPauseNotUnpause then
                    iCategoryStartPoint = 1
                    iIntervalChange = 1
                    iCategoryEndPoint = table.getn(tCategoriesByPriority)
                    if GetGameTimeSeconds() - M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEngiSelfDestruct] > 0.99 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                        local iEngiCategoryWanted
                        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer * categories.TECH3
                        elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 2 then iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer - categories.TECH1
                        else iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer
                        end
                        local iCurEngis = 0
                        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                            iCurEngis = iCurEngis + oBrain:GetCurrentUnits(iEngiCategoryWanted)
                        end

                        if iCurEngis >= 10 then
                            --If are defending against arti then want a lot more engineers before start considering ctrl-king any
                            if not(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) or iCurEngis >= 70 then
                                bConsiderReclaimingEngineer = true
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Time of last engi self destruct='..M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEngiSelfDestruct]..'; bConsiderReclaimingEngineer='..tostring(bConsiderReclaimingEngineer)) end
                else
                    iCategoryStartPoint = table.getn(tCategoriesByPriority)
                    iIntervalChange = -1
                    iCategoryEndPoint = 1
                end

                local bConsideringHQ
                local bConsideringTeamWideUnits = false
                local bNoRelevantUnits = true

                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': About to cycle through every category, bPauseNotUnpause=' .. tostring(bPauseNotUnpause) .. '; iCategoryStartPoint=' .. iCategoryStartPoint .. '; iCategoryEndPoint=' .. iCategoryEndPoint)
                end
                for iCategoryCount = iCategoryStartPoint, iCategoryEndPoint, iIntervalChange do
                    local tRelevantUnits
                    iCategoryRef = tCategoriesByPriority[iCategoryCount]

                    --Are we considering upgrading factory HQs?
                    if iCategoryRef == iSpecialHQCategory then
                        iCategoryRef = M28UnitInfo.refCategoryAllHQFactories
                        bConsideringHQ = true
                        bConsideringTeamWideUnits = false
                    else
                        if iCategoryRef == iSpecialSurplusUpgradeCategory then
                            bConsideringTeamWideUnits = true
                        else
                            bConsideringTeamWideUnits = false
                        end
                        bConsideringHQ = false
                    end

                    local iCurUnitMassUsage
                    local bApplyActionToUnit
                    local oBP
                    local oFocusUnitBP
                    local bFirstEngiCategoryRefBrain = true
                    bFirstBrain = true
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        if oBrain.CheatEnabled then iBuildRateMod = M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier]
                        else iBuildRateMod = 1
                        end

                        if bPauseNotUnpause then
                            if oBrain[refbBuiltParagon] then
                                if bDebugMessages == true then LOG(sFunctionRef..': This brain has built a paragon so wont search for units to pause') end
                            elseif iCategoryRef == iSpecialSurplusUpgradeCategory then
                                --Pause all but 1 upgrade per brain, pausing the lowest progress first, if we have multiple upgrades.  Dont pause the last mex upgrade. also dont pause anything that is >=85% complete
                                tRelevantUnits = {}
                                if M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) then
                                    local iMexesToPause = math.max(0, table.getn(M28Team.tTeamData[oBrain.M28Team][M28Team.subreftTeamUpgradingMexes]) - (0.5 + 0.5 * M28Team.tTeamData[oBrain.M28Team][M28Team.subrefiActiveM28BrainCount]))
                                    --Want to allow multiple upgrading mexes for a brain if we have lots of mexes
                                    if iMexesToPause > 0 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 14 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] > 10 and M28Conditions.GetHighestOtherTeamT3MexCount(iTeam) > M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][3])) then
                                        if oBrain[refiGrossMassBaseIncome] >= 6 then
                                            local iMexPerPlayer
                                            if M28Utilities.bLoudModActive or M28Map.iMapSize > 1024 then iMexPerPlayer = 1 + (oBrain[refiGrossMassBaseIncome] / 6)*0.45
                                            elseif M28Map.iMapSize == 1024 and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] > 0 then iMexPerPlayer = 0.5 + (oBrain[refiGrossMassBaseIncome] / 6)*0.4
                                            else iMexPerPlayer = 0.5 + (oBrain[refiGrossMassBaseIncome] / 6)*0.3
                                            end
                                            if M28Conditions.GetHighestOtherTeamT3MexCount(iTeam) > M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][3] then iMexPerPlayer = iMexPerPlayer * 2.5 end
                                            iMexesToPause = math.min(iMexesToPause, math.max(0, table.getn(M28Team.tTeamData[oBrain.M28Team][M28Team.subreftTeamUpgradingMexes]) - (0.5 + iMexPerPlayer * M28Team.tTeamData[oBrain.M28Team][M28Team.subrefiActiveM28BrainCount])))
                                        end
                                    end

                                    --LOUD - pause fewer mexes due to greater need to focus on ecoing
                                    if iMexesToPause > 0 and M28Utilities.bLoudModActive and not(M28Team.tTeamData[iTeam][M28Team.refbPrioritiseProduction]) and oBrain[refiGrossMassBaseIncome] >= 3 then
                                        iMexesToPause = math.max(0, iMexesToPause - 1)
                                    end

                                    while iMexesToPause > 0 do
                                        local iLowestProgress = 0.8
                                        local oLowestProgress
                                        local bAlreadyIncluded
                                        for iUnit, oUnit in M28Team.tTeamData[oBrain.M28Team][M28Team.subreftTeamUpgradingMexes] do
                                            if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetWorkProgress() < iLowestProgress then
                                                bAlreadyIncluded = false
                                                --Is the unit already in the table of relevant units?
                                                if M28Utilities.IsTableEmpty(tRelevantUnits) == false then
                                                    for iRecordedUnit, oRecordedUnit in tRelevantUnits do
                                                        if oRecordedUnit == oUnit then bAlreadyIncluded = true break end
                                                    end
                                                end
                                                if not(bAlreadyIncluded) then
                                                    oLowestProgress = oUnit
                                                    iLowestProgress = oUnit:GetWorkProgress()
                                                end
                                            end
                                        end
                                        if oLowestProgress then
                                            table.insert(tRelevantUnits, oLowestProgress)
                                        else
                                            break
                                        end
                                        iMexesToPause = iMexesToPause - 1
                                    end
                                    if M28Utilities.bLoudModActive and M28Utilities.IsTableEmpty(tRelevantUnits) == false then
                                        --Further check for loud - dont pause any T3 mex upgrades since they arem ore efficient
                                        for iCurRelevantUnitEntry = table.getn(tRelevantUnits), 1, -1 do
                                            local oCurRelevantUnit = tRelevantUnits[iCurRelevantUnitEntry]
                                            if EntityCategoryContains(categories.TECH3, oCurRelevantUnit.UnitId) then
                                                table.remove(tRelevantUnits, iCurRelevantUnitEntry)
                                            end
                                        end
                                    end
                                end
                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[oBrain.M28Team][M28Team.subreftTeamUpgradingOther]) == false then
                                    for iUnit, oUnit in M28Team.tTeamData[oBrain.M28Team][M28Team.subreftTeamUpgradingOther] do
                                        table.insert(tRelevantUnits, oUnit)
                                    end
                                end
                            else
                                tRelevantUnits = oBrain:GetListOfUnits(iCategoryRef, false, true)
                            end
                        else
                            if bFirstBrain then
                                tRelevantUnits = M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority][iCategoryCount]
                                bFirstBrain = false
                            else
                                break
                            end
                        end


                        if M28Utilities.IsTableEmpty(tRelevantUnits) == false then
                            bNoRelevantUnits = false
                            iTotalUnits = table.getn(tRelevantUnits)
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': iCategoryCount=' .. iCategoryCount .. '; iTotalUnits=' .. iTotalUnits .. '; bPauseNotUnpause=' .. tostring(bPauseNotUnpause))
                            end
                            if iCategoryRef == M28UnitInfo.refCategoryEngineer then
                                if bFirstEngiCategoryRefBrain then
                                    iEngineerSubtableCount = iEngineerSubtableCount + 1
                                    bFirstEngiCategoryRefBrain = false
                                end
                                tEngineerActionSubtable = tEngineerActionsByPriority[iEngineerSubtableCount]
                            end
                            for iUnit = iTotalUnits, 1, -1 do
                                oUnit = tRelevantUnits[iUnit]

                                --for iUnit, oUnit in tRelevantUnits do
                                bApplyActionToUnit = false
                                iCurUnitMassUsage = 0
                                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then --Only consider unit if it has been constructed
                                    if not(bPauseNotUnpause) then
                                        bApplyActionToUnit = true
                                        if (oUnit.GetTacticalSiloAmmoCount or oUnit.GetTacticalSiloAmmoCount) and M28UnitInfo.GetMissileCount(oUnit) >= 2 then
                                            --Dont unpause TML, SML and SMD that have 2+ missiles loaded already
                                            bApplyActionToUnit = false
                                        end
                                    else
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': About to consider pausing unit ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. '; will first check category specific logic for if we want to go ahead with pausing4')
                                        end


                                        --Do we actually want to pause the unit? check any category specific logic
                                        bApplyActionToUnit = true
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': UnitState=' .. M28UnitInfo.GetUnitState(oUnit) .. '; Is ActiveHQUpgrades Empty=' .. tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]))..'; bDontPauseUpgradingT1LandOrT2Land='..tostring(bDontPauseUpgradingT1LandOrT2Land)..'; Is unit upgrading='..tostring(oUnit:IsUnitState('Upgrading'))..'; refbPrimaryHighMexIslandFactory='..tostring(oUnit[M28Factory.refbPrimaryHighMexIslandFactory] or false))
                                        end
                                        --Factories, ACU and engineers - dont pause if >=85% done, or if is land factory that hasn't built many units (so e.g. if have just placed a land factory on a core expansion we dont immediately pause it)
                                        if oUnit.GetWorkProgress and EntityCategoryContains(M28UnitInfo.refCategoryEngineer + categories.COMMAND + M28UnitInfo.refCategoryFactory, oUnit.UnitId) and ((oUnit:GetWorkProgress() or 0) >= 0.85 or (EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) and (oUnit[M28Factory.refiTotalBuildCount] or 0) <= iMinBuildCountBeforePausingHQ)) then
                                            bApplyActionToUnit = false
                                        elseif oUnit[M28Factory.refbPrimaryHighMexIslandFactory] then bApplyActionToUnit = false
                                            --Air HQ - dont pause first ever unit or transport
                                        elseif EntityCategoryContains(M28UnitInfo.refCategoryAirHQ, oUnit.UnitId) and (oUnit[M28Factory.refiTotalBuildCount] == 0 or EntityCategoryContains(M28UnitInfo.refCategoryTransport, (oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] or 'ueb1105'))) then
                                            bApplyActionToUnit = false
                                        elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) and ((bDontPauseUpgradingT1LandOrT2Land and (EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId or oUnit:IsUnitState('Upgrading'))) or oUnit[M28Factory.refiTotalBuildCount] <= 10)) then

                                            --Is this on a dif island to closest enemy base?
                                            local tUnitLZData, tUnitLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                            if tUnitLZTeamData and not(NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition()) == NavUtils.GetLabel(M28Map.refPathingTypeLand, tUnitLZTeamData[M28Map.reftClosestEnemyBase])) and (oUnit[M28Factory.refiTotalBuildCount] or 0) <= iMinBuildCountBeforePausingHQ * 3 then
                                                bApplyActionToUnit = false
                                            elseif bDontPauseUpgradingT1LandOrT2Land and ((oUnit:IsUnitState('Upgrading') and EntityCategoryContains(categories.TECH1, oUnit.UnitId) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]) == false) or EntityCategoryContains(M28UnitInfo.refCategoryLandFactory * categories.TECH2, oUnit.UnitId)) then
                                                for iFactory, oFactory in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs] do
                                                    if oUnit == oFactory then
                                                        bApplyActionToUnit = false
                                                        break
                                                    end
                                                end
                                            end
                                            --SMD LOGIC - Check if already have 1 missile loaded before pausing (we know we are in a pause unit scenario from above condition)
                                        elseif iCategoryRef == M28UnitInfo.refCategorySMD and oUnit.GetTacticalSiloAmmoCount and oUnit:GetTacticalSiloAmmoCount() == 0 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false then
                                            if bDebugMessages == true then
                                                LOG(sFunctionRef .. ': Have SMD with at least 1 missile so will pause it')
                                            end
                                            bApplyActionToUnit = false
                                        elseif iCategoryRef == M28UnitInfo.refCategoryEngineer then
                                            if bDebugMessages == true then
                                                LOG(sFunctionRef .. ': Have an engineer with action=' .. (oUnit[M28Engineer.refiAssignedAction] or 'nil') .. '; tEngineerActionSubtable=' .. repru(tEngineerActionSubtable))
                                            end
                                            bApplyActionToUnit = false
                                            if not(oUnit:IsUnitState('Attached')) then
                                                for iActionCount, iActionRef in tEngineerActionSubtable do
                                                    if iActionRef == oUnit[M28Engineer.refiAssignedAction] then
                                                        bApplyActionToUnit = true
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Have an action match, iActionRef='..iActionRef..'; will apply action to unitunless have an override such as priamry power builder, oUnit[M28Engineer.refbPrimaryBuilder]='..tostring(oUnit[M28Engineer.refbPrimaryBuilder])) end
                                                        --Dont pause the last engi building power or GE Template, and also dont pause if are building PD/T2 Arti/Shield/Experimental and have a fraction complete of at least 70%
                                                        if oUnit[M28Engineer.refbPrimaryBuilder] and (iActionRef == M28Engineer.refActionBuildPower or iActionRef == M28Engineer.refActionBuildSecondPower or iActionRef == M28Engineer.refActionManageGameEnderTemplate) then
                                                            bApplyActionToUnit = false
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with primary builder that is building power or GE template so wont pause') end
                                                        elseif oUnit.GetFocusUnit then
                                                            local oFocusUnit = oUnit:GetFocusUnit()
                                                            if bDebugMessages == true then
                                                                if M28UnitInfo.IsUnitValid(oFocusUnit) then
                                                                    LOG(sFunctionRef..': Considering engineer '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; UC='..M28Engineer.GetEngineerUniqueCount(oUnit)..'; Focus unit='..oFocusUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFocusUnit)..'; Fraction complete='..oFocusUnit:GetFractionComplete())
                                                                else LOG(sFunctionRef..': Focus unit for engineer '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; UC='..M28Engineer.GetEngineerUniqueCount(oUnit)..' isnt valid') end
                                                            end
                                                            if M28UnitInfo.IsUnitValid(oFocusUnit) then
                                                                if oFocusUnit:GetFractionComplete() >= 0.7 and oFocusUnit:GetFractionComplete() < 1 and EntityCategoryContains(M28UnitInfo.refCategoryPD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryExperimentalLevel, oFocusUnit.UnitId) then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Wont apply action to unit as it is PD/Arti/Experimental') end
                                                                    bApplyActionToUnit = false
                                                                    if oUnit[M28UnitInfo.refbPaused] then M28UnitInfo.PauseOrUnpauseMassUsage(oUnit, false, iTeam, iCategoryCount) end
                                                                elseif iActionRef == M28Engineer.refActionBuildLandFactory and EntityCategoryContains(M28UnitInfo.refCategoryLandFactory - categories.TECH3, oFocusUnit.UnitId) and oBrain[refiGrossMassBaseIncome] >= 1.4 then
                                                                    local tEngiZone, tEngiTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Are building al and fac, wont pause if not in core zone, tEngiTeamData[M28Map.subrefLZbCoreBase]='..tostring(tEngiTeamData[M28Map.subrefLZbCoreBase] or false)) end
                                                                    if not(tEngiTeamData[M28Map.subrefLZbCoreBase]) then
                                                                        --Keep building expansion land fac
                                                                        bApplyActionToUnit = false
                                                                    end
                                                                end
                                                                --exception - primary engi trying to build land fac, and not in core zone
                                                            elseif iActionRef == M28Engineer.refActionBuildLandFactory then
                                                                local sBlueprint = oUnit[M28Orders.reftiLastOrders][1][M28Orders.subrefsOrderBlueprint]
                                                                if not(sBlueprint) and oUnit[M28Orders.reftiLastOrders][1][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueGuard then sBlueprint = oUnit[M28Orders.reftiLastOrders][1][M28Orders.subrefoOrderUnitTarget][M28Orders.reftiLastOrders][1][M28Orders.subrefsOrderBlueprint] end
                                                                if sBlueprint and EntityCategoryContains(M28UnitInfo.refCategoryLandFactory - categories.TECH3, sBlueprint) then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': We have queued up a land fac, want to build it if we are not in a core zone (since presumably are at an expansion point') end
                                                                    local tEngiZone, tEngiTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                                                    if not(tEngiTeamData[M28Map.subrefLZbCoreBase]) then
                                                                        bApplyActionToUnit = false
                                                                    end
                                                                end
                                                            end
                                                        end
                                                        if bApplyActionToUnit and bConsiderReclaimingEngineer and not(oUnit[M28Engineer.refbPrimaryBuilder]) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), M28Map.PlayerStartPoints[oBrain:GetArmyIndex()]) <= 90 then
                                                            --Is there reclaim near the engineer? If so clear its orders and have it reclaim, otherwise kill it
                                                            local oBP = oUnit:GetBlueprint()
                                                            if oBP.Economy.BuildCostMass < 500 and oBP.Economy.MaxBuildDistance then --redundancy so we dont ctrl-K SACUs or a unit with no build radius
                                                                bApplyActionToUnit = false


                                                                function KillEngineer(oUnit)
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': About to kill engineer '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; unless it is T3 and there is a T1 or T2 engi we can kill instead in the same zone') end
                                                                    local oEngiToKill = GetBestEngiToKill(oUnit)
                                                                    if M28UnitInfo.GetUnitTechLevel(oEngiToKill) == 1 and oBrain[refiOurHighestFactoryTechLevel] > 1 then iKillCount = iKillCount + 0.5
                                                                    else iKillCount = iKillCount + 1
                                                                    end
                                                                    M28Orders.IssueTrackedKillUnit(oEngiToKill)
                                                                    if iKillCount >= 2 then
                                                                        bConsiderReclaimingEngineer = false
                                                                    end
                                                                    M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEngiSelfDestruct] = GetGameTimeSeconds()
                                                                end
                                                                iCurPlateau, iCurLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                                                                if (iCurPlateau or 0) > 0 and (iCurLandZone or 0) > 0 then
                                                                    if M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefTotalMassReclaim] > 30 then
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': About to tell unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to reclaim nearby area due to mass stall') end
                                                                        M28Engineer.GetEngineerToReclaimNearbyArea(oUnit, 1, M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefLZTeamData][iTeam], iCurPlateau, iCurLandZone, false, true)
                                                                        --Kill engineers if htey are in a core LZ
                                                                    elseif M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] and (not(oUnit[M28UnitInfo.refbCampaignTriggerAdded]) or not(M28Map.bIsCampaignMap)) then
                                                                        KillEngineer(oUnit)
                                                                    end
                                                                end
                                                            end
                                                        end
                                                        break
                                                    end
                                                end
                                            end
                                        elseif iCategoryRef == M28UnitInfo.refCategoryPersonalShield or iCategoryRef == M28UnitInfo.refCategoryFixedShield or iCategoryRef == M28UnitInfo.refCategoryMobileLandShield then
                                            --Mass stalling so pausing shield not expected to do anything
                                            bApplyActionToUnit = false
                                        elseif iCategoryRef == M28UnitInfo.refCategoryTML and M28UnitInfo.GetMissileCount(oUnit) == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1.2 then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with TML that has no missile so dont want to pause it') end
                                            bApplyActionToUnit = false
                                        end



                                        if iCategoryRef == categories.COMMAND then
                                        --want in addition to above as ACU might have personal shield

                                        if oUnit:IsUnitState('Upgrading') then
                                        bApplyActionToUnit = false
                                        elseif oUnit.GetWorkProgress then
                                        --if oUnit:GetWorkProgress() >= 0.85 then
                                        bApplyActionToUnit = false
                                        --dont pause t1 mex construction
                                        if oUnit.GetFocusUnit and oUnit:GetFocusUnit() and oUnit:GetFocusUnit().UnitId and EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oUnit:GetFocusUnit().UnitId) then
                                        bApplyActionToUnit = false
                                        end
                                            end
                                            end
                                    end
                                end


                                --Pause/unpause the unit

                                if bApplyActionToUnit then
                                    bWasUnitAlreadyPaused = oUnit[M28UnitInfo.refbPaused] --Means we will ignore the mass usage when calculating how much we have saved
                                    oBP = oUnit:GetBlueprint()
                                    iCurUnitMassUsage = oBP.Economy.MaintenanceConsumptionPerSecondMass

                                    if (iCurUnitMassUsage or 0) == 0 or EntityCategoryContains(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryMex + categories.COMMAND, oUnit.UnitId) then
                                        --Approximate mass usage based on build rate as a very rough guide
                                        --examples: Upgrading mex to T3 costs 11E per BP; T3 power is 8.4; T1 power is 6; Guncom is 30; Laser is 178; Strat bomber is 15
                                        local iMassPerBP = 0.25 --e.g. building t1 land factory uses 4; building a titan uses 1.1; divide by 10 as dealing with values per tick
                                        if EntityCategoryContains(categories.SILO, oUnit.UnitId) and oBP.Economy.BuildRate then
                                            --Dealing with a silo so need to calculate mass usage differently
                                            iCurUnitMassUsage = 0
                                            for iWeapon, tWeapon in oBP.Weapon do
                                                if tWeapon.MaxProjectileStorage and tWeapon.ProjectileId then
                                                    local oProjectileBP = __blueprints[tWeapon.ProjectileId]
                                                    if oProjectileBP.Economy and oProjectileBP.Economy.BuildCostMass and oProjectileBP.Economy.BuildTime > 0 and oBP.Economy.BuildRate > 0 then
                                                        iCurUnitMassUsage = oProjectileBP.Economy.BuildCostMass * oBP.Economy.BuildRate * iBuildRateMod / oProjectileBP.Economy.BuildTime
                                                        --If are power stalling then assume we only save 80% of this, as might have adjacency
                                                        if bPauseNotUnpause then iCurUnitMassUsage = iCurUnitMassUsage * 0.8 end
                                                        break
                                                    end
                                                end
                                            end
                                        else
                                            if iCategoryRef == categories.COMMAND and oUnit[M28Orders.refiOrderCount] > 0 and oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] == M28Orders.refiOrderEnhancement then
                                                --Determine mass cost per BP
                                                local sUpgradeRef = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint]
                                                if bDebugMessages == true then LOG(sFunctionRef..': aiBrain='..oUnit:GetAIBrain():GetArmyIndex()..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; sUpgradeRef='..(sUpgradeRef or 'nil')..'; Upgrade mass cost='..(M28UnitInfo.GetUpgradeMassCost(oUnit, sUpgradeRef) or 'nil')..'; Upgrade build time='..(M28UnitInfo.GetUpgradeBuildTime(oUnit, sUpgradeRef) or 'nil')) end
                                                iMassPerBP = M28UnitInfo.GetUpgradeMassCost(oUnit, sUpgradeRef) / (M28UnitInfo.GetUpgradeBuildTime(oUnit, sUpgradeRef) or 1)
                                            end

                                            if oBP.Economy.BuildRate then
                                                --Reduce this massively if unit isn't actually building anything
                                                if bPauseNotUnpause then
                                                    if (not(oUnit:IsUnitState('Building')) and not(oUnit:IsUnitState('Repairing')) and not(oUnit.GetWorkProgress and oUnit:GetWorkProgress() > 0) and not(oUnit:IsUnitState('Upgrading'))) then
                                                        iCurUnitMassUsage = oBP.Economy.BuildRate * iBuildRateMod * 0.01
                                                    else
                                                        if M28UnitInfo.IsUnitValid(oUnit:GetFocusUnit()) then
                                                            oFocusUnitBP = oUnit:GetFocusUnit():GetBlueprint()
                                                            iCurUnitMassUsage = oBP.Economy.BuildRate * iBuildRateMod / oFocusUnitBP.Economy.BuildTime * oFocusUnitBP.Economy.BuildCostMass
                                                            oUnit[refiLastMassUsage] = iCurUnitMassUsage
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Setting unit last mass usage to '..oUnit[refiLastMassUsage]..'; Build rate='..oBP.Economy.BuildRate..'; Focus unit build time='..oFocusUnitBP.Economy.BuildTime..'; Focus unit build cost mass='..oFocusUnitBP.Economy.BuildCostMass..'; Build rate mod='..iBuildRateMod) end
                                                        else
                                                            iCurUnitMassUsage = oBP.Economy.BuildRate * iBuildRateMod *  iMassPerBP
                                                        end
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Checking for what the unit is building or upgrading to get more accurate calculation, unit state='..M28UnitInfo.GetUnitState(oUnit)..'; mass usage after check='..iCurUnitMassUsage..'; Is focus unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit:GetFocusUnit()))) end
                                                else
                                                    iCurUnitMassUsage = (oUnit[refiLastMassUsage] or oBP.Economy.BuildRate * iBuildRateMod * iMassPerBP)
                                                end
                                            end
                                        end
                                    end
                                    --We're working in ticks so adjust mass usage accordingly
                                    iCurUnitMassUsage = iCurUnitMassUsage * 0.1
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': Estimated mass usage=' .. iCurUnitMassUsage..'; About to call the function PauseOrUnpauseMassUsage on unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; iUnitsAdjusted before counting this unit='..iUnitsAdjusted)
                                    end

                                    if not((iCurUnitMassUsage or 0) == 0) then iUnitsAdjusted = iUnitsAdjusted + 1 end
                                    M28UnitInfo.PauseOrUnpauseMassUsage(oUnit, bPauseNotUnpause, iTeam, iCategoryCount)
                                    --Cant move the below into unitinfo as get a crash if unitinfo tries to refernce the table of paused units
                                    --Have made localised variable which looks to fix the issue
                                end
                                if bApplyActionToUnit then
                                    if bPauseNotUnpause and not(bWasUnitAlreadyPaused) then
                                        iMassSavingManaged = iMassSavingManaged + iCurUnitMassUsage
                                    elseif bWasUnitAlreadyPaused and not (bPauseNotUnpause) then
                                        iMassSavingManaged = iMassSavingManaged - iCurUnitMassUsage
                                    end
                                end
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': iMassSavingManaged=' .. iMassSavingManaged .. '; iMassPerTickSavingNeeded=' .. iMassPerTickSavingNeeded .. '; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass])..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; bWasUnitAlreadyPaused='..tostring(bWasUnitAlreadyPaused)..'; bApplyActionToUnit='..tostring(bApplyActionToUnit)..'; iCurUnitMassUsage='..iCurUnitMassUsage)
                                end

                                if bPauseNotUnpause then
                                    if iMassSavingManaged > iMassPerTickSavingNeeded then
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Estimate we have saved ' .. iMassSavingManaged .. ' which is more tahn we wanted so will pause')
                                        end
                                        bAbort = true
                                        break
                                    end
                                else
                                    if iMassSavingManaged < iMassPerTickSavingNeeded then
                                        bAbort = true
                                        break
                                    end
                                end
                            end
                        elseif bDebugMessages == true then
                            LOG(sFunctionRef .. ': We have no units for iCategoryCount=' .. iCategoryCount)
                        end

                        if bAbort then
                            break
                        end
                        if bConsideringTeamWideUnits then break end --dont want to consider for more than one brain
                    end
                    if bAbort then
                        break
                    end
                end
                if bDebugMessages == true then
                    LOG(sFunctionRef .. 'If we have no paused units then will set us as not having a mass stall')
                end
                if M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount] <= 0 then
                    M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] = false
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': We are no longer stalling mass, setting paused unit count to 0 (it was already <=0)')
                    end
                    M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount] = 0
                    M28Team.tTeamData[iTeam][M28Team.refiLastMassStallCategoryAndEngineerTables] = nil
                else
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': About to check if we wanted to unpause units but havent unpaused anything; iUnitsAdjusted=' .. iUnitsAdjusted .. '; bNoRelevantUnits=' .. tostring(bNoRelevantUnits) .. '; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]))
                    end
                    --Backup - sometimes we still have units in the table listed as being paused (e.g. if an engineer changes action to one that isnt listed as needing pausing) - unpause them if we couldnt find via category search
                    if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] and not (bPauseNotUnpause) and (iMassSavingManaged > iMassPerTickSavingNeeded or iUnitsAdjusted == 0 or bNoRelevantUnits) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.03 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] >= 0.9 then
                        --Have a decent amount of mass, are flagged as stalling mass, but couldnt find any categories to unpause
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': werent able to find any units to unpause with normal approach so will unpause all remaining units')
                        end
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority]) == false then
                            for iCategory, tUnits in M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority] do
                                if tUnits then
                                    local iUnitCount = table.getn(tUnits)
                                    if iUnitCount > 0 then
                                        for iCurUnit = iUnitCount, 1, -1 do
                                            if M28UnitInfo.IsUnitValid(tUnits[iCurUnit]) then
                                                M28UnitInfo.PauseOrUnpauseMassUsage(tUnits[iCurUnit], false, iTeam)
                                            end
                                        end
                                    end
                                end
                                tUnits = nil
                            end
                        end
                        M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] = false
                        M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount] = 0
                        M28Team.tTeamData[iTeam][M28Team.refiLastMassStallCategoryAndEngineerTables] = nil

                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': FInished unpausing any remaining units and resetting the staling mass flag')
                        end
                    end
                end
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': End of code, M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) .. '; Stalling energy='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; bPauseNotUnpause=' .. tostring(bPauseNotUnpause) .. '; iUnitsAdjusted=' .. iUnitsAdjusted .. '; Game time=' .. GetGameTimeSeconds() .. '; Mass stored %=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] .. '; Net mass income=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] .. '; gross mass income=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; refiPausedUnitCount='..M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount])
            end
        end
    else
        M28Utilities.ErrorHandler('No active M28 brains')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageEnergyStalls(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageEnergyStalls'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        local bOnlyEasyAI = true
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            if not(oBrain.M28Easy) then bOnlyEasyAI = false break end
        end
        if not(bOnlyEasyAI) or GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastConsideredEnergyStall] or -10) >= 2.99 then
            M28Team.tTeamData[iTeam][M28Team.refiTimeLastConsideredEnergyStall] = GetGameTimeSeconds()
            local bPauseNotUnpause = true
            local bChangeRequired = false
            local iUnitsAdjusted = 0
            local bHaveWeCappedUnpauseAmount = false
            if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] or (GetGameTimeSeconds() >= 120 or (GetGameTimeSeconds() >= 40 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 15)) then
                --Only consider power stall management after 2m, otherwise risk pausing things such as early microbots when we would probably be ok after a couple of seconds; lower time limit put in as a theroetical possibility due to AIX
                if bDebugMessages == true then LOG(sFunctionRef .. ': About to consider if we have an energy stall or not. Lowest energy % stored=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] .. '; M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] .. '; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])) end
                --First consider unpausing
                if bDebugMessages == true then LOG(sFunctionRef .. ': If we have flagged that we are stalling energy then will check if we have enough to start unpausing things') end

                local iPercentMod = 0
                local iNetMod = 0

                --Also increase net energy if are at tech 3 and lack 3k power
                if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 300 then iNetMod = iNetMod + 25 end

                    iPercentMod = math.max(0.05, iPercentMod)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': If are in stall mode will check if want to come out. M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; Gross income='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Stored ratio='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored]..'; Net income='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; iNetMod='..iNetMod..'; iPercentMod='..iPercentMod..'; GameTime='..GetGameTimeSeconds()..'; M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled]='..M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled]..'; Changei n power since then='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] - M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled]) end

                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 800 then iPercentMod = math.max(iPercentMod,  math.min(iPercentMod + 0.2, 0.275)) end

                if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] - M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] >= 45 then
                    iPercentMod = iPercentMod -0.3
                end

                --Overcharge - pause even if we dont have terrible E income
                if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastNeededEnergyForOvercharge] or -10) <= 1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] < 0.9 then
                    bPauseNotUnpause = true
                    iPercentMod = math.max(0.5, iPercentMod)
                    if bDebugMessages == true then LOG(sFunctionRef..': ACU needs energy so will set percentmod to 50% at time '..GetGameTimeSeconds()) end
                end
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamEnergyStored] >= 200000 and iPercentMod > -0.6 then iPercentMod = iPercentMod - 0.1 end


                if (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 100000 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] > math.min(0.95, (0.8 + iPercentMod)) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] > (0.7 + iPercentMod) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > (1 + iNetMod)) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] > (0.5 + iPercentMod) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > (4 + iNetMod)) or (GetGameTimeSeconds() <= 180 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] >= 0.3 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] > M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] * 1.2)))) then
                    --M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] = false
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Have enough energy stored or income to start unpausing things if any are paused, refiPausedUnitCount='..M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount])
                        if M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount] > 0 then
                            local iShieldsAndRadarPaused = 0
                            for iPriority, tUnits in M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority] do
                                local tShieldsAndRadarPaused = EntityCategoryFilterDown(M28UnitInfo.refCategoryAllShieldUnits + M28UnitInfo.refCategoryRadar, tUnits)
                                if M28Utilities.IsTableEmpty(tShieldsAndRadarPaused) == false then
                                    LOG(sFunctionRef..': iPriority '..iPriority..' has '..table.getn(tShieldsAndRadarPaused)..' units with shield or radar that are paused')
                                end
                                iShieldsAndRadarPaused = iShieldsAndRadarPaused + table.getn(tShieldsAndRadarPaused)
                            end
                            LOG(sFunctionRef..': tShieldsAndRadarPaused in total='..iShieldsAndRadarPaused)
                        end
                    end
                    bPauseNotUnpause = false
                    if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] then bChangeRequired = true end
                end
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Checking if we shoudl flag that we are energy stalling; bChangeRequired='..tostring(bChangeRequired)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]))
                end

                if not(bChangeRequired) and not(bPauseNotUnpause) and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) then
                    --We arent stalling so shouldnt have any units that are paused; Cycle thorugh each brain and check that the only units that are paused are missile launchers with loaded missiles
                    local bHaveUnexpectedlyPausedUnits = false
                    if M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount] > 0 then --This section is a redundancy as came across scenario where had paused factories and launchers when not stalling, and logs indicated we didnt think we were stalling
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority]) == false then
                            for iCategory, tUnits in M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority] do
                                if tUnits then
                                    for iUnit, oUnit in tUnits do
                                        if not(EntityCategoryContains(categories.SILO * categories.NUKE + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategoryTML, oUnit.UnitId)) then
                                            bHaveUnexpectedlyPausedUnits = true
                                            break
                                        else
                                            if M28UnitInfo.GetMissileCount(oUnit) == 0 then
                                                bHaveUnexpectedlyPausedUnits = true
                                                break
                                            end
                                        end
                                    end
                                    if bHaveUnexpectedlyPausedUnits then break end
                                end
                            end

                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount]='..M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount]..'; bHaveUnexpectedlyPausedUnits='..tostring(bHaveUnexpectedlyPausedUnits)) end
                    end
                    if bHaveUnexpectedlyPausedUnits then
                        bChangeRequired = true
                    end
                end
                --Check if should manage energy stall
                if bChangeRequired == false and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= (0.08 + iPercentMod) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= (0.6 + iPercentMod) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < (2 + iNetMod)) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= (0.4 + iPercentMod) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < (0.5 + (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] - 1) * 5 + iNetMod))) then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': We are stalling energy, will look for units to pause, subject to early game check')
                    end
                    --If this is early game then add extra check
                    if GetGameTimeSeconds() >= 180 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= 0.04 then
                        M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] = true
                        bChangeRequired = true
                        if not(M28Team.tTeamData[iTeam][M28Team.refbJustBuiltLotsOfPower]) then M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] = M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] end
                        if bDebugMessages == true then LOG(sFunctionRef..': early game check cleared, so are stalling energy') end
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Will move on to main pause or unpause logic now if change is required, bChangeRequired='..tostring(bChangeRequired)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)) end

                if bChangeRequired then
                    --Consider if we want to hold off pausing a T1 land fac upgrading to T2 if enemy has T2 arti threat (since we need MMLs)
                    local bDontPauseUpgradingT1LandOrT2Land = false
                    local bStopPausingIfGotToFactoriesAndHaveSomeEnergy = false
                    if M28Team.tTeamData[iTeam][M28Team.subrefiLowestFriendlyLandFactoryTech] == 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] < 3 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]) == false then
                        for iFactory, oFactory in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs] do
                            if M28UnitInfo.IsUnitValid(oFactory) then
                                local tFactoryLZData, tFactoryLZTeamData = M28Map.GetLandOrWaterZoneData(oFactory:GetPosition(), true, iTeam)
                                if tFactoryLZTeamData and M28Conditions.SaveMassForMMLForFirebase(tFactoryLZData, tFactoryLZTeamData, iTeam, true) then
                                    bDontPauseUpgradingT1LandOrT2Land = true
                                    break
                                end
                            end
                        end

                    end

                    if bPauseNotUnpause then
                        if bDebugMessages == true then LOG(sFunctionRef..': Change is required and we want to pause units, time='..GetGameTimeSeconds()) end
                        M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] = true
                        if not(M28Team.tTeamData[iTeam][M28Team.refbJustBuiltLotsOfPower]) then M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] = M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] end
                        if M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] >= 0.25 then bStopPausingIfGotToFactoriesAndHaveSomeEnergy = true end
                    end --redundancy
                    M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] = GetGameTimeSeconds() --Have even if unpausing, since we may only unpause some of the units
                    --Decide on order to pause/unpause

                    local tCategoriesByPriority, tEngineerActionsByPriority = GetCategoryAndActionsToPauseWhenStalling(iTeam)
                    if bDebugMessages == true then LOG(sFunctionRef..': tCategoriesByPriority='..reprs(tCategoriesByPriority)) end

                    local iEnergyPerTickSavingNeeded
                    if bPauseNotUnpause then
                        iEnergyPerTickSavingNeeded = math.max(1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] + iNetMod * 0.5 + M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.02)
                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= 0.15 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have less than 15% energy stored so increasing the energy saving wanted. iEnergyPerTickSavingNeeded pre increase='..iEnergyPerTickSavingNeeded..'; Gross base income='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Team lowest energy storage units='..M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount]) end
                            local iStorageFactor = 50
                            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 1000 then iStorageFactor = 100 end
                            iEnergyPerTickSavingNeeded = math.max(iEnergyPerTickSavingNeeded * 1.3, iEnergyPerTickSavingNeeded + M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.03)
                            iEnergyPerTickSavingNeeded = math.max(iEnergyPerTickSavingNeeded, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.06, math.min(M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] * iStorageFactor, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]*0.15))
                        elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= 0.225 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Less than 22.5% energy stored so increasing energy saving slightly') end
                            iEnergyPerTickSavingNeeded = math.max(iEnergyPerTickSavingNeeded * 1.15, iEnergyPerTickSavingNeeded + M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.015)
                        end
                    else
                        iEnergyPerTickSavingNeeded = math.min(-1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy], -M28Team.tTeamData[iTeam][M28Team.subrefiTeamEnergyStored] / 30)
                        iEnergyPerTickSavingNeeded = math.max(iEnergyPerTickSavingNeeded, math.min(-300, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] * 0.5), math.min(-600, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] * 0.25))
                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= 0.75 then iEnergyPerTickSavingNeeded = iEnergyPerTickSavingNeeded * 0.75 end
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to start unpausing things, M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored]..'; iEnergyPerTickSavingNeeded='..iEnergyPerTickSavingNeeded) end
                    end

                    local iEnergySavingManaged = 0
                    local iEngineerSubtableCount = 0
                    local tEngineerActionSubtable
                    local oUnit
                    local iBuildRateMod

                    local bAbort = false
                    local iTotalUnits = 0
                    local iCategoryStartPoint, iIntervalChange, iCategoryEndPoint, iCategoryRef
                    local bWasUnitAlreadyPaused
                    if bPauseNotUnpause then
                        iCategoryStartPoint = 1
                        iIntervalChange = 1
                        iCategoryEndPoint = table.getn(tCategoriesByPriority)
                    else
                        iCategoryStartPoint = table.getn(tCategoriesByPriority)
                        iIntervalChange = -1
                        iCategoryEndPoint = 1
                    end

                    local bConsideringHQ
                    local bConsideringTeamWideUnits = false
                    local bNoRelevantUnits = true

                    if bDebugMessages == true then LOG(sFunctionRef .. ': About to cycle through every category, bPauseNotUnpause=' .. tostring(bPauseNotUnpause) .. '; iCategoryStartPoint=' .. iCategoryStartPoint .. '; iCategoryEndPoint=' .. iCategoryEndPoint..'; iEnergyPerTickSavingNeeded='..iEnergyPerTickSavingNeeded) end

                    local bConsideringFactory
                    local bFirstBrain
                    for iCategoryCount = iCategoryStartPoint, iCategoryEndPoint, iIntervalChange do
                        local tRelevantUnits
                        iCategoryRef = tCategoriesByPriority[iCategoryCount]
                        bConsideringFactory = false

                        --Are we considering upgrading factory HQs?
                        if iCategoryRef == iSpecialHQCategory then
                            iCategoryRef = M28UnitInfo.refCategoryAllHQFactories
                            bConsideringHQ = true
                            bConsideringTeamWideUnits = false
                        else
                            if iCategoryRef == iSpecialSurplusUpgradeCategory then
                                bConsideringTeamWideUnits = true
                            else
                                bConsideringTeamWideUnits = false
                            end
                            bConsideringHQ = false
                        end

                        local iCurUnitEnergyUsage
                        local bApplyActionToUnit
                        local oBP
                        local oFocusUnitBP
                        local bFirstEngiCategoryRefBrain = true


                        bFirstBrain = true
                        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                            if oBrain.CheatEnabled then iBuildRateMod = M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier]
                            else iBuildRateMod = 1
                            end
                            if bPauseNotUnpause then
                                if iCategoryRef == iSpecialSurplusUpgradeCategory then
                                    --Pause all but 1 upgrade per brain, pausing the lowest progress first, if we have multiple upgrades
                                    tRelevantUnits = {}
                                    if M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) then
                                        local iMexesToPause
                                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 150 * M28Team.tTeamData[oBrain.M28Team][M28Team.subrefiActiveM28BrainCount] then
                                            iMexesToPause = math.max(0, table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) - M28Team.tTeamData[oBrain.M28Team][M28Team.subrefiActiveM28BrainCount])
                                        elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 35 * M28Team.tTeamData[oBrain.M28Team][M28Team.subrefiActiveM28BrainCount] then
                                            iMexesToPause = math.max(0, table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]))
                                        else
                                            iMexesToPause = math.max(0, table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) - (0.5 + 0.5 * M28Team.tTeamData[oBrain.M28Team][M28Team.subrefiActiveM28BrainCount]))
                                        end

                                        while iMexesToPause > 0 do
                                            local iLowestProgress = 0.85
                                            local oLowestProgress
                                            local bAlreadyIncluded
                                            for iUnit, oUnit in M28Team.tTeamData[oBrain.M28Team][M28Team.subreftTeamUpgradingMexes] do
                                                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetWorkProgress() < iLowestProgress then
                                                    bAlreadyIncluded = false
                                                    --Is the unit already in the table of relevant units?
                                                    if M28Utilities.IsTableEmpty(tRelevantUnits) == false then
                                                        for iRecordedUnit, oRecordedUnit in tRelevantUnits do
                                                            if oRecordedUnit == oUnit then bAlreadyIncluded = true break end
                                                        end
                                                    end
                                                    if not(bAlreadyIncluded) then
                                                        oLowestProgress = oUnit
                                                        iLowestProgress = oUnit:GetWorkProgress()
                                                    end
                                                end
                                            end
                                            if oLowestProgress then
                                                table.insert(tRelevantUnits, oLowestProgress)
                                            else
                                                break
                                            end
                                            iMexesToPause = iMexesToPause - 1
                                        end
                                    end
                                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[oBrain.M28Team][M28Team.subreftTeamUpgradingOther]) == false then
                                        for iUnit, oUnit in M28Team.tTeamData[oBrain.M28Team][M28Team.subreftTeamUpgradingOther] do
                                            table.insert(tRelevantUnits, oUnit)
                                        end
                                    end
                                else
                                    tRelevantUnits = oBrain:GetListOfUnits(iCategoryRef, false, true)
                                end
                            else
                                if bFirstBrain then
                                    tRelevantUnits = M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority][iCategoryCount]
                                    bFirstBrain = false
                                else
                                    break
                                end
                            end

                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iCategoryCount='..iCategoryCount..' for brain '..oBrain.Nickname..'; Is table of relevant units empty='..tostring(M28Utilities.IsTableEmpty(tRelevantUnits))) end
                            if M28Utilities.IsTableEmpty(tRelevantUnits) == false then
                                if bFirstBrain then
                                    --Will be pausing if are in this scenario as bFirstBrain is set to false earlier on for unpausing
                                    bConsideringFactory = EntityCategoryContains(M28UnitInfo.refCategoryAirFactory + M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryNavalFactory - M28UnitInfo.refCategorySpecialFactory, tRelevantUnits[1].UnitId)
                                    bFirstBrain = false
                                end
                                bNoRelevantUnits = false
                                iTotalUnits = table.getn(tRelevantUnits)
                                if bDebugMessages == true then LOG(sFunctionRef .. ': iCategoryCount=' .. iCategoryCount .. '; iTotalUnits=' .. iTotalUnits .. '; bPauseNotUnpause=' .. tostring(bPauseNotUnpause)..'; iEngineerSubtableCount before increasing='..iEngineerSubtableCount..'; tEngineerActionsByPriority='..repru(tEngineerActionsByPriority)) end

                                if iCategoryRef == M28UnitInfo.refCategoryEngineer then
                                    if bFirstEngiCategoryRefBrain then
                                        iEngineerSubtableCount = iEngineerSubtableCount + 1
                                        bFirstEngiCategoryRefBrain = false
                                    end
                                    tEngineerActionSubtable = tEngineerActionsByPriority[iEngineerSubtableCount]
                                end

                                for iUnit = iTotalUnits, 1, -1 do
                                    oUnit = tRelevantUnits[iUnit]
                                    --for iUnit, oUnit in tRelevantUnits do
                                    bApplyActionToUnit = false
                                    iCurUnitEnergyUsage = 0
                                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then  --Only consider unit if it has been constructed
                                        if not(bPauseNotUnpause) then
                                            bApplyActionToUnit = true
                                            if (oUnit.GetTacticalSiloAmmoCount or oUnit.GetTacticalSiloAmmoCount) then
                                                if M28UnitInfo.GetMissileCount(oUnit) >= 2 then
                                                    --Dont unpause TML, SML and SMD that have 2+ missiles loaded already
                                                    bApplyActionToUnit = false
                                                end
                                            elseif bConsideringHQ or (bDontPauseUpgradingT1LandOrT2Land and EntityCategoryContains(categories.TECH1 * M28UnitInfo.refCategoryLandFactory, oUnit.UnitId)) then
                                                --Only unpause HQs
                                                bApplyActionToUnit = false
                                                if oUnit:IsUnitState('Upgrading') and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]) == false then
                                                    for iFactory, oFactory in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs] do
                                                        if oUnit == oFactory then
                                                            bApplyActionToUnit = true
                                                            break
                                                        end
                                                    end
                                                end
                                            end
                                        else
                                            if bDebugMessages == true then
                                                LOG(sFunctionRef .. ': About to consider pausing/unpausingunit ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. '; will first check category specific logic for if we want to go ahead with pausing4; bConsideringFactory='..tostring(bConsideringFactory))
                                            end


                                            --Do we actually want to pause the unit? check any category specific logic
                                            bApplyActionToUnit = true
                                            if bDebugMessages == true then
                                                LOG(sFunctionRef .. ': UnitState=' .. M28UnitInfo.GetUnitState(oUnit) .. '; Is ActiveHQUpgrades Empty=' .. tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs])))
                                            end
                                            --SMD LOGIC - Check if already have 1 missile loaded before pausing (unless enemy has no nukes)
                                            if iCategoryRef == M28UnitInfo.refCategorySMD and oUnit.GetTacticalSiloAmmoCount and oUnit:GetTacticalSiloAmmoCount() == 0 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false then
                                                if bDebugMessages == true then
                                                    LOG(sFunctionRef .. ': Have SMD with at least 1 missile so will pause it')
                                                end
                                                bApplyActionToUnit = false
                                            elseif iCategoryRef == M28UnitInfo.refCategoryEngineer then
                                                if bDebugMessages == true then
                                                    LOG(sFunctionRef .. ': Have an engineer with action=' .. (oUnit[M28Engineer.refiAssignedAction] or 'nil') .. '; tEngineerActionSubtable=' .. repru(tEngineerActionSubtable)..'; Brain gross energy income='..oBrain[refiGrossEnergyBaseIncome])
                                                end
                                                bApplyActionToUnit = false

                                                for iActionCount, iActionRef in tEngineerActionSubtable do
                                                    if iActionRef == oUnit[M28Engineer.refiAssignedAction] then
                                                        bApplyActionToUnit = true
                                                        --Dont pause the last engi building power

                                                        if iActionRef == M28Engineer.refActionBuildPower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.7 then
                                                            bApplyActionToUnit = false
                                                            --Dont pause T1 factory construction if we have a certain amount of gross energy income
                                                        elseif iActionRef == M28Engineer.refActionBuildLandFactory and EntityCategoryContains(categories.TECH1, oUnit.UnitId) and oBrain[refiGrossEnergyBaseIncome] >= 26 then
                                                            if oUnit[M28Engineer.refbPrimaryBuilder] then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': wont pause primary engineer building t1 land fac') end
                                                                bApplyActionToUnit = false
                                                            else
                                                                local tEngiZone, tEngiTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                                                if not(tEngiTeamData[M28Map.subrefLZbCoreBase]) then
                                                                    --Keep building expansion land fac
                                                                    bApplyActionToUnit = false
                                                                end
                                                            end
                                                        elseif iActionRef == M28Engineer.refActionManageGameEnderTemplate and oUnit[M28Engineer.refbPrimaryBuilder] then
                                                            bApplyActionToUnit = false
                                                        end
                                                        break
                                                    end
                                                end
                                            elseif iCategoryRef == M28UnitInfo.refCategoryPersonalShield or iCategoryRef == M28UnitInfo.refCategoryFixedShield or iCategoryRef == M28UnitInfo.refCategoryMobileLandShield then
                                                --Dont disable shield if unit has enemies nearby
                                                if (oUnit[M28Building.reftArtiTemplateRefs] or (M28UnitInfo.IsUnitShieldEnabled(oUnit) and M28Utilities.IsTableEmpty(oBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryDangerousToLand, oUnit:GetPosition(), 40, 'Enemy')) == false)) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Shield has enemies nearby so wont pause it') end
                                                    bApplyActionToUnit = false
                                                end
                                            elseif bConsideringFactory then
                                                --Dont want to pause an HQ upgrade since it will give us better power, unless we already have access to that tech for the factory brain owner
                                                if (bDontPauseUpgradingT1LandOrT2Land and EntityCategoryContains(categories.TECH1 * M28UnitInfo.refCategoryLandFactory, oUnit.UnitId)) or (not (bConsideringHQ) and oUnit:IsUnitState('Upgrading') and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]) == false and EntityCategoryContains(categories.FACTORY, oUnit.UnitId) and (not(EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oUnit.UnitId)) or oUnit:GetAIBrain()[refiOurHighestFactoryTechLevel] <= M28UnitInfo.GetUnitTechLevel(oUnit))) then
                                                    for iFactory, oFactory in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs] do
                                                        if oUnit == oFactory then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with an upgrading factory, bConsideringHQ='..tostring(bConsideringHQ)..'; wont pause this factorys upgrade as it would give us a higher tech that could give us more power') end
                                                            bApplyActionToUnit = false
                                                            break
                                                        end
                                                    end
                                                end
                                                if bApplyActionToUnit then
                                                    if oUnit[M28Orders.reftiLastOrders][1][M28Orders.subrefsOrderBlueprint] and EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit[M28Orders.reftiLastOrders][1][M28Orders.subrefsOrderBlueprint]) and (oUnit[M28Orders.refiOrderCount] or 0) <= 1 then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Unit last order was to build an engineer so dont want to pause it as more engieneers might help us recover from a power stall by building more power') end
                                                        bApplyActionToUnit = false
                                                    elseif bStopPausingIfGotToFactoriesAndHaveSomeEnergy and EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) and not(oUnit:IsUnitState('Upgrading')) then
                                                        bApplyActionToUnit = false
                                                    end
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to pause unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Cur blueprint building='..(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subrefsOrderBlueprint] or 'nil')..'; bConsideringHQ='..tostring(bConsideringHQ)..'; bApplyActionToUnit='..tostring(bApplyActionToUnit)..'; Time='..GetGameTimeSeconds()) end

                                                if bApplyActionToUnit then
                                                    --Dont pause factory that is building an engineer or is an air factory that isnt building an air unit, if its our highest tech level and we dont have at least 5 engis of that tech level
                                                    if M28UnitInfo.GetUnitTechLevel(oUnit) >= math.max(2, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) and oBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(M28UnitInfo.GetUnitTechLevel(oUnit))) < 2 then
                                                        --Dont pause factory as have too few engis and want to build power with those engis
                                                        if bDebugMessages == true then LOG(sFunctionRef .. ': Have too few engineers so wont pause factory') end
                                                        bApplyActionToUnit = false
                                                    end
                                                end
                                            elseif iCategoryRef == M28UnitInfo.refCategoryTML and M28UnitInfo.GetMissileCount(oUnit) == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 30 then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Dealing with TML that has no missile so dont want to pause it') end
                                                bApplyActionToUnit = false
                                            end

                                            if iCategoryRef == categories.COMMAND then
                                                --want in addition to above as ACU might have personal shield

                                                if not (oUnit:IsUnitState('Upgrading')) then
                                                    bApplyActionToUnit = false
                                                elseif oUnit.GetWorkProgress then
                                                    if oUnit:GetWorkProgress() >= 0.85 then
                                                        bApplyActionToUnit = false
                                                        --dont pause t1 mex construction
                                                    elseif oUnit.GetFocusUnit and oUnit:GetFocusUnit() and oUnit:GetFocusUnit().UnitId and EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oUnit:GetFocusUnit().UnitId) then
                                                        bApplyActionToUnit = false
                                                    end
                                                end
                                            end
                                        end
                                    elseif bDebugMessages == true then LOG(sFunctionRef..': Unit entry='..iUnit..'; Unit isnt valid or constructed')
                                    end



                                    --Pause the unit
                                    if bDebugMessages == true then LOG(sFunctionRef..': bApplyActionToUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'='..tostring(bApplyActionToUnit)) end

                                    if bApplyActionToUnit then
                                        bWasUnitAlreadyPaused = oUnit[M28UnitInfo.refbPaused] --Means we will ignore the energy usage when calculating how much we have saved
                                        oBP = oUnit:GetBlueprint()
                                        iCurUnitEnergyUsage = oBP.Economy.MaintenanceConsumptionPerSecondEnergy

                                        if (iCurUnitEnergyUsage or 0) == 0 or EntityCategoryContains(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryMex + categories.COMMAND, oUnit.UnitId) then
                                            --Approximate energy usage based on build rate as a very rough guide
                                            --examples: Upgrading mex to T3 costs 11E per BP; T3 power is 8.4; T1 power is 6; Guncom is 30; Laser is 178; Strat bomber is 15
                                            local iEnergyPerBP = 9
                                            if EntityCategoryContains(categories.SILO, oUnit.UnitId) and oBP.Economy.BuildRate then
                                                --Dealing with a silo so need to calculate energy usage differently
                                                iCurUnitEnergyUsage = 0
                                                for iWeapon, tWeapon in oBP.Weapon do
                                                    if tWeapon.MaxProjectileStorage and tWeapon.ProjectileId then
                                                        local oProjectileBP = __blueprints[tWeapon.ProjectileId]
                                                        if oProjectileBP.Economy and oProjectileBP.Economy.BuildCostEnergy and oProjectileBP.Economy.BuildTime > 0 and oBP.Economy.BuildRate > 0 then
                                                            --(will multiply cost by 10% in later step)
                                                            iCurUnitEnergyUsage = oProjectileBP.Economy.BuildCostEnergy * oBP.Economy.BuildRate * iBuildRateMod / oProjectileBP.Economy.BuildTime
                                                            --If are power stalling then assume we only save 80% of this, as might have adjacency
                                                            if bPauseNotUnpause then iCurUnitEnergyUsage = iCurUnitEnergyUsage * 0.8 end
                                                            break
                                                        end
                                                    end
                                                end
                                            else
                                                if iCategoryRef == categories.COMMAND and oUnit[M28Orders.refiOrderCount] > 0 and oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] == M28Orders.refiOrderEnhancement then
                                                    --Determine energy cost per BP
                                                    local sUpgradeRef = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint]
                                                    iEnergyPerBP = M28UnitInfo.GetUpgradeEnergyCost(oUnit, sUpgradeRef) / (M28UnitInfo.GetUpgradeBuildTime(oUnit, sUpgradeRef) or 1)
                                                    oUnit[refiLastEnergyUsage] = iCurUnitEnergyUsage
                                                else
                                                    --Engineer - adjust energy consumption based on what are building
                                                    iEnergyPerBP = 3
                                                end

                                                if oBP.Economy.BuildRate then
                                                    --iCurUnitEnergyUsage = oBP.Economy.BuildRate * iEnergyPerBP
                                                    --Reduce this massively if unit isn't actually building anything
                                                    if bPauseNotUnpause then
                                                        if (not(oUnit:IsUnitState('Building')) and not(oUnit:IsUnitState('Repairing')) and not(oUnit.GetWorkProgress and oUnit:GetWorkProgress() > 0)) then
                                                            iCurUnitEnergyUsage = oBP.Economy.BuildRate * iBuildRateMod * 0.01
                                                        else
                                                            if M28UnitInfo.IsUnitValid(oUnit:GetFocusUnit()) then
                                                                oFocusUnitBP = oUnit:GetFocusUnit():GetBlueprint()
                                                                iCurUnitEnergyUsage = oBP.Economy.BuildRate * iBuildRateMod / oFocusUnitBP.Economy.BuildTime * oFocusUnitBP.Economy.BuildCostEnergy
                                                                oUnit[refiLastEnergyUsage] = iCurUnitEnergyUsage
                                                            else
                                                                iCurUnitEnergyUsage = oBP.Economy.BuildRate * iBuildRateMod * iEnergyPerBP
                                                            end
                                                        end
                                                    else
                                                        iCurUnitEnergyUsage = (oUnit[refiLastEnergyUsage] or oBP.Economy.BuildRate * iBuildRateMod * iEnergyPerBP)
                                                    end
                                                end
                                            end
                                        end
                                        --We're working in ticks so adjust energy usage accordingly
                                        iCurUnitEnergyUsage = iCurUnitEnergyUsage * 0.1
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Estimated energy usage before factoring in unit state=' .. iCurUnitEnergyUsage..'; About to call the function PauseOrUnpauseEnergyUsage on unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; iUnitsAdjusted where expected to save energy='..iUnitsAdjusted)
                                        end

                                        if not((iCurUnitEnergyUsage or 0) == 0) then
                                            iUnitsAdjusted = iUnitsAdjusted + 1
                                            if bPauseNotUnpause and EntityCategoryContains(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryFactory, oUnit.UnitId) then
                                                if not(oUnit:IsUnitState('Upgrading') or oUnit:IsUnitState('Repairing') or oUnit:IsUnitState('Building')) then
                                                    iCurUnitEnergyUsage = iCurUnitEnergyUsage * 0.01
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Unit state='..M28UnitInfo.GetUnitState(oUnit)..' so will set the amount of energy saved equal to just 1% of the actual value, so it is now '..iCurUnitEnergyUsage) end
                                                end
                                            end
                                        end
                                        M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, bPauseNotUnpause, nil, iTeam, iCategoryCount)
                                        --Cant move the below into unitinfo as get a crash if unitinfo tries to refernce the table of paused units
                                        --Managed to avoid the crash by making a localised import of M28Economy into the pauseorunpause function; want it in unitinfo as then m28orders can call the same function when clearing an engineer's orders


                                        --[[if bPauseNotUnpause then
                                            table.insert(oBrain[reftPausedUnits], oUnit)
                                            if bDebugMessages == true then
                                                LOG(sFunctionRef .. ': Added unit to tracker table, size=' .. table.getn(oBrain[reftPausedUnits]))
                                            end
                                        else
                                            if bDebugMessages == true then
                                                LOG(sFunctionRef .. ': Will remove unit from reftPausedUnits. Size of table before removal=' .. table.getn(oBrain[reftPausedUnits]))
                                            end
                                            for iPausedUnit, oPausedUnit in oBrain[reftPausedUnits] do
                                                if oPausedUnit == oUnit then
                                                    table.remove(oBrain[reftPausedUnits], iPausedUnit)
                                                end
                                            end
                                            if bDebugMessages == true then
                                                LOG(sFunctionRef .. ': Size of table after removal =' .. table.getn(oBrain[reftPausedUnits]))
                                            end
                                        end--]]

                                    end

                                    if not (bWasUnitAlreadyPaused) and bPauseNotUnpause then
                                        iEnergySavingManaged = iEnergySavingManaged + iCurUnitEnergyUsage
                                    elseif bWasUnitAlreadyPaused and not (bPauseNotUnpause) then
                                        iEnergySavingManaged = iEnergySavingManaged - iCurUnitEnergyUsage
                                    end
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': iEnergySavingManaged=' .. iEnergySavingManaged .. '; iEnergyPerTickSavingNeeded=' .. iEnergyPerTickSavingNeeded .. '; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; bWasUnitAlreadyPaused='..tostring(bWasUnitAlreadyPaused)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; iCurUnitEnergyUsage='..iCurUnitEnergyUsage)
                                    end

                                    if bPauseNotUnpause then
                                        if iEnergySavingManaged > iEnergyPerTickSavingNeeded then
                                            if bDebugMessages == true then
                                                LOG(sFunctionRef .. ': Estimate we have saved ' .. iEnergySavingManaged .. ' which is more tahn we wanted so will pause')
                                            end
                                            bAbort = true
                                            break
                                        end
                                    else
                                        if iEnergySavingManaged < iEnergyPerTickSavingNeeded then
                                            bAbort = true
                                            break
                                        end
                                    end
                                end
                            elseif bDebugMessages == true then
                                LOG(sFunctionRef .. ': We have no units for iCategoryCount=' .. iCategoryCount)
                            end



                            if bAbort then
                                break
                            end
                            if bConsideringTeamWideUnits then break end --dont want to consider for more than one brain
                        end
                        if bAbort then
                            break
                        end
                    end

                    if bDebugMessages == true then LOG(sFunctionRef .. 'If we have no paused units then will set us as not having an energy stall; M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount]='..M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount]..'; subrefbTeamIsStallingMass ='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass])..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)) end
                    if M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount] <= 0 then
                        M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] = false
                        M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount] = 0
                        M28Team.tTeamData[iTeam][M28Team.refiLastEnergyStallCategoryAndEngineerTables] = nil
                        if bDebugMessages == true then LOG(sFunctionRef .. ': We are no longer stalling energy, we had a paused unit count of <= 0') end
                    elseif M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] and not(bPauseNotUnpause) and not(bHaveWeCappedUnpauseAmount) then
                        --Unpause all units' energy usage only (i.e. production remains paused, but radar and shields should be unpaused
                        for iCategory, tUnits in M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority] do
                            if tUnits then
                                for iUnit, oUnit in tUnits do
                                    if M28UnitInfo.IsUnitValid(oUnit) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will pause just the energy usage parts of unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                        M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, false, true, iTeam)
                                    end
                                end
                            end
                        end

                        if bDebugMessages == true then LOG(sFunctionRef..': Are stalling mass so have finished unpausing energy usage of units at time='..GetGameTimeSeconds()) end
                        M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] = false
                        M28Team.tTeamData[iTeam][M28Team.refiLastEnergyStallCategoryAndEngineerTables] = nil
                    else
                        if bDebugMessages == true then LOG(sFunctionRef .. ': About to check if we wanted to unpause units but havent unpaused anything; iUnitsAdjusted=' .. iUnitsAdjusted .. '; bNoRelevantUnits=' .. tostring(bNoRelevantUnits) .. '; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])) end
                        --Backup - sometimes we still have units in the table listed as being paused (e.g. if an engineer changes action to one that isnt listed as needing pausing) - unpause them if we couldnt find via category search
                        if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] and not (bPauseNotUnpause) and (iEnergySavingManaged > iEnergyPerTickSavingNeeded or iUnitsAdjusted == 0 or bNoRelevantUnits) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] >= 0.95 then
                            --Have a decent amount of power, are flagged as stalling energy, but couldnt find any categories to unpause
                            if bDebugMessages == true then LOG(sFunctionRef .. ': werent able to find any units to unpause with normal approach so will unpause all remaining units for all M28 brains in the team') end
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority]) == false then
                                for iCategory, tUnits in M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority] do
                                    if tUnits then
                                        local iUnitCount = table.getn(tUnits)
                                        if iUnitCount > 0 then
                                            for iCurUnit = iUnitCount, 1, -1 do
                                                if M28UnitInfo.IsUnitValid(tUnits[iCurUnit]) then
                                                    M28UnitInfo.PauseOrUnpauseEnergyUsage(tUnits[iCurUnit], false, iTeam)
                                                end
                                            end
                                        end
                                    end
                                    tUnits = nil
                                end
                            end
                            M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] = false
                            M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount] = 0
                            M28Team.tTeamData[iTeam][M28Team.refiLastMassStallCategoryAndEngineerTables] = nil


                            if bDebugMessages == true then LOG(sFunctionRef .. ': FInished unpausing units and resetting the flag re paused units') end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef .. ': End of code, M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) .. '; bPauseNotUnpause=' .. tostring(bPauseNotUnpause) .. '; iUnitsAdjusted=' .. iUnitsAdjusted .. '; Game time=' .. GetGameTimeSeconds() .. '; Energy stored %=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] .. '; Net energy income=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] .. '; gross energy income=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]) end
                if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] then
                    M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] = GetGameTimeSeconds()
                end
            end

            if bDebugMessages == true then
                LOG(sFunctionRef..': Will now call manage mass stalls if not stalling energy. M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; bChangeRequired='..tostring(bChangeRequired)..'; is team stalling mass (pre mass stall check)='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass])..'; M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount]='..M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount])
            end
            if not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and not(bChangeRequired) then
                ForkThread(ManageMassStalls, iTeam)
            end
        end
    else
        M28Utilities.ErrorHandler('No active M28 brains')
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function GetEnergyStorageMaximum(aiBrain, bDetailedUpdate)
    --bDetailedUpdate - called periodically (but not by the every tick team resource sharer)
    if aiBrain:GetEconomyStoredRatio('ENERGY') > 0 then
        aiBrain[refiMaxEnergyStorage] = aiBrain:GetEconomyStored('ENERGY') / aiBrain:GetEconomyStoredRatio('ENERGY')
        return aiBrain[refiMaxEnergyStorage]
    else
        if bDetailedUpdate then
            aiBrain[refiMaxEnergyStorage] = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEnergyStorage) * M28Building.iEnergyStorageExpectedCapacity + aiBrain:GetCurrentUnits(categories.COMMAND) * 3900 + 100 + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryQuantumOptics) * 10000
        end
        return aiBrain[refiMaxEnergyStorage]
    end
end

function GetMassStorageMaximum(aiBrain, bDetailedUpdate)
    if aiBrain:GetEconomyStoredRatio('MASS') > 0 then
        aiBrain[refiMaxMassStorage] = aiBrain:GetEconomyStored('MASS') / aiBrain:GetEconomyStoredRatio('MASS')
        return aiBrain[refiMaxMassStorage]
    else
        if bDetailedUpdate then
            aiBrain[refiMaxMassStorage] = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMassStorage) * 500 + aiBrain:GetCurrentUnits(categories.COMMAND) * 650 + 150
        end
        return aiBrain[refiMaxMassStorage]
    end
end


function GiveResourcesToPlayer(oBrainGiver, oBrainReceiver, iMass, iEnergy)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GiveResourcesToPlayer'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Check we have the resources to give:
    if iMass > 0 and oBrainGiver:GetEconomyStored('MASS') >= iMass then
        --Check the person receiving has enough capacity
        if GetMassStorageMaximum(oBrainReceiver) - oBrainReceiver:GetEconomyStored('MASS') >= iMass then
            oBrainReceiver:GiveResource('Mass', iMass)
            oBrainGiver:TakeResource('Mass', iMass)
            if bDebugMessages == true then LOG(sFunctionRef..': Given '..iMass..' Mass from '..oBrainGiver.Nickname..' to '..oBrainReceiver.Nickname) end

        end
    end
    if iEnergy > 0 and oBrainGiver:GetEconomyStored('ENERGY') >= iEnergy then
        if GetEnergyStorageMaximum(oBrainReceiver) - oBrainReceiver:GetEconomyStored('ENERGY') >= iEnergy then
            oBrainReceiver:GiveResource('Energy', iEnergy)
            oBrainGiver:TakeResource('Energy', iEnergy)
            if bDebugMessages == true then LOG(sFunctionRef..': Given '..iEnergy..' Energy from '..oBrainGiver.Nickname..' to '..oBrainReceiver.Nickname) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function ShareResourcesMassAndEnergyBetweenTeam() M28Utilities.ErrorHandler('Using superceded code')  end --Done to make the below easier to find
function AllocateTeamEnergyAndMassResources(iTeam)
    --Smoothes out energy storage for M28 brains on the same team, where % storage is <95%

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AllocateTeamEnergyResources'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iTeam='..iTeam..'; Is table of active brains empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then

        local refiResourceEnergy = 1
        local refiResourceMass = 2
        local tDetailsOfBrainsNeedingEnergy = {}
        local tDetailsOfBrainsWithEnergy = {}
        local tDetailsOfBrainsNeedingMass = {}
        local tDetailsOfBrainsWithMass = {}

        local subrefoBrain = 1
        local subrefiRemainingResourceNeeded = 2
        local subrefiResourceToGive = 3

        local iTotalEnergyStored = 0
        local iTotalMassStored = 0

        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            iTotalEnergyStored = iTotalEnergyStored + oBrain:GetEconomyStored('ENERGY')
            iTotalMassStored = iTotalMassStored + oBrain:GetEconomyStored('MASS')
        end
        local iAverageEnergyStored = iTotalEnergyStored / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]
        local iAverageMassStored = iTotalMassStored / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]
        local iCurEnergySpare, iCurMassSpare

        if bDebugMessages == true then LOG(sFunctionRef..': Near start, time='..GetGameTimeSeconds()..'; iAverageEnergyStored='..iAverageEnergyStored..'; iAverageMassStored='..iAverageMassStored) end

        --Sort brains into those that have mass, and those that give mass
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            iCurEnergySpare = oBrain:GetEconomyStored('ENERGY') - iAverageEnergyStored
            --Adjust spare energy if we have significantly different % to average
            if math.abs(oBrain:GetEconomyStoredRatio('ENERGY') - M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored]) >= 0.3 then
                if iCurEnergySpare >= 0 and oBrain:GetEconomyStoredRatio('ENERGY') < M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] then
                    iCurEnergySpare = -GetEnergyStorageMaximum(oBrain) * 0.1
                elseif iCurEnergySpare <= 0 and oBrain:GetEconomyStoredRatio('ENERGY') > M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] then
                    if oBrain:GetEconomyStored('ENERGY') >= M28Building.iEnergyStorageExpectedCapacity or oBrain:GetEconomyStoredRatio('ENERGY') >= 0.99 then
                        iCurEnergySpare = 0
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iCurEnergySpare after limiting based on ratios='..iCurEnergySpare..'; Expected value before limitation='..(oBrain:GetEconomyStored('ENERGY') - iAverageEnergyStored)) end
            end

            if iCurEnergySpare < 0 then
                --Limit Energy to receive to the amount that takes us to 95% storage:
                iCurEnergySpare = math.max(iCurEnergySpare, math.min(0, oBrain:GetEconomyStored('ENERGY') -  GetEnergyStorageMaximum(oBrain) * 0.95))
                if iCurEnergySpare < 0 then
                    table.insert(tDetailsOfBrainsNeedingEnergy, {[subrefoBrain] = oBrain, [subrefiRemainingResourceNeeded] = iCurEnergySpare})
                end
            elseif iCurEnergySpare > 0 then
                table.insert(tDetailsOfBrainsWithEnergy, {[subrefoBrain] = oBrain, [subrefiResourceToGive] = iCurEnergySpare})
            end

            iCurMassSpare = oBrain:GetEconomyStored('MASS') - iAverageMassStored
            --Adjust spare mass if we have significantly different % to average
            if math.abs(oBrain:GetEconomyStoredRatio('MASS') - M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]) >= 0.2 or (iCurMassSpare < 0 and oBrain:GetEconomyStoredRatio('MASS') >= 0.95) then
                if iCurMassSpare >= 0 and oBrain:GetEconomyStoredRatio('MASS') < M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] then
                    iCurMassSpare = -GetMassStorageMaximum(oBrain) * 0.05
                elseif iCurMassSpare <= 0 and oBrain:GetEconomyStoredRatio('MASS') > M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] then
                    if oBrain:GetEconomyStored('MASS') >= 700 or oBrain:GetEconomyStoredRatio('MASS') >= 0.9 then
                        iCurMassSpare = 0
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iCurMassSpare after limiting based on ratios='..iCurMassSpare..'; Expected value before limitation='..(oBrain:GetEconomyStored('MASS') - iAverageMassStored)) end
            end

            if iCurMassSpare < 0 then
                --Limit mass to receive to the amount that takes us to 95% storage:
                iCurMassSpare = math.max(iCurMassSpare, math.min(0, oBrain:GetEconomyStored('MASS') -  GetMassStorageMaximum(oBrain) * 0.95))
                if iCurMassSpare < 0 then
                    table.insert(tDetailsOfBrainsNeedingMass, {[subrefoBrain] = oBrain, [subrefiRemainingResourceNeeded] = iCurMassSpare})
                end
            elseif iCurMassSpare > 0 then
                table.insert(tDetailsOfBrainsWithMass, {[subrefoBrain] = oBrain, [subrefiResourceToGive] = iCurMassSpare})
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering brain '..oBrain.Nickname..': iCurEnergySpare='..iCurEnergySpare..'; iCurMassSpare='..iCurMassSpare..'; Actual mass stored='..oBrain:GetEconomyStored('MASS')..'; Actual energy stored='..oBrain:GetEconomyStored('ENERGY')..'; iAverageMassStored='..iAverageMassStored) end
        end

        --Allocate resources:
        local tBrainsNeedingResource, tBrainsWithResource
        local iResourceToGive
        for iResourceType = 1, 2, 1 do
            if iResourceType == refiResourceEnergy then
                tBrainsNeedingResource = tDetailsOfBrainsNeedingEnergy
                tBrainsWithResource = tDetailsOfBrainsWithEnergy
                if bDebugMessages == true then LOG(sFunctionRef..': Allcoating energy') end
            else
                tBrainsNeedingResource = tDetailsOfBrainsNeedingMass
                tBrainsWithResource = tDetailsOfBrainsWithMass
                if bDebugMessages == true then LOG(sFunctionRef..': Allcoating mass') end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of brains needing this resource empty='..tostring(M28Utilities.IsTableEmpty(tBrainsNeedingResource))..'; Is table of brains with this resource available empty='..tostring(M28Utilities.IsTableEmpty(tBrainsWithResource))) end
            if M28Utilities.IsTableEmpty(tBrainsNeedingResource) == false and M28Utilities.IsTableEmpty(tBrainsWithResource) == false then
                for iBrainWithResource, tBrainWithResourceSubtable in tBrainsWithResource do
                    if bDebugMessages == true then LOG(sFunctionRef..': Deciding which brain '..tBrainWithResourceSubtable[subrefoBrain].Nickname..' should give its resources to') end
                    for iBrainNeedingResource, tBrainNeedingResourceSubtable in tBrainsNeedingResource do
                        iResourceToGive = math.min(-tBrainNeedingResourceSubtable[subrefiRemainingResourceNeeded], tBrainWithResourceSubtable[subrefiResourceToGive])
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to give resources to brain '..tBrainNeedingResourceSubtable[subrefoBrain].Nickname..'; iResourceToGive='..iResourceToGive..'; tBrainNeedingResourceSubtable[subrefiRemainingResourceNeeded]='..tBrainNeedingResourceSubtable[subrefiRemainingResourceNeeded]..'; tBrainWithResourceSubtable[subrefiResourceToGive]='..tBrainWithResourceSubtable[subrefiResourceToGive]) end
                        if iResourceToGive > 0 then
                            if iResourceType == refiResourceEnergy then
                                GiveResourcesToPlayer(tBrainWithResourceSubtable[subrefoBrain], tBrainNeedingResourceSubtable[subrefoBrain], 0, iResourceToGive)
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': About to give '..iResourceToGive..' mass from player '..tBrainWithResourceSubtable[subrefoBrain].Nickname..' to player '..tBrainNeedingResourceSubtable[subrefoBrain].Nickname) end
                                GiveResourcesToPlayer(tBrainWithResourceSubtable[subrefoBrain], tBrainNeedingResourceSubtable[subrefoBrain], iResourceToGive, 0)
                            end
                            tBrainNeedingResourceSubtable[subrefiRemainingResourceNeeded] = tBrainNeedingResourceSubtable[subrefiRemainingResourceNeeded] + iResourceToGive
                            tBrainWithResourceSubtable[subrefiResourceToGive] = tBrainWithResourceSubtable[subrefiResourceToGive] - iResourceToGive
                            if tBrainWithResourceSubtable[subrefiResourceToGive] <= 0 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Remaining resource available for brain '..tBrainWithResourceSubtable[subrefoBrain].Nickname..' to give='..tBrainWithResourceSubtable[subrefiResourceToGive]..' so will break') end
                                break
                            end
                        end
                    end
                end
            end
        end
    else
        M28Utilities.ErrorHandler('No active M28 brains')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TeamResourceSharingMonitor(iTeam)
    --Monitors resources for AI in the team and shares resources
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TeamResourceSharingMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, checking if already running a monitor for iTeam='..iTeam..': Is table of friendl yM28 brains for this team empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))..'; M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]='..(M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or 'nil')) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 then
        local iDefaultTimeToStop = GetGameTimeSeconds() + 120
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(10)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        while GetGameTimeSeconds() < iDefaultTimeToStop do
            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] > 1 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2.5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiLowestFriendlyLandFactoryTech] > 0) then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to start sharing resources between teammates as have T2 or alot of mass') end
                break
            else
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitSeconds(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
        end

        while M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd) --moved here since getting very high readings for how long this is taking
            ForkThread(AllocateTeamEnergyAndMassResources, iTeam)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateTableOfUpgradingMexesForTeam(iTeam)
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) == false then
        local tUpgradingMexes = M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]
        local iEntries = table.getn(tUpgradingMexes)

        for iCurEntry = iEntries, 1, -1 do
            if not(M28UnitInfo.IsUnitValid(tUpgradingMexes[iCurEntry])) then
                table.remove(tUpgradingMexes, iCurEntry)
            end
        end
    end
end

function ManageMassOverflow(iTeam)
    --Stop any engineers that have a reclaim area order
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMassOverflow'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastOverflowEngiCheck] or -100) >= 1 then --Only do this every couple of seconds
            M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastOverflowEngiCheck] = GetGameTimeSeconds()
            local iEngiCycleCount = 0
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do

                local tEngineers = oBrain:GetListOfUnits(M28UnitInfo.refCategoryEngineer, false, true)
                if M28Utilities.IsTableEmpty(tEngineers) == false then
                    for iUnit, oUnit in tEngineers do
                        iEngiCycleCount = iEngiCycleCount + 1
                        if M28UnitInfo.IsUnitValid(oUnit) and (oUnit[M28Engineer.refiAssignedAction] == M28Engineer.refActionReclaimArea or oUnit[M28Engineer.refiAssignedAction] == M28Engineer.refActionReclaimFriendlyUnit) then
                            if bDebugMessages == true then LOG(sFunctionRef..': About to stop engineer '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from reclaiming as have lots of mass now') end
                            M28Orders.IssueTrackedClearCommands(oUnit)
                        end
                        if iEngiCycleCount >= 30 then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitTicks(1)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                            M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastOverflowEngiCheck] = GetGameTimeSeconds()
                            iEngiCycleCount = 0
                        end
                    end
                end
            end
        end
    else
        M28Utilities.ErrorHandler('No M28 brains active')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderFutureMexUpgrade(oMex, iOverrideSecondsToWait)
    --Called when we have just constructed a mex - considers upgrading the mex in the future if we have no active upgrades
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderFutureMexUpgrade'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iTimeToWait = iOverrideSecondsToWait
    local iMexTechLevel = M28UnitInfo.GetUnitTechLevel(oMex)
    if not(iTimeToWait) then
        if iMexTechLevel == 1 then
            iTimeToWait = 7 * 60
        elseif iMexTechLevel == 2 then
            if oMex:GetAIBrain()[refiGrossMassBaseIncome] < 10 then
                iTimeToWait = 8 * 60 + 4 * 60 * (10-oMex:GetAIBrain()[refiGrossMassBaseIncome]) / 10
            else
                iTimeToWait = 8 * 60
            end
        elseif bT3MexCanBeUpgraded and M28Utilities.bLoudModActive and iMexTechLevel == 3 then
            iTimeToWait = 0
        else --redundancy
            local tLZData = M28Map.GetLandOrWaterZoneData(oMex:GetPosition())
            local iMexesInZone = (tLZData[M28Map.subrefLZMexCount] or 0)
            if oMex:GetAIBrain()[refiGrossMassBaseIncome] < 25 then
                iTimeToWait = 4 * 60 + 5 * 60 * (25-oMex:GetAIBrain()[refiGrossMassBaseIncome]) / 10
            else
                iTimeToWait = 4 * 60
            end
            if iMexesInZone < 4 and oMex:GetAIBrain()[refiGrossMassBaseIncome] <= 40 then iTimeToWait = iTimeToWait + 2 * 60 * (4 - (tLZData[M28Map.subrefLZMexCount] or 0)) end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': About to wait before considering upgrading this mex again='..iTimeToWait..' for mex '..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)..' owned by '..oMex:GetAIBrain().Nickname..' at time='..GetGameTimeSeconds()..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oMex))) end
    if iTimeToWait > 0 then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(iTimeToWait)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Is oMex still valid='..tostring(M28UnitInfo.IsUnitValid(oMex))) end
    if M28UnitInfo.IsUnitValid(oMex) then
        local iTeam = oMex:GetAIBrain().M28Team
        if bDebugMessages == true then LOG(sFunctionRef..': Are we in t1 spam mode='..tostring(M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam] or false)) end
        if not(M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam]) then
            --Only do this if there are 3+ mexes in the zone, or it's a plateau

            if bDebugMessages == true then LOG(sFunctionRef..': Considering whether we want to upgrade mex '..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)..'; safe to upgrade='..tostring(M28Conditions.SafeToUpgradeUnit(oMex))..'; iMexTechLevel='..iMexTechLevel..'; Team has low mass='..tostring(M28Conditions.TeamHasLowMass(iTeam))..'; Time='..GetGameTimeSeconds()) end
            if M28Conditions.SafeToUpgradeUnit(oMex) and not(M28Team.tLandSubteamData[oMex:GetAIBrain().M28LandSubteam][M28Team.refbPrioritiseProduction]) and (not(M28Conditions.TeamHasLowMass(iTeam)) or iMexTechLevel == 3) then
                local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oMex:GetPosition())
                local tLZOrWZData, tLZOrWZTeamData
                if iPlateauOrZero == 0 then
                    tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                    tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                else
                    tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                    tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                end

                if not(M28Conditions.ZoneWantsT1Spam(tLZOrWZTeamData, iTeam)) then

                    --Are there enough mexes that we want to consider upgrading?
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Safe to upgrade, will proceed if enoguh mexes in this zone to support an upgrade, or dealing with a 2 mex plateau, tLZOrWZData[M28Map.subrefLZMexCount]='..tLZOrWZData[M28Map.subrefLZMexCount]..'; Plateau mex count='..M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauTotalMexCount]..'; tLZOrWZTeamData[M28Map.refiModDistancePercent]='..tLZOrWZTeamData[M28Map.refiModDistancePercent]..'; Team upgrading mex count='..table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes] or {})..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass])
                        if table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes] or {}) >= 5 then
                            for iUpgradingMex, oUpgradingMex in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes] do
                                if M28UnitInfo.IsUnitValid(oUpgradingMex) then
                                    LOG(sFunctionRef..': iUpgradingMex='..iUpgradingMex..'; oUpgradingMex='..oUpgradingMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUpgradingMex)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUpgradingMex))..'; Work progress='..oUpgradingMex:GetWorkProgress())
                                else
                                    LOG(sFunctionRef..': iUpgradingMex='..iUpgradingMex..'; oUpgradingMex='..oUpgradingMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUpgradingMex)..'; mex is no longer valid')
                                end
                            end
                        end
                    end
                    if iMexTechLevel == 3 or tLZOrWZData[M28Map.subrefLZMexCount] >= 3 or (iPlateauOrZero > 0 and tLZOrWZData[M28Map.subrefLZMexCount] >= math.max(2, M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauTotalMexCount] * 0.5)) or (iPlateauOrZero > 0 and tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.25 and (not(M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes])) or table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) < math.max(2, M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount], M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / (2 * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier] * M28UnitInfo.GetUnitTechLevel(oMex)))))  then
                        --Do we have any active mex upgrades?
                        if bDebugMessages == true then LOG(sFunctionRef..': active mex upgrades='..(tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] or 0)..'; Stalling mass='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass])..'; Stalling energy='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; Is team table of upgrading mexes empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]))..'; Gross mass for brain='..oMex:GetAIBrain()[refiGrossMassBaseIncome])
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) == false then
                                LOG(sFunctionRef..': Number of mexes upgrading on team='..table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]))
                            end
                        end

                        if (iMexTechLevel ==3 and M28Utilities.bLoudModActive) or (M28Conditions.TeamHasLowMass(iTeam) == 3 or (tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] or 0) == 0 and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and
                                (not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) or
                                        M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) or
                                        (tLZOrWZData[M28Map.subrefLZMexCount] >= 3 and table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) < M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and oMex:GetAIBrain()[refiGrossMassBaseIncome] >= 3.5 * iMexTechLevel and (iMexTechLevel == 1 or  table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) < M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] * 0.5)) or
                                        ((tLZOrWZData[M28Map.subrefLZMexCount] >= 4 or tLZOrWZData[M28Map.subrefLZbCoreBase]) and M28Conditions.GetHighestOtherTeamT3MexCount(iTeam) > M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][3])
                                )) then
                            --Do we have any mexes lower than this tech level? if so then dont upgrade

                            if iMexTechLevel > 1 and (tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] > 0 or (iMexTechLevel >= 3 and tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] > 0)) then
                                ForkThread(ConsiderFutureMexUpgrade, oMex, 120)
                            elseif iMexTechLevel < 3 or M28Utilities.bLoudModActive then
                                --We arent stalling (or need to upgrade even if stalling), we dont have any active mex upgrades in this zone, and this mex has been alive a while - proceed with upgrade
                                if bDebugMessages == true then LOG(sFunctionRef..': Will upgrade mex '..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)..' as it has been active a while') end
                                UpgradeUnit(oMex, true)
                            end
                        else
                            --Check in a bit as we already have a mex upgrading or we are stalling resources
                            ForkThread(ConsiderFutureMexUpgrade, oMex, 20)
                        end
                    else
                        --Dont want to consider so will just rely on default logic, unless our mod dist is such that we likely failed due to temporary upgrade/eco conditions
                        if tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.25 then
                            ForkThread(ConsiderFutureMexUpgrade, oMex, 30)
                        end
                    end
                else
                    ForkThread(ConsiderFutureMexUpgrade, oMex, 600)
                end

            else
                --Not safe to upgrade or want to focus on production for now, consider in a while
                ForkThread(ConsiderFutureMexUpgrade, oMex, 120)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderUpgradingMexDueToCompletion(oJustBuilt, oOptionalEngineer)
    --Idea - if we have just completed a mex upgrade in a zone, then look to immediately start upgrading another mex (since the one we just built should be able to help fund it)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderUpgradingMexDueToCompletion'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28UnitInfo.IsUnitValid(oJustBuilt) then --needed as might call this via a delay now
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code for oJustBuilt='..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; Owner='..oJustBuilt:GetAIBrain().Nickname..'; Time='..GetGameTimeSeconds()) end
        if not(EntityCategoryContains(categories.TECH1, oJustBuilt.UnitId)) then
            local aiBrain = oJustBuilt:GetAIBrain()
            local iTeam = aiBrain.M28Team
            if bDebugMessages == true then LOG(sFunctionRef..': Is team stalling energy='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; Prioritise production for land team='..tostring(M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.refbPrioritiseProduction] or false)..'; Team low on mass='..M28Conditions.TeamHasLowMass(iTeam)) end
            if not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) then
                if M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.refbPrioritiseProduction] and M28Conditions.TeamHasLowMass(iTeam) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will call this function again in a while as we want to prioritise production at the moment') end
                    ForkThread(M28Utilities.DelayedFunction, 60, ConsiderUpgradingMexDueToCompletion, {oJustBuilt})
                else
                    local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oJustBuilt:GetPosition(), true, iTeam)
                    local iMexTechLevel = M28UnitInfo.GetUnitTechLevel(oJustBuilt)
                    if bDebugMessages == true then LOG(sFunctionRef..': tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades]='..(tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] or 'nil')..'; tLZOrWZTeamData[M28Map.subrefMexCountByTech][2]='..tLZOrWZTeamData[M28Map.subrefMexCountByTech][2]..'; tLZOrWZData[M28Map.subrefLZMexCount]='..tLZOrWZData[M28Map.subrefLZMexCount]) end
                    if (tLZOrWZData[M28Map.subrefLZMexCount] > 1 or tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and ((M28Map.iMapSize >= 1024 and tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] < 2) or tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] < tLZOrWZData[M28Map.subrefLZMexCount] * 0.3 or (M28Utilities.bLoudModActive and EntityCategoryContains(M28UnitInfo.refCategoryT3Mex, oJustBuilt.UnitId)) and (tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] < math.max(1, tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] * 0.5 + tLZOrWZData[M28Map.subrefLZMexCount] * 0.15 + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3]) or (tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] <= 1 and M28Map.iMapSize >= 1024) or (M28Utilities.bLoudModActive and EntityCategoryContains(M28UnitInfo.refCategoryT3Mex, oJustBuilt.UnitId)))) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Checkign we dont have lower tech mexes or loud active, iMexTechLevel='..iMexTechLevel..'; M28Utilities.bLoudModActive='..tostring(M28Utilities.bLoudModActive)) end
                        if tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] > 0 or (iMexTechLevel == 3 and (M28Utilities.bLoudModActive or tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] > 0)) then --In LOUD, T3 mex upgrades are more efficient than t2 to t3 apparently
                            --Basic safety check (much more limited than normal one):
                            if bDebugMessages == true then LOG(sFunctionRef..': Doing safety check, is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]))..'; Enemy air to ground threat='..(tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0)) end
                            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) and (tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) == 0 and M28Utilities.IsTableEmpty(oJustBuilt[M28Building.reftTMLInRangeOfThisUnit]) and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) and (tLZOrWZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) == 0 then
                                --Upgrade another mex in this zone (or this mex if T3 LOUD)
                                if iMexTechLevel == 3 and M28Utilities.bLoudModActive and not((oJustBuilt:GetBlueprint().General.UpgradesTo or '') == '') then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Upgrading this unit again') end
                                    UpgradeUnit(oJustBuilt, true)
                                elseif M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then --redundancy
                                    local iMexCategory
                                    if iMexTechLevel == 1 then iMexCategory = M28UnitInfo.refCategoryT1Mex
                                    elseif iMexTechLevel == 2 then iMexCategory = M28UnitInfo.refCategoryT1Mex + M28UnitInfo.refCategoryT2Mex
                                    else iMexCategory = M28UnitInfo.refCategoryMex
                                    end
                                    local tMexOfCategory = EntityCategoryFilterDown(iMexCategory, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                    if bDebugMessages == true then LOG(sFunctionRef..': is M28Utilities.IsTableEmpty(tMexOfCategory)='..tostring(M28Utilities.IsTableEmpty(tMexOfCategory))) end
                                    if M28Utilities.IsTableEmpty(tMexOfCategory) == false then
                                        for iMex, oMex in tMexOfCategory do
                                            if M28UnitInfo.IsUnitValid(oMex) and oMex:GetFractionComplete() == 1 and not(oMex:IsUnitState('Upgrading')) and not(oMex == oJustBuilt) and not(oMex == oOptionalEngineer) and not((oMex:GetBlueprint().General.UpgradesTo or '') == '') then
                                                UpgradeUnit(oMex, true)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will upgrade the mex '..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)..' as have just compelted a mex upgrade in this zone') end
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Will call this function again in a while as we arent upgrading due to low power') end
                ForkThread(M28Utilities.DelayedFunction, 10, ConsiderUpgradingMexDueToCompletion, {oJustBuilt})
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderPowerPgenUpgrade(oUnit, iOverrideSecondsToWait)
    --Called when we have just constructed a t3 pgen that is capable of being upgraded - tries to upgrade immediately unless are stalling mass
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderPowerPgenUpgrade'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTimeToWait = iOverrideSecondsToWait or 0

    if bDebugMessages == true then LOG(sFunctionRef..': About to wait '..iTimeToWait..' for oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..' at time='..GetGameTimeSeconds()..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
    if iTimeToWait > 0 then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(iTimeToWait)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Is oUnit still valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
    if M28UnitInfo.IsUnitValid(oUnit) then
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
        local iTeam = oUnit:GetAIBrain().M28Team
        local tLZOrWZData, tLZOrWZTeamData
        if iPlateauOrZero == 0 then
            tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
            tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
        else
            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
            tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
        end

        if (M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] and (tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] < math.min(2, tLZOrWZData[M28Map.subrefLZMexCount]))) or (M28Team.tTeamData[iTeam][M28Team.refbPrioritiseProduction] and not(M28Conditions.HaveLowPower(iTeam)) and M28Conditions.HaveLowMass(iTeam)) or not(M28Conditions.SafeToUpgradeUnit(oUnit)) then
            if bDebugMessages == true then LOG(sFunctionRef..': Dont have enough mass or want to produce more so will delay consideration of pgen upgrade, tLZOrWZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZOrWZTeamData[M28Map.subrefMexCountByTech])..'; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] or false)..'; Prioritise production='..tostring(M28Team.tTeamData[iTeam][M28Team.refbPrioritiseProduction] or false)..'; Safe to upgrade unit='..tostring(M28Conditions.SafeToUpgradeUnit(oUnit))) end
            ForkThread(ConsiderPowerPgenUpgrade, oUnit, 10)
        else
            if not(M28Conditions.ZoneWantsT1Spam(tLZOrWZTeamData, iTeam)) then
                --Wnat to upgrade pgen
                if bDebugMessages == true then LOG(sFunctionRef..': Will upgrade unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                UpgradeUnit(oUnit, true)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Want t1 spam so will reconsider later') end
                ForkThread(ConsiderPowerPgenUpgrade, oUnit, 10)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderMassFabUpgrade(oUnit, iOverrideSecondsToWait)
    --Called when we have just constructed a t3 mass fab that is capable of being upgraded - tries to upgrade immediately unless are stalling energy
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderMassFabUpgrade'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTimeToWait = iOverrideSecondsToWait or 0

    if bDebugMessages == true then LOG(sFunctionRef..': About to consider wait '..iTimeToWait..' for oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..' at time='..GetGameTimeSeconds()..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
    if iTimeToWait > 0 then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(iTimeToWait)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Is oUnit still valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
    if M28UnitInfo.IsUnitValid(oUnit) then
        local iTeam = oUnit:GetAIBrain().M28Team
        if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] or (M28Team.tTeamData[iTeam][M28Team.refbPrioritiseProduction] and (M28Conditions.HaveLowPower(iTeam) or M28Conditions.HaveLowMass(iTeam))) or not(M28Conditions.SafeToUpgradeUnit(oUnit)) then
            if bDebugMessages == true then LOG(sFunctionRef..': Dont have enough energy or want to produce more so will delay consideration of mass fab upgrade, or we are dealing with unsafe to upgrade unit') end
            ForkThread(ConsiderMassFabUpgrade, oUnit, 10)
        else
            local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
            local tLZOrWZData, tLZOrWZTeamData
            if iPlateauOrZero == 0 then
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
            else
                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
            end

            if not(M28Conditions.ZoneWantsT1Spam(tLZOrWZTeamData, iTeam)) then
                --Wnat to upgrade pgen
                if bDebugMessages == true then LOG(sFunctionRef..': Will upgrade mass fab unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                UpgradeUnit(oUnit, true)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Want t1 spam so will reconsider later') end
                ForkThread(ConsiderMassFabUpgrade, oUnit, 10)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function JustBuiltT2PlusPowerOrExperimentalInZone(oPGen)
    --If we dont have an activem ex upgrade in the zone then will try and upgrade a mex, assuming it is safe
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'JustBuiltT2PlusPowerOrExperimentalInZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTeam = oPGen:GetAIBrain().M28Team
    local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oPGen:GetPosition(), true, iTeam)
    if tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] == 0 and (tLZOrWZData[M28Map.subrefLZMexCount] or 0) > 0 and tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] < tLZOrWZData[M28Map.subrefLZMexCount] then
        if  tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] > 0 or (tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] > 0 and EntityCategoryContains(categories.TECH3 + categories.EXPERIMENTAL, oPGen.UnitId)) then
            if not(tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] or tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) and (tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) == 0 then
                if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.2 then
                    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                        --Get a mex in the zone to upgrade
                        local oMexToUpgrade
                        local iCurDist
                        local iClosestDist = 10000
                        function ConsiderUnits(tUnitsToConsider)
                            if M28Utilities.IsTableEmpty(tUnitsToConsider) == false then
                                for iUnit, oUnit in tUnitsToConsider do
                                    if M28UnitInfo.IsUnitValid(oUnit) then
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZOrWZData[M28Map.subrefMidpoint])
                                        if iCurDist < iClosestDist then
                                            iClosestDist = iCurDist
                                            oMexToUpgrade = oUnit
                                        end
                                    end
                                end
                            end
                        end
                        ConsiderUnits(EntityCategoryFilterDown(M28UnitInfo.refCategoryT1Mex, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))
                        if not(oMexToUpgrade) then ConsiderUnits(EntityCategoryFilterDown(M28UnitInfo.refCategoryT2Mex, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) end
                        if oMexToUpgrade  then
                            if bDebugMessages == true then LOG(sFunctionRef..': Just completed oPgen='..oPGen.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPGen)..'; oMexToUpgrade='..oMexToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMexToUpgrade)) end
                            UpgradeUnit(oMexToUpgrade, true)
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetBestEngiToKill(oUnit)
    --If we are planning on killing oUnit, and it is T3, and we have T1 or T2 engis in the esame area, then consider switching to killing the T1/T2 unit instead
    --returns either oUnit, or the replacement engineer
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBestEngiToKill'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iUnitTechLevel = M28UnitInfo.GetUnitTechLevel(oUnit)
    if iUnitTechLevel == 1 then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return oUnit
    else
        --Dealing with T3 engineer, is there a T1/T2 in the same zone?
        local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, oUnit:GetAIBrain().M28Team)
        local iSearchCategory
        if iUnitTechLevel == 2 then iSearchCategory = M28UnitInfo.refCategoryEngineer * categories.TECH1
        else iSearchCategory = M28UnitInfo.refCategoryEngineer * categories.TECH1 + M28UnitInfo.refCategoryEngineer * categories.TECH2
        end
        local tT1AndT2EngisInZone = EntityCategoryFilterDown(iSearchCategory, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty( tT1AndT2EngisInZone) == false then
            --The higher the priority number the less important the task
            local iLowestPriorityEngineer = -1000
            local iPrimaryBuilderPriorityAdjust = -500
            local iNoPriorityReplacement = 400
            local iTech1PriorityAdjust = 50 --i.e. treats t1 engi as having +50 to priority value
            local oLowestPriorityEngineer
            local iCurPriority
            local iOrigFaction = M28UnitInfo.GetUnitFaction(oUnit)
            local iCurFaction

            for iEngi, oEngi in tT1AndT2EngisInZone do
                if M28UnitInfo.IsUnitValid(oEngi) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering possible replacement engi, oEngi='..oEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngi)..'; Engi state='..M28UnitInfo.GetUnitState(oEngi)..'; Assigned priority='..(oEngi[M28Engineer.refiAssignedActionPriority] or 'nil')..'; Is primary builder='..tostring(oEngi[M28Engineer.refbPrimaryBuilder] or false)) end
                    if not(oEngi:IsUnitState('Reclaiming')) then
                        iCurPriority = (oEngi[M28Engineer.refiAssignedActionPriority] or iNoPriorityReplacement)
                        if oEngi[M28Engineer.refbPrimaryBuilder] then
                            iCurPriority = iCurPriority + iPrimaryBuilderPriorityAdjust
                        end
                        if iUnitTechLevel == 3 and M28UnitInfo.GetUnitTechLevel(oEngi) == 1 then iCurPriority = iCurPriority + iTech1PriorityAdjust end
                        if iCurPriority > iLowestPriorityEngineer then
                            --If it is for a different faction then check we have a factory of the new faction in this zone or higher tech engi before we kill the engi
                            iCurFaction = M28UnitInfo.GetUnitFaction(oEngi)
                            if iCurFaction == iOrigFaction or (iCurFaction and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory * M28UnitInfo.ConvertFactionToCategory(iCurFaction) + M28UnitInfo.refCategoryEngineer * categories.TECH3 * M28UnitInfo.ConvertFactionToCategory(iCurFaction), tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false) then
                                iLowestPriorityEngineer = iCurPriority
                                oLowestPriorityEngineer = oEngi
                            end
                        end
                    end
                end
            end
            if oLowestPriorityEngineer then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return oLowestPriorityEngineer
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oUnit
end

function ConsiderImmediateUpgradeOfFactory(oFactory)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderImmediateUpgradeOfFactory'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(M28Utilities.bFAFActive) then
        local iTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
        local aiBrain = oFactory:GetAIBrain()
        if iTechLevel < math.min(3, aiBrain[refiOurHighestFactoryTechLevel]) then

            if EntityCategoryContains(M28UnitInfo.refCategoryAirHQ, oFactory.UnitId) then
                if aiBrain[refiOurHighestAirFactoryTech] > math.min(3, iTechLevel) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will upgrade air factory immediately, oFactory='..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)) end
                    UpgradeUnit(oFactory, true)
                end
            elseif EntityCategoryContains(M28UnitInfo.refCategoryLandHQ, oFactory.UnitId) then
                iCategoryWanted = M28UnitInfo.refCategoryLandHQ
                if iTechLevel == 1 then
                    iCategoryWanted = iCategoryWanted * categories.TECH3 + iCategoryWanted * categories.TECH2
                else iCategoryWanted = iCategoryWanted * categories.TECH3
                end

                if iCategoryWanted then
                    local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oFactory:GetPosition(), true, aiBrain.M28Team)
                    if M28Conditions.GetNumberOfConstructedUnitsMeetingCategoryInZone(tLZOrWZTeamData, iCategoryWanted) > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will upgrade land factory immediately, oFactory='..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)) end
                        UpgradeUnit(oFactory, true)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UnpausePausedMexFollowingUpgrade(oJustBuilt, bBuiltMexCanUpgrade)
    local iTeam = oJustBuilt:GetAIBrain().M28Team
    if not(EntityCategoryContains(categories.TECH1, oJustBuilt.UnitId)) and (M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] or M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) then
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) == false then
            local iMexToUnpause = 1
            if not(bBuiltMexCanUpgrade) and M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] then iMexToUnpause = 2 end
            local iClosestToCompletion, oMexToUnpause, iCurProgress
            while iMexToUnpause > 0 do
                iClosestToCompletion = -1
                iMexToUnpause = iMexToUnpause - 1
                for iMex, oMex in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes] do
                    iCurProgress = oMex:GetWorkProgress()
                    if iCurProgress > iClosestToCompletion and oMex[M28UnitInfo.refbPaused] then
                        iClosestToCompletion = iCurProgress
                        oMexToUnpause = oMex
                    end
                end
                if oMexToUnpause then
                    M28UnitInfo.PauseOrUnpauseMassUsage(oMexToUnpause, false, iTeam)
                else
                    break
                end
            end

        end
    end
end