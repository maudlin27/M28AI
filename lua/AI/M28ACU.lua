---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 08:29
---
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')
local NavUtils = M28Utilities.NavUtils --import("/lua/sim/navutils.lua")
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Chat = import('/mods/M28AI/lua/AI/M28Chat.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')

--ACU specific variables against the ACU
refbTreatingAsACU = 'M28ACUTreatACU' --true if are running ACU logic on this unit - e.g. for campagins where are given SACU but not an ACU
refbDoingInitialBuildOrder = 'M28ACUInitialBO'
reftPreferredUpgrades = 'M28ACUPreferredUpgrades' --table of the enhancement IDs in the order that we want to get them (which is updated to remove any upgrades we already have as and when we get them)
refiUpgradeCount = 'M28ACUUpgradeCount' --Number of upgrades the ACU has
refbTriedAndFailedToGetBuildRateUpgrade = 'M28ACUFailBRU' --for SACUs - true if we tried to improve their build rate and failed
refiBuildTech = 'M28ACUTcL' --Tech levle the ACU can build (i.e. 2 if it has t2 upgrade, 3 if it has t3 upgrade)
refiTimeLastWantedToRun = 'M28ACUTimeLastWantedToRun' --gametimeseconds that last wanted to run
reftLastRallyPointRanTo = 'M28ACULsRPn' --last rally point Acu ran to
refbACUAvailableToDoSnipeAttack = 'M28ACUAvailableForSnipe' --true if ACU not busy doing higher priority actions
reftiLastAssignedPlateauAndZone = 'M28ACULastPlateauAndLZ' --Records the last plateau and LZ/WZ that we were assigned to; if in WZ then plateau is 0
reftiCurAssignedPlateauAndZone = 'M28ACUCurPlateauAndLZ' --Records the current plateau and LZ/WZ that we are assigned to, if we are in a valid LZ/WZ; if WZ then plateau is 0
refbStartedUnderwater = 'M28ACUStartUnderwater' --true if ACU started underwater
refiTimeLastToldToMoveToZone = 'M28ACUTimeLastMoveZone' --gametime last told to move to a zone
refiLastPlateauAndZoneToMoveTo = 'M28ACULastZoneToMove' --PlateauOrZero and Land/Water zone ref if given move to zone order
refiTimeLastToldToAttackUnitInOtherZone = 'M28ACUTimeLastAttackUnit'
refiLastPlateauAndZoneToAttackUnitIn = 'M28ACULastZoneToAttack' --PlateauOrZero and Land/Water zone ref if given move to zone order in order to attack a unit
reftiTimeLastRanFromZoneByPlateau = 'M28ACUTimeLastRanByZone' --[x] is plateau or zero, [y] is the zone (currently only have logic for LZs though), returns gametimeseconds that last ran when in that zone
refbUseACUAggressively = 'M28ACUUseAggress' --Against ACU
refbSupportFriendlyACUAttack = 'M28ACUSupAtc' --e.g. if we have an ACU trying to push into enemy ACU to cancel an upgrade, then this will be true (and effectively means we search for enemy ACU with a larger search range for the same check)
reftSpecialObjectiveMoveLocation = 'M28ACUObjMoveLoc' --If has a value, ACU will move here
refbACUHasTeleport = 'M28ACUHasTel' --true if ACU has teleport (will assume it also has good gun upgrade) - used to impact on telesnipe logic
refbPlanningToGetTeleport = 'M28ACUPlanningTeleport' --true if are planning on getting teleport upgrade on the ACU
refbPlanningToGetShield = 'M28ACUPlanningShield' --nil if haven't considered whether to get shield or not yet; true if planning on getting shield/equivalent upgrade on the ACU
refiTimeLastConsideredUpgradePath = 'M28ACUTimUpP' --Gametimeseconds we last considered the upgrade path
refoShieldRallyTarget = 'M28ACUShR' --Shield unit that ACU is trying to shelter under
refbWantsPriorityUpgrade = 'M28ACUPrU' --true if want to get upgrade asap (e.g. enemy ACU getting upgrade and we want our own upgrade to defend against it)
refbOnlyOverchargeHighValueTargets = 'M28ACUOCHV' --true if we only want to overcharge high value targets - e.g. intended for if we are trying to chase down an enemy ACU
iACUAssassinationUpgradingRangeAdjust = 25 --increase to apply to assassination search range if target is upgrading (use global variable since want to be consistent where use in several places)

--ACU related variables against the ACU's brain
refoPrimaryACU = 'M28PrimACU' --ACU unit for the brain; recorded against aibrain
refbACUHasBeenGivenABuildOrderRecently = 'M28ACUBuildR' --true if ACU has been given a build order recently
refbACUSnipeModeActive = 'M28ACUSnipA' --true if are trying to kill enemy ACU (via all-in ACU push)

function ACUBuildUnit(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearchForAdjacencyAndUnderConstruction, iMaxAreaToSearchForBuildLocation, iOptionalAdjacencyCategory, iOptionalCategoryBuiltUnitCanBuild, tOptionalSearchLocation)
    local sFunctionRef = 'ACUBuildUnit'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Do we have a nearby unit of the type we want to build under construction?
    local tNearbyUnitsOfCategoryToBuild = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, oACU:GetPosition(), iMaxAreaToSearchForAdjacencyAndUnderConstruction, 'Ally')
    local oNearestPartComplete

    if M28Utilities.IsTableEmpty(tNearbyUnitsOfCategoryToBuild) == false then
        local iClosestUnit = 10000
        local iCurDist
        for _, oUnit in tNearbyUnitsOfCategoryToBuild do
            if oUnit:GetFractionComplete() < 1 and not(oUnit[M28Engineer.refbDontIncludeAsPartCompleteBuildingForConstruction]) then --Dont want to assist shields for shield defence
                iCurDist = M28Utilities.GetTravelDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition(), M28Map.refPathingTypeAmphibious)
                if iCurDist < iClosestUnit then
                    oNearestPartComplete = oUnit
                    iClosestUnit = iCurDist
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; brain='..aiBrain.Nickname..'; ACU='..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..'; Is tNearbyUnitsOfCategoryToBuild empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnitsOfCategoryToBuild))..'; Is oNearestPartComplete valid='..tostring(M28UnitInfo.IsUnitValid(oNearestPartComplete))..'; ACU position='..repru(oACU:GetPosition())) end
    if M28UnitInfo.IsUnitValid(oNearestPartComplete) then
        if bDebugMessages == true then LOG(sFunctionRef..': Will assist part complete building='..oNearestPartComplete.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestPartComplete)) end
        local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
        --if not(tLastOrder[M28Orders.subrefoOrderUnitTarget] == oNearestPartComplete) then --Dont need this step, as the order already takes this into account, and reissues once we get within build range
        M28Orders.IssueTrackedRepair(oACU, oNearestPartComplete, false, 'ACUComplB', false)
        --M28Orders.IssueTrackedGuard(oACU, oNearestPartComplete, false)
        --end

    else
        --No nearby under construction factory, so build one unless we allready have a queued orer to build one
        oACU[refbACUHasBeenGivenABuildOrderRecently] = true
        local bAlreadyHaveOrder = false
        M28Orders.UpdateRecordedOrders(oACU)
        local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
        --NOTE: Dont do location check, as we will exclude queued locations; i.e. first time this runs ACU queues land fac; second time it runs if it looks for a location to build it treats the first location as unavailable (due to the queued order) so tries somewhere else
        if tLastOrder[M28Orders.subrefsOrderBlueprint] and EntityCategoryContains(iCategoryToBuild, tLastOrder[M28Orders.subrefsOrderBlueprint]) then
            bAlreadyHaveOrder = true
        end
        if bDebugMessages == true then LOG(sFunctionRef..': tLastOrder='..reprs(tLastOrder)..'; bAlreadyHaveOrder='..tostring(bAlreadyHaveOrder)) end
        if not(bAlreadyHaveOrder) then
            local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oACU:GetPosition(), true, oACU:GetAIBrain().M28Team)
            --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerActionForDebug, iCategoryToBuild, iMaxAreaToSearch,                                   iCatToBuildBy,              tAlternativePositionToLookFrom, bLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData)
            local sBlueprint, tBuildLocation =                       M28Engineer.GetBlueprintAndLocationToBuild(aiBrain, oACU,        nil,                            iCategoryToBuild, iMaxAreaToSearchForAdjacencyAndUnderConstruction, iOptionalAdjacencyCategory, tOptionalSearchLocation,            false,                      nil,         iOptionalCategoryBuiltUnitCanBuild,    nil,                        tLZData, tLZTeamData)
            if not(tBuildLocation) then sBlueprint, tBuildLocation = M28Engineer.GetBlueprintAndLocationToBuild(aiBrain, oACU,          nil,                        iCategoryToBuild,    iMaxAreaToSearchForBuildLocation,                  nil,                         tOptionalSearchLocation,        false,                      nil,         iOptionalCategoryBuiltUnitCanBuild, nil,                           tLZData, tLZTeamData) end
            if bDebugMessages == true then
                local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oACU:GetPosition())
                LOG(sFunctionRef..': Blueprint to build='..(sBlueprint or 'nil')..'; tBuildLocation='..repru(tBuildLocation)..'; ACU plateau and land zone based on cur position='..iPlateauOrZero..'; Land or water zone='..(iLandOrWaterZone or 'nil')..'; iMaxAreaToSearchForBuildLocation='..(iMaxAreaToSearchForBuildLocation or 'nil')..'; was iOptionalAdjacencyCategory nil='..tostring(iOptionalAdjacencyCategory == nil)..'; tLZData midpoint='..repru(tLZData[M28Map.subrefMidpoint])..'; Is team data empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData))..'; iMaxAreaToSearchForAdjacencyAndUnderConstruction='..(iMaxAreaToSearchForAdjacencyAndUnderConstruction or 'nil'))
                if sBlueprint and tBuildLocation then
                    LOG(sFunctionRef..': Can build structure at target='..tostring(aiBrain:CanBuildStructureAt(sBlueprint, tBuildLocation)))
                end
            end
            if sBlueprint and tBuildLocation then
                --If our last order was to build this unit (ignoring location)
                --Move to the target and then build on it
                local tMoveTarget = M28Engineer.GetLocationToMoveForConstruction(oACU, tBuildLocation, sBlueprint)
                if tMoveTarget then
                    --IssueTrackedMoveAndBuild(oUnit, tBuildLocation, sOrderBlueprint, tMoveTarget, iDistanceToReorderMoveTarget, bAddToExistingQueue)
                    M28Orders.IssueTrackedMoveAndBuild(oACU, tBuildLocation, sBlueprint, tMoveTarget, 2, false)
                else
                    M28Orders.IssueTrackedBuild(oACU, tBuildLocation, sBlueprint, false)
                end
            else
                --M28Orders.UpdateRecordedOrders(oACU) --now are doing this earlier on
            end
        else
            --Consider reissuing the same order if we are close
            if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to reissue order to build, last order position='..repru(tLastOrder[M28Orders.subreftOrderPosition])..'; Dist to ACU position='..M28Utilities.GetDistanceBetweenPositions(tLastOrder[M28Orders.subreftOrderPosition], oACU:GetPosition())..'; BUilding radius+ACU build distance - 0.1='..(oACU:GetBlueprint().Economy.MaxBuildDistance + M28UnitInfo.GetBuildingSize(tLastOrder[M28Orders.subrefsOrderBlueprint]) * 0.5 - 0.1)) end
            if M28Utilities.IsTableEmpty(tLastOrder[M28Orders.subreftOrderPosition]) == false and M28Utilities.GetDistanceBetweenPositions(tLastOrder[M28Orders.subreftOrderPosition], oACU:GetPosition()) <= oACU:GetBlueprint().Economy.MaxBuildDistance + M28UnitInfo.GetBuildingSize(tLastOrder[M28Orders.subrefsOrderBlueprint]) * 0.5 - 0.1 then
                if bDebugMessages == true then LOG(sFunctionRef..': Will attempt to reissue build order') end
                M28Orders.IssueTrackedClearCommands(oACU)
                M28Orders.IssueTrackedBuild(oACU, tLastOrder[M28Orders.subreftOrderPosition], tLastOrder[M28Orders.subrefsOrderBlueprint], false)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLandOrWaterZone, tLZData, tLZTeamData, iFactoryCategoryOverride, iEngineerActionOverride)
    local sFunctionRef = 'ACUActionBuildFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iMaxAreaToSearch = 35
    local iCategoryToBuild
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for aiBrain '..aiBrain.Nickname..' at time '..GetGameTimeSeconds()) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) and GetGameTimeSeconds() >= 60 and iPlateauOrZero > 0 and tLZTeamData[M28Map.subrefLZbCoreBase] then M28Utilities.ErrorHandler('Empty allied units table, iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Is LZTeamData empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData))) end
    if iFactoryCategoryOverride then iCategoryToBuild = iFactoryCategoryOverride
    else
        local iTeam = oACU:GetAIBrain().M28Team
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if we want to build an air factory, do we want air instead of land='..tostring(M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData, aiBrain))..'; Is tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits] empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))..'; tLZTeamData[CoreBase]='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])) end
        if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData, aiBrain) then iCategoryToBuild = M28UnitInfo.refCategoryAirFactory
        else iCategoryToBuild = M28UnitInfo.refCategoryLandFactory
        end
    end
    --= (iFactoryCategoryOverride or M28UnitInfo.refCategoryLandFactory)
    if iCategoryToBuild == M28UnitInfo.refCategoryLandFactory then
        local iCurLandFacs = aiBrain:GetCurrentUnits(iCategoryToBuild)
        if iCurLandFacs >= 2 then
            iMaxAreaToSearch = 20
        elseif iCurLandFacs == 0 then
            iMaxAreaToSearch = oACU:GetBlueprint().Economy.MaxBuildDistance + M28UnitInfo.GetBuildingSize('ueb0101') * 0.5 + 1 --are ok with moving a very small distance to start building if it means we get adjacency
        end
    end
    local iSearchSegments = 20
    if iPlateauOrZero == 0 then
        iSearchSegments = 50
        if M28Map.bIsCampaignMap then
            iSearchSegments = iSearchSegments * 5
            if iEngineerActionOverride == M28Engineer.refActionBuildNavalFactory and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalFactory) == 0 then
                iSearchSegments = iSearchSegments * 2
            end
        end --Issue on Aeon mission 1 where ACU doesnt build because it hasnt searched through enough of the segments
    end
    --Start of game - first factory - massively increase search segments
    if M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryFactory) == 0 then
        local iSegmentRef
        if iPlateauOrZero == 0 then
            iSegmentRef = M28Map.subrefWZSegments
        else
            iSegmentRef = M28Map.subrefLZSegments
        end
        local iTotalSegments = table.getn(tLZData[iSegmentRef])
        if (GetGameTimeSeconds() <= 10 or (tLZData[M28Map.subrefiCumulativeSegmentsConsideredForBuilding] or 0) < iTotalSegments * 0.75) then

            local iSegmentStart = (tLZData[M28Map.subrefiLastSegmentEntryConsideredForBuilding] or 0)
            if iSegmentStart < iTotalSegments * 0.75 then
                iSearchSegments = math.max(iSearchSegments, iTotalSegments * 0.75 - iSegmentStart)
            end
        end
    end
    iSearchSegments = math.floor(iSearchSegments)
    if M28Overseer.refiRoughTotalUnitsInGame <= 500 then iSearchSegments = iSearchSegments * 2 end

    if bDebugMessages == true then LOG(sFunctionRef..': Will try and search for '..iSearchSegments..' in iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..' so ACU is picking from best location for factory') end
    M28Engineer.SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iSearchSegments)
    ACUBuildUnit(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearch, iMaxAreaToSearch * 2, M28Engineer.tiActionAdjacentCategory[(iEngineerActionOverride or M28Engineer.refActionBuildLandFactory)], M28UnitInfo.refCategoryEngineer)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData, oOptionalUnderConstructionHydro)
    --If have hydro under construction then assist the hydro if it's within build range; if not under construciton or out of build range then move towards it
    local sFunctionRef = 'ACUActionAssistHydro'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Redundancy - make sure we have hydros in this LZ:
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oACU:GetPosition(), true, oACU)
    if bDebugMessages == true then LOG(sFunctionRef..': Do we have hydro loations in iPlateau '..iPlateau..'; iLZ='..iLandZone..': Table empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]))) end
    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]) == false or oOptionalUnderConstructionHydro then
        local tNearestHydro
        local iNearestHydro = 10000
        local iCurDist
        local iBuildRange = oACU:GetBlueprint().Economy.MaxBuildDistance
        local iMinRangeToAssist = iBuildRange + 10
        local oNearestUnderConstructionHydro
        local iCompletedHydroCount = 0
        if not(oOptionalUnderConstructionHydro) or oOptionalUnderConstructionHydro:GetFractionComplete() == 1 then
            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroUnbuiltLocations]) == false then
                for iHydro, tHydro in tLZOrWZData[M28Map.subrefHydroLocations] do
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tHydro, oACU:GetPosition())
                    if iCurDist < iNearestHydro then iNearestHydro = iCurDist tNearestHydro = tHydro end
                end
            end
            local tNearbyHydro = EntityCategoryFilterDown(M28UnitInfo.refCategoryHydro, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby hydro empty based on subreftoLZOrWZAlliedUnits='..tostring(M28Utilities.IsTableEmpty(tNearbyHydro))) end
            if M28Utilities.IsTableEmpty(tNearbyHydro) == false then
                for iHydro, oHydro in tNearbyHydro do
                    if bDebugMessages == true then LOG(sFunctionRef..': considering oHydro='..(oHydro.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oHydro) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oHydro))) end
                    if M28UnitInfo.IsUnitValid(oHydro) then
                        if oHydro:GetFractionComplete() < 1 then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oHydro:GetPosition(), oACU:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurDist='..iCurDist..'; iNearestHydro='..iNearestHydro) end
                            --2 competing scenarios to avoid, 1 - helping a teammate's hydro that starts construction just before our hydro; 2 - having 2 hydros in our base and not helping the first one because the second is slightly closer (e.g. xander adaptive)
                            if iCurDist <= iNearestHydro or (not(oNearestUnderConstructionHydro) and (oHydro:GetAIBrain() == oACU:GetAIBrain() or iCurDist - 10 <= iNearestHydro)) then
                                iNearestHydro = iCurDist
                                tNearestHydro = oHydro:GetPosition()
                                oNearestUnderConstructionHydro = oHydro
                                if bDebugMessages == true then LOG(sFunctionRef..': Recording as the nearest hydro so far') end
                            end
                        else
                            iCompletedHydroCount = iCompletedHydroCount + 1
                        end
                    end
                end
            end
        else
            tNearestHydro = oOptionalUnderConstructionHydro:GetPosition()
            iNearestHydro = M28Utilities.GetDistanceBetweenPositions(oOptionalUnderConstructionHydro:GetPosition(), oACU:GetPosition())

        end
        --If we are in range of a hydro then assist it (or wait until construction is started)
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if have hydro near enough to consider mvoing to and assisting, iNearestHydro='..iNearestHydro..'; iMinRangeToAssist='..iMinRangeToAssist) end
        if iNearestHydro < iMinRangeToAssist then

            local oUnderConstructionHydro = oOptionalUnderConstructionHydro or oNearestUnderConstructionHydro
            if not(oUnderConstructionHydro) then
                local tUnderConstructionHydro = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryHydro, tNearestHydro, 5, 'Ally')
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of hydros around nearest hydro point empty='..tostring(M28Utilities.IsTableEmpty(tUnderConstructionHydro))) end
                if M28Utilities.IsTableEmpty(tUnderConstructionHydro) == false then
                    for iHydro, oHydro in tUnderConstructionHydro do
                        if oHydro:GetFractionComplete() < 1 then
                            oUnderConstructionHydro = oHydro
                            break
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': oUnderConstructionHydro='..(oUnderConstructionHydro.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnderConstructionHydro) or 'nil')) end
            if oUnderConstructionHydro and oUnderConstructionHydro:GetFractionComplete() < 1 then
                M28Orders.IssueTrackedRepair(oACU, oUnderConstructionHydro, false, 'RH')
            elseif not(oUnderConstructionHydro) then
                oACU['M28BOHydroWait'] = ( oACU['M28BOHydroWait'] or 0) + 1
                if  oACU['M28BOHydroWait'] >= 20 then
                    ACUActionBuildPower(aiBrain, oACU)
                else
                    --Stay where we are as maybe we are waiting for an engi to start construction
                    M28Orders.IssueTrackedMove(oACU, oACU:GetPosition(), 3, false, 'W4C')
                end
            end
        elseif tNearestHydro and (iCompletedHydroCount == 0 or table.getn(tLZOrWZData[M28Map.subrefHydroLocations]) > iCompletedHydroCount) then
            --Move to be near hydro
            local tLocationNearHydro = M28Engineer.GetLocationToMoveForConstruction(oACU, tNearestHydro, 'ueb1102', -0.5, false)
            if tLocationNearHydro then
                M28Orders.IssueTrackedMove(oACU, tLocationNearHydro, 0.5, false, 'M2NH')
            else
                M28Orders.IssueTrackedMove(oACU, tNearestHydro, 0.5, false, 'M2H')
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': No nearby hydro for ACU - e.g. might hapepn if called this as a redundancy action') end
        end
    else
        M28Utilities.ErrorHandler('Trying to buidl hydro when none nearby')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ACUActionBuildPower(aiBrain, oACU)
    local sFunctionRef = 'ACUActionBuildPower'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCategoryToBuild = M28UnitInfo.refCategoryPower
    local iMaxAreaToSearch = 16
    local iOptionalAdjacencyCategory
    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) > 0 then iOptionalAdjacencyCategory = M28UnitInfo.refCategoryAirFactory
    elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= 11 then iOptionalAdjacencyCategory = M28UnitInfo.refCategoryLandFactory
    end
    if bDebugMessages == true then LOG(sFunctionRef..': About to tell ACU to build power; is optional adjacency category nil='..tostring(iOptionalAdjacencyCategory == nil)) end
    ACUBuildUnit(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearch, iMaxAreaToSearch * 3, iOptionalAdjacencyCategory, nil)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ACUActionBuildMex(aiBrain, oACU, iAreaToSearchOverride)
    local sFunctionRef = 'ACUActionBuildMex'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iMaxAreaToSearch = iAreaToSearchOverride
    --Increase search range if still doing initial build order, as this suggests we have mexes in our initial land zone that we havent built on yet
    if not(iMaxAreaToSearch) then
        if oACU[refbDoingInitialBuildOrder] then
            if aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 12 then iMaxAreaToSearch = 50
            elseif aiBrain[M28Economy.refiGrossMassBaseIncome] < 6 then iMaxAreaToSearch = 30
            end
        else
            iMaxAreaToSearch = 20
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': About to tell ACU to build a mex, iMaxAreaToSearch='..iMaxAreaToSearch..'; iAreaToSearchOverride='..(iAreaToSearchOverride or 'nil')) end
    local iMexCategoryWanted
    if aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.99 and aiBrain:GetEconomyStored('MASS') >= 4000 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 300 then iMexCategoryWanted = M28UnitInfo.refCategoryMex
    else iMexCategoryWanted = M28UnitInfo.refCategoryMex * categories.TECH1
    end
    ACUBuildUnit(aiBrain, oACU, iMexCategoryWanted, iMaxAreaToSearch, iMaxAreaToSearch * 2, nil, nil)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MoveACUToNearbyWaterForFactory(aiBrain, oACU, tLZOrWZData)
    local sFunctionRef = 'MoveACUToNearbyWaterForFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTeam = aiBrain.M28Team

    --Get the first WZ that has a naval fac build location
    local iClosestWZRefWithBuild
    local iClosestWZRefWithoutBuild
    local iClosestWZWithBuildLocation = 100000
    local iClosestWZWithoutBuildLocation = 100000
    for iEntry, tSubtable in tLZOrWZData[M28Map.subrefAdjacentWaterZones] do
        local iAdjWZ = tSubtable[M28Map.subrefAWZRef]
        local tAdjWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ]
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to move to adjacent water zone '..iAdjWZ..'; Midpoint='..repru(tAdjWZData[M28Map.subrefMidpoint])..'; Straight line dist to ACU='..M28Utilities.GetDistanceBetweenPositions(tAdjWZData[M28Map.subrefMidpoint], oACU:GetPosition())..'; AWZ dist='..tSubtable[M28Map.subrefAWZDistance]..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAdjWZData[M28Map.subrefMidpoint]))) end
        if M28Conditions.IsLocationInPlayableArea(tAdjWZData[M28Map.subrefMidpoint]) then
            local tAdjWZTeamData = tAdjWZData[M28Map.subrefWZTeamData][iTeam]
            if bDebugMessages == true then LOG(sFunctionRef..': Does WZ contain naval build location='..tostring(tAdjWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation])) end
            if tAdjWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation] then
                if tSubtable[M28Map.subrefAWZDistance] < iClosestWZWithBuildLocation then
                    iClosestWZWithBuildLocation = tSubtable[M28Map.subrefAWZDistance]
                    iClosestWZRefWithBuild = iAdjWZ
                end
            else
                if tSubtable[M28Map.subrefAWZDistance] < iClosestWZWithoutBuildLocation then
                    iClosestWZWithoutBuildLocation = tSubtable[M28Map.subrefAWZDistance]
                    iClosestWZRefWithoutBuild = iAdjWZ
                end
            end
        end
    end
    local iOtherWZWanted = (iClosestWZRefWithBuild or iClosestWZRefWithoutBuild)
    if not(iOtherWZWanted) and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
        --Search all water zones
        for iEntry, tSubtable in tLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
            if tSubtable[M28Map.subrefbIsWaterZone] then
                local iAdjPond = tSubtable[M28Map.subrefiPlateauOrPond]
                local iOtherWZ = tSubtable[M28Map.subrefiLandOrWaterZoneRef]
                local tOtherWZData = M28Map.tPondDetails[iAdjPond][M28Map.subrefPondWaterZones][iOtherWZ]
                if bDebugMessages == true then LOG(sFunctionRef..': considering iOtherWZ='..iOtherWZ..'; Midpoint='..repru(tOtherWZData[M28Map.subrefMidpoint])..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tOtherWZData[M28Map.subrefMidpoint]))) end
                if M28Conditions.IsLocationInPlayableArea(tOtherWZData[M28Map.subrefMidpoint]) then
                    iOtherWZWanted = iOtherWZ
                    break
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for adjacent water zone to move to, iOtherWZWanted='..(iOtherWZWanted or 'nil')..'; ACU pos='..repru(oACU:GetPosition())) end
    if iOtherWZWanted then
        local tAdjWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iOtherWZWanted]][M28Map.subrefPondWaterZones][iOtherWZWanted]
        M28Orders.IssueTrackedMove(oACU, tAdjWZData[M28Map.subrefMidpoint], 2, false, 'MoveToWZ'..iOtherWZWanted, false)
    else
        local tPotentialDestination = M28Map.GetNearestWaterToBuildNavalFactoryInPlayableArea(aiBrain, oACU:GetPosition(), 8, nil, nil, true)
        if bDebugMessages == true then LOG(sFunctionRef..': Potential water destination to move to='..repru(tPotentialDestination)) end
        if tPotentialDestination then
            M28Orders.IssueTrackedMove(oACU, tPotentialDestination, 2, false, 'MoveToNBL', false)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetLowMexMapEarlyACUOrder(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData)
    local sFunctionRef = 'GetLowMexMapEarlyACUOrder'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, aiBrain[M28Economy.refiGrossEnergyBaseIncome]='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; aiBrain[M28Economy.refiGrossMassBaseIncome]='..aiBrain[M28Economy.refiGrossMassBaseIncome]) end

    --more specific initial build order
    local iMexInLandZone = 0
    local iResourceMod = aiBrain[M28Economy.refiBrainResourceMultiplier]
    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZOrWZMexLocations]) == false then iMexInLandZone = table.getn(tLZOrWZData[M28Map.subrefLZOrWZMexLocations]) end
    if iMexInLandZone > 0 and aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(4, iMexInLandZone) * 0.2 * iResourceMod and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false and (not(M28Overseer.bNoRushActive) or not(M28Conditions.NoRushPreventingHydroOrMex(tLZOrWZData, true))) then
        ACUActionBuildMex(aiBrain, oACU)
        --want 40 energy for every 2 mass
    elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] < math.max(math.min(8, iMexInLandZone * 4 + 4), math.min(25, aiBrain[M28Economy.refiGrossMassBaseIncome] * 14)) then
        local bHydroBuildOrder = false
        local tClosestHydroToACU
        local iClosestDistToACU = 100000
        local iCurHydroDist
        local bHaveUnderConstructionFirstHydro = false
        local oOptionalUnderConstructionHydro --used for redundancy
        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]) == false then
            for iEntry, tHydro in tLZOrWZData[M28Map.subrefHydroLocations] do
                if bDebugMessages == true then LOG(sFunctionRef..': Travel dist to hydro='..M28Utilities.GetTravelDistanceBetweenPositions(M28Map.GetPlayerStartPosition(aiBrain), tHydro, M28Map.refPathingTypeLand)) end
                if M28Utilities.GetTravelDistanceBetweenPositions(M28Map.GetPlayerStartPosition(aiBrain), tHydro, M28Map.refPathingTypeLand) <= 125 then --further than normal since we are in low mass scenario
                    bHydroBuildOrder = true
                    iCurHydroDist = M28Utilities.GetTravelDistanceBetweenPositions(tHydro, oACU:GetPosition(), M28Map.refPathingTypeLand)
                    if iCurHydroDist < iClosestDistToACU then
                        iClosestDistToACU = iCurHydroDist
                        tClosestHydroToACU = {tHydro[1], tHydro[2], tHydro[3]}
                    end
                end
            end
        end
        if bHydroBuildOrder and aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= 10 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryEngineer) > 0 then --have a hydro in the zone but havent built it yet, so want to build hydro
            ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData, oOptionalUnderConstructionHydro)
        else
            ACUActionBuildPower(aiBrain, oACU)
        end
    else
        --Build factory if dont have one and have lots of mass stored, or there are other mexes we want to get
        local iCurFactories = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory)
        if bDebugMessages == true then LOG(sFunctionRef..': iCurFactories='..iCurFactories..'; GetMexesNotNearPlayerStartingZone='..M28Conditions.GetMexesNotNearPlayerStartingZone()) end
        if iCurFactories == 0 and (aiBrain:GetEconomyStoredRatio('MASS') >= 0.95 or tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] > 0 or iMexInLandZone == 0) then
            ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryLandFactory)
        elseif iCurFactories == 0 and M28Conditions.GetMexesNotNearPlayerStartingZone() > 0 then
            ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryLandFactory)
        else
            --Attack (further away) nearby units
            if not(AttackNearestEnemyWithACU(iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, oACU, 100)) then
                --Get any reclaim, if any
                if not(ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, oACU, false, 1)) then

                    --Assist upgrade if we have any
                    local oUnitToAssist
                    local iHighestFractionComplete = -1
                    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoActiveUpgrades]) == false then
                        for iUpgrading, oUpgrading in  tLZOrWZTeamData[M28Map.subreftoActiveUpgrades] do
                            if M28UnitInfo.IsUnitValid(oUpgrading) then
                                if oUpgrading:GetWorkProgress() < 1 and oUpgrading:GetWorkProgress() > iHighestFractionComplete then
                                    iHighestFractionComplete = oUpgrading:GetWorkProgress()
                                    oUnitToAssist = oUpgrading
                                end
                            end
                        end
                    end
                    if oUnitToAssist then
                        if oUnitToAssist:GetFractionComplete() < 1 then
                            M28Orders.IssueTrackedRepair(oACU, oUnitToAssist, false, 'LMTR', false)
                            if bDebugMessages == true then LOG(sFunctionRef..': Just given repair order to oUnitToAssist') end
                        else
                            M28Orders.IssueTrackedGuard(oACU, oUnitToAssist, false, 'LMGB', false)
                            if bDebugMessages == true then LOG(sFunctionRef..': Just given guard order to oUnitToAssist') end
                        end
                    else
                        --Check for capture targets
                        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subreftoUnitsToCapture]) == false then
                            local t1ToT2PowerToCapture = EntityCategoryFilterDown(M28UnitInfo.refCategoryPower - categories.TECH3 - categories.EXPERIMENTAL, tLZOrWZData[M28Map.subreftoUnitsToCapture])
                            local tT1PowerToCapture
                            if M28Utilities.IsTableEmpty(t1ToT2PowerToCapture) == false then
                                tT1PowerToCapture = EntityCategoryFilterDown(categories.TECH1,t1ToT2PowerToCapture)
                            end
                            --Get more power to support capturing if we have mass
                            if aiBrain:GetEconomyStored('MASS') >= 75 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= 14 then
                                if M28Utilities.IsTableEmpty(tT1PowerToCapture) == false then
                                    local oClosestCaptureTarget = M28Utilities.GetNearestUnit(tT1PowerToCapture, oACU:GetPosition(), true, M28Map.refPathingTypeAmphibious)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have a capture target, oClosestCaptureTarget='..(oClosestCaptureTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestCaptureTarget))) end
                                    if M28UnitInfo.IsUnitValid(oClosestCaptureTarget) then
                                        M28Orders.IssueTrackedCapture(oACU, oClosestCaptureTarget, false, 'ACUCap', false)
                                    else
                                        ACUActionBuildPower(aiBrain, oACU) --redundancy
                                    end
                                else
                                    local bHydroBuildOrder = false
                                    local tClosestHydroToACU
                                    local iClosestDistToACU = 100000
                                    local iCurHydroDist
                                    local oOptionalUnderConstructionHydro --used for redundancy
                                    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]) == false then
                                        for iEntry, tHydro in tLZOrWZData[M28Map.subrefHydroLocations] do
                                            if bDebugMessages == true then LOG(sFunctionRef..': Travel dist to hydro='..M28Utilities.GetTravelDistanceBetweenPositions(M28Map.GetPlayerStartPosition(aiBrain), tHydro, M28Map.refPathingTypeLand)) end
                                            if M28Utilities.GetTravelDistanceBetweenPositions(M28Map.GetPlayerStartPosition(aiBrain), tHydro, M28Map.refPathingTypeLand) <= 125 then --further than normal since we are in low mass scenario
                                                bHydroBuildOrder = true
                                                iCurHydroDist = M28Utilities.GetTravelDistanceBetweenPositions(tHydro, oACU:GetPosition(), M28Map.refPathingTypeLand)
                                                if iCurHydroDist < iClosestDistToACU then
                                                    iClosestDistToACU = iCurHydroDist
                                                    tClosestHydroToACU = {tHydro[1], tHydro[2], tHydro[3]}
                                                end
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to build hydro instead of pgen, before doing more capturing, will check for under construction hydro if we dont have a build order already, bHydroBuildOrder='..tostring(bHydroBuildOrder)..'; Gross E='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; Is table of hydro points on map empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tHydroPoints))) end
                                    if not(bHydroBuildOrder) and aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= 20 and M28Utilities.IsTableEmpty(M28Map.tHydroPoints) == false then
                                        --Check for nearby hydro under construction by us (in case zones have meant hydro is a bit further away)
                                        local tNearbyHydro = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryHydro, oACU:GetPosition(), 60, 'Ally')
                                        if bDebugMessages == true then LOG(sFunctionRef..': Is tNearbyHydro (hydro units) empty='..tostring(M28Utilities.IsTableEmpty(tNearbyHydro))) end
                                        if M28Utilities.IsTableEmpty(tNearbyHydro) == false then
                                            local iClosestHydro = 100
                                            local iCurDist
                                            for iHydro, oHydro in tNearbyHydro do
                                                if oHydro:GetFractionComplete() < 1 and oHydro:GetAIBrain() == aiBrain then
                                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oHydro:GetPosition(), oACU:GetPosition())
                                                    if iCurDist < iClosestHydro then
                                                        iClosestHydro = iCurDist
                                                        oOptionalUnderConstructionHydro = oHydro
                                                        bHydroBuildOrder = true
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Recording oOptionalUnderConstructionHydro as oHydro='..oHydro.UnitId..M28UnitInfo.GetUnitLifetimeCount(oHydro)) end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    if bHydroBuildOrder and (aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= 10 or oOptionalUnderConstructionHydro) and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryEngineer) > 0 then --have a hydro in the zone but havent built it yet, so want to build hydro
                                        ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData, oOptionalUnderConstructionHydro)
                                    else
                                        ACUActionBuildPower(aiBrain, oACU)
                                    end
                                end
                            else
                                --If have low power prioritise power
                                local oClosestCaptureTarget
                                if M28Utilities.IsTableEmpty(t1ToT2PowerToCapture) == false and M28Conditions.HaveLowPower(aiBrain.M28Team) then
                                    if M28Utilities.IsTableEmpty(tT1PowerToCapture) == false then
                                        oClosestCaptureTarget = M28Utilities.GetNearestUnit(tT1PowerToCapture, oACU:GetPosition(), true, M28Map.refPathingTypeAmphibious)
                                        if bDebugMessages == true then LOG(sFunctionRef..': will get closest t1 pgen to capture') end
                                    else
                                        oClosestCaptureTarget = M28Utilities.GetNearestUnit(t1ToT2PowerToCapture, oACU:GetPosition(), true, M28Map.refPathingTypeAmphibious)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will get closest T1-T2 pgen to capture') end
                                    end
                                else
                                    local tT1OrT2MassGeneration = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryMassFab - categories.TECH3 - categories.EXPERIMENTAL,tLZOrWZData[M28Map.subreftoUnitsToCapture])
                                    if M28Utilities.IsTableEmpty(  tT1OrT2MassGeneration) == false and M28Conditions.HaveLowMass(aiBrain) then
                                        oClosestCaptureTarget = M28Utilities.GetNearestUnit(tT1OrT2MassGeneration, oACU:GetPosition(), true, M28Map.refPathingTypeAmphibious)
                                        if bDebugMessages == true then LOG(sFunctionRef..': will get closest mass fab or mex to cpature') end
                                    else
                                        oClosestCaptureTarget = M28Utilities.GetNearestUnit(tLZOrWZData[M28Map.subreftoUnitsToCapture], oACU:GetPosition(), true, M28Map.refPathingTypeAmphibious)
                                        if bDebugMessages == true then LOG(sFunctionRef..'; Will get closest unit to capture') end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have a capture target, oClosestCaptureTarget='..(oClosestCaptureTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestCaptureTarget))) end
                                if M28UnitInfo.IsUnitValid(oClosestCaptureTarget) then
                                    M28Orders.IssueTrackedCapture(oACU, oClosestCaptureTarget, false, 'ACUCap', false)
                                end
                            end
                        end
                    end
                end
            end
        end

    end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetACUEarlyGameOrders(aiBrain, oACU)
    local sFunctionRef = 'GetACUEarlyGameOrders'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iPlateauOrZero, iLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oACU:GetPosition())



    local tLZOrWZData
    local tLZOrWZTeamData
    local iTeam = oACU:GetAIBrain().M28Team
    local iResourceMod = aiBrain[M28Economy.refiBrainResourceMultiplier]
    --if aiBrain.CheatEnabled then iResourceMod = M28Team.tTeamData[aiBrain.M28Team][M28Team.refiHighestBrainResourceMultiplier] end
    if iPlateauOrZero == 0 then
        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLZOrWZ]][M28Map.subrefPondWaterZones][iLZOrWZ]
        tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][aiBrain.M28Team]
    else
        tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLZOrWZ]
        tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Considering ACU for brain '..oACU:GetAIBrain().Nickname..'; Time='..GetGameTimeSeconds()..'; ACU state='..M28UnitInfo.GetUnitState(oACU)..'; iPlateauOrZero='..iPlateauOrZero..'; iLZOrWZ='..(iLZOrWZ or 'nil')..'; Hover label at position='..NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oACU:GetPosition())..'; ACU position='..repru(oACU:GetPosition())) end


    --If have low cost mex upgrades then fork a thread to get all of these first
    if not(oACU[reftPreferredUpgrades]) then
        GetUpgradePathForACU(oACU)
    end
    if bDebugMessages == true and oACU[reftPreferredUpgrades][1] then LOG(sFunctionRef..': oACU[reftPreferredUpgrades][1]='..oACU[reftPreferredUpgrades][1]..'; Build cost mass='..(oACU:GetBlueprint().Enhancements[oACU[reftPreferredUpgrades][1]].BuildCostMass or 'nil')..'; Build time='..(oACU:GetBlueprint().Enhancements[oACU[reftPreferredUpgrades][1]].BuildTime or 'nil')..'; Has enhancement='..tostring(oACU:HasEnhancement(oACU[reftPreferredUpgrades][1]))) end
    if oACU[reftPreferredUpgrades][1] and oACU:GetBlueprint().Enhancements[oACU[reftPreferredUpgrades][1]].BuildCostMass <= 10 and oACU:GetBlueprint().Enhancements[oACU[reftPreferredUpgrades][1]].BuildTime <= 10 and not(oACU:HasEnhancement(oACU[reftPreferredUpgrades][1])) then
        GetUpgradePathForACU(oACU) --Refresh to be safe
        local bQueuedEnhancement = false
        for iEnhancement, sEnhancement in oACU[reftPreferredUpgrades] do
            if oACU:GetBlueprint().Enhancements[sEnhancement].BuildCostMass <= 10 and oACU:GetBlueprint().Enhancements[sEnhancement].BuildTime <= 10 and not(oACU:HasEnhancement(sEnhancement)) then
                if bDebugMessages == true then LOG(sFunctionRef..'; Queing up enhancement '..sEnhancement) end
                M28Orders.IssueTrackedEnhancement(oACU, sEnhancement, true, 'ACULCEn')
                bQueuedEnhancement = true
            else
                break
            end
        end
        if bQueuedEnhancement then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return nil
        end
    end


    --Nearby enemy units in other land zone if we already have a complete land factory
    local iSearchDistance = 40
    if M28Map.bIsCampaignMap then iSearchDistance = 36 end
    local bACUWantsToRun = DoesACUWantToRun(iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, oACU)
    local bProceedWithLogic = true
    local iCurLandFacs = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory)
    if iCurLandFacs >= 1 and iPlateauOrZero > 0 and (not(M28Map.bIsCampaignMap) or iPlateauOrZero == 0 or not(bACUWantsToRun)) and AttackNearestEnemyWithACU(iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, oACU, iSearchDistance) then
        if bDebugMessages == true then LOG(sFunctionRef..': ACU has enemies within 40 of it so will attack as we already have a factory complete') end
        bProceedWithLogic = false
    elseif bACUWantsToRun and M28Map.bIsCampaignMap and iCurLandFacs >= 1 and tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
        --Retreat from nearest enemy
        local bHaveRun = false
        local oNearestEnemy
        local iClosestDistUntilInRange = 10000
        local iCurDist
        function ConsiderNearestEnemyInZone(tCurLZTeamData)
            if M28Utilities.IsTableEmpty(tCurLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                for iUnit, oUnit in tCurLZTeamData[M28Map.subrefTEnemyUnits] do
                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 and (oUnit[M28UnitInfo.refiCombatRange] or 0) > 0 then
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition()) - oUnit[M28UnitInfo.refiCombatRange]
                        if iCurDist < iClosestDistUntilInRange then
                            iClosestDistUntilInRange = iCurDist
                            oNearestEnemy = oUnit
                            if iClosestDistUntilInRange < 0 then break end
                        end
                    end
                end
            end
        end
        ConsiderNearestEnemyInZone(tLZOrWZTeamData)
        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in tLZOrWZData[M28Map.subrefLZAdjacentLandZones] do
                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                ConsiderNearestEnemyInZone(tAdjLZTeamData)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..'; Considering ignoring special micro, iClosestDistUntilInRange='..iClosestDistUntilInRange..'; oNearestEnemy='..(oNearestEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemy) or 'nil')) end
        if iClosestDistUntilInRange <= 1 and oNearestEnemy then
            --We want to run
            local tRallyPoint = M28Land.GetNearestLandRallyPoint(tLZOrWZData, iTeam, iPlateauOrZero, iLZOrWZ, 2, true)
            if M28Utilities.IsTableEmpty(tRallyPoint) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Angle to rally point tRallyPoint='..M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tRallyPoint)..'; Angle to nearest enemy PD='..M28Utilities.GetAngleFromAToB(oACU:GetPosition(), oNearestEnemy:GetPosition())) end
                if M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tRallyPoint), M28Utilities.GetAngleFromAToB(oACU:GetPosition(), oNearestEnemy:GetPosition())) > 90 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will consider running to shield or rally point') end
                    if not(ConsiderRunningToNearestShield(oACU, tLZOrWZData, tLZOrWZTeamData, iTeam, iPlateauOrZero, iLZOrWZ)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will override micro logic and retreat') end
                        M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'ACUIgnMRetr', true)
                        bHaveRun = true
                        bProceedWithLogic = false
                    end
                end
            end
        end
        if not(bHaveRun) and AttackNearestEnemyWithACU(iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, oACU, iSearchDistance) then
            bProceedWithLogic = false
        end
    end
    --Mod that reduces upgrade costs to negligible amount
    if bProceedWithLogic and GetGameTimeSeconds() <= 15 and (oACU:GetBlueprint().Enhancements.ResourceAllocation.BuildCostMass or 10000) <= 100 and (oACU:GetBlueprint().Enhancements.ResourceAllocation.BuildTime or 10000) <= 100 then
        local sUpgradeToGet, bIgnoreOtherUpgradeConditions = GetACUUpgradeWanted(oACU, nil, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]))
        if bDebugMessages == true then LOG(sFunctionRef..': sUpgradeToGet='..(sUpgradeToGet or 'nil')) end
        if not(sUpgradeToGet) and not(oACU:HasEnhancement('ResourceAllocation')) then sUpgradeToGet = 'ResourceAllocation' end --e.g. if in eco slot then we ignore upgrades initially
        if sUpgradeToGet == 'ResourceAllocation' or sUpgradeToGet == 'AdvancedEngineering' or sUpgradeToGet == 'ResourceAllocationAdvanced' or sUpgradeToGet == 'T3Engineering' then
            M28Orders.IssueTrackedEnhancement(oACU, sUpgradeToGet, false, 'ACUEGUpr1')
            bProceedWithLogic = false
        elseif oACU:HasEnhancement('ResourceAllocation') and not(oACU:HasEnhancement('AdvancedEngineering')) and oACU:GetBlueprint().Enhancements.AdvancedEngineering and GetGameTimeSeconds() <= 15 then
            --Get advanced engineering so we build faster
            sUpgradeToGet = 'AdvancedEngineering'
            M28Orders.IssueTrackedEnhancement(oACU, sUpgradeToGet, false, 'ACUEGUpr2')
            bProceedWithLogic = false
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': bProceedWithLogic='..tostring(bProceedWithLogic)) end
    if bProceedWithLogic then
        --Are we already building something?
        if bDebugMessages == true then LOG(sFunctionRef..': ACU unit state='..M28UnitInfo.GetUnitState(oACU)) end
        if not(oACU:IsUnitState('Building')) and not(oACU:IsUnitState('Repairing')) and not(oACU:IsUnitState('Capturing')) and (aiBrain:GetEconomyStoredRatio('MASS') <= 0.95 or not(oACU:IsUnitState('Reclaiming'))) then
            M28Air.UpdateTransportPlateauDropLocationShortlist(iTeam) --Redundancy

            --local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oACU:GetPosition(), true, oACU)

            if bDebugMessages == true then LOG(sFunctionRef..': iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLZOrWZ='..(iLZOrWZ or 'nil')..'; ACU pos='..repru(oACU:GetPosition())..'; Cur mexes='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMex)..'; Cur Pgens='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower)..'; Mass stored='..aiBrain:GetEconomyStored('MASS')..'; Energy stored='..aiBrain:GetEconomyStored('ENERGY')) end
            if (iPlateauOrZero or 0) > 0 and iLZOrWZ > 0 then
                --Do we want to build a mex, hydro or factory?
                if bDebugMessages == true then LOG(sFunctionRef..': Current land factories='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory)..'; Gross energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; Gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]) end
                local iMinEnergyPerTickWanted = 14 * iResourceMod --i.e. 6 T1 PGens given ACU gives 2 E
                --Large maps - consider going 2nd air instead of 2nd land
                local bGoSecondAir = false
                local iLandTravelDistanceToEnemyBase = 100000
                local iEnemyIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZOrWZTeamData[M28Map.reftClosestEnemyBase])
                local iOurIsland = tLZOrWZData[M28Map.subrefLZIslandRef]
                if iOurIsland > 0 and iOurIsland == iEnemyIsland then
                    local iEnemyPlateau, iEnemyLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tLZOrWZTeamData[M28Map.reftClosestEnemyBase])
                    if iEnemyLandZone > 0 then iLandTravelDistanceToEnemyBase = M28Map.GetTravelDistanceBetweenLandZones(iEnemyPlateau, iLZOrWZ, iEnemyLandZone) end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to go second air, map size='..(M28Map.iMapSize or 'nil')..'; iLandTravelDistanceToEnemyBase='..(iLandTravelDistanceToEnemyBase or 'nil')..'; Is table of potential drop zones empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau]))..'; Is transport island shortlist empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftTransportIslandDropShortlist]))..'; Travel distance using nearest allied and enemy base='..(M28Utilities.GetTravelDistanceBetweenPositions(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], tLZOrWZTeamData[M28Map.reftClosestEnemyBase], M28Map.refPathingTypeLand) or 'nil')) end
                if M28Map.iMapSize >= 512 and (M28Map.iMapSize > 512 or iLandTravelDistanceToEnemyBase > 280) and iPlateauOrZero > 0 and (M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau]) == false or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftTransportIslandDropShortlist]) == false) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Going second air due to map size or travel distance, unless have lots of mass stored and wnat a land fac quickly to spend the mass') end
                    if aiBrain:GetEconomyStoredRatio('MASS') >= 0.4 and M28Map.iMapSize <= 800 and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] and iLandTravelDistanceToEnemyBase <= 600 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory) < 2 then
                        --Dont go second air
                    elseif tLZOrWZData[M28Map.subrefLZOrWZMexCount] > 12 then
                        --Dont go second air as lots of mexes
                    else
                        bGoSecondAir = true
                    end
                end
                if not(bGoSecondAir) and M28Map.iMapSize >= 512 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false and table.getn(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) >= 2 then
                    --Still consider going 2nd air if have teammates between us and enemy (all teammates, not just M28 teammates) and are on a 10km+ map
                    if tLZOrWZTeamData[M28Map.refbBaseInSafePosition] then
                        bGoSecondAir = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Will go second air for brain '..aiBrain.Nickname) end
                    end

                end
                if not(bGoSecondAir) and (aiBrain[M28Overseer.refbPrioritiseNavy] or aiBrain[M28Overseer.refbPrioritiseAir]) and M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZOrWZData, tLZOrWZTeamData, aiBrain) then
                    bGoSecondAir = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Navy or air focus, we want air fac instead of land so will go second air') end
                end
                --Personality override
                if bGoSecondAir and (aiBrain[M28Overseer.refbPrioritiseLand] or aiBrain[M28Overseer.refbPrioritiseLowTech]) then bGoSecondAir = false end
                if bDebugMessages == true then LOG(sFunctionRef..': Deciding on min energy wanted, bGoSecondAir='..tostring(bGoSecondAir)..'; Gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]) end
                if bGoSecondAir then
                    aiBrain[M28Economy.refbGoingSecondAir] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Going second air, net energy base income='..aiBrain[M28Economy.refiNetEnergyBaseIncome]..'; Energy stored='..aiBrain:GetEconomyStored('ENERGY')) end
                    if aiBrain[M28Economy.refiNetEnergyBaseIncome] >= 4.5 and aiBrain:GetEconomyStored('ENERGY') >= 1800 then
                        iMinEnergyPerTickWanted = 20 * math.min(iResourceMod, aiBrain[M28Economy.refiBrainBuildRateMultiplier]) --Can get away with 4 pgens in some casese, even if engineers have managed to get some tree reclaim
                    else
                        iMinEnergyPerTickWanted = 22 * math.min(iResourceMod, aiBrain[M28Economy.refiBrainBuildRateMultiplier]) --ACU gives 2E, want equiv of 10 PGens, assuming build rate is same as resource rate
                    end
                end
                local iFactoryCap = 4 --redundancy - only intend to use in very low mass scenarios that arent low mex maps
                if aiBrain[M28Economy.refiGrossMassBaseIncome] < 0.8 * aiBrain[M28Economy.refiBrainBuildRateMultiplier] and (tLZOrWZData[M28Map.subrefLZOrWZMexCount] or 0) <= 2 and aiBrain:GetEconomyStoredRatio('MASS') < 0.3 then
                    iMinEnergyPerTickWanted = 6 * aiBrain[M28Economy.refiBrainBuildRateMultiplier]
                    iFactoryCap = 1
                end

                if iMinEnergyPerTickWanted <= 15 and aiBrain:GetEconomyStored('ENERGY') <= 200 and (aiBrain:GetEconomyStored('ENERGY') < 50 or aiBrain:GetEconomyStored('MASS') > math.min(75, aiBrain:GetEconomyStored('ENERGY'))) then
                    iMinEnergyPerTickWanted = iMinEnergyPerTickWanted + 2
                    if bDebugMessages == true then LOG(sFunctionRef..': Will get extra pgen as looks like we are about to stall E') end
                end

                local iCurLandFactories = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory)
                if bDebugMessages == true then LOG(sFunctionRef..': iCurLandFactories='..iCurLandFactories..'; AIr factories='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory)..'; iFactoryCap='..iFactoryCap..'; aiBrain[M28Economy.refiGrossEnergyBaseIncome]='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; iMinEnergyPerTickWanted='..iMinEnergyPerTickWanted) end
                if M28Map.bIsLowMexMap and GetGameTimeSeconds() <= 1800 and tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] == 0 then
                    GetLowMexMapEarlyACUOrder(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData)
                else
                    --First bomber mode - apply special build order
                    if aiBrain[M28Overseer.refbFirstBomber] and iCurLandFactories == 0 then
                        --If havent got pgen then build pgen
                        local iCurPGens = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower)
                        local iCurAirFac = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory)
                        local iCurMex = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMex)
                        if iCurPGens == 0 or (iCurPGens < 3 and M28Utilities.bQuietModActive) then
                            ACUActionBuildPower(aiBrain, oACU)
                        elseif iCurAirFac == 0 then
                            ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryAirFactory)
                        elseif iCurPGens < 3 or (iCurPGens < 4 and M28Utilities.bQuietModActive) then
                            ACUActionBuildPower(aiBrain, oACU)
                        elseif iCurMex < 4 and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false then
                            ACUActionBuildMex(aiBrain, oACU)
                        else
                            ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryLandFactory)
                        end
                    elseif iCurLandFactories == 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want ACU to build a land factory') end
                        ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryLandFactory)
                        --Build more factories if we have 100% E, positive net energy, have a decent amount of mass stored, and we have at least 1 pgen or hydro
                    elseif iCurLandFactories < 10 and aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.99 and aiBrain:GetEconomyStored('MASS') >= 250 and aiBrain[M28Economy.refiNetMassBaseIncome] > 0 and aiBrain[M28Economy.refiNetEnergyBaseIncome] > 0 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory) < math.max(3, math.min(8, aiBrain[M28Economy.refiGrossMassBaseIncome] * 0.5)) and (not(tLZOrWZTeamData[M28Map.refbBaseInSafePosition]) or tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] >= 2) then
                        if  M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZOrWZData, tLZOrWZTeamData, aiBrain) or (bGoSecondAir and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) == 0) then
                            if not(bGoSecondAir) and aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 20 * aiBrain[M28Economy.refiBrainResourceMultiplier] and (aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= iMinEnergyPerTickWanted or aiBrain:GetEconomyStoredRatio('ENERGY') < 0.99 or aiBrain[M28Economy.refiBrainBuildRateMultiplier] >= 1.2) then
                                if bDebugMessages == true then LOG(sFunctionRef..': want power so can build an air fac') end
                                ACUActionBuildPower(aiBrain, oACU)
                            else
                                ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryAirFactory, M28Engineer.refActionBuildAirFactory)
                            end
                        else
                            ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryLandFactory)
                        end
                        --do we have unbuilt nearby mexes (within 2 of ACU build range)? if so then build on them
                    elseif aiBrain.CheatEnabled and iResourceMod >= 1.3 and aiBrain:GetEconomyStored('MASS') >= 90 and (iResourceMod >= 2.0 or aiBrain[M28Economy.refiBrainBuildRateMultiplier] > 1.0) and aiBrain[M28Economy.refiGrossEnergyBaseIncome] < iMinEnergyPerTickWanted and ((iResourceMod >= 1.5 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 6 * M28Team.tTeamData[aiBrain.M28Team][M28Team.refiHighestBrainResourceMultiplier]) or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower) == 0) and (tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] or 0) >= 2 then
                        --Build a couple of PGen even if nearby hydro given cheat mult
                        if bDebugMessages == true then LOG(sFunctionRef..': Want more power due to cheat mult before hydro') end
                        ACUActionBuildPower(aiBrain, oACU)
                        --High resource mods where we are going to be getting T2 on our ACU as our first upgrade - go to T2
                    elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 100 and oACU[refiUpgradeCount] == 0 and aiBrain[M28Economy.refiNetMassBaseIncome] >= 1 and (tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] > 0 or tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] > 0) and aiBrain[M28Economy.refiNetEnergyBaseIncome] >= 25 and aiBrain:GetEconomyStoredRatio('MASS') >= 0.3 and GetACUUpgradeWanted(oACU, false, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero) == 'AdvancedEngineering' and M28Conditions.SafeToUpgradeUnit(oACU) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Early T2 upgrade for high resourcem odifier games') end
                        M28Orders.IssueTrackedEnhancement(oACU, 'AdvancedEngineering', false, 'ACUT2')
                        --We have T2+ and want power
                    elseif oACU[refiBuildTech] >= 2 and HaveActionForACUAsEngineer(oACU, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iLZOrWZ) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will make use of ACU engineering suite to build power') end
                    elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 12 * iResourceMod and (aiBrain:GetEconomyStored('ENERGY') >= 100 or aiBrain[M28Economy.refiNetEnergyBaseIncome] > -0.1) and ((tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] * 3 + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] * 9) < 5 or aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.5 or aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 10 * aiBrain[M28Economy.refiGrossMassBaseIncome]) and ConsiderBuildingMex(tLZOrWZData, tLZOrWZTeamData, oACU, 2) then
                        --Do nothing - have bene given an order to build a neaby mex
                        if bDebugMessages == true then LOG(sFunctionRef..': Want more mex as have decent base power level, tLZOrWZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZOrWZTeamData[M28Map.subrefMexCountByTech])..'; energy %='..aiBrain:GetEconomyStoredRatio('ENERGY')..'; gross mass='..aiBrain[M28Economy.refiGrossMassBaseIncome]) end
                        --LOUD - consider mexes further away and get in proportion to pgens initially
                    elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] < iMinEnergyPerTickWanted then

                        --Do we want to build a hydro (so get mexes first then hydro) or build pgen?


                        local bHydroBuildOrder = false
                        --On crag dunes the hydro travel distance is 102 away and going for early hydro (with 4 mexes) causes power stall; top players BO appears to be normal no-hydro BO
                        --For theta passage the travel distance is 62.5
                        --For Cadmium green its 51.9
                        local tClosestHydroToACU
                        local iClosestDistToACU = 100000

                        local iCurHydroDist
                        local bHaveUnderConstructionFirstHydro = false
                        local oOptionalUnderConstructionHydro --used for redundancy
                        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]) == false then

                            for iEntry, tHydro in tLZOrWZData[M28Map.subrefHydroLocations] do
                                if bDebugMessages == true then LOG(sFunctionRef..': Travel dist to hydro='..M28Utilities.GetTravelDistanceBetweenPositions(M28Map.GetPlayerStartPosition(aiBrain), tHydro, M28Map.refPathingTypeLand)) end
                                if M28Utilities.GetTravelDistanceBetweenPositions(M28Map.GetPlayerStartPosition(aiBrain), tHydro, M28Map.refPathingTypeLand) <= 90 then --Open palms is 85.65
                                    bHydroBuildOrder = true
                                    iCurHydroDist = M28Utilities.GetTravelDistanceBetweenPositions(tHydro, oACU:GetPosition(), M28Map.refPathingTypeLand)
                                    if iCurHydroDist < iClosestDistToACU then
                                        iClosestDistToACU = iCurHydroDist
                                        tClosestHydroToACU = {tHydro[1], tHydro[2], tHydro[3]}
                                    end
                                end
                            end
                        end
                        if not(bHydroBuildOrder) then
                            --Redundancy 1 incase have a hydro registered to core zone instead of nearby and we ahve travlled to nearby zone
                            local tNearbyHydro = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryHydro, oACU:GetPosition(), 35, 'Ally')
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby hydros empty='..tostring(M28Utilities.IsTableEmpty(tNearbyHydro))) end
                            local oCompleteHydro
                            if M28Utilities.IsTableEmpty(tNearbyHydro) == false then

                                for iHydro, oHydro in tNearbyHydro do
                                    if oHydro:GetAIBrain() == aiBrain and oHydro:GetFractionComplete() < 1 then
                                        iCurHydroDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oHydro:GetPosition())
                                        if iCurHydroDist < iClosestDistToACU then
                                            iClosestDistToACU = iCurHydroDist
                                            tClosestHydroToACU = oHydro:GetPosition()
                                            oOptionalUnderConstructionHydro = oHydro
                                        end
                                    else
                                        oCompleteHydro = oHydro
                                    end
                                end
                            end
                            if not(oOptionalUnderConstructionHydro) and oCompleteHydro then
                                iClosestDistToACU = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oCompleteHydro:GetPosition())
                                tClosestHydroToACU = oCompleteHydro:GetPosition()
                                bHydroBuildOrder = true
                            elseif oOptionalUnderConstructionHydro then bHydroBuildOrder = true
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Will adjust build order depending on if have hydro nearby. Is table of land zone hydros empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]))..'; bHydroBuildOrder='..tostring(bHydroBuildOrder)) end
                        if not(bHydroBuildOrder) then
                            --Per discord gameplay and training pinned build order for going land facs with no hydro:
                            --ACU:      Landfac - 2 PG - 2 Mex - 1 PG - 2 Mex - 3 PG - Landfac - PG - Landfac
                            if bDebugMessages == true then LOG(sFunctionRef..': No hydro locations so will build power or mex depending on income') end
                            --LOUD special build order
                            if (M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMex) < math.min(4, aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower)) and aiBrain:GetEconomyStored('MASS') <= math.min(200, aiBrain:GetEconomyStored('ENERGY') * 4) and ConsiderBuildingMex(tLZOrWZData, tLZOrWZTeamData, oACU, 50) then
                                if bDebugMessages == true then LOG(sFunctionRef..': LOUD/QUIET build order = want to get mex sooner than normal') end
                            elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] < math.max(6, 2 * (tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] * 3 + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] * 9)) * iResourceMod then
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to build initial PGens') end
                                ACUActionBuildPower(aiBrain, oACU)
                            else
                                local iMexInLandZone = 0
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZOrWZMexLocations]) == false then iMexInLandZone = table.getn(tLZOrWZData[M28Map.subrefLZOrWZMexLocations]) end
                                local iMaxMexesBeforeHydro = 4
                                if iMexInLandZone > 4 and aiBrain:GetEconomyStored('MASS') >= 25 then iMaxMexesBeforeHydro = 3 end
                                if bDebugMessages == true then LOG(sFunctionRef..': Deciding on ACU action for where no hydro nearby, gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; Gross energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; iMexInLandZone='..iMexInLandZone..'; iMinEnergyPerTickWanted='..iMinEnergyPerTickWanted..'; iCurLandFactories='..iCurLandFactories) end
                                if aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(2, iMexInLandZone) * 0.2 * iResourceMod and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false and (not(M28Overseer.bNoRushActive) or not(M28Conditions.NoRushPreventingHydroOrMex(tLZOrWZData, true))) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want at least 2 mexes') end
                                    ACUActionBuildMex(aiBrain, oACU)

                                elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 8 * iResourceMod then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want at least 4 PGens') end
                                    ACUActionBuildPower(aiBrain, oACU)
                                elseif aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(iMaxMexesBeforeHydro, iMexInLandZone) * 0.2 * iResourceMod and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false and (not(M28Overseer.bNoRushActive) or not(M28Conditions.NoRushPreventingHydroOrMex(tLZOrWZData, true))) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want up to iMaxMexesBeforeHydro='..iMaxMexesBeforeHydro..' mexes') end
                                    ACUActionBuildMex(aiBrain, oACU)
                                    --QUIET specific - abort build order early if are heavily stalling
                                elseif (M28Utilities.bQuietModActive or M28Utilities.bLoudModActive) and (aiBrain[M28Economy.refiNetEnergyBaseIncome] >= 4 or aiBrain:GetEconomyTrend('ENERGY') >= 4 or (aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.65 and math.max(aiBrain[M28Economy.refiNetEnergyBaseIncome], aiBrain:GetEconomyTrend('ENERGY')) >= 2.5)) and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 18 and aiBrain[M28Economy.refiNetMassBaseIncome] <= -0.2 and aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.4 and aiBrain:GetEconomyStored('MASS') <= 1 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Finish build order early as we cant spend the mass') end
                                    oACU[refbDoingInitialBuildOrder] = false
                                elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] < iMinEnergyPerTickWanted and ((aiBrain:GetEconomyStoredRatio('ENERGY') <= 0.6 or (aiBrain:GetEconomyStoredRatio('ENERGY') <= 0.75 and aiBrain[M28Economy.refiNetEnergyBaseIncome] <= 3) or (aiBrain[M28Economy.refiNetEnergyBaseIncome] <= 1.5 and (aiBrain[M28Economy.refiNetEnergyBaseIncome] < 0.5 or aiBrain:GetEconomyStoredRatio('ENERGY') <= 0.98)) or aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= math.max(12 * aiBrain[M28Economy.refiBrainBuildRateMultiplier], iMinEnergyPerTickWanted * 0.75)) or aiBrain:GetEconomyStoredRatio('MASS') >= 0.35) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want basic level of power, energy stored='..aiBrain:GetEconomyStoredRatio('ENERGY')..'; Net E income='..aiBrain[M28Economy.refiNetEnergyBaseIncome]..'; aiBrain:GetEconomyTrend(ENERGY)='..aiBrain:GetEconomyTrend('ENERGY')..'; Gross inc='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; Mass %='..aiBrain:GetEconomyStoredRatio('MASS')..'; Net mass='..aiBrain[M28Economy.refiNetMassBaseIncome]) end
                                    ACUActionBuildPower(aiBrain, oACU)
                                    --below are redundancy - if we have min energy per tick wanted then wouldn't expect below to trigger
                                elseif aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(4, iMexInLandZone) * 0.2 * iResourceMod and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false and (not(M28Overseer.bNoRushActive) or not(M28Conditions.NoRushPreventingHydroOrMex(tLZOrWZData, true))) then
                                    --e.g. if went 3 mex hydro then want to get 4th mex before factory
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want up to 4 mexes') end
                                    ACUActionBuildMex(aiBrain, oACU)
                                elseif iCurLandFactories < 2 and iCurLandFactories + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) < 3 and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] and (not(tLZOrWZTeamData[M28Map.refbBaseInSafePosition]) or tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] >= 2 or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) == 0) and M28Conditions.WantMoreFactories(aiBrain.M28Team, iPlateauOrZero, iLZOrWZ) and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) == 0 then
                                    if bGoSecondAir then
                                        ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryAirFactory, M28Engineer.refActionBuildAirFactory)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to go second air') end
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want 2 land factories') end
                                        ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData)
                                    end
                                elseif aiBrain[M28Economy.refiGrossMassBaseIncome] < iMexInLandZone * 0.2 * iResourceMod and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false and (not(M28Overseer.bNoRushActive) or not(M28Conditions.NoRushPreventingHydroOrMex(tLZOrWZData, true))) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to build on every mex in land zone') end
                                    ACUActionBuildMex(aiBrain, oACU)
                                elseif iCurLandFactories < 2 and M28Map.iMapSize <= 512 and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] and (not(tLZOrWZTeamData[M28Map.refbBaseInSafePosition]) or tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] >= 2) and aiBrain:GetEconomyStored('MASS') >= 40 and iPlateauOrZero > 0 and (aiBrain:GetEconomyStored('MASS') >= 200 or M28Conditions.WantMoreFactories(iTeam, iPlateauOrZero, iLZOrWZ)) and not(M28Overseer.bNoRushActive) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have 2 land facs yet so will get another') end
                                    --ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLandOrWaterZone, tLZData, tLZTeamData, iFactoryCategoryOverride, iEngineerActionOverride)
                                    ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData,     M28UnitInfo.refCategoryLandFactory, M28Engineer.refActionBuildLandFactory)

                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': We dont have the min level of power that we want yet') end
                                    ACUActionBuildPower(aiBrain, oACU)
                                end
                            end

                            --Redundancy if failed to get orer from the above
                            if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) and oACU[refbDoingInitialBuildOrder] then
                                --No hydro nearby - try building power; then try building mex; then cancel initial build order
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false and (not(M28Overseer.bNoRushActive) or not(M28Conditions.NoRushPreventingHydroOrMex(tLZOrWZData, true))) then
                                    ACUActionBuildMex(aiBrain, oACU)
                                end
                                if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and build power as redundancy') end
                                    ACUActionBuildPower(aiBrain, oACU)
                                    if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) then
                                        oACU[refbDoingInitialBuildOrder] = false
                                    end
                                end
                            end
                        else --Have a hydro so get more mexes initially
                            --Max mex to build
                            local iHydroDistToStart = M28Utilities.GetDistanceBetweenPositions(tClosestHydroToACU, tLZOrWZData[M28Map.subrefMidpoint])
                            local iMexInLandZone = 0
                            local oHydroToConsiderAssisting
                            local iClosestHydroDist = 1000
                            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZOrWZMexLocations]) == false then iMexInLandZone = table.getn(tLZOrWZData[M28Map.subrefLZOrWZMexLocations]) end
                            if bDebugMessages == true then LOG(sFunctionRef..': Hydro is nearby, Gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; iMexInLandZone='..iMexInLandZone..'; Gross base energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; Dist of closest hydro='..iHydroDistToStart) end
                            --Do we have a hydro underconstruction in this land zone?
                            if aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 12 * iResourceMod then
                                local tHydroInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryHydro, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                if M28Utilities.IsTableEmpty(tHydroInZone) == false then
                                    local iCurHydroDist
                                    bHaveUnderConstructionFirstHydro = true
                                    for iHydro, oHydro in tHydroInZone do
                                        if oHydro:GetFractionComplete() == 1 and oHydro:GetAIBrain() == aiBrain then
                                            bHaveUnderConstructionFirstHydro = false
                                            break
                                        else
                                            iCurHydroDist = M28Utilities.GetDistanceBetweenPositions(oHydro:GetPosition(), oACU:GetPosition())
                                            if iCurHydroDist < iClosestHydroDist then
                                                oHydroToConsiderAssisting = oHydro
                                                iClosestHydroDist = iCurHydroDist
                                            end
                                        end
                                    end
                                end
                            end
                            local iMexCap = 4
                            if iHydroDistToStart >= 50 and not(M28Utilities.bLoudModActive) and not(M28Utilities.bQuietModActive) then iMexCap = 3 end --e.g. Verdant Valley - dist is c.95, and we power-stall if going for 4 mexes (even after getting 4 trees).  Theta passage dist is 32; Canis river is 61 travel dist and 58 straight line and we also stall E for a while by getting 4 mexes
                            local bHaveUnbuiltMexNearHydro = false
                            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false then
                                local iDistanceThreshold = 80 - 5 * (tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3])

                                for iMex, tMex in tLZOrWZData[M28Map.subrefMexUnbuiltLocations] do
                                    if M28Utilities.GetTravelDistanceBetweenPositions(tMex, tClosestHydroToACU, M28Map.refPathingTypeLand) <= iDistanceThreshold then
                                        bHaveUnbuiltMexNearHydro = true
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Loud/QUIET early pgen builder check - cur pgens='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower)..'; Mass stored='..aiBrain:GetEconomyStored('MASS')..'; Energy stored='..aiBrain:GetEconomyStored('ENERGY')) end
                            if (M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower) <= 1 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMex) >= aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower) and aiBrain:GetEconomyStored('ENERGY') <= math.min(2000, aiBrain:GetEconomyStored('MASS') * 20) then
                                if bDebugMessages == true then LOG(sFunctionRef..': LOUD/QUIET build order = want to get a pgen before hydro to avoid stalling') end
                                ACUActionBuildPower(aiBrain, oACU)
                            elseif bHaveUnderConstructionFirstHydro and
                                (aiBrain[M28Economy.refiBrainResourceMultiplier] <= 1.2 or
                                (oHydroToConsiderAssisting:GetFractionComplete() <= 0.7 - math.min(0.55, 0.35 * (iClosestHydroDist - 10)/10) and (iClosestHydroDist <= 60 - math.min(50, (aiBrain[M28Economy.refiBrainBuildRateMultiplier]-1)*100))) or
                                aiBrain:GetEconomyStored('ENERGY') <= 450 or
                                iClosestHydroDist <= 2 + oACU:GetBlueprint().Economy.MaxBuildDistance)
                             and (aiBrain[M28Economy.refiGrossMassBaseIncome] >= 1.2 * iResourceMod or tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] >= math.min(3, iMexInLandZone)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have underconstruction hydro and equiv of 3 mexes or every mex in zone so will try and assist it, oHydroToConsiderAssisting:GetFractionComplete()='..oHydroToConsiderAssisting:GetFractionComplete()..'; iClosestHydroDist='..iClosestHydroDist..'; E stored='..aiBrain:GetEconomyStored('ENERGY')..'; Resource multiplier='..aiBrain[M28Economy.refiBrainResourceMultiplier]..'; aiBrain[M28Economy.refiBrainBuildRateMultiplier]='..aiBrain[M28Economy.refiBrainBuildRateMultiplier]) end
                                ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData, oOptionalUnderConstructionHydro)
                            elseif (tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] * 3 + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3]) >= 5 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] < math.max(6, 2 * (tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] * 3 + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] * 9)) * iResourceMod then
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to build pgens or extra hydro, is oOptionalUnderConstructionHydro valid='..tostring(M28UnitInfo.IsUnitValid(oOptionalUnderConstructionHydro))) end
                                if oOptionalUnderConstructionHydro then
                                    ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData, oOptionalUnderConstructionHydro)
                                else
                                    ACUActionBuildPower(aiBrain, oACU)
                                end

                            elseif bHaveUnbuiltMexNearHydro and aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(iMexCap, iMexInLandZone) * 0.2 * aiBrain[M28Economy.refiBrainBuildRateMultiplier] or (aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(4, iMexInLandZone) * 0.2 * iResourceMod and aiBrain:GetEconomyStored('MASS') < 100) and (not(M28Overseer.bNoRushActive) or not(M28Conditions.NoRushPreventingHydroOrMex(tLZOrWZData, true))) and ((not(M28Utilities.bLoudModActive) and not(M28Utilities.bQuietModActive)) or not(bHaveUnderConstructionFirstHydro) or not(oOptionalUnderConstructionHydro) or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMex) <= 3) then
                                if bDebugMessages == true then LOG(sFunctionRef..': We ahve mexes in land zone and we havent built on all of them so will build a mex') end
                                ACUActionBuildMex(aiBrain, oACU)
                                if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) then
                                    if M28Orders.bDontConsiderCombinedArmy or oACU.M28Active then
                                        M28Utilities.ErrorHandler('ACU wants to build a mex but failed to find anywhere')
                                    end
                                end
                            elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 10 * iResourceMod and (iResourceMod <= 1.7 or aiBrain:GetEconomyStored('MASS') <= 80) and (iResourceMod <= 1.4 or aiBrain[M28Economy.refiBrainBuildRateMultiplier] <= 1.4 or iClosestHydroDist <= 40 or aiBrain:GetEconomyStored('ENERGY') <= 450) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will try to assist a hydro nearby') end
                                ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData, oOptionalUnderConstructionHydro)
                            else --We ahve alreadyu confirmed we have < min energy per tick wanted earlier, so want to build pgen
                                --Have base level of power suggesting already have hydro but we still want a bit more power
                                if bDebugMessages == true then LOG(sFunctionRef..': Want more power to reach a base level') end
                                ACUActionBuildPower(aiBrain, oACU)
                            end

                            --Redundancy if fail to get order from above
                            if bDebugMessages == true then LOG(sFunctionRef..': Is ACU table of last orders empty after attempting above='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))..'; Does ACU have a valid order='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))) end
                            if not(M28Conditions.DoesACUHaveValidOrder(oACU)) and oACU[refbDoingInitialBuildOrder] and (M28Orders.bDontConsiderCombinedArmy or oACU.M28Active) then
                                --Is it just that we want to assist a hydro and engineers havent started one yet? If so then check if we have an engineer assigned to build one, and check the game time
                                if GetGameTimeSeconds() <= 180 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 10 * iResourceMod and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]) == false then
                                    ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData, oOptionalUnderConstructionHydro)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Assuming we are waiting for an engi to start on building a hydro, or we have no nearby mexes to our ACU') end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': Failed to get order from above so will resort to backup logic') end
                                    --No hydro nearby - try building power; then try building mex; then cancel initial build order
                                    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false and (not(M28Overseer.bNoRushActive) or not(M28Conditions.NoRushPreventingHydroOrMex(tLZOrWZData, true))) then
                                        ACUActionBuildMex(aiBrain, oACU)
                                    end
                                    if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then
                                        ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData)
                                        if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then
                                            ACUActionBuildPower(aiBrain, oACU)
                                            if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then
                                                if not(M28Map.bIsCampaignMap) or GetGameTimeSeconds() <= 540 then oACU[refbDoingInitialBuildOrder] = false end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    else
                        --Have initial power and mexes built, get second factory now subject to the cap
                        if iCurLandFactories + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) < iFactoryCap then
                            local bWantAirFactory = M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZOrWZData, tLZOrWZTeamData, aiBrain)
                            if bDebugMessages == true then LOG(sFunctionRef..': Checking if want more factories, iCurLandFactories='..iCurLandFactories..'; Want more factories='..tostring(M28Conditions.WantMoreFactories(aiBrain.M28Team, iPlateauOrZero, iLZOrWZ))..'; Cur air factories='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory)) end
                            if bGoSecondAir and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) == 0 then
                                ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryAirFactory, M28Engineer.refActionBuildAirFactory)
                                if bDebugMessages == true then LOG(sFunctionRef..': Want ACU to go second air') end
                            elseif iCurLandFactories < 2 and M28Conditions.WantMoreFactories(aiBrain.M28Team, iPlateauOrZero, iLZOrWZ) and iCurLandFactories + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) < 3 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to g et a second land factory or air factory') end
                                if bWantAirFactory then
                                    if not(bGoSecondAir) and aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 20 * aiBrain[M28Economy.refiBrainResourceMultiplier] then
                                        if bDebugMessages == true then LOG(sFunctionRef..': want power in order that we can build an air fac') end
                                        ACUActionBuildPower(aiBrain, oACU)
                                    else
                                        ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData,     M28UnitInfo.refCategoryAirFactory, M28Engineer.refActionBuildAirFactory)
                                    end
                                else
                                    ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData,     M28UnitInfo.refCategoryLandFactory, M28Engineer.refActionBuildLandFactory)
                                end
                            elseif iCurLandFactories < 2 and M28Map.iMapSize <= 512 and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] and (not(tLZOrWZTeamData[M28Map.refbBaseInSafePosition]) or tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] >= 2) and aiBrain:GetEconomyStored('MASS') >= 40 and iPlateauOrZero > 0 and (aiBrain:GetEconomyStored('MASS') >= 200 or M28Conditions.WantMoreFactories(iTeam, iPlateauOrZero, iLZOrWZ)) and not(M28Overseer.bNoRushActive) and iCurLandFactories + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) < 2 then
                                --ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLandOrWaterZone, tLZData, tLZTeamData, iFactoryCategoryOverride, iEngineerActionOverride)
                                if bDebugMessages == true then LOG(sFunctionRef..': Dont have 2 land facs yet so will get another') end
                                if bWantAirFactory then
                                    ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData,     M28UnitInfo.refCategoryAirFactory, M28Engineer.refActionBuildAirFactory)
                                else
                                    ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData,     M28UnitInfo.refCategoryLandFactory, M28Engineer.refActionBuildLandFactory)
                                end
                            elseif aiBrain:GetEconomyStoredRatio('MASS') >= 0.6 and (aiBrain[M28Economy.refiNetMassBaseIncome] > 0.2 or aiBrain:GetEconomyStoredRatio('MASS') >= 0.9) and M28Conditions.HaveLowPower(iTeam) and aiBrain[M28Economy.refiOurHighestFactoryTechLevel] <= 1 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Lots of mass stored, low power, and we arent at T2 yet so will build more power') end
                                ACUActionBuildPower(aiBrain, oACU)
                            else
                                local iMexInLandZone = 0
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZOrWZMexLocations]) == false then iMexInLandZone = table.getn(tLZOrWZData[M28Map.subrefLZOrWZMexLocations]) end
                                if bDebugMessages == true then LOG(sFunctionRef..': Checking if want to build more mexes, iMexInLandZone='..iMexInLandZone..'; Mex count for LZ='..tLZOrWZData[M28Map.subrefLZOrWZMexCount]..'; Gross mass='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; iResourceMod='..iResourceMod..'; Is table of unbuilt mexes empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]))..'; Mex count by tech='..repru(tLZOrWZTeamData[M28Map.subrefMexCountByTech])..'; iCurLandFactories='..iCurLandFactories..'; iCurAirFactories='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory)) end
                                if aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(5, iMexInLandZone) * 0.2 * iResourceMod and (aiBrain:GetEconomyStoredRatio('MASS') <= 0.9 or aiBrain:GetEconomyStored('MASS') < 100) and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false and (not(M28Overseer.bNoRushActive) or not(M28Conditions.NoRushPreventingHydroOrMex(tLZOrWZData, true))) then
                                    ACUActionBuildMex(aiBrain, oACU)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will try building another mex') end
                                    --Third factory if overflowing mass or have quite a bit stored
                                elseif iCurLandFactories < 3 and (not(tLZOrWZTeamData[M28Map.refbBaseInSafePosition]) or tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] >= 2) and (M28Map.iMapSize <= 512 and (M28Map.iMapSize <= 256 or M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] == 1)) and aiBrain:GetEconomyStored('MASS') >= 250 or (aiBrain:GetEconomyStoredRatio('MASS') >= 0.9 and aiBrain:GetEconomyStored('MASS') >= 100) and iCurLandFactories + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) < 4 and M28Conditions.WantMoreFactories(iTeam, iPlateauOrZero, iLZOrWZ) then

                                    if bWantAirFactory then
                                        ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData,     M28UnitInfo.refCategoryAirFactory, M28Engineer.refActionBuildAirFactory)
                                    else
                                        ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData,     M28UnitInfo.refCategoryLandFactory, M28Engineer.refActionBuildLandFactory)
                                    end
                                    --If we are overflowing mass and have a unit upgrading in the zone then assist that instead (e.g. intended for maps where loads of reclaim that causes us to overflow)
                                else
                                    --Check for (rare) case where enemy ACU is getting near our base
                                    local bAbortLogic = false
                                    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) == false and iPlateauOrZero > 0 then
                                        local iApproachingACUThreat = M28Conditions.GetThreatOfApproachingEnemyACUsAndNearestACU(tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iLZOrWZ, iTeam)
                                        if bDebugMessages == true then LOG(sFunctionRef..': iApproachingACUThreat='..iApproachingACUThreat) end
                                        if iApproachingACUThreat >= 600 then
                                            if M28Conditions.CloseToEnemyUnit(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftoNearestDFEnemies], 15, iTeam, true, nil, nil, nil, nil, nil) then
                                                bAbortLogic = true
                                                oACU[refbDoingInitialBuildOrder] = false
                                                if bDebugMessages == true then LOG(sFunctionRef..': Are close to enemy DF unit so will attack enemy and end early game order') end
                                                if AttackNearestEnemyWithACU(iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, oACU, 90) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': will attack the nearest enemy') end
                                                else
                                                    --For some reason we dont want to attack, but will have aborted early game order so this should just be a 1s delay
                                                end
                                            elseif ACUActionBuildMex(aiBrain, oACU, 15) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have very close mex we can build so will do that instead while waiting for enemy to get closer') end
                                            elseif AttackNearestEnemyWithACU(iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, oACU, 90)  then
                                                if bDebugMessages == true then LOG(sFunctionRef..': will attack nearest enemy and end early game order') end
                                                bAbortLogic = true
                                                oACU[refbDoingInitialBuildOrder] = false
                                            end
                                        end
                                    end
                                    if not(bAbortLogic) then
                                        local oUnitToAssist
                                        if aiBrain:GetEconomyStoredRatio('MASS') >= 0.9 and aiBrain:GetEconomyStored('MASS') >= 100 and tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim] >= 1000 and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoActiveUpgrades]) == false then
                                            local iHighestFractionComplete = -1
                                            local oUnitToAssist
                                            for iUpgrading, oUpgrading in  tLZOrWZTeamData[M28Map.subreftoActiveUpgrades] do
                                                if M28UnitInfo.IsUnitValid(oUpgrading) then
                                                    if oUpgrading:GetWorkProgress() < 1 and oUpgrading:GetWorkProgress() > iHighestFractionComplete then
                                                        iHighestFractionComplete = oUpgrading:GetWorkProgress()
                                                        oUnitToAssist = oUpgrading
                                                    end
                                                end
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': oUnitToAssist='..(oUnitToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitToAssist) or 'nil')) end
                                        if M28UnitInfo.IsUnitValid(oUnitToAssist) then
                                            M28Orders.IssueTrackedGuard(oACU, oUnitToAssist, false, 'ACUEGAssist', false)
                                        elseif M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false and tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] < iMexInLandZone and (not(M28Overseer.bNoRushActive) or not(M28Conditions.NoRushPreventingHydroOrMex(tLZOrWZData, true))) then
                                            --If we have 3+ mexes in the zone, and the unclaimed mex is further from the enemy base than we are notably, then dont build the mex and instead just end the build orde
                                            local bTryBuildingMex = true
                                            if tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] >= 3 and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] then
                                                bTryBuildingMex = false
                                                local iDistToEnemyBaseThreshold = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) + 20
                                                local iDistToACUOverrideThreshold = 15
                                                if tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] >= 4 then
                                                    iDistToACUOverrideThreshold = iDistToACUOverrideThreshold + 5
                                                    iDistToEnemyBaseThreshold = iDistToEnemyBaseThreshold - 5
                                                end
                                                for iMex, tMex in tLZOrWZData[M28Map.subrefMexUnbuiltLocations] do
                                                    if M28Utilities.GetDistanceBetweenPositions(tMex, oACU:GetPosition()) <= iDistToACUOverrideThreshold then
                                                        bTryBuildingMex = true
                                                        break --proceed with building mex as it is close to ACU
                                                    elseif M28Utilities.GetDistanceBetweenPositions(tMex, tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) <= iDistToEnemyBaseThreshold then
                                                        bTryBuildingMex = true
                                                        break
                                                    end
                                                end
                                            end
                                            if bTryBuildingMex then
                                                ACUActionBuildMex(aiBrain, oACU)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will try building more mexes') end
                                            else
                                                if bDebugMessages == true then LOG(sFunctionRef..': Building mex means we take a detour so leave it for engineers and end our initial build order') end
                                                oACU[refbDoingInitialBuildOrder] = false
                                            end
                                        else
                                            --Finish the initial BO
                                            oACU[refbDoingInitialBuildOrder] = false
                                            if bDebugMessages == true then LOG(sFunctionRef..': Finishing initial build order') end
                                        end
                                    end
                                end
                            end
                        else
                            --Have the power and factories that we want; if there are mexes in the zone and we have built fewer than 5 then build them; if not then finish initial build order
                            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false and tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] < math.min(5, tLZOrWZData[M28Map.subrefLZOrWZMexCount]) and (not(M28Overseer.bNoRushActive) or not(M28Conditions.NoRushPreventingHydroOrMex(tLZOrWZData, true))) then
                                ACUActionBuildMex(aiBrain, oACU)
                                if bDebugMessages == true then LOG(sFunctionRef..': Low factory BO Will try building more mexes') end
                            else
                                --Finish the initial BO
                                oACU[refbDoingInitialBuildOrder] = false
                                if bDebugMessages == true then LOG(sFunctionRef..': Low factory BO Finishing initial build order') end
                            end
                        end
                    end
                end
                --backup in case of unit restrictions (campaign) or e.g. far away mex that we dont want to build
                if bDebugMessages == true then LOG(sFunctionRef..': Campaign redundancy for if ACU has no order, reprs of last orders='..reprs(oACU[M28Orders.reftiLastOrders])..'; oACU[refbDoingInitialBuildOrder]='..tostring(oACU[refbDoingInitialBuildOrder])..'; M28Map.bIsCampaignMap='..tostring(M28Map.bIsCampaignMap)..'; Is table of last orders empty='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))) end
                if not(M28Conditions.DoesACUHaveValidOrder(oACU)) and oACU[refbDoingInitialBuildOrder] and (M28Orders.bDontConsiderCombinedArmy or oACU.M28Active) and (not(M28Map.bIsLowMexMap) or aiBrain:GetEconomyStoredRatio('MASS') >= 0.95) then
                    --Build mex if any available mex locations in zone
                    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false and (not(M28Overseer.bNoRushActive) or not(M28Conditions.NoRushPreventingHydroOrMex(tLZOrWZData, true))) then
                        ACUActionBuildMex(aiBrain, oACU)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Redundancy - Attempted to build mex if there were any unbuilt locations, IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]))..', is table of last orders empty='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))..'; DoesACUHaveValidOrder(oACU)='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))) end
                    if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then
                        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]) == false then ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData) end
                        if bDebugMessages == true then LOG(sFunctionRef..': Redundancy - Attempted to assist hydro, is table of last orders empty='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))..'; DoesACUHaveValidOrder(oACU)='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))) end
                        if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then
                            local iCurPower =  aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower) + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryHydro) * 5
                            if iCurPower <= 7 or (iCurPower <= 13 and aiBrain:GetEconomyStoredRatio('MASS') >= 0.25 and aiBrain:GetEconomyStoredRatio('ENERGY') <= 0.95) then
                                ACUActionBuildPower(aiBrain, oACU)
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Redundancy - Attempted to build power, is table of last orders empty='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))..'; DoesACUHaveValidOrder(oACU)='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))..'; Cur factory count='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory)) end
                            if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then

                                if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory) < 3 then
                                    if aiBrain:GetEconomyStoredRatio('MASS') >= 0.2 and aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.8 then
                                        ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryLandFactory, M28Engineer.refActionBuildLandFactory)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Redundancy - Attempted to build land factory, is table of last orders empty='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))..'; DoesACUHaveValidOrder(oACU)='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))) end
                                        if not(M28Conditions.DoesACUHaveValidOrder(oACU)) and (M28Orders.bDontConsiderCombinedArmy or oACU.M28Active) then
                                            ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryAirFactory, M28Engineer.refActionBuildAirFactory)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Redundancy - Attempted to build air factory, is table of last orders empty='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))..'; DoesACUHaveValidOrder(oACU)='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))) end
                                            if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then
                                                if iPlateauOrZero == 0 then
                                                    ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryNavalFactory, M28Engineer.refActionBuildNavalFactory)
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': Redundancy - Attempted to build naval factory if we are in water, iPlateauorZero='..iPlateauOrZero..'; is table of last orders empty='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))..'; DoesACUHaveValidOrder(oACU)='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))) end
                                                if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then
                                                    --Are we capable of building a naval factory yet?
                                                    --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition,               oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
                                                    local sNavalFacBP = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryNavalFactory, oACU)
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if it is possible for us to build a naval factory, sNavalFacBP='..(sNavalFacBP or 'nil')) end
                                                    if sNavalFacBP then

                                                        --Do we have an adjacent water zone? If so then move here as might be Aeon M1 where can only build naval fac)
                                                        if iPlateauOrZero > 0 and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]) == false then
                                                            MoveACUToNearbyWaterForFactory(aiBrain, oACU, tLZOrWZData)

                                                        else
                                                            M28Utilities.ErrorHandler('Unable to get any action for ACU owned by brain '..aiBrain.Nickname)
                                                        end
                                                    else
                                                        --Campaign specific - might have strange restrictions early game, so hide this message initially
                                                        if not(M28Map.bIsCampaignMap) or GetGameTimeSeconds() >= 300 then
                                                            M28Utilities.ErrorHandler('Unable to get early game action for ACU')
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            else
                --ACU is underwater so presumably water based start position

                if (iLZOrWZ or 0) == 0 then

                    --Go to the midpoint of the nearest zone that can find
                    --Move to midpoint
                    M28Orders.IssueTrackedMove(oACU, tLZOrWZData[M28Map.subrefMidpoint], 1, false, 'FindValidLoc', false)
                    M28Utilities.ErrorHandler('ACU showing as not being on a land zone, but doesnt have a water zone either, will try moving to midpoint of nearest land or water zone')
                else
                    oACU[refbStartedUnderwater] = true
                    --Are in a water zone - build a naval fac and build on any unbuilt mexes before marking initial BO as being  complete
                    local iCurNavalFactories = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalFactory)
                    if bDebugMessages == true then LOG(sFunctionRef..': iCurNavalFactories='..iCurNavalFactories..'; Is table of unbuilt mex locations empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]))..'; Gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; Gross energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; Is table of hydro locations empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]))) end
                    if iCurNavalFactories == 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want ACU to build land factory') end
                        ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryNavalFactory, M28Engineer.refActionBuildNavalFactory)
                    else
                        --Build mexes if nearby assuming we have nearby hydr; assist hydro if we have hydro
                        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false and (aiBrain[M28Economy.refiGrossMassBaseIncome] < 0.8 * iResourceMod or aiBrain[M28Economy.refiGrossEnergyBaseIncome] > 10 * iResourceMod) and (not(M28Overseer.bNoRushActive) or not(M28Conditions.NoRushPreventingHydroOrMex(tLZOrWZData, true))) then
                            if bDebugMessages == true then LOG(sFunctionRef..': We have unbuilt mexes in water zone and our income seems less than 4 mex equiv, so will build mexes') end
                            ACUActionBuildMex(aiBrain, oACU)
                        elseif M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]) == false and aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 10 * iResourceMod then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will try to assist a hydro nearby') end
                            ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData)
                        elseif M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false and (not(M28Overseer.bNoRushActive) or not(M28Conditions.NoRushPreventingHydroOrMex(tLZOrWZData, true))) then
                            ACUActionBuildMex(aiBrain, oACU)
                        else
                            oACU[refbDoingInitialBuildOrder] = false
                        end
                    end
                end

            end
        else
            --Rare case where ACU and engieners start building pgen at the same time, leading to them both building separately to each other; solution - if ACU fraction complete is <10%, switch to the engi built one if it is in the build range
            local oACUFocusUnit = oACU:GetFocusUnit()
            if bDebugMessages == true then LOG(sFunctionRef..': Are building so wont give any new orders subject to Pgen execption and reclaiming wreck mass exception. is oACUFocusUnit valid='..tostring(M28UnitInfo.IsUnitValid(oACUFocusUnit)))
                if M28UnitInfo.IsUnitValid(oACUFocusUnit) then LOG(sFunctionRef..': Focus unit='..oACUFocusUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACUFocusUnit)..'; Fraction complete='..oACUFocusUnit:GetFractionComplete()..'; ACU work progress='..oACU:GetWorkProgress()) end
            end
            --If about to overflow mass, dont have a valid unit being built, and we have at least 1 factory in the zone, then build power or do nothing
            if not(M28UnitInfo.IsUnitValid(oACUFocusUnit)) and aiBrain:GetEconomyStoredRatio('MASS') >= 0.95 and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false then
                --Are overflowing mass presumably from trying to build on a wreck - either build power or (if we have lots of power) clear orders
                if bDebugMessages == true then LOG(sFunctionRef..': Will try either clearing commands or building power') end
                if aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 80 then
                    M28Orders.IssueTrackedClearCommands(oACU)
                else
                    --Is there an under construction hydro in this zone? if so assist it, otherwise build a pgen
                    local bHaveUnderConstructionFirstHydro = false
                    local oOptionalUnderConstructionHydro
                    local tHydroInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryHydro, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tHydroInZone) == false then
                        for iHydro, oHydro in tHydroInZone do
                            if oHydro:GetFractionComplete() < 1 and oHydro:GetAIBrain() == aiBrain then
                                bHaveUnderConstructionFirstHydro = true
                                oOptionalUnderConstructionHydro = oHydro
                                break
                            end
                        end
                    end
                    if bHaveUnderConstructionFirstHydro then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to assist hydro') end
                        ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData, oOptionalUnderConstructionHydro)
                    else
                        ACUActionBuildPower(aiBrain, oACU)
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to build power') end
                    end
                end


            elseif EntityCategoryContains(M28UnitInfo.refCategoryPower * categories.TECH1, oACUFocusUnit.UnitId) and aiBrain:GetEconomyStored('ENERGY') < 1500 and oACUFocusUnit:GetFractionComplete() < 0.1 then
                local tNearbyPower = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryPower * categories.TECH1, oACU:GetPosition(), oACU:GetBlueprint().Economy.MaxBuildDistance + M28UnitInfo.GetBuildingSize(oACUFocusUnit.UnitId), 'Ally')
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby power empty='..tostring(M28Utilities.IsTableEmpty(tNearbyPower))) end
                if M28Utilities.IsTableEmpty(tNearbyPower) == false and table.getn(tNearbyPower) >= 2 then
                    local tEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    local tPowerBuiltByEngineers = {}
                    local oCurFocusUnit
                    if M28Utilities.IsTableEmpty(tEngineers) == false then
                        for iEngineer, oEngineer in tEngineers do
                            if M28UnitInfo.IsUnitValid(oEngineer) and oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionBuildPower then
                                oCurFocusUnit = oEngineer:GetFocusUnit()
                                if EntityCategoryContains(M28UnitInfo.refCategoryPower * categories.TECH1, oCurFocusUnit.UnitId) then
                                    table.insert(tPowerBuiltByEngineers, oCurFocusUnit)
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': is table of power built by engineers empty='..tostring(M28Utilities.IsTableEmpty(tPowerBuiltByEngineers))) end
                    if M28Utilities.IsTableEmpty(tPowerBuiltByEngineers) == false then
                        --Do we have any engineers building the ACU focus unit?
                        local bEngineersBuildingACUPower = false
                        for iUnit, oUnit in tPowerBuiltByEngineers do
                            if oUnit == oACUFocusUnit then bEngineersBuildingACUPower = true break end
                        end
                        if not(bEngineersBuildingACUPower) then
                            local bHaveEngineersBuildingThisPower
                            local iMostCompletePower = 0
                            local oPowerToSwitchTo
                            for iUnit, oUnit in tNearbyPower do
                                if not(oUnit == oACUFocusUnit) then
                                    --Do we have engineers building this power?
                                    bHaveEngineersBuildingThisPower = false
                                    for iPower, oPower in tPowerBuiltByEngineers do
                                        if oPower == oUnit then
                                            bHaveEngineersBuildingThisPower = true
                                            break
                                        end
                                    end
                                    if bHaveEngineersBuildingThisPower then
                                        if oUnit:GetFractionComplete() > iMostCompletePower then
                                            iMostCompletePower = oUnit:GetFractionComplete()
                                            oPowerToSwitchTo = oUnit
                                        end
                                    end
                                end
                            end
                            if oPowerToSwitchTo then
                                M28Orders.IssueTrackedRepair(oACU, oPowerToSwitchTo, false, 'EGPwrR', false)
                            end
                        end
                    end
                end
                --Hydro and power-stalling and tree reclaim within build area - reclaim trees
            elseif aiBrain:GetEconomyStored('ENERGY') <= 30 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 10 then
                local iReclaimSegmentX, iReclaimSegmentZ = M28Map.GetReclaimSegmentsFromLocation(oACU:GetPosition())
                if bDebugMessages == true then LOG(sFunctionRef..': Are power stalling, will see if energy reclaim nearby, energy in segment are in='..(M28Map.tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][M28Map.refSegmentReclaimTotalEnergy] or 'nil')) end
                if (M28Map.tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][M28Map.refSegmentReclaimTotalEnergy] or 0) > 10 then
                    local iBuildRange = oACU:GetBlueprint().Economy.MaxBuildDistance
                    local rNearbyRect = M28Utilities.GetRectAroundLocation(oACU:GetPosition(), iBuildRange)
                    local tReclaimables = M28Map.GetReclaimInRectangle(4, rNearbyRect, false)
                    if M28Utilities.IsTableEmpty(tReclaimables) == false then
                        local tWrecksToReclaim = {}
                        for iWreck, oWreck in tReclaimables do
                            if (oWreck.MaxEnergyReclaim or 0) >= 10 and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oWreck.CachePosition) <= iBuildRange then
                                table.insert(tWrecksToReclaim, oWreck)
                            end
                        end
                        if M28Utilities.IsTableEmpty(tWrecksToReclaim) == false then
                            M28Orders.IssueTrackedClearCommands(oACU)
                            for iWreck, oWreck in tWrecksToReclaim do
                                M28Orders.IssueTrackedReclaim(oACU, oWreck, true, 'ACUTree', false)
                            end
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, is ACU table of last orders empty='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))..'; Does ACU have valid order='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RemovePreferredUpgradesThatWeAlreadyHave(oACU, oBP)
    local sFunctionRef = 'RemovePreferredUpgradesThatWeAlreadyHave'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) == false and oACU.HasEnhancement then
        local tObsoletePreRequisites = {}
        local bCheckForObsoletePrerequisites
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Considering upgrades already have for oACU ' .. oACU.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oACU) .. ' owned by ' .. oACU:GetAIBrain().Nickname .. '; Upgrade count=' .. (oACU[refiUpgradeCount] or 'nil'))
        end
        if (oACU[refiUpgradeCount] or 0) > 0 then
            for iEntry, sEnhancement in oACU[reftPreferredUpgrades] do
                if oBP.Enhancements[sEnhancement].Prerequisite and oACU:HasEnhancement(sEnhancement) then
                    table.insert(tObsoletePreRequisites, oBP.Enhancements[sEnhancement].Prerequisite)
                    bCheckForObsoletePrerequisites = true
                    --Check for double-prerequisite
                    if oBP.Enhancements[oBP.Enhancements[sEnhancement].Prerequisite].Prerequisite then
                        table.insert(tObsoletePreRequisites, oBP.Enhancements[oBP.Enhancements[sEnhancement].Prerequisite].Prerequisite)
                    end
                end
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Considering if sEnhancement ' .. sEnhancement .. ' has prerequisite, BP Preq val=' .. (oBP.Enhancements[sEnhancement].Prerequisite or 'nil')..'; bCheckForObsoletePrerequisites='..tostring(bCheckForObsoletePrerequisites)..'; tObsoletePreRequisites='..repru(tObsoletePreRequisites))
                end
            end
        end
        local bUpgradeIsObsolete

        local iRevisedIndex = 0
        local iTableSize = table.getn(oACU[reftPreferredUpgrades])

        --First check if we have any upgrades that have prerequiites, in which case we want to remove those prerequisites first
        for iOrigIndex = 1, iTableSize do
            if oACU[reftPreferredUpgrades][iOrigIndex] then
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if the upgrade index '..iOrigIndex..' which is '..repru(oACU[reftPreferredUpgrades][iOrigIndex])..' is obsolete; Does ACU have this enhancement='..tostring(oACU:HasEnhancement(oACU[reftPreferredUpgrades][iOrigIndex]))..'; bCheckForObsoletePrerequisites='..tostring(bCheckForObsoletePrerequisites)..'; oACU[M28UnitInfo.reftiTimeOfLastEnhancementComplete]='..repru((oACU[M28UnitInfo.reftiTimeOfLastEnhancementComplete] or 'nil'))..'; oACU[M28UnitInfo.reftiTimeOfLastEnhancementComplete][oACU[reftPreferredUpgrades[iOrigIndex]]]='..(oACU[M28UnitInfo.reftiTimeOfLastEnhancementComplete][oACU[reftPreferredUpgrades[iOrigIndex]]] or 'nil')..'; Time='..GetGameTimeSeconds()) end
                if not (oACU:HasEnhancement(oACU[reftPreferredUpgrades][iOrigIndex])) and (not (oACU[M28UnitInfo.reftiTimeOfLastEnhancementComplete][oACU[reftPreferredUpgrades[iOrigIndex]]]) or GetGameTimeSeconds() - (oACU[M28UnitInfo.reftiTimeOfLastEnhancementComplete][oACU[reftPreferredUpgrades[iOrigIndex]]] or -1) >= 0.5) then
                    --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                    --We dont have this enhancement; however we might have one that supercedes this, in which case also want to remove it
                    bUpgradeIsObsolete = false
                    if bCheckForObsoletePrerequisites then
                        for iEntry, sPreRequisite in tObsoletePreRequisites do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering sPreRequisite='..sPreRequisite..'; If this equals this upgrade then will mark it as obsolete') end
                            if sPreRequisite == oACU[reftPreferredUpgrades][iOrigIndex] then
                                bUpgradeIsObsolete = true
                                break
                            end
                        end
                    end
                    if bUpgradeIsObsolete then
                        if bDebugMessages == true then LOG(sFunctionRef..': Upgrade is obsolete so will clear '..oACU[reftPreferredUpgrades][iOrigIndex]..'; iOrigIndex='..iOrigIndex..'; iRevisedIndex='..iRevisedIndex) end
                        oACU[reftPreferredUpgrades][iOrigIndex] = nil;
                    else

                        --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                        iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                        if (iOrigIndex ~= iRevisedIndex) then
                            if bDebugMessages == true then LOG(sFunctionRef..': setting iRevisedIndex '..iRevisedIndex..' to equal '..oACU[reftPreferredUpgrades][iOrigIndex]) end
                            oACU[reftPreferredUpgrades][iRevisedIndex] = oACU[reftPreferredUpgrades][iOrigIndex];
                            oACU[reftPreferredUpgrades][iOrigIndex] = nil;
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': We dont have this upgrade yet so will retain it') end
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Clearing the upgrade '..oACU[reftPreferredUpgrades][iOrigIndex]) end
                    oACU[reftPreferredUpgrades][iOrigIndex] = nil;
                end
            end
        end
        iTableSize = table.getn(oACU[reftPreferredUpgrades])
        if bDebugMessages == true then LOG(sFunctionRef..': End of removal, iRevisedIndex='..iRevisedIndex..'; iTableSize='..iTableSize..'; repru='..repru(oACU[reftPreferredUpgrades])..'; Entry 1 of table='..(oACU[reftPreferredUpgrades][1] or 'nil')) end
        if iRevisedIndex < iTableSize then
            if iRevisedIndex == 0 then oACU[reftPreferredUpgrades] = {}
            elseif iRevisedIndex == 1 then
                --redundancy (had issue where doing table.remove results in the last entry with a value being removed, i think it was due to separate error with not refreshing iTableSize, but adding this to be safe)
                oACU[reftPreferredUpgrades] = {[1] = oACU[reftPreferredUpgrades][1]}
            else
                --table.setn(oACU[reftPreferredUpgrades], iRevisedIndex - 1)
                for iRemovalEntry = iTableSize, (iRevisedIndex + 1), -1 do
                    if bDebugMessages == true then LOG(sFunctionRef..': About to remove entry '..(iRemovalEntry or 'nil')..' with value='..(oACU[reftPreferredUpgrades][iRemovalEntry] or 'nil')) end
                    table.remove(oACU[reftPreferredUpgrades], iRemovalEntry)
                    if bDebugMessages == true then LOG(sFunctionRef..': repr of table after removal='..repru(oACU[reftPreferredUpgrades])) end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetUpgradePathForACU(oACU, bWantToDoTeleSnipe)
    --Records the order of upgrades we will want for the ACU
    local sFunctionRef = 'GetUpgradePathForACU'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local aiBrain = oACU:GetAIBrain()

    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; oACU='..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' owned by brain '..aiBrain.Nickname..'; oACU[refbStartedUnderwater]='..tostring(oACU[refbStartedUnderwater] or false)..'; oACU[refiUpgradeCount='..oACU[refiUpgradeCount]..'; aiBrain[M28Economy.refiGrossEnergyBaseIncome]='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; aiBrain[M28Economy.refiGrossMassBaseIncome]='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; Is aeon or cybran='..tostring(EntityCategoryContains(categories.AEON + categories.CYBRAN, oACU.UnitId))..'; aiBrain[M28Economy.refiBrainResourceMultiplier]='..aiBrain[M28Economy.refiBrainResourceMultiplier]..'; bWantToDoTeleSnipe='..tostring(bWantToDoTeleSnipe or false)..'; oACU[refbPlanningToGetTeleport]='..tostring(oACU[refbPlanningToGetTeleport] or false)..'; aiBrain[refbPlanningToGetShield]='..tostring(aiBrain[refbPlanningToGetShield] or false)) end
    local oBP = oACU:GetBlueprint()

    oACU[refiTimeLastConsideredUpgradePath] = GetGameTimeSeconds()
    if (bWantToDoTeleSnipe or (oACU[refbPlanningToGetTeleport] and (oACU:HasEnhancement('MicrowaveLaserGenerator') or oACU:HasEnhancement('Teleporter') or oACU:HasEnhancement('BlastAttack')))) and oBP.Enhancements['Teleporter'] then
        if EntityCategoryContains(categories.CYBRAN, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'CoolingUpgrade', 'MicrowaveLaserGenerator', 'Teleporter'}
        elseif EntityCategoryContains(categories.SERAPHIM, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'RateOfFire', 'BlastAttack', 'Teleporter'}
        else M28Utilities.ErrorHandler('Trying to do telesnipe without a cybran or seraphim ACU')
        end
        --Unusually cheap upgrades - get the best possible ones available
    elseif oBP.Enhancements.AdvancedEngineering.BuildCostMass <= 10 and oBP.Enhancements.ResourceAllocation.BuildCostMass <= 10 then
        if EntityCategoryContains(categories.UEF, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'T3Engineering', 'ResourceAllocation', 'Shield'}
        elseif EntityCategoryContains(categories.AEON, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'T3Engineering', 'ResourceAllocation', 'ResourceAllocationAdvanced', 'HeatSink'}
        elseif EntityCategoryContains(categories.CYBRAN, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'T3Engineering', 'ResourceAllocation'}
            --Mod that makes upgrades cost nothing
            if (oBP.Enhancements['MicrowaveLaserGenerator'].BuildCostMass or 10000) <= 1000 then
                table.insert(oACU[reftPreferredUpgrades], 'MicrowaveLaserGenerator')
                if (oBP.Enhancements['MicrowaveLaserGenerator'].BuildCostMass or 10000) <= 100 and oBP.Enhancements['T3Engineering'].BuildCostMass <= 100 then
                    if GetGameTimeSeconds() <= 120 or (aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= 500 and M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossEnergy] <= 750 and oACU:HasEnhancement('ResourceAllocationAdvanced')) then
                        oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'T3Engineering', 'ResourceAllocation', 'MicrowaveLaserGenerator'}
                    elseif GetGameTimeSeconds() <= 900 and M28Team.tTeamData[aiBrain.M28Team][M28Team.refiConstructedExperimentalCount] == 0 and not(M28Team.tTeamData[aiBrain.M28Team][M28Team.refbAssassinationOrSimilar]) and M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossEnergy] >= 750 and oBP.Enhancements['FAF_SelfRepairSystem'] then
                        oACU[reftPreferredUpgrades] = {'CoolingUpgrade', 'StealthGenerator', 'FAF_SelfRepairSystem', 'MicrowaveLaserGenerator', 'CloakingGenerator'}
                    else
                        oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'T3Engineering', 'ResourceAllocation', 'MicrowaveLaserGenerator'}
                    end
                end
            end
        elseif EntityCategoryContains(categories.SERAPHIM, oACU.UnitId) then
            --Mod that makes upgrades cost nothing
            if (oBP.Enhancements['BlastAttack'].BuildCostMass or 10000) <= 100 and oBP.Enhancements['T3Engineering'].BuildCostMass <= 100 then
                --Cant have T3 and splash, so want to adjust depending on what stage of the game we are at
                if GetGameTimeSeconds() <= 120 or (aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= 500 and M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossEnergy] <= 750 and oACU:HasEnhancement('ResourceAllocationAdvanced')) then
                    oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'T3Engineering','ResourceAllocation', 'ResourceAllocationAdvanced', 'DamageStabilization', 'DamageStabilizationAdvanced'}
                elseif GetGameTimeSeconds() <= 900 and M28Team.tTeamData[aiBrain.M28Team][M28Team.refiConstructedExperimentalCount] == 0 and not(M28Team.tTeamData[aiBrain.M28Team][M28Team.refbAssassinationOrSimilar]) then
                    --Wnat to use ACU more aggressively so get splash and gun (range+ROF) instead of RAS
                    oACU[reftPreferredUpgrades] = {'RateOfFire', 'BlastAttack', 'DamageStabilization', 'DamageStabilizationAdvanced'}
                else
                    oACU[reftPreferredUpgrades] = {'ResourceAllocation', 'ResourceAllocationAdvanced', 'BlastAttack', 'DamageStabilization', 'DamageStabilizationAdvanced'}
                end
            else
                oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'T3Engineering', 'ResourceAllocation', 'ResourceAllocationAdvanced', 'DamageStabilization', 'DamageStabilizationAdvanced'}
            end
        end
        --oACU[refiUpgradeCount] == 0 and (oBP.Enhancements.ResourceAllocation.BuildCostMass or 10000) <= 100 and GetGameTimeSeconds() <= 60 and not(oACU[reftPreferredUpgrades][1] == 'ResourceAllocation') then
    elseif aiBrain[M28Economy.refiBrainResourceMultiplier] >= 1.7 and (M28Map.iMapSize >= 1000 or aiBrain[M28Economy.refiBrainResourceMultiplier] >= 4.0) then
        if EntityCategoryContains(categories.UEF, oACU.UnitId) then
            if M28Team.tTeamData[aiBrain.M28Team][M28Team.refbAssassinationOrSimilar] then
                oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'Shield', 'T3Engineering', 'ResourceAllocation'}
            else
                oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'T3Engineering', 'ResourceAllocation', 'Shield'}
            end
        elseif EntityCategoryContains(categories.AEON, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'T3Engineering', 'ResourceAllocation', 'ResourceAllocationAdvanced'}
        elseif EntityCategoryContains(categories.CYBRAN, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'T3Engineering', 'ResourceAllocation'}
            --Mod that makes upgrades cost nothing
            if (oBP.Enhancements['MicrowaveLaserGenerator'].BuildCostMass or 10000) <= 1000 then table.insert(oACU[reftPreferredUpgrades], 'MicrowaveLaserGenerator') end
        elseif EntityCategoryContains(categories.SERAPHIM, oACU.UnitId) then
            --Mod that makes upgrades cost nothing
            if (oBP.Enhancements['BlastAttack'].BuildCostMass or 10000) <= 1000 then
                oACU[reftPreferredUpgrades] = {'BlastAttack', 'DamageStabilization', 'ResourceAllocation', 'ResourceAllocationAdvanced', 'DamageStabilizationAdvanced'}
            elseif M28Team.tTeamData[aiBrain.M28Team][M28Team.refbAssassinationOrSimilar] then
                oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'DamageStabilization', 'T3Engineering', 'ResourceAllocation', 'ResourceAllocationAdvanced', 'DamageStabilizationAdvanced'}
            else
                oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'T3Engineering', 'ResourceAllocation', 'ResourceAllocationAdvanced', 'DamageStabilization', 'DamageStabilizationAdvanced'}
            end
        end
    elseif oACU[refbStartedUnderwater] then
        if EntityCategoryContains(categories.UEF, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'ResourceAllocation', 'Shield'}
        elseif EntityCategoryContains(categories.AEON, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'ResourceAllocation', 'ResourceAllocationAdvanced'}
        elseif EntityCategoryContains(categories.CYBRAN, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'NaniteTorpedoTube', 'StealthGenerator'}
        elseif EntityCategoryContains(categories.SERAPHIM, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'ResourceAllocation', 'ResourceAllocationAdvanced'}
        end
        --Cybran ACU on naval map where enemy isnt at T3 yet
    elseif oACU.UnitId == 'url0001' and not(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) and aiBrain[M28Map.refbCanPathToEnemyBaseWithAmphibious] and M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyNavalFactoryTech] < 3 and M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestEnemyNavyTech] < 3 then
        --Cybran - get torpedo upgrade
        oACU[reftPreferredUpgrades] = {'NaniteTorpedoTube', 'StealthGenerator'}
        if oBP.Enhancements['SelfRepairSystem'] then table.insert( oACU[reftPreferredUpgrades], 'SelfRepairSystem') end
        if oBP.Enhancements['FAF_SelfRepairSystem'] then table.insert( oACU[reftPreferredUpgrades], 'FAF_SelfRepairSystem') end
        if bDebugMessages == true then LOG(sFunctionRef..': Want to use acu torpedo attack') end
        --ACUs that have to choose between RAS and defensive upgrades - at high eco levels switch from getting RAS to getting defensive upgrade
        --UEF can get shield+RAS
        --Sera can get nano+RAS
        --Aeon and Cybran have to choose
    elseif oACU[refiUpgradeCount] >= 2 and (aiBrain[M28Economy.refbBuiltParagon] or (aiBrain[M28Economy.refiGrossMassBaseIncome] >= 100 * aiBrain[M28Economy.refiBrainResourceMultiplier] and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 2500) or aiBrain[refbPlanningToGetShield]) and EntityCategoryContains(categories.AEON + categories.CYBRAN, oACU.UnitId) then
        if not(oACU[refbPlanningToGetShield]) then oACU[refbPlanningToGetShield] = true end
        if bDebugMessages == true then LOG(sFunctionRef..': Recording that ACU wants to get shield type upgrades') end
        if EntityCategoryContains(categories.AEON, oACU.UnitId) then
            --Mod that makes all upgrades super cheap
            if (oBP.Enhancements['ResourceAllocation'].BuildCostMass or 10000) <= 100 then
                oACU[reftPreferredUpgrades] = {'ResourceAllocation', 'AdvancedEngineering', 'ResourceAllocationAdvanced', 'T3Engineering', 'HeatSink'}
                if bDebugMessages == true then LOG(sFunctionRef..': Going with eco build due to cheap RAS') end
            else
                oACU[reftPreferredUpgrades] = {'CrysalisBeam', 'HeatSink', 'Shield', 'ShieldHeavy'}
            end
        elseif EntityCategoryContains(categories.CYBRAN, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'CoolingUpgrade', 'StealthGenerator'}
            if oBP.Enhancements['SelfRepairSystem'] then table.insert( oACU[reftPreferredUpgrades], 'SelfRepairSystem') end
            if oBP.Enhancements['FAF_SelfRepairSystem'] then table.insert( oACU[reftPreferredUpgrades], 'FAF_SelfRepairSystem') end
            --Mod that makes upgrades cost nothing
            if (oBP.Enhancements['MicrowaveLaserGenerator'].BuildCostMass or 10000) <= 1000 then table.insert(oACU[reftPreferredUpgrades], 'MicrowaveLaserGenerator') end
            table.insert(oACU[reftPreferredUpgrades], 'CloakingGenerator')
        else M28Utilities.ErrorHandler('Unrecognised ACU category')
        end
    elseif M28Team.iPlayersAtGameStart > 4 and M28Map.iMapSize >= 512 and (M28Team.iPlayersAtGameStart >= 8 or M28Map.iMapSize >= 768) then
        if EntityCategoryContains(categories.UEF, oACU.UnitId) then
            if oACU[refiUpgradeCount] >= 2 then
                if oACU[refiUpgradeCount] >= 3 and M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) == false then
                    --Do nothing - have already decided what upgrade path to go down
                else
                    if oACU[refbPlanningToGetShield] == nil then
                        if M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.85 then
                            oACU[refbPlanningToGetShield] = true
                        end
                    elseif M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.6 then
                        oACU[refbPlanningToGetShield] = true
                    end
                    --Also get shield if a good chance we will use ACU in combat for a while
                    if oACU[refbPlanningToGetShield] or M28Conditions.ACULikelyToWantCombatUpgradeOrShield(oACU) or M28Team.tTeamData[aiBrain.M28Team][M28Team.refbAssassinationOrSimilar] then
                        oACU[reftPreferredUpgrades] = {'Shield', 'ResourceAllocation'}
                    else
                        oACU[reftPreferredUpgrades] = {'ResourceAllocation', 'Shield'}
                    end
                end
            else
                local bWantNanoNotT2 = true
                if M28Map.iMapSize >= 1000 or (M28Map.iMapSize >= 768 and M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiActiveM28BrainCount] >= 4) then bWantNanoNotT2 = false end
                if bWantNanoNotT2 then
                    if oACU[refiUpgradeCount] >= 1 then
                        if M28Team.tTeamData[aiBrain.M28Team][M28Team.refbAssassinationOrSimilar] then
                            oACU[reftPreferredUpgrades] = {'DamageStabilization', 'Shield', 'ResourceAllocation'}
                        else
                            oACU[reftPreferredUpgrades] = {'DamageStabilization', 'ResourceAllocation', 'Shield'}
                        end
                    else
                        oACU[reftPreferredUpgrades] = {'HeavyAntiMatterCannon', 'DamageStabilization'}
                    end
                else
                    if oACU[refiUpgradeCount] >= 1 then
                        if M28Team.tTeamData[aiBrain.M28Team][M28Team.refbAssassinationOrSimilar] then
                            oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'Shield', 'ResourceAllocation'}
                        else
                            oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'ResourceAllocation', 'Shield'}
                        end
                    else
                        oACU[reftPreferredUpgrades] = {'HeavyAntiMatterCannon', 'AdvancedEngineering'}
                    end
                end
            end
        elseif EntityCategoryContains(categories.AEON, oACU.UnitId) then
            if (oBP.Enhancements['ResourceAllocation'].BuildCostMass or 10000) <= 100 then
                oACU[reftPreferredUpgrades] = {'ResourceAllocation', 'AdvancedEngineering', 'ResourceAllocationAdvanced', 'T3Engineering', 'HeatSink'}
                if bDebugMessages == true then LOG(sFunctionRef..': Going with eco build due to cheap RAS2') end
            elseif oACU[refiUpgradeCount] >= 3 then
                if oACU[refiUpgradeCount] >= 4 and M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) == false then
                    --Do nothing - already determined upgrade path
                else
                    if oACU[refbPlanningToGetShield] == nil then
                        if M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.8 then
                            oACU[refbPlanningToGetShield] = true
                        end
                    elseif M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.5 then
                        oACU[refbPlanningToGetShield] = true
                    end

                    --Also get shield if a good chance we will use ACU in combat for a while
                    if oACU[refbPlanningToGetShield] or M28Conditions.ACULikelyToWantCombatUpgradeOrShield(oACU) or oACU:HasEnhancement('Shield') or oACU:HasEnhancement('ShieldHeavy') then
                        oACU[reftPreferredUpgrades] = {'CrysalisBeam', 'HeatSink', 'Shield', 'ShieldHeavy'}
                    else
                        oACU[reftPreferredUpgrades] = {'CrysalisBeam', 'HeatSink', 'ResourceAllocation', 'ResourceAllocationAdvanced'}
                    end
                end
            else
                if oACU[refbPlanningToGetShield] == nil then
                    if M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.8 then
                        oACU[refbPlanningToGetShield] = true
                    end
                elseif M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.5 then
                    oACU[refbPlanningToGetShield] = true
                end
                if oACU[refbPlanningToGetShield] or M28Conditions.ACULikelyToWantCombatUpgradeOrShield(oACU) or oACU:HasEnhancement('Shield') or oACU:HasEnhancement('ShieldHeavy') then
                    oACU[reftPreferredUpgrades] = {'CrysalisBeam', 'HeatSink', 'Shield', 'ShieldHeavy'}
                else
                    oACU[reftPreferredUpgrades] = {'CrysalisBeam', 'HeatSink', 'ResourceAllocation', 'ResourceAllocationAdvanced'}
                end
            end
            if oBP.Enhancements['FAF_CrysalisBeamAdvanced'] then
                local iCurEntries = table.getn(oACU[reftPreferredUpgrades])
                local bHaveAdvancedRange = false
                for iEntry, sEntry in oACU[reftPreferredUpgrades] do
                    if sEntry == 'FAF_CrysalisBeamAdvanced' then
                        bHaveAdvancedRange = true
                        break
                    end
                end
                if not(bHaveAdvancedRange) then
                    --Do we either have the CrysalisBeam upgrade, or is it in preferred upgrades?
                    local bHaveInitialRange = false
                    if oACU:HasEnhancement('CrysalisBeam') then bHaveInitialRange = true
                    else
                        for iEntry, sEntry in oACU[reftPreferredUpgrades] do
                            if sEntry == 'CrysalisBeam' then
                                bHaveInitialRange = true
                                break
                            elseif iEntry >4 then break
                            end
                        end
                    end
                    if bHaveInitialRange then
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding in FAF_CrysalisBeamAdvanced to enhancements wanted') end
                        local iEntryWanted = 4
                        if oACU[reftPreferredUpgrades][3] == 'ResourceAllocation' then iEntryWanted = 3 end
                        if iCurEntries >= iEntryWanted and  not(oACU[reftPreferredUpgrades][iEntryWanted] == 'FAF_CrysalisBeamAdvanced') then table.insert( oACU[reftPreferredUpgrades], iEntryWanted, 'FAF_CrysalisBeamAdvanced')
                        else table.insert(oACU[reftPreferredUpgrades], 'FAF_CrysalisBeamAdvanced')
                        end
                    end
                end
            end
        elseif EntityCategoryContains(categories.CYBRAN, oACU.UnitId) then
            --Mod that makes upgrades cost nothing
            if (oBP.Enhancements['MicrowaveLaserGenerator'].BuildCostMass or 10000) <= 1000 and oBP.Enhancements['ResourceAllocation'].BuildCostMass <= 1000 then
                oACU[reftPreferredUpgrades] = {'CoolingUpgrade', 'ResourceAllocation', 'MicrowaveLaserGenerator'}
            elseif oACU[refiUpgradeCount] >= 1 then
                if oACU[refiUpgradeCount] >= 3 and M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) == false then
                    --Do nothing - already determined upgrade path
                    if bDebugMessages == true then LOG(sFunctionRef..': Already determiend upgrade path as have 3+ upgrades') end
                else
                    if oACU[refbPlanningToGetShield] == nil then
                        if M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.6 then
                            if bDebugMessages == true then LOG(sFunctionRef..': ACU low enough health that we want to get a shield') end
                            oACU[refbPlanningToGetShield] = true
                        end
                    elseif not(oACU[refbPlanningToGetShield]) and M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.3 then
                        oACU[refbPlanningToGetShield] = true
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': oACU[refbPlanningToGetShield]='..tostring(oACU[refbPlanningToGetShield])) end
                    if oACU[refbPlanningToGetShield] or M28Conditions.ACULikelyToWantCombatUpgradeOrShield(oACU) or oACU:HasEnhancement('SelfRepairSystem') then
                        oACU[reftPreferredUpgrades] = {'StealthGenerator'}
                        if oBP.Enhancements['SelfRepairSystem'] then table.insert( oACU[reftPreferredUpgrades], 'SelfRepairSystem') end
                        if oBP.Enhancements['FAF_SelfRepairSystem'] then table.insert( oACU[reftPreferredUpgrades], 'FAF_SelfRepairSystem') end
                        if bDebugMessages == true then LOG(sFunctionRef..': Want stealth and nano for ACU') end
                        if M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyNovaxCount] >= 2 then table.insert(oACU[reftPreferredUpgrades], 'CloakingGenerator') end
                    else
                        oACU[reftPreferredUpgrades] = {'ResourceAllocation'}
                        if bDebugMessages == true then LOG(sFunctionRef..': Want RAS for ACU') end
                    end
                end
            else
                oACU[reftPreferredUpgrades] = {'CoolingUpgrade', 'ResourceAllocation'}
                if bDebugMessages == true then LOG(sFunctionRef..': Will start with default being gun and RAS') end
            end
        elseif EntityCategoryContains(categories.SERAPHIM, oACU.UnitId) then
            if (oBP.Enhancements['BlastAttack'].BuildCostMass or 10000) <= 1000 then
                oACU[reftPreferredUpgrades] = {'BlastAttack', 'DamageStabilization', 'ResourceAllocation', 'ResourceAllocationAdvanced', 'DamageStabilizationAdvanced'}
            elseif oACU[refiUpgradeCount] >= 2 then
                if oACU[refiUpgradeCount] >= 3 and M28Utilities.IsTableEmpty( oACU[reftPreferredUpgrades]) == false then
                    --Do nothing - already determined which path to go down
                else
                    if oACU[refbPlanningToGetShield] == nil then
                        if M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.6 then
                            oACU[refbPlanningToGetShield] = true
                        end
                    elseif M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.4 then
                        oACU[refbPlanningToGetShield] = true
                    end
                    if oACU[refbPlanningToGetShield] or M28Conditions.ACULikelyToWantCombatUpgradeOrShield(oACU) or M28Team.tTeamData[aiBrain.M28Team][M28Team.refbAssassinationOrSimilar] then
                        oACU[reftPreferredUpgrades] = {'DamageStabilization', 'ResourceAllocation', 'DamageStabilizationAdvanced', 'ResourceAllocationAdvanced'}
                    else
                        oACU[reftPreferredUpgrades] = {'ResourceAllocation', 'ResourceAllocationAdvanced', 'DamageStabilization'}
                    end
                end
            else
                oACU[reftPreferredUpgrades] = {'RateOfFire', 'AdvancedEngineering', 'ResourceAllocation', 'ResourceAllocationAdvanced', 'DamageStabilization'}
            end
        end
    else
        if EntityCategoryContains(categories.UEF, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'HeavyAntiMatterCannon', 'DamageStabilization', 'Shield'}
        elseif EntityCategoryContains(categories.AEON, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'CrysalisBeam', 'HeatSink', 'Shield'}
            if oBP.Enhancements['FAF_CrysalisBeamAdvanced'] then table.insert( oACU[reftPreferredUpgrades], 'FAF_CrysalisBeamAdvanced') end --get shield before advanced range for survivability
            if bDebugMessages == true then LOG(sFunctionRef..': Standard Aeon, with FAF_CrysalisBeamAdvanced added if relevant') end
        elseif EntityCategoryContains(categories.CYBRAN, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'CoolingUpgrade', 'StealthGenerator'}
            --FAF balance patch expected 15th July 2023 to introduce nano upgrade for Cybran
            if oBP.Enhancements['SelfRepairSystem'] then table.insert( oACU[reftPreferredUpgrades],'SelfRepairSystem') end
        elseif EntityCategoryContains(categories.SERAPHIM, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'RateOfFire', 'AdvancedEngineering', 'DamageStabilization'}
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': oACU[reftPreferredUpgrades] before refining to exclude invalid ones='..repru(oACU[reftPreferredUpgrades])) end

    --Check all of these are options (in case a mod has changed them)
    local tRestrictedEnhancements = import("/lua/enhancementcommon.lua").GetRestricted()
    local bCheckForRestrictions = not (M28Utilities.IsTableEmpty(tRestrictedEnhancements))
    local bInvalidUpgrade

    if M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) == false then
    local tiEntriesToRemove = {}
    if bDebugMessages == true then LOG(sFunctionRef..': oACU[reftPreferredUpgrades] before removing invalid entries='..repru(oACU[reftPreferredUpgrades])) end
    for iUpgradeWanted, sUpgradeWanted in oACU[reftPreferredUpgrades] do
        bInvalidUpgrade = false
        if M28Utilities.IsTableEmpty(oBP.Enhancements[sUpgradeWanted]) then
        bInvalidUpgrade = true
        oACU[reftPreferredUpgrades] = {}
        if bDebugMessages == true then LOG(sFunctionRef..': ACU doesnt have sUpgradeWanted='..sUpgradeWanted..' in its blueprint so aborting') end
        break
        elseif bCheckForRestrictions then
        --If we cant get the first upgrade, then cancel all upgrades; otherwise just remove the later upgrade that we cant get
        if tRestrictedEnhancements[sUpgradeWanted] then
        if bDebugMessages == true then LOG(sFunctionRef..': sUpgradeWanted '..sUpgradeWanted..' is in the restricted enhancements table so cant get it yet') end
        bInvalidUpgrade = true
        end
        end
        if bInvalidUpgrade then
        if bDebugMessages == true then LOG(sFunctionRef..': Considering restricted upgrade='..sUpgradeWanted..'; iUpgradeWanted='..iUpgradeWanted) end
    if iUpgradeWanted <= 1 then
    if bDebugMessages == true then LOG(sFunctionRef..': We cant get the first planned upgrade so wont get any further upgrades') end
    oACU[reftPreferredUpgrades] = {}
    break
    else
    table.insert(tiEntriesToRemove, iUpgradeWanted)
    end
    end
    end
    if M28Utilities.IsTableEmpty(tiEntriesToRemove) == false then
    local iTotalEntriesToRemove = table.getn(tiEntriesToRemove)
    for iCurEntry = iTotalEntriesToRemove, 1, -1 do
    if bDebugMessages == true then LOG(sFunctionRef..': Removing iCurEntry='..iCurEntry..' from preferred upgrades, Upgrade='..(oACU[reftPreferredUpgrades][iCurEntry] or 'nil')) end
        table.remove(oACU[reftPreferredUpgrades], tiEntriesToRemove[iCurEntry])
        end
        end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of preferred upgrades empty='..tostring(M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]))..'; repru='..repru(oACU[reftPreferredUpgrades])) end
        if M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) and oACU[refiUpgradeCount] == 0 then
        --Find the cheapest upgrade that boosts either rate of fire or range (if didnt start underwater) or that boosts build power (if started underwater)
        if bDebugMessages == true then LOG(sFunctionRef..': Have no preferred upgrades so will try finding a rate of fire or range boost') end
        oACU[reftPreferredUpgrades] = {}
        local iLowestMassCost = 1000000
        local sLowestUpgrade
        if M28Utilities.IsTableEmpty(oBP.Enhancements) == false then
        for sUpgrade, tUpgrade in oBP.Enhancements do
        if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering sUpgrade=' .. sUpgrade .. '; tUpgrade=' .. reprs(tUpgrade))
        end
        if (oACU[refbStartedUnderwater] and (tUpgrade.NewBuildRate or 0) > 10) or (tUpgrade.NewMaxRadius or tUpgrade.NewRateOfFire) then
        if tUpgrade.BuildCostMass < iLowestMassCost and not (tUpgrade.Prerequisite) and not (tRestrictedEnhancements[sUpgrade]) then
        sLowestUpgrade = sUpgrade
    iLowestMassCost = tUpgrade.BuildCostMass
    if bDebugMessages == true then
    LOG(sFunctionRef .. ': Have a new preferred upgrade ' .. sUpgrade .. '; iLowestMassCost=' .. iLowestMassCost)
    end
    end
    end
    end
    if bDebugMessages == true then
    LOG(sFunctionRef .. ': Finished considering the cheapest gun improving upgrade, sLowestUpgrade=' .. (sLowestUpgrade or 'nil')..'; Does ACU have RAS, or is RAS nil='..tostring(oBP.Enhancements['ResourceAllocation'] == nil))
    end
    if sLowestUpgrade then
    oACU[reftPreferredUpgrades] = { sLowestUpgrade }
    --Further backup - sometimes (e.g. cmapaign) RAS might be available but gun isnt
    elseif oBP.Enhancements['ResourceAllocation'] and not (tRestrictedEnhancements['ResourceAllocation']) then
    if bDebugMessages == true then LOG(sFunctionRef..': Adding in RAS if the upgrade slot is available') end
    local bSlotAvailable = true
    if oACU[refiUpgradeCount] > 0 then
    local sSlotWanted = oBP.Enhancements['ResourceAllocation'].Slot
    for sUpgrade, tUpgrade in oBP.Enhancements do
    if tUpgrade.Slot == sSlotWanted and oACU:HasEnhancement(sUpgrade) then
    if bDebugMessages == true then LOG(sFunctionRef..': Already using slot '..sSlotWanted..' for the upgrade '..sUpgrade) end
    bSlotAvailable = false
    break
    end
    end
    end
    if bSlotAvailable then
    oACU[reftPreferredUpgrades] = { 'ResourceAllocation' }
        if oBP.Enhancements['ResourceAllocationAdvanced'] and not (tRestrictedEnhancements['ResourceAllocationAdvanced']) then
    table.insert(oACU[reftPreferredUpgrades], 'ResourceAllocationAdvanced')
    if bDebugMessages == true then LOG(sFunctionRef..': Adding in RAS advanced as well') end
    end
    end
    --LOUD support where ACU upgrades dont show as improving max radius
    else
    local tsOtherUpgradeNames = {
    'EXRipperBooster', --Cybran
    'EXZephyrBooster', --UEF
    'EXChronotronBooster', --Seraphim
    'EXDisruptorrBooster', --Aeon
    }
    for iPotentialUpgrade, sPotentialUpgrade in tsOtherUpgradeNames do
    if oBP.Enhancements[sPotentialUpgrade] then
    if bDebugMessages == true then LOG(sFunctionRef..': Found backup gun upgrade so will use it, sPotentialUpgrade='..sPotentialUpgrade) end
    oACU[reftPreferredUpgrades] = { sPotentialUpgrade}
        break
        end
        end
        end

        --Add support for (blackops?) ACU upgrades, e.g. based on LOUD
        local tsModUpgradesToConsider = {
        --Shield (UEF and Aeon)
        'EXShieldBubble', --UEF and Aeon shield (blueprints have the same reference)

        --RH slot:
        'EXL1Lambda', --Seraphim lambda field - Destroys some incoming projectiles (so a defensive buff)
        'EXL2Lambda', --Seraphim lambda field that redirects the projectiles

        --LH slot:
        'EXCombatEngineering', --Gives HP buff and slight regen, although fairly expensive

        --Other weapons (that would replace the main gun so have held off getting)
        --[['EXMasor', --Cybran laser (cheap version)
        'EXEMPArray', --Cybran EMP weapon
        'EXGattlingEnergyCannon', --UEF Gatling weapon
        'EXRapidCannon', --Seraphim gatling weapon
        'EXStormCannon', --Seraphim storm cannon weapon
        'EXBeamPhason', --Aeon laser (cheap version)--]]
        }
        for iPotentialUpgrade, sPotentialUpgrade in  tsModUpgradesToConsider do
        if oBP.Enhancements[sPotentialUpgrade] then
        if bDebugMessages == true then LOG(sFunctionRef..': Blackops ACU upgrades - adding upgrade '..sPotentialUpgrade..' to ACU owned by player '..oACU:GetAIBrain().Nickname) end
        table.insert(oACU[reftPreferredUpgrades], sPotentialUpgrade)
        end
        end
        end
        else
        --If can get RAS, and it is cheap, then make it the first upgrade to get
        if oACU[refiUpgradeCount] == 0 and (oBP.Enhancements.ResourceAllocation.BuildCostMass or 10000) <= 100 and GetGameTimeSeconds() <= 60 and not(oACU[reftPreferredUpgrades][1] == 'ResourceAllocation') then
    table.insert(oACU[reftPreferredUpgrades], 1, 'ResourceAllocation')
    --Remove the other RAS
    for iUpgrade, sUpgrade in oACU[reftPreferredUpgrades] do
    if sUpgrade == 'ResourceAllocation' and iUpgrade > 1 then
    table.remove(oACU[reftPreferredUpgrades], iUpgrade)
    break
    end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': The first upgrade entry should be RAS upgrade because of how cheap it is') end
    end
    end
    --Campaign specific - add RAS upgrade if we only have 1 upgrade
    if bDebugMessages == true then
    LOG(sFunctionRef .. ': Campaign specific - considering adding RAS upgrade; is preferred upgrades nil=' .. tostring(oACU[reftPreferredUpgrades]))
    if oACU[reftPreferredUpgrades] and oACU[refiUpgradeCount] == 0 then
    LOG(sFunctionRef .. ': Upgrade size=' .. table.getn(oACU[reftPreferredUpgrades])..'; repru='..repru(oACU[reftPreferredUpgrades]))
    end
    end
    if (oACU[refiUpgradeCount] or 0) > 0 and oACU[reftPreferredUpgrades] and table.getn(oACU[reftPreferredUpgrades]) <= 2 and (EntityCategoryContains(categories.AEON, oACU.UnitId) or table.getn(oACU[reftPreferredUpgrades]) <= 1) and oBP.Enhancements['ResourceAllocation'] and not (tRestrictedEnhancements['ResourceAllocation']) then
    local bSlotAvailable = true
    if oACU[refiUpgradeCount] > 0 then
    local sSlotWanted = oBP.Enhancements['ResourceAllocation'].Slot
    for sUpgrade, tUpgrade in oBP.Enhancements do
    if tUpgrade.Slot == sSlotWanted and oACU:HasEnhancement(sUpgrade) then
    if bDebugMessages == true then LOG(sFunctionRef..': Already using slot '..sSlotWanted..' for the upgrade '..sUpgrade) end
    bSlotAvailable = false
    break
    end
    end
    end
    if bSlotAvailable or (M28UnitInfo.GetUnitHealthAndShieldPercent(oACU) == 1 and not(oACU:HasEnhancement('ShieldHeavy')) and M28Team.tTeamData[aiBrain.M28Team][M28Team.refbDangerousForACUs] and M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyAirToGroundThreat] <= 1000 and not(M28Team.tTeamData[aiBrain.M28Team][M28Team.refbAssassinationOrSimilar]) and M28Map.tAllPlateaus[oACU[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28Team][1]][M28Map.subrefPlateauLandZones][oACU[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28Team][2]][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.refbBaseInSafePosition]) then
    table.insert(oACU[reftPreferredUpgrades], 'ResourceAllocation')
    if bDebugMessages == true then LOG(sFunctionRef..': Adding RAS to table of preferred upgrades') end
    if oBP.Enhancements['ResourceAllocationAdvanced'] and not (tRestrictedEnhancements['ResourceAllocationAdvanced']) then
    table.insert(oACU[reftPreferredUpgrades], 'ResourceAllocationAdvanced')
    if bDebugMessages == true then LOG(sFunctionRef..': Adding in RAS advanced as well') end
    end
    end
    end

    --Remove any upgrades that we already have
    RemovePreferredUpgradesThatWeAlreadyHave(oACU, oBP)

    if bDebugMessages == true then
    LOG(sFunctionRef .. ': End of code, oACU[reftPreferredUpgrades] after removing upgrades we already have=' .. repru(oACU[reftPreferredUpgrades]))
        end
end

function GetACUUpgradeWanted(oACU, bWantToDoTeleSnipe, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, bIgnoreEcoCondition)
    --Returns nil if cantr find anything; also returns true as a second variable if we have a low cost upgrade
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetACUUpgradeWanted'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local sUpgradeWanted, bIgnoreOtherConditions

    if EntityCategoryContains(categories.COMMAND, oACU.UnitId) then
        local aiBrain = oACU:GetAIBrain()
        local iTeam = aiBrain.M28Team
        local bDontConsiderAnyUpgrades = false
        --Norush - dont get if more than 1m until it ends (want to use resources for eco instead) unless are close to overflowing (with slight random element to reduce tendancy of multiple ACUs to ugprade at the same time)
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if norush active first, M28Overseer.bNoRushActive='..tostring(M28Overseer.bNoRushActive or false)..'; oACU[refbPlanningToGetTeleport]='..tostring(oACU[refbPlanningToGetTeleport] or false)) end
        if M28Overseer.bNoRushActive then
            local iTimeUntilNoRushEnds = M28Overseer.iNoRushTimer - GetGameTimeSeconds()
            local iDelayAdj = 0
            if iTimeUntilNoRushEnds >= 80 then
                bDontConsiderAnyUpgrades = true
            else
                local iCurACU =  aiBrain:GetCurrentUnits(categories.COMMAND)
                if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 0 or iCurACU > 0 then
                    iDelayAdj = aiBrain:GetArmyIndex()
                    if iCurACU > 0 then
                        local tACUs = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
                        if M28Utilities.IsTableEmpty(tACUs) == false then
                            for iUnit, oUnit in aiBrain:GetListOfUnits(categories.COMMAND, false, true) do
                                if oUnit == oACU then
                                    iDelayAdj = iDelayAdj + iUnit
                                    break
                                end
                            end
                        end
                    end
                end
                if iTimeUntilNoRushEnds >= 60 + iDelayAdj then
                    bDontConsiderAnyUpgrades = true
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iTimeUntilNoRushEnds='..iTimeUntilNoRushEnds..'; iDelayAdj='..iDelayAdj..'; bDontConsiderAnyUpgrades='..tostring(bDontConsiderAnyUpgrades or false)) end
            --In a 'safe' spot and early on - delay getting upgrade so can focus on ecoing instead; also delay in larger teamgames early on if no t2 mex
        elseif GetGameTimeSeconds() <= 420 then
            local tStartPosition = M28Map.GetPlayerStartPosition(aiBrain)
            local tStartLZOrWZData, tStartLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(tStartPosition, true, iTeam)
            if tStartLZOrWZTeamData[M28Map.refbBaseInSafePosition] then
                if tStartLZOrWZTeamData[M28Map.subrefMexCountByTech][3] == 0 and tStartLZOrWZTeamData[M28Map.subrefMexCountByTech][2] < 3 and (tStartLZOrWZTeamData[M28Map.subrefMexCountByTech][2] < 2 or not(M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU]) or M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) > M28Utilities.GetDistanceBetweenPositions(tStartLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestEnemyBase])) then
                    bDontConsiderAnyUpgrades = true
                    if bDebugMessages == true then LOG(sFunctionRef..': In a safe spot so will delay ACU upgrade so can get more eco') end
                end
            end
            if not(bDontConsiderAnyUpgrades) and not(M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU]) then
                --Cybran torp upgrade when have enough base eco - ignore normal 'delay upgrade' logic
                if not(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) and aiBrain[M28Map.refbCanPathToEnemyBaseWithAmphibious] and oACU.UnitId == 'url0001' and (tStartLZOrWZTeamData[M28Map.subrefMexCountByTech][2] > 0 or aiBrain[M28Economy.refiGrossMassBaseIncome] >= 3) and (iPlateauOrZero == 0 or M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]) == false) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech] < 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] < 3 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to consider getting upgrade for cybran since it can get torpedo upgrade') end
                elseif M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 3 and tStartLZOrWZTeamData[M28Map.subrefMexCountByTech][2] == 0 and tStartLZOrWZTeamData[M28Map.subrefMexCountByTech][3] == 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Early teamgame, enemy doesnt have upgraded ACU, we lack T2 mex in our core base, so wont consider upgrade yet') end
                    bDontConsiderAnyUpgrades = true
                    --Exception for maps like setons and isis where large value reclaim area we want to go in priority to getting an upgrade early game and we dont have high AIx mod
                elseif aiBrain[M28Economy.refiBrainBuildRateMultiplier] <= 1.5 and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] then
                    --Search for other zones we can path to from here that have lots of reclaim in them that have a mod dist of >=0.25 and <=0.55, and are within 275 of our ACU
                    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                        for iEntry, tSubtable in tLZOrWZData[M28Map.subrefLZPathingToOtherLandZones] do
                            if tSubtable[M28Map.subrefLZTravelDist] >= 300 then break end
                            local tAltLZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefLZNumber]]
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if have high value zone to reclaim, iAdjLZ='..tSubtable[M28Map.subrefLZNumber]..'; Signif mass Reclaim='..(tAltLZData[M28Map.subrefTotalSignificantMassReclaim] or 'nil')) end
                            if tAltLZData[M28Map.subrefTotalSignificantMassReclaim] >= 1500 then
                                --Check mod distance
                                local tAltLZTeamData = tAltLZData[M28Map.subrefLZTeamData][iTeam]
                                if bDebugMessages == true then LOG(sFunctionRef..': Zone mod dist%='..tAltLZTeamData[M28Map.refiModDistancePercent]) end
                                if tAltLZTeamData[M28Map.refiModDistancePercent] <= 0.55 and tAltLZTeamData[M28Map.refiModDistancePercent] >= 0.15 then
                                    bDontConsiderAnyUpgrades = true
                                end
                            end
                        end
                    end
                end
            end
            --Exception for low cost mod where we are calling this from the early game order
            if bDontConsiderAnyUpgrades and GetGameTimeSeconds() <= 15 then
                bDontConsiderAnyUpgrades = false
            end
            --tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] <= 2
        end
        if bDontConsiderAnyUpgrades then
            --Do nothing
            if bDebugMessages == true then LOG(sFunctionRef..': Dont want to consider any upgrades due to norush or being in a safe spot') end
        else
            --If we were to get an upgrade, what upgrade would it be?
            if not(oACU[reftPreferredUpgrades]) or (oACU[reftPreferredUpgrades][1] and oACU.HasEnhancement and oACU:HasEnhancement(oACU[reftPreferredUpgrades][1])) or bWantToDoTeleSnipe or (oACU[refiUpgradeCount] > 0 and GetGameTimeSeconds() - (oACU[refiTimeLastConsideredUpgradePath] or 0) >= 30) then
                GetUpgradePathForACU(oACU, bWantToDoTeleSnipe)
            end

            if bDebugMessages == true then LOG(sFunctionRef..': oACU[reftPreferredUpgrades]='..repru(oACU[reftPreferredUpgrades])..'; Have low power='..tostring(M28Conditions.HaveLowPower(iTeam))..'; bWantToDoTeleSnipe='..tostring(bWantToDoTeleSnipe or false)) end
            local sPotentialUpgrade = oACU[reftPreferredUpgrades][1]
            if M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) == false and sPotentialUpgrade then
                local tEnhancement = oACU:GetBlueprint().Enhancements[sPotentialUpgrade]
                if tEnhancement.BuildCostMass <= 100 and tEnhancement.BuildCostEnergy <= 100 and (oACU:GetAIBrain()[M28Economy.refiGrossEnergyBaseIncome] >= 600 or not(sUpgradeWanted == 'CloakingGenerator' or sUpgradeWanted == 'Sheild')) then
                    sUpgradeWanted = sPotentialUpgrade
                    if tEnhancement.BuildTime <= 100 then
                        bIgnoreOtherConditions = true
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Low cost upgrade wanted') end
                elseif (not(M28Conditions.HaveLowPower(iTeam)) or aiBrain[M28Economy.refbBuiltParagon] or (aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 7500 and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]))) then
                    if bWantToDoTeleSnipe or bIgnoreEcoCondition then sUpgradeWanted = sPotentialUpgrade
                    else
                        --Do we have the eco to support the upgrade?
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering sPotentialUpgrade='..sPotentialUpgrade..'; for ACU '..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' for brain '..oACU:GetAIBrain().Nickname..'; tEnhancement='..reprs(tEnhancement)) end
                        local iBuildRate = oACU:GetBlueprint().Economy.BuildRate
                        if aiBrain.CheatEnabled then iBuildRate = iBuildRate * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier] end
                        local iMassCostPerTick = 0.1 * tEnhancement.BuildCostMass / (tEnhancement.BuildTime / iBuildRate)
                        local iEnergyCostPerTick = 0.1 * tEnhancement.BuildCostEnergy / (tEnhancement.BuildTime / iBuildRate)
                        --Do we have enough gross energy?
                        local iActiveACUUpgrades = 0
                        local iResourceFactor
                        if aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] then
                            iResourceFactor = 1
                        elseif aiBrain[M28Map.refbCanPathToEnemyBaseWithAmphibious] then
                            iResourceFactor = 2
                        else
                            iResourceFactor = 4 --Cant path to enemy except with air
                        end

                        --If want MMLs then also increase resource requirements
                        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oACU:GetPosition())
                        if M28Conditions.SaveMassForMMLOrMobileT3ArtiForFirebase(tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iTeam, M28Conditions.HaveLowMass(aiBrain)) then
                            iResourceFactor = iResourceFactor * 2
                            if M28Conditions.HaveLowPower(aiBrain.M28Team) then iResourceFactor = iResourceFactor * 2 end
                        end

                        --If enemy has dangerous ACU and the upgrade is combat related and is a T1-T2 stage upgrade (e.g. first nano, shield) and either we lack T3 land or we are UEF or Cybran, then decrease resource requirements
                        if M28Team.tTeamData[iTeam][M28Team.refbEnemyHasDangerousACU] and M28UnitInfo.GetUpgradeCombatWeighting(sPotentialUpgrade) >= 1 and tEnhancement.BuildCostMass <= 2500 and tEnhancement.BuildCostEnergy <= 125000 and (aiBrain[M28Economy.refiOurHighestLandFactoryTech] <= 2 or aiBrain:GetFactionIndex() == M28UnitInfo.refFactionUEF or aiBrain:GetFactionIndex() == M28UnitInfo.refFactionCybran) then
                            iResourceFactor = iResourceFactor * 0.7
                        elseif (oACU[refiUpgradeCount] or 0) >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 2 and tEnhancement.BuildCostMass >= 1500 and (oACU[refiUpgradeCount] >= 3 or not(aiBrain:GetFactionIndex() == M28UnitInfo.refFactionAeon)) then iResourceFactor = iResourceFactor * 1.3
                        elseif (oACU[refiUpgradeCount] or 0) == 0 and GetGameTimeSeconds() >= 600 then iResourceFactor = iResourceFactor * 0.5
                        end
                        if M28Map.bIsCampaignMap and GetGameTimeSeconds() >= 480 then
                            iResourceFactor = iResourceFactor * 0.5
                            if GetGameTimeSeconds() >= 1200 then
                                iResourceFactor = iResourceFactor * 0.5
                                if (tEnhancement.ProductionPerSecondMass or 0) > 0 and (tEnhancement.ProductionPerSecondEnergy or 0) > 0 and GetGameTimeSeconds() >= 1800 then iResourceFactor = iResourceFactor * 0.2 end --Campaign - even if have really poor eco want to get RAS upgrade
                            end
                        end
                        if oACU[refbStartedUnderwater] and (tEnhancement.ProductionPerSecondEnergy or 0) > 20 then iResourceFactor = 0.5 end
                        local iDistToEnemyBase
                        if iPlateauOrZero == 0 then
                            iDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam][M28Map.reftClosestEnemyBase])
                        else
                            iDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.reftClosestEnemyBase])
                        end
                        if iDistToEnemyBase >= 400 then iResourceFactor = iResourceFactor * 1.5 end
                        if (oACU[refiUpgradeCount] or 0) > 0 then
                            if (oACU[refiUpgradeCount] or 0) >= 2 and (oACU[refiUpgradeCount] >= 3 or not(aiBrain:GetFactionIndex() == M28UnitInfo.refFactionAeon)) and M28Conditions.HaveLowMass(aiBrain) then iResourceFactor = iResourceFactor * 2
                            else iResourceFactor = iResourceFactor * 1.25
                            end
                        end
                        if M28Overseer.bNoRushActive and M28Overseer.iNoRushTimer - GetGameTimeSeconds() > 120 then
                            if M28Conditions.HaveLowMass(aiBrain) or M28Conditions.HaveLowPower(aiBrain.M28Team) then
                                iResourceFactor = iResourceFactor * 2.5
                            else iResourceFactor = iResourceFactor * 1.75
                            end
                        end
                        if aiBrain[M28Factory.refiHighestFactoryBuildCount] >= 20 + 10 * (oACU[refiUpgradeCount] or 0) then

                            if M28Map.bIsCampaignMap then
                                iResourceFactor = iResourceFactor * 0.7
                            else
                                iResourceFactor = iResourceFactor * 0.8
                            end
                            if aiBrain[M28Factory.refiHighestFactoryBuildCount] >= 30 + 15 * (oACU[refiUpgradeCount] or 0) then
                                if M28Map.bIsCampaignMap then
                                    iResourceFactor = iResourceFactor * 0.7
                                    if aiBrain[M28Factory.refiHighestFactoryBuildCount] >= 60 then iResourceFactor = iResourceFactor * 0.75 end
                                else
                                    iResourceFactor = iResourceFactor * 0.85
                                end

                            end
                        end
                        --Reduce factor in smaller maps if lack gun
                        if iActiveACUUpgrades == 0 and not(sPotentialUpgrade == 'T3Engineering') and oACU[refiUpgradeCount] <= 1 and (oACU[M28UnitInfo.refiDFRange] <= 25 or oACU[refiUpgradeCount] == 0 or EntityCategoryContains(categories.AEON, oACU.UnitId)) and M28Utilities.GetDistanceBetweenPositions(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) <= 250 and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] then
                            iResourceFactor = iResourceFactor * 0.8
                        end

                        --If trying to get T3 - check we have T2/T3 power first
                        if sPotentialUpgrade == 'T3Engineering' and aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= 250 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower - categories.TECH1) == 0 then
                            iResourceFactor = iResourceFactor * 3
                        end

                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingACUs]) == false then iActiveACUUpgrades = table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingACUs]) end
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have enough resources to get this upgrade, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; Net mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]..'; Other active upgrades='..iActiveACUUpgrades..'; Is safe to get upgrade='..tostring(M28Conditions.SafeToUpgradeUnit(oACU) or false)..'; iEnergyCostPerTick='..iEnergyCostPerTick..'; iMassCostPerTick='..iMassCostPerTick..'; iResourceFactor'..iResourceFactor..'; iDistToEnemyBase='..iDistToEnemyBase..'; oACU[refiUpgradeCount]='..(oACU[refiUpgradeCount] or 0)..'; aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]='..tostring(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand])..'; Have low mass='..tostring(M28Conditions.HaveLowMass(aiBrain))..'; iResourceFactor='..iResourceFactor..'; aiBrain[M28Factory.refiHighestFactoryBuildCount]='..aiBrain[M28Factory.refiHighestFactoryBuildCount]) end
                        --Aeon exception - if we have the first gun upgrade, have high health %, and are close to a core base, then consider getting the second upgrade regardless of eco

                        if sPotentialUpgrade == 'HeatSink' and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) and aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.5 and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.75 then
                            local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oACU:GetPosition(), true, iTeam)
                            if bDebugMessages == true then LOG(sFunctionRef..': Aeon already has range so now wants dps, tLZOrWZTeamData[M28Map.refiModDistancePercent]='..tLZOrWZTeamData[M28Map.refiModDistancePercent]) end
                            if tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.45 then
                                sUpgradeWanted = sPotentialUpgrade
                            end
                        end
                        local iModifiedBrainCountForEcoConditions = (M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] - 1) * 0.6 + 1

                        if not(sUpgradeWanted) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= (45 * iActiveACUUpgrades * iModifiedBrainCountForEcoConditions + iEnergyCostPerTick * 1.35) * iResourceFactor then
                            --Do we have enough gross mass?
                            if bDebugMessages == true then LOG(sFunctionRef..': Have enough gross energy, do we have enough gross mass? iActiveACUUpgrades='..iActiveACUUpgrades..'; iModifiedBrainCountForEcoConditions='..iModifiedBrainCountForEcoConditions..'; iMassCostPerTick='..iMassCostPerTick..'; iResourceFactor='..iResourceFactor) end
                            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= (iActiveACUUpgrades * iModifiedBrainCountForEcoConditions * 2.5 + iMassCostPerTick * 2) * iResourceFactor then
                                --Do we have enough net energy?
                                if bDebugMessages == true then LOG(sFunctionRef..': Have enough gross mass, do we have enough net energy? iActiveACUUpgrades='..iActiveACUUpgrades..'; Team is stalling E='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; Brain gross energy='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; ACU health%='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; enhancement combat factor='..M28UnitInfo.GetUpgradeCombatWeighting(sPotentialUpgrade)..'; enemy has dangerous ACU='..tostring(M28Team.tTeamData[iTeam][M28Team.refbEnemyHasDangerousACU])..'; subrefiTeamNetEnergy='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] or 'nil')..'; iEnergyCostPerTick='..iEnergyCostPerTick) end
                                if (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= (iActiveACUUpgrades * iModifiedBrainCountForEcoConditions + 100 * iEnergyCostPerTick * 2) * iResourceFactor and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 5 * iResourceFactor) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= iEnergyCostPerTick * math.min(2.5, iResourceFactor * 0.4) or (iActiveACUUpgrades == 0 and oACU[refiUpgradeCount] == 0 and iEnergyCostPerTick <= 50 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 100 * aiBrain[M28Economy.refiBrainResourceMultiplier] and (aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.9 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 1))
                                        or (iActiveACUUpgrades <= 1 and (iActiveACUUpgrades == 0 or M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 4) and oACU[refiUpgradeCount] > 0 and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and M28UnitInfo.GetUpgradeCombatWeighting(sPotentialUpgrade) >= 1 and (iActiveACUUpgrades == 0 or M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 3) and (M28Team.tTeamData[iTeam][M28Team.refbEnemyHasDangerousACU] or M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.75) and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= iEnergyCostPerTick * 2 * iResourceFactor)
                                        or (iActiveACUUpgrades == 0 and oACU[refiUpgradeCount] == 0 and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and (aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.99 or aiBrain:GetEconomyStored('ENERGY') >= 12000) and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= math.max(80*aiBrain[M28Economy.refiBrainBuildRateMultiplier], 3 * iEnergyCostPerTick)) then

                                    --Do we have enoguh net mass?
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have enough net energy, do we have enough net mass or so much gross mass that we can still proceed? Brain gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]) end
                                    if (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= (iActiveACUUpgrades * iModifiedBrainCountForEcoConditions * 3.5 + iMassCostPerTick * 3) * iResourceFactor or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= iMassCostPerTick * math.min(2.5, iResourceFactor * 0.4) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= math.min(3, iResourceFactor) * tEnhancement.BuildCostMass * 0.5 or (M28Map.bIsCampaignMap and aiBrain[M28Factory.refiHighestFactoryBuildCount] >= 30))
                                            --e.g. Cybran nano is 1500 mass; if want to start such an upgrade when ahve 40 mass income (if enemy has nano guncom), then means doing roughly a total mass / 375 calculation
                                            or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 16 and iActiveACUUpgrades == 0 and aiBrain[M28Economy.refiGrossMassBaseIncome] >= tEnhancement.BuildCostMass / 375 and (M28Team.tTeamData[iTeam][M28Team.refbEnemyHasDangerousACU] or (oACU[refiUpgradeCount] == 0 and aiBrain[M28Economy.refiGrossMassBaseIncome] >= 4*aiBrain[M28Economy.refiBrainBuildRateMultiplier])) and M28UnitInfo.GetUpgradeCombatWeighting(sPotentialUpgrade) >= 1)
                                            or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 0.5 and tEnhancement.BuildCostMass <= 800)
                                    then
                                        --Early game on larger map where we lack 2+ T2 mexes, and dont have a t2 factory yet, and enemy doesnt have upgrades yet
                                        if bDebugMessages == true then LOG(sFunctionRef..': Checking if want to delay upgrade, M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs]='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs])..'; M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU]='..tostring(M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU])) end
                                        if not(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs]) and (M28Map.iMapSize >= 750 or not(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand])) and not(M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU]) and (((oACU[refiUpgradeCount] or 0) == 0 and GetGameTimeSeconds() <= 360 and aiBrain[M28Economy.refiOurHighestFactoryTechLevel] <= 1 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryT2Mex) < 2 and (M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][3] or 0) == 0 and (GetGameTimeSeconds() <= 270 or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) or (M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) == false and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M28Utilities.GetNearestUnit(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs], oACU:GetPosition()):GetPosition()) > 225))
                                                or ((oACU[refiUpgradeCount] or 0) > 0 and aiBrain[M28Economy.refiOurHighestFactoryTechLevel] <= 2 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryT3Mex) == 0 and (not(EntityCategoryContains(categories.CYBRAN, oACU.UnitId)) or oACU[refiUpgradeCount] >= 2 or (M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) == false and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M28Utilities.GetNearestUnit(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies], oACU:GetPosition()):GetPosition()) <= 100))))) then
                                            if bDebugMessages == true then
                                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) then LOG(sFunctionRef..': Early game, larger map, no enemy ACU table, will delay upgrade')
                                                else
                                                    LOG(sFunctionRef..': Early game on larger map, enemy lacks upgrade, and either we dont have t2, so no rush to get gun, or we have gun so dont need further upgrade urgently, Dist to nearest enemy ACU='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M28Utilities.GetNearestUnit(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs], oACU:GetPosition()):GetPosition()))
                                                end
                                            end
                                        else
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will get the upgrade unless naval map with noncybran ACU, aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]='..tostring(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] or false)..'; M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.refiEnemyMobileDFThreatNearOurSide]='..(M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.refiEnemyMobileDFThreatNearOurSide] or 'nil')..'; Approaching ACU threat='..M28Conditions.GetThreatOfApproachingEnemyACUsAndNearestACU(tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iLandOrWaterZone, iTeam, 150)) end
                                            local bProceedWithUpgrade = aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] or M28Map.bIsCampaignMap or aiBrain[M28Economy.refbBuiltParagon] or M28Map.iMapSize <= 500 or tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] >= 3 or aiBrain[M28Economy.refiGrossMassBaseIncome] >= 30 or (M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs] and M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) or M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.refiEnemyMobileDFThreatNearOurSide] >= 1000 or oACU.UnitId == 'url0001'
                                            if not(bProceedWithUpgrade) and M28Team.tTeamData[iTeam][M28Team.refbEnemyHasDangerousACU] and aiBrain[M28Economy.refiOurHighestFactoryTechLevel] >= 2 and tLZOrWZTeamData[M28Map.subrefLZbCoreBase] then
                                                local iApproachingACUThreat, oApproachingACU = M28Conditions.GetThreatOfApproachingEnemyACUsAndNearestACU(tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iLandOrWaterZone, iTeam, 150)
                                                if bDebugMessages == true then LOG(sFunctionRef..': oApproachingACU DF range='..(oApproachingACU[M28UnitInfo.refiDFRange] or 'nil')) end
                                                if iApproachingACUThreat >= 1500 and oApproachingACU and oApproachingACU[M28UnitInfo.refiDFRange] >= 26 then
                                                    bProceedWithUpgrade = true
                                                end
                                            end
                                            if bProceedWithUpgrade then --M28Conditions.GetThreatOfApproachingEnemyACUsAndNearestACU(tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iLandOrWaterZone, iTeam, 150) >= 1500) then
                                                --Require T3 mex if 3rd+ upgrade and the upgrade has a significant cost
                                                if bDebugMessages == true then LOG(sFunctionRef..': T3 mex count='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryT3Mex)..'; T2 mex count='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryT2Mex)) end
                                                if (oACU[refiUpgradeCount] or 0) < 2 or tEnhancement.BuildCostMass <= 800 or aiBrain[M28Economy.refbBuiltParagon] or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryT3Mex) > 1 or (tEnhancement.BuildCostMass <= 2000 and aiBrain[M28Economy.refiGrossMassBaseIncome] >= 4 and (oACU[refiUpgradeCount] or 0) == 2 and M28Team.tTeamData[iTeam][M28Team.refbEnemyHasDangerousACU] and M28UnitInfo.GetUpgradeCombatWeighting(sPotentialUpgrade) >= 1 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryT2Mex) >= 6 * (tEnhancement.BuildCostMass - 1000) / 1000) then
                                                    --Naval maps - delay getting upgrade until have t3 mexes if no threat on our land mass and no appraoching ACU
                                                    sUpgradeWanted = sPotentialUpgrade
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then
                LOG(sFunctionRef..': End of code, sUpgradeWanted='..(sUpgradeWanted or 'nil'))
                if sUpgradeWanted then
                    LOG(sFunctionRef..': Does ACU have this enhancement='..tostring(oACU:HasEnhancement(sUpgradeWanted)))
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return sUpgradeWanted, bIgnoreOtherConditions
end

function GetUpgradeForSACU(oSACU, bWantBuildPower, bForceGetNewUpgradePath, bWantShieldField)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUpgradeForSACU'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --E.g. used when overflowing resources and want engineer upgrade for the SACU
    local sUpgradeWanted
    local aiBrain = oSACU:GetAIBrain()
    local iTeam = aiBrain.M28Team
    --If we were to get an upgrade, what upgrade would it be?
    if bForceGetNewUpgradePath or not(oSACU[reftPreferredUpgrades]) or (oSACU[reftPreferredUpgrades][1] and oSACU.HasEnhancement and oSACU:HasEnhancement(oSACU[reftPreferredUpgrades][1])) then
        --Determine upgrade path
        oSACU[reftPreferredUpgrades] = {}
        --Find build rate and RAS enhancements
        local tUpgradesAvailable = oSACU:GetBlueprint().Enhancements
        local oBP = oSACU:GetBlueprint()
        if M28Utilities.IsTableEmpty(tUpgradesAvailable) == false then
            local sBuildRateUpgrade, sBestShieldSizeEnhancement

            --First get what slots are available
            --Check if can get RAS upgrade
            local tbSlotsInUse = {}
            local iBestBuildPowerRate, iBestShieldSize
            if bWantBuildPower then
                iBestBuildPowerRate = (oSACU:GetBlueprint().Economy.BuildRate or 0)
            end
            if bWantShieldField then
                iBestShieldSize = (oSACU:GetBlueprint().Defense.Shield.ShieldSize or 0)
            end

            local iBestEcoRate = 0
            local sBestEcoEnhancement, iCurEcoRate
            for sEnhancement, tEnhancement in tUpgradesAvailable do
                if oSACU:HasEnhancement(sEnhancement) then
                    if bDebugMessages == true then LOG(sFunctionRef..': We already have the enhancement '..sEnhancement..'; ProductionPerSecondMass='..(tEnhancement.ProductionPerSecondMass or 0)..'; NewBuildRate='..(tEnhancement.NewBuildRate or 0)..'; ShieldSize='..(tEnhancement.ShieldSize or 0)) end
                    tbSlotsInUse[tEnhancement.Slot] = true
                    iCurEcoRate = (tEnhancement.ProductionPerSecondEnergy or 0) / 100 + (tEnhancement.ProductionPerSecondMass or 0)
                    if iCurEcoRate > iBestEcoRate then
                        iBestEcoRate = iCurEcoRate
                    end
                    if bWantBuildPower and (tEnhancement.NewBuildRate or 0) > iBestBuildPowerRate then
                        iBestBuildPowerRate = tEnhancement.NewBuildRate
                        sBuildRateUpgrade = nil
                    end
                    if bWantShieldField and (tEnhancement.ShieldSize or 0) > iBestShieldSize then
                        iBestShieldSize = tEnhancement.ShieldSize
                        sBestShieldSizeEnhancement = nil
                    end
                elseif not(tEnhancement.Prerequisite) or (oSACU:HasEnhancement(tEnhancement.Prerequisite)) then
                    iCurEcoRate = (tEnhancement.ProductionPerSecondEnergy or 0) / 100 + (tEnhancement.ProductionPerSecondMass or 0)
                    if iCurEcoRate > iBestEcoRate then
                        iBestEcoRate = iCurEcoRate
                        sBestEcoEnhancement = sEnhancement
                    end
                    if bWantBuildPower and (tEnhancement.NewBuildRate or 0) > iBestBuildPowerRate then
                        iBestBuildPowerRate = tEnhancement.NewBuildRate
                        sBuildRateUpgrade = sEnhancement
                    end
                    if bWantShieldField and (tEnhancement.ShieldSize or 0) > iBestShieldSize then
                        iBestShieldSize = tEnhancement.ShieldSize
                        sBestShieldSizeEnhancement = sEnhancement
                    end
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': bWantBuildPower='..tostring(bWantBuildPower)..'; sBuildRateUpgrade='..(sBuildRateUpgrade or 'nil')..'; sBestShieldSizeEnhancement='..(sBestShieldSizeEnhancement or 'nil')) end
            --Shield upgrade if are defending against arti
            if bWantShieldField and sBestShieldSizeEnhancement and M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] and not(tbSlotsInUse[tUpgradesAvailable[sBuildRateUpgrade].Slot]) then
                table.insert(oSACU[reftPreferredUpgrades], sBestShieldSizeEnhancement)
            end
            if bWantBuildPower then
                if sBuildRateUpgrade and (not(sBestEcoEnhancement) or bWantBuildPower or not(tUpgradesAvailable[sBuildRateUpgrade].Slot == tUpgradesAvailable[sBestEcoEnhancement].Slot)) and not(tbSlotsInUse[tUpgradesAvailable[sBuildRateUpgrade].Slot]) then
                    table.insert(oSACU[reftPreferredUpgrades], sBuildRateUpgrade)
                    if bDebugMessages == true then LOG(sFunctionRef..': Included build power enhancement in table of upgrades for the SACU') end
                end
            end
            if sBestEcoEnhancement then
                table.insert(oSACU[reftPreferredUpgrades], sBestEcoEnhancement)
            end
            --Shield upgrade if not defending against arti
            if bWantShieldField and sBestShieldSizeEnhancement and not(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) and not(tbSlotsInUse[tUpgradesAvailable[sBuildRateUpgrade].Slot]) then
                table.insert(oSACU[reftPreferredUpgrades], sBestShieldSizeEnhancement)
            end

            if bDebugMessages == true then LOG(sFunctionRef..': oSACU[reftPreferredUpgrades] before refining to exclude invalid ones='..repru(oSACU[reftPreferredUpgrades])) end

            --Check all of these are options (in case a mod has changed them)
            local tRestrictedEnhancements = import("/lua/enhancementcommon.lua").GetRestricted()
            local bCheckForRestrictions = not (M28Utilities.IsTableEmpty(tRestrictedEnhancements))
            local bInvalidUpgrade

            if M28Utilities.IsTableEmpty(oSACU[reftPreferredUpgrades]) == false then
                local tiEntriesToRemove = {}
                if bDebugMessages == true then LOG(sFunctionRef..': oSACU[reftPreferredUpgrades] before removing invalid entries='..repru(oSACU[reftPreferredUpgrades])) end
                for iUpgradeWanted, sUpgradeWanted in oSACU[reftPreferredUpgrades] do
                    bInvalidUpgrade = false
                    if M28Utilities.IsTableEmpty(oBP.Enhancements[sUpgradeWanted]) then
                        bInvalidUpgrade = true
                        oSACU[reftPreferredUpgrades] = {}
                        if bDebugMessages == true then LOG(sFunctionRef..': ACU doesnt have sUpgradeWanted='..sUpgradeWanted..' in its blueprint so aborting') end
                        break
                    elseif bCheckForRestrictions then
                        --If we cant get the first upgrade, then cancel all upgrades; otherwise just remove the later upgrade that we cant get
                        if tRestrictedEnhancements[sUpgradeWanted] then
                            if bDebugMessages == true then LOG(sFunctionRef..': sUpgradeWanted '..sUpgradeWanted..' is in the restricted enhancements table so cant get it yet') end
                            bInvalidUpgrade = true
                        end
                    end
                    if bInvalidUpgrade then
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering restricted upgrade='..sUpgradeWanted..'; iUpgradeWanted='..iUpgradeWanted) end
                        if iUpgradeWanted <= 1 then
                            if bDebugMessages == true then LOG(sFunctionRef..': We cant get the first planned upgrade so wont get any further upgrades') end
                            oSACU[reftPreferredUpgrades] = {}
                            break
                        else
                            table.insert(tiEntriesToRemove, iUpgradeWanted)
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tiEntriesToRemove) == false then
                    local iTotalEntriesToRemove = table.getn(tiEntriesToRemove)
                    for iCurEntry = iTotalEntriesToRemove, 1, -1 do
                        if bDebugMessages == true then LOG(sFunctionRef..': Removing iCurEntry='..iCurEntry..' from preferred upgrades, Upgrade='..(oSACU[reftPreferredUpgrades][iCurEntry] or 'nil')) end
                        table.remove(oSACU[reftPreferredUpgrades], tiEntriesToRemove[iCurEntry])
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of preferred upgrades empty='..tostring(M28Utilities.IsTableEmpty(oSACU[reftPreferredUpgrades]))..'; repru='..repru(oSACU[reftPreferredUpgrades])) end

            --Remove any upgrades that we already have
            RemovePreferredUpgradesThatWeAlreadyHave(oSACU, oBP)

            if bDebugMessages == true then
                LOG(sFunctionRef .. ': End of code, oSACU[reftPreferredUpgrades] after removing upgrades we already have=' .. repru(oSACU[reftPreferredUpgrades]))
            end


            if oSACU[reftPreferredUpgrades][1] and not(oSACU:HasEnhancement(oSACU[reftPreferredUpgrades][1])) then
                sUpgradeWanted = oSACU[reftPreferredUpgrades][1]
            end
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef..': End of code, sUpgradeWanted='..(sUpgradeWanted or 'nil'))
        if sUpgradeWanted then
            LOG(sFunctionRef..': Does ACU have this enhancement='..tostring(oSACU:HasEnhancement(sUpgradeWanted)))
        end
    end
    if not(sUpgradeWanted) and bWantBuildPower then oSACU[refbTriedAndFailedToGetBuildRateUpgrade] = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return sUpgradeWanted
end

function DoesACUWantToRun(iPlateau, iLandZone, tLZData, tLZTeamData, oACU)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DoesACUWantToRun'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bWantToRun = false
    local iTeam = oACU:GetAIBrain().M28Team

    --Dont run if in core base unless low health or close to the rally point
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for brain '..oACU:GetAIBrain().Nickname..'; Is ACU in core base='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])..' iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; oACU='..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..'; M28Team.tTeamData[aiBrain.M28Team][M28Team.refbDangerousForACUs]='..tostring(M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refbDangerousForACUs] or false)..'; Does enemy have sub? count='..(M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refiEnemySubCount] or 0)..'; Dist to midpoint='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZData[M28Map.subrefMidpoint])) end
    if tLZTeamData[M28Map.subrefLZbCoreBase] and (M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.2 and (oACU[refbUseACUAggressively] or (M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.4 and ((oACU[refiUpgradeCount] or 0) > 0 or not(M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU])) and (false and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.75 or M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= 70)) or M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= 15)) and ((M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.5 or M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase]) > 5 + M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint],tLZTeamData[M28Map.reftClosestEnemyBase])))  then
        if bDebugMessages == true then LOG(sFunctionRef..': Are in core base with some health so dont want to run unless approaching experimental or large threat, oACU[refbUseACUAggressively]='..tostring(oACU[refbUseACUAggressively])) end
        --20km type map - be more cautious in assassination
    elseif tLZTeamData[M28Map.refiModDistancePercent] >= 0.3 and M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar] and GetGameTimeSeconds() >= 1000 and M28Map.iMapSize >= 756 then
        if bDebugMessages == true then LOG(sFunctionRef..': Large map, cant afford to lose ACU, so will be cautious and stay relatively near base') end
        bWantToRun = true
    else

        local iACUThreat = (M28UnitInfo.GetCombatThreatRating({ oACU}, false) or 0)
        --Dont run if building T1 mex and almost done, assuming our health is ok
        if iACUThreat >= 400 and (oACU:IsUnitState('Building') or oACU:IsUnitState('Repairing') or oACU:IsUnitState('Capturing')) and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= math.max(1500, iACUThreat * 1.5) and M28UnitInfo.IsUnitValid(oACU:GetFocusUnit()) and EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oACU:GetFocusUnit()) and oACU:GetFocusUnit():GetFractionComplete() >= 0.7 then
            --Dont run - might as well finish mex as a small chance we wont run for long, the mex might absorb some damage, and the mex may generate a small bit of mass before dying
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and complete construciton of mex') end
        else
            --Run if on low health or shield
            local bAgainstEnemyACUAndMightWin = false

            --If we are closer to enemy base then require a greater threat differential
            local iDistToFriendlyBase
            local iDistToEnemyBase
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftClosestFriendlyBase]) == false then
                iDistToFriendlyBase = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], oACU:GetPosition())
                iDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], oACU:GetPosition())
            else
                --May e.g. be underwater and not have a LZ
                iDistToFriendlyBase = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M28Map.GetPlayerStartPosition(oACU:GetAIBrain()))
                iDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M28Map.GetPrimaryEnemyBaseLocation(oACU:GetAIBrain()))
            end
            local iPercentageToFriendlyBase = iDistToFriendlyBase / (iDistToFriendlyBase + iDistToEnemyBase)

            if iPlateau > 0 and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 then
                local tEnemyACU = EntityCategoryFilterDown(categories.COMMAND, tLZTeamData[M28Map.subrefTEnemyUnits])
                if M28Utilities.IsTableEmpty(tEnemyACU) == false then
                    if table.getn(tEnemyACU) == 1 then
                        if (tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0) + iACUThreat > 1.05 * (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) then
                            --If we are closer to enemy base then require a greater threat differential
                            if bDebugMessages == true then LOG(sFunctionRef..': tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; iPercentageToFriendlyBase='..(iPercentageToFriendlyBase or 'nil')..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 'nil')..'; iACUThreat='..(iACUThreat or 'nil')..'; iPlateau='..(iPlateau or 'nil')..'; ACU position='..repru(oACU:GetPosition())..'; Surface height of position='..GetSurfaceHeight(oACU:GetPosition()[1], oACU:GetPosition()[3])) end
                            if iPercentageToFriendlyBase < 0.6 or tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] + iACUThreat > 1.25 * tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] then
                                --Dont do this if enemy has air to ground threat and we dont have >= this in MAA
                                if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] == 0 or tLZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] >= 0.25 * tLZTeamData[M28Map.refiEnemyAirToGroundThreat] then
                                    bAgainstEnemyACUAndMightWin = true
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iACUThreat='..(iACUThreat or 'nil')..'; LZ enemy combat total='..(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; bOneEnemyACUInSameLZ='..tostring(bAgainstEnemyACUAndMightWin or false)..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]='..(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 'nil')..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 'nil')..'; iDistToFriendlyBase='..iDistToFriendlyBase..'; tLZTeamData[M28Map.refiModDistancePercent]='..tLZTeamData[M28Map.refiModDistancePercent]) end
            if (iACUThreat <= 500 or (iACUThreat <= 600 and (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 80)) and (not(bAgainstEnemyACUAndMightWin) or (oACU[refbUseACUAggressively] and (iACUThreat + (tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0) + 250 < (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)))) then
                if bDebugMessages == true then LOG(sFunctionRef..': ACU has low threat so want to run') end
                bWantToRun = true
            else
                local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oACU, true)
                if bDebugMessages == true then LOG(sFunctionRef..'; iCurSHield='..iCurShield..'; iMaxShield='..iMaxShield) end
                if iMaxShield > 0 and iCurShield <= (iMaxShield * 0.1) then
                    if bDebugMessages == true then LOG(sFunctionRef..': ACU shield is less than 10% so want to run') end
                    bWantToRun = true
                else
                    local iHealthPercent = M28UnitInfo.GetUnitHealthPercent(oACU)
                    local iPercentMod = 1
                    if oACU[refbUseACUAggressively] then iPercentMod = 0.5 end
                    if bDebugMessages == true then LOG(sFunctionRef..': iHealthPercent='..iHealthPercent) end
                    if (iHealthPercent <= 0.6 * iPercentMod or (iHealthPercent <= 0.75 * iPercentMod and (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 80)) and (not(bAgainstEnemyACUAndMightWin) or iHealthPercent <= 0.5 * iPercentMod) then
                        if bDebugMessages == true then LOG(sFunctionRef..': ACU is injured so want to run') end
                        bWantToRun = true
                    else
                        --Do we have a land zone?
                        if iPlateau > 0 and iLandZone > 0 then
                            local iEnemyAirToGroundNearbyThreat = tLZTeamData[M28Map.refiEnemyAirToGroundThreat]
                            local iFriendlyAAThreat = tLZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA]
                            --If there are big enemy threats then run if we arent adjacnet to a core LZ
                            local bAdjacentToCoreLZ = false
                            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                    if tAdjLZTeamData[M28Map.subrefLZbCoreBase] then bAdjacentToCoreLZ = true end
                                    iEnemyAirToGroundNearbyThreat = iEnemyAirToGroundNearbyThreat + tAdjLZTeamData[M28Map.refiEnemyAirToGroundThreat]
                                    iFriendlyAAThreat = iFriendlyAAThreat + tAdjLZTeamData[M28Map.subrefLZThreatAllyMAA]
                                end
                            end

                            if M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs] and (GetGameTimeSeconds() > 1260 or not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) or (iACUThreat < 3500 and (iACUThreat < 1700 or oACU[refiUpgradeCount] < 3 or M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar] or M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] > 0 or iHealthPercent < 0.9 or M28UnitInfo.GetUnitMaxHealthIncludingShield(oACU) < 20000 or (oACU.MyShield.GetHealth and (iHealthPercent < 0.98 or M28UnitInfo.GetUnitHealthAndShieldPercent(oACU) <= 0.95))))) then
                                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': No adjacent land zones and dangerous for ACU so want to run') end
                                    bWantToRun = true
                                else
                                    if not(bAdjacentToCoreLZ) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Not adjacent to core LZ so want to run as it is dangerous for ACUs now, and no nearby enemies to consider attacking') end
                                        bWantToRun = true
                                    end
                                end

                            end
                            if not(bWantToRun) then
                                --Run if non-full share or last ACU, are past 15m in-game, mod dist is >=0.4, and we are far from base
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to run when in assassination, moddist%='..(tLZTeamData[M28Map.refiModDistancePercent] or 'nil')..'; Upgrade count='..(oACU[refiUpgradeCount] or 'nil')..'; oACU='..(oACU.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oACU) or 'nil')..' owned by '..oACU:GetAIBrain().Nickname..'; iPercentageToFriendlyBase='..(iPercentageToFriendlyBase or 'nil')..'; iDistToFriendlyBase='..(iDistToFriendlyBase or 'nil')..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]='..(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 'nil')..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]='..(M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] or 'nil')..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech]='..(M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] or 'nil')..'; Assassination='..tostring(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar] or false)..'; Brain gross mass='..(oACU:GetAIBrain()[M28Economy.refiGrossMassBaseIncome] or 'nil')) end
                                if tLZTeamData[M28Map.refiModDistancePercent] >= 0.35 + 0.04*(oACU[refiUpgradeCount] or 0) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets]) and iPercentageToFriendlyBase >= 0.35 and iDistToFriendlyBase >= (200 + 75 * (oACU[refiUpgradeCount] or 0)) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 or (GetGameTimeSeconds() >= 900 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] > 1)) and (not(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) or oACU:GetAIBrain()[M28Economy.refiGrossMassBaseIncome] >= 25)
                                        --Exception - if enemy isnt at t3 land yet, and we have a mobile shield assigned to guncom ACU with full health
                                        and (oACU[refiUpgradeCount] == 0 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] >= 3 or oACU:GetAIBrain()[M28Economy.refiGrossMassBaseIncome] >= 30 or tLZTeamData[M28Map.refiModDistancePercent] >= 0.6 or not(M28UnitInfo.IsUnitValid(oACU[M28Land.refoAssignedMobileShield])) or M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.97) then
                                    bWantToRun = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': ACU owned by '..oACU:GetAIBrain().Nickname..' is getting a bit far from base so want to run, time='..GetGameTimeSeconds()) end
                                end
                            end
                            if not(bWantToRun) then
                                if bDebugMessages == true then LOG(sFunctionRef..': deciding if want to run from air, iEnemyAirToGroundNearbyThreat='..iEnemyAirToGroundNearbyThreat..'; iFriendlyAAThreat='..(iFriendlyAAThreat or 'nil')..'; iPercentageToFriendlyBase='..(iPercentageToFriendlyBase or 'nil')..'; iDistToFriendlyBase='..(iDistToFriendlyBase or 'nil')..'; Enemy team air to ground threat='..(M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refiEnemyAirToGroundThreat] or 'nil')..'; ACU health percent='..M28UnitInfo.GetUnitHealthPercent(oACU)) end
                                --If significant air to ground threat and not in adjacent to core base LZ then also run; however adjust if have nearby MAA
                                if (iEnemyAirToGroundNearbyThreat > (iFriendlyAAThreat or 0) * 2.5 or iEnemyAirToGroundNearbyThreat >= 1000) and not(bAdjacentToCoreLZ) and (iMaxShield == 0 or tLZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] < tLZTeamData[M28Map.refiEnemyAirToGroundThreat] * 0.5) and (iEnemyAirToGroundNearbyThreat > 150 or not(oACU[refbUseACUAggressively])) and (iEnemyAirToGroundNearbyThreat >= 300 or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 400 or iDistToFriendlyBase >= 300 or iPercentageToFriendlyBase > 0.5 or M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.75) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Significant air to ground threat so want to run, iFriendlyAAThreat='..(iFriendlyAAThreat or 0)) end
                                    bWantToRun = true
                                else
                                    local bHighHealthWithStealth = false
                                    if bDebugMessages == true then LOG(sFunctionRef..': If high health and stealth will just attack, otherwise will assess nearby enemy threat, ACU upgrade count='..(oACU[refiUpgradeCount] or 'nil')..'; ACU has stealth, nano, cor cloak='..tostring(oACU:HasEnhancement('StealthGenerator') or oACU:HasEnhancement('FAF_SelfRepairSystem') or oACU:HasEnhancement('CloakingGenerator'))..'; Does ACU have a valid assigned mobile stealth='..tostring(M28UnitInfo.IsUnitValid(oACU[M28Land.refoAssignedMobileStealth]))..';  tLZTeamData[M28Map.refiModDistancePercent]='..tLZTeamData[M28Map.refiModDistancePercent]..'; M28Map.iMapSize='..M28Map.iMapSize..'; M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]='..M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]..'; M28Team.tTeamData[iTeam][M28Team. refbAssassinationOrSimilar]='..tostring(M28Team.tTeamData[iTeam][M28Team. refbAssassinationOrSimilar])..'; ScenarioInfo.Options.Victory='..ScenarioInfo.Options.Victory..'; ScenarioInfo.Options.Share='..ScenarioInfo.Options.Share..'; Stealth condition combined='..tostring((oACU:HasEnhancement('StealthGenerator') or oACU:HasEnhancement('FAF_SelfRepairSystem') or oACU:HasEnhancement('CloakingGenerator') or (M28UnitInfo.IsUnitValid(oACU[M28Land.refoAssignedMobileStealth]) and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oACU[M28Land.refoAssignedMobileStealth]:GetPosition()) <= (oACU[M28Land.refoAssignedMobileStealth]:GetBlueprint().Intel.RadarStealthFieldRadius or 10))))) end
                                    if iHealthPercent >= 0.99 and oACU[refiUpgradeCount] >= 1 and (oACU:HasEnhancement('StealthGenerator') or oACU:HasEnhancement('FAF_SelfRepairSystem') or oACU:HasEnhancement('CloakingGenerator') or (M28UnitInfo.IsUnitValid(oACU[M28Land.refoAssignedMobileStealth]) and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oACU[M28Land.refoAssignedMobileStealth]:GetPosition()) <= (oACU[M28Land.refoAssignedMobileStealth]:GetBlueprint().Intel.RadarStealthFieldRadius or 10))) then
                                        bHighHealthWithStealth = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': Are stealthed and on high health so will ignore enemy threat and be aggressive unless in assassination') end
                                    end
                                    if not(bHighHealthWithStealth) or not(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) then
                                        local iEnemyNearbyThreat = (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                                        local iEnemyMobileNearbyDFThreat = (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)
                                        local aiBrain = oACU:GetAIBrain()
                                        local iTeam = aiBrain.M28Team
                                        local iAllyNearbyThreat
                                        if aiBrain[M28Economy.refiOurHighestLandFactoryTech] == 1 then
                                            iAllyNearbyThreat = math.max(0, (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0) - iACUThreat)
                                        else
                                            iAllyNearbyThreat = math.max(0, (tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0) - iACUThreat)
                                            if tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] then
                                                for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                                                    iAllyNearbyThreat = iAllyNearbyThreat + iThreat
                                                end
                                            end
                                        end
                                        local iAllyAdjacentZoneThreat = 0
                                        local iBestEnemyMobileDFRange = (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0)
                                        local iMaxLRThreat = (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0)
                                        local tOutrangedACUs = {}
                                        if iEnemyNearbyThreat > 0 and oACU[refiUpgradeCount] > 0 then
                                            if tLZTeamData[M28Map.subrefThreatEnemyDFStructures] > 0 and tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] < oACU[M28UnitInfo.refiDFRange] then iEnemyNearbyThreat = iEnemyNearbyThreat - (tLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0) end
                                            local tEnemyACUs = EntityCategoryFilterDown(categories.COMMAND, tLZTeamData[M28Map.subrefTEnemyUnits])
                                            if M28Utilities.IsTableEmpty(tEnemyACUs) == false then
                                                for iEnemy, oEnemy in tEnemyACUs do
                                                    if M28UnitInfo.IsUnitValid(oEnemy) then
                                                        if (oACU[M28UnitInfo.refiDFRange] or 0) > (oEnemy[M28UnitInfo.refiDFRange] or 0) then
                                                            table.insert(tOutrangedACUs, oEnemy)
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': About to consider adjacent zones, iEnemyMobileNearbyDFThreat before considering adjzones='..iEnemyMobileNearbyDFThreat) end


                                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                            --First get best enemy nearby range
                                            local tbZonesConsidered = {}
                                            local iDistUntilInRangeThreshold = 30 + tLZTeamData[M28Map.refiModDistancePercent] * 100
                                            local toDetailedCheckMobileDFUnits
                                            local bConsiderDetailedCheck = false
                                            local iCurDist
                                            if bHighHealthWithStealth or (oACU[refiUpgradeCount] >= 2 and (oACU[refiUpgradeCount] >= 3 or not(EntityCategoryContains(categories.AEON, oACU.UnitId)))) then bConsiderDetailedCheck = true end
                                            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                                tbZonesConsidered[iAdjLZ] = true
                                                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                                iBestEnemyMobileDFRange = math.max(iBestEnemyMobileDFRange, (tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0))
                                                if bDebugMessages == true then LOG(sFunctionRef..': Adding threat for iAdjLZ='..iAdjLZ..' with threat subrefTThreatEnemyCombatTotal='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal]..'; subrefLZThreatAllyMobileDFTotal='..(tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 'nil')..'; Mobile indirect='..(tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)..'; subrefiNearbyEnemyLongRangeDFThreat='..(tAdjLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 'nil')..'; Enemy best mobile DF range in this LZ='..(tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0)..'; subrefLZThreatEnemyMobileDFTotal='..(tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)) end
                                                iEnemyNearbyThreat = iEnemyNearbyThreat + (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                                                if bConsiderDetailedCheck and (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) >= 50 and iEnemyMobileNearbyDFThreat <= 6000 then
                                                    --Do more detailed check
                                                    for iUnit, oUnit in tAdjLZTeamData[M28Map.subrefTEnemyUnits] do
                                                        if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and not(oUnit.Dead) then
                                                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())
                                                            if iCurDist - oUnit[M28UnitInfo.refiDFRange] < iDistUntilInRangeThreshold and EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Including enemy mobile DF unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' as iCurDist='..iCurDist..'; and iCurDist less its range, i.e. its distance until in range of our ACU='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition()) - oUnit[M28UnitInfo.refiDFRange]..'; iDistUntilInRangeThreshold='..iDistUntilInRangeThreshold) end
                                                                if not(toDetailedCheckMobileDFUnits) then toDetailedCheckMobileDFUnits = {} end
                                                                table.insert(toDetailedCheckMobileDFUnits, oUnit)
                                                            end
                                                        end
                                                    end
                                                else
                                                    iEnemyMobileNearbyDFThreat = iEnemyMobileNearbyDFThreat + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)
                                                end
                                                if tAdjLZTeamData[M28Map.subrefThreatEnemyDFStructures] > 0 and tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] < oACU[M28UnitInfo.refiDFRange] then iEnemyNearbyThreat = iEnemyNearbyThreat - (tAdjLZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0) end
                                                iMaxLRThreat = math.max(iMaxLRThreat, (tAdjLZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0))
                                                --Include adjacent enemies assuming ACU has enough health that they are likely to be able to arrive
                                                if iHealthPercent >= 0.65 and (iHealthPercent >= 0.8 or oACU[refbUseACUAggressively] or (iHealthPercent >= 0.35 and M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 and not(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]))) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Including mobile DF threat from adjacent zone in ally total force, tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..(tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 'nil')) end
                                                    iAllyAdjacentZoneThreat = iAllyAdjacentZoneThreat + (tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0) * 0.9
                                                end
                                                if iMaxLRThreat == 0 and oACU[refiUpgradeCount] > 0 and (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) <= 10000 then
                                                    if iBestEnemyMobileDFRange < (oACU[M28UnitInfo.refiDFRange] or 0) then --this is testing the mobile range
                                                        --Exclude enemy ACU threat
                                                        local tEnemyACUs = EntityCategoryFilterDown(categories.COMMAND, tAdjLZTeamData[M28Map.subrefTEnemyUnits])
                                                        if M28Utilities.IsTableEmpty(tEnemyACUs) == false then
                                                            for iEnemy, oEnemy in tEnemyACUs do
                                                                if M28UnitInfo.IsUnitValid(oEnemy) then
                                                                    table.insert(tOutrangedACUs, oEnemy)
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                            if toDetailedCheckMobileDFUnits then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Threat of enemy mobile DF units from detailed check='..M28UnitInfo.GetCombatThreatRating(toDetailedCheckMobileDFUnits, true)..'; Threat when excluding ACUs='..M28UnitInfo.GetCombatThreatRating(EntityCategoryFilterDown(categories.ALLUNITS - categories.COMMAND, toDetailedCheckMobileDFUnits),true)..'; will add to iEnemyMobileNearbyDFThreat before this='..iEnemyMobileNearbyDFThreat) end
                                                iEnemyMobileNearbyDFThreat = iEnemyMobileNearbyDFThreat + M28UnitInfo.GetCombatThreatRating(toDetailedCheckMobileDFUnits, true)
                                            end
                                            --Consider nearby nonadjacent zones as well if ACU on less than 95% threat or has at least 5 mass income
                                            if not(oACU[refbUseACUAggressively]) and (iHealthPercent <= 0.95 or oACU:GetAIBrain()[M28Economy.refiGrossMassBaseIncome] >= 5) then
                                                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                                                    for iEntry, tSubtable in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering other zone='..tSubtable[M28Map.subrefLZNumber]..'; Travel dist='..tSubtable[M28Map.subrefLZTravelDist]..'; Considered already='..tostring(tbZonesConsidered[tSubtable[M28Map.subrefLZNumber]] or false)) end
                                                        if tSubtable[M28Map.subrefLZTravelDist] >= 150 then break
                                                        elseif not(tbZonesConsidered[tSubtable[M28Map.subrefLZNumber]]) then
                                                            --Is ACU close to this zone midpoint?
                                                            local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefLZNumber]]
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Dist from ACU to zone midpoint='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tAdjLZData[M28Map.subrefMidpoint])) end
                                                            if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tAdjLZData[M28Map.subrefMidpoint]) <= 100 then
                                                                local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                                                                iEnemyNearbyThreat = iEnemyNearbyThreat + math.max(0, (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) - (tAdjLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0))
                                                            end
                                                        end
                                                    end
                                                end
                                            end


                                            if bDebugMessages == true then LOG(sFunctionRef..': iBestEnemyMobileDFRange='..iBestEnemyMobileDFRange..'; oACU[M28UnitInfo.refiDFRange]='..oACU[M28UnitInfo.refiDFRange]..'; iAllyNearbyThreat pre update for adj='..iAllyNearbyThreat..'; iAllyAdjacentZoneThreat='..iAllyAdjacentZoneThreat) end
                                            --Include ally threat if we arent outranged or our relatively near our base with a gun upgrade
                                            if (iBestEnemyMobileDFRange <= oACU[M28UnitInfo.refiDFRange] and (oACU[refbUseACUAggressively] or M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1)) or (iPercentageToFriendlyBase <= 0.4 and iDistToFriendlyBase <= 275 and (oACU[refiUpgradeCount] or 0) >= 1 and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.75)  then
                                                --Have nearby allies so can be more aggressive
                                                iAllyNearbyThreat = iAllyNearbyThreat + iAllyAdjacentZoneThreat
                                            end
                                        end

                                        --If adjacent water zones then include enemy surface threat units if ACU is damaged
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering nearby water zone threats, is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
                                        if not(bHighHealthWithStealth) and (iHealthPercent <= 0.95 or M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                                            local tWaterEnemiesNearACU = {}
                                            local iAdjWZ
                                            local iBestEnemyDFWaterUnitRange = 0
                                            for _, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                                                iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                                                local tAdjWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjWZ='..iAdjWZ..'; Enemy surface threat in this zone='..(tAdjWZTeamData[M28Map.subrefWZThreatEnemyVsSurface] or 'nil')) end
                                                if (tAdjWZTeamData[M28Map.subrefWZThreatEnemyVsSurface] or 0) > 100 then
                                                    local tEnemiesInWZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategoryAmphibiousCombat, tAdjWZTeamData[M28Map.subrefTEnemyUnits])
                                                    if M28Utilities.IsTableEmpty(tEnemiesInWZ) == false then
                                                        for iEnemy, oEnemy in tEnemiesInWZ do
                                                            if bDebugMessages == true and not(oEnemy.Dead) then LOG(sFunctionRef..': Considering water zone oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; Dist to ACU='..M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oACU:GetPosition())..'; Combat range='..oEnemy[M28UnitInfo.refiCombatRange]) end
                                                            if not(oEnemy.Dead) and (oEnemy[M28UnitInfo.refiDFRange] or 0) >= 20 and M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oACU:GetPosition()) - oEnemy[M28UnitInfo.refiDFRange] <= 20 then
                                                                table.insert(tWaterEnemiesNearACU, oEnemy)
                                                                iBestEnemyDFWaterUnitRange = math.max(oEnemy[M28UnitInfo.refiDFRange], iBestEnemyDFWaterUnitRange)
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                            if M28Utilities.IsTableEmpty(tWaterEnemiesNearACU) == false then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Threat of water enemies near ACU='..M28UnitInfo.GetCombatThreatRating(tWaterEnemiesNearACU, true, false)..'; iBestEnemyDFWaterUnitRange='..iBestEnemyDFWaterUnitRange..'; Will increase enemy threat value if they significantly outrange us') end
                                                if iBestEnemyDFWaterUnitRange > math.max(40, (oACU[M28UnitInfo.refiDFRange] or 0) + 5) then
                                                    iEnemyNearbyThreat = iEnemyNearbyThreat + M28UnitInfo.GetCombatThreatRating(tWaterEnemiesNearACU, true, false) * 1.5
                                                else
                                                    iEnemyNearbyThreat = iEnemyNearbyThreat + M28UnitInfo.GetCombatThreatRating(tWaterEnemiesNearACU, true, false) * 1.5
                                                end
                                            end
                                        end
                                        if iMaxLRThreat > 0 then
                                            iEnemyNearbyThreat = iEnemyNearbyThreat + iMaxLRThreat
                                            iEnemyMobileNearbyDFThreat = iEnemyMobileNearbyDFThreat + iMaxLRThreat
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to reduce enemy mobileDF threat for enemy ACU threat, iMaxLRThreat='..iMaxLRThreat..'; Is tOutrangedACUs empty='..tostring(M28Utilities.IsTableEmpty(tOutrangedACUs))..'; iBestEnemyMobileDFRange='..iBestEnemyMobileDFRange..'; oACU[M28UnitInfo.refiDFRange]='..oACU[M28UnitInfo.refiDFRange]) end
                                        if iMaxLRThreat == 0 and M28Utilities.IsTableEmpty(tOutrangedACUs) == false and (iBestEnemyMobileDFRange < oACU[M28UnitInfo.refiDFRange] or (iHealthPercent >= 0.9 and not(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]))) then
                                            local iAmountToReduceThreatBy
                                            local iCurThreatReduction
                                            for iEnemyACU, oEnemyACU in tOutrangedACUs do
                                                if oEnemyACU:IsUnitState('Building') or (oEnemyACU:IsUnitState('Upgrading') and oEnemyACU:GetWorkProgress() <= 0.95) then
                                                    if M28UnitInfo.CanSeeUnit(oACU:GetAIBrain(), oEnemyACU, false) then
                                                        iCurThreatReduction = 0.9
                                                    elseif M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oEnemyACU:GetPosition()) > 4 + (oEnemyACU[M28UnitInfo.refiDFRange] or 0) and (tLZTeamData[M28Map.refiRadarCoverage] >= 30 or (M28UnitInfo.IsUnitValid(oACU[M28Land.refoAssignedLandScout]) and M28Utilities.GetDistanceBetweenPositions(oACU[M28Land.refoAssignedLandScout]:GetPosition(), oACU:GetPosition()) <= 25) and (oEnemyACU[refiUpgradeCount] == 0 or not(EntityCategoryContains(categories.CYBRAN, oEnemyACU.UnitId)) or (not(oEnemyACU:HasEnhancement('StealthGenerator')) and not(oEnemyACU:HasEnhancement('CloakingGenerator')) and not(oEnemyACU:HasEnhancement('FAF_SelfRepairSystem'))))) then
                                                        iCurThreatReduction = 0.8
                                                    else
                                                        iCurThreatReduction = 0.7
                                                    end
                                                elseif M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oEnemyACU:GetPosition()) > 4 + (oEnemyACU[M28UnitInfo.refiDFRange] or 0) then
                                                    if M28UnitInfo.CanSeeUnit(oACU:GetAIBrain(), oEnemyACU, false) then
                                                        iCurThreatReduction = 0.8
                                                    elseif tLZTeamData[M28Map.refiRadarCoverage] >= 30 or (M28UnitInfo.IsUnitValid(oACU[M28Land.refoAssignedLandScout]) and M28Utilities.GetDistanceBetweenPositions(oACU[M28Land.refoAssignedLandScout]:GetPosition(), oACU:GetPosition()) <= 25) and (oEnemyACU[refiUpgradeCount] == 0 or not(EntityCategoryContains(categories.CYBRAN, oEnemyACU.UnitId)) or (not(oEnemyACU:HasEnhancement('StealthGenerator')) and not(oEnemyACU:HasEnhancement('CloakingGenerator')) and not(oEnemyACU:HasEnhancement('FAF_SelfRepairSystem')))) then
                                                        iCurThreatReduction = 0.7
                                                    else iCurThreatReduction = 0.4
                                                    end
                                                else iCurThreatReduction = 0
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': Reducing enemy threat by ACU threat reduction, enemy ACU owner='..oEnemyACU:GetAIBrain().Nickname..'; iCurThreatReduction='..iCurThreatReduction..'; ACU threat (100%)='..M28UnitInfo.GetCombatThreatRating({ oEnemyACU}, true, false)..'; Enemy ACU state='..M28UnitInfo.GetUnitState(oEnemyACU)) end
                                                if iCurThreatReduction > 0 then
                                                    iAmountToReduceThreatBy = M28UnitInfo.GetCombatThreatRating({ oEnemyACU}, true, false) * iCurThreatReduction
                                                    iEnemyNearbyThreat = iEnemyNearbyThreat - iAmountToReduceThreatBy
                                                    iEnemyMobileNearbyDFThreat = iEnemyMobileNearbyDFThreat - iAmountToReduceThreatBy
                                                end
                                            end
                                            --Be more aggressive if enemy ACUs that we outrange (to the point of being dangerous) if not in assassination
                                            if not(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) and iHealthPercent >= 0.9 then iEnemyNearbyThreat = iEnemyNearbyThreat - M28UnitInfo.GetCombatThreatRating(tOutrangedACUs, true, false) * 0.4 end
                                        end

                                        if bDebugMessages == true then LOG(sFunctionRef..': iEnemyNearbyThreat='..iEnemyNearbyThreat..'; iACUThreat='..iACUThreat..'; iEnemyMobileNearbyDFThreat='..iEnemyMobileNearbyDFThreat..'; bAgainstEnemyACUAndMightWin='..tostring(bAgainstEnemyACUAndMightWin or false)..'; iPercentageToFriendlyBase='..iPercentageToFriendlyBase..'; bAdjacentToCoreLZ='..tostring(bAdjacentToCoreLZ)..'; iAllyNearbyThreat='..iAllyNearbyThreat..'; iMaxLRThreat='..iMaxLRThreat..'; ACU cur health+shield='..M28UnitInfo.GetUnitCurHealthAndShield(oACU)..'; ACU cur health+shield%='..M28UnitInfo.GetUnitHealthAndShieldPercent(oACU)) end
                                        --Run if enemy has a really large threat (regardless of if we think we can beat it)
                                        if iEnemyNearbyThreat > math.min(math.max(iACUThreat * 2, iACUThreat * 0.75 + iAllyNearbyThreat), 4000 + 2000 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and (iEnemyNearbyThreat > math.max(iACUThreat * 3, iACUThreat + iAllyNearbyThreat) or ((not(bAgainstEnemyACUAndMightWin) and iPercentageToFriendlyBase >= 0.35 and not(bAdjacentToCoreLZ) and not(oACU[refbUseACUAggressively]))))
                                                and (iACUThreat < iEnemyMobileNearbyDFThreat * 1.1 or iACUThreat * 3 < iEnemyNearbyThreat)
                                                --In teamgames want ACU with shield to be more aggressive
                                                and (iACUThreat < 1500 or oACU[refiUpgradeCount] <= 2 or M28UnitInfo.GetUnitHealthAndShieldPercent(oACU) <= 0.9 or M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar] or M28UnitInfo.GetUnitCurHealthAndShield(oACU) <= 18000 or GetGameTimeSeconds() >= 1500 or tLZTeamData[M28Map.refiModDistancePercent] >= 0.75 or (tLZTeamData[M28Map.refiModDistancePercent] >= 0.3 + 0.1 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy has too large a threat so will run') end
                                            bWantToRun = true
                                        else
                                            --Run if we dont have enough threat to easily beat enemy threat in all adjacent LZs
                                            local iACUFactor = 0.5
                                            if bAgainstEnemyACUAndMightWin then iACUFactor = 1
                                            elseif bAdjacentToCoreLZ then iACUFactor = 0.9
                                            elseif iPercentageToFriendlyBase <= 0.4 then iACUFactor = 0.8
                                            elseif iPercentageToFriendlyBase <= 0.6 then
                                                if M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.9 then iACUFactor = 0.7
                                                else iACUFactor = 0.6
                                                end
                                            end
                                            --Increase ACU factor if we have gun and good health, and enemy lacks T3 land/high health units
                                            if bDebugMessages == true then LOG(sFunctionRef..': ACU health%='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; Highest enemy ground tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]..'; Highest enemy air tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech]..'; Air to gorund threat='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]) end
                                            if M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.8 and (oACU[refiUpgradeCount] or 0) >= 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] < 3 and  M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] < 3 and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] <= 1500 then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Guncom with decent health and enemy doesnt have T3 land or air or significant air to ground threat so increasing factor') end
                                                iACUFactor = iACUFactor * 1.1
                                                if iPercentageToFriendlyBase <= 0.45 then
                                                    iACUFactor = iACUFactor * 1.1
                                                end
                                            end

                                            --Decrease ACU factor if we have high mass income and are in assassination and dont have many upgrades
                                            local iAllyNearbyThreatFactor = 1
                                            if oACU:GetAIBrain()[M28Economy.refiGrossMassBaseIncome] >= 10 and M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar] and oACU[refiUpgradeCount] < 3 then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Reducing ACU factor as are in assassination mode or similar') end
                                                if oACU[refiUpgradeCount] > 0 and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.95 and (M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][3] or 0) <= 1 and M28Conditions.GetHighestOtherTeamT3MexCount(iTeam) <= 1 and tLZTeamData[M28Map.refiModDistancePercent] <= 0.35 then
                                                    iACUFactor = iACUFactor * 0.85
                                                else
                                                    iACUFactor = iACUFactor * 0.6
                                                    iAllyNearbyThreatFactor = 0.8
                                                end
                                            end

                                            --Increase ACU factor if enemy lacks much mobile threat
                                            if iEnemyMobileNearbyDFThreat < 0.5 * iEnemyNearbyThreat and iEnemyMobileNearbyDFThreat * 1.2 < iACUThreat and not(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) then iACUFactor = iACUFactor * 1.25 end
                                            if bHighHealthWithStealth then iACUFactor = iACUFactor * 1.2 end

                                            --Increase ACU factor if enemy has ACU but we outrange it and all other mobile DF units (this is in addition to the enemy threat reduction above)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will adjust ACUFactor if we outrange mobile enemies and they have an outranged ACU in this or adjacent zone, iBestEnemyMobileDFRange='..iBestEnemyMobileDFRange..'; oACU[M28UnitInfo.refiDFRange]='..(oACU[M28UnitInfo.refiDFRange] or 'nil')..'; Is tOutrangedACUs empty='..tostring(M28Utilities.IsTableEmpty(tOutrangedACUs))..'; iHealthPercent='..iHealthPercent) end
                                            if iBestEnemyMobileDFRange < (oACU[M28UnitInfo.refiDFRange] or 0) and M28Utilities.IsTableEmpty(tOutrangedACUs) == false and iHealthPercent >= 0.8 and not(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) then
                                                --Double check we arent so close to the enemy ACU that it can soon hit us
                                                local bEnemyACUAlmostAbleToShootUs = false
                                                for iEnemyACU, oEnemyACU in tOutrangedACUs do
                                                    if oEnemyACU[M28UnitInfo.refiDFRange] and M28Utilities.GetDistanceBetweenPositions(oEnemyACU:GetPosition(), oACU:GetPosition()) - oEnemyACU[M28UnitInfo.refiDFRange] <= 4 then
                                                        bEnemyACUAlmostAbleToShootUs = true
                                                        break
                                                    end
                                                end
                                                if not(bEnemyACUAlmostAbleToShootUs) then
                                                    if oACU[refiUpgradeCount] >= 2 and (oACU[refiUpgradeCount] >= 3 or not(EntityCategoryContains(categories.AEON, oACU.UnitId))) and iHealthPercent >= 0.9 then
                                                        iACUFactor = iACUFactor * 1.3
                                                    else
                                                        iACUFactor = iACUFactor * 1.15
                                                    end
                                                end
                                            end

                                            --Increase ACU factor in teamgame if have shield
                                            if not(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) and oACU[refiUpgradeCount] >= 3 and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 2 and ((oACU.MyShield.GetHealth and iHealthPercent >= 0.98 and M28UnitInfo.GetUnitHealthAndShieldPercent(oACU) >= 0.9) or (oACU:GetMaxHealth() >= 26000 and iHealthPercent >= 0.9)) then
                                                iACUFactor = iACUFactor + iACUFactor * 0.4 / iACUFactor
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will be very aggressive due to ACU having shield or very high health') end
                                            end

                                            --NOTE: subrefLZTThreatAllyCombatTotal includes the ACU threat
                                            if not(oACU[refbUseACUAggressively]) and (iACUThreat * iACUFactor + iAllyNearbyThreat * iAllyNearbyThreatFactor < iEnemyNearbyThreat) and iEnemyMobileNearbyDFThreat >= iACUThreat * iACUFactor then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will run as iACUThreat='..iACUThreat..'; iACUFactor='..iACUFactor..'; tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]='..(tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 'nil')..'; iEnemyNearbyThreat='..iEnemyNearbyThreat..'; Ally mobile DF total='..(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0)..'; iAllyNearbyThreat='..iAllyNearbyThreat) end
                                                bWantToRun = true
                                                --Be more cautious in assassination mode
                                            elseif iHealthPercent < 0.75 and not(oACU[refbUseACUAggressively]) and not(bWantToRun) and M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar] and iACUThreat * math.min(1, iACUFactor) < iEnemyNearbyThreat * 1.25 and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) >= 25 then
                                                bWantToRun = true
                                                if bDebugMessages == true then LOG(sFunctionRef..': We think we can win but our ACU is getting low health and if we lose it we lose the game so will retreat') end
                                            else
                                                --If enemy has an upgrading or upgraded ACU relatively nearby and we dont have any upgrades then run - think we already ahve this covered in earlier step
                                                --[[local bEnemyHasNearbyUpgradedACU = false
                                                local iCurEnemyACUDist
                                                if (oACU[refiUpgradeCount] or 0) == 0 and M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU] then
                                                    local iClosestEnemyACU = 10000

                                                    for iEnemyACU, oEnemyACU in M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs] do
                                                        iCurEnemyACUDist = M28Utilities.GetDistanceBetweenPositions(oEnemyACU:GetPosition(), oACU:GetPosition())
                                                        if iCurEnemyACUDist < iClosestEnemyACU then iClosestEnemyACU = iCurEnemyACUDist end
                                                    end
                                                    if iClosestEnemyACU <= 54 then bEnemyHasNearbyUpgradedACU = true end
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': Checking if enemy has nearby guncom, ACU upgrade count='..(oACU[refiUpgradeCount] or 0)..'; Enemy has upgraded ACU='..tostring(M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU])..'; iClosestEnemyACU='..(iClosestEnemyACU or 'nil')..'; bEnemyHasNearbyUpgradedACU='..tostring(bEnemyHasNearbyUpgradedACU)) end
                                                if bEnemyHasNearbyUpgradedACU then
                                                    bWantToRun = true
                                                else--]]

                                                --If enemy units are between us and the closest friendly base then also want to run; also run if enemy has multiple T2+ PD as part of the enemy threat and we lack upgrades
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if should run from PD, or if enemies closer to our base than we are, iEnemyNearbyThreat='..(iEnemyNearbyThreat or 'nil')..'; oACU[refbUseACUAggressively]='..tostring(oACU[refbUseACUAggressively] or false)..'; ACU upgrade count='..(oACU[refiUpgradeCount] or 0)..'; tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] ='..(tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 'nil')) end
                                                if iEnemyNearbyThreat > 800 or (iEnemyNearbyThreat > 400 and not(oACU[refbUseACUAggressively])) then
                                                    --Enemy PD check - if enemy has T2+/long range PD and we lack 3 upgrades, then make it more likely we run
                                                    local bEnemyHasPDOrSignificantACUs = false
                                                    local iAggressiveFactor = 1
                                                    if oACU[refbUseACUAggressively] and iPercentageToFriendlyBase <= 0.3 then iAggressiveFactor = 1.5 end
                                                    --Decrease ACU factor and aggressive factor if enemy has more ACUs than us that have similar range to us and arent close to our base, and has significant nearby threat
                                                    if tLZTeamData[M28Map.refiModDistancePercent] >= 0.25 and iEnemyNearbyThreat >= 1200 then
                                                        local iNearbyEnemyACUWithGoodRangeCount = 0
                                                        local iTotalNearbyEnemyACUCount = 0
                                                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) == false then
                                                            for iEnemyACU, oEnemyACU in M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs] do
                                                                if M28UnitInfo.IsUnitValid(oEnemyACU) then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Dist of enemy ACU owned by brain '..oEnemyACU:GetAIBrain().Nickname..' to us='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oEnemyACU:GetPosition())..'; Their combat range='..oEnemyACU[M28UnitInfo.refiCombatRange]) end
                                                                    if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oEnemyACU:GetPosition()) <= 30 + oEnemyACU[M28UnitInfo.refiCombatRange] then
                                                                        iTotalNearbyEnemyACUCount = iTotalNearbyEnemyACUCount + 1
                                                                        if oEnemyACU[M28UnitInfo.refiCombatRange] >= oACU[M28UnitInfo.refiDFRange] - 3 then
                                                                            iNearbyEnemyACUWithGoodRangeCount = iNearbyEnemyACUWithGoodRangeCount + 1
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                            if iTotalNearbyEnemyACUCount >= 2 then
                                                                local iNearbyFriendlyACUWithGoodRangeCount = 0
                                                                local iNearbyFriendlyACUCount = 0
                                                                --Get nearby friendly ACUs
                                                                for iFriendlyACU, oFriendlyACU in M28Team.tTeamData[iTeam][M28Team.reftM28ACUs] do
                                                                    if M28UnitInfo.IsUnitValid(oFriendlyACU) then
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Dist of friendly ACU owned by brain '..oFriendlyACU:GetAIBrain().Nickname..' to us='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oFriendlyACU:GetPosition())..'; Their combat range='..oFriendlyACU[M28UnitInfo.refiCombatRange]) end
                                                                        if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oFriendlyACU:GetPosition()) <= 20 + oFriendlyACU[M28UnitInfo.refiCombatRange] then
                                                                            iNearbyFriendlyACUCount = iNearbyFriendlyACUCount + 1
                                                                            if oFriendlyACU[M28UnitInfo.refiCombatRange] >= oACU[M28UnitInfo.refiDFRange] - 3 then
                                                                                iNearbyFriendlyACUWithGoodRangeCount = iNearbyFriendlyACUWithGoodRangeCount + 1
                                                                            end
                                                                        end
                                                                    end
                                                                end
                                                                if iNearbyEnemyACUWithGoodRangeCount >= 4 or iNearbyEnemyACUWithGoodRangeCount > iNearbyFriendlyACUCount or (iNearbyEnemyACUWithGoodRangeCount >= iNearbyFriendlyACUWithGoodRangeCount and iTotalNearbyEnemyACUCount > iNearbyFriendlyACUWithGoodRangeCount) then
                                                                    iACUFactor = iACUFactor * 0.8
                                                                    iAggressiveFactor = math.min(0.9, iAggressiveFactor * 0.7)
                                                                    bEnemyHasPDOrSignificantACUs = true
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': will be significantly more cautious given enemy has more ACUs') end
                                                                elseif iTotalNearbyEnemyACUCount > iNearbyFriendlyACUCount then
                                                                    iACUFactor = iACUFactor * 0.9
                                                                    iAggressiveFactor = iAggressiveFactor * 0.85
                                                                    bEnemyHasPDOrSignificantACUs = true
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will be a bit more cautious given more enemy ACUs than friendly ACUs') end
                                                                end
                                                                if bDebugMessages == true then LOG(sFunctionRef..': iNearbyFriendlyACUCount='..iNearbyFriendlyACUCount..'; iNearbyEnemyACUWithGoodRangeCount='..iNearbyEnemyACUWithGoodRangeCount..'; iTotalNearbyEnemyACUCount='..iTotalNearbyEnemyACUCount..'; iACUFactor='..iACUFactor..'; iAggressiveFactor='..iAggressiveFactor..'; Adjusted enemy threat='..iEnemyNearbyThreat / iAggressiveFactor..'; Our allied threat='..iACUThreat * iACUFactor + iAllyNearbyThreat) end
                                                            end
                                                        end
                                                        if not(bEnemyHasPDOrSignificantACUs) then
                                                            local iNearbyEnemyLRDFThreat = 0
                                                            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                                                                for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                                                                    if iRange > oACU[M28UnitInfo.refiDFRange] then
                                                                        iNearbyEnemyLRDFThreat = iNearbyEnemyLRDFThreat + iThreat
                                                                    end
                                                                end
                                                            end
                                                            if iNearbyEnemyLRDFThreat >= 3000 * iAggressiveFactor and (iACUThreat <= 5000 or iNearbyEnemyLRDFThreat >= iACUThreat * iAggressiveFactor or M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) then
                                                                bEnemyHasPDOrSignificantACUs = true
                                                            elseif iNearbyEnemyLRDFThreat >= 700 and iTotalNearbyEnemyACUCount >= 1 then
                                                                bEnemyHasPDOrSignificantACUs = true
                                                            end
                                                            if bDebugMessages == true then LOG(sFunctionRef..': bEnemyHasPDOrSignificantACUs='..tostring(bEnemyHasPDOrSignificantACUs or false)..'; iNearbyEnemyLRDFThreat='..iNearbyEnemyLRDFThreat..'; iACUThreat='..iACUThreat) end
                                                        end

                                                    elseif iPercentageToFriendlyBase > 0.3 then
                                                        --Alternative T2 check - consider running if lots of T2 PD threat (vs above which just runs if any) - Check how many T2 PD are nearby (if any), along with shields, and dont be aggressive if we are almost in their range
                                                        local iNearbyEnemyLRDFThreat = 0
                                                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                                                            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                                                                if iRange > oACU[M28UnitInfo.refiDFRange] then
                                                                    iNearbyEnemyLRDFThreat = iNearbyEnemyLRDFThreat + iThreat
                                                                end
                                                            end
                                                        end

                                                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                                            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                                                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                                                if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                                                                    for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                                                                        iNearbyEnemyLRDFThreat = iNearbyEnemyLRDFThreat + iThreat
                                                                    end
                                                                end
                                                            end
                                                        end
                                                        if bDebugMessages == true then LOG(sFunctionRef..': iNearbyEnemyLRDFThreat='..iNearbyEnemyLRDFThreat..'; bWantToRun='..tostring(bWantToRun or false)..'; iACUThreat='..iACUThreat) end
                                                        if iNearbyEnemyLRDFThreat >= 3000 and (iACUThreat <= 5000 or iNearbyEnemyLRDFThreat >= iACUThreat or M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) then
                                                            bWantToRun = true
                                                        elseif iNearbyEnemyLRDFThreat >= 1750 and iNearbyEnemyLRDFThreat >= iACUThreat * 0.7 then
                                                            --Do more precise check of whether we are in range of the enemy based on nearest enemies in this zone and adjacent zones
                                                            local toLRUnits = {}
                                                            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                                                                for iUnit, oUnit in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                                                                    if not(oUnit.Dead) and oUnit[M28UnitInfo.refiDFRange] > oACU[M28UnitInfo.refiDFRange] then
                                                                        table.insert(toLRUnits, oUnit)
                                                                    end
                                                                end
                                                            end
                                                            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                                                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                                                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                                                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                                                                        for iUnit, oUnit in tAdjLZTeamData[M28Map.reftoNearestDFEnemies] do
                                                                            if not(oUnit.Dead) and oUnit[M28UnitInfo.refiDFRange] > oACU[M28UnitInfo.refiDFRange] then
                                                                                table.insert(toLRUnits, oUnit)
                                                                            end
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Size of toLRUnits='..table.getn(toLRUnits)..'; Are we close to these='..tostring(M28Conditions.CloseToEnemyUnit(oACU:GetPosition(), toLRUnits, 5, iTeam, true, nil, nil, nil, nil, false))) end
                                                            if M28Conditions.CloseToEnemyUnit(oACU:GetPosition(), toLRUnits, 5, iTeam, true, nil, nil, nil, nil, false) then
                                                                bWantToRun = true
                                                            end
                                                        end
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Deciding if want to run after checking if enemy has PD or significnat ACUs, bEnemyHasPDOrSignificantACUs='..tostring(bEnemyHasPDOrSignificantACUs)..'; iEnemyNearbyThreat='..iEnemyNearbyThreat..'; iAggressiveFactor='..iAggressiveFactor..'; iACUFactor='..iACUFactor..'; iACUThreat='..iACUThreat..'; iAllyNearbyThreat='..iAllyNearbyThreat) end
                                                    local iOptionalNearlyInRangeAlliedDFThreat
                                                    if bEnemyHasPDOrSignificantACUs and iAllyNearbyThreat > 0 and tLZTeamData[M28Map.refiModDistancePercent] >= 0.25 and M28UnitInfo.GetUnitHealthAndShieldPercent(oACU) <= 0.95 then
                                                        --Be more cautious if enemy has ACUs or tanks - just because we have units nearby they may not be able to help, or may be other friendly ACUs who are retreating
                                                        iOptionalNearlyInRangeAlliedDFThreat = 0
                                                        local toNearbyFriendlyCombatUnits = {}
                                                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedCombatUnits]) == false then
                                                            for iUnit, oUnit in tLZTeamData[M28Map.subrefLZTAlliedCombatUnits] do
                                                                if oUnit[M28UnitInfo.refiCombatRange] > 0 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition()) - oUnit[M28UnitInfo.refiCombatRange] <= 10 and (not(oUnit[refiTimeLastWantedToRun]) or GetGameTimeSeconds() - oUnit[refiTimeLastWantedToRun] >= 5) and not(oUnit == oACU) then
                                                                    table.insert(toNearbyFriendlyCombatUnits, oUnit)
                                                                end
                                                            end
                                                        end
                                                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                                            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                                                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                                                if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZTAlliedCombatUnits]) == false then
                                                                    for iUnit, oUnit in tAdjLZTeamData[M28Map.subrefLZTAlliedCombatUnits] do
                                                                        if oUnit[M28UnitInfo.refiCombatRange] > 0 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition()) - oUnit[M28UnitInfo.refiCombatRange] <= 10 and (not(oUnit[refiTimeLastWantedToRun]) or GetGameTimeSeconds() - oUnit[refiTimeLastWantedToRun] >= 5) and not(oUnit == oACU) then
                                                                            table.insert(toNearbyFriendlyCombatUnits, oUnit)
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                        iOptionalNearlyInRangeAlliedDFThreat = M28UnitInfo.GetCombatThreatRating(toNearbyFriendlyCombatUnits, false)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': iOptionalNearlyInRangeAlliedDFThreat='..iOptionalNearlyInRangeAlliedDFThreat..'; iAllyNearbyThreat='..iAllyNearbyThreat) end
                                                    end
                                                    if iEnemyNearbyThreat >= 1200 and iACUThreat <= 5000 and ((oACU[refiUpgradeCount] or 0) < 3 or EntityCategoryContains(categories.UEF + categories.AEON, oACU.UnitId) or iEnemyNearbyThreat >= 4000) and iEnemyNearbyThreat / iAggressiveFactor > (iACUThreat * iACUFactor + (iOptionalNearlyInRangeAlliedDFThreat or iAllyNearbyThreat)) then
                                                        if not(bEnemyHasPDOrSignificantACUs) then
                                                            local iBestEnemyThreatRange = 0
                                                            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                                                                for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                                                                    iBestEnemyThreatRange = math.max(iBestEnemyThreatRange, iRange)
                                                                end
                                                            end
                                                            if iBestEnemyThreatRange < 40 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                                                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                                                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                                                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                                                                        for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                                                                            iBestEnemyThreatRange = math.max(iBestEnemyThreatRange, iRange)
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Checking highest enemy PD range nearby, iBestEnemyThreatRange='..(iBestEnemyThreatRange or 'nil')) end
                                                            if iBestEnemyThreatRange >= 40 then
                                                                bEnemyHasPDOrSignificantACUs = true
                                                            end
                                                        end
                                                        if bEnemyHasPDOrSignificantACUs then bWantToRun = true end
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if want to run due to PD or multiple enemy ACUs, bWantToRun='..tostring(bWantToRun)..'; iAggressiveFactor='..iAggressiveFactor) end
                                                    if not(bWantToRun) then
                                                        local iACUDistToClosestFriendlyBase = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                                                        local tEnemyCombatUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandCombat,  tLZTeamData[M28Map.subrefTEnemyUnits])
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Will check if we have enemy units in this zone that are closer to our base than our ACU and which are in range of our ACU (i.e. suggesting enemy is trying to ambush/kill our ACU - dont want to just run if they are closer to base as zone might be large and ACU could e.g. be approaching the units from another direction so we want acu to attack them), is table of enemy combat units empty='..tostring(M28Utilities.IsTableEmpty(tEnemyCombatUnits))) end
                                                        if M28Utilities.IsTableEmpty(tEnemyCombatUnits) == false then
                                                            for iUnit, oUnit in tEnemyCombatUnits do
                                                                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) < iACUDistToClosestFriendlyBase and (not(EntityCategoryContains(categories.COMMAND, oUnit.UnitId)) or oUnit[M28UnitInfo.refiDFRange] > oACU[M28UnitInfo.refiDFRange]) then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': iEnemyNearbyThreat='..iEnemyNearbyThreat..'; iACUDistToClosestFriendlyBase='..iACUDistToClosestFriendlyBase..'; Nearest enemy threat='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Dist of that to our base='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])) end
                                                                    if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition()) <= oACU[M28UnitInfo.refiDFRange] - 3 then
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy is within 3 of us so want to run') end
                                                                        bWantToRun = true
                                                                        break
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        else
                            --No land zone - if we have no order then return to base
                            if bDebugMessages == true then LOG(sFunctionRef..': No land zone so will return to base if have no orders, order count='..(oACU[M28Orders.refiOrderCount] or 'nil')) end
                            if oACU[M28Orders.refiOrderCount] == 0 then
                                bWantToRun = true
                            else
                                --Is this water zone dangerous, and are we trying to travel to water?
                                local tOrderTarget
                                if M28UnitInfo.IsUnitValid(oACU[M28Orders.reftiLastOrders][1][M28Orders.subrefoOrderUnitTarget]) then tOrderTarget = oACU[M28Orders.reftiLastOrders][1][M28Orders.subrefoOrderUnitTarget]:GetPosition()
                                else tOrderTarget = oACU[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]
                                end
                                if M28Utilities.IsTableEmpty(tOrderTarget) == false then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Terrain height of target='..NavUtils.GetTerrainHeight(tOrderTarget[1], tOrderTarget[3])..'; Map water height='..M28Map.iMapWaterHeight) end
                                    if NavUtils.GetTerrainHeight(tOrderTarget[1], tOrderTarget[3]) < M28Map.iMapWaterHeight then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Are trying to move underwater, will run instead if the water is dangerous and we lack antinavy attack') end
                                        local iAntiNavyThreat = (tLZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] or 0)
                                        if iAntiNavyThreat >= 800 and (oACU[M28UnitInfo.refiAntiNavyRange] or 0) < 10 then
                                            bWantToRun = true
                                        elseif M28Utilities.IsTableEmpty(tLZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                                            for _, iAdjWZ in tLZData[M28Map.subrefWZAdjacentWaterZones] do
                                                local tAdjWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                                                iAntiNavyThreat = iAntiNavyThreat + (tAdjWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] or 0)
                                            end
                                            if iAntiNavyThreat >= 1500 and ((oACU[M28UnitInfo.refiAntiNavyRange] or 0) < 10 or iAntiNavyThreat >= 9000 or (iAntiNavyThreat >= 6000 and M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.9)) then
                                                bWantToRun = true
                                                if bDebugMessages == true then LOG(sFunctionRef..': iAntiNavyThreat in this and adjacent zones='..iAntiNavyThreat) end
                                            end
                                        end
                                    end
                                end

                            end
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': bWantToRun before override='..tostring(bWantToRun)..'; oACU[refbUseACUAggressively]='..tostring(oACU[refbUseACUAggressively])..'; Dnagerous for ACUs='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs])) end
    if not(bWantToRun) and not(oACU[refbUseACUAggressively]) and M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs] then
        if bDebugMessages == true then LOG(sFunctionRef..': Considering override to make ACU run if enemy has approaching land exp, is table of enemy land exp empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]))) end
        --Dangerous for ACUs so consider running if approaching enemy experimental threat
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
            local iClosestExperimentalDist = 100000
            local iCurDist
            for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
                if M28UnitInfo.IsUnitValid(oUnit) then
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition())
                    if iCurDist < iClosestExperimentalDist then
                        iClosestExperimentalDist = iCurDist
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iClosestExperimentalDist='..iClosestExperimentalDist) end
            if iClosestExperimentalDist <= math.max(math.min(M28Map.iMapSize * 0.4, 250), 150) then
                bWantToRun = true
                if bDebugMessages == true then LOG(sFunctionRef..': Want to run from experimental') end
            end
        end
    end

    if bWantToRun then
        oACU[refiTimeLastWantedToRun] = GetGameTimeSeconds()
        --Record the zone that we are in, and that we were traveling to, as running from
        if not(oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iLandZone]) then
            if not(oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau]) then
                if not(oACU[reftiTimeLastRanFromZoneByPlateau]) then oACU[reftiTimeLastRanFromZoneByPlateau] = {} end
                oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau] = {}
            end
        end
        oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iLandZone] = GetGameTimeSeconds()
        if oACU[refiTimeLastToldToMoveToZone] and GetGameTimeSeconds() - oACU[refiTimeLastToldToMoveToZone] <= 10 then
            local iTargetPlateau = oACU[refiLastPlateauAndZoneToMoveTo][1]
            local iTargetLZ = oACU[refiLastPlateauAndZoneToMoveTo][2]
            if not(oACU[reftiTimeLastRanFromZoneByPlateau][iTargetPlateau][iTargetLZ]) then
                if not(oACU[reftiTimeLastRanFromZoneByPlateau][iTargetPlateau]) then
                    if not(oACU[reftiTimeLastRanFromZoneByPlateau]) then oACU[reftiTimeLastRanFromZoneByPlateau] = {} end
                    oACU[reftiTimeLastRanFromZoneByPlateau][iTargetPlateau] = {}
                end
            end
            oACU[reftiTimeLastRanFromZoneByPlateau][iTargetPlateau][iTargetLZ] = GetGameTimeSeconds()
        end

    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bWantToRun='..tostring(bWantToRun)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bWantToRun
end

function DoesACUWantToReturnToCoreBase(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)
    --Returns true if want ACU to return to the core base - to be used when ACU is facing critical threat that could kill it vs the normal 'does acu want to run' where ACU might return to an island sub-base
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DoesACUWantToReturnToCoreBase'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iTeam = oACU:GetAIBrain().M28Team

    --If big threat or ACU very low health then retreat; exception if ACU on full health with no enemies in this zone
    if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and M28UnitInfo.GetUnitHealthPercent(oACU) >= 1 and not(tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and (tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) == 0 and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] <= 500 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] then
        if bDebugMessages == true then LOG(sFunctionRef..': ACU is on full health and in the core zone with no major enemy threat so wont try to return to core base') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for ACU '..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' owned by '..oACU:GetAIBrain().Nickname..' on team '..iTeam..'; Dangerous for ACUs='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs])..'; ACU health percent='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; Air to ground threat='..tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Team air to ground threat='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; Nearby enemy air to ground threat='..M28Conditions.GetNearbyEnemyAirToGroundThreat(tLZOrWZData, tLZOrWZTeamData, iTeam, 175, 0)..'; Mod dist%='..tLZOrWZTeamData[M28Map.refiModDistancePercent]..'; Have air control='..tostring(M28Team.tAirSubteamData[oACU:GetAIBrain().M28AirSubteam][M28Team.refbHaveAirControl])..'; Assassinationorsimilar='..tostring(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar])..'; Highest individual brain air to ground threat='..M28Conditions.GetHighestAirToGroundThreatForIndividualEnemyBrain(iTeam)..'; Dist to closest friendly base='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftClosestFriendlyBase])) end
    --Cloak or advanced nano - dont retreat in most cases where enemy lacks nearby experimental and odesnt have significant air threat
    if not(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) and (oACU:HasEnhancement('CloakingGenerator') or M28UnitInfo.GetUnitCurHealthAndShield(oACU) >= 30000) and M28UnitInfo.GetUnitHealthAndShieldPercent(oACU) >= 0.95 then
        if bDebugMessages == true then LOG(sFunctionRef..': Considering being very aggressive with ACU because it has cloack or advanced nano/equivalent - even if we think it is generally dangerous for ACUs') end
        local iClosestLandExperimental = 10000
        local iCurPlateau
        local oClosestLandExp, iCurDist
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
            for iExp, oExp in M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
                if not(oExp.Dead) then
                    if not(iCurPlateau) or NavUtils.GetLabel(refPathingTypeHover, oExp:GetPosition()) == iPlateauOrZero then
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oExp:GetPosition(), oACU:GetPosition())
                        if iCurDist < iClosestLandExperimental then
                            iClosestLandExperimental = iCurDist
                            oClosestLandExp = oExp
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iClosestLandExperimental='..iClosestLandExperimental..'; will run if it is close (unless have cloak and close to base)') end
        if iClosestLandExperimental <= 200 and (not(oACU:HasEnhancement('CloakingGenerator')) or tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.1 or M28UnitInfo.CanSeeUnit(oClosestLandExp:GetAIBrain(), oACU, false)) then
            if bDebugMessages == true then LOG(sFunctionRef..': enemy has exp that is too close') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end

        --Consider running from very large enemy air to ground threat if we are relatively far from base
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to run from enemy air threat, M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; Our groundAA='..(tLZOrWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] or 0)..'; Dist to friendly base='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftClosestFriendlyBase])..'; Do we have air control='..tostring(M28Conditions.TeamHasAirControl(iTeam))..'; Highest enemy brain air to ground threat='..M28Conditions.GetHighestAirToGroundThreatForIndividualEnemyBrain(iTeam)) end
        if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 5000 and (tLZOrWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] or 0) <= 1000 and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) >= 180 and not(M28Conditions.TeamHasAirControl(iTeam)) and M28Conditions.GetHighestAirToGroundThreatForIndividualEnemyBrain(iTeam) >= 4000 then
            --if we are overextending or enemy has nearby air to ground threat then retreat
            local iDistToFriendlyBase = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftClosestFriendlyBase])
            if bDebugMessages == true then LOG(sFunctionRef..': Will retreat if overextending, iDistToFriendlyBase='..iDistToFriendlyBase..'; Mod dist%='..tLZOrWZTeamData[M28Map.refiModDistancePercent]..'; Enemy nearby air to ground (aborting at threshold)='..M28Conditions.GetNearbyEnemyAirToGroundThreat(tLZOrWZData, tLZOrWZTeamData, iTeam, 175, 800)) end
            if tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.2 and iDistToFriendlyBase >= 200 and ((iDistToFriendlyBase >= 300 and tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.45) or M28Conditions.GetNearbyEnemyAirToGroundThreat(tLZOrWZData, tLZOrWZTeamData, iTeam, 175, 800)) then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false

    end
    --First row - dangerous for ACUs related conditions
    if bDebugMessages == true then LOG(sFunctionRef..': Condition1 (dangerousforACUs): M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs]='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs])..'; Cond1a='..tostring((GetGameTimeSeconds() >= 1080 and (GetGameTimeSeconds() >= 1200 or M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar])))..';Cond1b='..tostring( M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] > 0)..'; Cond1c='..tostring((M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar] and GetGameTimeSeconds() >= 300 and (((oACU:GetAIBrain()[M28Economy.refiOurHighestFactoryTechLevel] >= 3 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 or M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandCombat * categories.TECH3) >= 2)) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 or M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandCombat * categories.TECH3) >= 2))  or tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.45 or (M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][3] or 0) >= 3 or ((M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][2] or 0) >= 5 and M28Conditions.GetHighestOtherTeamT2AndT3MexCount(iTeam) * 1.25 < (M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][3] or 0) +  (M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][2] or 0)))))..'; cond1d='..tostring(M28UnitInfo.GetUnitHealthPercent(oACU) < 0.9)..'; cond1e='..tostring(M28UnitInfo.GetUnitHealthPercent(oACU) < 0.9)..'; cond1f='..tostring((tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.25 and (M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar] or M28Utilities.GetDistanceBetweenPositions(tLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) >= 150 + 50 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])))..'; cond1c broken out in more detail:refiOurHighestFactoryTechLevel='..oACU:GetAIBrain()[M28Economy.refiOurHighestFactoryTechLevel]..'; Moddist%='..tLZOrWZTeamData[M28Map.refiModDistancePercent]..'; T3 mexes='..M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][3]..';T2 mexes='..M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][2]..'; Enemy T2+T3 mexes='..M28Conditions.GetHighestOtherTeamT2AndT3MexCount(iTeam)..'; Our fac and enemy fac or our LC t3='..tostring(oACU:GetAIBrain()[M28Economy.refiOurHighestFactoryTechLevel] >= 3 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 or M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandCombat * categories.TECH3) >= 2))..'; Dist to base='..M28Utilities.GetDistanceBetweenPositions(tLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase])) end
    if (M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs] and
            ((GetGameTimeSeconds() >= 1080 and (GetGameTimeSeconds() >= 1260 or M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar])) --1a
                    or M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] > 0 --1b
                    or (M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar] and GetGameTimeSeconds() >= 300 and (oACU:GetAIBrain()[M28Economy.refiOurHighestFactoryTechLevel] >= 3 or tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.45 or (M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][3] or 0) >= 3 or ((M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][2] or 0) >= 5 and M28Conditions.GetHighestOtherTeamT2AndT3MexCount(iTeam) * 1.25 < (M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][3] or 0) +  (M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][2] or 0)))) --1c
                    or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false --1d
                    or M28UnitInfo.GetUnitHealthPercent(oACU) < 0.9 --1e
                    or (tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.25 and (M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar] or M28Utilities.GetDistanceBetweenPositions(tLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) >= 150 + 50 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]))) --1f
            --Exception to dangerous for ACUs - we have 2+ M28 on team, fullshare, have an ACU threat of at least 3.5k (e.g. Sera ACU with 3 upgrades is 3.9k), mod dist is <0.7, and this ACU is closer to enemy base than any other ACU (i.e. have 1 ACU that will be more aggressive)
            and not(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) and not(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) and GetGameTimeSeconds() <= 1200 and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.95 and oACU[refiUpgradeCount] >= 2 and (M28UnitInfo.GetCombatThreatRating({ oACU}, false) or 0) >= 3500 and M28Utilities.GetDistanceBetweenPositions(tLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) <= 250 and M28Conditions.IsFurthestACUToFriendlyBase(oACU, tLZOrWZTeamData, iTeam)))
            --Rows 2+ - air snipe related conditions (note the log row references treat the above and the first one below as part of the same row)
            or M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.4 or (tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) >= math.max(400, math.min(tLZOrWZTeamData[M28Map.subrefLZThreatAllyMAA], 1500)) or
            --Is enemy planning a potential air snipe and we are exposed?
            ((M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= math.max(500, 500 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech], (tLZOrWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] or 0) + (tLZOrWZTeamData[M28Map.subrefLZThreatAllyMAA] or 0)))
                    and (M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar] or (not(M28Team.tAirSubteamData[oACU:GetAIBrain().M28AirSubteam][M28Team.refbHaveAirControl]) and (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 1200 or M28Team.iPlayersAtGameStart <= 4 or M28Conditions.GetHighestAirToGroundThreatForIndividualEnemyBrain(iTeam) > 400))
                    and (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 1000 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or (tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.45 and (M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) >= 180 or M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.75) and (tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.55 or (tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.45 and M28Map.iMapSize >= 1000))) or M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.95 or oACU[refiUpgradeCount] <= 1 or M28Conditions.GetNearbyEnemyAirToGroundThreat(tLZOrWZData, tLZOrWZTeamData, iTeam, 175, 0) > math.max(100, (tLZOrWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] or 0) * 2.5, M28Conditions.GetFriendlyMAAInThisAndAdjacentLandZones(tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iTeam))))
                    and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 or GetGameTimeSeconds() >= 1080 or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 3000 or M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.9 or tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.6 or iPlateauOrZero == 0 or
                    M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * (0.35 + math.min(math.max(-0.15,tLZOrWZTeamData[M28Map.refiModDistancePercent] - 0.4), 0.2)) >= M28Conditions.GetFriendlyMAAInThisAndAdjacentLandZones(tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iTeam))
            ) then
        if bDebugMessages == true then LOG(sFunctionRef..': Is dangerous for ACU or low health or large enemy air to ground threat so returning to base; First condition row='..tostring(((M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs] and (GetGameTimeSeconds() >= 1080 or tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.35 or M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar] or M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] > 0 or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false or M28UnitInfo.GetUnitHealthPercent(oACU) < 0.9 or (tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.25 and M28Utilities.GetDistanceBetweenPositions(tLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) >= 175))) or M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.4 or (tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) >= 400) or M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.4 or (tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) >= 400)..'; Eception to first row condition='..tostring(not(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) and not(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) and GetGameTimeSeconds() <= 1200 and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.95 and oACU[refiUpgradeCount] >= 2 and (M28UnitInfo.GetCombatThreatRating({ oACU}, false) or 0) >= 3500 and M28Utilities.GetDistanceBetweenPositions(tLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) <= 250))..'; Is furthest ACU from friendly base='..tostring(M28Conditions.IsFurthestACUToFriendlyBase(oACU, tLZOrWZTeamData, iTeam))..'; 2nd row condition='..tostring((M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= math.max(500, 500 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech], (tLZOrWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] or 0) + (tLZOrWZTeamData[M28Map.subrefLZThreatAllyMAA] or 0))))..'; 3rd row condition='..tostring((M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar] or (not(M28Team.tAirSubteamData[oACU:GetAIBrain().M28AirSubteam][M28Team.refbHaveAirControl]) and (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 1200 or M28Team.iPlayersAtGameStart <= 4 or M28Conditions.GetHighestAirToGroundThreatForIndividualEnemyBrain(iTeam) > 400))))..'; 4th row condition='..tostring((M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 1000 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or (tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.45 and (M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) >= 180 or M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.75) and (tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.55 or (tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.45 and M28Map.iMapSize >= 1000))) or M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.95 or oACU[refiUpgradeCount] <= 1 or M28Conditions.GetNearbyEnemyAirToGroundThreat(tLZOrWZData, tLZOrWZTeamData, iTeam, 175, 0) > math.max(100, (tLZOrWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] or 0) * 2.5)))..'; MAA in this and adj zone='..M28Conditions.GetFriendlyMAAInThisAndAdjacentLandZones(tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iTeam)..'; Total enemy air to ground threat='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; Mod dist='..tLZOrWZTeamData[M28Map.refiModDistancePercent]..'; Enemy air to ground factor for check='..(0.35 + math.min(math.max(-0.15,tLZOrWZTeamData[M28Map.refiModDistancePercent] - 0.4), 0.2))..'; Row 4='..tostring((M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 or GetGameTimeSeconds() >= 1080 or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 3000 or M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.9 or tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.6 or iPlateauOrZero == 0))..'; En land tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]..'; En air tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech]..'; ACU health%='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; Plateau='..iPlateauOrZero..'; Is table of enemy land exp empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]))) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    else
        --Run if enemy has an ACU with upgrades or is upgrading and we have no upgrades
        if not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU] and (oACU[refiUpgradeCount] or 0) == 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': Enemy ACU has upgrade and we dont so return to base unless are in a core expansion or have enemy units we want to try and kill and enemy ACU is far away, tLZOrWZTeamData[M28Map.subrefLZCoreExpansion]='..tostring(tLZOrWZTeamData[M28Map.subrefLZCoreExpansion] or false)..'; Enemies in adj zone='..tostring(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; tLZOrWZTeamData[M28Map.refiModDistancePercent]='..tLZOrWZTeamData[M28Map.refiModDistancePercent]..'; Dist to nearest friendly base='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftClosestFriendlyBase])..'; ACU health %='..M28UnitInfo.GetUnitHealthPercent(oACU)) end
            if (tLZOrWZTeamData[M28Map.subrefLZCoreExpansion] or (tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.35 and GetGameTimeSeconds() <= 600 and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.8 and (tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.2 or M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) <= 125))) and tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and GetGameTimeSeconds() <= 840 then
                local iClosestEnemyACU = 10000
                local iCurDist
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) == false then
                    for iEnemyACU, oEnemyACU in M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs] do
                        if (oEnemyACU[M28UnitInfo.refiDFRange] or 0) > (oACU[M28UnitInfo.refiDFRange] or 0) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oEnemyACU:GetPosition())
                            if iCurDist < iClosestEnemyACU and (not(oEnemyACU:IsUnitState('Upgrading')) or iCurDist <= (oEnemyACU[M28UnitInfo.refiDFRange] or 0) + 40) then iClosestEnemyACU = iCurDist end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iClosestEnemyACU with better range than us='..iClosestEnemyACU) end
                if iClosestEnemyACU <= 175 then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                else
                    --If not a core expansion, then check there is actually an enemy unit nearby (such that we are liekly going to be attacking)
                    if tLZOrWZTeamData[M28Map.subrefLZCoreExpansion] then
                        --Do nothing
                        if bDebugMessages == true then LOG(sFunctionRef..': Etiher core xpansion or closest DF unit is within 50 of us so we dont want to run as it may be better to attack instead') end
                    else
                        local oNearestUnit
                        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                            oNearestUnit = M28Utilities.GetNearestUnit(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies], oACU:GetPosition())
                            if M28UnitInfo.IsUnitValid(oNearestUnit) then
                                if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oNearestUnit:GetPosition()) <= 50 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Closest enmy unit is within 50 so dont want to run as it may be better to attack') end
                                else
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                    return true
                                end
                            else
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return true
                            end
                        else
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        end
                    end

                end
            else
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            end
        end

        --Return to base if enemy has signiifcant air to ground threat and we lack air control, and our mod dist isnt low
        if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= math.max(math.min(1000, 400 + math.max(250 * (M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or 1), (M28Team.iPlayersAtGameStart or 1) * 100)), math.min(750, (tLZOrWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] or 0) * 2), math.min(4000, (M28Team.tAirSubteamData[oACU:GetAIBrain().M28AirSubteam][M28Team.subrefiOurAirAAThreat] or 0))) and M28Team.tAirSubteamData[oACU:GetAIBrain().M28AirSubteam][M28Team.refbFarBehindOnAir] and ((oACU[refiUpgradeCount] or 0) < 3 or not(oACU:GetHealth() >= 15000 - 500 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or (oACU.MyShield.GetHealth and oACU.MyShield:GetHealth()) >= 7000))
                --Unless ACU is relatively near our base already and has good health and upgrades
                and (tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.4 or (tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.2 and (oACU[refiUpgradeCount] < 2 or tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 or M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.8 or (M28Map.iMapSize >= 1000 and M28Utilities.GetDistanceBetweenPositions(tLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) >= 150))))
        then
            if bDebugMessages == true then LOG(sFunctionRef..': Vulnerable to an air snipe so want to retreat, oACU[refiUpgradeCount]='..oACU[refiUpgradeCount]) end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        else
            --If ACU is upgrading then we wont have checked if we want to run, so do a check of enemy threat and consider running
            if bDebugMessages == true then LOG(sFunctionRef..': Is ACU upgrading='..tostring(oACU:IsUnitState('Upgrading'))..'; ACU work progress='..(oACU:GetWorkProgress() or 'nil')..'; Core base='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or false)..'; Dangerous enemies in this LZ='..tostring(tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] or false)..'; Is table of DF enemies empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]))..'; Enemy mobile DF total='..(tLZOrWZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 'nil')) end
            if oACU:IsUnitState('Upgrading') then
                if iPlateauOrZero > 0 and M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.99 and oACU:GetWorkProgress() <= 0.8 and (tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] or oACU:GetWorkProgress() <= 0.6) and not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': ACU is upgrading, will consider if a really large threat such that we should run, safe to get upgrade='..tostring(M28Conditions.SafeToUpgradeUnit(oACU))) end
                    if not(M28Conditions.SafeToUpgradeUnit(oACU)) then
                        local toNearbyEnemyUnits = {}
                        local toApproachingEnemies = {}
                        local iNearbyThreshold = 10
                        local iApproachingThreshold = 40
                        local iCurDist
                        function AddNearbyEnemyThreats(tCurLZTeamData)
                            if M28Utilities.IsTableEmpty(tCurLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                                for iEnemy, oEnemy in tCurLZTeamData[M28Map.subrefTEnemyUnits] do
                                    if not(oEnemy.Dead) and oEnemy[M28UnitInfo.refiCombatRange] > 10 then
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oACU:GetPosition()) - oEnemy[M28UnitInfo.refiCombatRange]
                                        if iCurDist <= iNearbyThreshold then
                                            table.insert(toNearbyEnemyUnits, oEnemy)
                                        elseif iCurDist <= iApproachingThreshold then
                                            table.insert(toApproachingEnemies, oEnemy)
                                        end

                                    end
                                end
                            end
                        end
                        AddNearbyEnemyThreats(tLZOrWZTeamData)
                        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false then
                            for _, iAdjLZ in tLZOrWZData[M28Map.subrefLZAdjacentLandZones] do
                                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                AddNearbyEnemyThreats(tAdjLZTeamData)
                            end
                        end
                        local iNearbyEnemyThreat = M28UnitInfo.GetCombatThreatRating(toNearbyEnemyUnits, true, false)
                        if bDebugMessages == true then LOG(sFunctionRef..': iNearbyEnemyThreat='..iNearbyEnemyThreat) end
                        if iNearbyEnemyThreat >= 400 then
                            local iApproachingEnemyThreat = M28UnitInfo.GetCombatThreatRating(toApproachingEnemies, true, false)
                            if iNearbyEnemyThreat + iApproachingEnemyThreat >= 800 then
                                local iThreatFactor = 1.5 + oACU:GetWorkProgress() * 0.5
                                if not(oACU[refbUseACUAggressively]) and M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar] then iThreatFactor = iThreatFactor - 0.5 end
                                if bDebugMessages == true then LOG(sFunctionRef..': iApproachingEnemyThreat='..iApproachingEnemyThreat..'; Cur LZ friendly combat='..tLZOrWZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]..'; iThreatFactor='..iThreatFactor) end
                                if (iNearbyEnemyThreat + iApproachingEnemyThreat) * iThreatFactor > math.max(tLZOrWZTeamData[M28Map.subrefLZTThreatAllyCombatTotal], M28UnitInfo.GetCombatThreatRating(oACU)) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will return to base if we also want to run') end
                                    if DoesACUWantToRun(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to cancel upgrade and return to base') end
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        return true
                                    end
                                end
                            end
                        end
                    end
                end
                --If enemy has approaching experimental also run
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false and oACU:GetWorkProgress() <= 0.7 then
                    for iExp, oExp in M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
                        if not(oExp.Dead) and oExp[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] == iPlateauOrZero and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oExp:GetPosition()) <= 100 and DoesACUWantToRun(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                            if bDebugMessages == true then LOG(sFunctionRef..': want to cancel upgrade due to approaching enemy experimental') end
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        end
                    end
                end
            end

            --Run if enemy still has some of an air threat and we have better eco than them and our ACU lacks 3+ upgradews and not early-game
            if (GetGameTimeSeconds() >= 300 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2) and not(oACU[refbUseACUAggressively]) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 400 and M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar] and tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.25 and oACU[refiUpgradeCount] < 3 then
                local iEnemyEco = 0
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains]) == false then
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
                        iEnemyEco = iEnemyEco + oBrain:GetEconomyIncome('MASS')
                    end
                end
                --Assume a player would have a reasonable sense of if very far ahead on eco, so will use a much higher eco threshold as a rough proxy of just 'we are ahead on eco
                if bDebugMessages == true then LOG(sFunctionRef..': iEnemyEco='..iEnemyEco..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) end
                if iEnemyEco * 1.35 < M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                end
            end



            --Run if we are underwater or on a different island to our core base and enemy has subs
            local bWaterIsDangerous = (M28Team.tTeamData[iTeam][M28Team.refiEnemySubCount] or 0) >= 2
            if not(bWaterIsDangerous) then
                bWaterIsDangerous = not(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoEnemyTorpBombers]))
                if not(bWaterIsDangerous) then
                    --If enemy has T3 air or T2 navy then treat water as dangerous for ACU
                    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech] >= 2 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 then
                        bWaterIsDangerous = true
                    elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 2 and M28Team.tAirSubteamData[oACU:GetAIBrain().M28AirSubteam][M28Team.refbFarBehindOnAir] then
                        bWaterIsDangerous = true
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bWaterIsDangerous='..tostring(bWaterIsDangerous)..'; Is ACU underwtaer='..tostring(M28UnitInfo.IsUnitUnderwater(oACU))) end
            --If ACU has torpedo upgrade and good health dont treat water as dangerous
            if (oACU[M28UnitInfo.refiAntiNavyRange] or 0) > 10 and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.75 and (M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] <= 600 or (M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] <= 5000 and M28Team.tAirSubteamData[oACU:GetAIBrain().M28AirSubteam][M28Team.refbHaveAirControl])) then
                if bDebugMessages == true then LOG(sFunctionRef..': ACU has torpedo upgrade and decent health so wont retreat to base') end
                bWaterIsDangerous = false
            end
            if bWaterIsDangerous then
                --If ACU has 1+ upgrade, 95% health (80% if on land that is part of a high value island), and its movement target isn't more than 60% away from our base or 200 if higher, then dont run
                local bWantACUToRun = false
                if M28UnitInfo.IsUnitUnderwater(oACU) then
                    bWantACUToRun = true --default - will reconsider below
                else
                    local iNearestBaseIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZOrWZTeamData[M28Map.reftClosestFriendlyBase])
                    local iCurIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, oACU:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': iNearestBaseIsland='..(iNearestBaseIsland or 'nil')..'; iCurIsland='..(iCurIsland or 'nil')) end
                    if not(iNearestBaseIsland == iCurIsland) then

                        bWantACUToRun = true --default, will reconsider below
                    end
                end
                if bWantACUToRun and (oACU[refiUpgradeCount] or 0) >= 1 then
                    local iHealthPercent = M28UnitInfo.GetUnitHealthPercent(oACU)
                    if iHealthPercent >= 0.8 then
                        local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
                        if bDebugMessages == true then LOG(sFunctionRef..': repru(tLZData[M28Map.subrefMidpoint])='..repru(tLZOrWZData[M28Map.subrefMidpoint])..'; iPlateau='..(iPlateauOrZero or 'nil')..'; iLandZone='..(iLandOrWaterZone or 'nil')..'Is ACU underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oACU))..'; tLastOrder='..reprs(tLastOrder)) end
                        local iDistToBase
                        --Get nearest base to us
                        local tNearestFriendlyBase
                        local tNearestEnemyBase
                        if tLZOrWZTeamData[M28Map.reftClosestFriendlyBase] then
                            tNearestFriendlyBase = {tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][1], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][2], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][3]}
                            tNearestEnemyBase = {tLZOrWZTeamData[M28Map.reftClosestEnemyBase][1], tLZOrWZTeamData[M28Map.reftClosestEnemyBase][2], tLZOrWZTeamData[M28Map.reftClosestEnemyBase][3]}
                        else
                            --Use our start position
                            local aiBrain = oACU:GetAIBrain()
                            local iStartPositionX, iStartPositionZ = M28Map.GetPlayerStartPosition(aiBrain, true)
                            tNearestFriendlyBase = { iStartPositionX, GetTerrainHeight(iStartPositionX, iStartPositionZ), iStartPositionZ }
                            tNearestEnemyBase = aiBrain[M28Overseer.refoNearestEnemyBrain][M28Overseer.refoNearestEnemyBrain]
                        end

                        if tLastOrder and M28Utilities.IsTableEmpty(tLastOrder[M28Orders.subreftOrderPosition]) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': tNearestFriendlyBase='..repru(tNearestFriendlyBase)..'; tLastOrder[M28Orders.subreftOrderPosition]='..repru(tLastOrder[M28Orders.subreftOrderPosition])) end
                            iDistToBase = M28Utilities.GetDistanceBetweenPositions(tNearestFriendlyBase, tLastOrder[M28Orders.subreftOrderPosition])
                        else
                            iDistToBase = M28Utilities.GetDistanceBetweenPositions(tNearestFriendlyBase, oACU:GetPosition())
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iDistToBase='..iDistToBase..'; iHealthPercent='..iHealthPercent..'; Enemy naval tech='..(M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech] or 0)..'; Enemy sub count='..(M28Team.tTeamData[iTeam][M28Team.refiEnemySubCount] or 0)) end
                        if iDistToBase <= math.max(250, M28Utilities.GetDistanceBetweenPositions(tNearestEnemyBase, tNearestFriendlyBase) * 0.5) then
                            if iHealthPercent >= 0.95 or ((M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech] or 0) <= 1 and (M28Team.tTeamData[iTeam][M28Team.refiEnemySubCount] or 0) <= 7) then
                                bWantACUToRun = false
                            end
                        end
                    end
                    if bWantACUToRun and iHealthPercent >= 0.75 then
                        --Exception - ACU has at least 75% health, and doesnt have far to travel underwater to reach its destination
                        local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
                        if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueMove then
                            local iDistUntilIsland = 200
                            local iIslandRefWanted = NavUtils.GetLabel(M28Map.refPathingTypeLand,  tLastOrder[M28Orders.subreftOrderPosition])
                            local iAngleToTarget = M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tLastOrder[M28Orders.subreftOrderPosition])
                            local bArePassingEnemyAntiNavyThreat = false
                            for iCurDist = 10, 70, 10 do
                                local tTempMoveLocation = M28Utilities.MoveInDirection(oACU:GetPosition(), iAngleToTarget, iCurDist, true, true, false)
                                if bDebugMessages == true then LOG(sFunctionRef..': iCurDist='..iCurDist..'; Island ref='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tTempMoveLocation) or 'nil')..'; iIslandRefWanted='..(iIslandRefWanted or 'nil')) end
                                if not(bArePassingEnemyAntiNavyThreat) then
                                    local tMoveLocationData, tMoveLocationTeamData = M28Map.GetLandOrWaterZoneData(tTempMoveLocation, true, iTeam)
                                    if (tMoveLocationTeamData[M28Map.subrefWZThreatEnemyAntiNavy] or 0) > 0 then bArePassingEnemyAntiNavyThreat = true end
                                end
                                if tTempMoveLocation and NavUtils.GetLabel(M28Map.refPathingTypeLand, tTempMoveLocation) == iIslandRefWanted then
                                    iDistUntilIsland = iCurDist
                                    break
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iDistUntilIsland (defaults to 200 if couldnt find island after 60)='..iDistUntilIsland..'; iHealthPercent='..iHealthPercent..'; 30 +  (iHealthPercent - 0.75) * 30)='..30 +  (iHealthPercent - 0.75) * 30) end
                            if iDistUntilIsland <= 70 and (iDistUntilIsland <= 30 or (not(bArePassingEnemyAntiNavyThreat) and iHealthPercent >= 0.9) or iDistUntilIsland <= 30 +  (iHealthPercent - 0.75) / 0.25 * 40) then
                                bWantACUToRun = false
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Do we want to return to base due to water being dangerous? bWantACUToRun='..tostring(bWantACUToRun)) end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return bWantACUToRun
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GiveOverchargeOrderIfRelevant(tLZData, tLZTeamData, oACU, iPlateauOrZero, iLandOrWaterZone)
    --Are there enemies in this LZ or adjacent, and do we have the energy to overcharge?
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GiveOverchargeOrderIfRelevant'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; DO we have enemies in this or adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ])..'; Can we use overcharge='..tostring(M28Conditions.CanUnitUseOvercharge(oACU:GetAIBrain(), oACU))..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')) end

    if iPlateauOrZero > 0 and ((tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) and M28Conditions.CanUnitUseOvercharge(oACU:GetAIBrain(), oACU, tLZTeamData)) then
        --Dont overcharge if have teleport as can affect targeting and delay the return jump
        if not(oACU[refbACUHasTeleport]) then
            local bDoesACUWantToRun = DoesACUWantToRun(iPlateauOrZero, iLandOrWaterZone, tLZData, tLZTeamData, oACU)
            local oUnitToOvercharge = M28Micro.GetOverchargeTarget(tLZData, oACU:GetAIBrain(), oACU, bDoesACUWantToRun)
            if bDebugMessages == true then LOG(sFunctionRef..': Do we have a valid OC target='..tostring(M28UnitInfo.IsUnitValid(oUnitToOvercharge))) end
            if oUnitToOvercharge then
                --Redundancy - in some cases when we want to overcharge (e.g. replay 21026248 at 13m08) we can be stuck and not overcharge; therefore if we were already trying to overcharge this unit, and haven't fired our weapon in 2 seconds, then abort
                local tLastOrder = oACU[M28Orders.reftiLastOrders][1]
                if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderOvercharge and tLastOrder[M28Orders.subrefoOrderUnitTarget] == oUnitToOvercharge and GetGameTimeSeconds() - (oACU[M28UnitInfo.refiLastWeaponEvent] or -100) >= 2.5 then
                    if bDebugMessages == true then LOG(sFunctionRef..': ACU weapon might be stuck so clearing overcharge order') end
                    M28Orders.IssueTrackedClearCommands(oACU)
                    oACU[M28UnitInfo.refbSpecialMicroActive] = false
                else
                    M28Orders.IssueTrackedOvercharge(oACU, oUnitToOvercharge, false, 'OC', true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Have just told ACU '..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' owned by '..oACU:GetAIBrain().Nickname..' to overcharge '..oUnitToOvercharge.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToOvercharge)..'; Dist to this unit='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnitToOvercharge:GetPosition())..'; ACU DF range='..oACU[M28UnitInfo.refiDFRange]) end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function AttackNearestEnemyWithACU(iPlateau, iLandZone, tLZData, tLZTeamData, oACU, iOptionalDistThresholdOverride)
    --Attack move to the nearest enemy if we arent in range of it or retreat if we are in range of it
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AttackNearestEnemyWithACU'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local oEnemyToTarget
    if (oACU[M28UnitInfo.refiDFRange] or 0) > 0 then
        local iCurDist

        local tUnitsToTarget
        local aiBrain = oACU:GetAIBrain()
        local iTeam = aiBrain.M28Team
        local iDistThreshold
        if iOptionalDistThresholdOverride then iDistThreshold = iOptionalDistThresholdOverride
        else
            if (oACU[refiUpgradeCount] or 0) > 0 then
                iDistThreshold = 70
                if oACU[refiUpgradeCount] >= 2 and (oACU[refiUpgradeCount] >= 3 or not(EntityCategoryContains(categories.AEON, oACU.UnitId))) and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.95 and (tLZData[M28Map.subrefTotalSignificantMassReclaim] or 0) <= 250 then
                    local iMassCostOfEnemyUnits = M28UnitInfo.GetMassCostOfUnits(tLZTeamData[M28Map.reftoNearestDFEnemies], true)
                    if iMassCostOfEnemyUnits < 200 then
                        iDistThreshold = 80
                    elseif M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar] then
                        iDistThreshold = 90
                    elseif iMassCostOfEnemyUnits >= 1000 then
                        iDistThreshold = 110
                    else
                        iDistThreshold = 105
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished deciding dist threshold for upgraded ACU, UpgradeCount='..oACU[refiUpgradeCount]..'; Health%='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; Mass value of DF enemies='..M28UnitInfo.GetMassCostOfUnits(tLZTeamData[M28Map.reftoNearestDFEnemies], true)..'; iDistThreshold='..iDistThreshold) end
            else iDistThreshold = 60
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Adding table of enemy units to consider targeting, is table of nearest DF enemies empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]))) end
        local bCheckCurTarget = false
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
            tUnitsToTarget = tLZTeamData[M28Map.reftoNearestDFEnemies]
            iDistThreshold = iDistThreshold + 10
            bCheckCurTarget = true
            if bDebugMessages == true then LOG(sFunctionRef..': Will target nearest enemy DF units') end
        elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
            tUnitsToTarget = EntityCategoryFilterDown(categories.ALLUNITS - M28UnitInfo.refCategoryLandScout + M28UnitInfo.refCategoryCombatScout, tLZTeamData[M28Map.subrefTEnemyUnits])
            iDistThreshold = iDistThreshold + 10
            bCheckCurTarget = true
            if bDebugMessages == true then LOG(sFunctionRef..': Will target nearest enemy units') end
        end
        --Search adjacent land zones for enemy units if none in this zone (even if we have nearby DF enemies - i.e. want more accurate/detailed check of nearby DF units if therea re no enemies in ACU cur zone), and consider if they are within 60 of ACU position
        if (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) < 350 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            if not(tUnitsToTarget) then
                tUnitsToTarget = {}
            end
            local bAlreadyRecorded = false
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': Checking for enemies in iAdjLZ='..iAdjLZ..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]))) end
                if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    local tEnemiesAlreadyRecorded = tUnitsToTarget
                    for iUnit, oUnit in tAdjLZTeamData[M28Map.subrefTEnemyUnits] do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Dist to ACU='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())..'; iDistThreshold='..iDistThreshold) end
                            if not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition()) <= iDistThreshold then
                                bAlreadyRecorded = false
                                if M28Utilities.IsTableEmpty(tEnemiesAlreadyRecorded) then
                                    --Not recorded
                                else
                                    for iRecorded, oRecorded in tEnemiesAlreadyRecorded do
                                        if oRecorded == oUnit then
                                            bAlreadyRecorded = true
                                            break
                                        end
                                    end
                                end
                                if not(bAlreadyRecorded) then
                                    table.insert(tUnitsToTarget, oUnit)
                                end
                            end
                        end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tUnitsToTarget) then
            tUnitsToTarget = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure -M28UnitInfo.refCategoryLandScout + M28UnitInfo.refCategoryCombatScout, oACU:GetPosition(), iDistThreshold, 'Enemy')
        end
        if bCheckCurTarget and M28Utilities.IsTableEmpty(oACU.WeaponInstances) == false then
            for iWeapon, oWeapon in oACU.WeaponInstances do
                if oWeapon.GetCurrentTarget then
                    local oCurTarget = oWeapon:GetCurrentTarget()
                    if bDebugMessages == true and oCurTarget then LOG(sFunctionRef..': Cur weapon target='..oCurTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oCurTarget)..'; with combat range='..(oCurTarget[M28UnitInfo.refiCombatRange] or 'nil')) end
                    if M28UnitInfo.IsUnitValid(oCurTarget) and (oCurTarget[M28UnitInfo.refiCombatRange] or 0) > 0 then
                        if not(oCurTarget[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] == iPlateau and oCurTarget[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Cur target isnt assigned to this zone so will add into table of units to target') end
                            table.insert(tUnitsToTarget, oCurTarget)
                        end
                    end
                end
            end
        end

        local iClosestDist = iDistThreshold + 1
        if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Is table of units to target empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToTarget))..'; Is tLZTeamData[M28Map.reftoNearestDFEnemies] empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]))..'; iClosestDist='..iClosestDist) end
        if M28Utilities.IsTableEmpty(tUnitsToTarget) == false then
            local iOurACUHealthPercent = M28UnitInfo.GetUnitHealthAndShieldPercent(oACU)
            local bAbortDueToStartingPD = false
            if tLZTeamData[M28Map.subrefLZbCoreBase] and tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] > oACU[M28UnitInfo.refiDFRange] and (GetGameTimeSeconds() <= 300 or (GetGameTimeSeconds() <= 600 and M28Map.bIsCampaignMap)) then
                local tPDToTarget = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD, tUnitsToTarget)
                if M28Utilities.IsTableEmpty(tUnitsToTarget) == false then
                    bAbortDueToStartingPD = true
                end
            end
            --refiTimeCreated
            local sPathing = M28Map.refPathingTypeAmphibious
            local iUnitPlateau, iUnitZone
            local bUnitInFurtherAwayZoneWeRanFrom
            local iStartPlateau, iStartZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tLZTeamData[M28Map.reftClosestFriendlyBase])
            local iACUZoneTravelDistToBase
            if bDebugMessages == true then LOG(sFunctionRef..': iStartPlateau='..(iStartPlateau or 'nil')..'; iStartZone='..(iStartZone or 'nil')..'; bAbortDueToStartingPD='..tostring(bAbortDueToStartingPD or false)) end
            if bAbortDueToStartingPD then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return false
            end
            if iStartPlateau > 0 and iStartZone > 0 then
                if iPlateau > 0 then
                    iACUZoneTravelDistToBase = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iStartZone)
                else
                    iACUZoneTravelDistToBase = M28Utilities.GetTravelDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase], M28Map.refPathingTypeAmphibious)
                end
            end
            local iUnitInZoneRanFromDistThresholdIfOutrange = oACU[M28UnitInfo.refiDFRange] + 7
            local iUnitInZoneRanFromDistThresholdIfDontOutrange = oACU[M28UnitInfo.refiDFRange] + 2
            local iRanFromDistThreshold
            local iClosestUnshieldedDist = 10000
            local oClosestUnshielded
            for iUnit, oUnit in tUnitsToTarget do
                if M28UnitInfo.IsUnitValid(oUnit) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                    --Is unit in a zone that we have recently run from and that zone is further from our base than our current position?
                    iUnitPlateau, iUnitZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                    bUnitInFurtherAwayZoneWeRanFrom = false
                    if iUnitPlateau > 0 and iUnitZone > 0 and (oACU[reftiTimeLastRanFromZoneByPlateau][iUnitPlateau][iUnitZone] and GetGameTimeSeconds() - oACU[reftiTimeLastRanFromZoneByPlateau][iUnitPlateau][iUnitZone] < 30) or (oACU[refiLastPlateauAndZoneToAttackUnitIn][2] == iUnitZone and oACU[refiLastPlateauAndZoneToAttackUnitIn][1] == iUnitPlateau and GetGameTimeSeconds() - (oACU[refiTimeLastToldToAttackUnitInOtherZone] or -100) < 30) then
                        --Unit in zone we ran from, dont want to attack it unless zone is closer to our base than our current zone, or enemy is close
                        if iACUZoneTravelDistToBase and not(tLZTeamData[M28Map.subrefLZbCoreBase]) then
                            if oUnit[M28UnitInfo.refiCombatRange] >= oACU[M28UnitInfo.refiDFRange] then
                                iRanFromDistThreshold = iUnitInZoneRanFromDistThresholdIfDontOutrange
                            else
                                iRanFromDistThreshold = iUnitInZoneRanFromDistThresholdIfOutrange
                            end

                            if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition()) >= iRanFromDistThreshold and M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iUnitZone) > iACUZoneTravelDistToBase then
                                bUnitInFurtherAwayZoneWeRanFrom = true
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; iCurDist='..(M28Utilities.GetTravelDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition(), sPathing) or 'nil')..'; bUnitInFurtherAwayZoneWeRanFrom='..tostring(bUnitInFurtherAwayZoneWeRanFrom or false)..'; iUnitZone='..(iUnitZone or 'nil')..'; refiLastPlateauAndZoneToAttackUnitIn='..reprs(oACU[refiLastPlateauAndZoneToAttackUnitIn])..'; refiTimeLastToldToAttackUnitInOtherZone='..reprs(oACU[refiTimeLastToldToAttackUnitInOtherZone])..'; Is unit under shield='..tostring(M28Logic.IsTargetUnderShield(aiBrain, oUnit, 3000, false, false, false, false, false))..'; iUnitPlateau='..iUnitPlateau) end
                    if not(bUnitInFurtherAwayZoneWeRanFrom) then
                        --iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition())
                        iCurDist = M28Utilities.GetTravelDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition(), sPathing)
                        if iCurDist then
                            --If unit in water and we cant reach it with DF then ignore
                            if iUnitPlateau == 0 and iClosestDist > 1 + oACU[M28UnitInfo.refiDFRange] and not(NavUtils.GetLabel(M28Map.refPathingTypeLand, M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oACU:GetPosition()), oACU[M28UnitInfo.refiDFRange], true, true, false)) == (tLZData[M28Map.subrefLZIslandRef] or 0)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Nearby naval unit, but it doesnt look like we can reach it if we advance, so we will ignore it') end
                            elseif iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oEnemyToTarget = oUnit
                                if not(M28Logic.IsTargetUnderShield(aiBrain, oUnit, 3000, false, false, false, false, false)) then
                                    oClosestUnshielded = oUnit
                                    iClosestUnshieldedDist = iCurDist
                                end
                            elseif iCurDist < iClosestUnshieldedDist and not(M28Logic.IsTargetUnderShield(aiBrain, oUnit, 3000, false, false, false, false, false)) then
                                oClosestUnshielded = oUnit
                                iClosestUnshieldedDist = iCurDist
                            end
                        end
                    end
                end
            end
            local bNearestEnemyIsShieldedButEnemyToTargetLacksShield = false
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to switch to unshielded target, is oClosestUnshielded same as oEnemyToTarget='..tostring(oEnemyToTarget == oClosestUnshielded)..'; iClosestUnshieldedDist='..(iClosestUnshieldedDist or 'nil')..'; iClosestDist='..iClosestDist) end
            if oClosestUnshielded and not(oEnemyToTarget == oClosestUnshielded) and (iClosestUnshieldedDist < oACU[M28UnitInfo.refiDFRange] + 2 or iClosestUnshieldedDist - 4 < iClosestDist) then
                bNearestEnemyIsShieldedButEnemyToTargetLacksShield = true
                oEnemyToTarget = oClosestUnshielded
                if bDebugMessages == true then LOG(sFunctionRef..': Switched enemy to target to the closest unshielded enmey') end
            end
            --If we have a friendly ACU near an enemy ACU, and we arent outranged by it, and this is relatively early on (we have T1-T2 tech) then go to help the friendly ACU
            if not(oEnemyToTarget) and not(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs]) and not(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) and aiBrain[M28Economy.refiOurHighestFactoryTechLevel] <= 2 and GetGameTimeSeconds() <= 1200
                    --Also check enemy lacks PD/mobile land units in this zone that outranges us (will check for ACU zone in a bit)
                    and tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] <= oACU[M28UnitInfo.refiDFRange] and tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] <= oACU[M28UnitInfo.refiDFRange] then
                local toNearbyEnemyACUs = {}
                local toNearbyFriendlyACUs = {}
                local iFriendlyACUSearchDistance = 100
                for iFriendlyACU, oFriendlyACU in M28Team.tTeamData[iTeam][M28Team.reftM28ACUs] do
                    if not(oFriendlyACU == oACU) and not(oFriendlyACU.Dead) and M28Utilities.GetDistanceBetweenPositions(oFriendlyACU:GetPosition(), oACU:GetPosition()) <= iFriendlyACUSearchDistance then
                        table.insert(toNearbyFriendlyACUs, oFriendlyACU)
                    end
                end
                if M28Utilities.IsTableEmpty(toNearbyFriendlyACUs) == false then
                    local iEnemyACUSearchDistance = iFriendlyACUSearchDistance + 35
                    local iOurDistToACU, iFriendlyDistToACU
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) == false then
                        for iEnemyACU, oEnemyACU in M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs] do
                            if not(oEnemyACU.Dead) then
                                iOurDistToACU = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oEnemyACU:GetPosition())
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy ACU owned by '..oEnemyACU:GetAIBrain().Nickname..'; iOurDistToACU='..iOurDistToACU..'; iEnemyACUSearchDistance='..iEnemyACUSearchDistance) end
                                if iOurDistToACU <= iEnemyACUSearchDistance and not(M28UnitInfo.IsUnitUnderwater(oEnemyACU)) then
                                    if oEnemyACU[M28UnitInfo.refiDFRange] > oACU[M28UnitInfo.refiDFRange] then
                                        if bDebugMessages == true then LOG(sFunctionRef..': enemy has an ACU that outranges us and is relatively close so we wont consider supporting friendly ACUs') end
                                        oEnemyToTarget = nil --redundancy
                                        break
                                    else
                                        --Enemy ACU is close enough to us that we might be able to help in the fight; is it closer to a friendly ACU than to us (and by a notable distance)
                                        for iFriendlyACU, oFriendlyACU in toNearbyFriendlyACUs do
                                            iFriendlyDistToACU = M28Utilities.GetDistanceBetweenPositions(oFriendlyACU:GetPosition(), oEnemyACU:GetPosition())
                                            if iFriendlyDistToACU < iOurDistToACU - 5 and iFriendlyDistToACU < math.min(iOurDistToACU - 15, 15 + oACU[M28UnitInfo.refiDFRange]) then
                                                iEnemyACUSearchDistance = iOurDistToACU
                                                oEnemyToTarget = oEnemyACU
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    if oEnemyToTarget then
                        if oEnemyToTarget[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] == iPlateau then
                            --Check enemy doesnt have any T2 PD (or T1 PD if we have short range) near the enemy ACU (we have already checked for the zone we are in)
                            if not(oEnemyToTarget[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone) then
                                local tEnemyACULZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][oEnemyToTarget[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]][M28Map.subrefLZTeamData][iTeam]
                                if tEnemyACULZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] > oACU[M28UnitInfo.refiDFRange] or tEnemyACULZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] > oACU[M28UnitInfo.refiDFRange] then
                                    if bDebugMessages == true then LOG(sFunctionRef..': enemy has DF units that outrange our ACU in the target zone, wont target/assist the ACU fight') end
                                    oEnemyToTarget = nil
                                end
                            end
                        else
                            oEnemyToTarget = nil
                            if bDebugMessages == true then LOG(sFunctionRef..': We cant path to enemy ACU') end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finsihed considering if we want to go help a friendly ACU fight, Is toNearbyFriendlyACUs empty='..tostring(M28Utilities.IsTableEmpty(toNearbyFriendlyACUs))) end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': oEnemyToTarget='..(oEnemyToTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEnemyToTarget) or 'nil')) end
            if oEnemyToTarget then
                local iUnitPlateau, iUnitZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oEnemyToTarget:GetPosition())
                local iMaxDistToBeInRange = 5 --placeholder
                if iUnitZone > 0 then
                    if not(oACU[refiLastPlateauAndZoneToAttackUnitIn]) then oACU[refiLastPlateauAndZoneToAttackUnitIn] = {} end
                    oACU[refiTimeLastToldToAttackUnitInOtherZone] = GetGameTimeSeconds()
                    oACU[refiLastPlateauAndZoneToAttackUnitIn] = {iUnitPlateau, iUnitZone}
                end
                if oACU[M28UnitInfo.refbLastShotBlocked] then
                    --Shot blocked, but we must think we can win the fight or we would be running, so move towards enemy, or (if there is an enemy in range we can hit attack that enemy)
                    local oEnemyToAttack
                    if iPlateau > 0 then
                        --Are we akready targeting an enemy? in which case keep targeting if not blocked
                        if oACU[M28Orders.reftiLastOrders][1][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAttack and M28UnitInfo.IsUnitValid(oACU[M28Orders.reftiLastOrders][1][M28Orders.subrefoOrderUnitTarget]) and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(),oACU[M28Orders.reftiLastOrders][1][M28Orders.subrefoOrderUnitTarget]:GetPosition()) <= oACU[M28UnitInfo.refiDFRange] and not(M28Logic.IsShotBlocked(oACU, oACU[M28Orders.reftiLastOrders][1][M28Orders.subrefoOrderUnitTarget], false, nil)) then
                            oEnemyToAttack = oACU[M28Orders.reftiLastOrders][1][M28Orders.subrefoOrderUnitTarget]
                            if bDebugMessages == true then LOG(sFunctionRef..': Will continue attacking last order target') end
                        else
                            local tEnemiesInRange = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryPD + M28UnitInfo.refCategoryLandCombat, oACU:GetPosition(), (oACU[M28UnitInfo.refiDFRange] or 2) - 1, 'Enemy')
                            local iClosestEnemyNotBlocked = 10000
                            local iCurDist
                            if bDebugMessages == true then LOG(sFunctionRef..': Is tEnemiesInRange empty='..tostring(M28Utilities.IsTableEmpty( tEnemiesInRange))) end
                            if M28Utilities.IsTableEmpty( tEnemiesInRange) == false then
                                for iEnemy, oEnemy in tEnemiesInRange do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy '..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; Is shot blocked='..tostring(M28Logic.IsShotBlocked(oACU, oEnemy, false, nil))..'; Dist to our ACU='..M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oACU:GetPosition())) end
                                    if not(M28Logic.IsShotBlocked(oACU, oEnemy, false, nil)) then
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oACU:GetPosition())
                                        if iCurDist < iClosestEnemyNotBlocked then
                                            oEnemyToAttack = oEnemy
                                            iClosestEnemyNotBlocked = iCurDist
                                        end
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Shot is blocked, have chekced if enemy we dont htink will be blocked iwthin our DF range to attack, oEnemyToAttack='..(oEnemyToAttack.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEnemyToAttack) or 'nil')) end
                    if oEnemyToAttack then
                        M28Orders.IssueTrackedAttack(oACU, oEnemyToAttack, false, 'ACUBAt', false)
                    else
                        M28Orders.IssueTrackedMove(oACU, oEnemyToTarget:GetPosition(), 5, false, 'ACUBl', false)
                        if bDebugMessages == true then LOG(sFunctionRef..': ACU shot blocked so will move to enemy') end
                    end
                else
                    iMaxDistToBeInRange = 1.5
                    local iEnemyHighestDFInThisLZ = 0
                    local bConsiderAttackMoveDueToIntel = false
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) == false then
                        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] do
                            if iThreat >= 20 then
                                iEnemyHighestDFInThisLZ = math.max(iEnemyHighestDFInThisLZ, iRange)
                            end
                        end
                    end

                    if oACU[M28UnitInfo.refiDFRange] <= iEnemyHighestDFInThisLZ then
                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy has same or better range than us so want to be reasonable amount in range, iEnemyHighestDFInThisLZ='..iEnemyHighestDFInThisLZ..'; Radar coverage='..tLZTeamData[M28Map.refiRadarCoverage]) end
                        iMaxDistToBeInRange = 3.5
                        if (not(M28UnitInfo.CanSeeUnit(aiBrain, oEnemyToTarget, false)) or (tLZTeamData[M28Map.refiRadarCoverage] < 30 and not(M28UnitInfo.IsUnitValid(oACU[M28Land.refoAssignedLandScout])))) then
                            iMaxDistToBeInRange = math.max(iMaxDistToBeInRange, math.min(iMaxDistToBeInRange, 3) + oACU[M28UnitInfo.refiDFRange] - (oACU:GetBlueprint().Intel.VisionRadius or oACU[M28UnitInfo.refiDFRange]))
                            bConsiderAttackMoveDueToIntel = true
                        end
                    elseif oACU[M28UnitInfo.refiDFRange] - 6 >= iEnemyHighestDFInThisLZ then
                        --If nearest enemy unit isnt facing us then increase dist to be in range
                        local iAngleDif = M28Utilities.GetAngleDifference(M28UnitInfo.GetUnitFacingAngle(oEnemyToTarget), M28Utilities.GetAngleFromAToB(oEnemyToTarget:GetPosition(), oACU:GetPosition()))
                        if (EntityCategoryContains(categories.COMMAND + M28UnitInfo.refCategoryStructure, oEnemyToTarget.UnitId) and not(oEnemyToTarget:IsUnitState('Attacking')) and not(oEnemyToTarget:IsUnitState('Moving'))) then
                            iMaxDistToBeInRange = math.max(3.5, oACU[M28UnitInfo.refiDFRange] - iEnemyHighestDFInThisLZ - 2)
                        elseif iAngleDif >= 55 then
                            iMaxDistToBeInRange = 3.5
                        elseif iAngleDif <= 10 and oEnemyToTarget:IsUnitState('Moving') then
                            iMaxDistToBeInRange = 0.25
                        end
                        if (not(M28UnitInfo.CanSeeUnit(aiBrain, oEnemyToTarget, false)) or (tLZTeamData[M28Map.refiRadarCoverage] < 30 and not(M28UnitInfo.IsUnitValid(oACU[M28Land.refoAssignedLandScout])))) then
                            iMaxDistToBeInRange = math.max(iMaxDistToBeInRange, math.min(iMaxDistToBeInRange, 3) + oACU[M28UnitInfo.refiDFRange] - (oACU:GetBlueprint().Intel.VisionRadius or oACU[M28UnitInfo.refiDFRange]))
                            bConsiderAttackMoveDueToIntel = true
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iAngleDif='..iAngleDif..'; iMaxDistToBeInRange='..iMaxDistToBeInRange..'; iEnemyHighestDFInThisLZ range='..iEnemyHighestDFInThisLZ..'; ACU vision range='..oACU:GetBlueprint().Intel.VisionRadius) end
                    end
                    local iStraightLineDist = M28Utilities.GetDistanceBetweenPositions(oEnemyToTarget:GetPosition(), oACU:GetPosition())
                    local iNearbyMobileEnemyDFThreat = (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                            local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                            iNearbyMobileEnemyDFThreat = iNearbyMobileEnemyDFThreat + tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]
                        end
                    end
                    local bWantKitingRetreat = false
                    local iEnemyT1ArtiAndDFThreatCloseToOurRange = 0

                    if iStraightLineDist + iMaxDistToBeInRange <= oACU[M28UnitInfo.refiDFRange] and (iOurACUHealthPercent <= 0.75 or iNearbyMobileEnemyDFThreat >= 250 or (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 150) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to do a kiting retreat, iStraightLineDist='..iStraightLineDist..'; iMaxDistToBeInRange='..iMaxDistToBeInRange..'; Our DF range='..(oACU[M28UnitInfo.refiDFRange] or 'nil')..'; ACU health%='..(iOurACUHealthPercent or 'nil')..'; iNearbyMobileEnemyDFThreat='..iNearbyMobileEnemyDFThreat..'; tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')) end
                        bWantKitingRetreat = true
                        --Exception - we have >= enemy range, and the threat of enemy units within our range + 5 isn't that great, and the mobile threat of enemy units isn't that great
                        local iAdjacentThreatThreshold = 1500 + oACU[refiUpgradeCount] * 750
                        if not(M28Team.tTeamData[iTeam][M28Team. refbAssassinationOrSimilar]) then
                            iAdjacentThreatThreshold = iAdjacentThreatThreshold * 3
                        end
                        local iACUInZone = 1
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefAlliedACU]) == false then iACUInZone = table.getn(tLZTeamData[M28Map.subrefAlliedACU]) end
                        if iACUInZone > 1 then
                            iAdjacentThreatThreshold = iAdjacentThreatThreshold * (1 + (iACUInZone -1) * 0.6)
                        end
                        local iEnemyThreatThresholdForDetailedCheck = 1750 + oACU[refiUpgradeCount] * 750

                        if iOurACUHealthPercent >= 0.95 then
                            iEnemyThreatThresholdForDetailedCheck = iEnemyThreatThresholdForDetailedCheck + 500 + 250 * oACU[refiUpgradeCount]
                        end

                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to ignore kiting retreat and advance due to low enemy threat, iNearbyMobileEnemyDFThreat (which is mobile DF in this and adjacent zones)='..iNearbyMobileEnemyDFThreat..'; iAdjacentThreatThreshold='..iAdjacentThreatThreshold..'; iACUInZone='..iACUInZone..'; iEnemyThreatThresholdForDetailedCheck='..iEnemyThreatThresholdForDetailedCheck) end
                        if iNearbyMobileEnemyDFThreat <= iEnemyThreatThresholdForDetailedCheck then --will do a more detailed check later on
                            local iCurDist
                            local iACUDistThreshold = (oACU[M28UnitInfo.refiDFRange] or 0)
                            local iShortEnemyRangeThreshold = 6
                            local iLongEnemyRangeThreshold = 40
                            local iPDDistThreshold = 10 --i.e. if PD is this much close to being in range of us we will take into account its threat
                            local iEnemyT1PDInRangeOfUs = 0
                            local iEnemyNearbyT2PlusPDThreat = 0
                            local iEnemyFurtherAwayLRPDThreat = 0

                            if M28Map.iMapSize >= 1000 or tLZTeamData[M28Map.refiModDistancePercent] >= 0.5 then iLongEnemyRangeThreshold = 80 end
                            local iEnemyMobileThreatSlightlyFurtherAway = 0
                            local bEnemyHasLongerRangedUnits = false

                            function AddNearbyCombatThreat(tCurLZTeamData)
                                if M28Utilities.IsTableEmpty(tCurLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                                    --Include all units either close to being in our range, or that are close to being able to fire at us

                                    local tEnemyUnitsOfInterest = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryPD, tCurLZTeamData[M28Map.subrefTEnemyUnits])
                                    if M28Utilities.IsTableEmpty(tEnemyUnitsOfInterest) == false then
                                        local iCurThreatRating
                                        for iUnit, oUnit in tEnemyUnitsOfInterest do
                                            if M28UnitInfo.IsUnitValid(oUnit) then
                                                if not(bEnemyHasLongerRangedUnits) and (oUnit[M28UnitInfo.refiDFRange] or 0) > (oACU[M28UnitInfo.refiDFRange] or 0) then
                                                    bEnemyHasLongerRangedUnits = true
                                                end
                                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if enemy unit is close enough to record threat, iCurDist='..iCurDist..'; iACUDistThreshold='..iACUDistThreshold..'; Unit DF range and  SR threshold='..(oUnit[M28UnitInfo.refiDFRange] or 0) + iShortEnemyRangeThreshold..'; Unit threat='..M28UnitInfo.GetCombatThreatRating({ oUnit }, false, false)..'; Unit combat range and LR threat='..(oUnit[M28UnitInfo.refiCombatRange] or 0) + iLongEnemyRangeThreshold) end
                                                if iCurDist <= iACUDistThreshold or iCurDist <= (oUnit[M28UnitInfo.refiDFRange] or 0) + iShortEnemyRangeThreshold then
                                                    iCurThreatRating = M28UnitInfo.GetCombatThreatRating({ oUnit }, false, false)
                                                    iEnemyT1ArtiAndDFThreatCloseToOurRange = iEnemyT1ArtiAndDFThreatCloseToOurRange + iCurThreatRating
                                                    if EntityCategoryContains(M28UnitInfo.refCategoryPD, oUnit.UnitId) then
                                                        if (oUnit[M28UnitInfo.refiDFRange] or 0) <= (oACU[M28UnitInfo.refiDFRange] or 0) then
                                                            iEnemyT1PDInRangeOfUs = iEnemyT1PDInRangeOfUs + iCurThreatRating
                                                        elseif (oUnit[M28UnitInfo.refiDFRange] or 0) > (oACU[M28UnitInfo.refiDFRange] or 0) then
                                                            iEnemyNearbyT2PlusPDThreat = iEnemyNearbyT2PlusPDThreat + iCurThreatRating
                                                        end
                                                    end

                                                elseif iCurDist <= (oUnit[M28UnitInfo.refiCombatRange] or 0) + iLongEnemyRangeThreshold then
                                                    iCurThreatRating = M28UnitInfo.GetCombatThreatRating({ oUnit }, false, false)
                                                    iEnemyMobileThreatSlightlyFurtherAway = iEnemyMobileThreatSlightlyFurtherAway + iCurThreatRating
                                                    if EntityCategoryContains(M28UnitInfo.refCategoryPD, oUnit.UnitId) then
                                                        if iCurDist > (oUnit[M28UnitInfo.refiCombatRange] or 0) + iPDDistThreshold then
                                                            --Exclude PD that isn't going to be in our range very soon given its not mobile
                                                            iEnemyMobileThreatSlightlyFurtherAway = iEnemyMobileThreatSlightlyFurtherAway - iCurThreatRating
                                                        elseif (oUnit[M28UnitInfo.refiDFRange] or 0) > (oACU[M28UnitInfo.refiDFRange] or 0) then
                                                            iEnemyFurtherAwayLRPDThreat = iEnemyFurtherAwayLRPDThreat + iCurThreatRating
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            AddNearbyCombatThreat(tLZTeamData)
                            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                    AddNearbyCombatThreat(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam])
                                end
                            end
                            if iEnemyT1ArtiAndDFThreatCloseToOurRange <= 200 + 100 * oACU[refiUpgradeCount] and iEnemyT1ArtiAndDFThreatCloseToOurRange + iEnemyMobileThreatSlightlyFurtherAway <= 600 + oACU[refiUpgradeCount] * 300 then
                                bWantKitingRetreat = false
                                if bDebugMessages == true then LOG(sFunctionRef..': Dont want to do king retreat after all') end
                            elseif oACU[refiUpgradeCount] >= 2 and (oACU[refiUpgradeCount] >= 3 or not(EntityCategoryContains(categories.AEON, oACU.UnitId))) and iOurACUHealthPercent >= 0.95 and iEnemyT1ArtiAndDFThreatCloseToOurRange <= 1800 and iEnemyT1ArtiAndDFThreatCloseToOurRange + iEnemyMobileThreatSlightlyFurtherAway <= 2700 and iEnemyT1PDInRangeOfUs == 0 and (iEnemyT1ArtiAndDFThreatCloseToOurRange + iEnemyMobileThreatSlightlyFurtherAway <= 1900 or iEnemyNearbyT2PlusPDThreat + iEnemyFurtherAwayLRPDThreat >= 800) then
                                bWantKitingRetreat = false
                                if bDebugMessages == true then LOG(sFunctionRef..': We have high health and are heavily upgraded so want to press a bit more either due to enemy threat not being massive, or because neemy threat includes PD which we could always run from') end
                                --if shot is blocked for the closest enemy unit then dont kite
                            elseif bEnemyHasLongerRangedUnits and iEnemyT1ArtiAndDFThreatCloseToOurRange <= iEnemyThreatThresholdForDetailedCheck * 0.5 and M28Logic.IsShotBlocked(oACU, oEnemyToTarget, false, nil) then
                                bWantKitingRetreat = false
                                if bDebugMessages == true then LOG(sFunctionRef..': Our shot is blocked so dont want to kite enemy') end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iEnemyT1ArtiAndDFThreatCloseToOurRange='..iEnemyT1ArtiAndDFThreatCloseToOurRange..'; iEnemyMobileThreatSlightlyFurtherAway='..iEnemyMobileThreatSlightlyFurtherAway..'; iEnemyT1PDInRangeOfUs='..iEnemyT1PDInRangeOfUs..'; iEnemyNearbyT2PlusPDThreat='..iEnemyNearbyT2PlusPDThreat..'; iEnemyFurtherAwayLRPDThreat='..iEnemyFurtherAwayLRPDThreat..'; bEnemyHasLongerRangedUnits='..tostring(bEnemyHasLongerRangedUnits)..'; Is shot blocked='..tostring(M28Logic.IsShotBlocked(oACU, oEnemyToTarget, false, nil))) end
                        end
                    end

                    --Check for ACUs in our range that we outrange
                    local tACUsNearby
                    if M28Utilities.IsTableEmpty(tUnitsToTarget) == false then tACUsNearby = EntityCategoryFilterDown(categories.COMMAND, tUnitsToTarget) end
                    local oClosestACU
                    local iClosestACU = 1000
                    local bOutrangeAllACUs = true
                    if M28Utilities.IsTableEmpty(tACUsNearby) == false and oACU[M28UnitInfo.refiDFRange] >= 28 then
                        for iEnemyACU, oEnemyACU in tACUsNearby do
                            if oACU[M28UnitInfo.refiDFRange] >= oEnemyACU then
                                bOutrangeAllACUs = false
                                break
                            end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oEnemyACU:GetPosition())
                            if iCurDist < iClosestACU then
                                iClosestACU = iCurDist
                                oClosestACU = oEnemyACU
                            end
                        end
                    end
                    if bDebugMessages == true then
                        if oClosestACU then
                            LOG(sFunctionRef..': iClosestACU='..iClosestACU..'; Can see ACU='..tostring(M28UnitInfo.CanSeeUnit(aiBrain, oClosestACU))..'; Do we have a valid land scout='..tostring(M28UnitInfo.IsUnitValid(oACU[M28Land.refoAssignedLandScout]))..'; Closest ACU health%='..M28UnitInfo.GetUnitHealthAndShieldPercent(oClosestACU)..'; Our ACU health%='..iOurACUHealthPercent..'; Enemy ACU range='..oClosestACU[M28UnitInfo.refiDFRange]..'; tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange]='..tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange]..'; tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]='..tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] ..'; iEnemyT1ArtiAndDFThreatCloseToOurRange='..iEnemyT1ArtiAndDFThreatCloseToOurRange..'; Mod dist%='..tLZTeamData[M28Map.refiModDistancePercent]..'; ACU shot blocked='..tostring(oACU[M28UnitInfo.refbLastShotBlocked] or false))
                            if M28UnitInfo.IsUnitValid(M28UnitInfo.IsUnitValid(oACU[M28Land.refoAssignedLandScout])) then LOG(sFunctionRef..': Dist to assigned land scout='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oACU[M28Land.refoAssignedLandScout]:GetPosition())) end
                        else LOG(sFunctionRef..': No nearby enemy ACU')
                        end
                    end

                    local oUnitToMoveTo
                    --If within 2 of being in range of enemy ACU that we outrange then keep pressing forwards (we will ignore this if we decide we still want kiting retreat)
                    if iUnitPlateau > 0 and iClosestACU <= oACU[M28UnitInfo.refiDFRange] + 2 and (M28UnitInfo.CanSeeUnit(aiBrain, oClosestACU) or (M28UnitInfo.IsUnitValid(oACU[M28Land.refoAssignedLandScout]) and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oACU[M28Land.refoAssignedLandScout]:GetPosition()) <= 40) or (iOurACUHealthPercent >= 0.9 and iClosestACU <= oACU[M28UnitInfo.refiDFRange] and tLZTeamData[M28Map.refiModDistancePercent] <= 0.8 and M28UnitInfo.GetUnitHealthAndShieldPercent(oClosestACU) < iOurACUHealthPercent - 0.05)) and iOurACUHealthPercent * 0.95 > M28UnitInfo.GetUnitHealthAndShieldPercent(oClosestACU) then
                        local iOurVisualRange = oACU:GetBlueprint().Intel.VisionRadius
                        if bDebugMessages == true then LOG(sFunctionRef..': iOurVisualRange='..iOurVisualRange..'; iClosestACU='..iClosestACU..'; oClosestACU owner='..oClosestACU:GetAIBrain().Nickname) end
                        if iClosestACU > iOurVisualRange - 3 or (oACU[M28UnitInfo.refbLastShotBlocked] or iOurACUHealthPercent > 0.4 + M28UnitInfo.GetUnitHealthPercent(oClosestACU) or M28Logic.IsShotBlocked(oACU, oClosestACU, false, false)) then
                            oUnitToMoveTo = oClosestACU
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to move to enemy ACU unless decide to kite, oClosestACU='..oClosestACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestACU)) end
                        end
                    end

                    --Consider override for kiting retreat if enemy ACU in our range, and we have more health than them, and enemy lacks T2 PD/similar
                    if oUnitToMoveTo and bWantKitingRetreat and oClosestACU and iClosestACU <= oACU[M28UnitInfo.refiDFRange] then
                        if bOutrangeAllACUs and oACU[M28UnitInfo.refiDFRange]  >= math.max((tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0), (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0)) and (iEnemyT1ArtiAndDFThreatCloseToOurRange <= 1500 or (iOurACUHealthPercent > 0.2 + M28UnitInfo.GetUnitHealthPercent(oClosestACU) and M28UnitInfo.GetUnitHealthPercent(oClosestACU) <= 0.55 and (not(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) or oClosestACU:GetHealth() <= 4000))) and (iClosestACU > oClosestACU[M28UnitInfo.refiDFRange] or (iOurACUHealthPercent > 0.2 + M28UnitInfo.GetUnitHealthPercent(oClosestACU) and (oACU[M28UnitInfo.refbLastShotBlocked] or iOurACUHealthPercent > 0.4 + M28UnitInfo.GetUnitHealthPercent(oClosestACU)))) then
                            if iOurACUHealthPercent >= M28UnitInfo.GetUnitHealthPercent(oClosestACU) then
                                if bDebugMessages == true then LOG(sFunctionRef..': We are in range of an enemy ACU that we outrange, so want to ignore kiting retreat and go for the kill') end
                                bWantKitingRetreat = false
                            end
                        end
                        --Up against a stealthed ACU and we have good health
                        if bDebugMessages == true then LOG(sFunctionRef..': iClosestACU='..iClosestACU..'; iOurACUHealthPercent='..iOurACUHealthPercent..'; Does enemy ACU have stealth or nano='..tostring((oClosestACU:HasEnhancement('Stealth') or oClosestACU:HasEnhancement('FAF_SelfRepairSystem')))) end
                        if bWantKitingRetreat and iClosestACU >= (oACU:GetBlueprint().Intel.VisionRadius or 26) - 4 and iOurACUHealthPercent >= 0.8 and EntityCategoryContains(categories.CYBRAN, oClosestACU.UnitId) and (oClosestACU:HasEnhancement('Stealth') or oClosestACU:HasEnhancement('FAF_SelfRepairSystem')) and (tLZTeamData[M28Map.refiOmniCoverage] or 0) < 50 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Up against cybran acu with stealth so want to stay close to it so we can keep firing') end
                            bWantKitingRetreat = false
                        end
                    end

                    if bDebugMessages == true then LOG(sFunctionRef..': oEnemyToTarget='..oEnemyToTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToTarget)..'; iClosestDist='..iClosestDist..'; iMaxDistToBeInRange='..iMaxDistToBeInRange..'; ACU DF range='..(oACU[M28UnitInfo.refiDFRange] or 0)..'; ACU position='..repru(oACU:GetPosition())..'; Enemy unit to target='..repru(oEnemyToTarget:GetPosition())..'; Dist betweeh tnem straight line='..M28Utilities.GetDistanceBetweenPositions(oEnemyToTarget:GetPosition(), oACU:GetPosition())..'; ACU health percent='..iOurACUHealthPercent..'; Enemy combat total based just on this zone='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; iNearbyMobileEnemyDFThreat='..iNearbyMobileEnemyDFThreat..'; bWantKitingRetreat='..tostring(bWantKitingRetreat)) end
                    if bWantKitingRetreat then
                        --Retreat temporarily - if aren't in a core zone then retreat to rally point
                        local tRallyPoint
                        if tLZTeamData[M28Map.subrefLZbCoreBase] then
                            --Retreat from nearest enemy
                            local iAngleFromEnemyToACU = M28Utilities.GetAngleFromAToB(oEnemyToTarget:GetPosition(), oACU:GetPosition())
                            tRallyPoint = M28Utilities.MoveInDirection(oACU:GetPosition(), iAngleFromEnemyToACU, 6, true, true, M28Map.bIsCampaignMap)
                            --Check this is in the same plateau, otherwise move it
                            local iRallyPlateau = NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, tRallyPoint)
                            if iRallyPlateau == iPlateau then
                                --Do nothing
                            else
                                local bHavePlateauInSameArea = false
                                --Search for position in the same plateau
                                for iAngleAdjust = -20, 20, 20 do
                                    for iDist = 7, 28, 7 do
                                        tRallyPoint = M28Utilities.MoveInDirection(oACU:GetPosition(), iAngleAdjust + iAngleFromEnemyToACU, 6, true, true, M28Map.bIsCampaignMap)
                                        iRallyPlateau = NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tRallyPoint)
                                        if iRallyPlateau == iPlateau then
                                            bHavePlateauInSameArea = true
                                            break
                                        end
                                    end
                                    if bHavePlateauInSameArea then break end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Are in core zone so will move away from nearest enemy, tRallyPoint='..repru(tRallyPoint)) end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Will move to nearest rally point') end
                            tRallyPoint = M28Land.GetNearestLandRallyPoint(tLZData, oACU:GetAIBrain().M28Team, iPlateau, iLandZone, 2, true)
                        end
                        M28Orders.IssueTrackedMove(oACU, tRallyPoint, 6, false, 'ACUKit', false)
                    else
                        --If near to enemy ACU that we outrange then stay within visual range of it
                        if oUnitToMoveTo then
                            M28Orders.IssueTrackedMove(oACU, oUnitToMoveTo:GetPosition(), 0, false, 'ACUMacu', false)
                            oACU[refbOnlyOverchargeHighValueTargets] = true
                            oEnemyToTarget = oUnitToMoveTo --need to set this or else we will think we didnt get an order
                            if bDebugMessages == true then LOG(sFunctionRef..': will move closer to enemy ACU that we outrange, oUnitToMoveTo='..oUnitToMoveTo.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToMoveTo)..' owned by '..oUnitToMoveTo:GetAIBrain().Nickname..'; refbOnlyOverchargeHighValueTargets='..tostring(oACU[refbOnlyOverchargeHighValueTargets])..'; Position of enemy='..repru(oUnitToMoveTo:GetPosition())) end
                        elseif bNearestEnemyIsShieldedButEnemyToTargetLacksShield and ((iEnemyT1ArtiAndDFThreatCloseToOurRange or 0) <= 250 or M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.8) then
                            local iCurDist = M28Utilities.GetDistanceBetweenPositions(oEnemyToTarget:GetPosition(), oACU:GetPosition())
                            if iCurDist > (oACU[M28UnitInfo.refiDFRange] or 0) + 2 then
                                M28Orders.IssueTrackedMove(oACU, oEnemyToTarget:GetPosition(), 5, false, 'ACUAShlM', false)
                            else
                                M28Orders.IssueTrackedAttack(oACU, oEnemyToTarget, false, 'ACUAShlA', false)
                            end
                        elseif iEnemyT1ArtiAndDFThreatCloseToOurRange >= 250 then
                            --Attack-move towards enemy due to significant threat
                            if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Will attack-move to enemy target unless have active micro, oEnemyToTarget='..oEnemyToTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToTarget)..'; refbSpecialMicroActive='..tostring(oACU[M28UnitInfo.refbSpecialMicroActive] or false)) end
                            M28Orders.IssueTrackedAggressiveMove(oACU, oEnemyToTarget:GetPosition(), 5, false, 'ACUAtM', false)
                        else
                            local iCurDist = M28Utilities.GetDistanceBetweenPositions(oEnemyToTarget:GetPosition(), oACU:GetPosition())
                            --Attack-move if in range of enemy, and either dealing with more dangerous unit, or a greater general enemy threat level
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurDist='..iCurDist..'; iNearbyMobileEnemyDFThreat='..iNearbyMobileEnemyDFThreat..'; Enemy unit range='..(oEnemyToTarget[M28UnitInfo.refiDFRange] or 0)..'; Considering whether to attack move or move, iMaxDistToBeInRange='..iMaxDistToBeInRange..'; Are we close enoguh we want to attack under 1 measure='..tostring((iCurDist <= oACU[M28UnitInfo.refiDFRange] - math.min(10, math.max(0.25, iMaxDistToBeInRange - 2))))..'; Is enemy an ACU or dangerous or immobile unit='..tostring(EntityCategoryContains(categories.COMMAND + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryLandCombat * categories.TECH2 + categories.TECH3 - M28UnitInfo.refCategoryEngineer, oEnemyToTarget.UnitId))) end
                            if iCurDist <= 8 or ((iCurDist <= oACU[M28UnitInfo.refiDFRange] - math.min(10, math.max(0.25, iMaxDistToBeInRange - 2)) or (iCurDist <= oACU[M28UnitInfo.refiDFRange] and iCurDist <= 2 + (oEnemyToTarget[M28UnitInfo.refiDFRange] or 0))) and (EntityCategoryContains(categories.COMMAND + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryLandCombat * categories.TECH2 + categories.TECH3 - M28UnitInfo.refCategoryEngineer, oEnemyToTarget.UnitId) or (iNearbyMobileEnemyDFThreat >= 500 and iCurDist <= oACU[M28UnitInfo.refiDFRange] - 8))) or (bConsiderAttackMoveDueToIntel and iCurDist < oACU[M28UnitInfo.refiDFRange] - 3.5) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to attack move, bConsiderAttackMoveDueToIntel='..tostring(bConsiderAttackMoveDueToIntel)) end
                                M28Orders.IssueTrackedAggressiveMove(oACU, oEnemyToTarget:GetPosition(), 5, false, 'ACUAtcM', false)
                            elseif iUnitPlateau == 0 and iCurDist <= oACU[M28UnitInfo.refiDFRange] + 2 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Targeting naval unit so attackmove towards it') end
                                M28Orders.IssueTrackedAggressiveMove(oACU, oEnemyToTarget:GetPosition(), 5, false, 'ACUAtcNM', false)
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Will move to closest enemy') end
                                if M28Conditions.GiveAttackMoveAsWeaponStuck(oACU) then
                                    M28Orders.IssueTrackedAttackMove(oACU, oEnemyToTarget:GetPosition(), 3, false, 'ACUAT')
                                else
                                    if EntityCategoryContains(categories.COMMAND, oEnemyToTarget.UnitId) and M28UnitInfo.GetUnitHealthAndShieldPercent(oEnemyToTarget) <= 0.5 then
                                        oACU[refbOnlyOverchargeHighValueTargets] = true
                                    end
                                    M28Orders.IssueTrackedMove(oACU, oEnemyToTarget:GetPosition(), 5, false, 'ACUAM', false)
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

    if oEnemyToTarget then return true else return false end
end

function ConsiderBuildingMex(tLZOrWZData, tLZOrWZTeamData, oACU, iOptionalMaxDistanceFromBuildRangeToConsider)
    --Do we have unclaimed mexes in the LZ? If so then build a mex on them.  However first check we dont alreayd have engineers trying to do this. also exception if we are overflowing mass and are in a core base

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderBuildingMex'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain = oACU:GetAIBrain()


    if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and aiBrain:GetEconomyStoredRatio('MASS') >= 0.9 and aiBrain:GetEconomyStored('MASS') >= 100 then
        if bDebugMessages == true then LOG(sFunctionRef..': Mass overflow scenario - dont want to build mex, as would rather get factory or assist something building') end
    else
        if bDebugMessages == true then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oACU:GetPosition())
            LOG(sFunctionRef..': Do we have any unbuilt locations for this LZ, iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..' - is table empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]))..'; Is table of part built mexes empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes])))
        end
        local tPotentialLocations = {}
        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false then
            for iEntry, tLocation in tLZOrWZData[M28Map.subrefMexUnbuiltLocations]  do
                table.insert(tPotentialLocations, tLocation)
            end
        end
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
            for iEntry, oMex in tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes] do
                if bDebugMessages == true then LOG(sFunctionRef..': Adding part build mex at position '..repru(oMex:GetPosition())..' to list of potential locations') end
                table.insert(tPotentialLocations, oMex:GetPosition())
            end
        end
        if M28Utilities.IsTableEmpty(tPotentialLocations) == false then
            --Check how close the mexes are - e.g. if calling this for higher priority orders we only want to consider mexes near to our build range
            local bHaveMexesWithinMaxDistanceToConsider = false
            local bHaveMexWithinACUBuildRange = false
            local iSearchRange
            local iACUBuildRange = oACU:GetBlueprint().Economy.MaxBuildDistance
            if iOptionalMaxDistanceFromBuildRangeToConsider then
                iSearchRange = iACUBuildRange + iOptionalMaxDistanceFromBuildRangeToConsider
            else
                iSearchRange = 60
            end
            if not(iOptionalMaxDistanceFromBuildRangeToConsider) then bHaveMexesWithinMaxDistanceToConsider = true
            else
                for iEntry, tLocation in tPotentialLocations do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering tLocation='..repru(tLocation)..'; iSearchRange='..iSearchRange..'; Distance to ACU='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLocation)) end
                    if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLocation) <= iSearchRange then
                        bHaveMexesWithinMaxDistanceToConsider = true
                        break
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': TIme='..GetGameTimeSeconds()..'; bHaveMexesWithinMaxDistanceToConsider='..tostring(bHaveMexesWithinMaxDistanceToConsider)..'; iSearchRange='..iSearchRange..'; iOptionalMaxDistanceFromBuildRangeToConsider='..(iOptionalMaxDistanceFromBuildRangeToConsider or 'nil')) end
            if bHaveMexesWithinMaxDistanceToConsider then
                for iEntry, tLocation in tPotentialLocations do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering location '..repru(tLocation)..'; Dist to ACU='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLocation)..'; iACUBuildRange='..iACUBuildRange) end
                    if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLocation) <= iACUBuildRange then
                        if (not(M28Overseer.bNoRushActive) or not(M28Conditions.NoRushPreventingHydroOrMex(tLZOrWZData, true))) then
                            bHaveMexWithinACUBuildRange = true
                            break
                        end
                    end
                end
                if bHaveMexWithinACUBuildRange then
                    iSearchRange = iACUBuildRange + 0.5 --added +0.5 in v117 just in case (but issue were investigating caused by different problem)
                end

                local bHaveEngineersAssignedAlready = false
                local tEngisInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])

                if M28Utilities.IsTableEmpty(tEngisInLZ) == false then
                    for iEngi, oEngi in tEngisInLZ do
                        if oEngi[M28Engineer.refiAssignedAction] == M28Engineer.refActionBuildMex or oEngi[M28Engineer.refiAssignedAction] == M28Engineer.refActionCompletePartBuiltMex then
                            bHaveEngineersAssignedAlready = true
                            break
                        end
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': bHaveMexWithinACUBuildRange='..tostring(bHaveMexWithinACUBuildRange)..'; bHaveEngineersAssignedAlready='..tostring(bHaveEngineersAssignedAlready)) end
                if not(bHaveEngineersAssignedAlready) or bHaveMexWithinACUBuildRange or ((M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) and aiBrain[M28Economy.refiGrossMassBaseIncome] < aiBrain[M28Economy.refiGrossEnergyBaseIncome] / 8) then
                    ACUActionBuildMex(oACU:GetAIBrain(), oACU, iSearchRange)
                    local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
                    if bDebugMessages == true then LOG(sFunctionRef..': Have tried telling ACU to build mex, tLastOrder='..reprs(tLastOrder)) end
                    if tLastOrder and (tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueRepair) then
                        if not(M28Conditions.DoesACUHaveValidOrder(oACU)) and (M28Orders.bDontConsiderCombinedArmy or oACU.M28Active) then
                            local tLastTarget = {tLastOrder[M28Orders.subreftOrderPosition][1], tLastOrder[M28Orders.subreftOrderPosition][2], tLastOrder[M28Orders.subreftOrderPosition][3]}
                            if bDebugMessages == true then LOG(sFunctionRef..': Trying workaround as for some reason ACU doesnt have valid order, will try building on the next mex, tLastTarget='..repru(tLastTarget)) end
                            if table.getn(tPotentialLocations) > 1 then
                                local iClosestMex = 10000
                                local tClosestMex
                                local iCurDist
                                for iLocation, tLocation in tPotentialLocations do
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tLocation, oACU:GetPosition())
                                    if iCurDist < iClosestMex then
                                        tClosestMex = {tLocation[1], tLocation[2], tLocation[3]}
                                        iClosestMex = iCurDist
                                    end
                                end
                                if tClosestMex then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will retry build order at location '..repru(tClosestMex)) end
                                    ACUBuildUnit(aiBrain, oACU, M28UnitInfo.refCategoryMex, 30, 100, nil, nil, tClosestMex)
                                    --Track micro temporarily
                                    M28Micro.TrackTemporaryUnitMicro(oACU, 2.9, nil, true)
                                end
                            end

                        end
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return true
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, did not give build mex order') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function ConsiderNearbyReclaimForACUOrEngineer(iPlateau, iLandZone, tLZData, tLZTeamData, oEngineer, bOnlyConsiderIfInBuildRange, iIndividualReclaimThresholdOverride, iTotalReclaimFactorOverride, iMassStoredThresholdOverride)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderNearbyReclaimForACUOrEngineer'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if EntityCategoryContains(categories.RECLAIM, oEngineer.UnitId) then

        local iTotalReclaimWanted
        local iIndividualReclaimThreshold
        local bGetEnergy = false
        if bOnlyConsiderIfInBuildRange then
            if (oEngineer[refiUpgradeCount] or 0) > 0 and not(oEngineer.HasEnhancement and oEngineer:HasEnhancement('AdvancedEngineering')) then
                if (tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) or not(M28Conditions.TeamHasLowMass(oEngineer:GetAIBrain().M28Team)) then
                    iIndividualReclaimThreshold = iIndividualReclaimThresholdOverride or 24
                else
                    iIndividualReclaimThreshold = iIndividualReclaimThresholdOverride or 15
                end
                iTotalReclaimWanted = iIndividualReclaimThreshold * (iTotalReclaimFactorOverride or 4)
                if not(iTotalReclaimFactorOverride) and oEngineer[refiUpgradeCount] >= 2 and (oEngineer[refiUpgradeCount] >= 3 or not(EntityCategoryContains(categories.AEON, oEngineer.UnitId))) then
                    iTotalReclaimWanted = iTotalReclaimWanted * 1.5
                end
            else
                if M28Conditions.TeamHasLowMass(oEngineer:GetAIBrain().M28Team) then
                    iIndividualReclaimThreshold = iIndividualReclaimThresholdOverride or 10
                    iTotalReclaimWanted = iIndividualReclaimThreshold * (iTotalReclaimFactorOverride or 2.5)
                else
                    iTotalReclaimWanted = 40
                    iIndividualReclaimThreshold = iIndividualReclaimThresholdOverride or 10
                    iTotalReclaimWanted = iIndividualReclaimThreshold * (iTotalReclaimFactorOverride or 4)
                end
            end
            if oEngineer:GetAIBrain():GetEconomyStored('ENERGY') <= 50 then
                bGetEnergy = true
                iIndividualReclaimThreshold = iIndividualReclaimThresholdOverride or 15
                iTotalReclaimWanted = iIndividualReclaimThreshold * (iTotalReclaimFactorOverride or 1)
            end
        else
            if iIndividualReclaimThresholdOverride then
                iIndividualReclaimThreshold = iIndividualReclaimThresholdOverride
            elseif M28Conditions.TeamHasLowMass(oEngineer:GetAIBrain().M28Team) then
                iIndividualReclaimThreshold = 20
            else
                iIndividualReclaimThreshold = 25
            end
            iTotalReclaimWanted = iIndividualReclaimThreshold * (iTotalReclaimFactorOverride or 5)
            if tLZTeamData[M28Map.subrefLZbCoreBase] and (GetGameTimeSeconds() <= 300 and M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subrefiTeamGrossMass]) <= 5 then iTotalReclaimWanted = iTotalReclaimWanted * 2 end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': LZ reclaim mass='..tLZData[M28Map.subrefTotalMassReclaim]..'; subrefTotalSignificantMassReclaim='..tLZData[M28Map.subrefTotalSignificantMassReclaim]..'; Team mass % stored='..M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subrefiTeamAverageMassPercentStored]..'; iTotalReclaimWanted='..iTotalReclaimWanted..'; iIndividualReclaimThreshold='..iIndividualReclaimThreshold..'; bOnlyConsiderIfInBuildRange='..tostring(bOnlyConsiderIfInBuildRange or false)..'; bGetEnergy='..tostring(bGetEnergy or false)..'; Mass stored threshold='..(iMassStoredThresholdOverride or 'nil')) end

        if (bGetEnergy and tLZData[M28Map.subrefLZTotalEnergyReclaim] >= iTotalReclaimWanted) or (not(bGetEnergy) and tLZData[M28Map.subrefTotalMassReclaim] >= iTotalReclaimWanted and (tLZData[M28Map.subrefTotalSignificantMassReclaim] >= iIndividualReclaimThreshold or iIndividualReclaimThreshold <= M28Map.iSignificantMassThreshold * 0.7) and M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subrefiTeamAverageMassPercentStored] <= (iMassStoredThresholdOverride or 0.6)) then
            --If any reclaim of iIndividualReclaimThreshold+ value then get ACU to reclaim
                                          --GetEngineerToReclaimNearbyArea(oEngineer, iPriorityOverride, tLZOrWZTeamData, iPlateauOrPond, iLandOrWaterZone, bWantEnergyNotMass, bOnlyConsiderReclaimInRangeOfEngineer, iMinIndividualValueOverride, bIsWaterZone, bOptionalReturnTrueIfGivenOrder)
            local bGivenOrder = M28Engineer.GetEngineerToReclaimNearbyArea(oEngineer, 1,                    tLZTeamData, iPlateau,          iLandZone,      bGetEnergy,         (bOnlyConsiderIfInBuildRange or false), iIndividualReclaimThreshold, false, true)
            if bDebugMessages == true then LOG(sFunctionRef..': ACU last order after checking for reclaim in area='..reprs(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]])) end
            local tLastOrder = oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]]
            if bGivenOrder and tLastOrder and tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueReclaim then
                if bDebugMessages == true then LOG(sFunctionRef..': ACU has a reclaim order so will stop') end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function MoveToOtherLandZone(iPlateau, tLZData, iLandZone, oACU)
    --COnsiders the land zone we want to support with the ACU - get the LZ within 175 travel distance that has the greatest value, wants DF support, and has less than 800 enemy threat in it
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MoveToOtherLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iLZToMoveTo
    local iTeam = oACU:GetAIBrain().M28Team
    local iAdjLZ
    if bDebugMessages == true then LOG(sFunctionRef..': Will consider moving to another LZ for ACU '..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' owned by '..oACU:GetAIBrain().Nickname..'; Is table of pathing to other LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]))) end
    local iHighValueDistanceThreshold = 175
    local iLowerPriorityDistanceThreshold = 300
    --Increase distance if ACU has upgrade and is near-full health, and we and enemy lack T3
    if (oACU[refiUpgradeCount] > 0 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1) and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.95 and ((M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] < 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] < 3) or (not(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs]) and oACU[refiUpgradeCount] >= 2 and (M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 2 and not(M28Team.tTeamData[iTeam][M28Team. refbAssassinationOrSimilar])) and not(oACU:HasEnhancement('ResourceAllocation') and not(oACU:HasEnhancement('ResourceAllocationAdvanced')) and (oACU[refiUpgradeCount] >= 3 or (oACU.MyShield.GetHealth and oACU.MyShield:GetHealth() >= 4000) or oACU:GetHealth() >= 15000)))) then
        iLowerPriorityDistanceThreshold = iLowerPriorityDistanceThreshold + 100
        --Increase by another 50 if we are less than half map size and all indicators are ok
        local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
        if bDebugMessages == true then LOG(sFunctionRef..': Increased lower priority distance threshold, iLowerPriorityDistanceThreshold='..iLowerPriorityDistanceThreshold..'; will consider if want to increase further, upgradecount='..oACU[refiUpgradeCount]..'; In core base='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])..'; Highest enemy ground tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]..'; Highest enemy air tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech]..'; Map size='..M28Map.iMapSize) end
        if tLZTeamData[M28Map.subrefLZbCoreBase] and oACU[refiUpgradeCount] >= 2 and iLowerPriorityDistanceThreshold < math.min(475, M28Map.iMapSize * 0.6) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] < 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] < 3 and M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 2 and not(M28Team.tTeamData[iTeam][M28Team. refbAssassinationOrSimilar]) then
            if bDebugMessages == true then LOG(sFunctionRef..': Increased lower priority dist by a further 50') end
            iLowerPriorityDistanceThreshold = iLowerPriorityDistanceThreshold + 50
        end
    end
    local iLastPathedZoneTravelDist
    local iRecentLandZoneRef
    local iSecondsToIgnoreZonesRecentlyRunFrom = 30
    if bDebugMessages == true then LOG(sFunctionRef..': Time ACU last had order to move to zone='..(oACU[refiTimeLastToldToMoveToZone] or 'nil')..'; oACU[refiLastPlateauAndZoneToMoveTo]='..repru(oACU[refiLastPlateauAndZoneToMoveTo])..'; iLowerPriorityDistanceThreshold berfore last zone adjust='..iLowerPriorityDistanceThreshold) end
    if GetGameTimeSeconds() - (oACU[refiTimeLastToldToMoveToZone] or -100) <= 10 and not(oACU[refiLastPlateauAndZoneToMoveTo][1] == 0) then
        iRecentLandZoneRef = oACU[refiLastPlateauAndZoneToMoveTo][2]
        iLastPathedZoneTravelDist = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iRecentLandZoneRef)

        iHighValueDistanceThreshold = math.max(iHighValueDistanceThreshold, (iLastPathedZoneTravelDist or 190) + 1)
        iLowerPriorityDistanceThreshold = math.max(iLowerPriorityDistanceThreshold, (iLastPathedZoneTravelDist or 315) + 1)
        if bDebugMessages == true then LOG(sFunctionRef..': Recently tried to travel to land zone '..(iRecentLandZoneRef or 'nil')..'; iHighValueDistanceThreshold='..iHighValueDistanceThreshold..'; iLowerPriorityDistanceThreshold='..iLowerPriorityDistanceThreshold..'; iLastPathedZoneTravelDist='..(iLastPathedZoneTravelDist or 'nil')) end
    end
    local tbIslandsAlreadyConsidered = {}
    local iWaterZoneToConsiderBuildingNavalFactoryInFirst
    local aiBrain = oACU:GetAIBrain()
    --ACUs without torpedo upgrade early game where not had too many failed naval fac attempts and on a naval map - have ACU build naval fac (will consider later on if we find such a wz we want to help)
        --First consider global and cur LZ specific checks for if we want acu to build naval fac:
    if M28Conditions.DoesACUWantToConsiderGettingNavalFactoryInCurWaterZone(oACU, aiBrain, iTeam, tLZData, tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team], iLandZone, true, false) then
        --Consider if we have a nearby naval zone that wants more engineers and send ACU there to help construction, unless have a higher priority target
        local iAdjWZ, iPond, iCurWZDist
        local iClosestWZConsideringDist = 10000
        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
            iAdjWZ = tSubtable[M28Map.subrefAWZRef]
            iPond = M28Map.tiPondByWaterZone[iAdjWZ]
            local tAdjWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
            local tAdjWZTeamData = tAdjWZData[M28Map.subrefWZTeamData][iTeam]
            --next consider zone specific checks for if ACU wants to get naval fac in this zone
            if M28Conditions.DoesACUWantToConsiderGettingNavalFactoryInCurWaterZone(oACU, aiBrain, iTeam, tAdjWZData, tAdjWZTeamData, iAdjWZ, false, true) then
                iCurWZDist = M28Utilities.GetDistanceBetweenPositions(tAdjWZData[M28Map.subrefMidpoint], oACU:GetPosition())
                if not(iRecentLandZoneRef) and oACU[refiLastPlateauAndZoneToMoveTo][2] == iAdjWZ and oACU[refiLastPlateauAndZoneToMoveTo][1] == 0 then iCurWZDist = iCurWZDist - 50 end
                if iCurWZDist < iClosestWZConsideringDist then
                    iWaterZoneToConsiderBuildingNavalFactoryInFirst = iAdjWZ
                    iClosestWZConsideringDist = iCurWZDist
                end
            end
        end
    end
    --First consider adjacent zones wanting combat support
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
        local iHighestValueAmount = 0
        local iCurValue
        for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
            iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; Travel dist='..tPathingDetails[M28Map.subrefLZTravelDist]..'; Does it want DF support='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport])) end
            if tPathingDetails[M28Map.subrefLZTravelDist] < iHighValueDistanceThreshold then
                if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport] then
                    iCurValue = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTValue]
                    if iAdjLZ == iRecentLandZoneRef then iCurValue = iCurValue * 1.05 + 25 end
                    if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTValue] > iHighestValueAmount then
                        --Have we run from this zone recently?
                        if not(oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iAdjLZ]) or GetGameTimeSeconds() - oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iAdjLZ] > iSecondsToIgnoreZonesRecentlyRunFrom then
                            if not(oACU[refiLastPlateauAndZoneToAttackUnitIn][2] == iAdjLZ) or not(oACU[refiLastPlateauAndZoneToAttackUnitIn][1] == iPlateau) or GetGameTimeSeconds() - (oACU[refiTimeLastToldToAttackUnitInOtherZone] or -100) > 30 then
                                iHighestValueAmount = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTValue]
                                iLZToMoveTo = iAdjLZ
                            end
                        end
                    end
                end
            else
                break
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished considering nearby zones, iLZToMoveTo='..(iLZToMoveTo or 'nil')) end
        if not(iLZToMoveTo) then
            --Are there any LZs nearby with unclaimed mexes, dangerous enemy ground units where we want DF support, or significant reclaim?
            local iNearestPotentialExpansionPoint, iPlannedDistOfPotentialExpansion

            local tLZTeamData = tLZData[M28Map.subrefLZTeamData][oACU:GetAIBrain().M28Team]
            local iDistToClosestEnemyFromStart = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], tLZTeamData[M28Map.reftClosestEnemyBase])
            local iCurZoneValue, iBestZoneDist
            local iBestZoneValue = 0
            local iClosestWorthwhileTravelDist
            local bBestZoneHasNearbyEnemies = false
            function GetAdjZoneValueForACU(iAdjLZ, iCurTravelDist, iShortestTravelDist)
                local iCurValue = 0
                local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': Considering zone '..iAdjLZ..'; Travel dist='..iCurTravelDist..'; Dangerous enemies here='..tostring(tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])..'; tAdjLZTeamData[M28Map.subrefbLZWantsDFSupport]='..tostring(tAdjLZTeamData[M28Map.subrefbLZWantsDFSupport] or false)..'; Is table of unbuilt mexes empty='..tostring(M28Utilities.IsTableEmpty(tAdjLZData[M28Map.subrefMexUnbuiltLocations]))..'; Core base='..tostring(tAdjLZTeamData[M28Map.subrefLZbCoreBase])..'; iNearestPotentialExpansionPoint='..(iNearestPotentialExpansionPoint or 'nil')..'; Total mass reclaim='..(tAdjLZData[M28Map.subrefTotalMassReclaim] or 'nil')..'; subrefTThreatEnemyCombatTotal='..(tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)..'; Mod dist%='..tAdjLZTeamData[M28Map.refiModDistancePercent]) end

                local iFactoryCount = 0
                local iEngiCount = 0
                if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                    local tFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tFactories) == false then
                        iFactoryCount = table.getn(tFactories)
                    end
                    local tEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tEngineers) == false then
                        iEngiCount = table.getn(tEngineers)
                    end
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
                        iEngiCount = 0.3 * table.getn(tAdjLZTeamData[M28Map.subrefTEngineersTravelingHere])
                    end
                end
                -- or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryEngineer, tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) and M28Utilities.GetDistanceBetweenPositions(tAdjLZData[M28Map.subrefMidpoint], tAdjLZTeamData[M28Map.reftClosestEnemyBase]) < iDistToClosestEnemyFromStart) then
                if (tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false) and tAdjLZTeamData[M28Map.subrefbLZWantsDFSupport] then
                    iCurValue = iCurValue + 250 + math.min(2000, (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 2)
                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy units so increasing  value to iCurValue='..iCurValue) end
                    --Have ACU be more aggressive if has good combat upgrades (e.g. one scenario is enemy only has PD in the zone so doesnt flag as wanting DF support)
                elseif (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 500 and (oACU[M28UnitInfo.refiDFMassThreatOverride] or 0) >= math.max(2000, 2 * (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)) then
                    iCurValue = iCurValue + math.min(1000, (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0))
                end
                if M28Utilities.IsTableEmpty(tAdjLZData[M28Map.subrefMexUnbuiltLocations]) == false and iFactoryCount == 0 and iEngiCount <= 3 then
                    iCurValue = iCurValue + math.max(0, 100 * (tAdjLZData[M28Map.subrefLZOrWZMexCount] - iEngiCount * 2))
                end
                if tAdjLZData[M28Map.subrefTotalSignificantMassReclaim] >= 500 then iCurValue = iCurValue + math.max(0, tAdjLZData[M28Map.subrefTotalSignificantMassReclaim] / 5 - 1000 * iFactoryCount - 250 * iEngiCount) end

                --General value % adjustments (e.g. for core base, travel dist, and dist towards enemy base)
                if iCurValue > 0 then
                    --Reduce value of core base if no enemies in it
                    if tAdjLZTeamData[M28Map.subrefLZbCoreBase] and not(tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) then iCurValue = iCurValue * 0.25 end

                    --Reduce value if further from enemy base than our start position
                    if M28Utilities.GetDistanceBetweenPositions(tAdjLZData[M28Map.subrefMidpoint], tAdjLZTeamData[M28Map.reftClosestEnemyBase]) > iDistToClosestEnemyFromStart then
                        iCurValue = iCurValue * 0.1
                        if bDebugMessages == true then LOG(sFunctionRef..': Further from enemy base than our start position so significanlty reducing value') end
                    end

                    --If on enemy side of map reduce value
                    if tAdjLZTeamData[M28Map.refiModDistancePercent] > 0.5 then
                        if not(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) and (oACU[M28UnitInfo.refiDFMassThreatOverride] or 0) >= 3000 and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.99 then
                            iCurValue = iCurValue * math.max(0.05, 0.85 * (1 - tAdjLZTeamData[M28Map.refiModDistancePercent]))
                            if bDebugMessages == true then LOG(sFunctionRef..': High mod dist but strong ACU threat so reducing iCurValue a bit') end
                        else
                            iCurValue = iCurValue * math.max(0.01, 0.8 * (1 - tAdjLZTeamData[M28Map.refiModDistancePercent]))
                            if bDebugMessages == true then LOG(sFunctionRef..': High mod dist so reducing iCurValue') end
                        end
                    end

                    --Adjust based on travel distance
                    iCurValue = iCurValue * (iShortestTravelDist / iCurTravelDist)
                    if iCurTravelDist - iShortestTravelDist >= 125 then
                        iCurValue = iCurValue * (iShortestTravelDist / iCurTravelDist)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iCurValue after mods='..iCurValue) end
                end

                return iCurValue
            end
            for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                if bDebugMessages == true then LOG(sFunctionRef..': Considering any LZs that have enemies, iAdjLZ='..iAdjLZ..'; tPathingDetails[M28Map.subrefLZTravelDist]='..tPathingDetails[M28Map.subrefLZTravelDist]..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]))..'; Is table of unbuilt locations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMexUnbuiltLocations]))..'; time last ran from iAdjZ='..(oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iAdjLZ] or 'nil')..'; oACU[refiLastPlateauAndZoneToAttackUnitIn]='..repru(oACU[refiLastPlateauAndZoneToAttackUnitIn])..'; oACU[refiTimeLastToldToAttackUnitInOtherZone]='..(oACU[refiTimeLastToldToAttackUnitInOtherZone] or 'nil')) end
                if tPathingDetails[M28Map.subrefLZTravelDist] < iLowerPriorityDistanceThreshold then
                    if bDebugMessages == true then LOG(sFunctionRef..': Time since ran from this zone='..GetGameTimeSeconds() - (oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iAdjLZ] or -10000)) end
                    if not(oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iAdjLZ]) or GetGameTimeSeconds() - oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iAdjLZ] > iSecondsToIgnoreZonesRecentlyRunFrom then
                        if bDebugMessages == true then LOG(sFunctionRef..': Time since last told to attack unit in this one='..(GetGameTimeSeconds() - (oACU[refiTimeLastToldToAttackUnitInOtherZone] or -10000))) end
                        if not(oACU[refiLastPlateauAndZoneToAttackUnitIn][2] == iAdjLZ) or not(oACU[refiLastPlateauAndZoneToAttackUnitIn][1] == iPlateau) or GetGameTimeSeconds() - (oACU[refiTimeLastToldToAttackUnitInOtherZone] or -100) > 30 then
                            iCurZoneValue = GetAdjZoneValueForACU(iAdjLZ, tPathingDetails[M28Map.subrefLZTravelDist], (iClosestWorthwhileTravelDist or tPathingDetails[M28Map.subrefLZTravelDist]))
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurZoneValue='..iCurZoneValue..'; iBestZoneValue so far='..iBestZoneValue) end
                            if iCurZoneValue > iBestZoneValue then
                                local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                                local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                                if tAdjLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then bBestZoneHasNearbyEnemies = true end

                                iLZToMoveTo = iAdjLZ
                                iBestZoneValue = iCurZoneValue
                                if iCurZoneValue >= 100 then --equiv to 1 unbuilt t1 mex or a zone with enemies
                                    iBestZoneDist = tPathingDetails[M28Map.subrefLZTravelDist]
                                    if iBestZoneDist < iClosestWorthwhileTravelDist then iClosestWorthwhileTravelDist = iBestZoneDist end
                                end
                            end
                        end
                    end
                else
                    --Nearest place of interest is so far away we might as well keep ACU at base
                    break
                end
            end

            --High value islands (we consider islands more generally below) - Consider moving if have high value island that isnt that far with a lot of mexes - do it based on drop locations
            if not(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropIslandsByPlateau]) then M28Air.UpdateTransportPlateauDropLocationShortlist(iTeam, false) end
            local iBackupLZToMoveTo = iLZToMoveTo
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have high value islands to consider, iBackupLZToMoveTo='..(iBackupLZToMoveTo or 'nil')..'; Is table of drop islands by plateau empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropIslandsByPlateau][iPlateau]))..'; Is table of pathing to other islands empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]))..'; bBestZoneHasNearbyEnemies='..tostring(bBestZoneHasNearbyEnemies)..'; iBestZoneValue='..iBestZoneValue..'; Can path to enemy with land='..tostring(oACU:GetAIBrain()[M28Map.refbCanPathToEnemyBaseWithLand] or false)) end
            if not(iWaterZoneToConsiderBuildingNavalFactoryInFirst) and (not(iLZToMoveTo) or (not(bBestZoneHasNearbyEnemies) and (iBestZoneValue <= 300 or not(oACU:GetAIBrain()[M28Map.refbCanPathToEnemyBaseWithLand])))) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropIslandsByPlateau][iPlateau]) == false and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
                local iClosestLZRef, iCurTravelDist
                local iClosestLZTravelDist = 1000

                local iTravelDistThreshold = iLowerPriorityDistanceThreshold
                local bIslandHasUnclaimedMexesOrEnemies
                for iEntry, iIsland in M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropIslandsByPlateau][iPlateau] do
                    --Is this a high value island?
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering island '..iIsland..'; Mex count='..(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][iIsland] or 'nil')) end
                    if (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][iIsland] or 0) >= 9 then
                        --How long will it take to travel here, and do we need support on the island?
                        for _, tSubtable in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                            if tSubtable[M28Map.subrefIslandNumber] == iIsland then
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering iIsland='..iIsland..'; Mex count='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][iIsland]..'; Travel dist='..tSubtable[M28Map.subrefIslandTravelDist]) end
                                if tSubtable[M28Map.subrefIslandTravelDist] <= math.min(iTravelDistThreshold, iClosestLZTravelDist) then
                                    tbIslandsAlreadyConsidered[iIsland] = true
                                    --Is this suitable (mod dist <0.5)?
                                    local tIslandLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefIslandClosestLZRef]]
                                    local tIslandLZTeamData = tIslandLZData[M28Map.subrefLZTeamData][iTeam]
                                    if bDebugMessages == true then LOG(sFunctionRef..': Mod dist='..(tIslandLZTeamData[M28Map.refiModDistancePercent] or 'nil')) end
                                    if tIslandLZTeamData[M28Map.refiModDistancePercent] <= 0.5 then
                                        --Check if this island is suitable - cycle through every zone and check if there is a zone with enemy combat threat and/or unclaimed mexes
                                        bIslandHasUnclaimedMexesOrEnemies = false
                                        if M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefMexUnbuiltLocations]) == false or M28Utilities.IsTableEmpty(tIslandLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                                            bIslandHasUnclaimedMexesOrEnemies = true
                                            iCurTravelDist = tSubtable[M28Map.subrefIslandTravelDist]
                                        else
                                            if M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                                                for iPathingRef, tPathingDetails in tIslandLZData[M28Map.subrefLZPathingToOtherLandZones] do
                                                    iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering any LZs on target island that have unclaimed mexes or enemies, Is table of unbuilt locations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMexUnbuiltLocations]))..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]))) end
                                                    if tPathingDetails[M28Map.subrefLZTravelDist] < (iTravelDistThreshold + 150) then
                                                        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false or M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMexUnbuiltLocations]) == false then
                                                            iCurTravelDist = tPathingDetails[M28Map.subrefLZTravelDist]
                                                            bIslandHasUnclaimedMexesOrEnemies = true
                                                            break
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                        if bIslandHasUnclaimedMexesOrEnemies and iCurTravelDist < iClosestLZTravelDist then
                                            iClosestLZRef = tSubtable[M28Map.subrefIslandClosestLZRef]
                                            iClosestLZTravelDist = tSubtable[M28Map.subrefIslandTravelDist]
                                            if bDebugMessages == true then LOG(sFunctionRef..': This island '..iIsland..' has unclaimed mexes or enemies and suitable travel distance') end
                                        end
                                    end
                                end
                                break
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished going through all potential island drop locations for high value ACU islands, iClosestLZRef='..(iClosestLZRef or 'nil')) end
                if iClosestLZRef then iLZToMoveTo = iClosestLZRef end
            end
            if iBackupLZToMoveTo and not(iLZToMoveTo) then iLZToMoveTo = iBackupLZToMoveTo end



            --[[if not(iLZToMoveTo) and iNearestPotentialExpansionPoint then
                iLZToMoveTo = iNearestPotentialExpansionPoint
                iPlannedTargetDist = iPlannedDistOfPotentialExpansion
                if bDebugMessages == true then LOG(sFunctionRef..': Setting LZ to move to as the pbackup iNearestPotentialExpansionPoint='..iNearestPotentialExpansionPoint..'; iPlannedDistOfPotentialExpansion='..iPlannedDistOfPotentialExpansion) end
            end--]]
            if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for zones with enemies, iLZToMoveTo='..(iLZToMoveTo or 'nil')..'; iRecentLandZoneRef='..(iRecentLandZoneRef or 'nil')) end
            if iLZToMoveTo and iRecentLandZoneRef and not(iRecentLandZoneRef == iLZToMoveTo) then
                --dont change our target if our current target is suitable still - this is to avoid cases where the land zone we move to has another land zone slightly closer to its midpoint but in the opposite direction, leading to the ACU stuck in an infinite loop going back and forth between two conflicting land zones whenever its current LZ changes
                local tPrevLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iRecentLandZoneRef]
                local tPrevLZTeamData = tPrevLZData[M28Map.subrefLZTeamData][iTeam]

                if bDebugMessages == true then LOG(sFunctionRef..': iLZToMoveTo before adj='..iLZToMoveTo..'; iRecentLandZoneRef='..iRecentLandZoneRef..'; iClosestWorthwhileTravelDist='..(iClosestWorthwhileTravelDist or 'nil')..'; iLastPathedZoneTravelDist='..(iLastPathedZoneTravelDist or 'nil')..'; tPrevLZTeamData[M28Map.subrefTEnemyUnits]='..tostring(M28Utilities.IsTableEmpty(tPrevLZTeamData[M28Map.subrefTEnemyUnits]))..'; Mass reclaim='..(tPrevLZData[M28Map.subrefTotalMassReclaim] or 0)..'; Is table of unbuilt mexes empty='..tostring(M28Utilities.IsTableEmpty(tPrevLZData[M28Map.subrefMexUnbuiltLocations]))..'; iBestZoneValue='..iBestZoneValue)
                    if iLastPathedZoneTravelDist then LOG(sFunctionRef..': Prev zone value='..GetAdjZoneValueForACU(iAdjLZ, iLastPathedZoneTravelDist, (iClosestWorthwhileTravelDist or iLastPathedZoneTravelDist))) end
                end                
                if iLastPathedZoneTravelDist and (not(iClosestWorthwhileTravelDist) or iClosestWorthwhileTravelDist + 50 >= iLastPathedZoneTravelDist) then
                    if GetAdjZoneValueForACU(iAdjLZ, iLastPathedZoneTravelDist, (iClosestWorthwhileTravelDist or iLastPathedZoneTravelDist)) * 2 >= iBestZoneValue then
                        iLZToMoveTo = iRecentLandZoneRef
                        if bDebugMessages == true then LOG(sFunctionRef..': Will retain previous expansion target as it still seems okish') end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering whether to move to a land zone on the same island, iLZToMoveTo='..(iLZToMoveTo or 'nil')..'; Does enemy have sub? count='..(M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refiEnemySubCount] or 0)..'; iWaterZoneToConsiderBuildingNavalFactoryInFirst='..(iWaterZoneToConsiderBuildingNavalFactoryInFirst or 'nil')) end

    if not(iLZToMoveTo) and not(iWaterZoneToConsiderBuildingNavalFactoryInFirst) and not(oACU:GetAIBrain()[M28Map.refbCanPathToEnemyBaseWithLand]) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false
            and (M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refiEnemySubCount] or 0) <= 1 then
        local bIslandHasUnclaimedMexesOrEnemies
        local iSearchRange = 300
        if GetGameTimeSeconds() <= 600 and math.max(M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech], M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech], M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech]) <= 1 then
            iSearchRange = 400
        end

        for iEntry, tSubtable in tLZData[M28Map.subrefLZPathingToOtherIslands] do
            if not(tbIslandsAlreadyConsidered[tSubtable[M28Map.subrefIslandNumber]]) and tSubtable[M28Map.subrefIslandTravelDist] <= iSearchRange then
                if oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][tSubtable[M28Map.subrefIslandClosestLZRef]] and GetGameTimeSeconds() - oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][tSubtable[M28Map.subrefIslandClosestLZRef]] > iSecondsToIgnoreZonesRecentlyRunFrom then
                    --Are there any unclaimed mexes on the LZ?
                    bIslandHasUnclaimedMexesOrEnemies = false
                    local tIslandLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefIslandClosestLZRef]]
                    if M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefMexUnbuiltLocations]) == false or M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                        bIslandHasUnclaimedMexesOrEnemies = true
                    else
                        if M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                            for iPathingRef, tPathingDetails in tIslandLZData[M28Map.subrefLZPathingToOtherLandZones] do
                                iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering any LZs on target island that have unclaimed mexes or enemies, Is table of unbuilt locations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMexUnbuiltLocations]))..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]))) end
                                if tPathingDetails[M28Map.subrefLZTravelDist] < (iSearchRange + 150) then
                                    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false or M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMexUnbuiltLocations]) == false then
                                        bIslandHasUnclaimedMexesOrEnemies = true
                                        break
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering for land zone '..tSubtable[M28Map.subrefIslandClosestLZRef]..'; bIslandHasUnclaimedMexesOrEnemies='..tostring(bIslandHasUnclaimedMexesOrEnemies)) end
                    if bIslandHasUnclaimedMexesOrEnemies then
                        iLZToMoveTo = tSubtable[M28Map.subrefIslandClosestLZRef]
                    end
                end
            end
        end
    end
    if iLZToMoveTo then
        if M28Overseer.bNoRushActive and not(M28Conditions.IsLocationInNoRushArea(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZToMoveTo][M28Map.subrefMidpoint])) then
            iLZToMoveTo = nil
        else
            M28Orders.IssueTrackedMove(oACU, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZToMoveTo][M28Map.subrefMidpoint], 6, false, 'ACMLZ'..iLZToMoveTo, false)
            oACU[refiTimeLastToldToMoveToZone] = GetGameTimeSeconds()
            oACU[refiLastPlateauAndZoneToMoveTo] = {iPlateau, iLZToMoveTo}
            if bDebugMessages == true then LOG(sFunctionRef..': Telling ACU to move to zone '..iLZToMoveTo..' at time='..GetGameTimeSeconds()) end
        end
    elseif iWaterZoneToConsiderBuildingNavalFactoryInFirst then
        if M28Overseer.bNoRushActive then
            iWaterZoneToConsiderBuildingNavalFactoryInFirst = nil
        else
            local tTargetWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZoneToConsiderBuildingNavalFactoryInFirst]][M28Map.subrefPondWaterZones][iWaterZoneToConsiderBuildingNavalFactoryInFirst]
            M28Orders.IssueTrackedMove(oACU, tTargetWZData[M28Map.subrefMidpoint], 6, false, 'ACMWZ'..iWaterZoneToConsiderBuildingNavalFactoryInFirst, false)
            oACU[refiTimeLastToldToMoveToZone] = GetGameTimeSeconds()
            oACU[refiLastPlateauAndZoneToMoveTo] = {0, iWaterZoneToConsiderBuildingNavalFactoryInFirst}
            if bDebugMessages == true then LOG(sFunctionRef..': Telling ACU to move to WZ='..iWaterZoneToConsiderBuildingNavalFactoryInFirst..' at time='..GetGameTimeSeconds()) end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if iLZToMoveTo or iWaterZoneToConsiderBuildingNavalFactoryInFirst then return true else return false end
end

function UpdateACULandOrWaterZoneAssignment(oACU, iPlateauOrZero, iLandOrWaterZone, tLZOrWZTeamData)
    local sFunctionRef = 'UpdateACULandOrWaterZoneAssignment'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Update ACU tracking
    --Is the actual LZ and plateau the same? If not, then need to update tracking
    if oACU[reftiCurAssignedPlateauAndZone][1] == iPlateauOrZero and oACU[reftiCurAssignedPlateauAndZone][iLandOrWaterZone] == iLandOrWaterZone then
        --Do nothing
    else
        local iTeam = oACU:GetAIBrain().M28Team
        if iLandOrWaterZone > 0 then --No point updating if we dont have a valid land zone
            oACU[reftiLastAssignedPlateauAndZone] = {oACU[reftiCurAssignedPlateauAndZone][1], oACU[reftiCurAssignedPlateauAndZone][2]}
            oACU[reftiCurAssignedPlateauAndZone] = {iPlateauOrZero, iLandOrWaterZone}
            if (oACU[reftiLastAssignedPlateauAndZone][2] or 0) > 0 then
                local tPrevLZOrWZTeamData
                if oACU[reftiLastAssignedPlateauAndZone][1] > 0 then
                    tPrevLZOrWZTeamData = M28Map.tAllPlateaus[oACU[reftiLastAssignedPlateauAndZone][1]][M28Map.subrefPlateauLandZones][oACU[reftiLastAssignedPlateauAndZone][2]][M28Map.subrefLZTeamData][iTeam]
                else
                    tPrevLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[oACU[reftiLastAssignedPlateauAndZone][2]]][M28Map.subrefPondWaterZones][oACU[reftiLastAssignedPlateauAndZone][2]][M28Map.subrefWZTeamData][iTeam]
                end

                --Check we are in the table
                if M28Utilities.IsTableEmpty(tPrevLZOrWZTeamData[M28Map.subrefAlliedACU]) == false then
                    for iRecordedACU, oRecordedACU in tPrevLZOrWZTeamData[M28Map.subrefAlliedACU] do
                        if oRecordedACU == oACU then
                            table.remove(tPrevLZOrWZTeamData[M28Map.subrefAlliedACU], iRecordedACU)
                            break
                        end
                    end
                end
            end
            local bAlreadyRecorded = false --Redundancy - we shouldnt have scenario where we are already recorded
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefAlliedACU]) == false then
                for iRecordedACU, oRecordedACU in tLZOrWZTeamData[M28Map.subrefAlliedACU] do
                    if oRecordedACU == oACU then
                        bAlreadyRecorded = true
                        break
                    end
                end
            end
            if not(bAlreadyRecorded) then
                if not(tLZOrWZTeamData[M28Map.subrefAlliedACU]) then tLZOrWZTeamData[M28Map.subrefAlliedACU] = {} end
                table.insert(tLZOrWZTeamData[M28Map.subrefAlliedACU], oACU)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderGettingExtraLandFactory(tLZData, tLZTeamData, oACU, iPlateau, iLandZone)
    local sFunctionRef = 'ConsiderGettingExtraLandFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; ACU upgrade count='..(oACU[refiUpgradeCount] or 0)..'; Is ACU in core base='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])..'; Plateau-LZ='..iPlateau..'-'..(iLandZone or 'nil')..'; Brain mass stored='..oACU:GetAIBrain():GetEconomyStored('MASS')..'; Want more factories for this LZ='..tostring(M28Conditions.WantMoreFactories(oACU:GetAIBrain().M28Team, iPlateau, iLandZone))) end

    if (oACU[refiUpgradeCount] or 0) == 0 and tLZTeamData[M28Map.subrefLZbCoreBase] and oACU:GetAIBrain():GetEconomyStored('MASS') >= 220 and M28Conditions.WantMoreFactories(oACU:GetAIBrain().M28Team, iPlateau, iLandZone) then
        --We think we want another land factory; however dont do this if we will use up our current mass in 20s or less, or we have 4+ land factories, or we are at T2
        local iTeam = oACU:GetAIBrain().M28Team
        if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData, oACU:GetAIBrain()) then
            --DO nothing for now
        else
            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] <= 1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= -0.5 then
                local tExistingFactoriesInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                local iExistingFactories = 0
                if tExistingFactoriesInLZ then iExistingFactories = table.getn(tExistingFactoriesInLZ) end
                if bDebugMessages == true then LOG(sFunctionRef..': iExistingFactories='..iExistingFactories..'; If < 4 then will try and build another') end
                if iExistingFactories < 4 then
                    ACUActionBuildFactory(oACU:GetAIBrain(), oACU, iPlateau, iLandZone, tLZData, tLZTeamData)
                    --Check if we have an order as a result of this to build something
                    local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
                    if bDebugMessages == true then LOG(sFunctionRef..': Just told ACU to try and build a factory, last order='..reprs(tLastOrder)) end
                    if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueRepair or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueGuard then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return true
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function ConsiderAttackingNearbyNavalUnits(tLZData, tLZTeamData, oACU, iRangeThresholdOverride)
    --If can find an enemy that it wants the ACU to attack/move towards, will give the ACU orders and return true
    --Normally called for LZ, but if ACU has toredp attack then the LZData and teamdata may be a waterzone
    local sFunctionRef = 'ConsiderAttackingNearbyNavalUnits'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Torpedo upgrade ACU - consider moving into water/towards nearby enemy
    local bAttackingWithTorpedo = false
    if oACU[M28UnitInfo.refiAntiNavyRange] and oACU[M28UnitInfo.refiAntiNavyRange] > 10 then
        local oNearestNavalEnemy
        local aiBrain = oACU:GetAIBrain()
        local iTeam = aiBrain.M28Team
        local iClosestNavalEnemyDist = 10000
        local iCurDist
        function ConsiderUnitForTorpedoAttack(oUnit)
            if not(oUnit.Dead) and not(EntityCategoryContains(categories.HOVER, oUnit.UnitId)) then
                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())
                if iCurDist < iClosestNavalEnemyDist then
                    iClosestNavalEnemyDist = iCurDist
                    oNearestNavalEnemy = oUnit
                end
            end
        end
        --If are on land then check adjacent zones
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
            for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                local iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                local iPond = M28Map.tiPondByWaterZone[iAdjWZ]
                local tWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false and not(tWZTeamData[M28Map.subrefbWZOnlyHoverEnemies]) then
                    for iUnit, oUnit in tWZTeamData[M28Map.subrefTEnemyUnits] do
                        ConsiderUnitForTorpedoAttack(oUnit)
                    end
                end
                if not(oNearestNavalEnemy) then
                    --redundancy - use getunitsaroundpoint as sometimes can have nearby WZ that unit isnt showing in
                    local aiBrain = oACU:GetAIBrain()
                    local tNearbyNavalUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryAllAmphibiousAndNavy - categories.HOVER - M28UnitInfo.refCategoryAmphibious, oACU:GetPosition(), oACU[M28UnitInfo.refiAntiNavyRange] + (iRangeThresholdOverride or 30), 'Enemy')
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby enemy hover and surface navy empty='..tostring(M28Utilities.IsTableEmpty(tNearbyNavalUnits))) end
                    if M28Utilities.IsTableEmpty(tNearbyNavalUnits) == false then
                        for iUnit, oUnit in tNearbyNavalUnits do
                            ConsiderUnitForTorpedoAttack(oUnit)
                        end
                    end
                end
            end
            --If we are a water zone then check this zone and adjacent zone
        elseif tLZData[M28Map.subrefWZAdjacentWaterZones] or tLZTeamData[M28Map.subrefWZThreatEnemyVsSurface] or tLZTeamData[M28Map.subrefWZThreatEnemySubmersible] then
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false and not(tLZTeamData[M28Map.subrefbWZOnlyHoverEnemies]) then
                for iUnit, oUnit in tLZTeamData[M28Map.subrefTEnemyUnits] do
                    ConsiderUnitForTorpedoAttack(oUnit)
                end
            end
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                for _, iAdjWZ in tLZData[M28Map.subrefWZAdjacentWaterZones] do
                    local tAdjWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                    if M28Utilities.IsTableEmpty(tAdjWZTeamData[M28Map.subrefTEnemyUnits]) == false and not(tAdjWZTeamData[M28Map.subrefbWZOnlyHoverEnemies]) then
                        for iUnit, oUnit in tAdjWZTeamData[M28Map.subrefTEnemyUnits] do
                            ConsiderUnitForTorpedoAttack(oUnit)
                        end
                    end
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': oNearestNavalEnemy='..(oNearestNavalEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestNavalEnemy) or 'nil')..'; iClosestNavalEnemyDist='..iClosestNavalEnemyDist..'; refiAntiNavyRange='..oACU[M28UnitInfo.refiAntiNavyRange]..'; iRangeThresholdOverride='..(iRangeThresholdOverride or 'nil')) end
        if oNearestNavalEnemy then
            local iDistThreshold
            if not(iRangeThresholdOverride) then
                --Do we have stealth upgrade and are near full health? if so increase range threshold
                if oACU[refiUpgradeCount] >= 2 and (oACU:HasEnhancement('StealthGenerator') or oACU:HasEnhancement('FAF_SelfRepairSystem') or oACU:HasEnhancement('CloakingGenerator')) and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.95 and GetGameTimeSeconds() <= 1200 and (not(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) or (M28Team.tTeamData[iTeam][M28Team.refbNoAvailableTorpsForEnemies] and (M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] or 0) == 0)) then
                    iDistThreshold = 110
                elseif GetGameTimeSeconds() <= 900 and M28Team.tTeamData[iTeam][M28Team.refbNoAvailableTorpsForEnemies] and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.9 then
                    iDistThreshold = 70
                else
                    iDistThreshold = 50
                end
            else
                iDistThreshold = iRangeThresholdOverride
            end
            iDistThreshold = oACU[M28UnitInfo.refiAntiNavyRange] + iDistThreshold
            if bDebugMessages == true then LOG(sFunctionRef..': iDistThreshold='..iDistThreshold) end
            if iClosestNavalEnemyDist <= iDistThreshold then
                bAttackingWithTorpedo = true
                --If we are already in range and can see the unit, and we outrange its antinavy attack consider kiting
                local bGivenKitingOrder = false
                if iClosestNavalEnemyDist <= oACU[M28UnitInfo.refiAntiNavyRange] and M28UnitInfo.CanSeeUnit(aiBrain, oNearestNavalEnemy, false) then
                    --If it is a building then just do an attack order
                    local bWantToDoKitingRetreat = false
                    if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oNearestNavalEnemy.UnitId) then
                        bGivenKitingOrder = true
                        M28Orders.IssueTrackedAttack(oACU, oNearestNavalEnemy, false, 'TrpAtB', false)
                        --Dealing with mobile target within our range - do we want to retreat or do manual attack, or advance?
                    elseif iClosestNavalEnemyDist + 10 <= oACU[M28UnitInfo.refiAntiNavyRange] then
                        bWantToDoKitingRetreat = true
                    else
                        --If enemy moving away from us then advance; if it is moving towards us then retreat; if it is barely moving then attack
                        local iCurSpeedX, iCurSpeedY, iCurSpeedZ = oNearestNavalEnemy:GetVelocity()
                        local tCurPosition = oNearestNavalEnemy:GetPosition()
                        if math.abs(iCurSpeedX) + math.abs(iCurSpeedZ) <= 0.2 then
                            bGivenKitingOrder = true
                            M28Orders.IssueTrackedAttack(oACU, oNearestNavalEnemy, false, 'TrpAtS', false)
                        else
                            local iDistanceShortly = M28Utilities.GetDistanceBetweenPositions({tCurPosition[1] + iCurSpeedX, tCurPosition[2] + iCurSpeedY, tCurPosition[3] + iCurSpeedZ}, oACU:GetPosition())
                            if iDistanceShortly > iClosestNavalEnemyDist + 0.2 then
                                bGivenKitingOrder = true
                                M28Orders.IssueTrackedMove(oACU, oNearestNavalEnemy:GetPosition(), 1.5, false, 'TrpMV', false) --dont want attackmove as it references maingun not torp launcher
                            elseif iDistanceShortly < iClosestNavalEnemyDist - 0.2 then
                                bWantToDoKitingRetreat = true
                            end
                        end
                    end
                    if bWantToDoKitingRetreat then
                        --Check we can retreat while still staying underwater so we dont take surface fire and can keep using torpedo attack
                        local iRetreatAngle = M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                        local tPotentialRetreatPosition = M28Utilities.MoveInDirection(oACU:GetPosition(), iRetreatAngle, 10, true, true, M28Map.bIsCampaignMap)
                        local iUnderwaterAmountWanted = (oACU:GetBlueprint().SizeY or 0) + 0.1
                        if M28Utilities.IsTableEmpty(tPotentialRetreatPosition) == false and GetSurfaceHeight(tPotentialRetreatPosition[1], tPotentialRetreatPosition[3]) - GetTerrainHeight(tPotentialRetreatPosition[1], tPotentialRetreatPosition[3]) >= iUnderwaterAmountWanted then
                            bGivenKitingOrder = true
                            M28Orders.IssueTrackedMove(oACU,tPotentialRetreatPosition, 1.5, false, 'TrpKiM', false) --dont want attackmove as it references maingun not torp launcher
                        elseif GetSurfaceHeight(tPotentialRetreatPosition[1], tPotentialRetreatPosition[3]) - GetTerrainHeight(tPotentialRetreatPosition[1], tPotentialRetreatPosition[3]) >= iUnderwaterAmountWanted then
                            --Attack so we dont move closer, provided we are fully underwater
                            bGivenKitingOrder = true
                            M28Orders.IssueTrackedAttack(oACU, oNearestNavalEnemy, false, 'TrpAtU', false)
                        end
                    end
                end
                if not(bGivenKitingOrder) then
                    --Move to target
                    M28Orders.IssueTrackedMove(oACU, oNearestNavalEnemy:GetPosition(), 1.5, false, 'TrpMV', false) --dont want attackmove as it references maingun not torp launcher
                end
            end
        end
    end
    if not(bAttackingWithTorpedo) and (oACU[M28UnitInfo.refiDFRange] or 0) > 0 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
        local iClosestEnemyToAttack = 100000
        local oClosestEnemyToAttack
        local tViaPointForClosestEnemy
        local iTeam = oACU:GetAIBrain().M28Team
        local iDistToACUThreshold = (iRangeThresholdOverride or 50)
        if tLZTeamData[M28Map.subrefLZbCoreBase] and not(iRangeThresholdOverride) then iDistToACUThreshold = iDistToACUThreshold + 25 end
        local iDistToLandThreshold = oACU[M28UnitInfo.refiDFRange] - 5
        local iCurDistToACU
        local bCanHitFromLand, iAngleFromACUToUnit, iTempSegmentX, iTempSegmentZ
        local tPotentialViaPoint
        local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)

        if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..', iRangeThresholdOverride='..(iRangeThresholdOverride or 'nil')..'; iDistToLandThreshold='..iDistToLandThreshold..'; iDistToACUThreshold='..iDistToACUThreshold) end
        function ConsiderPotentialUnitTarget(oUnit)
            if M28UnitInfo.IsUnitValid(oUnit) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) and (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(oUnit:GetPosition())) then
                iCurDistToACU = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition())
                if bDebugMessages == true then LOG(sFunctionRef..': iCurDistToACU='..iCurDistToACU..'; iDistToACUThreshold='..iDistToACUThreshold..'; iClosestEnemyToAttack='..iClosestEnemyToAttack) end
                if iCurDistToACU <= iDistToACUThreshold and iCurDistToACU < iClosestEnemyToAttack then
                    --If we move from the ACU until we are within ACU range of the unit, are we on land rather than water?
                    bCanHitFromLand = false
                    if iCurDistToACU <= iDistToLandThreshold then
                        bCanHitFromLand = true
                        tPotentialViaPoint = oUnit:GetPosition()
                    else
                        iAngleFromACUToUnit = M28Utilities.GetAngleFromAToB(oACU:GetPosition(), oUnit:GetPosition())
                        tPotentialViaPoint = M28Utilities.MoveInDirection(oACU:GetPosition(), iAngleFromACUToUnit, iCurDistToACU - iDistToLandThreshold, true, true, true)
                        iTempSegmentX, iTempSegmentZ = M28Map.GetPathingSegmentFromPosition(tPotentialViaPoint)
                        if M28Map.tLandZoneBySegment[iTempSegmentX][iTempSegmentZ] then
                            bCanHitFromLand = true
                        elseif iCurDistToACU <= oACU[M28UnitInfo.refiDFRange] then
                            bCanHitFromLand = true
                            tPotentialViaPoint = oUnit:GetPosition()
                        end
                    end
                    if bCanHitFromLand then
                        iClosestEnemyToAttack = iCurDistToACU
                        oClosestEnemyToAttack = oUnit
                        tViaPointForClosestEnemy = {tPotentialViaPoint[1], tPotentialViaPoint[2], tPotentialViaPoint[3]}
                    end
                end
            end
        end
        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
            local iAdjWZ = tSubtable[M28Map.subrefAWZRef]
            local iPond = M28Map.tiPondByWaterZone[iAdjWZ]
            local tWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjWZ='..iAdjWZ..'; Enemy surface threat='.. tWZTeamData[M28Map.subrefWZThreatEnemyVsSurface]..'; tWZTeamData[M28Map.subrefiThreatEnemyGroundAA]='..tWZTeamData[M28Map.subrefiThreatEnemyGroundAA]) end
            if (tWZTeamData[M28Map.subrefWZThreatEnemyVsSurface] + tWZTeamData[M28Map.subrefiThreatEnemyGroundAA]) > 0 and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                for iUnit, oUnit in tWZTeamData[M28Map.subrefTEnemyUnits] do
                    if bDebugMessages == true then if M28UnitInfo.IsUnitValid(oUnit) then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is unit undetwater='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(oUnit:GetPosition()))) end end
                    ConsiderPotentialUnitTarget(oUnit)
                end
                if not(oClosestEnemyToAttack) then
                    --redundancy - use getunitsaroundpoint as sometimes can have nearby WZ that unit isnt showing in
                    local aiBrain = oACU:GetAIBrain()
                    local tNearbyNavalUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryAllAmphibiousAndNavy - M28UnitInfo.refCategoryAmphibious, oACU:GetPosition(), iDistToACUThreshold, 'Enemy')
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby enemy hover and surface navy empty='..tostring(M28Utilities.IsTableEmpty(tNearbyNavalUnits))) end
                    if M28Utilities.IsTableEmpty(tNearbyNavalUnits) == false then
                        for iUnit, oUnit in tNearbyNavalUnits do
                            ConsiderPotentialUnitTarget(oUnit)
                        end
                    end
                end
            end
        end

        if oClosestEnemyToAttack then
            --move towards the enemy unit if we are out of range or only just in range, otherwise attack (or ground attack) the enemy
            if bDebugMessages == true then LOG(sFunctionRef..': oClosestEnemyToAttack='..oClosestEnemyToAttack.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyToAttack)..'; iClosestEnemyToAttack='..iClosestEnemyToAttack..'; ACU range='..oACU[M28UnitInfo.refiDFRange]..'; Can see unit='..tostring(M28UnitInfo.CanSeeUnit(oACU:GetAIBrain(), oClosestEnemyToAttack))..'; Time since last weapon event='..GetGameTimeSeconds() - (oACU[M28UnitInfo.refiLastWeaponEvent] or -10)) end
            if iClosestEnemyToAttack <= iDistToLandThreshold then

                if M28UnitInfo.CanSeeUnit(oACU:GetAIBrain(), oClosestEnemyToAttack) and GetGameTimeSeconds() - (oACU[M28UnitInfo.refiLastWeaponEvent] or -10) <= 3 then
                    M28Orders.IssueTrackedAttack(oACU, oClosestEnemyToAttack, false, 'NUAt', false)
                else
                    M28Orders.IssueTrackedAggressiveMove(oACU, oClosestEnemyToAttack:GetPosition(), 1, false, 'NUAM', false)
                    --M28Orders.IssueTrackedGroundAttack(oACU, oClosestEnemyToAttack:GetPosition(), 1, false, 'NuGA', false) --tried ground attack but on frigates it just means shotting the water
                end
            else
                if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tViaPointForClosestEnemy) >= 2 or GetGameTimeSeconds() - (oACU[M28UnitInfo.refiLastWeaponEvent] or -10) <= 2 then
                    M28Orders.IssueTrackedMove(oACU, tViaPointForClosestEnemy, 1.5, false, 'NuMV', false) --Tried doing attack move but often ACU would just stand there with attackmove slightly infront of it, and do nothing while it takes fire, e.g. if enemy isnt visible
                else
                    M28Orders.IssueTrackedMove(oACU, oClosestEnemyToAttack:GetPosition(), 1.5, false, 'NuMU', false) --Tried doing attack move but often ACU would just stand there with attackmove slightly infront of it, and do nothing while it takes fire, e.g. if enemy isnt visible
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end
    elseif bAttackingWithTorpedo then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderRunningToNearestShield(oACU, tLZOrWZData, tLZOrWZTeamData, iTeam, iPlateauOrZero, iLandOrWaterZone)
    --If it's dangerous for ACUs and the current zone isnt a core zone with a shield, but there is a nearby core zone with a shield, then send the ACU there and returns true
    --Also includes logic for ACU to assist the shield and/or flag it for other engineers to assist
    local sFunctionRef = 'ConsiderRunningToNearestShield'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --No point looking for other core bases if we were the only M28 on the team originally, or if not dangerous for ACU
    if bDebugMessages == true then LOG(sFunctionRef..': M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs]='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs] or false)..'; Orig brain count='..M28Team.tTeamData[iTeam][M28Team.subrefiOrigM28BrainCount]..'; tLZOrWZTeamData[M28Map.refiModDistancePercent]='..tLZOrWZTeamData[M28Map.refiModDistancePercent]) end
    if M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs] and (M28Team.tTeamData[iTeam][M28Team.subrefiOrigM28BrainCount] > 1 or tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.3) then
        --If we have shields in this zone dont leave it
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if it is safe for ACU owend by brain '..oACU:GetAIBrain().Nickname..' to be in zone '..iLandOrWaterZone..'; tLZOrWZTeamData[M28Map.subrefiT3FixedShieldConstructedCount]='..(tLZOrWZTeamData[M28Map.subrefiT3FixedShieldConstructedCount] or 'nil')..'; Is core base='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or false)..'; Time='..GetGameTimeSeconds()) end
        if (tLZOrWZTeamData[M28Map.subrefiT3FixedShieldConstructedCount] or 0) > 0 and (tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or (M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] > 0 and M28UnitInfo.GetUnitHealthPercent(oACU) < 1)) then
            if bDebugMessages == true then LOG(sFunctionRef..': Want to go to the nearest constructed shield in this zone') end
            --If we arent already under shield coverage and ACU is sub-100% health move to be under it
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false and (M28UnitInfo.GetUnitHealthPercent(oACU) < 1 or (M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] > 0 and tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and oACU:GetMaxHealth() < 20000 and (not(oACU.MyShield.GetHealth) or oACU.MyShield:GetHealth() <= 5000) and (not(oACU[M28UnitInfo.refCategoryMobileLandShield]) or M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] > 1) and M28Utilities.IsTableEmpty(oACU:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryNovax, oACU:GetPosition(), 70, 'Enemy')) == false)) then
                local tFriendlyFixedShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if M28Utilities.IsTableEmpty(tFriendlyFixedShields) == false then
                    local oNearestShieldWithHealth
                    local iNearestShieldWithHealthDist = 1000
                    local iCurDist
                    for iShield, oShield in tFriendlyFixedShields do
                        if M28UnitInfo.IsUnitValid(oShield) and oShield.MyShield.GetHealth and oShield.MyShield:GetHealth() >= 100 then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oACU:GetPosition())
                            if iCurDist < iNearestShieldWithHealthDist then
                                iNearestShieldWithHealthDist = iCurDist
                                oNearestShieldWithHealth = oShield
                            end
                        end
                    end
                    if oNearestShieldWithHealth then
                        oACU[refoShieldRallyTarget] = oNearestShieldWithHealth
                        --Are we not comfortably within the shield coverage?
                        if iNearestShieldWithHealthDist > (oNearestShieldWithHealth:GetBlueprint().Defense.Shield.ShieldSize or 0) * 0.45 - 4 then
                            M28Orders.IssueTrackedMove(oACU, oNearestShieldWithHealth:GetPosition(), 1, false, 'RetrCSh', false)
                            if bDebugMessages == true then LOG(sFunctionRef..': Will retreat ACU to the nearest shield '..oNearestShieldWithHealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestShieldWithHealth)..'; Special micro active='..tostring(oACU[M28UnitInfo.refbSpecialMicroActive] or false)) end
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        else
                            --Do we want to assist the shield if it isnt at full health?
                            local iShieldCurHealth, iShieldMaxHealth = M28UnitInfo.GetCurrentAndMaximumShield(oNearestShieldWithHealth, true)
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want ACU to assist the shield it is currently assigned to, shield health%='..iShieldCurHealth / iShieldMaxHealth) end
                            if iShieldCurHealth / iShieldMaxHealth <= 0.85 then
                                M28Orders.IssueTrackedGuard(oACU, oNearestShieldWithHealth, false, 'RetrAsSh', false)
                                if not(oNearestShieldWithHealth[M28Building.reftArtiTemplateRefs]) and iShieldCurHealth / iShieldMaxHealth <= 0.8 then
                                    --Add shield to table of priority shields to assist for engineers
                                    local bAlreadyRecorded = false
                                    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftPriorityShieldsToAssist]) == false then
                                        for iRecorded, oRecorded in tLZOrWZTeamData[M28Map.reftPriorityShieldsToAssist] do
                                            if oRecorded == oNearestShieldWithHealth then bAlreadyRecorded = true break end
                                        end
                                    end
                                    if not(bAlreadyRecorded) then
                                        if not(tLZOrWZTeamData[M28Map.reftPriorityShieldsToAssist]) then tLZOrWZTeamData[M28Map.reftPriorityShieldsToAssist] = {} end
                                        table.insert(tLZOrWZTeamData[M28Map.reftPriorityShieldsToAssist], oNearestShieldWithHealth)
                                        oNearestShieldWithHealth[M28Building.refbRemoveShieldFromPriorityTableWhenFullHealth] = true
                                    end
                                end
                            end
                        end
                    end

                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': We have a shield in this zone, but ACU is on full health and/or is already under shield coverage or the shield lacks sufficient health so wont retreat to this shield') end
        else
            --Find out closest zone on a plateau that has a shield
            local iClosestCoreZoneWithShield = 275 --no point trying to move to a zone further away than this
            local iCurDist
            local iClosestZoneWithShieldRef
            local tMoveDestination
            local iMinShieldsWanted = 2
            if M28UnitInfo.GetUnitHealthPercent(oACU) < 1 or tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] then iMinShieldsWanted = 1 end
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iPlateauOrZero]) == false then
                for iZone, bCoreZone in M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iPlateauOrZero] do
                    if not(iZone == iLandOrWaterZone) then
                        local tAltLZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iZone]
                        local tAltLZTeamData = tAltLZData[M28Map.subrefLZTeamData][iTeam]
                        --Require at least 1 more shield at the target zone than in this zone, otherwise hte first zone to get a shield will have all ACUs going towards it
                        if (tAltLZTeamData[M28Map.subrefiT3FixedShieldConstructedCount] or 0) >= iMinShieldsWanted and tAltLZTeamData[M28Map.subrefLZbCoreBase] and not(tAltLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) then
                            if tAltLZData[M28Map.subrefLZIslandRef] == tLZOrWZData[M28Map.subrefLZIslandRef] then
                                iCurDist = M28Map.GetTravelDistanceBetweenLandZones(iPlateauOrZero, iLandOrWaterZone, iZone, true)
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Zone on dif island so significantly increasing the distance') end
                                iCurDist = 100 + M28Utilities.GetDistanceBetweenPositions(tAltLZData[M28Map.subrefMidpoint], tLZOrWZData[M28Map.subrefMidpoint])
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Alternative zone '..iZone..' has shield constructed count '..(tAltLZTeamData[M28Map.subrefiT3FixedShieldConstructedCount] or 0)..'; iCurDist='..repru(iCurDist)..'; iMinShieldsWanted='..iMinShieldsWanted..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')) end
                            if iCurDist < iClosestCoreZoneWithShield then
                                --Is the target zone not significantly closer to the nearest enemy base?
                                if bDebugMessages == true then LOG(sFunctionRef..': Dist to nearest base from target zone='..M28Utilities.GetDistanceBetweenPositions(tAltLZData[M28Map.subrefMidpoint], tAltLZTeamData[M28Map.reftClosestEnemyBase])..'; Dist to enemy base from cur zone='..M28Utilities.GetDistanceBetweenPositions(tLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestEnemyBase])) end
                                if M28Utilities.GetDistanceBetweenPositions(tAltLZData[M28Map.subrefMidpoint], tAltLZTeamData[M28Map.reftClosestEnemyBase]) + 30 >= M28Utilities.GetDistanceBetweenPositions(tLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) then
                                    iClosestCoreZoneWithShield = iCurDist
                                    iClosestZoneWithShieldRef = iZone
                                    tMoveDestination = {tAltLZData[M28Map.subrefMidpoint][1], tAltLZData[M28Map.subrefMidpoint][2], tAltLZData[M28Map.subrefMidpoint][3]}
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iClosestZoneWithShieldRef='..(iClosestZoneWithShieldRef or 'nil')..'; iClosestCoreZoneWithShield='..iClosestCoreZoneWithShield) end
            if iClosestZoneWithShieldRef then
                M28Orders.IssueTrackedMove(oACU, tMoveDestination, 5, false, 'RetrSh', false)
                if bDebugMessages == true then LOG(sFunctionRef..': Will retreat ACU to the zone') end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if are any T2 plus shields nearby if vulnerable to novax, since since last novax tLZOrWZTeamData[M28Map.refiTimeOfNearbyEnemyNovax]='..GetGameTimeSeconds() - (tLZOrWZTeamData[M28Map.refiTimeOfNearbyEnemyNovax] or 0)..'; ACU health percent='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; iPlateauOrZero='..iPlateauOrZero..'; Novax count='..M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount]) end
                if M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.95 and iPlateauOrZero > 0 and M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] > 0 and tLZOrWZTeamData[M28Map.refiTimeOfNearbyEnemyNovax] and GetGameTimeSeconds() - tLZOrWZTeamData[M28Map.refiTimeOfNearbyEnemyNovax] <= 5 then
                    --Do we have any allied Fixed T2 non-Cybran shields nearby? if so try heading here instead
                    local aiBrain = oACU:GetAIBrain()
                    local tNearbyFixedShields = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedShield - categories.CYBRAN * categories.TECH2 -categories.TECH1, oACU:GetPosition(), 120, 'Ally')
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby fixed shields empty='..tostring(M28Utilities.IsTableEmpty(tNearbyFixedShields) == false)) end
                    if M28Utilities.IsTableEmpty(tNearbyFixedShields) == false then
                        --Assist the closest fixed shield with health, or just the closest under construction
                        local iClosestWithHealthShieldDist = 10000
                        local iClosestShieldOfAnyTypeDist = 10000
                        local oClosestWithHealthShield
                        local oClosestShieldOfAnyType
                        local iCurDist, iCurShield, iMaxShield


                        for iShield, oShield in tNearbyFixedShields do
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oACU:GetPosition())
                            if iCurDist < iClosestWithHealthShieldDist then
                                if NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oShield:GetPosition()) == iPlateauOrZero then
                                    if iCurDist < iClosestShieldOfAnyTypeDist then
                                        oClosestShieldOfAnyType = oShield
                                        iClosestShieldOfAnyTypeDist = iCurDist
                                    end
                                    if oShield:GetFractionComplete()== 1 then
                                        iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                                        if iCurShield >= 100 then
                                            iClosestWithHealthShieldDist = iCurDist
                                            oClosestWithHealthShield = oShield
                                        end
                                    end
                                end
                            end
                        end
                        local oShieldToAssist = oClosestWithHealthShield or oClosestShieldOfAnyType
                        if bDebugMessages == true then LOG(sFunctionRef..': oShieldToAssist='..(oShieldToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oShieldToAssist) or 'nil')) end
                        if oShieldToAssist then
                            oACU[refoShieldRallyTarget] = oShieldToAssist
                            M28Orders.IssueTrackedGuard(oACU, oShieldToAssist, false, 'BkcupAsSh', false)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function ReturnACUToCoreBase(oACU, tLZOrWZData, tLZOrWZTeamData, aiBrain, iTeam, iPlateauOrZero, iLandOrWaterZone)
    local sFunctionRef = 'ReturnACUToCoreBase'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    oACU[refiTimeLastWantedToRun] = GetGameTimeSeconds()

    --Go to core base
    local tRallyPoint

    if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        local tFixedShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tFixedShields) == false then
            local iNearestDist = 10000
            local iCurDist
            local oNearestUnit
            local bCheckIfOtherACUsUnderShield = false
            local bAddAsNearestShield
            if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 then
                bCheckIfOtherACUsUnderShield = true
                if M28UnitInfo.GetUnitHealthPercent(oACU) < 0.9 then bCheckIfOtherACUsUnderShield = false end
            end
            for iUnit, oUnit in tFixedShields do
                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())
                    if iCurDist < iNearestDist then
                        bAddAsNearestShield = true
                        --Check not already assigned to an ACU (unless we are low health)
                        if bCheckIfOtherACUsUnderShield then
                            for iFriendlyACU, oFriendlyACU in M28Team.tTeamData[iTeam][M28Team.reftM28ACUs] do
                                if not(oFriendlyACU == oACU) then
                                    if oFriendlyACU[refoShieldRallyTarget] and oFriendlyACU[refoShieldRallyTarget] == oUnit then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Wont go to nearest shield as it is already a rally target for another ACU') end
                                        iCurDist = iCurDist + 400
                                        if iCurDist > iNearestDist then
                                            bAddAsNearestShield = false
                                            break
                                        end
                                    end
                                end
                            end
                        end
                        if bAddAsNearestShield then
                            iNearestDist = iCurDist
                            oNearestUnit = oUnit
                        end
                    end
                end
            end

            if oNearestUnit then
                oACU[refoShieldRallyTarget] = oNearestUnit
                if bDebugMessages == true then LOG(sFunctionRef..': Will set rally point to the nearest fixed shield, position='..repru(oNearestUnit:GetPosition())..'; Nearest unit='..oNearestUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestUnit)) end
                tRallyPoint = oNearestUnit:GetPosition()
            end
        end
    end
    if not(tRallyPoint) then
        if bDebugMessages == true then LOG(sFunctionRef..': No shields so will move ACU to start point') end
        tRallyPoint = M28Map.GetPlayerStartPosition(oACU:GetAIBrain())
    end

    local iNearestEnemyExperimental = 1000
    local oNearestEnemyExperimental
    local iCurDist
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
        for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())
            if iCurDist < iNearestEnemyExperimental then
                iNearestEnemyExperimental = iCurDist
                oNearestEnemyExperimental = oUnit
            end
        end
    end
    local iAngleThreshold = 115
    --Consider running from the experimental if we arent in its range yet
    if oNearestEnemyExperimental and iNearestEnemyExperimental > (oNearestEnemyExperimental[M28UnitInfo.refiDFRange] or 30) + 1 and iNearestEnemyExperimental <= 160 then
        --Would moving towards the closest base take us in a similar direction to this experimental?
        local iAngleToExperimental = M28Utilities.GetAngleFromAToB(oACU:GetPosition(), oNearestEnemyExperimental:GetPosition())
        local iAngleToRally = M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tRallyPoint)
        local iAngleDif = M28Utilities.GetAngleDifference(iAngleToExperimental, iAngleToRally)
        if bDebugMessages == true then LOG(sFunctionRef..': iAngleToExperimental='..iAngleToExperimental..'; iAngleToRally='..iAngleToRally..'; iAngleDif='..iAngleDif..'; iNearestEnemyExperimental='..iNearestEnemyExperimental) end
        if iAngleDif < iAngleThreshold then
            --What if we just go to a land rally point?
            local tAltRallyPoint
            if iPlateauOrZero == 0 then
                tAltRallyPoint = oACU[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition] or M28Navy.GetNearestWaterRallyPoint(tLZOrWZData, iTeam, M28Map.tiPondByWaterZone[iLandOrWaterZone], iLandOrWaterZone)
            else
                tAltRallyPoint = M28Land.GetNearestLandRallyPoint(tLZOrWZData, iTeam, iPlateauOrZero, iLandOrWaterZone, 3, true)
            end
            local iAngleToAltRally = M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tAltRallyPoint)
            local iAltRallyAngleDif = M28Utilities.GetAngleDifference(iAngleToExperimental, iAngleToAltRally)
            if bDebugMessages == true then LOG(sFunctionRef..': Angle to alt rally='..iAltRallyAngleDif) end
            if iAltRallyAngleDif >= iAngleThreshold or (iAltRallyAngleDif >= 90 and iAltRallyAngleDif > iAngleDif) then
                tRallyPoint = tAltRallyPoint
            elseif iNearestEnemyExperimental <= 100 then
                --Try moving away from the enemy unit if it is getting close to us
                local tTempPosition
                local bHaveValidRunAwayPosition = false
                for iDistance = 10, 30, 10 do
                    for iAngleSize = 0, 45, 15 do
                        for iAngleMod = -1, 1, 2 do
                            tTempPosition = M28Utilities.MoveInDirection(oACU:GetPosition(), iAngleToExperimental + 180 + iAngleSize * iAngleMod, iDistance, true, true, M28Map.bIsCampaignMap)
                            if M28Utilities.IsTableEmpty(tTempPosition) == false and NavUtils.GetLabel(M28Map.refPathingTypeHover, tTempPosition) == iPlateauOrZero then
                                tRallyPoint = tTempPosition
                                bHaveValidRunAwayPosition = true
                                if bDebugMessages == true then LOG(sFunctionRef..': will try running in opposite direction to approaching enemy experimental, iDistance='..iDistance..'; iAngleSize='..iAngleSize..'; iAngleMod='..iAngleMod) end
                                break
                            end
                        end
                        if bHaveValidRunAwayPosition then break end
                    end
                    if bHaveValidRunAwayPosition then break end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': bHaveValidRunAwayPosition='..tostring(bHaveValidRunAwayPosition)..'; tRallyPoint='..repru(tRallyPoint)) end
            end
        end
    end

    if not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and not(tLZOrWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) then
        if iPlateauOrZero > 0 and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) == false and M28Conditions.GiveAttackMoveAsWeaponStuck(oACU) and M28Conditions.CloseToEnemyUnit(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftoNearestDFEnemies], oACU[M28UnitInfo.refiCombatRange], iTeam, false, nil, nil, nil, nil, nil) then
            M28Orders.IssueTrackedAttackMove(oACU, tRallyPoint, 3, false, 'RunT')
        else
            M28Orders.IssueTrackedMove(oACU, tRallyPoint, 3, false, 'Runa')
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Sending ACU to core base') end
    else
        --Consider attacking nearby enemies if no enemy experimental
        if bDebugMessages == true then LOG(sFunctionRef..': iNearestEnemyExperimental='..iNearestEnemyExperimental..'; ACU range='..oACU[M28UnitInfo.refiDFRange]..'; ACU health='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; ACU dist to rally='..M28Utilities.GetDistanceBetweenPositions(tRallyPoint, oACU:GetPosition())) end
        if (iNearestEnemyExperimental <= 150 and iNearestEnemyExperimental >= (oACU[M28UnitInfo.refiDFRange] or 0) + 5) or (M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.6 and M28Utilities.GetDistanceBetweenPositions(tRallyPoint, oACU:GetPosition()) > 10) then
            if bDebugMessages == true then LOG(sFunctionRef..': Will move ACU to rally point instead of base, unless it means moving close to the exp, in which case will try moving in the opposite direction if we can') end
            if oNearestEnemyExperimental then
                local iAngleToNearestExp = M28Utilities.GetAngleFromAToB(oACU:GetPosition(), oNearestEnemyExperimental:GetPosition())
                local iAngleToRally = M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tRallyPoint)
                local iAngleThreshold = 115
                if M28Utilities.GetAngleDifference(iAngleToNearestExp, iAngleToRally) <= iAngleThreshold then
                    --We aren't moving away from the experimental by much
                    local tPotentialAltLocation
                    local iClosestAltLocation = 10000
                    --If we have ot her core bases we can retreat to them, otherwise try moving in the opposite direction
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iPlateauOrZero]) == false then
                        for iLandZone, _ in M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau][iPlateauOrZero] do
                            if not(iLandZone == iLandOrWaterZone) then
                                local tAltLZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandZone]
                                local iAngleToAltMidpoint = M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tAltLZData[M28Map.subrefMidpoint])
                                if M28Utilities.GetAngleDifference(iAngleToNearestExp, iAngleToAltMidpoint) > iAngleThreshold then
                                    local iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tAltLZData[M28Map.subrefMidpoint])
                                    if iCurDist < iClosestAltLocation then
                                        iClosestAltLocation = iCurDist
                                        tPotentialAltLocation = { tAltLZData[M28Map.subrefMidpoint][1], tAltLZData[M28Map.subrefMidpoint][2], tAltLZData[M28Map.subrefMidpoint][3]}
                                    end
                                end
                            end
                        end
                    end
                    if not(tPotentialAltLocation) then
                        local iAmphibiousLabelWanted = NavUtils.GetTerrainLabel(M28Map.refPathingTypeAmphibious, oACU:GetPosition())
                        if iAmphibiousLabelWanted then
                            for iMoveDist = 10, 30, 5 do
                                tPotentialAltLocation = M28Utilities.MoveInDirection(oACU:GetPosition(), iAngleToNearestExp + 180, iMoveDist, true, true, M28Map.bIsCampaignMap)
                                if M28Utilities.IsTableEmpty(tPotentialAltLocation) == false and NavUtils.GetTerrainLabel(M28Map.refPathingTypeAmphibious, tPotentialAltLocation) == iAmphibiousLabelWanted then
                                    break
                                else
                                    tPotentialAltLocation = nil
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Angle to rally is too close to exp, so tried searching for alt locations, tPotentialAltLocation='..repru(tPotentialAltLocation)) end
                    if M28Utilities.IsTableEmpty(tPotentialAltLocation) == false then
                        tRallyPoint = {tPotentialAltLocation[1], tPotentialAltLocation[2], tPotentialAltLocation[3]}
                    end
                end
            end

            M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'Runb')

        else
            if tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] and AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                --Do nothing
                if bDebugMessages == true then LOG(sFunctionRef..': Will attack nearby enemy units with ACU') end
            else
                --Are there nearby enemy naval units to attack?
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if are nearby naval threats to attack, is table of adjacent WZs empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]))..'; Do we lack torp bombers for enemy naval='..tostring(M28Team.tAirSubteamData[oACU:GetAIBrain().M28AirSubteam][M28Team.refbNoAvailableTorpsForEnemies])) end
                if (oACU[M28UnitInfo.refiDFRange] or 0) > 0 and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]) == false and M28Team.tAirSubteamData[oACU:GetAIBrain().M28AirSubteam][M28Team.refbNoAvailableTorpsForEnemies] and ConsiderAttackingNearbyNavalUnits(tLZOrWZData, tLZOrWZTeamData, oACU, oACU[M28UnitInfo.refiDFRange] + 10) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will attack nearby naval threats') end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': No naval threats close enough to attack so will consider nearby reclaim') end
                    if not(ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, true)) then
                        local sUpgradeToGet, bIgnoreOtherUpgradeConditions = GetACUUpgradeWanted(oACU, nil, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero)
                        if sUpgradeToGet and (bIgnoreOtherUpgradeConditions or (not(M28Conditions.HaveLowMass(aiBrain)) and not(M28Conditions.HaveLowPower(aiBrain)))) then
                            --Are we safe to get the upgrade here? if not then retreat
                            if bIgnoreOtherUpgradeConditions or M28Conditions.SafeToUpgradeUnit(oACU) then
                                if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastIssuedACUEnhancementOrder] or -100) >= 2 or oACU[M28Orders.refiTimeOfLastRemovalUpgrade] or oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] == sUpgradeToGet then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Safe to get upgrade so will proceed with upgrading ACU, sUpgradeToGet='..(sUpgradeToGet or 'nil')..' brain='..oACU:GetAIBrain().Nickname) end
                                    M28Orders.IssueTrackedEnhancement(oACU, sUpgradeToGet, false, 'ACUUpg')
                                end
                            else
                                M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'Runc')
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Dont want upgrade or reclaim, will look for buildings to assist. Is table of ugprades empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoActiveUpgrades]))..'; Have low mass='..tostring(M28Conditions.HaveLowMass(aiBrain))..'; Have low power='..tostring(M28Conditions.HaveLowPower(iTeam))) end
                            local oUnitToAssist
                            if (not(M28Conditions.HaveLowPower(iTeam)) or (aiBrain:GetEconomyStoredRatio('ENERGY') >= 1 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 25 and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]))) then
                                local bOnlyGetMexToAssist = M28Conditions.HaveLowMass(aiBrain)
                                local iHighestFractionComplete = -1

                                if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoActiveUpgrades]) == false then
                                    for iUpgrading, oUpgrading in  tLZOrWZTeamData[M28Map.subreftoActiveUpgrades] do
                                        if M28UnitInfo.IsUnitValid(oUpgrading) then
                                            if oUpgrading:GetWorkProgress() < 1 and oUpgrading:GetWorkProgress() > iHighestFractionComplete then
                                                if not(bOnlyGetMexToAssist) or EntityCategoryContains(M28UnitInfo.refCategoryMex, oUpgrading.UnitId) then
                                                    iHighestFractionComplete = oUpgrading:GetWorkProgress()
                                                    oUnitToAssist = oUpgrading
                                                end
                                            end
                                        end
                                    end
                                end
                                if not(oUnitToAssist) and not(bOnlyGetMexToAssist) then
                                    --Do we have any part-complete buildings and dont have low mass? if so assist these
                                    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                        local tStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryExperimentalLevel, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                        if M28Utilities.IsTableEmpty(tStructures) == false then
                                            for iUnit, oUnit in tStructures do
                                                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() < 1 and oUnit:GetFractionComplete() > iHighestFractionComplete and not(oUnit[M28Engineer.refbDontIncludeAsPartCompleteBuildingForConstruction]) then
                                                    iHighestFractionComplete = oUnit:GetFractionComplete()
                                                    oUnitToAssist = oUnit
                                                end
                                            end
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': oUnitToAssist='..(oUnitToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitToAssist) or 'nil')..'; ACU last order reprs='..reprs(oACU[M28Orders.reftiLastOrders])) end
                            end
                            if oUnitToAssist then
                                if oUnitToAssist:GetFractionComplete() < 1 then
                                    M28Orders.IssueTrackedRepair(oACU, oUnitToAssist, false, 'ACUTR', false)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Just given repair order to oUnitToAssist') end
                                else
                                    M28Orders.IssueTrackedGuard(oACU, oUnitToAssist, false, 'ACUGB', false)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Just given guard order to oUnitToAssist') end
                                end
                            else
                                M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'Rund')
                            end

                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetBestTeleSnipeUnitTarget(oACU, iTeam)
    --Make sure we have a relatively recent target list since we are proceeding to teleport
    local sFunctionRef = 'GetBestTeleSnipeUnitTarget'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    M28Team.RefreshPotentialTeleSnipeTargets(iTeam, 1)
    local oTargetWanted
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of targets empty after forced refresh every 1s='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoPotentialTeleSnipeTargets]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoPotentialTeleSnipeTargets]) == false then
        local iHighestValueTarget = 0
        local iCurTargetValue
        for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftoPotentialTeleSnipeTargets] do
            if M28UnitInfo.IsUnitValid(oUnit) then
                if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                    iCurTargetValue = 20000 --will only have an ACU if in assassination mode
                    if table.getn(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) == 1 and M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refbAssassinationOrSimilar] and M28UnitInfo.GetCombatThreatRating({M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs][1]}, true) <= 4000 then
                        iCurTargetValue = 250000 --i.e. if we kill the ACU then it is better than killing a game ender (although will reduce to less than a gameender if it has high health)
                    end
                    local iUnitHealth = oUnit:GetHealth()
                    local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, true)
                    iUnitHealth = iUnitHealth + iCurShield
                    if iUnitHealth >= 15000 then
                        iCurTargetValue = 180000 --likely better to target a gameender than ACU if acu is high health
                        iCurTargetValue = iCurTargetValue - math.min(iCurTargetValue * 0.6, math.max((iUnitHealth - 15000) * 0.3))
                    end
                else
                    iCurTargetValue = (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * oUnit:GetFractionComplete()
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurTargetValue before shield adjust='..iCurTargetValue) end
                if iCurTargetValue > iHighestValueTarget then
                    --Reduce value by shields in the zone
                    local tUnitLZData, tUnitLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                    iCurTargetValue = iCurTargetValue - math.min(iCurTargetValue * 0.3, (tUnitLZTeamData[M28Map.subrefThreatEnemyShield] or 0))
                    if iCurTargetValue > iHighestValueTarget then
                        iHighestValueTarget = iCurTargetValue
                        oTargetWanted = oUnit
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording unit as oTargetWanted subject to any better ones, iHighestValueTarget='..iHighestValueTarget) end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oTargetWanted
end

function GetBestLocationForTeleSnipeTarget(oACU, oSnipeTarget, iTeam, bJustCheckIfLocationWithLowPDThreat)
    --oACU - if nil then will assume has a range of 30
    --bJustCheckIfLocationWithLowPDThreat - if this is true, then returns true if think there is a low PD threat location to teleport to


    local sFunctionRef = 'GetBestLocationForTeleSnipeTarget'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --We ahve a valid oSnipeTarget for oACU to teleport to and try and kill, now we want to refine the teleport destination, e.g. to avoid volatile units and PD
    local tBestTarget
    local bConsiderAvoidingVolatileUnits = true
    local iMinDistanceAway = 0
    local iDistFromAOEWanted = 2
    local iMaxDistFromTarget = (oACU[M28UnitInfo.refiDFRange] or 30) - 2
    if EntityCategoryContains(categories.MOBILE - M28UnitInfo.refCategoryScathis, oSnipeTarget.UnitId) then iMaxDistFromTarget = iMaxDistFromTarget - 8 end

    local iTargetPlateau, iTargetLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oSnipeTarget:GetPosition())

    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, oSnipeTarget='..oSnipeTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSnipeTarget)..' owned by brain '..oSnipeTarget:GetAIBrain().Nickname..'; Position='..repru(oSnipeTarget:GetPosition())..'; iTargetPlateau='..(iTargetPlateau or 'nil')..'; iTargetLandZone='..(iTargetLandZone or 'nil')) end
    if iTargetPlateau > 0 and (iTargetLandZone or 0) > 0 then
        local tTargetLZData = M28Map.tAllPlateaus[iTargetPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone]
        local tTargetLZTeamData = tTargetLZData[M28Map.subrefLZTeamData][iTeam]

        local tNearbyPD = {}
        local tCurZonePD = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD, tTargetLZTeamData[M28Map.subrefTEnemyUnits])
        if M28Utilities.IsTableEmpty(tCurZonePD) == false then
            for iUnit, oUnit in tCurZonePD do
                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then
                    table.insert(tNearbyPD, oUnit)
                end
            end
        end
        if M28Utilities.IsTableEmpty(tTargetLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in tTargetLZData[M28Map.subrefLZAdjacentLandZones] do
                local tAdjLZData = M28Map.tAllPlateaus[iTargetPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    local tAdjPD = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD, tAdjLZTeamData[M28Map.subrefTEnemyUnits])
                    if M28Utilities.IsTableEmpty(tAdjPD) == false then
                        for iPD, oPD in tAdjPD do
                            if M28UnitInfo.IsUnitValid(oPD) then
                                table.insert(tNearbyPD, oPD)
                            end
                        end
                    end
                end
            end
        end


        local tiApproxPDDPSByTech = {[1]=167,[2]=132,[3]=273, [4]=1000}
        local iCurDistToTarget
        function EstimatePDDPSNearLocation(tLocation, iDistanceThreshold)
            local iPDApproxDPS = 0
            if M28Utilities.IsTableEmpty(tNearbyPD) == false then
                for iUnit, oUnit in tNearbyPD do
                    iCurDistToTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLocation)
                    if iCurDistToTarget - oUnit[M28UnitInfo.refiDFRange] <= (iDistanceThreshold or 2) then
                        iPDApproxDPS = iPDApproxDPS + tiApproxPDDPSByTech[M28UnitInfo.GetUnitTechLevel(oUnit)]
                    end
                end
            end
            return iPDApproxDPS
        end

        --Get volatile units and PD in this and adjacent land zones so can factor in if alternative locations are more dangerous
        local tVolatileUnits = {}
        if not(bJustCheckIfLocationWithLowPDThreat) then
            local tPotentialVolatileUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryVolatile * categories.STRUCTURE, tTargetLZTeamData[M28Map.subrefTEnemyUnits])
            if M28Utilities.IsTableEmpty(tPotentialVolatileUnits) == false then
                for iUnit, oUnit in tPotentialVolatileUnits do
                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then
                        local iDeathDamage, iDeathAOE, tDeathWeapon = M28UnitInfo.GetDeathWeaponDamageAOEAndTable(oUnit)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering volatile units in zone, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iDeathDamage='..iDeathDamage) end
                        if iDeathDamage >= 1250 then
                            table.insert(tVolatileUnits, oUnit)
                        end
                    end
                end
            end
        end

        function EstimateVolatileDamageNearLocation(tPotentialLocation, iOptionalAOEAdjust)
            local iVolatileDamage = 0
            if M28Utilities.IsTableEmpty(tVolatileUnits) == false then
                for iUnit, oUnit in tVolatileUnits do
                    iCurDistToTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tPotentialLocation)
                    local iDeathDamage, iDeathAOE, tDeathWeapon = M28UnitInfo.GetDeathWeaponDamageAOEAndTable(oUnit)
                    if bDebugMessages == true then LOG(sFunctionRef..': iCurDistToTarget='..iCurDistToTarget..'; iDeathDamage='..(iDeathDamage or 'nil')..'; iDeathAOE='..(iDeathAOE or 'nil')..'; iOptionalAOEAdjust='..(iOptionalAOEAdjust or 'nil')) end
                    if iCurDistToTarget <= 1 + iDeathAOE + (iOptionalAOEAdjust or 0) then
                        iVolatileDamage = iVolatileDamage + iDeathDamage
                    end
                end
            end
            return iVolatileDamage
        end
        local iBaseTargetPDDPS = EstimatePDDPSNearLocation(oSnipeTarget:GetPosition(), 6)
        local iBaseTargetVolatileDamage = 0

        local bKeepToCampaignPlayableArea = M28Map.bIsCampaignMap

        function IsPotentialAlternativeLocationTooDangerous(tPotentialLocation, iDistThreshold, iPDDPSThreshold, iOptionalVolatileTarget)
            --factors in tVolatileUnits, tPD, and general zone stats re dangerous units if the zone is different to the target unit (air to ground and mobile DF) to decide whether it is safe to teleport to a location
            local bDangerous = true
            local iPDDPS = EstimatePDDPSNearLocation(tPotentialLocation, iDistThreshold)
            if iPDDPS <= iPDDPSThreshold then
                if not(iOptionalVolatileTarget) then
                    bDangerous = false
                else
                    if EstimateVolatileDamageNearLocation(tPotentialLocation, iDistThreshold) <= iOptionalVolatileTarget then
                        bDangerous = false
                    end
                end
            end
            return bDangerous, iPDDPS
        end

        function UpdateBestTargetIfSafeLocationNearTargetUnit(oTargetUnit, iDistanceAwayMin, iDistanceAwayMax, iMaxPDDPS, iOptionalMaxVolatileDamage)
            --Try 8 different points around target to see if any of them are safer
            local iAngleInterval = 360 / 8
            local iDistFromSnipeTarget
            local bTargetWithinRange
            local iLeewayUntilOutOfRange
            local iPDDistThreshold
            local iDistanceInterval = iDistanceAwayMax - iDistanceAwayMin
            local iPDDPSThreshold = iMaxPDDPS
            if iDistanceInterval >= 4 then iDistanceInterval = 4 end
            if bDebugMessages == true then LOG(sFunctionRef..': Searching for safer locations to target oTargetUnit '..oTargetUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTargetUnit)..'; iDistanceAwayMin='..iDistanceAwayMin..'; iDistanceAwayMax='..iDistanceAwayMax..'; iOptionalMaxVolatileDamage='..(iOptionalMaxVolatileDamage or 'nil')) end
            for iDistanceAway = iDistanceAwayMin, iDistanceAwayMax, iDistanceInterval do
                for iCurAngle = iAngleInterval, 360, iAngleInterval do
                    local tPotentialTarget = M28Utilities.MoveInDirection(oTargetUnit:GetPosition(), iAngleInterval, iDistanceAway, true, false, bKeepToCampaignPlayableArea)
                    --Is this location actually within range of the snipe target?
                    iDistFromSnipeTarget = M28Utilities.GetDistanceBetweenPositions(tPotentialTarget, oSnipeTarget:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering tPotentialTarget='..repru(tPotentialTarget)..'; iDistanceAway='..iDistanceAway..'; iCurAngle='..iCurAngle..'; iDistFromSnipeTarget='..iDistFromSnipeTarget..'; iMaxDistFromTarget='..iMaxDistFromTarget) end
                    if iDistFromSnipeTarget < iMaxDistFromTarget then
                        bTargetWithinRange = false
                        iLeewayUntilOutOfRange = (oACU[M28UnitInfo.refiDFRange] or 30) - iDistFromSnipeTarget
                        iPDDistThreshold = 2
                        local tNearbyUnits = GetUnitsInRect(tPotentialTarget[1] - 1, tPotentialTarget[3] - 1, tPotentialTarget[1] + 1, tPotentialTarget[3] + 1)
                        if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                            local tNearbyStructures = EntityCategoryFilterDown(categories.STRUCTURE, tNearbyUnits)
                            if M28Utilities.IsTableEmpty(tNearbyStructures) == false then
                                for iUnit, oUnit in tNearbyStructures do
                                    iPDDistThreshold = math.max(iPDDistThreshold, M28UnitInfo.GetBuildingSize(oUnit.UnitId))
                                end
                            end
                        end

                        if iPDDistThreshold < iLeewayUntilOutOfRange then
                            bTargetWithinRange = true
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iPDDistThreshold='..iPDDistThreshold..'; iLeewayUntilOutOfRange='..iLeewayUntilOutOfRange..'; bTargetWithinRange='..tostring(bTargetWithinRange)) end
                        if bTargetWithinRange then
                            --Is PD threat from this location less than before?
                            local bAlternativeLocationDangerous, iPotentialPDDPS = IsPotentialAlternativeLocationTooDangerous(tPotentialTarget, iPDDistThreshold, iPDDPSThreshold, iOptionalMaxVolatileDamage)
                            if not(bAlternativeLocationDangerous) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have a new best target') end
                                tBestTarget = {tPotentialTarget[1], tPotentialTarget[2], tPotentialTarget[3]}
                                if iPotentialPDDPS <= 400 then
                                    break
                                else
                                    --Keep looking in case are locations with even less PD threat
                                    iPDDPSThreshold = math.min(iPotentialPDDPS, iPDDPSThreshold * 0.8)
                                end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Target not safe enough') end
                            end
                        end
                    end
                end
                if iDistanceInterval <= 0 or (tBestTarget and iPDDPSThreshold <= 400) then break end
            end
        end

        local bConsiderVolatileHealth = false
        if M28Team.tTeamData[iTeam][M28Team. refbAssassinationOrSimilar] then bConsiderVolatileHealth = true end
        if bDebugMessages == true then LOG(sFunctionRef..': iBaseTargetPDDPS='..iBaseTargetPDDPS) end
        if iBaseTargetPDDPS >= 700 then
            --Want to search for locations with lower PD threat, if there are any
            local iTargetBuildingSize = M28UnitInfo.GetBuildingSize(oSnipeTarget.UnitId)
            if bDebugMessages == true then LOG(sFunctionRef..': Will look for targets that avoid PD, tBestTarget before change='..repru(tBestTarget)..'; iTargetBuildingSize='..iTargetBuildingSize..'; ACU DF range='..(oACU[M28UnitInfo.refiDFRange] or 30)) end
            local iMaxDPSWanted
            if bJustCheckIfLocationWithLowPDThreat then iMaxDPSWanted = 690 --Roughly 4 T1 pd
            else
                iMaxDPSWanted = iBaseTargetPDDPS * 0.8
            end
            local iVolatileHealthLevel = nil
            if bConsiderVolatileHealth then iVolatileHealthLevel = 9000 end
            UpdateBestTargetIfSafeLocationNearTargetUnit(oSnipeTarget, iTargetBuildingSize, math.min(iMaxDistFromTarget, iTargetBuildingSize + 4 * 4, (oACU[M28UnitInfo.refiDFRange] or 30) - 6), iMaxDPSWanted, iVolatileHealthLevel)
            if bDebugMessages == true then LOG(sFunctionRef..': Attempted to change target to avoid PD, tBestTarget after change='..repru(tBestTarget)) end
            if bJustCheckIfLocationWithLowPDThreat and tBestTarget then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            end
        else
            if bJustCheckIfLocationWithLowPDThreat then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            else
                --avoid aoe on the target itself unless iti s a game ender with heavy shielding, or it doesnt matter if we die
                if bConsiderVolatileHealth and not(EntityCategoryContains(categories.MOBILE - M28UnitInfo.refCategoryScathis, oSnipeTarget.UnitId)) then --(dont want to mvoe away from mobile units such as ACUs in case they then move out of our range; exceptino for scathis due to how slow it is and itneeding to pack up)
                    if not(EntityCategoryContains(M28UnitInfo.refCategoryGameEnder, oSnipeTarget.UnitId)) or (tTargetLZTeamData[M28Map.subrefThreatEnemyShield] or 0) <= 5000 or M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] == 1 then
                        --First move away if targeting a highly volatile unit that could kill us, and we outrange the volatile radius (e.g. paragon and yolona)
                        local iBaseTargetVolatileDamage, iDeathAOE, tDeathWeapon = M28UnitInfo.GetDeathWeaponDamageAOEAndTable(oSnipeTarget)
                        if tDeathWeapon and iBaseTargetVolatileDamage >= 1250 then
                            if iDeathAOE + iDistFromAOEWanted < (oACU[M28UnitInfo.refiDFRange] or 30) then --Energy storage is 1k damage; also no point avoiding if outside our range

                                iMinDistanceAway = iDeathAOE + iDistFromAOEWanted
                                if bDebugMessages == true then LOG(sFunctionRef..': Snipe target has death aoe we want to avoid, iMinDistanceAway='..iMinDistanceAway..'; iDeathAOE='..iDeathAOE..'; iBaseTargetVolatileDamage='..iBaseTargetVolatileDamage) end
                            else
                                bConsiderAvoidingVolatileUnits = false --No point avoiding things like t3 pgens if the target itself will kill us when it dies
                                if bDebugMessages == true then LOG(sFunctionRef..': We cant dodge target volatile explosion so will not bother trying to dodge other volatile units') end
                            end
                        end
                    end
                end


                if bConsiderAvoidingVolatileUnits then
                    if iMinDistanceAway > 0 then
                        --Snipe target is volatile, so try and avoid
                        if bDebugMessages == true then LOG(sFunctionRef..': Snipe target is volatile so will try and avoid') end
                        UpdateBestTargetIfSafeLocationNearTargetUnit(oSnipeTarget, iMinDistanceAway, math.min(iMinDistanceAway + 4, iMaxDistFromTarget), iBaseTargetPDDPS * 0.25, iBaseTargetVolatileDamage * 0.5)

                    else
                        --We arent trying to avoid explosion from the target itself so consider avoiding explosion from nearby T3 pgens
                        local iTargetBuildingSize = M28UnitInfo.GetBuildingSize(oSnipeTarget.UnitId)
                        iBaseTargetVolatileDamage = EstimateVolatileDamageNearLocation(oSnipeTarget:GetPosition(), iTargetBuildingSize)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to try and avoid nearby volatile units, iBaseTargetVolatileDamage='..iBaseTargetVolatileDamage..'; iTargetBuildingSize='..iTargetBuildingSize) end
                        if iBaseTargetVolatileDamage > 0 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will try searching for safer locations') end
                            UpdateBestTargetIfSafeLocationNearTargetUnit(oSnipeTarget, iTargetBuildingSize, math.min(iMaxDistFromTarget, iTargetBuildingSize + 4 * 2, (oACU[M28UnitInfo.refiDFRange] or 30) - 6), iBaseTargetPDDPS * 0.25, 2000)
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Near end of code, tBestTarget before applying default if it is nil='..repru(tBestTarget)..'; will consider adjusting if close to mobile target, bJustCheckIfLocationWithLowPDThreat='..tostring(bJustCheckIfLocationWithLowPDThreat or false)) end
    if not(tBestTarget) then
        if bDebugMessages == true then LOG(sFunctionRef..': No safe targets, will just try teleporting to the snipe target') end
        tBestTarget = oSnipeTarget:GetPosition()
    end
    if bDebugMessages == true then LOG(sFunctionRef..': dist to snipe target='..M28Utilities.GetDistanceBetweenPositions(oSnipeTarget:GetPosition(), tBestTarget)..'; Does ACU have laser upgrade='..tostring(oACU:HasEnhancement('MicrowaveLaserGenerator'))..'; oSnipeTarget='..(oSnipeTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oSnipeTarget) or 'nil')) end
    --Issue - laser doesnt fire if are too close (which can happen if try to teleport right ontop of the enemy ACU)
    if EntityCategoryContains(categories.MOBILE, oSnipeTarget.UnitId) and oACU.HasEnhancement and oACU:HasEnhancement('MicrowaveLaserGenerator') and M28Utilities.GetDistanceBetweenPositions(tBestTarget, oSnipeTarget:GetPosition()) <= 4 then
        local iLandLabelWanted = NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, oSnipeTarget:GetPosition())
        local bHaveAltTarget = false
        if (iLandLabelWanted or 0) > 0 then
            for iDistFromTarget = 4, 16, 2 do
                for iAngleFromTarget = 0, 360, 15 do
                    local tPossibleTarget = M28Utilities.MoveInDirection(oSnipeTarget:GetPosition(), iAngleFromTarget, iDistFromTarget, true, true, true)
                    if tPossibleTarget and NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tPossibleTarget) == iLandLabelWanted then
                        bHaveAltTarget = true
                        tBestTarget = {tPossibleTarget[1], tPossibleTarget[2], tPossibleTarget[3]}
                        break
                    end
                end
                if bHaveAltTarget then break end
            end

        end
        if bDebugMessages == true then LOG(sFunctionRef..': Targeting mobile unit, bHaveAltTarget='..tostring(bHaveAltTarget)..'; tBestTarget='..repru(tBestTarget)) end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bJustCheckIfLocationWithLowPDThreat='..tostring(bJustCheckIfLocationWithLowPDThreat or false)..'; if this is true then will return false; tBestTarget='..repru(tBestTarget)) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bJustCheckIfLocationWithLowPDThreat then return false
    else return tBestTarget
    end


end

function HaveTelesnipeAction(oACU, tLZOrWZData, tLZOrWZTeamData, aiBrain, iTeam, iPlateauOrZero, iLandOrWaterZone)
    local sFunctionRef = 'HaveTelesnipeAction'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bGivenACUOrder = false

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for brain '..aiBrain.Nickname..'; Does ACU have special micro active='..tostring(oACU[M28UnitInfo.refbSpecialMicroActive] or false)) end
    if not(oACU[M28UnitInfo.refbSpecialMicroActive]) then

        --First check if we want to get upgrades to enable a tele-snipe
        local sUpgradeWanted
        if not(oACU[refbACUHasTeleport]) and EntityCategoryContains(categories.CYBRAN + categories.SERAPHIM, oACU.UnitId) then
            if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] and M28Team.tTeamData[iTeam][M28Team.refiEnemyT3ArtiCount] + M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] * 0.5 >= 1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 600 + 450 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                local bConsiderSniping = false
                function GetArtiEquivValue(oUnit)
                    local iArtiValue = 0
                    if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder - M28UnitInfo.refCategorySML, oUnit.UnitId) then
                        iArtiValue = 3
                    elseif EntityCategoryContains(M28UnitInfo.refCategorySML * categories.EXPERIMENTAL, oUnit.UnitId) then
                        iArtiValue = 2
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryNovaxCentre + M28UnitInfo.refCategorySatellite, oUnit.UnitId) then
                        iArtiValue = 0.6
                    else
                        iArtiValue = 1
                    end
                    return iArtiValue * oUnit:GetFractionComplete()
                end
                local iEnemyArtiCount = 0
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure]) == false then
                    for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure] do
                        if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() >= 0.85 then
                            iEnemyArtiCount = iEnemyArtiCount + GetArtiEquivValue(oUnit)
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyMobileSatellites]) == false then
                    local iNovaxCount = 0
                    for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyMobileSatellites] do
                        iNovaxCount = iNovaxCount + GetArtiEquivValue(oUnit)
                    end
                    iEnemyArtiCount = math.max(iEnemyArtiCount, iNovaxCount)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering for ACU '..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' owned by brain '..oACU:GetAIBrain().Nickname..'; iEnemyArtiCount='..iEnemyArtiCount) end
                if EntityCategoryContains(categories.CYBRAN, oACU.UnitId) or iEnemyArtiCount > 1 then
                    local bWeHaveRAS = false
                    if oACU:HasEnhancement('ResourceAllocation') or oACU:HasEnhancement('ResourceAllocationAdvanced') then bWeHaveRAS = true end

                    if not(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) and not(bWeHaveRAS) and (iEnemyArtiCount >= 2 or (iEnemyArtiCount >= 0.8 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 2250)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Arent in assassination mode so will consider sniping') end
                        bConsiderSniping = true
                    elseif not(bWeHaveRAS) and M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 and (iEnemyArtiCount >= 2 or (M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 2250 and (iEnemyArtiCount >= 0.8 or M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][3] < M28Conditions.GetHighestOtherTeamT3MexCount(iTeam)))) and (M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 3 or iEnemyArtiCount >= 2 or M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][3] * 0.8 < M28Conditions.GetHighestOtherTeamT3MexCount(iTeam)) then
                        bConsiderSniping = true
                    else
                        --Assassination, and down to last ACU, only go for telesnipe as a last resort
                        if iEnemyArtiCount >= 3 then
                            local iFriendlyArtiCount = 0
                            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                local tFriendlyExperimentals = oBrain:GetListOfUnits(M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryNovaxCentre + M28UnitInfo.refCategoryFixedT3Arti, false, false)
                                for iUnit, oUnit in tFriendlyExperimentals do
                                    if oUnit:GetFractionComplete() >= 0.4 then
                                        iFriendlyArtiCount = iFriendlyArtiCount + GetArtiEquivValue(oUnit)
                                    end
                                end
                            end
                            if iFriendlyArtiCount < 2 and iEnemyArtiCount - iFriendlyArtiCount >= 3 and (iEnemyArtiCount >= 4 or M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][3] < M28Conditions.GetHighestOtherTeamT3MexCount(iTeam)) then
                                bConsiderSniping = true
                            end
                        end
                    end
                end

                if bConsiderSniping then
                    --Only get teleport on seraphim if we have no cybran ACU and enemy has a friendly arti count; dont get teleport on either if we are already getting teleport (or have it) on another ACU
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        local tFriendlyACUs = oBrain:GetListOfUnits(categories.COMMAND * categories.CYBRAN + categories.COMMAND * categories.SERAPHIM, true, false)
                        if M28Utilities.IsTableEmpty(tFriendlyACUs) == false then
                            for iFriendlyACU, oFriendlyACU in tFriendlyACUs do
                                if not(oFriendlyACU == oACU) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if other ACUs are planning on getting teleport, ACU owned by brain '..oBrain.Nickname..': oFriendlyACU[refbPlanningToGetTeleport]='..tostring(oFriendlyACU[refbPlanningToGetTeleport] or false)..'; oFriendlyACU[refbACUHasTeleport]='..tostring(oFriendlyACU[refbACUHasTeleport])) end
                                    if oFriendlyACU[refbPlanningToGetTeleport] or oFriendlyACU[refbACUHasTeleport] then
                                        bConsiderSniping = false
                                        break
                                    elseif EntityCategoryContains(categories.CYBRAN, oFriendlyACU.UnitId) and EntityCategoryContains(categories.SERAPHIM, oACU.UnitId) then
                                        bConsiderSniping = false
                                        break
                                    end
                                end
                            end
                        end
                        if not(bConsiderSniping) then break end
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': bConsiderSniping='..tostring(bConsiderSniping)) end
                if bConsiderSniping then
                    --Do we have any viable targets?
                    M28Team.RefreshPotentialTeleSnipeTargets(iTeam)
                    if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to get teleport upgrade, Is table of potentail snipe targets empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoPotentialTeleSnipeTargets]))) end
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoPotentialTeleSnipeTargets]) == false then
                        sUpgradeWanted = GetACUUpgradeWanted(oACU, true, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero)
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': sUpgradeWanted='..(sUpgradeWanted or 'nil')) end
        if sUpgradeWanted then
            oACU[refbPlanningToGetTeleport] = true
            bGivenACUOrder = true
            --Are we under a fixed shield or underwater? If not, and we have a fixed shield that we own, then move to it

            local oClosestFixedShield
            local iClosestFixedShield = 100000
            local bUnderShieldOrWater = false
            local iCurDist, iCurShield, iMaxShield
            function ConsiderShield(oShield)
                if M28UnitInfo.IsUnitValid(oShield) and oShield:GetFractionComplete() == 1 then
                    iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                    if iCurShield > 0 and iCurShield > iMaxShield * 0.5 and iMaxShield >= 12000 and NavUtils.GetLabel(M28Map.refPathingTypeHover, oShield:GetPosition()) == iPlateauOrZero then
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oACU:GetPosition())
                        if iCurDist < iClosestFixedShield then
                            iClosestFixedShield = iCurDist
                            oClosestFixedShield = oShield
                        end
                    end
                end
            end
            if M28UnitInfo.IsUnitUnderwater(oACU) then bUnderShieldOrWater = true

            elseif M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                local tFixedShieldsInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if M28Utilities.IsTableEmpty(tFixedShieldsInLZ) == false then
                    for iShield, oShield in tFixedShieldsInLZ do
                        ConsiderShield(oShield)
                    end
                end
            end
            if not(oClosestFixedShield) then
                local tNearbyShields = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedShield, oACU:GetPosition(), 120, 'Ally')
                if M28Utilities.IsTableEmpty(tNearbyShields) == false then
                    for iShield, oShield in tNearbyShields do
                        ConsiderShield(oShield)
                    end
                end
            end
            if oClosestFixedShield and iClosestFixedShield + 1 < (oClosestFixedShield:GetBlueprint().Defense.Shield.ShieldSize or 0) * 0.5 then
                bUnderShieldOrWater = true
            end

            if bUnderShieldOrWater then
                --Upgrade to telesnipe
                if bDebugMessages == true then LOG(sFunctionRef..': Will get telesnipe upgrade as under shield') end
                M28Orders.IssueTrackedEnhancement(oACU, sUpgradeWanted, false, 'ACUTeleU')
            elseif oClosestFixedShield then
                --Move to the closest shield
                M28Orders.IssueTrackedMove(oACU, oClosestFixedShield:GetPosition(), 5, false, 'ACUTelSh', false)
            else
                if not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) then
                    if bDebugMessages == true then LGO(sFunctionRef..': Will return ACU to core base unless want shield instead') end
                    if not(ConsiderRunningToNearestShield(oACU, tLZOrWZData, tLZOrWZTeamData, iTeam, iPlateauOrZero, iLandOrWaterZone)) then
                        ReturnACUToCoreBase(oACU, tLZOrWZData, tLZOrWZTeamData, aiBrain, iTeam, iPlateauOrZero, iLandOrWaterZone)
                        if bDebugMessages == true then LOG(sFunctionRef..': Going to core base') end
                    end
                else

                    --Upgrade to telesnipe
                    if bDebugMessages == true then LOG(sFunctionRef..': Will get telesnipe upgrade as in core base') end
                    M28Orders.IssueTrackedEnhancement(oACU, sUpgradeWanted, false, 'ACUTeleU')
                end
            end

        else
            if bDebugMessages == true then LOG(sFunctionRef..': Dont want to get upgrade, does ACU already have teleport='..tostring(oACU[refbACUHasTeleport] or false)) end
            if oACU[refbACUHasTeleport] then
                --Are we not in core base? Teleport to core base
                if bDebugMessages == true then LOG(sFunctionRef..': Are we in a core base='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase])) end
                if not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will teleport back to base') end
                    bGivenACUOrder = true
                    if M28Conditions.BaseIsSafeToRetreatTo(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], iTeam) or M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] <= 1 then
                        M28Orders.IssueTrackedTeleport(oACU, tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], 5, true, 'ACUTelB', true)
                    else
                        --Find a safe base
                        local iClosestSafeBaseDist = 100000
                        local tPotentialBase
                        local tTeleportBaseTarget, iCurDist
                        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                            tPotentialBase = M28Map.GetPlayerStartPosition(aiBrain)
                            if tPotentialBase and M28Conditions.BaseIsSafeToRetreatTo(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], iTeam) then
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tPotentialBase)
                                if iCurDist < iClosestSafeBaseDist then
                                    iClosestSafeBaseDist = iCurDist
                                    tTeleportBaseTarget = {tPotentialBase[1], tPotentialBase[2], tPotentialBase[3]}
                                end
                            end
                        end
                        if not(tTeleportBaseTarget) then tTeleportBaseTarget = {tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][1],tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][2],tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][3]} end
                        M28Orders.IssueTrackedTeleport(oACU, tTeleportBaseTarget, 5, true, 'ACUTelC', true)
                    end
                else
                    --Do we have enough health to target
                    if M28UnitInfo.GetUnitHealthPercent(oACU) < 0.95 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to heal up first, health percent='..M28UnitInfo.GetUnitHealthPercent(oACU)) end
                        bGivenACUOrder = false --redundancy
                    else
                        M28Team.RefreshPotentialTeleSnipeTargets(iTeam)
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of telesnipe targets empty after refresh='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoPotentialTeleSnipeTargets]))) end
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoPotentialTeleSnipeTargets]) == false then
                            local oSnipeTarget = GetBestTeleSnipeUnitTarget(oACU, iTeam)
                            if bDebugMessages == true then LOG(sFunctionRef..': oSnipeTarget='..(oSnipeTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oSnipeTarget) or 'nil')..'; Is target valid='..tostring(M28UnitInfo.IsUnitValid(oSnipeTarget))) end
                            if not(M28UnitInfo.IsUnitValid(oSnipeTarget)) then
                                bGivenACUOrder = false --redundancy
                            else
                                local tTeleportTarget = GetBestLocationForTeleSnipeTarget(oACU, oSnipeTarget, iTeam)
                                local bAddToExistingQueue = true
                                if not(oACU:IsUnitState('Teleporting')) and not(oACU:IsUnitState('Upgrading')) then bAddToExistingQueue = false end

                                M28Orders.IssueTrackedTeleport(oACU, tTeleportTarget, 5, bAddToExistingQueue, 'ACUTelA', true)
                                if bDebugMessages == true then LOG(sFunctionRef..': Just tried to give ACU a teleport order') end
                                bGivenACUOrder = true
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bGivenACUOrder
end

function AssistBuildingUpgradeOrStorageConstruction(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)
    --Looks for nearby upgrading mex, under construction mass storage, or factory, if there are any, and assists it, returning true if it finds something to assist
    local sFunctionRef = 'AssistBuildingUpgradeOrStorageConstruction'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Consider assisting experimental if approaching enemy threat and experimental is a land or air experimental

    local oUnitToAssist
    local aiBrain = oACU:GetAIBrain()
    local iTeam = aiBrain.M28Team
    if not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) and (M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.refiEnemyMobileDFThreatNearOurSide] or 0) >= 8000 then
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            local tLandOrAirExperimentals = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryAirNonScout * categories.EXPERIMENTAL, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tLandOrAirExperimentals) == false then
                local iHighestCompletion = 0
                for iUnit, oUnit in tLandOrAirExperimentals do
                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetAIBrain().M28AI and oUnit:GetFractionComplete() < 1 then
                        if oUnit:GetFractionComplete() > iHighestCompletion then
                            iHighestCompletion = oUnit:GetFractionComplete()
                            oUnitToAssist = oUnit
                            if bDebugMessages == true then LOG(sFunctionRef..': Will get ACU to assist experimental under construction, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()) end
                        end
                    end
                end
            end
        end
    end
    if not(oUnitToAssist) and M28Conditions.IsTableOfUnitsStillValid(tLZOrWZTeamData[M28Map.subreftoActiveUpgrades]) then
        local iHighestCompletion = 0
        local iHighestLowPriorityCompletion = 0
        local iCurCompletion
        local oLowPriorityUnit
        local bWantToImproveMassIncome = M28Conditions.HaveLowMass(oACU:GetAIBrain())

        function ConsiderCurUnitPriority(oUnit)
            if oUnit:GetFractionComplete() < 1 then
                iCurCompletion = oUnit:GetFractionComplete()
            else
                iCurCompletion = oUnit:GetWorkProgress()
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to assist unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurCompletion='..iCurCompletion..'; iHighestCompletion='..iHighestCompletion..'; bWantToImproveMassIncome='..tostring(bWantToImproveMassIncome)) end
            if iCurCompletion > iHighestCompletion and (not(bWantToImproveMassIncome) or EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryMassStorage, oUnit.UnitId)) then
                oUnitToAssist = oUnit
                iHighestCompletion = iCurCompletion
            elseif iHighestCompletion == 0 and iCurCompletion > iHighestLowPriorityCompletion then
                iHighestLowPriorityCompletion = iCurCompletion
                oLowPriorityUnit = oUnit
            end
        end

        for iUnit, oUnit in tLZOrWZTeamData[M28Map.subreftoActiveUpgrades] do
            ConsiderCurUnitPriority(oUnit)
        end
        local tStorageInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryMassStorage + M28UnitInfo.refCategoryMassFab, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tStorageInZone) == false then
            for iUnit, oUnit in tStorageInZone do
                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() < 1 then
                    ConsiderCurUnitPriority(oUnit)
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': end of code, oUnitToAssist='..(oUnitToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitToAssist) or 'nil')..'; aiBrain='..oACU:GetAIBrain().Nickname..'; Time='..GetGameTimeSeconds()) end
    if oUnitToAssist then
        if oUnitToAssist:GetFractionComplete() < 1 then
            M28Orders.IssueTrackedRepair(oACU, oUnitToAssist, false, 'ACUAstR', false)
        else
            M28Orders.IssueTrackedGuard(oACU, oUnitToAssist, false, 'ACUAstG', false)
        end
        return true
    end
    return false
end

function RunFromEnemyTeleport(oACU, iTeam, tLZOrWZData)
    --Returns true if we have given an order to run from a nearby enemy teleport
    local sFunctionRef = 'RunFromEnemyTeleport'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftRecentEnemyTeleportDetails]) == false then
        --Are any teleport targets within 60 of us? If so then run in the opposite direction unless we are underwater or have a powerufl gun upgrade
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if we need to run from enemy teleport') end
        if not(M28UnitInfo.IsUnitUnderwater(oACU)) and (oACU[refiUpgradeCount] <= 2 or not(oACU:HasEnhancement('MicrowaveLaserGenerator') or oACU:HasEnhancement('BlastAttack'))) then
            local iClosestTeleportDist = 50
            local iCurTeleportDist
            local tClosestTeleport
            local oNearestTeleportUnit
            local iCurTeleportUnitDist
            local iNearestTeleportUnitDist = 1000
            for iEntry, tTeleportData in M28Team.tTeamData[iTeam][M28Team.reftRecentEnemyTeleportDetails] do
                if M28UnitInfo.IsUnitValid(tTeleportData[M28Team.subrefoTeleportUnit]) and (tTeleportData[M28Team.subrefoTeleportUnit][M28UnitInfo.refiDFRange] or 0) > 0 then
                    iCurTeleportDist = M28Utilities.GetDistanceBetweenPositions(tTeleportData[M28Team.subreftTeleportTarget], oACU:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': iCurTeleportDist='..iCurTeleportDist..'; iClosestTeleportDist threshold='..iClosestTeleportDist) end
                    if iCurTeleportDist < iClosestTeleportDist then
                        iClosestTeleportDist = iCurTeleportDist
                        tClosestTeleport = {tTeleportData[M28Team.subreftTeleportTarget][1], tTeleportData[M28Team.subreftTeleportTarget][2], tTeleportData[M28Team.subreftTeleportTarget][3]}
                    end
                    iCurTeleportUnitDist = M28Utilities.GetDistanceBetweenPositions(tTeleportData[M28Team.subrefoTeleportUnit]:GetPosition(), oACU:GetPosition())
                    if iCurTeleportUnitDist < iNearestTeleportUnitDist then
                        iNearestTeleportUnitDist = iCurTeleportUnitDist
                        oNearestTeleportUnit = tTeleportData[M28Team.subrefoTeleportUnit]
                    end
                end
            end

            --Cover off the following scenarios:
            --1 - enemy has teleported and is now moving closer to us
            --2 - enemy teleported, and then teleports again (while in range of us) to just infront of where we would be trying to run (so we run back towards them/into their range)
            local tRunToLocation
            if bDebugMessages == true then LOG(sFunctionRef..': tClosestTeleport='..repru(tClosestTeleport)..'; oNearestTeleportUnit='..(oNearestTeleportUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestTeleportUnit) or 'nil')..'; iNearestTeleportUnitDist='..iNearestTeleportUnitDist..'; oNearestTeleportUnit[M28UnitInfo.refiDFRange]='..(oNearestTeleportUnit[M28UnitInfo.refiDFRange] or 'nil')) end
            local iAngleToRun
            if oNearestTeleportUnit and (iNearestTeleportUnitDist <= oNearestTeleportUnit[M28UnitInfo.refiDFRange] + 3 or iNearestTeleportUnitDist <= 50) then
                --Want to run from nearest teleport unit; check if also want to run from a teleport location
                if bDebugMessages == true then LOG(sFunctionRef..': Unit state of oNearestTeleportUnit='..M28UnitInfo.GetUnitState(oNearestTeleportUnit)) end
                if oNearestTeleportUnit:IsUnitState('Teleporting') and tClosestTeleport then
                    iAngleToRun = (M28Utilities.GetAngleFromAToB(oNearestTeleportUnit:GetPosition(), oACU:GetPosition()) + M28Utilities.GetAngleFromAToB(tClosestTeleport, oACU:GetPosition())) / 2
                else
                    iAngleToRun = M28Utilities.GetAngleFromAToB(oNearestTeleportUnit:GetPosition(), oACU:GetPosition())
                end
            elseif tClosestTeleport then
                iAngleToRun = M28Utilities.GetAngleFromAToB(tClosestTeleport, oACU:GetPosition())
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iANgleToRun='..(iAngleToRun or 'nil')) end
            if iAngleToRun then
                local iPlateauWanted = NavUtils.GetLabel(M28Map.refPathingTypeHover, oACU:GetPosition())
                for iDist = 30, 5, -5 do
                    tRunToLocation = M28Utilities.MoveInDirection(oACU:GetPosition(), iAngleToRun, 30, true)
                    if M28Utilities.IsTableEmpty(tRunToLocation) == false and NavUtils.GetLabel(M28Map.refPathingTypeHover, tRunToLocation) == iPlateauWanted then
                        break
                    end
                end
                if M28Utilities.IsTableEmpty(tRunToLocation) == false then
                    --IssueTrackedMove(oUnit, tOrderPosition, iDistanceToReissueOrder, bAddToExistingQueue, sOptionalOrderDesc, bOverrideMicroOrder)
                    M28Orders.IssueTrackedMove(oACU, tRunToLocation, 1, false, 'RunFrTel', true)
                    --Make sure we dont dodge shots or do something that causes us to stop
                    M28Micro.TrackTemporaryUnitMicro(oACU, 1, nil, false)
                    if bDebugMessages == true then LOG(sFunctionRef..': Given ACU order to move away from enemy teleport, iAngleToRun='..iAngleToRun..'; tRunToLocation='..repru(tRunToLocation)) end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetACUOrder(aiBrain, oACU)
    local sFunctionRef = 'GetACUOrder'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    

    if oACU[refbUseACUAggressively] then
        oACU[refbUseACUAggressively] = DoWeStillWantToBeAggressiveWithACU(oACU)
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oACU.Nickname='..aiBrain.Nickname..'; oACU.M28Active='..tostring(oACU.M28Active or false)..'; Brain type='..aiBrain.BrainType..'; bDontConsiderCombinedArmy='..tostring(M28Orders.bDontConsiderCombinedArmy)..'; Special micro active for ACU='..tostring(oACU[M28UnitInfo.refbSpecialMicroActive] or false)..'; ACU upgrade count='..(oACU[refiUpgradeCount] or 'nil')..'; Time='..GetGameTimeSeconds()) end
    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oACU:GetPosition())

    local tLZOrWZData
    local tLZOrWZTeamData
    local iTeam = oACU:GetAIBrain().M28Team

    if iPlateauOrZero == 0 then
        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
    else
        tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
    end

    tLZOrWZTeamData[M28Map.refbACUInTrouble] = false --will set to true later (if want ACU to run)
    oACU[refbACUAvailableToDoSnipeAttack] = false --will set to true later

    --local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oACU:GetPosition(), true, oACU)
    --local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    --local tLZTeamData = tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
    UpdateACULandOrWaterZoneAssignment(oACU, iPlateauOrZero, iLandOrWaterZone, tLZOrWZTeamData)

    --Refresh ACU last orders as some functions will check last order to decide if it was given an order
    M28Orders.UpdateRecordedOrders(oACU)

    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code for brain '..oACU:GetAIBrain().Nickname..', ACU='..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..'; time='..GetGameTimeSeconds()..'; oACU[refbDoingInitialBuildOrder]='..tostring(oACU[refbDoingInitialBuildOrder])..'; ACU unit state='..M28UnitInfo.GetUnitState(oACU)..'; iPlateau='..(iPlateauOrZero or 'nil')..'; iLandZone='..(iLandOrWaterZone or 'nil')..'; Can ACU use overcharge='..tostring(M28Conditions.CanUnitUseOvercharge(oACU:GetAIBrain(), oACU))..'; ACU position='..repru(oACU:GetPosition())..'; ACU Orders (before updates)='..reprs(oACU[M28Orders.reftiLastOrders])..'; Is special micro active='..tostring(oACU[M28UnitInfo.refbSpecialMicroActive] or false)..'; Time to stop micro='..(oACU[M28UnitInfo.refiGameTimeToResetMicroActive] or 'nil')..'; Brian nickname='..aiBrain.Nickname..'; reftSpecialObjectiveMoveLocation='..repru(oACU[reftSpecialObjectiveMoveLocation])..'; Enemy combat threat='..(tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; Is table of unbuilt mexes empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefMexUnbuiltLocations]))..'; refbFocusOnT1Spam='..tostring(M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam])..'; oACU[M28UnitInfo.refbUsingDefaultWeaponPriority]='..tostring(oACU[M28UnitInfo.refbUsingDefaultWeaponPriority] or false)..'; Is table of snipe targets empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets]))) end

    --Check weapon priority
    if not(oACU[M28UnitInfo.refbUsingDefaultWeaponPriority]) then
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets]) then
            M28UnitInfo.SetUnitWeaponTargetPriorities(oACU, M28UnitInfo.refWeaponPriorityACU, false)
            oACU[M28UnitInfo.refbUsingDefaultWeaponPriority] = true
        end
    elseif M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets]) == false then
        --Double-check if have nearby snipe target that is enemy ACU since we are using default priority
        local iClosestSnipeTarget = 10000
        local iCurSnipeTargetDist
        local oClosestSnipeTarget
        for iSnipeTarget, oSnipeTarget in M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets] do
            if M28UnitInfo.IsUnitValid(oSnipeTarget) then
                iCurSnipeTargetDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oSnipeTarget:GetPosition())
                if iCurSnipeTargetDist < iClosestSnipeTarget then
                    iClosestSnipeTarget = iCurSnipeTargetDist
                    oClosestSnipeTarget = oSnipeTarget
                end
            end
        end

        if iClosestSnipeTarget <= oACU[M28UnitInfo.refiCombatRange] + 1 then
            local iTargetHealthPercent = M28UnitInfo.GetUnitHealthPercent(oClosestSnipeTarget)
            if iTargetHealthPercent <= 0.5 or (iTargetHealthPercent <= M28UnitInfo.GetUnitHealthPercent(oACU) - 0.2) then
                M28UnitInfo.SetUnitWeaponTargetPriorities(oACU, M28UnitInfo.refWeaponPriorityACUSnipe, false)
                oACU[M28UnitInfo.refbUsingDefaultWeaponPriority] = false
            end
        end
    end

    --Check for mobile shields
    CheckForNearbyMobileShieldToRequisition(oACU, tLZOrWZData, tLZOrWZTeamData, iTeam, iPlateauOrZero)

    --Is the ACU busy with something?
    if oACU:IsUnitState('Upgrading') then
        --Do nothing unless in a very dangerous situation
        if bDebugMessages == true then LOG(sFunctionRef..': ACU upgrading so will only cancel if in dangerous situation. is ACU doing initial BO='..tostring(oACU[refbDoingInitialBuildOrder])) end
        if not(oACU[refbDoingInitialBuildOrder]) then
            if bDebugMessages == true then LOG(sFunctionRef..': ACU is upgrading') end
            local bCanceledUpgrade = false
            if DoesACUWantToReturnToCoreBase(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                if bDebugMessages == true then LOG(sFunctionRef..': ACU wants to run to core base, considering if need emergency support and, if ACU health is low, will consider cancelling, ACU health%='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; use acu aggressively='..tostring(oACU[refbUseACUAggressively] or false)) end
                ConsiderIfACUNeedsEmergencySupport(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)
                --Are we in a different LZ to core base, and have enemy threat or are on <60% health with less health than our upgrade progress?
                if not(tLZOrWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) and (not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) or (M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.99 and tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZData[M28Map.subrefMidpoint]) >= 35 and DoesACUWantToRun(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU))) then
                    local iACUHealthPercent = M28UnitInfo.GetUnitHealthPercent(oACU)
                    if (iACUHealthPercent <= 0.99 and ((1 - iACUHealthPercent) + 0.1 > oACU:GetWorkProgress()) or M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) then
                        --Do we no longer consider this location safe?
                        if bDebugMessages == true then LOG(sFunctionRef..': ACU health relatively low, iACUHealthPercent='..iACUHealthPercent..'; Work progress='..oACU:GetWorkProgress()..'; woudl it be safe to start an ugprade here='..tostring(M28Conditions.SafeToUpgradeUnit(oACU))) end
                        if not(M28Conditions.SafeToUpgradeUnit(oACU)) then
                            --Cancel upgrade
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to cancel ACU upgrade') end
                            M28Orders.IssueTrackedMove(oACU, M28Map.GetPlayerStartPosition(oACU:GetAIBrain()), 5, false, 'CURun')
                            bCanceledUpgrade = true
                        end
                    end
                end
                if not(bCanceledUpgrade) and not(M28Conditions.SafeToUpgradeUnit(oACU)) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false and oACU:GetWorkProgress() <= 0.7 then
                    local iClosestExp = 100
                    local oClosestExp
                    local iCurDist
                    for iExp, oExp in M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
                        if not(oExp.Dead) and oExp[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] == iPlateauOrZero then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oExp:GetPosition())
                            if iCurDist < iClosestExp then
                                oClosestExp = oExp
                                iClosestExp = iCurDist
                            end
                        end
                    end
                    if oClosestExp then
                        --Just return to base, as normal 'no-upgrade' logic will kick in next cycle
                        M28Orders.IssueTrackedMove(oACU, M28Map.GetPlayerStartPosition(oACU:GetAIBrain()), 5, false, 'CUExRun')
                        if bDebugMessages == true then LOG(sFunctionRef..': will cancel upgrade and reun to base') end
                        bCanceledUpgrade = true
                    end
                end
            elseif bDebugMessages == true then LOG(sFunctionRef..': Dont want to return to base so wont cancel upgrade except in a few niche cases')
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bCanceledUpgrade='..tostring(bCanceledUpgrade or false)) end
            if not(bCanceledUpgrade) and tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and not(tLZOrWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) and M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.7 and tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZData[M28Map.subrefMidpoint]) >= 35 and DoesACUWantToRun(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                local iACUHealthPercent = M28UnitInfo.GetUnitHealthPercent(oACU)
                if iACUHealthPercent < 0.6 and (1 - iACUHealthPercent) + 0.1 > oACU:GetWorkProgress() then
                    --Do we no longer consider this location safe?
                    if bDebugMessages == true then LOG(sFunctionRef..': ACU health relatively low, iACUHealthPercent='..iACUHealthPercent..'; Work progress='..oACU:GetWorkProgress()..'; woudl it be safe to start an ugprade here='..tostring(M28Conditions.SafeToUpgradeUnit(oACU))) end
                    if not(M28Conditions.SafeToUpgradeUnit(oACU)) and M28Utilities.GetDistanceBetweenPositions(M28Map.GetPlayerStartPosition(oACU:GetAIBrain()), oACU:GetPosition()) >= 35 then
                        --Cancel upgrade
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to cancel ACU upgrade') end
                        M28Orders.IssueTrackedMove(oACU, M28Map.GetPlayerStartPosition(oACU:GetAIBrain()), 5, false, 'CURun')
                        bCanceledUpgrade = true
                    end
                end
            elseif bDebugMessages == true then LOG(sFunctionRef..': ACU doesnt want to return to core base')
            end
            if bCanceledUpgrade then
                oACU[M28UnitInfo.refiTimeLastCanceledUpgrade] = GetGameTimeSeconds()
                oACU[M28UnitInfo.refiDistToEnemyBaseWhenLastCanceledUpgrade] = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftClosestEnemyBase])
            end

        end
    elseif oACU:IsUnitState('Teleporting') then
        --Do nothing
        if bDebugMessages == true then LOG(sFunctionRef..': ACU is teleporting') end
    elseif M28Map.bIsCampaignMap and (oACU:IsUnitState('TransportLoading') or oACU:IsUnitState('Attached')) then
        --Liekly campaign wants to do something special with ACU
        if bDebugMessages == true then LOG(sFunctionRef..': campaign and ACU is loading or attached') end
    elseif GiveOverchargeOrderIfRelevant(tLZOrWZData, tLZOrWZTeamData, oACU, iPlateauOrZero, iLandOrWaterZone) then
        --when an overcharge shot is fired it triggers this code to run again so no need to queue things up afterwards
        if bDebugMessages == true then LOG(sFunctionRef..': Have just givne overcharge order') end
    elseif oACU[M28UnitInfo.refbSpecialMicroActive] and not(oACU[refbACUSnipeModeActive]) then
        --Do nothing unless are in range of PD in which case retreat despite the special micro
        if bDebugMessages == true then LOG(sFunctionRef..': ACU has special micro active, Time remaining='..(oACU[M28UnitInfo.refiGameTimeToResetMicroActive] or 0) - GetGameTimeSeconds()) end
        if RunFromEnemyTeleport(oACU, iTeam, tLZOrWZData) then
            if bDebugMessages == true then LOG(sFunctionRef..': Are running from a nearby enemy teleport attempt') end
        elseif DoesACUWantToRun(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
            if bDebugMessages == true then LOG(sFunctionRef..': have flagged that acu wants to run, iPlateauOrZero='..iPlateauOrZero..'; Enemy DF structure threat='..(tLZOrWZTeamData[M28Map.subrefThreatEnemyDFStructures] or 0)..'; ACU health%='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; Is table of enemy units empty='..tostring( M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]))) end
            ConsiderIfACUNeedsEmergencySupport(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)
            if iPlateauOrZero > 0 and M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.8 then
                local oNearestPD
                local iClosestDistUntilInRange = 10000
                local iCurDist
                function ConsiderNearestPDInZone(tLZTeamData)
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                        local tEnemyPD = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD, tLZTeamData[M28Map.subrefTEnemyUnits])
                        if M28Utilities.IsTableEmpty(tEnemyPD) == false then
                            for iUnit, oUnit in tEnemyPD do
                                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0)
                                    if iCurDist < iClosestDistUntilInRange then
                                        iClosestDistUntilInRange = iCurDist
                                        oNearestPD = oUnit
                                        if iClosestDistUntilInRange < 0 then break end
                                    end
                                end
                            end
                        end
                    end
                end
                ConsiderNearestPDInZone(tLZOrWZTeamData)
                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZOrWZData[M28Map.subrefLZAdjacentLandZones] do
                        local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                        ConsiderNearestPDInZone(tAdjLZTeamData)
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..'; Considering ignoring special micro, iClosestDistUntilInRange='..iClosestDistUntilInRange..'; oNearestPD='..(oNearestPD.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestPD) or 'nil')) end
                if iClosestDistUntilInRange <= 1 and oNearestPD then
                    --We want to run
                    local tRallyPoint = M28Land.GetNearestLandRallyPoint(tLZOrWZData, iTeam, iPlateauOrZero, iLandOrWaterZone, 2, true)
                    if M28Utilities.IsTableEmpty(tRallyPoint) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': Angle to rally point tRallyPoint='..M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tRallyPoint)..'; Angle to nearest enemy PD='..M28Utilities.GetAngleFromAToB(oACU:GetPosition(), oNearestPD:GetPosition())) end
                        if M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tRallyPoint), M28Utilities.GetAngleFromAToB(oACU:GetPosition(), oNearestPD:GetPosition())) > 90 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will consider running to shield or rally point') end
                            if not(ConsiderRunningToNearestShield(oACU, tLZOrWZData, tLZOrWZTeamData, iTeam, iPlateauOrZero, iLandOrWaterZone)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will override micro logic and retreat') end
                                M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'ACUIgnMRetr', true)
                            end
                        end
                    end
                end
            end
        end
        if GetGameTimeSeconds() > (oACU[M28UnitInfo.refiGameTimeToResetMicroActive] or 0) then
            oACU[M28UnitInfo.refbSpecialMicroActive] = false
        end
        --Low cost and build time upgrades - ensure we always have the desired upgrades
    else
        oACU[refbOnlyOverchargeHighValueTargets] = oACU[refbACUSnipeModeActive] --will also set to true if we are trying to run down an enemy ACU
        oACU[refoShieldRallyTarget] = nil
        oACU[refbACUHasBeenGivenABuildOrderRecently] = false
        local bProceedWithLogic = true
        if oACU[refbDoingInitialBuildOrder] then
            if not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and GetGameTimeSeconds() >= 20 and DoesACUWantToReturnToCoreBase(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) and (not(M28Map.bIsCampaignMap) or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory) > 0) then
                ConsiderIfACUNeedsEmergencySupport(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)
                if bDebugMessages == true then LOG(sFunctionRef..': Want to return to core base (or core zone with shield)') end
                if not(ConsiderRunningToNearestShield(oACU, tLZOrWZData, tLZOrWZTeamData, iTeam, iPlateauOrZero, iLandOrWaterZone)) then
                    ReturnACUToCoreBase(oACU, tLZOrWZData, tLZOrWZTeamData, aiBrain, iTeam, iPlateauOrZero, iLandOrWaterZone)
                    if bDebugMessages == true then LOG(sFunctionRef..': Will go to core base') end
                end
                bProceedWithLogic = false

            elseif M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) then
                bProceedWithLogic = false
                GetACUEarlyGameOrders(aiBrain, oACU) --Avoid some scenarios where ACU might get stuck in 'run to core zone' mode
                if bDebugMessages == true then LOG(sFunctionRef..': No enemies in LZ and ACU doing initial order so referred to early game order logic') end
            elseif (iLandOrWaterZone or 0) == 0 then
                bProceedWithLogic = false
                GetACUEarlyGameOrders(aiBrain, oACU) --backup which should ahve ACU move if it doesnt seem to be on a land or water zone
                if bDebugMessages == true then LOG(sFunctionRef..': ACU not in land zone and is doing initial order so referred to early game order logic') end
            elseif (iLandOrWaterZone or 0) > 0 and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                --Are enemies in this zone, decide if we want to attack them - get closest enemy to ACU, and ignore any structures that are more than 10 from being in range of ACU
                --Exception - we have no factory in this zone, and the enemy isn't a combat unit
                local iClosestDist = 100000
                local iClosestUntilInRange = 100000
                local iClosestMobileThreatUntilInRange = 100000
                local iCurDist, iCurDistUntilInRange, iCurRange
                local oClosestEnemyByDist
                local oClosestEnemyUntilInRange
                local oClosestMobileThreatUntilInRange
                local bEnemyInACURange = false
                for iUnit, oUnit in tLZOrWZTeamData[M28Map.subrefTEnemyUnits] do
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())
                    iCurRange = math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0))
                    if iCurDist < iClosestDist then
                        iClosestDist = iCurDist
                        oClosestEnemyByDist = oUnit
                    end
                    iCurDistUntilInRange = iCurDist - iCurRange
                    if iCurDistUntilInRange < iClosestUntilInRange then
                        iClosestUntilInRange = iCurDistUntilInRange
                        oClosestEnemyUntilInRange = oUnit
                    end
                    if iCurDistUntilInRange < iClosestMobileThreatUntilInRange and iCurRange > 0 and EntityCategoryContains(categories.MOBILE, oUnit.UnitId) and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - M28UnitInfo.refCategoryCombatScout, oUnit.UnitId)) then
                        iClosestMobileThreatUntilInRange = iCurDistUntilInRange
                        oClosestMobileThreatUntilInRange = oUnit
                    end
                    if iCurDist <= (oACU[M28UnitInfo.refiDFRange] or 0) then bEnemyInACURange = true end
                end
                local iOurRange = (oACU[M28UnitInfo.refiDFRange] or 0)
                local bCampaignRetreatInstead = false
                if M28Map.bIsCampaignMap then
                    --Consider retreating to build, or just building, in some cases
                    local tFriendlyFactories = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryFactory, false, true)
                    local oNearestFactory
                    local iCurDist
                    local iClosestDist = 10000
                    if M28Utilities.IsTableEmpty(tFriendlyFactories) == false then
                        for iUnit, oUnit in tFriendlyFactories do
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oNearestFactory = oUnit
                            end
                        end
                    end
                    if oNearestFactory and iClosestDist >= 10 and DoesACUWantToRun(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                        M28Orders.IssueTrackedMove(oACU, oNearestFactory:GetPosition(), 3, false, 'ACUCampFacR', false)
                        bCampaignRetreatInstead = true
                        bProceedWithLogic = false
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to go with early game orders despite enemy having units in this zone, subrefTThreatEnemyCombatTotal='..(tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; iOurRange='..iOurRange..'; iClosestUntilInRange='..iClosestUntilInRange..'; iClosestMobileThreatUntilInRange='..iClosestMobileThreatUntilInRange..'; bCampaignRetreatInstead='..tostring(bCampaignRetreatInstead)) end
                --Ignore nearby enemy if will be a while before in our range, with the threshold depending on if it is is a mobile threat or not
                if not(bCampaignRetreatInstead) then
                    local tFactoriesOwned = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryFactory, false, true)
                    local bHaveNoFactory = true
                    if M28Utilities.IsTableEmpty(tFactoriesOwned) == false then
                        for iFactory, oFactory in tFactoriesOwned do
                            if oFactory:GetFractionComplete() == 1 then bHaveNoFactory = false break end
                        end
                    end

                    if ((iClosestMobileThreatUntilInRange > 25 or (bHaveNoFactory and (iClosestMobileThreatUntilInRange > 20 or (M28Map.bIsCampaignMap and iClosestMobileThreatUntilInRange >= 10)))) and ((iClosestUntilInRange > (iOurRange + 15) and iCurDistUntilInRange > 15) or (iCurDistUntilInRange >= 10 and M28Map.bIsCampaignMap))) or (bHaveNoFactory and not(bEnemyInACURange) and (oACU:IsUnitState('Building') or oACU:IsUnitState('Repairing') or oACU:IsUnitState('Capturing')) and oACU:GetWorkProgress() >= 0.85) then
                        bProceedWithLogic = false
                        GetACUEarlyGameOrders(aiBrain, oACU) --Avoid some scenarios where ACU might get stuck in 'run to core zone' mode
                    elseif iClosestMobileThreatUntilInRange > 25 or (aiBrain[M28Economy.refiBrainBuildRateMultiplier] >= 3 and iClosestMobileThreatUntilInRange > 1) or aiBrain[M28Economy.refiBrainBuildRateMultiplier] >= 6 then
                        if bHaveNoFactory then
                            bProceedWithLogic = false
                            GetACUEarlyGameOrders(aiBrain, oACU) --Avoid some scenarios where ACU might get stuck in 'run to core zone' mode
                        else
                            local bCompleteCurrentConstruction = false
                            if oACU:IsUnitState('Building') or oACU:IsUnitState('Repairing') or oACU:IsUnitState('Capturing') then
                                local oFocusUnit = oACU:GetFocusUnit()
                                if oFocusUnit and oACU:GetWorkProgress() >= 0.8 then
                                    bCompleteCurrentConstruction = true
                                    bProceedWithLogic = false
                                    if oACU:GetWorkProgress() >= 0.95 then
                                        --Complete construction
                                    elseif AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, (oACU[M28UnitInfo.refiDFRange] or 0) + 3) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy almost in our range so will attack even though almost complete') end
                                    else
                                        --Complete construction
                                    end
                                end
                            end
                            if not(bCompleteCurrentConstruction) then
                                if bDebugMessages == true then LOG(sFunctionRef..': About to consider attacking nearest enemy ACU, iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')) end
                                if AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, 35) then
                                    bProceedWithLogic = false
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have enemies fairly close in this zone and have land fac so will attack') end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have a facotry, but nearby enemies arent close enough to attack with ACU using 45 distane threshold, will proceed with non-early game logic temporarily unless we are building') end
                                    if oACU:IsUnitState('Building') or oACU:IsUnitState('Repairing') or oACU:IsUnitState('Capturing') then
                                        bProceedWithLogic = false
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': bCompleteCurrentConstruction (true if enemy in our range and we are attacking as well)='..tostring(bCompleteCurrentConstruction)..'; bProceedWithLogic='..tostring(bProceedWithLogic)) end
                        end
                    elseif AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, 45) then
                        bProceedWithLogic = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Have enemies close in this zone so will attack') end
                    end
                end
            end
            --Override to doing build order - clear off if have had 1m and have access to tech 3
            if oACU[refbDoingInitialBuildOrder] and GetGameTimeSeconds() >= 60 and aiBrain[M28Economy.refiOurHighestFactoryTechLevel] >= 3 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 15 and aiBrain[M28Economy.refiGrossMassBaseIncome] >= 1.5 then
                oACU[refbDoingInitialBuildOrder] = false
                if bDebugMessages == true then LOG(sFunctionRef..': Clearing the initial build order flag for ACU earlier than normal as we already have tech 3') end
            end
            if not(oACU[refbDoingInitialBuildOrder]) then bProceedWithLogic = true end
        elseif oACU[reftSpecialObjectiveMoveLocation] then
            M28Orders.IssueTrackedMove(oACU, oACU[reftSpecialObjectiveMoveLocation], 3, false, 'ACUObj', false)
            bProceedWithLogic = false
            --Move away from a teleport
        elseif RunFromEnemyTeleport(oACU, iTeam, tLZOrWZData) then
            bProceedWithLogic = false
        end
        if bDebugMessages == true then LOG(sFunctionRef..': oACU[refbDoingInitialBuildOrder]='..tostring(oACU[refbDoingInitialBuildOrder] or false)..'; bProceedWithLogic='..tostring(bProceedWithLogic or false)..'; Is table of enemy units for this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]))) end
        if bProceedWithLogic and oACU[refiUpgradeCount] >= 3 and not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and not(oACU[M28UnitInfo.refbSpecialMicroActive]) and oACU[reftPreferredUpgrades][1] and oACU:GetBlueprint()[oACU[reftPreferredUpgrades][1]].BuildCostMass <= 10 and not(oACU:IsUnitState('Upgrading')) then
            if bDebugMessages == true then LOG(sFunctionRef..': Havent got all preferred upgrades') end
            --Are there enemies in the same LZ as the ACU? If so then consider action for these
            local sUpgradeWanted = GetACUUpgradeWanted(oACU, false, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero)
            if sUpgradeWanted then
                if M28Conditions.SafeToUpgradeUnit(oACU) then
                    if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastIssuedACUEnhancementOrder] or -100) > 1.5 or oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] == sUpgradeWanted then
                        M28Orders.IssueTrackedEnhancement(oACU, sUpgradeWanted, false, 'ACULCUpr')
                        bProceedWithLogic = false
                        if bDebugMessages == true then LOG(sFunctionRef..': sUpgradeWanted='..sUpgradeWanted..'; will proceed with getting it due to its low cost') end
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': We want to get upgrade but it isnt safe, so return to base') end
                    ReturnACUToCoreBase(oACU, tLZOrWZData, tLZOrWZTeamData, aiBrain, iTeam, iPlateauOrZero, iLandOrWaterZone)
                    bProceedWithLogic = false
                end
            end
        end
        if bProceedWithLogic then
            --Special case - rebuilding destroyed base (relevant for teamgame) - if ACU at core base, and has no factories, then build a factory
            --Cant just use factory count in case we have plateaus/islands that have factories on them
            if bDebugMessages == true then LOG(sFunctionRef..': Considerinb brain '..aiBrain.Nickname..' at time '..GetGameTimeSeconds()..'; Current factories='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory)..'; In core LZ='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase])..'; Enemies in this LZ='..tostring(tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])..'; aiBrain[M28Economy.refiOurHighestAirFactoryTech]='..(aiBrain[M28Economy.refiOurHighestAirFactoryTech] or 'nil')..'; brain mass %='..aiBrain:GetEconomyStoredRatio('MASS')..'; Brain energy%='..aiBrain:GetEconomyStoredRatio('ENERGY')..'; Gross energy='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; gross mass='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]='..tostring((tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or false))..'; aiBrain[M28Economy.refiOurHighestLandFactoryTech]='..(aiBrain[M28Economy.refiOurHighestLandFactoryTech] or 'nil')..'; aiBrain[M28Economy.refiNetMassBaseIncome]='..aiBrain[M28Economy.refiNetMassBaseIncome]..'; Energy % stored='..aiBrain:GetEconomyStoredRatio('ENERGY')..'; LZ S value='..(tLZOrWZTeamData[M28Map.subrefLZSValue] or 'nil')..'; Time last built at facotry based on refiTimeLastBuiltAtFactory='..GetGameTimeSeconds() - (tLZOrWZTeamData[M28Map.refiTimeLastBuiltAtFactory] or 0)) end
            if (iPlateauOrZero > 0 and not(tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and (tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or not(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]))) and (M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) or not(DoesACUWantToRun(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU))) then
                --Consider getting another factory if either have none of a particular type, or we are close to overflowing
                local bWantAnotherFactory
                local iFactoryCategoryToGet = M28UnitInfo.refCategoryLandFactory
                local iFactoryEngineerAction = M28Engineer.refActionBuildLandFactory
                if aiBrain[M28Economy.refiOurHighestLandFactoryTech] == 0 or (aiBrain[M28Economy.refiOurHighestAirFactoryTech] == 0 and (aiBrain[M28Economy.refiGrossMassBaseIncome] >= 6 * aiBrain[M28Economy.refiBrainBuildRateMultiplier] or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMex - categories.TECH1) >= 2)) or (not(tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and aiBrain:GetEconomyStoredRatio('MASS') >= 0.8 and (aiBrain[M28Economy.refiGrossEnergyBaseIncome] > 150 or (aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.99 and aiBrain[M28Economy.refiNetEnergyBaseIncome] > 0)) and (aiBrain[M28Economy.refiGrossMassBaseIncome] > 2 or aiBrain[M28Economy.refiNetMassBaseIncome] > 0) and aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.95) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Do we have factories of any type in this LZ? Is table empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))..'; aiBrain[M28Economy.refiOurHighestLandFactoryTech]='..aiBrain[M28Economy.refiOurHighestLandFactoryTech]) end

                    if aiBrain[M28Economy.refiOurHighestLandFactoryTech] == 0 then bWantAnotherFactory = true
                        --elseif M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) then bWantAnotherFactory = true
                    elseif M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                        local iLandFacHQCount = 0
                        local iAirFacHQCount = 0
                        --local bHaveHQFactoriesWeOwnInZone = false

                        local tFactoriesInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory - categories.SUPPORTFACTORY, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])

                        if M28Utilities.IsTableEmpty(tFactoriesInLZ) == false then
                            for iFactory, oFactory in tFactoriesInLZ do
                                if oFactory:GetFractionComplete() >= 1 then
                                    if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oFactory.UnitId) then iLandFacHQCount = iLandFacHQCount + 1
                                    elseif EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oFactory.UnitId) then iAirFacHQCount = iAirFacHQCount + 1
                                    end
                                    --if oFactory:GetAIBrain() == aiBrain then bHaveHQFactoriesWeOwnInZone = true
                                end
                            end
                        end
                        if iLandFacHQCount == 0 then
                            bWantAnotherFactory = true
                        elseif iAirFacHQCount == 0 then
                            bWantAnotherFactory = true
                            iFactoryCategoryToGet = M28UnitInfo.refCategoryAirFactory
                            iFactoryEngineerAction = M28Engineer.refActionBuildAirFactory
                        elseif M28Conditions.WantMoreFactories(iTeam, iPlateauOrZero, iLandOrWaterZone) then
                            bWantAnotherFactory = true
                            if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZOrWZData, tLZOrWZTeamData, aiBrain) then
                                iFactoryCategoryToGet = M28UnitInfo.refCategoryAirFactory
                                iFactoryEngineerAction = M28Engineer.refActionBuildAirFactory
                            end
                        else
                            bWantAnotherFactory = false
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iLandFacHQCount='..iLandFacHQCount..'; iAirFacHQCount='..iAirFacHQCount..'; iFactoryEngineerAction='..(iFactoryEngineerAction or 'nil')) end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Do we want another factory='..tostring(bWantAnotherFactory)..'; want more factories condition result='..tostring(M28Conditions.WantMoreFactories(iTeam, iPlateauOrZero, iLandOrWaterZone))..'; iFactoryEngineerAction='..(iFactoryEngineerAction or 'nil')) end
                if bWantAnotherFactory then
                    bProceedWithLogic = false
                    ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, iFactoryCategoryToGet, iFactoryEngineerAction)
                    oACU[refbDoingInitialBuildOrder] = true --reset flag so we get some mexes and pgens

                    if bDebugMessages == true then LOG(sFunctionRef..': WIll try and rebuild base by building a factory') end
                    if not(M28Conditions.DoesACUHaveValidOrder(oACU)) and (M28Orders.bDontConsiderCombinedArmy or oACU.M28Active) then
                        --Try building land if we failed to build air, and vice versa, provided we have decent power, and we lack any factories of the other type, and we want more factories
                        local bWantMoreFactories = M28Conditions.WantMoreFactories(iTeam, iPlateauOrZero, iLandOrWaterZone)
                        if bDebugMessages == true then LOG(sFunctionRef..': We dont have a valid order, bWantMoreFactories='..tostring(bWantMoreFactories)..'; Energy stored ratio='..aiBrain:GetEconomyStoredRatio('ENERGY')) end
                        if bWantMoreFactories and aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.95 then
                            if iFactoryEngineerAction == M28Engineer.refActionBuildLandFactory then
                                iFactoryEngineerAction = M28Engineer.refActionBuildAirFactory
                                iFactoryCategoryToGet = M28UnitInfo.refCategoryAirFactory
                            else
                                iFactoryEngineerAction = M28Engineer.refActionBuildLandFactory
                                iFactoryCategoryToGet = M28UnitInfo.refCategoryLandFactory
                            end
                            ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, iFactoryCategoryToGet, iFactoryEngineerAction)
                            if bDebugMessages == true then LOG(sFunctionRef..': Just tried another factory type with iFactoryEngineerAction='..iFactoryEngineerAction..'; do we have a valid order='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))) end
                        end

                        if bWantMoreFactories and not(M28Conditions.DoesACUHaveValidOrder(oACU)) and (M28Orders.bDontConsiderCombinedArmy or oACU.M28Active) then
                            --Move to WZ to build a naval factory if we have none and are adjacent to water
                            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]) == false and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalFactory) == 0 then
                                MoveACUToNearbyWaterForFactory(aiBrain, oACU, tLZOrWZData)
                                --Do we want more power?
                            elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 50 * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.3 and not(M28Conditions.HaveLowMass(aiBrain)) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 2 and oACU.HasEnhancement and oACU:HasEnhancement('AdvancedEngineering'))) and (M28Conditions.WantMorePower(iTeam) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.7) then
                                ACUActionBuildPower(aiBrain, oACU)
                            end
                        end
                        if not(M28Conditions.DoesACUHaveValidOrder(oACU)) and (M28Orders.bDontConsiderCombinedArmy or oACU.M28Active) then
                            --Do we want more power?
                            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 50 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.3 and not(M28Conditions.HaveLowMass(aiBrain)) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 2 and oACU.HasEnhancement and oACU:HasEnhancement('AdvancedEngineering'))) and (M28Conditions.WantMorePower(iTeam) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.7) then
                                ACUActionBuildPower(aiBrain, oACU)
                            else
                                bProceedWithLogic = true
                            end
                        end
                    end

                    if bDebugMessages == true then LOG(sFunctionRef..': We want to build factory or power, so wont proceed with logic, unless we werent able to build eg due to unit restrictions, bProceedWithLogic='..tostring(bProceedWithLogic)) end
                end
            elseif iPlateauOrZero == 0 and (tLZOrWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] or M28Map.bIsCampaignMap) and aiBrain[M28Economy.refiOurHighestNavalFactoryTech] == 0 and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) then
                ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryNavalFactory, M28Engineer.refActionBuildNavalFactory)
                bProceedWithLogic = false
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bProceedWithLogic='..tostring(bProceedWithLogic or false)) end
            if bProceedWithLogic then
                --Special telesnipe logic (takes priorioty over running)
                if HaveTelesnipeAction(oACU, tLZOrWZData, tLZOrWZTeamData, aiBrain, iTeam, iPlateauOrZero, iLandOrWaterZone) then
                    if bDebugMessages == true then LOG(sFunctionRef..': ACU is proceeding with a telesnipe action') end
                else
                    oACU[refbACUAvailableToDoSnipeAttack] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if ACU wants to run, Does it want to return to core base='..tostring(DoesACUWantToReturnToCoreBase(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) or false)..'; ACU unit state='..M28UnitInfo.GetUnitState(oACU)..'; Is this core base='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or false)..'; Dist to midpoint='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZData[M28Map.subrefMidpoint])..'; Does ACU want to run='..tostring(DoesACUWantToRun(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) or false)..'; Is Enemy snipe target table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets]))..'; oACU[refbACUSnipeModeActive]='..tostring(oACU[refbACUSnipeModeActive] or false)..'; Enemy team mass income='..M28Conditions.GetEnemyTeamActualMassIncome(iTeam)..'; Our team mass income='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) end
                    function GetPositionToRunFromNearestEnemy()
                        local tPositionToRunTo
                        local oClosestEnemy, iCurDist
                        local iClosestEnemy = 1000
                        for iEnemy, oEnemy in tLZOrWZTeamData[M28Map.reftoNearestDFEnemies] do
                            if not(oEnemy.Dead) then
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oACU:GetPosition()) - (oEnemy[M28UnitInfo.refiDFRange] or 0)
                                if iCurDist < iClosestEnemy then
                                    iClosestEnemy = iCurDist
                                    oClosestEnemy = oEnemy
                                end
                            end
                        end
                        local tPositionToRunFrom
                        if oClosestEnemy then tPositionToRunFrom = oClosestEnemy:GetPosition() else tPositionToRunFrom = tLZOrWZTeamData[M28Map.reftClosestEnemyBase] end
                        local iAngleToMove = M28Utilities.GetAngleFromAToB(tPositionToRunFrom, oACU:GetPosition())
                        for iDistToMove = 20, 10, -5 do
                            tPositionToRunTo = M28Utilities.MoveInDirection(oACU:GetPosition(), iAngleToMove, iDistToMove, true, true, M28Map.bIsCampaignMap)
                            if M28Utilities.IsTableEmpty(tPositionToRunTo) == false and NavUtils.GetLabel(M28Map.refPathingTypeHover, tPositionToRunTo) == iPlateauOrZero then
                                break
                            else
                                tPositionToRunTo = nil
                            end
                        end
                        if not(tPositionToRunTo) then tPositionToRunTo = M28Land.GetNearestLandRallyPoint(tLZOrWZData, iTeam, iPlateauOrZero, iLandOrWaterZone, 2, true) end
                        return tPositionToRunTo
                    end
                    --Potential snipe target if we are in range of an enemy ACU and it is low enough health that we can just go for a kill
                    if oACU[refbACUSnipeModeActive] or DoesACUWantToSuicideIntoEnemyACU(oACU, iTeam, iPlateauOrZero, iLandOrWaterZone, tLZOrWZTeamData) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and kill enemy ACU (via special micro logic)') end
                    elseif not(oACU:IsUnitState('Building')) and DoesACUWantToReturnToCoreBase(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                        if  tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                            if not(ConsiderRunningToGETemplate(oACU, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero)) then
                                local tRallyPoint = GetPositionToRunFromNearestEnemy()
                                if bDebugMessages == true then LOG(sFunctionRef..': Will run from enarest enemy as are in core base') end
                                M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'RunNrEcb')
                            end
                        else
                            ConsiderIfACUNeedsEmergencySupport(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)
                            if not(ConsiderRunningToGETemplate(oACU, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': ACU more than 10 from core base midpoint so will retreat there, ACU dist to this midpoint='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZData[M28Map.subrefMidpoint])..'; Is this core base='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase])) end
                                if not(ConsiderRunningToNearestShield(oACU, tLZOrWZData, tLZOrWZTeamData, iTeam, iPlateauOrZero, iLandOrWaterZone)) then
                                    ReturnACUToCoreBase(oACU, tLZOrWZData, tLZOrWZTeamData, aiBrain, iTeam, iPlateauOrZero, iLandOrWaterZone)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Going to core base') end
                                end
                            elseif bDebugMessages == true then LOG(sFunctionRef..': Will run to GE template')
                            end
                        end
                    elseif DoesACUWantToRun(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) and
                            (not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) or M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.7
                                    or (M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar] and (M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 2 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1.3 * M28Conditions.GetEnemyTeamActualMassIncome(iTeam)))
                                    or (M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false and M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.refiEnemyMobileDFThreatNearOurSide] >= 5000 and M28Conditions.CloseToEnemyUnit(oACU:GetPosition(), M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals], 80, iTeam, true, nil, nil, nil, nil, nil)))

                    then --and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZData[M28Map.subrefMidpoint]) <= 10) then
                        local tRallyPoint
                        local bConsiderMexesAndReclaim = false
                        if not(ConsiderRunningToGETemplate(oACU, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero)) then
                            ConsiderIfACUNeedsEmergencySupport(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)
                            oACU[refiTimeLastWantedToRun] = GetGameTimeSeconds()

                            --If are in core zone then run from nearest enemy
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearest DF enemies empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]))..'; Core base='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase])) end
                            if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) == false and (M28UnitInfo.GetUnitHealthPercent(oACU) < 0.9 or M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) then
                                tRallyPoint = GetPositionToRunFromNearestEnemy()
                                if bDebugMessages == true then LOG(sFunctionRef..'; Rally point is based on running from the nearest enemy, angle to rally point='..M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tRallyPoint)) end
                            else
                                --Retreat to nearest rally (unless we arent in a land zone in which case head towards core base)

                                if iLandOrWaterZone > 0 and iPlateauOrZero > 0 then
                                    --Are we on a different island to our base, and want to move back there?

                                    tRallyPoint = M28Land.GetNearestLandRallyPoint(tLZOrWZData, iTeam, iPlateauOrZero, iLandOrWaterZone, 2, true)
                                    --If the rally point takes us further away from the closest friendly base, and is more than 50 from the closest friendly base, then head towards the base (exception if rally point is a core base or is a location with friendly PD and/or factories or significantly friendly combat)
                                    if bDebugMessages == true then LOG(sFunctionRef..': tRallyPoint='..repru(tRallyPoint)..' for P'..iPlateauOrZero..'Z'..iLandOrWaterZone..'; ACU position='..repru(oACU:GetPosition())..'; ACU angle to rally='..M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tRallyPoint)..'; Dist from rally to closest friendly base='..M28Utilities.GetDistanceBetweenPositions(tRallyPoint, tLZOrWZTeamData[M28Map.reftClosestFriendlyBase])) end
                                    if M28Utilities.GetDistanceBetweenPositions(tRallyPoint, tLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) >= 50 then
                                        local iDistToBase = M28Utilities.GetDistanceBetweenPositions(tLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase])
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will switch to running to base if base relatively close and rally point a dif angle, iDistToBase='..iDistToBase..'; Mod dist%='..tLZOrWZTeamData[M28Map.refiModDistancePercent]..'; Angle dif='..M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tRallyPoint), M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftClosestFriendlyBase]))) end
                                        if iDistToBase <= 250 and tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.6 and M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tRallyPoint), M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftClosestFriendlyBase])) >= 35 then
                                            if M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.8 then bConsiderMexesAndReclaim = true end

                                            --Consider friendly base if it isnt dangerous
                                            if M28Conditions.BaseIsSafeToRetreatTo(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], iTeam) then
                                                tRallyPoint = {tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][1], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][2], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][3]}
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will have ACU retreat to closest friendly base, angle to closest friendly base='..M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tRallyPoint)) end
                                            end
                                        else

                                            local tRallyLZData, tRallyLZTeamData = M28Map.GetLandOrWaterZoneData(tRallyPoint, true, iTeam)

                                            if not(tRallyLZTeamData[M28Map.subrefLZbCoreBase]) then
                                                local iRallyThreat = (tRallyLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)
                                                if tRallyLZTeamData == tLZOrWZTeamData then iRallyThreat = iRallyThreat - M28UnitInfo.GetCombatThreatRating({oACU}, false, false, false, false, false, false, false, false) end
                                                if bDebugMessages == true then LOG(sFunctionRef..': Rally point is more than 50 from closest friendly base, checking if threat is too low, iRallyThreat='..iRallyThreat..'; Is rally in a core expansion='..tostring(tRallyLZTeamData[M28Map.subrefLZCoreExpansion])) end
                                                if iRallyThreat <= 500 and (not(tRallyLZTeamData[M28Map.subrefLZCoreExpansion]) or tRallyLZTeamData[M28Map.subrefLZSValue] < 220) then --Only consider core expansion if it has significant structure value, e.g. similar to having 1 land factory
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Dist from rally to closest base='..M28Utilities.GetDistanceBetweenPositions(tRallyLZTeamData[M28Map.reftClosestFriendlyBase], tRallyLZData[M28Map.subrefMidpoint])..'; Dist from ACU to closest base='..M28Utilities.GetDistanceBetweenPositions(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], oACU:GetPosition())) end
                                                    if M28Utilities.GetDistanceBetweenPositions(tRallyLZTeamData[M28Map.reftClosestFriendlyBase], tRallyLZData[M28Map.subrefMidpoint]) > M28Utilities.GetDistanceBetweenPositions(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], oACU:GetPosition()) then
                                                        bConsiderMexesAndReclaim = false
                                                        --Is our closest friendly base in the same plateau?
                                                        local iClosestBasePlateauOrZero, iClosestBaseLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase])
                                                        if iClosestBasePlateauOrZero == iPlateauOrZero and M28Conditions.BaseIsSafeToRetreatTo(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], iTeam)  then
                                                            tRallyPoint = {tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][1], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][2], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][3]}
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Changed rally point to be the closest friendly base, angle to this='..M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tRallyPoint)) end
                                                        end
                                                    end
                                                else
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if rally LZ is same as ACU LZ, are they equal='..tostring(tRallyLZData == tLZOrWZData)) end
                                                    if tRallyLZData == tLZOrWZData then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': ACU health%='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; iRallyThreat='..iRallyThreat) end
                                                        if M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.5 and iRallyThreat < 100 then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Want to consider mexes and reclaim') end
                                                            bConsiderMexesAndReclaim= true
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                        if bConsiderMexesAndReclaim then
                                            --If have DF enemies in our range or their range then dont consider reclaim
                                            local iCurEnemyDist
                                            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                                                for iEnemy, oEnemy in tLZOrWZTeamData[M28Map.reftoNearestDFEnemies] do
                                                    if M28UnitInfo.IsUnitValid(oEnemy) then
                                                        iCurEnemyDist = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oACU:GetPosition())
                                                        if iCurEnemyDist < math.max((oACU[M28UnitInfo.refiDFRange] or 0), oEnemy[M28UnitInfo.refiDFRange] or 0) then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy '..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..' is only '..iCurEnemyDist..' away from us so wont consider mex building or reclaim after all') end
                                                            bConsiderMexesAndReclaim = false
                                                            break
                                                        end
                                                    end
                                                end
                                            end
                                            if bConsiderMexesAndReclaim and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats]) == false then
                                                for iEnemy, oEnemy in tLZOrWZTeamData[M28Map.subrefoNearbyEnemyLongRangeDFThreats] do
                                                    if M28UnitInfo.IsUnitValid(oEnemy) then
                                                        iCurEnemyDist = M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oACU:GetPosition())
                                                        if iCurEnemyDist < math.max((oACU[M28UnitInfo.refiDFRange] or 0), oEnemy[M28UnitInfo.refiDFRange] or 0) + 5 then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy '..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..' is only '..iCurEnemyDist..' away from us so wont consider mex building or reclaim after all') end
                                                            bConsiderMexesAndReclaim = false
                                                            break
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    --[[GetTravelDistanceBetweenPositions(tStart, tEnd, sPathing)
                                    local iTravelDistFromRallyToClosestFriendlyBase

                                     = M28Utilities.GetTravelDist--]]


                                else
                                    tRallyPoint = M28Map.GetPlayerStartPosition(oACU:GetAIBrain())
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will retreat to ACU start position, angle to this='..M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tRallyPoint)) end
                                end
                            end

                            --If enemy has nearby exp then run in opposite direction (rather tahn going to rally point) if rally point isn't much further away from the exp, unless we are already in range of the EXP (since we might as well then consider overcharging it)
                            local bHaveNearbyExperimentalOrder = false
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy land exp empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]))) end
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
                                local iClosestEnemyExp = 160
                                if tLZOrWZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= 20000 then iClosestEnemyExp = 135 end
                                local oClosestEnemyExp, iCurDist
                                for iExp, oExp in M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
                                    if M28UnitInfo.IsUnitValid(oExp) then
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oExp:GetPosition(), oACU:GetPosition())
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy land exp '..oExp.UnitId..M28UnitInfo.GetUnitLifetimeCount(oExp)..'; iCurDist='..iCurDist..'; Unit range='..(oExp[M28UnitInfo.refiDFRange] or 0)) end
                                        if iCurDist < iClosestEnemyExp then
                                            iClosestEnemyExp = iCurDist
                                            oClosestEnemyExp = oExp
                                        end
                                    end
                                end
                                --If enemy has land exp near us but we arent already in range of it then run in the opopsite direction
                                if oClosestEnemyExp then
                                    if iClosestEnemyExp > math.max((oACU[M28UnitInfo.refiDFRange] or 0), (oClosestEnemyExp[M28UnitInfo.refiDFRange] or 0) + 2) then
                                        --Is the rally point taking us further away from this?
                                        local iRallyPointDist = M28Utilities.GetDistanceBetweenPositions(oClosestEnemyExp:GetPosition(), tRallyPoint)
                                        local iAngleFromACUToExp = M28Utilities.GetAngleFromAToB(oACU:GetPosition(), oClosestEnemyExp:GetPosition())
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want ACU to run from enemy EXP, oClosestEnemyExp='..oClosestEnemyExp.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyExp)..'; iClosestEnemyExp='..iClosestEnemyExp..'; iAngleFromACUToExp='..iAngleFromACUToExp..'; iRallyPointDist='..iRallyPointDist..'; Angle to rally='..M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tRallyPoint)..'; Dist to rally='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tRallyPoint)) end
                                        if iRallyPointDist <= 30 + iClosestEnemyExp and (M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tRallyPoint) <= 30 or M28Utilities.GetAngleDifference(iAngleFromACUToExp, M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tRallyPoint)) <= 110) then
                                            local tAltRallyPoint = M28Utilities.MoveInDirection(oACU:GetPosition(), iAngleFromACUToExp-180, 15, true, true, true)
                                            if M28Utilities.IsTableEmpty(tAltRallyPoint) == false and NavUtils.GetLabel(M28Map.refPathingTypeHover, tAltRallyPoint) == NavUtils.GetLabel(M28Map.refPathingTypeHover, oACU:GetPosition()) then
                                                bHaveNearbyExperimentalOrder = true
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will run to alt rally point') end
                                                M28Orders.IssueTrackedMove(oACU, tAltRallyPoint, 5, false, 'RunExp')
                                            end
                                        end
                                    else
                                        if not(ConsiderRunningToNearestShield(oACU, tLZOrWZData, tLZOrWZTeamData, iTeam, iPlateauOrZero, iLandOrWaterZone)) then
                                            bHaveNearbyExperimentalOrder = true
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will run to nearby shield') end
                                        else
                                            if iClosestEnemyExp <= (oACU[M28UnitInfo.refiDFRange] or 0) + 17 and M28Conditions.CanUnitUseOvercharge(oACU:GetAIBrain(), oACU, tLZOrWZTeamData) then --e.g. up against ythotha, gc or monkeylord - want to try and get in range to overcharge since we are now in range
                                                --We dont have nearby shield to retreat to, and are in range of the enemy EXP, but we can overcharge it
                                                bHaveNearbyExperimentalOrder = true
                                                M28Orders.IssueTrackedMove(oACU, oClosestEnemyExp:GetPosition(), 5, false, 'RnAtkExp')
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will attack Exp in case we can overcharge it') end
                                            end
                                        end
                                    end
                                end
                            end


                            --If we are already in the zone for the rally point and it has unbuilt mexes or significant reclaim then want to consider getting them; otherwise go to nearest friendly base
                            if not(bHaveNearbyExperimentalOrder) and (not(bConsiderMexesAndReclaim) or (not(ConsiderBuildingMex(tLZOrWZData, tLZOrWZTeamData, oACU, 15)) and not(ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, M28UnitInfo.GetUnitHealthPercent(oACU) < 0.75, 20)))) then

                                --Consider using old rally point if new one is further from base and <60s since we have retreated
                                if oACU[reftLastRallyPointRanTo] and oACU[refiTimeLastWantedToRun] and GetGameTimeSeconds() - oACU[refiTimeLastWantedToRun] <= 60 then
                                    local iCurDistToBase = M28Utilities.GetDistanceBetweenPositions(tRallyPoint, tLZOrWZTeamData[M28Map.reftClosestFriendlyBase])
                                    local iPreviousDistToBase = M28Utilities.GetDistanceBetweenPositions(oACU[reftLastRallyPointRanTo], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase])
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering using old rally point if its closer to our base than current rally point, iCurDistToBase='..iCurDistToBase..'; iPreviousDistToBase='..iPreviousDistToBase) end
                                    if iCurDistToBase - 5 > iPreviousDistToBase then
                                        local tOldRallyLZData, tOldRallyLZTeamData = M28Map.GetLandOrWaterZoneData(oACU[reftLastRallyPointRanTo], true, iTeam)
                                        if tOldRallyLZTeamData and not(tOldRallyLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) then
                                            tRallyPoint = {oACU[reftLastRallyPointRanTo][1], oACU[reftLastRallyPointRanTo][2], oACU[reftLastRallyPointRanTo][3]}
                                            if bDebugMessages == true then LOG(sFunctionRef..': Switching to old rally point') end
                                        end
                                    end
                                end
                                if not(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs]) then
                                    if iPlateauOrZero > 0 and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) == false and M28Conditions.GiveAttackMoveAsWeaponStuck(oACU) and M28Conditions.CloseToEnemyUnit(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftoNearestDFEnemies], oACU[M28UnitInfo.refiCombatRange], iTeam, false, nil, nil, nil, nil, nil) then
                                        M28Orders.IssueTrackedAttackMove(oACU, tRallyPoint, 5, false, 'RunARP')
                                    else
                                        M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'RunRP')
                                    end
                                    oACU[reftLastRallyPointRanTo] = {tRallyPoint[1], tRallyPoint[2], tRallyPoint[3]}
                                elseif M28Conditions.BaseIsSafeToRetreatTo(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], iTeam) then
                                    M28Orders.IssueTrackedMove(oACU, tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], 5, false, 'RunRBs') --v82 and earlier - the 'move to rally point' line was commented out in place of this; have switched back to enabling it (v83); if it causes issues then try and think of better solution than just running to base which I suspect was a placeholder
                                    oACU[reftLastRallyPointRanTo] = {tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][1], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][2], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][3]}
                                else
                                    M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'RunRBr')
                                    oACU[reftLastRallyPointRanTo] = {tRallyPoint[1], tRallyPoint[2], tRallyPoint[3]}
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Telling ACU to run; aACU orders after this='..reprs(oACU[M28Orders.reftiLastOrders])..'; Is micro active='..tostring(oACU[M28UnitInfo.refbSpecialMicroActive])..'; Nearest land rally point='..repru(M28Land.GetNearestLandRallyPoint(tLZOrWZData, iTeam, iPlateauOrZero, iLandOrWaterZone, 2, true))..'; P'..iPlateauOrZero..'Z'..iLandOrWaterZone..'; Rally point='..repru(tRallyPoint)..'; Nearest friendly base='..repru(M28Map.GetPlayerStartPosition(oACU:GetAIBrain()))..'; Dist from rally point to friendly base='..M28Utilities.GetDistanceBetweenPositions(tRallyPoint, M28Map.GetPlayerStartPosition(oACU:GetAIBrain()))..'; Dist from ACU to rally point='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tRallyPoint)) end
                            end
                        elseif bDebugMessages == true then LOG(sFunctionRef..': Will run to GE template')
                        end
                    else
                        --ACU is being used as an engineer?
                        if oACU[refiBuildTech] > 1 and ((oACU[refiBuildTech] >= aiBrain[M28Economy.refiOurHighestFactoryTechLevel] and ((oACU[refiBuildTech] > aiBrain[M28Economy.refiOurHighestFactoryTechLevel] and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies])) or not(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]))) or (oACU[M28UnitInfo.refiDFRange] or 0) <= 24) and HaveActionForACUAsEngineer(oACU, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iLandOrWaterZone) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Are using ACU more as an engineer') end
                        else
                            --Snipe mode
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to use ACU to attack a snipe target, is table of snipe targets empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets]))) end
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets]) or not(HaveACUSnipeAction(oACU, iTeam, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData)) then
                                --Nearby enemy naval units
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if nearby naval units that should send ACU to try and fight; M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbNoAvailableTorpsForEnemies] ='..tostring(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbNoAvailableTorpsForEnemies])..'; ACU health='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; Is table of adjacent WZs empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]))) end
                                local iWaterZoneEnemyRangeOverride
                                if M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.3 then iWaterZoneEnemyRangeOverride = 10 end
                                --if ACU has torp upgrade but lacks stealth, then consider getting stealth upgrade when in water
                                if oACU[refiUpgradeCount] == 1 and oACU[M28UnitInfo.refiAntiNavyRange] and iPlateauOrZero == 0 and M28UnitInfo.IsUnitUnderwater(oACU) and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and (M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 2 or (oACU[M28UnitInfo.refiLastWeaponEvent] and GetGameTimeSeconds() - oACU[M28UnitInfo.refiLastWeaponEvent] <= 5)) and tLZOrWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] <= 2000 and GetACUUpgradeWanted(oACU, nil, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, true) == 'StealthGenerator' and (GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastIssuedACUEnhancementOrder] or -100) >= 2 or oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] == 'StealthGenerator' or (oACU[M28Orders.refiTimeOfLastRemovalUpgrade] and GetGameTimeSeconds() - oACU[M28Orders.refiTimeOfLastRemovalUpgrade] <= 2)) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Get priority stealth upgrade as are underwater and can hopefully fire at enemy with torpedo while getting it') end
                                    M28Orders.IssueTrackedEnhancement(oACU, 'StealthGenerator', false, 'ACUWtSUpr')
                                elseif oACU[M28UnitInfo.refiAntiNavyRange] and oACU[M28UnitInfo.refiAntiNavyRange] > 10 and not(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.6 and ConsiderAttackingNearbyNavalUnits(tLZOrWZData, tLZOrWZTeamData, oACU) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': ACU has torpedo upgrade so want to attack nearby enemy navla units') end
                                elseif iPlateauOrZero > 0 and M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbNoAvailableTorpsForEnemies] and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]) == false and ConsiderAttackingNearbyNavalUnits(tLZOrWZData, tLZOrWZTeamData, oACU, iWaterZoneEnemyRangeOverride) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Telling ACU to attack nearby enemy navla units') end

                                else
                                    --Priority gun upgrade due to enemy getting upgrade (intended for 1v1 on smaller maps)
                                    local bGettingPriorityUpgrade = false
                                    if oACU[refbWantsPriorityUpgrade] and (not(oACU:IsUnitState('Building')) and not(oACU:IsUnitState('Capturing')) and (not(oACU:IsUnitState('Repairing')) or oACU:IsUnitState('Guarding')) and (not(oACU:IsUnitState('Reclaiming')) or aiBrain:GetEconomyStoredRatio('MASS') >= 0.8) and not(oACU:IsUnitState('Capturing'))) then
                                        --Do we want to get an upgrade?
                                        local sUpgradeToGet, bIgnoreOtherUpgradeConditions = GetACUUpgradeWanted(oACU, nil, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]))
                                        if bDebugMessages == true then LOG(sFunctionRef..': Do we have a priority upgrade we want to get? sUpgradeToGet='..(sUpgradeToGet or 'nil')) end
                                        if sUpgradeToGet then
                                            bGettingPriorityUpgrade = true
                                            --Do we have a friendly nearby ugprading ACU? If so then assist its upgrade first before getting ours
                                            if bIgnoreOtherUpgradeConditions or not(AssistNearbyUpgradingACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, 40)) then
                                                --Are we safe to get the upgrade here? if not then retreat
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will check if safe to get priority upgrade for oACU, oACU='..(oACU.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oACU) or 'nil')..'; Brain='..oACU:GetAIBrain().Nickname) end
                                                if bIgnoreOtherUpgradeConditions or M28Conditions.SafeToUpgradeUnit(oACU) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Safe to get priority upgrade here so will proceed with upgrading ACU, sUpgradeToGet='..(sUpgradeToGet or 'nil')..' brain='..oACU:GetAIBrain().Nickname..'; Has enhancement='..tostring(oACU:HasEnhancement(sUpgradeToGet))) end
                                                    if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastIssuedACUEnhancementOrder] or -100) >= 2 or (oACU[M28Orders.refiTimeOfLastRemovalUpgrade] and GetGameTimeSeconds() - oACU[M28Orders.refiTimeOfLastRemovalUpgrade] <= 10) or oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] == sUpgradeToGet then
                                                        M28Orders.IssueTrackedEnhancement(oACU, sUpgradeToGet, false, 'ACUUpr')
                                                    end
                                                else
                                                    --Retreat
                                                    local tRallyPoint = M28Land.GetNearestLandRallyPoint(tLZOrWZData, oACU:GetAIBrain().M28Team, iPlateauOrZero, iLandOrWaterZone, 2)
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Not safe to get priority upgrade so want to retreat until it is, going to nearest land rally point, P'..iPlateauOrZero..'Z'..iLandOrWaterZone..'; tRallyPoint='..repru(tRallyPoint)..'; ACU position='..repru(oACU:GetPosition())..'; Angle to this='..M28Utilities.GetAngleFromAToB(oACU:GetPosition(), tRallyPoint)) end
                                                    M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'R4UeNg')
                                                end
                                            end
                                        end
                                    end
                                    if not(bGettingPriorityUpgrade) then
                                        --Part-built or unbuilt mex in build range of ACU when no enemies in the LZ
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will consider building mex if one is almost in build range and no enemy combat threat in this LZ/WZ, or we outrange enemy and enemy isnt in our range; threat='..tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]) end
                                        local bConsiderBuildingNearbyMex = true
                                        local iNearbyMexRangeThreshold = 2
                                        if tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] == 0 then
                                            --Do nothing - want to consider building mex
                                        elseif tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 200 then
                                            bConsiderBuildingNearbyMex = false
                                            if bDebugMessages == true then LOG(sFunctionRef..':Too much threat in this zone') end
                                        else
                                            --Enemy has small threat, so might want to build mex rather than attack
                                            if math.max((tLZOrWZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0), (tLZOrWZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0), (tLZOrWZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0)) >= (oACU[M28UnitInfo.refiDFRange] or 0) then
                                                bConsiderBuildingNearbyMex = false
                                                if bDebugMessages == true then LOG(sFunctionRef..'; We dont outrange enemy so wont consider building mex') end
                                            else
                                                --We outrange enemy, which is a small threat, so consider building mex instead of pursuing enemy
                                                local tClosestMex
                                                local iClosestMex = 10000
                                                local iCurDist
                                                if (oACU:IsUnitState('Building') or oACU:IsUnitState('Repairing') or oACU:IsUnitState('Capturing')) and EntityCategoryContains(M28UnitInfo.refCategoryMex, oACU:GetFocusUnit().UnitId) then
                                                    if M28Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat, oACU:GetPosition(), oACU[M28UnitInfo.refiDFRange], 'Enemy')) == false then
                                                        bConsiderBuildingNearbyMex = false
                                                    end
                                                elseif M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) then
                                                    bConsiderBuildingNearbyMex = false
                                                    if bDebugMessages == true then LOG(sFunctionRef..': No unbuilt locations for this zone') end
                                                else
                                                    for iMex, tMex in tLZOrWZData[M28Map.subrefMexUnbuiltLocations] do
                                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(tMex, oACU:GetPosition())
                                                        if iCurDist < iClosestMex then
                                                            iClosestMex = iCurDist
                                                            tClosestMex = {tMex[1], tMex[2], tMex[3]}
                                                        end
                                                    end
                                                    if iClosestMex <= oACU[M28UnitInfo.refiDFRange] + iNearbyMexRangeThreshold then
                                                        --Have an unbuilt mex in or near our build range, so now check if enemy is closer to the mex than we are/is in range of the mex
                                                        local bEnemyAlmostInRangeOfMex = false
                                                        for iUnit, oUnit in tLZOrWZTeamData[M28Map.subrefTEnemyUnits] do
                                                            if M28UnitInfo.IsUnitValid(oUnit) then
                                                                iCurDist = M28Utilities.GetDistanceBetweenPositions(tClosestMex, oUnit:GetPosition())
                                                                if iCurDist - (oUnit[M28UnitInfo.refiCombatRange] or 0) <= 2 then
                                                                    bEnemyAlmostInRangeOfMex = true
                                                                    break
                                                                end
                                                            end
                                                        end
                                                        if bDebugMessages == true then LOG(sFunctionRef..': bEnemyAlmostInRangeOfMex='..tostring(bEnemyAlmostInRangeOfMex)) end
                                                        if bEnemyAlmostInRangeOfMex then
                                                            bConsiderBuildingNearbyMex = false
                                                        end
                                                    else
                                                        bConsiderBuildingNearbyMex = false
                                                    end
                                                end


                                            end
                                        end
                                        --Adjust - if land zone and we want to consider building a mex, but there are DF enemies, then check if we are close to them, if we are then dont want to build (as dont want to build a mex while taking fire or where the mex will just die)
                                        if bConsiderBuildingNearbyMex and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) == false and M28Conditions.CloseToEnemyUnit(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftoNearestDFEnemies], 6, iTeam, true, nil, nil, nil, nil, nil) then
                                            bConsiderBuildingNearbyMex = false
                                            if bDebugMessages == true then LOG(sFunctionRef..': Are close to enemy so dont want to consdier getting mex') end
                                        end

                                        --Part-built or unbuilt mex in build range of ACU when no enemies in the LZ
                                        if bDebugMessages == true then LOG(sFunctionRef..': Finished consider building mex if one is almost in build range and no enemy combat threat in this LZ/WZ, threat='..tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; bConsiderBuildingNearbyMex='..tostring(bConsiderBuildingNearbyMex)) end
                                        if not(bConsiderBuildingNearbyMex) or not(ConsiderBuildingMex(tLZOrWZData, tLZOrWZTeamData, oACU, 2)) then
                                            if not(ConsiderRunningToGETemplate(oACU, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero)) then
                                                --ACU damaged and we have a T3 shield in the zone - make sure we are underneath shield coverage
                                                local bHaveMovedToBeUnderShield = false
                                                if M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.8 and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                                    local tFriendlyShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield - categories.TECH2 - categories.TECH1, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                                    if M28Utilities.IsTableEmpty(tFriendlyShields) == false then
                                                        local iCurShieldHealth, iMaxShieldHealth, iCurShieldDist
                                                        local iClosestShield = 150 --No point trying to move to a shield further away
                                                        local oClosestShield
                                                        for iShield, oShield in tFriendlyShields do
                                                            if M28UnitInfo.IsUnitValid(oShield) then
                                                                iCurShieldHealth, iMaxShieldHealth = M28UnitInfo.GetCurrentAndMaximumShield(oShield, false)
                                                                if iCurShieldHealth >= 6000 then
                                                                    iCurShieldDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oACU:GetPosition())
                                                                    if iCurShieldDist < iClosestShield then
                                                                        iClosestShield = iCurShieldDist
                                                                        oClosestShield = oShield
                                                                    end
                                                                end
                                                            end
                                                        end
                                                        if oClosestShield and iClosestShield < 4 + oClosestShield:GetBlueprint().Defense.Shield.ShieldSize * 0.5 then
                                                            bHaveMovedToBeUnderShield = true
                                                            M28Orders.IssueTrackedMove(oACU, oClosestShield:GetPosition(), 4, false, 'ACUUnSh', false)
                                                        end
                                                    end
                                                end
                                                if not(bHaveMovedToBeUnderShield) then

                                                    --Priority reclaim - if reclaim that is in ACU build radius and have <30% mass stored even if nearby enemies (provided arent in range, unless shot is blocked), if have no upgrade or T2 upgrade
                                                    local bAreBuildingOrReclaiming = false
                                                    if oACU:IsUnitState('Building') or oACU:IsUnitState('Repairing') or oACU:IsUnitState('Capturing') then bAreBuildingOrReclaiming = true end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': About to check for priority reclaim, mass stored%='..aiBrain:GetEconomyStoredRatio('MASS')..'; ACU upgrade count='..(oACU[refiUpgradeCount] or 0)..'; Does ACU have adanced engineering='..tostring(oACU:HasEnhancement('AdvancedEngineering'))..'; ACU health %='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; bAreBuildingOrReclaiming='..tostring(bAreBuildingOrReclaiming)..'; Is ACU in T1 spam mode='..tostring(M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam])) end

                                                    if aiBrain:GetEconomyStoredRatio('MASS') < 0.3 and (not(bAreBuildingOrReclaiming) or aiBrain:GetEconomyStored('MASS') < 25) and ((oACU[refiUpgradeCount] or 0) == 0 or oACU:HasEnhancement('AdvancedEngineering')) and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.9 and
                                                            (oACU[M28UnitInfo.refbLastShotBlocked] or M28Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryNavalSurface, oACU:GetPosition(), (oACU[M28UnitInfo.refiDFRange] or 0), 'Enemy'))) and
                                                            ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, true) then
                                                        --ACU wants to get reclaim
                                                        if bDebugMessages == true then LOG(sFunctionRef..': ACU will get reclaim') end
                                                    else
                                                        if not(bAreBuildingOrReclaiming) then
                                                            --Consider building power if in core zone with lots of mass, and either we lack gun upgrade, or it is late game with no adjacent enemies; however require our stored actual energy to be less then 4k (since we may have just built energy storage)
                                                            local bBuildingOrAssistingPowerOrFactory = false
                                                            if bDebugMessages == true then LOG(sFunctionRef..': About to consider getting power or factories if in core base and have lots of mass stored, M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam]='..tostring(M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam])..'; tLZOrWZTeamData[M28Map.subrefLZbCoreBase]='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase])..'; Energy%='..aiBrain:GetEconomyStoredRatio('ENERGY')..'; Mass %='..aiBrain:GetEconomyStoredRatio('MASS')..'; Gross energy='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; Enemeis in this or adj='..tostring(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end

                                                            if not(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and aiBrain:GetEconomyStoredRatio('MASS') >= 0.2 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 3000 and (aiBrain:GetEconomyStoredRatio('MASS') >= 0.5 or not(aiBrain[M28Overseer.refbPrioritiseAir] or aiBrain[M28Overseer.refbPrioritiseHighTech] or aiBrain[M28Overseer.refbPrioritiseDefence] or aiBrain[M28Overseer.refbPrioritiseNavy]) or aiBrain[M28Economy.refiOurHighestFactoryTechLevel] >= 3 or (aiBrain:GetEconomyStoredRatio('MASS') >= 0.3 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory) < 3 and M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandOrWaterZone(tLZOrWZTeamData, M28UnitInfo.refCategoryFactory * categories.TECH1) == 0)) then
                                                                --First consider factories if a t1 spam mode and enemy lacks gun
                                                                if bDebugMessages == true then LOG(sFunctionRef..': About to check if want to build more factories, iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]='..(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] or 'nil')..'; tLZTeamData[M28Map.subrefMexCountByTech][3]='..(tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] or 'nil')) end
                                                                if GetGameTimeSeconds() <= 600 and iPlateauOrZero > 0 and (aiBrain[M28Economy.refiOurHighestFactoryTechLevel] <= 1 or oACU[refiBuildTech] >= 2) and not(M28Overseer.bLikelyGunUpgrade) and aiBrain:GetEconomyStoredRatio('MASS') >= 0.35 and (aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.8 or aiBrain[M28Economy.refiNetEnergyBaseIncome] > 0 and aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.5) and M28Conditions.WantMoreFactories(iTeam, iPlateauOrZero, iLandOrWaterZone) and not(M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZOrWZData, tLZOrWZTeamData, aiBrain)) then
                                                                    --No enemies in this or adj zone, consider building fac unless mod dist is high
                                                                    if tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.3 or tLZOrWZTeamData[M28Map.subrefLZbCoreBase] then
                                                                        --If cant path to enemy with land, or are tech or turtle or navy, then be less likely
                                                                        if (aiBrain:GetEconomyStoredRatio('MASS') >= 0.5 and aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.95)
                                                                                or not(aiBrain[M28Overseer.refbPrioritiseHighTech] or aiBrain[M28Overseer.refbPrioritiseNavy] or aiBrain[M28Overseer.refbPrioritiseDefence] or aiBrain[M28Overseer.refbPrioritiseAir])
                                                                                or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryAirFactory) < 3 or (tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and M28Conditions.GetNumberOfConstructedUnitsMeetingCategoryInZone(tLZOrWZTeamData, M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryAirFactory) < 3) then
                                                                            bBuildingOrAssistingPowerOrFactory = true
                                                                            ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, nil, nil)
                                                                        end
                                                                    end
                                                                end


                                                                if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and aiBrain:GetEconomyStoredRatio('ENERGY') < 0.95 and
                                                                        (((oACU[refiUpgradeCount] == 0 or (oACU[M28UnitInfo.refiDFRange] or 0) < 26) and aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= 80*aiBrain[M28Economy.refiBrainBuildRateMultiplier])
                                                                                or (oACU[refiBuildTech] >= 2 and ((oACU[M28UnitInfo.refiDFRange] or 0) < 26 or aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= 150 * aiBrain[M28Economy.refiBrainBuildRateMultiplier]))
                                                                                or (GetGameTimeSeconds() >= 720 and not(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and (M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs] or GetGameTimeSeconds() >= 840))) then
                                                                    if (aiBrain:GetEconomyStoredRatio('ENERGY') <= 0.8 or M28Conditions.HaveLowPower(aiBrain.M28Team)) and (not(M28Conditions.ZoneWantsT1Spam(tLZOrWZTeamData, iTeam)) or (aiBrain:GetEconomyStored('ENERGY') < 3500 and (aiBrain[M28Economy.refiNetEnergyBaseIncome] < 0 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < 0))) and ((oACU[M28UnitInfo.refiDFMassThreatOverride] or 0) <= 3000 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 150) then
                                                                        --Do we have no power of a higher tech level than our ACU in this core zone?
                                                                        local tFriendlyPower = EntityCategoryFilterDown(M28UnitInfo.refCategoryPower, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                                                        local oNearestUnderConstructionPower, iCurDist
                                                                        local iNearestUnderConstructionPower = 10000
                                                                        local iHighestTechConstructed = 0
                                                                        if M28Conditions.IsTableOfUnitsStillValid(tFriendlyPower) then
                                                                            for iUnit, oUnit in tFriendlyPower do
                                                                                if oUnit:GetFractionComplete() < 1 then
                                                                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition())
                                                                                    if iCurDist < iNearestUnderConstructionPower then
                                                                                        iNearestUnderConstructionPower = iCurDist
                                                                                        oNearestUnderConstructionPower = oUnit
                                                                                    end
                                                                                else
                                                                                    if iHighestTechConstructed < 3 then iHighestTechConstructed = math.max(iHighestTechConstructed, M28UnitInfo.GetUnitTechLevel(oUnit)) end
                                                                                end
                                                                            end
                                                                        end
                                                                        if oNearestUnderConstructionPower then
                                                                            --Build own power if ACU is far away and it's T1 power
                                                                            bBuildingOrAssistingPowerOrFactory = true
                                                                            if EntityCategoryContains(M28UnitInfo.refCategoryT1Power, oNearestUnderConstructionPower.UnitId) and iNearestUnderConstructionPower >= 30 then
                                                                                ACUActionBuildPower(aiBrain, oACU)
                                                                            else
                                                                                M28Orders.IssueTrackedRepair(oACU, oNearestUnderConstructionPower, false, 'ACUAsPwr')
                                                                            end
                                                                        else
                                                                            --build our own power if we have equal or better tech
                                                                            if iHighestTechConstructed <= 1 then
                                                                                bBuildingOrAssistingPowerOrFactory = true
                                                                                ACUActionBuildPower(aiBrain, oACU)
                                                                            else
                                                                                local sPowerBlueprintToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryPower, oACU)
                                                                                if sPowerBlueprintToBuild and M28UnitInfo.GetBlueprintTechLevel(sPowerBlueprintToBuild) >= iHighestTechConstructed then
                                                                                    bBuildingOrAssistingPowerOrFactory = true
                                                                                    ACUActionBuildPower(aiBrain, oACU)
                                                                                end
                                                                            end
                                                                        end

                                                                    end
                                                                end
                                                            end

                                                            --Check if our economy is so good that we want to run next cycle if enemy has T3 land or air to keep our ACU safe
                                                            if not(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs]) and (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] >= 30 or aiBrain[M28Economy.refiGrossMassBaseIncome] >= 16 or (aiBrain[M28Economy.refiGrossMassBaseIncome] >= 11 + (oACU[refiUpgradeCount] or 0) and (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestEnemyAirTech] >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 or M28UnitInfo.GetUnitHealthPercent(oACU) < 0.8))) then
                                                                --Consider running if enemy is at T3 or has large air to ground threat, or we have built ltos of T3
                                                                if M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] >= 3 or M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestEnemyAirTech] >= 3 or M28Team.tTeamData[aiBrain.M28Team][M28Team.refbBuiltLotsOfT3Combat] or M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftTeamEngineersBuildingExperimentals]) == false then
                                                                    if not(M28Team.tTeamData[iTeam][M28Team. refbAssassinationOrSimilar]) and M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] <= 40 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and (not(M28Team.tTeamData[aiBrain.M28Team][M28Team.refbBuiltLotsOfT3Combat]) or M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiActiveM28BrainCount] >= 3) and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] == 0 then
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Although it is quite dangerous for ACUs we wont flag that it is very dangerous just yet due to full share') end
                                                                    else
                                                                        M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs] = true
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': refbDangerousForACUs true for ACU due to general mass income level so will retreat with ACU if not in adjacent LZ from now on. M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]..'; M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestEnemyAirTech]='..M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestEnemyAirTech]..'; M28Team.tTeamData[aiBrain.M28Team][M28Team.refbBuiltLotsOfT3Combat]='..tostring(M28Team.tTeamData[aiBrain.M28Team][M28Team.refbBuiltLotsOfT3Combat])..'; Is table of engis building experimetnals empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftTeamEngineersBuildingExperimentals]))) end
                                                                    end
                                                                end
                                                            end
                                                            --Consider building naval fac or torp launcher in this zone if in water zone and lack torpedo upgrade and it is early game
                                                            if iPlateauOrZero == 0 and not(bBuildingOrAssistingPowerOrFactory) and (oACU[M28UnitInfo.refiAntiNavyRange] or 0) < 10 then
                                                                --Consider torp launcher if this zone wants one and not campaign map
                                                                local bWantTorpLauncher = M28Conditions.DoesACUWantToConsiderGettingNavalFactoryInCurWaterZone(oACU, aiBrain, iTeam, tLZOrWZData, tLZOrWZTeamData, iLandOrWaterZone, false, false, true)
                                                                --Further check due to delay between ACU completing torp launcher and it being updated in the LZ
                                                                if bWantTorpLauncher and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                                                    local tFriendlyTorpLauncher = EntityCategoryFilterDown(M28UnitInfo.refCategoryTorpedoLauncher, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                                                    if M28Utilities.IsTableEmpty(tFriendlyTorpLauncher) == false then
                                                                        for iTorp, oTorp in tFriendlyTorpLauncher do
                                                                            if not(oTorp.Dead) and oTorp:GetFractionComplete() == 1 then
                                                                                if bDebugMessages == true then LOG(sFunctionRef..': We already have torp launcher and presumably just not updated threat yet so wont get another') end
                                                                                bWantTorpLauncher = false
                                                                                break
                                                                            end
                                                                        end
                                                                    end
                                                                end
                                                                if bWantTorpLauncher and (tLZOrWZTeamData[M28Map.subreftiBPWantedByAction][M28Engineer.refActionBuildTorpLauncher] or 0) > 0 and (tLZOrWZTeamData[M28Map.subrefWZTThreatAllyLauncherDefenceTotal] or 0) == 0 and ((M28Team.tTeamData[iTeam][M28Team.refiEnemySubCount] or 0) > 0 or tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) and not(M28Map.bIsCampaignMap) then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to build torp launcher with ACU to protect naval fac') end
                                                                    bBuildingOrAssistingPowerOrFactory = true
                                                                    ACUBuildUnit(aiBrain, oACU, M28Engineer.tiActionCategory[M28Engineer.refActionBuildT1TorpLauncher], 30, 30, nil, nil, nil)
                                                                end


                                                                if not(bBuildingOrAssistingPowerOrFactory) and M28Conditions.DoesACUWantToConsiderGettingNavalFactoryInCurWaterZone(oACU, aiBrain, iTeam, tLZOrWZData, tLZOrWZTeamData, iLandOrWaterZone, false, false) then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Want ACU to build naval fac in this zone') end
                                                                    ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryNavalFactory, M28Engineer.refActionBuildNavalFactory)
                                                                    bBuildingOrAssistingPowerOrFactory = true
                                                                end

                                                                --If already in water zone and have naval fac on naval map then get preemptive torp launcher
                                                                if bWantTorpLauncher and not(bBuildingOrAssistingPowerOrFactory) and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to build pre-emptive torp launcher with ACU to protect naval fac, subrefWZTThreatAllyLauncherDefenceTotal='..tLZOrWZTeamData[M28Map.subrefWZTThreatAllyLauncherDefenceTotal]..'; iLandOrWaterZone='..iLandOrWaterZone) end
                                                                    bBuildingOrAssistingPowerOrFactory = true
                                                                    ACUBuildUnit(aiBrain, oACU, M28Engineer.tiActionCategory[M28Engineer.refActionBuildT1TorpLauncher], 30, 30, nil, nil, nil)
                                                                end
                                                            end


                                                            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if we want ACU to build power, bBuildingOrAssistingPowerOrFactory='..tostring(bBuildingOrAssistingPowerOrFactory)) end

                                                            if not(bBuildingOrAssistingPowerOrFactory) then

                                                                --If have orders for ACU but no land zone then wait until it is in a land zone again
                                                                if not(iLandOrWaterZone) or (iPlateauOrZero == 0 and not(tLZOrWZTeamData[M28Map.subrefWZbContainsUnderwaterStart])) then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': ACU isnt in a land zone, if has no orders will tell it to retreat to start position, oACU[M28Orders.refiOrderCount]='..(oACU[M28Orders.refiOrderCount] or 'nil')..'; ACU unit state='..M28UnitInfo.GetUnitState(oACU)..'; reprs of last order='..reprs(oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]])) end
                                                                    if (oACU[M28Orders.refiOrderCount] or 0) == 0 then

                                                                        M28Orders.IssueTrackedMove(oACU, M28Map.GetPlayerStartPosition(oACU:GetAIBrain()), 5, false, 'NLZRun')
                                                                    elseif oACU:IsUnitState('Attacking') and M28UnitInfo.IsUnitUnderwater(oACU) and not(tLZOrWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) then
                                                                        --Came across rare issue where ACU has attack-move order, that doesnt get refreshed, but ACU gets stuck not moving in the water, its unit state when this happened was attacking, and its last order was refiOrderIssueAggressiveMove; the below is a workaround as in some cases want ACU to advance where this is the case, in others want it to retreat
                                                                        local iCurWaterZone = M28Map.GetWaterZoneFromPosition(oACU:GetPosition())
                                                                        if M28UnitInfo.GetUnitHealthPercent(oACU) < 0.95 or not(iCurWaterZone) then

                                                                            M28Orders.IssueTrackedMove(oACU, M28Map.GetPlayerStartPosition(oACU:GetAIBrain()), 5, false, 'NLZRn')
                                                                        else
                                                                            --Look for nearest land zone and move here
                                                                            local iPond = M28Map.tiPondByWaterZone[iCurWaterZone]
                                                                            local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iCurWaterZone]
                                                                            local tLZMidpointToMoveTo
                                                                            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
                                                                                for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                                                                                    local tAltLZ = M28Map.tAllPlateaus[tSubtable[M28Map.subrefWPlatAndLZNumber][1]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefWPlatAndLZNumber][2]]
                                                                                    if tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsSupport] then
                                                                                        tLZMidpointToMoveTo = tAltLZ[M28Map.subrefMidpoint]
                                                                                        break
                                                                                    end
                                                                                end
                                                                            end
                                                                            if bDebugMessages == true then LOG(sFunctionRef..': tLZMidpointToMoveTo after checking if have adjacent land zones that want support='..repru(tLZMidpointToMoveTo)) end

                                                                            if not(tLZMidpointToMoveTo) then tLZMidpointToMoveTo = M28Map.GetPlayerStartPosition(oACU:GetAIBrain()) end

                                                                            M28Orders.IssueTrackedMove(oACU, tLZMidpointToMoveTo, 5, false, 'ACUWtr')

                                                                        end
                                                                    end
                                                                else
                                                                    --Are there enemies in this LZ? If so then attack them
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy units for this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]))) end
                                                                    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) == false and iPlateauOrZero > 0 and AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                                                                        --(Do nothing further - will ahve given the order)
                                                                        --If enemy ACU in this zone, then consider getting emergency support
                                                                        ConsiderIfACUNeedsEmergencySupport(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)
                                                                    else
                                                                        if oACU[refbDoingInitialBuildOrder] and (M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) or not(DoesACUWantToRun(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU))) then
                                                                            GetACUEarlyGameOrders(aiBrain, oACU)

                                                                            --Have we finished our initial build order? (even if we stil lahve some early game orders)
                                                                            if bDebugMessages == true then LOG(sFunctionRef..': Checking if have finished initial build order, Economy stored mass='..aiBrain:GetEconomyStored('MASS')..'; Gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; Gross energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]) end
                                                                            if not(oACU:IsUnitState('Building')) and aiBrain:GetEconomyStored('MASS') == 0 and aiBrain[M28Economy.refiGrossMassBaseIncome] >= 0.3 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 15 then
                                                                                bDoingInitialBuildOrder = false
                                                                            end
                                                                        else
                                                                            --If we are reclaiming or building then dont do anything
                                                                            if bDebugMessages == true then
                                                                                LOG(sFunctionRef..': Arent doing initial build order and dont want to run, ACU unit state='..M28UnitInfo.GetUnitState(oACU)..'; Brain mass stored%='..aiBrain:GetEconomyStoredRatio('MASS')..'; If are nearby enemies then will list out, is table of nearby enemies empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]))..'; oACU[M28UnitInfo.refiDFRange]='..(oACU[M28UnitInfo.refiDFRange] or 'nil')..'; ACU position='..repru(oACU:GetPosition())..'; ACU team='..oACU:GetAIBrain().M28Team)
                                                                                if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                                                                                    LOG(sFunctionRef..': are we close to nearby units='..tostring(M28Conditions.CloseToEnemyUnit(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftoNearestDFEnemies], 12 , aiBrain.M28Team, true, math.max(25, oACU[M28UnitInfo.refiDFRange] + 12))))
                                                                                    for iUnit, oUnit in tLZOrWZTeamData[M28Map.reftoNearestDFEnemies] do
                                                                                        LOG(sFunctionRef..': Entry '..iUnit..' is unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' which is '..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition())..' with range '..(oUnit[M28UnitInfo.refiDFRange] or 'nil'))
                                                                                    end
                                                                                end
                                                                            end
                                                                            local iNearbyEnemyAttackRangeThreshold = 12
                                                                            if tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] and (oACU:IsUnitState('Building') or oACU:IsUnitState('Capturing') or oACU:IsUnitState('Repairing') or oACU:IsUnitState('Guarding') or (oACU:IsUnitState('Reclaiming') and aiBrain:GetEconomyStoredRatio('MASS') <= 0.6)) then iNearbyEnemyAttackRangeThreshold = 4 end
                                                                            --No nearby enemies - consider building power if have low level of it and lots of mass
                                                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want more power for high mass levels, or want to attack nearby enemies, or get nearby reclaim, Is table of nearest DF enemies empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]))..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; not(M28Conditions.HaveLowMass(aiBrain)='..tostring(not(M28Conditions.HaveLowMass(aiBrain)))..'; Want more power='..tostring(M28Conditions.WantMorePower(iTeam))..'; tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim]='..(tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim] or 'nil')) end
                                                                            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 50 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.3 and not(M28Conditions.HaveLowMass(aiBrain)) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 2 and oACU.HasEnhancement and oACU:HasEnhancement('AdvancedEngineering'))) and (M28Conditions.WantMorePower(iTeam) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.7) then
                                                                                ACUActionBuildPower(aiBrain, oACU)
                                                                                --Is there an enemy unit nearby that we want to attack?
                                                                                --CloseToEnemyUnit(tStartPosition, tUnitsToCheck,                       iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange)
                                                                            elseif (oACU[M28UnitInfo.refiDFRange] or 0) > 0 and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) == false and M28Conditions.CloseToEnemyUnit(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftoNearestDFEnemies], iNearbyEnemyAttackRangeThreshold , aiBrain.M28Team, true, math.max(25, oACU[M28UnitInfo.refiDFRange] + iNearbyEnemyAttackRangeThreshold)) and AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                                                                                if bDebugMessages == true then LOG(sFunctionRef..': Are close to enemy units so will attack rather than considering upgrades or building mexes etc.') end
                                                                                --If lots of reclaim in this zone consider getting it
                                                                            elseif oACU[refiUpgradeCount] > 0 and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) == false and iPlateauOrZero > 0 and HaveNearbyVulnerableEnemyACUToAttack(oACU, iTeam, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iLandOrWaterZone) then
                                                                                if bDebugMessages == true then LOG(sFunctionRef..': Are going to try and attack nearby vulnerable enemy ACU') end
                                                                            elseif tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim] >= 300 and not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and aiBrain:GetEconomyStoredRatio('MASS') <= 0.9 and ((oACU[M28UnitInfo.refiDFMassThreatOverride] or 0) <= 5000 or not(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) or tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim] >= 1.5*oACU[M28UnitInfo.refiDFMassThreatOverride] or 0) and (tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.45 or tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim] >= 3500 or not(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) or (M28Conditions.GetNumberOfConstructedUnitsMeetingCategoryInZone(tLZOrWZTeamData, M28UnitInfo.refCategoryLandFactory) == 0 and M28Conditions.GetNumberOfConstructedUnitsMeetingCategoryInZone(tLZOrWZTeamData, M28UnitInfo.refCategoryEngineer) <= math.max(1, tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim] / 1000))) and ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, false, nil, nil, nil) then
                                                                                if bDebugMessages == true then LOG(sFunctionRef..': Lots of reclaim so will stay here, signif reclaim='..tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim]..'; Mod dist%='..tLZOrWZTeamData[M28Map.refiModDistancePercent]..'; Enemies in this or adjacent zone='..tostring(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or false)) end
                                                                            elseif tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim] >= 40 and ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, true, nil, nil, nil) then
                                                                                if bDebugMessages == true then LOG(sFunctionRef..': Getting reclaim in build radius') end
                                                                            else
                                                                                if bDebugMessages == true then LOG(sFunctionRef..': Checking if ACU unit state not important so we can consider doing other things, ACU state='..M28UnitInfo.GetUnitState(oACU)..'; Mass stored ratio='..aiBrain:GetEconomyStoredRatio('MASS')..'; Is unit state building='..tostring(oACU:IsUnitState('Building'))..'; Is unit state repairing='..tostring(oACU:IsUnitState('Repairing'))..'; Is unit state reclaiming='..tostring(oACU:IsUnitState('Reclaiming'))..'; Is unit state guarding='..tostring(oACU:IsUnitState('Guarding'))) end
                                                                                if not(oACU:IsUnitState('Building')) and not(oACU:IsUnitState('Capturing')) and (not(oACU:IsUnitState('Repairing')) or oACU:IsUnitState('Guarding')) and (not(oACU:IsUnitState('Reclaiming')) or aiBrain:GetEconomyStoredRatio('MASS') >= 0.8) then
                                                                                    --Do we want to get an upgrade?
                                                                                    local sUpgradeToGet, bIgnoreOtherUpgradeConditions = GetACUUpgradeWanted(oACU, nil, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero)
                                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Do we have an upgrade we want to get? sUpgradeToGet='..(sUpgradeToGet or 'nil')) end
                                                                                    if sUpgradeToGet then
                                                                                        --Do we have a friendly nearby ugprading ACU? If so then assist its upgrade first before getting ours
                                                                                        if bIgnoreOtherUpgradeConditions or not(AssistNearbyUpgradingACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, 40)) then
                                                                                            --Are we safe to get the upgrade here? if not then retreat
                                                                                            if bDebugMessages == true then LOG(sFunctionRef..': Will check if safe to get upgrade for oACU, oACU='..(oACU.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oACU) or 'nil')..'; Brain='..oACU:GetAIBrain().Nickname) end
                                                                                            if bIgnoreOtherUpgradeConditions or M28Conditions.SafeToUpgradeUnit(oACU) then
                                                                                                if bDebugMessages == true then LOG(sFunctionRef..': Safe to get upgrade here so will proceed with upgrading ACU, sUpgradeToGet='..(sUpgradeToGet or 'nil')..' brain='..oACU:GetAIBrain().Nickname..'; Has enhancement='..tostring(oACU:HasEnhancement(sUpgradeToGet))) end
                                                                                                if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastIssuedACUEnhancementOrder] or -100) >= 2 or (oACU[M28Orders.refiTimeOfLastRemovalUpgrade] and GetGameTimeSeconds() - oACU[M28Orders.refiTimeOfLastRemovalUpgrade] <= 10) or oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] == sUpgradeToGet then
                                                                                                    M28Orders.IssueTrackedEnhancement(oACU, sUpgradeToGet, false, 'ACUUpr')
                                                                                                end
                                                                                            else
                                                                                                --Retreat
                                                                                                local tRallyPoint = M28Land.GetNearestLandRallyPoint(tLZOrWZData, oACU:GetAIBrain().M28Team, iPlateauOrZero, iLandOrWaterZone, 2)
                                                                                                if bDebugMessages == true then LOG(sFunctionRef..': Not safe to get upgrade so want to retreat until it is. tRallyPoint='..repru(tRallyPoint)..'; ACU position='..repru(oACU:GetPosition())) end
                                                                                                M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'R4UGen')
                                                                                            end
                                                                                        end
                                                                                    else
                                                                                        --We dont want an upgrade, and have no enemies in this LZ, but there might be enemies nearby (e.g. in an adjacent land zone); there might also be mexes to build or reclaim to get in this LZ - decide on what we want to do
                                                                                        --Does the LZ have uncalimed mexes?
                                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Will consider if we want to build a mex if there are any unclaimed') end
                                                                                        local iMaxSearchRange = 40
                                                                                        if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and GetGameTimeSeconds() >= 900 then iMaxSearchRange = 50
                                                                                        elseif oACU[refiUpgradeCount] > 0 then iMaxSearchRange = 30
                                                                                        end
                                                                                        if tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then iMaxSearchRange = iMaxSearchRange - 15 end
                                                                                        if iMaxSearchRange >= 5 and not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and oACU[refiUpgradeCount] > 0 and tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                                                                                            if M28Conditions.HaveEngineersOrFactoriesInZone(tLZOrWZTeamData) then
                                                                                                iMaxSearchRange = 5
                                                                                            end
                                                                                        end

                                                                                        if not(ConsiderBuildingMex(tLZOrWZData, tLZOrWZTeamData, oACU, iMaxSearchRange)) then
                                                                                            --Water zone specific - if underwater and is an underwater start position then do nothing
                                                                                            if iPlateauOrZero > 0 or not(tLZOrWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) then

                                                                                                --Do we want another land factory?
                                                                                                if bDebugMessages == true then LOG(sFunctionRef..': No mexes to build ni this LZ, seeing if we want another land factory') end
                                                                                                if not(ConsiderGettingExtraLandFactory(tLZOrWZData, tLZOrWZTeamData, oACU, iPlateauOrZero, iLandOrWaterZone)) then
                                                                                                    --Are there enemies in an adjacent LZ? in which case want to consider attacking them
                                                                                                    if ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, true) or (M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) == false and AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)) then
                                                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try getting reclaim in range or attacking enemy in this zone') end
                                                                                                    else
                                                                                                        --ACU is in a zone with lots of reclaim - consider prioritising this over attacking nearby enemies
                                                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if reclaim in this zone valuable enough to focus on it instead of enemies; Cur mass stored='..aiBrain:GetEconomyStoredRatio('MASS')..'; Signif Reclaim in zone='..tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim]..'; S value of zone='..tLZOrWZTeamData[M28Map.subrefLZSValue]) end
                                                                                                        --Only consider reclaim if min value of a wreck is 40 - dont want to waste ACU time on harder to get reclaim
                                                                                                        local iMinIndivReclaimThreshold = 40
                                                                                                        if M28Conditions.ZoneWantsT1Spam(tLZOrWZTeamData, iTeam) then
                                                                                                            if aiBrain:GetEconomyStored('MASS') < 50 then iMinIndivReclaimThreshold = 60 else iMinIndivReclaimThreshold = 100 end
                                                                                                        end
                                                                                                        if tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim] >= 300 and not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and tLZOrWZTeamData[M28Map.subrefLZSValue] <= 200 and aiBrain:GetEconomyStoredRatio('MASS') <= 0.6 and ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, false, iMinIndivReclaimThreshold) then
                                                                                                            if bDebugMessages == true then LOG(sFunctionRef..': Lots of reclaim in area so will focus on that') end
                                                                                                        else
                                                                                                            if AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                                                                                                                if bDebugMessages == true then LOG(sFunctionRef..': Attacking enemies in adjacent zone') end
                                                                                                            else
                                                                                                                local bOnlyConsiderInBuildRange = false
                                                                                                                if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and (not(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) or (GetGameTimeSeconds() <= 300 and aiBrain[M28Economy.refiGrossMassBaseIncome] <= 4)) then bOnlyConsiderInBuildRange = true
                                                                                                                elseif oACU[refiUpgradeCount] > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] <= 2 and not(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs]) and tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.55 and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.9 then
                                                                                                                    bOnlyConsiderInBuildRange = true
                                                                                                                elseif M28Conditions.ZoneWantsT1Spam(tLZOrWZTeamData, iTeam) then bOnlyConsiderInBuildRange = true
                                                                                                                end
                                                                                                                if bDebugMessages == true then LOG(sFunctionRef..': Dont want to build mex, will cehck if want to get reclaim, bOnlyConsiderInBuildRange='..tostring(bOnlyConsiderInBuildRange)..'; Mod dist='..tLZOrWZTeamData[M28Map.refiModDistancePercent]..'; Enemy ground tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]) end
                                                                                                                if not(ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, bOnlyConsiderInBuildRange)) then
                                                                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Dont want to get reclaim, will see if want to attack adjacent enemies; are there adjacent enemies='..tostring(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]='..tostring(tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ])) end
                                                                                                                    if tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                                                                                                                        --Do nothing - will have given the order
                                                                                                                    else
                                                                                                                        --Is a friendly ACU getting an upgrade in this or an adjacent zone? If so then assist it
                                                                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Checking if we want to assist a friendly nearby upgrading ACU if there is one') end
                                                                                                                        if not(AssistNearbyUpgradingACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)) then
                                                                                                                            --Search for any mexes nearby
                                                                                                                            if bDebugMessages == true then LOG(sFunctionRef..': Will search for unbuilt mexes in the zone with no search radius (unless have a big gun and not early on), oACU[M28UnitInfo.refiDFMassThreatOverride]='..(oACU[M28UnitInfo.refiDFMassThreatOverride] or 'nil')..'; subrefbEnemiesInThisOrAdjacentLZ='..tostring(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or false)) end
                                                                                                                            if M28Conditions.HaveEngineersOrFactoriesInZone(tLZOrWZTeamData) or (oACU[refiUpgradeCount] >= 2 and not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and GetGameTimeSeconds() >= 180 and (oACU[M28UnitInfo.refiDFMassThreatOverride]) >= 4000) or not(ConsiderBuildingMex(tLZOrWZData, tLZOrWZTeamData, oACU)) then
                                                                                                                                if bDebugMessages == true then LOG(sFunctionRef..': Will consider moving to another land zone as nothing to do in this one') end
                                                                                                                                if not(MoveToOtherLandZone(iPlateauOrZero, tLZOrWZData, iLandOrWaterZone, oACU)) then
                                                                                                                                    --Do we have any reclaim nearby?
                                                                                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Very low priority and threshold reclaim checker about to be checked') end
                                                                                                                                    if not(ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, false, 0.1, 0.1, 0.8)) then
                                                                                                                                        --Assist any upgrading mex or under construction storage if we have power but low mass

                                                                                                                                        if aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.99 and AssistBuildingUpgradeOrStorageConstruction(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                                                                                                                                            if bDebugMessages == true then LOG(sFunctionRef..': Are assisting am ex upgrade or storage construction') end
                                                                                                                                            --Backup - assist nearest factory
                                                                                                                                        else
                                                                                                                                            if bDebugMessages == true then LOG(sFunctionRef..': ACU no longer doing iniitial BO; Will give backup assist factory order if not building or guarding, ACU unit state='..M28UnitInfo.GetUnitState(oACU)) end
                                                                                                                                            if not(oACU:IsUnitState('Building')) and not(oACU:IsUnitState('Guarding')) and not(oACU:IsUnitState('Capturing')) then
                                                                                                                                                local tAllFactories = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryFactory, false, true)
                                                                                                                                                if M28Utilities.IsTableEmpty(tAllFactories) == false then
                                                                                                                                                    local oNearestFactory = M28Utilities.GetNearestUnit(tAllFactories, oACU:GetPosition(), true, M28Map.refPathingTypeHover)
                                                                                                                                                    if M28UnitInfo.IsUnitValid(oNearestFactory) then
                                                                                                                                                        M28Orders.IssueTrackedGuard(oACU, oNearestFactory, false)
                                                                                                                                                    end
                                                                                                                                                end
                                                                                                                                            end
                                                                                                                                        end
                                                                                                                                    end
                                                                                                                                end
                                                                                                                            end
                                                                                                                        end
                                                                                                                    end
                                                                                                                end
                                                                                                            end
                                                                                                        end
                                                                                                    end
                                                                                                end
                                                                                            end
                                                                                        end
                                                                                    end
                                                                                end
                                                                            end
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    if oACU[refbACUHasBeenGivenABuildOrderRecently] and not(M28Conditions.DoesACUHaveValidOrder(oACU)) and (M28Orders.bDontConsiderCombinedArmy or oACU.M28Active) then M28Engineer.ClearEngineerTracking(oACU) end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, does ACU have valid order='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))..'; reprs of last order='..reprs(oACU[M28Orders.reftiLastOrders])) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DoWeStillWantToBeAggressiveWithACU(oACU)
    --Intended for early game mostly on smaller maps to make ACU more aggressive, or teamgames where we have 3+ ACUs alive
    local sFunctionRef = 'DoWeStillWantToBeAggressiveWithACU'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bStillBeAggressive = true
    local aiBrain = oACU:GetAIBrain()
    local iTeam = aiBrain.M28Team

    --Still be aggressive if are attempting a snipe
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy snipe targets empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets]))) end
    local bNotCloseToSnipeTarget = true
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets]) == false then
        for iTarget, oTarget in M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets] do
            if M28UnitInfo.IsUnitValid(oTarget) and M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), oACU:GetPosition()) <= 60 then
                bNotCloseToSnipeTarget = false
                break
            end
        end
    end
    if bNotCloseToSnipeTarget then
        if M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs] then
            bStillBeAggressive = false
        else
            --If we are going all-in on T1 spam then want to be aggressive with ACU if it has a gun
            local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oACU:GetPosition(), true, oACU:GetAIBrain().M28Team)
            if oACU[refiUpgradeCount] > 0 and M28Conditions.ZoneWantsT1Spam(tLZOrWZTeamData, iTeam) and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.7 and GetGameTimeSeconds() <= 1000 and tLZOrWZTeamData[M28Map.refiModDistancePercent] < 0.6 then
                --Will remain aggressive
            elseif M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 3 and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.9 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] or 0) < 3 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] or 0) < 2 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech] or 0) < 2 and not(M28Team.tTeamData[iTeam][M28Team. refbAssassinationOrSimilar]) then
                bStillBeAggressive = true --redundancy
            else
                --If significant time elapsed then remove this flag
                if GetGameTimeSeconds() >= 900 then
                    bStillBeAggressive = false
                else
                    local iThresholdFactor = 1 + ((M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or 1) - 1) * 0.25
                    if tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim] > 350 then iThresholdFactor = iThresholdFactor + 0.4 end
                    if M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.3 then bStillBeAggressive = false
                    elseif aiBrain[M28Economy.refiGrossMassBaseIncome] >= 5 * iThresholdFactor or (aiBrain[M28Economy.refiOurHighestFactoryTechLevel] >= 2 and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryAllAir + M28UnitInfo.refCategoryLandCombat - categories.TECH1) >= 4) then
                        bStillBeAggressive = false
                    elseif M28Map.iMapSize > 512 and tLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.4 then
                        bStillBeAggressive = false
                    elseif not(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) then
                        bStillBeAggressive = false
                    elseif M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU] and (oACU[refiUpgradeCount] or 0) == 0 then
                        bStillBeAggressive = false
                    elseif M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat) >= 50 * iThresholdFactor then
                        bStillBeAggressive = false
                    elseif M28Map.bIsCampaignMap then
                        bStillBeAggressive = false
                    elseif M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][3] > 0 or M28Conditions.GetHighestOtherTeamT3MexCount(iTeam) > 0 then
                        bStillBeAggressive = false
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bStillBeAggressive
end

function ManageACU(aiBrain, oACUOverride)
    local sFunctionRef = 'ManageACU'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --First get our ACU
    local oACU = oACUOverride
    local iWaitCount = 0
    local iACUSearchCategory = categories.COMMAND
    while not(oACU) do
        local tOurACU = aiBrain:GetListOfUnits(iACUSearchCategory, false, true)
        if bDebugMessages == true then LOG(sFunctionRef..': Searching for ACUs at time='..GetGameTimeSeconds()..'; Is tOurACU empty='..tostring(M28Utilities.IsTableEmpty(tOurACU))) end
        if M28Utilities.IsTableEmpty(tOurACU) == false then
            for _, oUnit in tOurACU do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                if M28UnitInfo.IsUnitValid(oUnit) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have an ACU so will break') end
                    oACU = oUnit
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Looking for ACU that we own, is oACU valid='..tostring(M28UnitInfo.IsUnitValid(oACU))..'; oACU='..(oACU.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oACU) or 'nil')) end
        if oACU then
            oACU[refbDoingInitialBuildOrder] = true
            break
        end
        iWaitCount = iWaitCount + 1
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if iWaitCount >= 360 then --No ACU after 6m, see if we have any SACU we could use instead
            iACUSearchCategory = iACUSearchCategory + categories.SUBCOMMANDER
            -- if iWaitCount >= 480 then
            --iACUSearchCategory = iACUSearchCategory + M28UnitInfo.refCategoryEngineer
            if iWaitCount >= 600 then
                M28Utilities.ErrorHandler('No ACU or SACU after '..iWaitCount..' ticks so will abort')
                break
            end
            --end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if have oACU, oACU='..(oACU.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oACU) or 'nil')) end
    if oACU then

        --Wait until ok for us to give orders
        if bDebugMessages == true then LOG(sFunctionRef..': Will wait until after 4.5s before giving ACU orders, gametime='..GetGameTimeSeconds()) end
        while (GetGameTimeSeconds() <= 4.5) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end

        --Campaign specific - check if friendly units should gift to M28AI if near start of game (to avoid e.g. fletcher gating in on M5 and being gifted M28 player units)
        if M28Map.bIsCampaignMap and GetGameTimeSeconds() <= 180 then
            ForkThread(M28Overseer.CheckForAlliedCampaignUnitsToShareAtGameStart, oACU:GetAIBrain())
        end

        if M28UnitInfo.IsUnitValid(oACU) and not(M28UnitInfo.IsUnitValid(aiBrain[refoPrimaryACU])) then
            aiBrain[refoPrimaryACU] = oACU
        end

        --Make sure ACU is recorded
        M28Team.AssignUnitToLandZoneOrPond(aiBrain, oACU, false, false, true)

        --Make sure we have recorded this zone as a core zone
        --[[local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oACU:GetPosition())
        local tLZTeamData
        if iPlateauOrZero > 0 and (iLandOrWaterZone or 0) > 0 and GetGameTimeSeconds() <= 10 then
            tLZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][oACU:GetAIBrain().M28Team]
        end--]]

        oACU[refiUpgradeCount] = 0
        oACU[refbUseACUAggressively] = true
        oACU[refiBuildTech] = 1
        if EntityCategoryContains(categories.SUBCOMMANDER * categories.TECH3, oACU.UnitId) or EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oACU.UnitId) then
            oACU[refiBuildTech] = M28UnitInfo.GetUnitTechLevel(oACU)
        elseif oACU.HasEnhancement then
            if oACU:HasEnhancement('AdvancedEngineering') then oACU[refiBuildTech] = 2
            elseif oACU:HasEnhancement('T3Engineering') then oACU[refiBuildTech] = 3
            end
        end

        if aiBrain.HostileCampaignAI and tonumber(ScenarioInfo.Options.CmpAIDelay) > GetGameTimeSeconds() then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(tonumber(ScenarioInfo.Options.CmpAIDelay) - GetGameTimeSeconds())
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end

        --If this is an ACU then add to table of friendly ACUs, and set weapon prioritisation
        if EntityCategoryContains(categories.COMMAND, oACU.UnitId) then
            table.insert(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftM28ACUs], oACU)
            M28UnitInfo.SetUnitWeaponTargetPriorities(oACU, M28UnitInfo.refWeaponPriorityACU, false)
            oACU[M28UnitInfo.refbUsingDefaultWeaponPriority] = true
        end

        if oACU[M28UnitInfo.refbEasyBrain] and oACU.SetAutoOvercharge then
            --Enable autoovercharge if have easy mode ACU
            local bHaveAutoOvercharge = false
            for iWeapon, tWeapon in oACU:GetBlueprint() do
                if tWeapon.Label == 'AutoOverCharge' then
                    bHaveAutoOvercharge = true
                    break
                end
            end
            if bHaveAutoOvercharge then
                oACU:SetAutoOvercharge(true)
            end
        end

        while M28UnitInfo.IsUnitValid(oACU) do
            oACU[refbTreatingAsACU] = true

            ForkThread(GetACUOrder, aiBrain, oACU)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function ConsiderIfACUNeedsEmergencySupport(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)
    --Updates flag on the zone ACU is in to indicate it needs help from tanks (i.e. it's facing a ground based threat)
    local sFunctionRef = 'ConsiderIfACUNeedsEmergencySupport'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; Health percent='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; Enemies in this or adjacent LZ='..tostring(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or false)..'; Core bse='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or false)) end
    if iPlateauOrZero > 0 and tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and M28UnitInfo.GetUnitHealthPercent(oACU) < 0.98 and (not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) or ((tLZOrWZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) >= 200 and GetGameTimeSeconds() - (oACU[M28UnitInfo.refiLastWeaponEvent] or 0) <= 10)) then
        --ACU is damaged to some extent, outside core zone (or in core zone with enemies and in combat), and there are enemy ground units nearby
        local iEnemyCombatThreat = (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
        local iTeam = oACU:GetAIBrain().M28Team
        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false then
            --Include enemy combat units in adjacent zones if they are close to the ACU
            local tEnemyUnitsNearby = {}
            local iDistThreshold = 30 --This much dist until the unit will be in range of ACU for it to be included
            for iEntry, iAdjLZ in tLZOrWZData[M28Map.subrefLZAdjacentLandZones] do
                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                if (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) > 50 and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftoNearestCombatEnemies]) == false then
                    for iUnit, oUnit in tAdjLZTeamData[M28Map.reftoNearestCombatEnemies] do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[M28UnitInfo.refiDFRange]='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Dist to ACU='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition())) end
                            if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then
                                if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition()) - oUnit[M28UnitInfo.refiDFRange] <= iDistThreshold then
                                    table.insert(tEnemyUnitsNearby, oUnit)
                                end
                            end
                        end
                    end
                end
            end

            if M28Utilities.IsTableEmpty(tEnemyUnitsNearby) == false then
                iEnemyCombatThreat = iEnemyCombatThreat + M28UnitInfo.GetCombatThreatRating(tEnemyUnitsNearby, true, false, false, false, false, false, false)
            end
        end
        local iThreatRatio = 0.8
        if oACU[refbUseACUAggressively] then iThreatRatio = 1.1 end
        if M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.75 then iThreatRatio = iThreatRatio * 1.26 end --i.e. if just us vs enemy ACU with similar stats shouldnt trigger unless our healt his getting low
        if bDebugMessages == true then LOG(sFunctionRef..': ACU threat='..M28UnitInfo.GetCombatThreatRating({oACU}, false, false)..'; iThreatRatio='..iThreatRatio..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; Is table of ACUs in the LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefAlliedACU]))) end
        if M28UnitInfo.GetCombatThreatRating({oACU}, false, false) * iThreatRatio < iEnemyCombatThreat then
            tLZOrWZTeamData[M28Map.refbACUInTrouble] = true
            local iACUValueIncrease = GetValueIncreaseForACUInTrouble(iTeam)
            tLZOrWZTeamData[M28Map.subrefLZTValue] = math.max((tLZOrWZTeamData[M28Map.subrefLZTValue] or 0), iACUValueIncrease)
            if bDebugMessages == true then LOG(sFunctionRef..': Flagging that ACU is in trouble, tLZTeamData[M28Map.subrefLZTValue]='..(tLZOrWZTeamData[M28Map.subrefLZTValue] or 'nil')) end
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefAlliedACU]) then M28Utilities.ErrorHandler('ACU in trouble but not recorded against this LZ') end
            --Consider chat message if ACU health <75% and are in the first 20m
            if GetGameTimeSeconds() <= 1200 and M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.7 then
                if M28Orders.bDontConsiderCombinedArmy or oACU.M28Active then
                    ForkThread(M28Chat.ConsiderMessageForACUInTrouble, oACU, oACU:GetAIBrain())
                end
            end

        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tLZOrWZTeamData[M28Map.refbACUInTrouble]='..tostring(tLZOrWZTeamData[M28Map.refbACUInTrouble] or false)..'; P'..iPlateauOrZero..'Z'..iLandOrWaterZone) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetValueIncreaseForACUInTrouble(iTeam)
    local iCurValue = 1000
    --Increase by more if in noshare or assassination
    if M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar] then
        iCurValue = iCurValue + 20000
    end
    return iCurValue
end

function AssistNearbyUpgradingACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, iOptionalMaxDistOverride)
    local iTeam = oACU:GetAIBrain().M28Team
    if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 and M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingACUs]) then
        local iCurDist
        local iClosestDist = (iOptionalMaxDistOverride or 80) --dont want to assist ACU further away than this
        if oACU[refiUpgradeCount] > 0 and not(oACU:HasEnhancement('AdvancedEngineering')) then iClosestDist = math.min(10, iClosestDist) end

        local oClosestUpgradingACU
        for iUpgradingACU, oUpgradingACU in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingACUs] do
            if not(oUpgradingACU == oACU) then
                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUpgradingACU:GetPosition(), oACU:GetPosition())
                if iCurDist < iClosestDist then
                    if NavUtils.GetLabel(M28Map.refPathingTypeHover, oUpgradingACU:GetPosition()) == iPlateauOrZero or (iPlateauOrZero == 0 and NavUtils.GetLabel(M28Map.refPathingTypeHover, oUpgradingACU:GetPosition()) == NavUtils.GetLabel(M28Map.refPathingTypeHover, oACU:GetPosition())) then
                        if oUpgradingACU:GetWorkProgress() <= 0.75 or iCurDist <= 40 then
                            iClosestDist = iCurDist
                            oClosestUpgradingACU = oUpgradingACU
                        end
                    end
                end
            end

        end
        if oClosestUpgradingACU then
            M28Orders.IssueTrackedGuard(oACU, oClosestUpgradingACU, false, 'ACUAstU', false)
            return true
        end
    end
end

function CheckForNearbyMobileShieldToRequisition(oACU, tLZOrWZData, tLZOrWZTeamData, iTeam, iPlateauOrZero)
    local sFunctionRef = 'CheckForNearbyMobileShieldToRequisition'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    
    if not(M28UnitInfo.IsUnitValid(oACU[M28Land.refoAssignedMobileShield])) and iPlateauOrZero > 0 then
        oACU[M28Land.refoAssignedMobileShield] = nil
        --Do we have access to T2 land, and aren't in our core base (hiding)?
        if bDebugMessages == true then LOG(sFunctionRef..': Considering ACU owned by brain '..oACU:GetAIBrain().Nickname..'; Is in core base='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase])..'; Highest team factory tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]..'; Cur mobile shields on team='..M28Conditions.GetCurrentM28UnitsOfCategoryInTeam(M28UnitInfo.refCategoryMobileLandShield, iTeam)) end
        if not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 2 then
            if M28Conditions.GetCurrentM28UnitsOfCategoryInTeam(M28UnitInfo.refCategoryMobileLandShield, iTeam) > 0 then
                --Cycle through this zone and adjacent zones looking for mobile shields
                local bSearchForShield = true
                local iCurDist
                local iClosestDist = 100000
                local oClosestShield
                local iCurShield, iMaxShield
                function CheckZoneForShields(tCurLZTeamData)
                    local tShieldsInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryMobileLandShield, tCurLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tShieldsInZone) == false then
                        for iShield, oShield in tShieldsInZone do
                            if M28UnitInfo.IsUnitValid(oShield) and oShield:GetFractionComplete() == 1 then
                                iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to requisition shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; Dist to ACU='.. M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oACU:GetPosition())..'; iClosestDist='..iClosestDist) end
                                if iCurShield > 0 and iCurShield > iMaxShield * 0.6 and (not(oShield[M28Land.refoMobileShieldTarget].UnitId) or not(EntityCategoryContains(categories.COMMAND, oShield[M28Land.refoMobileShieldTarget].UnitId))) then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oACU:GetPosition())
                                    if M28UnitInfo.IsUnitValid(oShield[M28Land.refoMobileShieldTarget]) then iCurDist = iCurDist + 15 end --want to favour an unassigned nearby shield in the unlikely event we have one
                                    if iCurDist < iClosestDist then
                                        iClosestDist = iCurDist
                                        oClosestShield = oShield
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': oClosestShield='..(oClosestShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestShield) or 'nil')) end
                    if oClosestShield then
                        bSearchForShield = false
                        if M28UnitInfo.IsUnitValid(oClosestShield[M28Land.refoMobileShieldTarget]) then
                            oClosestShield[M28Land.refoMobileShieldTarget][M28Land.refoAssignedMobileShield] = nil
                        end
                        oClosestShield[M28Land.refoMobileShieldTarget] = oACU
                        oACU[M28Land.refoAssignedMobileShield] = oClosestShield
                        M28Land.MoveToShieldTarget(oClosestShield, tCurLZTeamData[M28Map.reftClosestEnemyBase])
                    end
                end
                CheckZoneForShields(tLZOrWZTeamData)
                if bSearchForShield and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZOrWZData[M28Map.subrefLZAdjacentLandZones] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Searching in iAdjLZ='..iAdjLZ..' for mobile shields') end
                        CheckZoneForShields(M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam])
                        if not(bSearchForShield) then break end
                    end
                end
            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function HaveActionForACUAsEngineer(oACU, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iLandOrWaterZone)
    --Intended where ACU has >=T2, returns true if we are giving the ACU a build order
    local sFunctionRef = 'HaveActionForACUAsEngineer'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bGivenOrder = false
    if oACU[refiBuildTech] >= 2 then
        local aiBrain = oACU:GetAIBrain()
        local iTeam = aiBrain.M28Team
        --Simple logic for now - only build more like an engineer if in core zone, and only if not stalling
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if have at least some mass stored, and arent stalling mass, and are in core base, mass stored='..aiBrain:GetEconomyStored('MASS')..'; Are stalling mass='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass])..'; In core base='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase])) end
        if iPlateauOrZero > 0 and aiBrain:GetEconomyStored('MASS') > 0 and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) and (tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] >= 4) then
            --Emergency T2 PD if nearby enemies and we lack at least 2 (unless we have gun ACU)
            if tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and (oACU[M28UnitInfo.refiDFRange] < 30 or (oACU[refiBuildTech] >= 3 and not(M28Conditions.HaveLowPower(iTeam)) and not(M28Conditions.TeamHasLowMass(iTeam)))) then
                local iExistingLRPDThreat = 0
                if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
                    for iRange, iThreat in tLZOrWZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                        if iRange >= 40 then
                            iExistingLRPDThreat = iExistingLRPDThreat + iThreat
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to build PD, iExistingLRPDThreat='..iExistingLRPDThreat) end
                if iExistingLRPDThreat <= 1500 or (iExistingLRPDThreat <= 3000 and not(M28Conditions.HaveLowPower(iTeam)) and not(M28Conditions.TeamHasLowMass(iTeam))) then
                    --Check it is a significant enough enemy threat
                    local iNearbyEnemyThreat = (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for _, iAdjLZ in tLZOrWZData[M28Map.subrefLZAdjacentLandZones] do
                            local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                            iNearbyEnemyThreat = iNearbyEnemyThreat + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iNearbyEnemyThreat='..iNearbyEnemyThreat..'; Gross mass='..aiBrain[M28Economy.refiGrossMassBaseIncome]) end
                    if iNearbyEnemyThreat >= 500 or (iNearbyEnemyThreat >= math.max(150, iExistingLRPDThreat * 0.5) and (iExistingLRPDThreat == 0 or not(M28Conditions.TeamHasLowMass(iTeam)) or aiBrain[M28Economy.refiGrossMassBaseIncome] >= 10)) then
                        if not(tLZOrWZTeamData[M28Map.refbBaseInSafePosition]) or M28Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat, oACU:GetPosition(), 100, 'Enemy')) == false then
                            bGivenOrder = true
                            ACUBuildUnit(aiBrain, oACU, M28UnitInfo.refCategoryPD, 50, 60, nil, nil)
                            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build PD') end
                        end
                    end
                end
            end
            --Do we have low power? If so then build some
            if not(bGivenOrder) then
                if bDebugMessages == true then LOG(sFunctionRef..': Checking if want to build power, have low power='..tostring(M28Conditions.HaveLowPower(iTeam))..'; Highest factory tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; Want more power='..tostring(M28Conditions.WantMorePower(iTeam))..'; have low mass='..tostring(M28Conditions.TeamHasLowMass(iTeam))) end
                if M28Conditions.HaveLowPower(iTeam) or (oACU[refiBuildTech] >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] and M28Conditions.WantMorePower(iTeam) and not(M28Conditions.TeamHasLowMass(iTeam))) then
                    --If we dont have highest tech level then look to just assist power
                    if oACU[refiBuildTech] >= aiBrain[M28Economy.refiOurHighestFactoryTechLevel] then
                        ACUActionBuildPower(aiBrain, oACU)
                        bGivenOrder = true
                        if bDebugMessages == true then LOG(sFunctionRef..': We have highest tech available on acu so will build power') end
                    else
                        local oPowerToAssist = M28Engineer.GetPartCompleteBuildingInZone(iTeam, iPlateauOrZero, iLandOrWaterZone, M28UnitInfo.refCategoryPower)
                        if bDebugMessages == true then LOG(sFunctionRef..': Only want to assist an under construction power, oPowerToAssist='..(oPowerToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oPowerToAssist) or 'nil')) end
                        if oPowerToAssist then
                            bGivenOrder = true
                            M28Orders.IssueTrackedRepair(oACU, oPowerToAssist, false, 'ACUAstP', false)
                            if bDebugMessages == true then LOG(sFunctionRef..': Will assist pgen') end
                        end
                    end
                    --Get experimental if T3 and dont have low power and have all t3 mexes in zone
                elseif oACU[refiBuildTech] >= 3 and tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] >= tLZOrWZData[M28Map.subrefLZOrWZMexCount] then
                    local tbEngineersOfFaction = {}
                    tbEngineersOfFaction[M28UnitInfo.GetUnitFaction(oACU)] = true
                    local iExperimentalCategory = M28Engineer.DecideOnExperimentalToBuild(M28Engineer.refActionReclaimFriendlyUnit, aiBrain, tbEngineersOfFaction, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iLandOrWaterZone)
                    if iExperimentalCategory then
                        if not(iExperimentalCategory == M28Engineer.refActionManageGameEnderTemplate) then
                            bGivenOrder = true
                            local oExpToAssist = M28Engineer.GetPartCompleteBuildingInZone(iTeam, iPlateauOrZero, iLandOrWaterZone, iExperimentalCategory)
                            if oExpToAssist then
                                M28Orders.IssueTrackedRepair(oACU, oExpToAssist, false, 'ACUAstEx', false)
                            else
                                ACUBuildUnit(aiBrain, oACU, iExperimentalCategory, 50, 60, nil, nil)
                            end
                        else
                            local oExpToAssist = M28Engineer.GetPartCompleteBuildingInZone(iTeam, iPlateauOrZero, iLandOrWaterZone, M28UnitInfo.refCategoryExperimentalLevel + M28UnitInfo.refCategoryFixedShield)
                            if oExpToAssist then
                                bGivenOrder = true
                                M28Orders.IssueTrackedRepair(oACU, oExpToAssist, false, 'ACUAstGEx', false)
                            end
                        end
                    end
                end

                if not(bGivenOrder) then
                    --Consider assisting a nearby upgrading unti as a high priority if lots of mass
                    if bDebugMessages == true then LOG(sFunctionRef..': If have lots of mass will consider assisting nearby construction, stored%='..aiBrain:GetEconomyStoredRatio('MASS')) end
                    if aiBrain:GetEconomyStoredRatio('MASS') >= 0.4 and not(M28Conditions.HaveLowPower(iTeam)) and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoActiveUpgrades]) == false then
                        --If are at T2 and next upgrade is for T3 then consider getting this
                        if  oACU[refiBuildTech] == 2 and tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] >= 1 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 150 then
                            local sUpgradeWanted, bIgnoreOtherUpgradeConditions
                            if tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] >= 3 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 300 then
                                --Ignore eco checks
                                sUpgradeWanted, bIgnoreOtherUpgradeConditions = GetACUUpgradeWanted(oACU, false, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, true)
                            else
                                sUpgradeWanted, bIgnoreOtherUpgradeConditions = GetACUUpgradeWanted(oACU, false, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, false)
                            end
                            if sUpgradeWanted then
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to get T3 on ACU') end
                                bGivenOrder = true
                                if bIgnoreOtherUpgradeConditions or M28Conditions.SafeToUpgradeUnit(oACU) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': ACU Eng Safe to get upgrade here so will proceed with upgrading ACU, sUpgradeWanted='..(sUpgradeWanted or 'nil')..' brain='..oACU:GetAIBrain().Nickname..'; Has enhancement='..tostring(oACU:HasEnhancement(sUpgradeWanted))) end
                                    if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastIssuedACUEnhancementOrder] or -100) >= 2 or (oACU[M28Orders.refiTimeOfLastRemovalUpgrade] and GetGameTimeSeconds() - oACU[M28Orders.refiTimeOfLastRemovalUpgrade] <= 10) or oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] == sUpgradeWanted then
                                        M28Orders.IssueTrackedEnhancement(oACU, sUpgradeWanted, false, 'ACUEUpr')
                                    end
                                else
                                    --Retreat
                                    local tRallyPoint = M28Land.GetNearestLandRallyPoint(tLZOrWZData, oACU:GetAIBrain().M28Team, iPlateauOrZero, iLandOrWaterZone, 2)
                                    if bDebugMessages == true then LOG(sFunctionRef..': ACU Eng Not safe to get upgrade so want to retreat until it is. tRallyPoint='..repru(tRallyPoint)..'; ACU position='..repru(oACU:GetPosition())) end
                                    M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'RE4U')
                                end
                            end
                        end
                        if not(bGivenOrder) then

                            bGivenOrder = AssistBuildingUpgradeOrStorageConstruction(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)
                            if bDebugMessages == true then LOG(sFunctionRef..': bGivenOrder after checking if want to assist an upgrade='..tostring(bGivenOrder)) end
                        end
                    end
                end
            end
        end

    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code for ACU owned by brain '..oACU:GetAIBrain().Nickname..'; oACU[refiBuildTech]='..(oACU[refiBuildTech] or 'nil')..', bGivenOrder='..tostring(bGivenOrder)..'; Time='..GetGameTimeSeconds()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bGivenOrder
end

function HaveACUSnipeAction(oACU, iTeam, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData)
    local sFunctionRef = 'HaveACUSnipeAction'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets]) and (oACU[M28UnitInfo.refiDFRange] or 0) >= 20 then
        local oClosestEnemyTarget
        local iClosestEnemyTarget = oACU[M28UnitInfo.refiDFRange] + 30 --dont want ACU to try and attack if its further away than this
        local iCurDist
        for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets] do
            if NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oUnit:GetPosition()) == iPlateauOrZero then
                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())
                if iCurDist < iClosestEnemyTarget then
                    iClosestEnemyTarget = iCurDist
                    oClosestEnemyTarget = oUnit
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': oClosestEnemyTarget='..(oClosestEnemyTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyTarget) or 'nil')..'; iClosestEnemyTarget='..(iClosestEnemyTarget or 'nil')..'; Our ACU range='..(oACU[M28UnitInfo.refiDFRange] or 'nil')) end
        if oClosestEnemyTarget then
            if bDebugMessages == true then LOG(sFunctionRef..': Our ACU health%='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; Target ACU health%='..M28UnitInfo.GetUnitHealthPercent(oClosestEnemyTarget)) end
            if iClosestEnemyTarget < oACU[M28UnitInfo.refiDFRange] - 6 then
                M28Orders.IssueTrackedAggressiveMove(oACU, oClosestEnemyTarget:GetPosition(), 6, false, 'ACUSni', false)
            else
                M28Orders.IssueTrackedMove(oACU, oClosestEnemyTarget:GetPosition(), 6, false, 'ACUSni', false)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function ConsiderRunningToGETemplate(oACU, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero)
    local sFunctionRef = 'ConsiderRunningToGETemplate'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTeam = oACU:GetAIBrain().M28Team
    --Do we want to run to GE template? only consider if enemy has multiple land exp, large air to ground threat, or we have built lots of experimentals
    if bDebugMessages == true then LOG(sFunctionRef..': start of code for ACU owned by brain '..oACU:GetAIBrain().Nickname..', is it dangerous for ACUs='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs])..'; Defend vs arti='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti])..'; Our constructed exp count='..M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount]..'; Enemy Air to ground threat='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; Time='..GetGameTimeSeconds()) end
    if M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs] and ((M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] and (M28Team.tTeamData[iTeam][M28Team.refiEnemyT3ArtiCount] > 0 or M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] > 1)) or M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= 3 or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 25000) then

        local iClosestShield = 1000 --(i.e. ignoring distance check for shields in this zone itself)
        local oClosestShield, iCurDist
        local bCheckIfOtherACUsUnderShield = false
        if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 then
            bCheckIfOtherACUsUnderShield = true
            if M28UnitInfo.GetUnitHealthPercent(oACU) < 0.9 then bCheckIfOtherACUsUnderShield = false end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of GE templates for this zone empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftActiveGameEnderTemplates]))) end

        local bAlreadyHaveFriendlyACU
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftActiveGameEnderTemplates]) == false then

            for iTemplate, tSubtable in tLZOrWZTeamData[M28Map.reftActiveGameEnderTemplates] do
                if tSubtable[M28Map.subrefGEbActiveShieldMonitor] and M28Utilities.IsTableEmpty(tSubtable[M28Map.subrefGEShieldUnits]) == false then
                    for iShield, oShield in tSubtable[M28Map.subrefGEShieldUnits] do
                        if M28UnitInfo.IsUnitValid(oShield) and oShield:GetFractionComplete() == 1 then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oACU:GetPosition())
                            if iCurDist < iClosestShield then
                                iClosestShield = iCurDist
                                oClosestShield = oShield
                            end
                        end
                    end
                end
            end
        end
        local tiPlateauAndZoneACUCount = {}
        if bCheckIfOtherACUsUnderShield then
            local iShieldPlateau, iShieldZone
            for iFriendlyACU, oFriendlyACU in M28Team.tTeamData[iTeam][M28Team.reftM28ACUs] do
                if not(oFriendlyACU == oACU) then
                    if bDebugMessages == true then LOG(sFunctionRef..': oFriendlyACU owned by '..oFriendlyACU:GetAIBrain().Nickname..' has oFriendlyACU[refoShieldRallyTarget]='..(oFriendlyACU[refoShieldRallyTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oFriendlyACU[refoShieldRallyTarget]) or 'nil')..'; iShieldPlateau='..(oFriendlyACU[refoShieldRallyTarget][M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] or 'nil')..'; iShieldZone='..(oFriendlyACU[refoShieldRallyTarget][M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] or 'nil')) end
                    if oFriendlyACU[refoShieldRallyTarget] then
                        if oClosestShield and oFriendlyACU[refoShieldRallyTarget] == oClosestShield then
                            if bAlreadyHaveFriendlyACU then --means have 2+ ACUs already here
                                oClosestShield = nil
                                if bDebugMessages == true then LOG(sFunctionRef..': Nearest shield is a rally target for multiple ACUs so will clear it') end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..':nearest shield is already a rally target for another ACU') end
                                iClosestShield = iClosestShield + 250
                                bAlreadyHaveFriendlyACU = true
                            end
                        end
                        iShieldPlateau = oFriendlyACU[refoShieldRallyTarget][M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1]
                        iShieldZone = oFriendlyACU[refoShieldRallyTarget][M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]
                        if iShieldPlateau and iShieldZone then
                            if not(tiPlateauAndZoneACUCount[iShieldPlateau]) then
                                tiPlateauAndZoneACUCount[iShieldPlateau] = {}
                            end
                            tiPlateauAndZoneACUCount[iShieldPlateau][iShieldZone] = (tiPlateauAndZoneACUCount[iShieldPlateau][iShieldZone] or 0) + 1
                        end
                    end

                end
            end
            if oClosestShield and (tiPlateauAndZoneACUCount[oClosestShield[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1]][oClosestShield[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]] or 0) >= 2 then
                if bDebugMessages == true then LOG(sFunctionRef..': We already have 2 ACUs in this zone so want to consider a further away shield') end
                oClosestShield = nil
                bAlreadyHaveFriendlyACU = true
            end
        end
        if not(oClosestShield) or bAlreadyHaveFriendlyACU then
            --Do we have any active GE templates nearby in a zone with fewer than 2 assigned ACUs?
            if bDebugMessages == true then LOG(sFunctionRef..': dont have shield in GE template for this zone, is table of potentially active GE templates empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.tPotentiallyActiveGETemplates]))) end
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.tPotentiallyActiveGETemplates]) == false then
                iClosestShield = math.min(iClosestShield, 300) --dont want to consider travelling further away than this
                for iEntry, tTemplateTable in M28Team.tTeamData[iTeam][M28Team.tPotentiallyActiveGETemplates] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering entry '..iEntry..'; Active shield monitor='..tostring(tTemplateTable[M28Map.subrefGEbActiveShieldMonitor])..'; Is table of shield units empty='..tostring(M28Utilities.IsTableEmpty(tTemplateTable[M28Map.subrefGEShieldUnits]))..'; ACU count for this zone='..((tiPlateauAndZoneACUCount[tTemplateTable[M28Map.subrefGEShieldUnits][1][M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1]][tTemplateTable[M28Map.subrefGEShieldUnits][1][M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]] or 0))) end
                    if tTemplateTable[M28Map.subrefGEbActiveShieldMonitor] and M28Utilities.IsTableEmpty(tTemplateTable[M28Map.subrefGEShieldUnits]) == false then
                        --Can we path here, and do we have fewer than 2 assigned ACUs?
                        if tTemplateTable[M28Map.subrefGEShieldUnits][1][M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] == iPlateauOrZero and M28UnitInfo.IsUnitValid(tTemplateTable[M28Map.subrefGEShieldUnits][1])
                                and (tiPlateauAndZoneACUCount[tTemplateTable[M28Map.subrefGEShieldUnits][1][M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1]][tTemplateTable[M28Map.subrefGEShieldUnits][1][M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]] or 0) < 2
                        then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(tTemplateTable[M28Map.subrefGEShieldUnits][1]:GetPosition(), oACU:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': dist to shield '..tTemplateTable[M28Map.subrefGEShieldUnits][1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tTemplateTable[M28Map.subrefGEShieldUnits][1])..'='..iCurDist) end
                            if iCurDist < iClosestShield then
                                if bCheckIfOtherACUsUnderShield then
                                    for iFriendlyACU, oFriendlyACU in M28Team.tTeamData[iTeam][M28Team.reftM28ACUs] do
                                        if not(oFriendlyACU == oACU) then
                                            if oFriendlyACU[refoShieldRallyTarget] and oFriendlyACU[refoShieldRallyTarget] == tTemplateTable[M28Map.subrefGEShieldUnits][1] then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Wont go to nearest shield as it is already a rally target for another ACU') end
                                                iClosestShield = iClosestShield + 250
                                            end
                                        end
                                    end
                                end
                                if iCurDist < iClosestShield then
                                    oClosestShield = tTemplateTable[M28Map.subrefGEShieldUnits][1]
                                    iClosestShield = iCurDist
                                end
                            end
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for shield to run to in GE template, oClosestShield='..(oClosestShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestShield) or 'nil')..'; bAlreadyHaveFriendlyACU='..tostring(bAlreadyHaveFriendlyACU or false)..'; bCheckIfOtherACUsUnderShield='..tostring(bCheckIfOtherACUsUnderShield)..'; oClosestShield assigned plateau and Zone=P'..(oClosestShield[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] or 'nil')..'Z'..(oClosestShield[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] or 'nil')) end
        if bAlreadyHaveFriendlyACU and not(oClosestShield) then
            --Get the ACU core base; If it doesnt have too many ACUs in it, and has shielding, then go here
            local iOrigBasePlateauOrZero, iOrigBaseLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(M28Map.GetPlayerStartPosition(oACU:GetAIBrain()))
            if bDebugMessages == true then LOG(sFunctionRef..': iOrigBasePlateauOrZero='..(iOrigBasePlateauOrZero or 'nil')..'; iOrigBaseLZOrWZ='..(iOrigBaseLZOrWZ or 'nil')..'; tiPlateauAndZoneACUCount='..repru(tiPlateauAndZoneACUCount))
                if iOrigBasePlateauOrZero and iOrigBaseLZOrWZ and (tiPlateauAndZoneACUCount[iOrigBasePlateauOrZero][iOrigBaseLZOrWZ] or 0) < 2 and iOrigBasePlateauOrZero > 0 then
                    local tOrigBaseLZData = M28Map.tAllPlateaus[iOrigBasePlateauOrZero][M28Map.subrefPlateauLandZones][iOrigBaseLZOrWZ]
                    local tOrigBaseLZTeamData = tOrigBaseLZData[M28Map.subrefLZTeamData][iTeam]
                    if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tOrigBaseLZData[M28Map.subrefMidpoint]) <= 350 and tOrigBaseLZTeamData[M28Map.refiEnemyAirToGroundThreat] == 0 and tOrigBaseLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] == 0 and tOrigBaseLZTeamData[M28Map.subrefiT3FixedShieldConstructedCount] > 0 and tOrigBaseLZTeamData[M28Map.subrefLZSValue] >= 5000 then
                        local tShieldsInOrigBase = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield - categories.TECH1 - categories.TECH2, tOrigBaseLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                        if M28Utilities.IsTableEmpty(tShieldsInOrigBase) == false then
                            iClosestShield = 350
                            for iOrigShield, oOrigShield in tShieldsInOrigBase do
                                if not(oOrigShield.Dead) then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oOrigShield:GetPosition(), oACU:GetPosition())
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering dist to oOrigShield in core base='..oOrigShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOrigShield)..'; iCurDist='..iCurDist) end
                                    if iCurDist < iClosestShield then
                                        oClosestShield = oOrigShield
                                        iClosestShield = iCurDist
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for shield in our original base and if we want to run to it, oClosestShield='..(oClosestShield.Unitid or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestShield) or 'nil')..'; bAlreadyHaveFriendlyACU='..tostring(bAlreadyHaveFriendlyACU or false)) end
        end

        if oClosestShield then
            oACU[refoShieldRallyTarget] = oClosestShield
            if bDebugMessages == true then LOG(sFunctionRef..': iClosestShield='..iClosestShield..'; Shield radius='..(oClosestShield:GetBlueprint().Defense.Shield.ShieldSize or 0)..'; Shield health='..oClosestShield.MyShield:GetHealth()..'; brain'..oACU:GetAIBrain().Nickname..'; oClosestShield[M28Building.reftArtiTemplateRefs]='..repru(oClosestShield[M28Building.reftArtiTemplateRefs])..'; Assigned Plateau and Zone for oClosestShield=P'..oClosestShield[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1]..'Z'..oClosestShield[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]..'; tiPlateauAndZoneACUCount='..repru(tiPlateauAndZoneACUCount)) end
            if iClosestShield <= 6 or (iClosestShield < math.min((oClosestShield:GetBlueprint().Defense.Shield.ShieldSize or 0) * 0.5 - 3.5, 26) and oClosestShield.MyShield.GetHealth and oClosestShield.MyShield:GetHealth() >= 5000) then
                --We want to be positioned inbetween the shield and the GE arti being shielded, to make sure if the shield is destroyed we are covered by other shields (as for some templates they only cover the midpoint of each shield)
                local tPositionToBeCloserTo

                if oClosestShield[M28Building.reftArtiTemplateRefs] then
                    local tTemplate = M28Map.tAllPlateaus[oClosestShield[M28Building.reftArtiTemplateRefs][1]][M28Map.subrefPlateauLandZones][oClosestShield[M28Building.reftArtiTemplateRefs][2]][M28Map.subrefLZTeamData][iTeam][M28Map.reftActiveGameEnderTemplates][oClosestShield[M28Building.reftArtiTemplateRefs][3]]
                    if bDebugMessages == true then LOG(sFunctionRef..': Is tTemplate[M28Map.subrefGEArtiLocations][1] nil='..tostring((tTemplate[M28Map.subrefGEArtiLocations][1] == nil))..'; is tTemplate nil='..tostring(tTemplate == nil)) end
                    if tTemplate[M28Map.subrefGEArtiLocations][1] then
                        local iACUDistToArti = M28Utilities.GetDistanceBetweenPositions(tTemplate[M28Map.subrefGEArtiLocations][1], oACU:GetPosition())
                        local iShieldDistToArti = M28Utilities.GetDistanceBetweenPositions(tTemplate[M28Map.subrefGEArtiLocations][1], oClosestShield:GetPosition())
                        if iACUDistToArti + 2 >= iShieldDistToArti then
                            tPositionToBeCloserTo = M28Utilities.MoveInDirection(oClosestShield:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestShield:GetPosition(), tTemplate[M28Map.subrefGEArtiLocations][1]), 4)
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iACUDistToArti='..iACUDistToArti..'; iShieldDistToArti='..iShieldDistToArti..'; tPositionToBeCloserTo='..repru(tPositionToBeCloserTo)) end

                    end
                end
                if tPositionToBeCloserTo then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will move to be inbetween shield and the arti being protected') end
                    M28Orders.IssueTrackedMove(oACU, tPositionToBeCloserTo, 3, false, 'RunToGEAr')
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                else

                    local sUpgradeToGet, bIgnoreOtherUpgradeConditions = GetACUUpgradeWanted(oACU, false, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, false)
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want upgrade, sUpgradeToGet='..(sUpgradeToGet or 'nil')..'; Have low mass='..tostring(M28Conditions.HaveLowMass(oACU:GetAIBrain()))..'; Have low power='..tostring(M28Conditions.HaveLowPower(oACU:GetAIBrain()))..'; Stalling mass='..tostring(M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.subrefbTeamIsStallingMass])..'; Gross brain mass='..oACU:GetAIBrain()[M28Economy.refiGrossMassBaseIncome]) end
                    if sUpgradeToGet and (bIgnoreOtherUpgradeConditions or (not(M28Conditions.HaveLowPower(oACU:GetAIBrain())) or oACU:GetAIBrain()[M28Economy.refbBuiltParagon]) and not(M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.subrefbTeamIsStallingMass]) and (not(M28Conditions.HaveLowMass(oACU:GetAIBrain())) or oACU:GetAIBrain()[M28Economy.refiGrossMassBaseIncome] >= 50)) then
                        M28Orders.IssueTrackedEnhancement(oACU, sUpgradeToGet, false, 'ACUUpLg')
                        if bDebugMessages == true then LOG(sFunctionRef..': Are under shield already but want to get an upgrade so will get upgrade') end
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return true
                    elseif iClosestShield <= 3 or (oClosestShield.MyShield.GetHealth and oClosestShield.MyShield:GetHealth() >= 5000) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Are under the shield already so will consider normal ACU logic') end
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return false
                    end
                end
            elseif bDebugMessages == true then LOG(sFunctionRef..': want to move closer to the shield')
            end

            M28Orders.IssueTrackedMove(oACU, oClosestShield:GetPosition(), 4, false, 'RunToGESh')

            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function HaveNearbyVulnerableEnemyACUToAttack(oACU, iTeam, tLZData, tLZTeamData, iPlateau, iStartLandZone)
    --Idea - if we have gun, and outrange enemy ACU in an adjacent zone with no upgrades, and enemy has no nearby units with same range as us, then will try attacking the ACU
    --Assumed we only call this if we are in a land zone, and have already called logic to attack enemies if we are almost in range of them

    local sFunctionRef = 'HaveNearbyVulnerableEnemyACUToAttack'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bAttackNearestACU = false
    --Ignore if at core base (mainly for optimisation reasons)
    if not(tLZTeamData[M28Map.subrefLZbCoreBase]) and M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) then
        --Get closest enemy ACU
        local oClosestEnemyACU, iCurDist
        local iDistThreshold = 175
        local iClosestEnemyACU = iDistThreshold --Ignore ACUs further away than this (but still record dist, so if closest ACU is a guncom then we wont bother trying to kill one further away that lacks gun)
        for iEnemyACU, oEnemyACU in M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oEnemyACU:GetPosition())
            if iCurDist < iClosestEnemyACU then
                iClosestEnemyACU = iCurDist
                if oEnemyACU[M28UnitInfo.refiDFRange] < oACU[M28UnitInfo.refiDFRange] and ((oEnemyACU[refiUpgradeCount] or 0) == 0 or iCurDist <= 70) then
                    oClosestEnemyACU = oEnemyACU
                end
            end
        end
        if oClosestEnemyACU then
            --Have a nearby enemy ACU that we outrange; now check that the enemy has no threats with at least our range in any zones between us and them
            local iTargetPlateau, iTargetLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oClosestEnemyACU:GetPosition())
            if iTargetPlateau == iPlateau and NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, oClosestEnemyACU:GetPosition()) == tLZData[M28Map.subrefLZIslandRef] then
                --We are both on the same island; now record all zones between us and them
                local tLandZonesBetweenACUs = {}
                table.insert(tLandZonesBetweenACUs, iStartLandZone)
                if not(iStartLandZone==iTargetLandZone) then
                    table.insert(tLandZonesBetweenACUs, iTargetLandZone)
                    --Check if we are adjacent, if not then need to do more detailed pathing check
                    local bAreAdjacent = false
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                            if iAdjLZ == iTargetLandZone then
                                bAreAdjacent = true
                                break
                            end
                        end
                    end
                    if not(bAreAdjacent) then
                        if M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iStartLandZone, iTargetLandZone, true) > iDistThreshold then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return false
                        else
                            if not(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]) then
                                M28Map.ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iPlateau, iStartLandZone, iTargetLandZone, tLZData[M28Map.subrefMidpoint])
                            end
                            local iEntryNumber = tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]

                            if iEntryNumber then
                                --Change closest LZ to run to to be 2 along the path from cur LZ to the target LZ
                                for iEntry, iLZPointInPath in tLZData[M28Map.subrefLZPathingToOtherLandZones][iEntryNumber][M28Map.subrefLZPath] do
                                    local bAlreadyIncluded = false
                                    for iEntry, iZone in tLandZonesBetweenACUs do
                                        if iLZPointInPath == iZone then bAlreadyIncluded = true break end
                                    end
                                    if not(bAlreadyIncluded) then table.insert(tLandZonesBetweenACUs, iLZPointInPath) end
                                end
                            end
                        end
                    end
                end
                for iEntry, iAltLZ in tLandZonesBetweenACUs do
                    local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAltLZ][M28Map.subrefLZTeamData][iTeam]
                    if tAltLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] then
                        if tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] >= oACU[M28UnitInfo.refiDFRange] or tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] >= oACU[M28UnitInfo.refiDFRange] then
                            if bDebugMessages == true then LOG(sFunctionRef..': Zone has enemies with at least as much range as us so wont attack ACU') end
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return false
                        end
                    end
                end
                --If we have got here then we outrange all enemy threats in every zone between here and enemy
                if oACU[refbUseACUAggressively] or iTargetLandZone == iStartLandZone then
                    if bDebugMessages == true then LOG(sFunctionRef..': Using ACU aggressively, or enemy ACU is in same zone as us') end
                    bAttackNearestACU = true
                else
                    --Check enemy threat vs ours, and if we aren't significantly outmatched then advance (we will already be doing this in the check of if ACU should run from earlier, so this is to reduce instances where we advance to an enemy ACU and then retreat almost straight away
                    local iTotalFriendlyCombat = 0
                    local iTotalEnemyCombat = 0
                    for iEntry, iAltLZ in tLandZonesBetweenACUs do
                        local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAltLZ][M28Map.subrefLZTeamData][iTeam]
                        iTotalFriendlyCombat = iTotalFriendlyCombat + tAltLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]
                        iTotalEnemyCombat = iTotalEnemyCombat + tAltLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]
                    end
                    if iTotalEnemyCombat * 0.8 < iTotalFriendlyCombat or iTotalEnemyCombat < 800 then
                        bAttackNearestACU = true
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iTotalEnemyCombat='..iTotalEnemyCombat..'; iTotalFriendlyCombat='..iTotalFriendlyCombat) end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to attack nearest enemy ACU, oACU[refbUseACUAggressively]='..tostring(oACU[refbUseACUAggressively])..'; iTargetLandZone='..iTargetLandZone..'; iStartLandZone='..iStartLandZone..'; bAttackNearestACU='..tostring(bAttackNearestACU)) end
            end
            if bAttackNearestACU then
                --We have already checked in the condition immediately preciding this if we want to attack enemies we are in range of, so we can just go and move towards the enemy ACU
                if iClosestEnemyACU < (oClosestEnemyACU[M28UnitInfo.refiDFRange] or 0) + 2 then
                    --Redundancy - check not too close to the ACU - Attack-move as almost within their ACUs firing range
                    M28Orders.IssueTrackedAggressiveMove(oACU, oClosestEnemyACU:GetPosition(), 2, false, 'AtckACUAM')
                else
                    M28Orders.IssueTrackedMove(oACU, oClosestEnemyACU:GetPosition(), 2, false, 'AtckACUM')
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bAttackNearestACU='..tostring(bAttackNearestACU)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bAttackNearestACU
end

function IsTargetSuitableSnipeTarget(oACU, oSnipeTarget, iOurACUPlateauOrZero, iDistanceThreshold, bMustBeWithinExplosionThreshold, bCalledFromUpgradingSnipeLogic)
    --Returns true/false if the target is suitable for an all-in ACU attack, and if returns how close the unit is
    local sFunctionRef = 'IsTargetSuitableSnipeTarget'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iClosestDist
    local bIsSuitable
    if M28UnitInfo.IsUnitValid(oSnipeTarget) then
        local iDistAdjust = 0
        if oSnipeTarget:IsUnitState('Upgrading') then iDistAdjust = iACUAssassinationUpgradingRangeAdjust end
        if bDebugMessages == true then LOG(sFunctionRef..': Considering oSnipeTarget='..oSnipeTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSnipeTarget)..' owned by '..oSnipeTarget:GetAIBrain().Nickname..'; iOurACUPlateauOrZero='..iOurACUPlateauOrZero..'; iDistanceThreshold='..iDistanceThreshold..'; Enemy plateau='..(NavUtils.GetLabel(M28Map.refPathingTypeHover, oSnipeTarget:GetPosition()) or 'nil')..'; iCurDist='..M28Utilities.GetDistanceBetweenPositions(oSnipeTarget:GetPosition(), oACU:GetPosition())..'; oACU[refbACUSnipeModeActive]='..tostring(oACU[refbACUSnipeModeActive] or false)..'; bMustBeWithinExplosionThreshold='..tostring(bMustBeWithinExplosionThreshold or false)..'; iDistanceThreshold='..iDistanceThreshold..'; iDistAdjust='..iDistAdjust) end
        if NavUtils.GetLabel(M28Map.refPathingTypeHover, oSnipeTarget:GetPosition()) == iOurACUPlateauOrZero then
            local iCurDist = M28Utilities.GetDistanceBetweenPositions(oSnipeTarget:GetPosition(), oACU:GetPosition())
            if iCurDist <= iDistanceThreshold + iDistAdjust then
                --We are in range of enemy ACU, check how many ACUs we have in range
                local iACUsInRange = 1
                local aiBrain = oACU:GetAIBrain()
                local tFriendlyACUs = aiBrain:GetUnitsAroundPoint(categories.COMMAND, oSnipeTarget:GetPosition(), 40, 'Ally')
                local bUpgradingSnipeLogic = bCalledFromUpgradingSnipeLogic
                if M28Utilities.IsTableEmpty(tFriendlyACUs) == false then
                    for iFriendlyACU, oFriendlyACU in tFriendlyACUs do
                        if oFriendlyACU[refbSupportFriendlyACUAttack] then bUpgradingSnipeLogic = true end
                        if not(oFriendlyACU == oACU) and M28Utilities.GetDistanceBetweenPositions(oFriendlyACU:GetPosition(), oSnipeTarget:GetPosition()) <= oFriendlyACU[M28UnitInfo.refiDFRange] + iDistAdjust then
                            if oFriendlyACU[refbACUSnipeModeActive] or M28UnitInfo.GetUnitCurHealthAndShield(oFriendlyACU) >= 4000 then
                                if iACUsInRange >= 2 then
                                    iACUsInRange = iACUsInRange + 0.5
                                else
                                    iACUsInRange = iACUsInRange + 1
                                end
                            else
                                iACUsInRange = iACUsInRange + 0.1
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Is tFriendlyACUs empty='..tostring(M28Utilities.IsTableEmpty(tFriendlyACUs))..'; iACUsInRange='..iACUsInRange..'; Snipe target health='..M28UnitInfo.GetUnitCurHealthAndShield(oSnipeTarget)..'; Nearby shield value='..M28Logic.IsTargetUnderShield(aiBrain, oSnipeTarget, 0, true, false, false, true, false)) end
                --Check enemy doesnt have mobile or fixed shield
                local iEnemyACUHealth = M28UnitInfo.GetUnitCurHealthAndShield(oSnipeTarget) + M28Logic.IsTargetUnderShield(aiBrain, oSnipeTarget, 0, true, false, false, true, false)
                --death nuke does 2k damage; however are likely able to get a couple of shots off if enemy is just above this level
                if (iEnemyACUHealth < iACUsInRange * 3000 and not(M28UnitInfo.IsUnitUnderwater(oSnipeTarget)) and (not(bMustBeWithinExplosionThreshold) or (iEnemyACUHealth <= 2200 and iCurDist <= 28)))
                        or (oSnipeTarget:IsUnitState('Upgrading') and bUpgradingSnipeLogic) then
                    iClosestDist = iCurDist
                    bIsSuitable = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Suitable snipe target') end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bIsSuitable='..tostring(bIsSuitable)..'; iClosestDist='..(iClosestDist or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bIsSuitable, iClosestDist
end

function DoesACUWantToSuicideIntoEnemyACU(oACU, iTeam, iPlateauOrZero, iLandOrWaterZone, tLZOrWZTeamData)
    local sFunctionRef = 'DoesACUWantToSuicideIntoEnemyACU'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oACU[refbACUSnipeModeActive]='..tostring(oACU[refbACUSnipeModeActive])..'; oACU brain='..oACU:GetAIBrain().Nickname..'; iPlateauOrZero='..iPlateauOrZero..'; Cur health='..M28UnitInfo.GetUnitCurHealthAndShield(oACU)) end
    local oClosestEnemyACU
    if not(oACU[refbACUSnipeModeActive]) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets]) == false and iPlateauOrZero > 0 then
        local iACUHealth = M28UnitInfo.GetUnitCurHealthAndShield(oACU)
        if iACUHealth >= 4000 or not(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) then
            local bEnemyACUMustBeInExplosionRange = DoesACUOnlyWantToSuicideIfInExplosionRange(oACU, tLZOrWZTeamData, iTeam)

            local iClosestEnemyACUDist = oACU[M28UnitInfo.refiDFRange]
            local iCurDist, aiBrain, bIsSuitableForSnipe
            for iSnipeTarget, oSnipeTarget in  M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets] do
                bIsSuitableForSnipe, iCurDist = IsTargetSuitableSnipeTarget(oACU, oSnipeTarget, iPlateauOrZero, iClosestEnemyACUDist, bEnemyACUMustBeInExplosionRange)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if want '..oSnipeTarget:GetAIBrain().Nickname..' unit as a snipe target, bIsSuitableForSnipe='..tostring(bIsSuitableForSnipe)..'; iCurDist='..iCurDist..'; iClosestEnemyACUDist='..iClosestEnemyACUDist) end
                if bIsSuitableForSnipe and iCurDist <= iClosestEnemyACUDist then
                    iClosestEnemyACUDist = iCurDist
                    oClosestEnemyACU = oSnipeTarget
                    if bDebugMessages == true then LOG(sFunctionRef..': Updating oClosestEnemyACU to oSnipeTarget='..oSnipeTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSnipeTarget)..' owned by '..oSnipeTarget:GetAIBrain().Nickname..'; iClosestEnemyACUDist='..iClosestEnemyACUDist) end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for potential enemy snipe targets, is oClosestEnemyACU valid='..tostring(oClosestEnemyACU)) end
            if oClosestEnemyACU then
                oACU[refbACUSnipeModeActive] = true
                ForkThread(SuicideACUIntoSnipeTarget, oACU, oClosestEnemyACU)
                if bDebugMessages == true then LOG(sFunctionRef..': Will suicide ACU into this target (via forked thread') end
            end
        end
    end
    --Special case - we have no upgrades, enemy ACU is nearby getting an upgrade, and it is relatively early on, and we have multiple friendly ACUs - consider pushing in to force them to cancel the upgrade
    if oACU[refiUpgradeCount] == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] < 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech] < 2 and not(oACU[refbACUSnipeModeActive]) and iPlateauOrZero > 0 and not(M28Team.tTeamData[iTeam][M28Team.refbAssassinationOrSimilar]) and M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU] and M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 2 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) == false and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftM28ACUs]) == false and (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) <= 2000 and oACU:GetHealth() >= 5000 then
        --Get nearest enemy ACU, and number of total nearby enemy ACUs
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if enemy has nearby upgrading ACU, and none nearby that have completed the upgrade, and we have multiple friendly ACUs') end
        local iMaxDistToEnemyACU = oACU[M28UnitInfo.refiDFRange] + iACUAssassinationUpgradingRangeAdjust --NOTE: Have an issue where it also needs to be a valid snipe target or else we dont actually try and snipe it
        local iSearchDistEnemyACUs = 100
        local iNearbyEnemyACUCount = 0
        local iFriendlyACUSearchRange = 40
        local bEnemyHasNearbyUpgradedACU = false
        local iCurDist
        local oClosestACUToConsiderAttacking
        if oACU[refbSupportFriendlyACUAttack] then iMaxDistToEnemyACU = iMaxDistToEnemyACU + 25 end
        --First see if we have a nearby enemy ACU that is either upgrading or unupgraded, and dont have many enemy ACUs
        for iEnemyACU, oEnemyACU in M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oEnemyACU:GetPosition())
            if bDebugMessages == true then LOG(sFunctionRef..': Considering ACU owned by '..oEnemyACU:GetAIBrain().Nickname..' and how close it is to oACU owned by '..oACU:GetAIBrain().Nickname..'; iCurDist='..iCurDist..'; Is enemy ACU upgrading='..tostring(oEnemyACU:IsUnitState('Upgrading'))) end
            if iCurDist <= iSearchDistEnemyACUs then
                iNearbyEnemyACUCount = iNearbyEnemyACUCount + 1
                if (oEnemyACU[refiUpgradeCount] or 0) > 0 or (oACU:IsUnitState('Upgrading') and oACU:GetWorkProgress() >= 0.8 and (oACU:GetHealth() >= 2500 or iCurDist >= 30)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': ACU is almost done with its upgrade or already has upgrade, so will assume it has gun') end
                    bEnemyHasNearbyUpgradedACU = true
                    break
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Enemy ACU plateau='..(NavUtils.GetLabel(M28Map.refPathingTypeHover, oEnemyACU:GetPosition()) or 'nil')..'; our ACU iPlateauOrZero='..iPlateauOrZero..'; Land label for enemy ACU='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, oEnemyACU:GetPosition()) or 'nil')) end
                if iCurDist <= iMaxDistToEnemyACU and NavUtils.GetLabel(M28Map.refPathingTypeHover, oEnemyACU:GetPosition()) == iPlateauOrZero and (NavUtils.GetLabel(M28Map.refPathingTypeLand, oEnemyACU:GetPosition()) or 0) > 0 then
                    --Check it is either upgrading (so vulnerable to us pushing in) or we are almost in range
                    if oEnemyACU:IsUnitState('Upgrading') or iCurDist <= (oACU[M28UnitInfo.refiDFRange] or 0) + 2 or oACU[refbSupportFriendlyACUAttack] then
                        iMaxDistToEnemyACU = iCurDist
                        oClosestACUToConsiderAttacking = oEnemyACU
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording as enemy ACU to consider attacking') end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Deciding if want to try and attack an ACU e.g. that is stuck upgrading, oClosestACUToConsiderAttacking='..(oClosestACUToConsiderAttacking.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestACUToConsiderAttacking) or 'nil')..'; bEnemyHasNearbyUpgradedACU='..tostring(bEnemyHasNearbyUpgradedACU)..'; iNearbyEnemyACUCount='..iNearbyEnemyACUCount) end
        if oClosestACUToConsiderAttacking and not(bEnemyHasNearbyUpgradedACU) and iNearbyEnemyACUCount == 1 then
            --Only 1 enemy ACU, and it either lacks an upgrade or is trying to get one, so consider attacking to force a cancellation if either we have multiple ACUs, or we have significantly more health
            local bHaveMuchMoreHealthOrFriendlyACUs = false
            local toFriendlyACUsToConsiderSupportingAttack = {}
            if oACU:GetHealth() >= oClosestACUToConsiderAttacking:GetHealth() + math.max(2000, oClosestACUToConsiderAttacking:GetHealth() * 0.5) then
                bHaveMuchMoreHealthOrFriendlyACUs = true
            else
                --Do we have nearby friendly ACUs?
                for iFriendlyACU, oFriendlyACU in M28Team.tTeamData[iTeam][M28Team.reftM28ACUs] do
                    if not(oFriendlyACU == oACU) and not(oFriendlyACU:IsUnitState('Upgrading')) and (oFriendlyACU:GetHealth() >= 4000 or not(oFriendlyACU[refiTimeLastWantedToRun] or GetGameTimeSeconds() - oFriendlyACU[refiTimeLastWantedToRun] > 1.01)) and M28Utilities.GetDistanceBetweenPositions(oFriendlyACU:GetPosition(), oACU:GetPosition()) <= iFriendlyACUSearchRange then
                        table.insert(toFriendlyACUsToConsiderSupportingAttack, oFriendlyACU)
                        bHaveMuchMoreHealthOrFriendlyACUs = true
                    end
                end
            end
            table.insert(toFriendlyACUsToConsiderSupportingAttack, oACU)
            if bDebugMessages == true then LOG(sFunctionRef..': Is closest ACU a potential snipe target='..tostring(IsTargetSuitableSnipeTarget(oACU, oClosestACUToConsiderAttacking, iPlateauOrZero, oACU[M28UnitInfo.refiDFRange], false, true))..'; oClosestACUToConsiderAttacking owner='..oClosestACUToConsiderAttacking:GetAIBrain().Nickname..'; bHaveMuchMoreHealthOrFriendlyACUs='..tostring(bHaveMuchMoreHealthOrFriendlyACUs)..'; oACU health='..oACU:GetHealth()..'; oClosestACUToConsiderAttacking health='..oClosestACUToConsiderAttacking:GetHealth()) end
            --Note-  we will adjust the distance threshold by iACUAssassinationUpgradingRangeAdjust in IsTargetSuitableSnipeTarget if target is upgrading
            if bHaveMuchMoreHealthOrFriendlyACUs and IsTargetSuitableSnipeTarget(oACU, oClosestACUToConsiderAttacking, iPlateauOrZero, oACU[M28UnitInfo.refiDFRange], false, true) then
                --We have a nearby enemy ACU without gun that we either have much more health than, or we have multiple ACUs to attack it with
                local iNearbyEnemyDF = 0
                local iNearbyFriendlyDF = 0
                local iEnemySearchLessRangeDist = 45
                local iFriendlySearchLessRangeDist = 20
                local tLZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                local tbZoneConsidered = {}
                local toEnemyUnitsNearRange = {}
                local toFriendlyUnitsNearRange = {}
                local toFriendlyACUsInLZCombatUnits = {}
                function ConsiderEnemyAndFriendlyUnits(iCurZone, tCurLZTeamData)
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iCurZone='..iCurZone..'; Have we already considered this='..tostring(tbZoneConsidered[iCurZone])) end
                    if not(tbZoneConsidered[iCurZone]) then
                        tbZoneConsidered[iCurZone] = true
                        if M28Utilities.IsTableEmpty(tCurLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                            local tEnemyCombatUnits = EntityCategoryFilterDown(categories.DIRECTFIRE + M28UnitInfo.refCategoryIndirect * categories.TECH1, tCurLZTeamData[M28Map.subrefTEnemyUnits])
                            if M28Utilities.IsTableEmpty(tEnemyCombatUnits) == false then
                                for iUnit, oUnit in tEnemyCombatUnits do
                                    if not(oUnit.Dead) then
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())
                                        if iCurDist > iEnemySearchLessRangeDist then
                                            iCurDist = math.min(iCurDist, M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestACUToConsiderAttacking:GetPosition()))
                                        end
                                        if iCurDist <= iEnemySearchLessRangeDist or iCurDist - oUnit[M28UnitInfo.refiCombatRange] <= iEnemySearchLessRangeDist then
                                            table.insert(toEnemyUnitsNearRange, oUnit)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Including enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..', enemy unit dist to our ACU='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())..'; Dist to enemy ACU='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestACUToConsiderAttacking:GetPosition())..'; Combat range='..oUnit[M28UnitInfo.refiCombatRange]..'; Threat of enemy unit='..M28UnitInfo.GetCombatThreatRating({ oUnit}, true)) end
                                        end
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of allied combat units empty='..tostring(M28Utilities.IsTableEmpty(tCurLZTeamData[M28Map.subrefLZTAlliedCombatUnits]))..'; subrefLZTThreatAllyCombatTotal='..tCurLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]..'; subrefLZThreatAllyMobileDFTotal='..tCurLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]) end
                        if M28Utilities.IsTableEmpty(tCurLZTeamData[M28Map.subrefLZTAlliedCombatUnits]) == false then
                            for iUnit, oUnit in tCurLZTeamData[M28Map.subrefLZTAlliedCombatUnits] do
                                if not(oUnit.Dead) then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())
                                    if iCurDist > iFriendlySearchLessRangeDist then
                                        iCurDist = math.min(iCurDist, M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestACUToConsiderAttacking:GetPosition()))
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering friendly unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Dist to our ACU='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())..'; Dist to enemy ACU='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestACUToConsiderAttacking:GetPosition())..'; Combat range='..oUnit[M28UnitInfo.refiCombatRange]..'; iFriendlySearchLessRangeDist='..iFriendlySearchLessRangeDist..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')) end
                                    if iCurDist <= iFriendlySearchLessRangeDist or iCurDist - oUnit[M28UnitInfo.refiCombatRange] <= iFriendlySearchLessRangeDist then
                                        if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or EntityCategoryContains(categories.TECH1, oUnit.UnitId) then
                                            table.insert(toFriendlyUnitsNearRange, oUnit)
                                            if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then table.insert(toFriendlyACUsInLZCombatUnits, oUnit) end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                --search this zone and adjacent zones for DF enemies, and consider pushing attack if total threat isnt too great; will do a precise check (since fairly rare we call this logic)
                ConsiderEnemyAndFriendlyUnits(iLandOrWaterZone, tLZOrWZTeamData)
                local iEnemyACUZone = oClosestACUToConsiderAttacking[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]
                tbZoneConsidered[iLandOrWaterZone] = true
                if not(iEnemyACUZone == iLandOrWaterZone) then
                    local tEnemyLZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iEnemyACUZone]
                    ConsiderEnemyAndFriendlyUnits(iEnemyACUZone, tEnemyLZData[M28Map.subrefLZTeamData][iTeam])
                    if M28Utilities.IsTableEmpty(tEnemyLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for _, iAdjLZ in tEnemyLZData[M28Map.subrefLZAdjacentLandZones] do
                            ConsiderEnemyAndFriendlyUnits(iAdjLZ, M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam])
                        end
                    end
                end

                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        ConsiderEnemyAndFriendlyUnits(iAdjLZ, M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam])
                    end
                end
                local bIncludeCurACU = false
                for iFriendlyACU, oFriendlyACU in toFriendlyACUsToConsiderSupportingAttack do
                    bIncludeCurACU = true
                    if M28Utilities.IsTableEmpty(toFriendlyACUsInLZCombatUnits) == false then
                        for iRecordedACU, oRecordedACU in toFriendlyACUsInLZCombatUnits do
                            if oRecordedACU == oFriendlyACU then
                                bIncludeCurACU = false
                                break
                            end
                        end
                    end
                    if bIncludeCurACU then
                        table.insert(toFriendlyUnitsNearRange, oFriendlyACU)
                    end
                end
                iNearbyEnemyDF = M28UnitInfo.GetCombatThreatRating(toEnemyUnitsNearRange, true)
                iNearbyFriendlyDF = M28UnitInfo.GetCombatThreatRating(toFriendlyUnitsNearRange, false)
                if bDebugMessages == true then LOG(sFunctionRef..': iNearbyEnemyDF='..iNearbyEnemyDF..'; iNearbyFriendlyDF='..iNearbyFriendlyDF) end
                if iNearbyFriendlyDF > iNearbyEnemyDF and iNearbyFriendlyDF > 1.2 * iNearbyEnemyDF then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to press the attack with our ACU, oClosestACUToConsiderAttacking owned by brain '..oClosestACUToConsiderAttacking:GetAIBrain().Nickname) end
                    if M28Utilities.IsTableEmpty(toFriendlyUnitsNearRange) == false then
                        for iFriendlyACU, oFriendlyACU in toFriendlyUnitsNearRange do
                            oFriendlyACU[refbSupportFriendlyACUAttack] = true
                        end
                    end
                    oClosestEnemyACU = oClosestACUToConsiderAttacking
                    ForkThread(SuicideACUIntoSnipeTarget, oACU, oClosestEnemyACU)
                end
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, is oClosestEnemyACU valid='..tostring(M28UnitInfo.IsUnitValid(oClosestEnemyACU))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if oClosestEnemyACU then return true
    elseif oACU[refbSupportFriendlyACUAttack] then oACU[refbSupportFriendlyACUAttack] = nil
    end
end

function SuicideACUIntoSnipeTarget(oACU, oSnipeTarget)
    local sFunctionRef = 'SuicideACUIntoSnipeTarget'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    oACU[refbACUSnipeModeActive] = true
    M28Micro.EnableUnitMicroUntilManuallyTurnOff(oACU, false)
    M28UnitInfo.SetUnitWeaponTargetPriorities(oACU, M28UnitInfo.refWeaponPriorityACUSnipe, false)
    local iCurDist
    if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop, is oACU valid='..tostring(M28UnitInfo.IsUnitValid(oACU))..'; Time='..GetGameTimeSeconds()) end
    local bOnlyAttackIfInExplosionRange = false
    local iCurACUHealth
    local iTimeOriginallyInSnipeMode = GetGameTimeSeconds()
    local aiBrain = oACU:GetAIBrain()
    while M28UnitInfo.IsUnitValid(oACU) do
        bOnlyAttackIfInExplosionRange = false
        if not(oSnipeTarget.Dead) and GetGameTimeSeconds() - iTimeOriginallyInSnipeMode >= 5 then --5s delay in case could get into a cycle where we say we shoudl suicide in the main logic, then we abort immediately in this loop. at least this way we have 5s of trying to kill them first
            local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oACU:GetPosition(), true, aiBrain.M28Team)
            bOnlyAttackIfInExplosionRange = DoesACUOnlyWantToSuicideIfInExplosionRange(oACU, tLZOrWZTeamData, aiBrain.M28Team)
        end
        if IsTargetSuitableSnipeTarget(oACU, oSnipeTarget, NavUtils.GetLabel(M28Map.refPathingTypeHover, oACU:GetPosition()), oACU[M28UnitInfo.refiDFRange], bOnlyAttackIfInExplosionRange) then
            --Move towards enemy unless well within range
            iCurDist = M28Utilities.GetDistanceBetweenPositions(oSnipeTarget:GetPosition(), oACU:GetPosition())
            if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to move closer to target or attackmove, oSnipeTarget owner='..oSnipeTarget:GetAIBrain().Nickname..'; iCurDist='..iCurDist..'; Is shot blocked='..tostring(M28Logic.IsShotBlocked(oACU, oSnipeTarget, false, nil))) end
            if iCurDist <= 10 and not(M28Logic.IsShotBlocked(oACU, oSnipeTarget, false, nil)) then
                --Attack target
                M28Orders.IssueTrackedAggressiveMove(oACU, oSnipeTarget:GetPosition(), 3, false, 'ACUSnipAM', true)
                if bDebugMessages == true then LOG(sFunctionRef..'L Will attackmove to enemy ACU') end

            else
                --Move to target
                M28Orders.IssueTrackedMove(oACU, oSnipeTarget:GetPosition(), 3, false, 'ACUSnipM', true)
                if bDebugMessages == true then LOG(sFunctionRef..': Will move to enemy ACU, enemy ACU position='..repru(oSnipeTarget:GetPosition())) end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if bDebugMessages == true and M28UnitInfo.IsUnitValid(oACU) and M28UnitInfo.IsUnitValid(oSnipeTarget) then LOG(sFunctionRef..': About to start new loop at time='..GetGameTimeSeconds()..'; oACU owner='..oACU:GetAIBrain().Nickname..'; oSnipeTarget owner='..oSnipeTarget:GetAIBrain().Nickname) end
        else
            break
        end
    end
    if M28UnitInfo.IsUnitValid(oACU) then
        oACU[refbACUSnipeModeActive] = false
        oACU[M28UnitInfo.refbSpecialMicroActive] = false
        M28UnitInfo.SetUnitWeaponTargetPriorities(oACU, M28UnitInfo.refWeaponPriorityACU, false)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DoesACUOnlyWantToSuicideIfInExplosionRange(oACU, tLZOrWZTeamData, iTeam)
    local iACUHealth = M28UnitInfo.GetUnitCurHealthAndShield(oACU)
    if iACUHealth >= 8000 then return false
    elseif iACUHealth <= 3000 then return true
    else
        --ACU is between 3k and 8k health, so be more cautious if enemy has T2 PD within our range
        local iEnemyT2PDInOurRange = 0
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) == false then
            local tEnemyPD = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD, tLZOrWZTeamData[M28Map.reftoNearestDFEnemies])
            if M28Utilities.IsTableEmpty(tEnemyPD) == false then
                for iPD, oPD in tEnemyPD do
                    if M28UnitInfo.IsUnitValid(oPD) and oPD:GetFractionComplete() == 1 and M28Utilities.GetDistanceBetweenPositions(oPD:GetPosition(), oACU:GetPosition()) < oPD[M28UnitInfo.refiDFRange] then
                        iEnemyT2PDInOurRange = iEnemyT2PDInOurRange + 1
                    end
                end
            end
        end
        if iEnemyT2PDInOurRange == 0 then
            return false
        elseif iEnemyT2PDInOurRange >= 4 then
            return true
        elseif iACUHealth > 3000 + 1500 * iEnemyT2PDInOurRange then
            return false
        else
            return true
        end

    end
end

function UpdateUnitUpgradeCountTrackingIfNotSet(oUnit)
    --E.g. for SACUs that are transferred on player death
    if not(oUnit[refiUpgradeCount]) then
        if __blueprints[oUnit.UnitId].Enhancements then
            for sEnhancement, tEnhancement in __blueprints[oUnit.UnitId].Enhancements do
                if oUnit:HasEnhancement(sEnhancement) then
                    oUnit[refiUpgradeCount] = (oUnit[refiUpgradeCount] or 0) + 1
                    if tEnhancement.Prerequisite then oUnit[refiUpgradeCount] = oUnit[refiUpgradeCount] + 1 end
                end
            end
        end
    end
end