---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 08:29
---
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')

--ACU specific variables against the ACU
refbDoingInitialBuildOrder = 'M28ACUInitialBO'
reftPreferredUpgrades = 'M28ACUPreferredUpgrades' --table of the enhancement IDs in the order that we want to get them (which is updated to remove any upgrades we already have as and when we get them)
refiUpgradeCount = 'M28ACUUpgradeCount' --Number of upgrades the ACU has
refiTimeLastWantedToRun = 'M28ACUTimeLastWantedToRun' --gametimeseconds that last wanted to run
reftiLastAssignedPlateauAndZone = 'M28ACULastPlateauAndLZ' --Records the last plateau and LZ/WZ that we were assigned to; if in WZ then plateau is 0
reftiCurAssignedPlateauAndZone = 'M28ACUCurPlateauAndLZ' --Records the current plateau and LZ/WZ that we are assigned to, if we are in a valid LZ/WZ; if WZ then plateau is 0
refbStartedUnderwater = 'M28ACUStartUnderwater' --true if ACU started underwater
refiTimeLastToldToMoveToZone = 'M28ACUTimeLastMoveZone' --gametime last told to move to a zone
refiLastPlateauAndZoneToMoveTo = 'M28ACULastZoneToMove' --PlateauOrZero and Land/Water zone ref if given move to zone order
refiTimeLastToldToAttackUnitInOtherZone = 'M28ACUTimeLastAttackUnit'
refiLastPlateauAndZoneToAttackUnitIn = 'M28ACULastZoneToAttack' --PlateauOrZero and Land/Water zone ref if given move to zone order in order to attack a unit
reftiTimeLastRanFromZoneByPlateau = 'M28ACUTimeLastRanByZone' --[x] is plateau or zero, [y] is the zone (currently only have logic for LZs though), returns gametimeseconds that last ran when in that zone
refbUseACUAggressively = true

function ACUBuildUnit(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearchForAdjacencyAndUnderConstruction, iMaxAreaToSearchForBuildLocation, iOptionalAdjacencyCategory, iOptionalCategoryBuiltUnitCanBuild)
    local sFunctionRef = 'ACUBuildUnit'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Do we have a nearby unit of the type we want to build under construction?
    local tNearbyUnitsOfCategoryToBuild = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, oACU:GetPosition(), iMaxAreaToSearchForAdjacencyAndUnderConstruction, 'Ally')
    local oNearestPartComplete

    if M28Utilities.IsTableEmpty(tNearbyUnitsOfCategoryToBuild) == false then
        local iClosestUnit = 10000
        local iCurDist
        for _, oUnit in tNearbyUnitsOfCategoryToBuild do
            if oUnit:GetFractionComplete() < 1 then
                iCurDist = M28Utilities.GetTravelDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition(), M28Map.refPathingTypeAmphibious)
                if iCurDist < iClosestUnit then
                    oNearestPartComplete = oUnit
                    iClosestUnit = iCurDist
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; brain='..aiBrain.Nickname..'; Is tNearbyUnitsOfCategoryToBuild empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnitsOfCategoryToBuild))..'; Is oNearestPartComplete valid='..tostring(M28UnitInfo.IsUnitValid(oNearestPartComplete))) end
    if M28UnitInfo.IsUnitValid(oNearestPartComplete) then
        if bDebugMessages == true then LOG(sFunctionRef..': Will assist part complete building='..oNearestPartComplete.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestPartComplete)) end
        local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
        if not(tLastOrder[M28Orders.subrefoOrderUnitTarget] == oNearestPartComplete) then
            M28Orders.IssueTrackedRepair(oACU, oNearestPartComplete, false, 'ACUComplB', false)
            --M28Orders.IssueTrackedGuard(oACU, oNearestPartComplete, false)
        end

    else
        --No nearby under construction factory, so build one unless we allready have a queued orer to build one
        local bAlreadyHaveOrder = false
        M28Orders.UpdateRecordedOrders(oACU)
        local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
        --NOTE: Dont do location check, as we will exclude queued locations; i.e. first time this runs ACU queues land fac; second time it runs if it looks for a location to build it treats the first location as unavailable (due to the queued order) so tries somewhere else
        if tLastOrder[M28Orders.subrefsOrderBlueprint] and EntityCategoryContains(iCategoryToBuild, tLastOrder[M28Orders.subrefsOrderBlueprint]) then
            bAlreadyHaveOrder = true
        end
        if bDebugMessages == true then LOG(sFunctionRef..': tLastOrder='..reprs(tLastOrder)..'; bAlreadyHaveOrder='..tostring(bAlreadyHaveOrder)) end
        if not(bAlreadyHaveOrder) then
                                                        --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerActionForDebug, iCategoryToBuild, iMaxAreaToSearch,                                   iCatToBuildBy,              tAlternativePositionToLookFrom, bLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZTeamData)
            local sBlueprint, tBuildLocation = M28Engineer.GetBlueprintAndLocationToBuild(aiBrain, oACU,        nil,                            iCategoryToBuild, iMaxAreaToSearchForAdjacencyAndUnderConstruction, iOptionalAdjacencyCategory, nil,                            false,                      nil,         iOptionalCategoryBuiltUnitCanBuild,    nil)
            if not(tBuildLocation) then sBlueprint, tBuildLocation = M28Engineer.GetBlueprintAndLocationToBuild(aiBrain, oACU, nil, iCategoryToBuild, iMaxAreaToSearchForBuildLocation, nil, nil,                           false,                      nil,         iOptionalCategoryBuiltUnitCanBuild, nil) end
            if bDebugMessages == true then
                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oACU:GetPosition(), true, oACU)
                LOG(sFunctionRef..': Blueprint to build='..(sBlueprint or 'nil')..'; tBuildLocation='..repru(tBuildLocation)..'; ACU plateau and land zone based on cur position='..iPlateau..'; iLandZone='..(iLandZone or 'nil')..'; iMaxAreaToSearchForBuildLocation='..(iMaxAreaToSearchForBuildLocation or 'nil')..'; was iOptionalAdjacencyCategory nil='..tostring(iOptionalAdjacencyCategory == nil))
                if sBlueprint and tBuildLocation then
                    LOG(sFunctionRef..': Can build structure at target='..tostring(aiBrain:CanBuildStructureAt(sBlueprint, tBuildLocation)))
                end
            end
            if sBlueprint and tBuildLocation then
                --If our last order was to build this unit (ignoring location)
                --Move to the target and then build on it
                local tMoveTarget = M28Engineer.GetLocationToMoveForConstruction(oACU, tBuildLocation, sBlueprint)
                if tMoveTarget then
                    --IssueTrackedMoveAndBuild(oUnit, tBuildLocation, sOrderBlueprint, tMoveTarget, iDistanceToReorderMoveTarget, bAddToExistingQueue)
                    M28Orders.IssueTrackedMoveAndBuild(oACU, tBuildLocation, sBlueprint, tMoveTarget, 2, false)
                else
                    M28Orders.IssueTrackedBuild(oACU, tBuildLocation, sBlueprint, false)
                end
            else
                --M28Orders.UpdateRecordedOrders(oACU) --now are doing this earlier on
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ACUActionBuildFactory(aiBrain, oACU, tLZData, tLZTeamData, iFactoryCategoryOverride, iEngineerActionOverride)
    local sFunctionRef = 'ACUActionBuildFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iMaxAreaToSearch = 35
    local iCategoryToBuild
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for aiBrain '..aiBrain.Nickname..' at time '..GetGameTimeSeconds()) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) then M28Utilities.ErrorHandler('Empty allied units table') end
    if iFactoryCategoryOverride then iCategoryToBuild = iFactoryCategoryOverride
    else
        local iTeam = oACU:GetAIBrain().M28Team
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if we want to build an air factory, do we want air instead of land='..tostring(M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData))..'; Is tLZTeamData[M28Map.subrefLZTAlliedUnits] empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]))..'; tLZTeamData[CoreBase]='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])) end
        if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) then iCategoryToBuild = M28UnitInfo.refCategoryAirFactory
        else iCategoryToBuild = M28UnitInfo.refCategoryLandFactory
        end
    end
    --= (iFactoryCategoryOverride or M28UnitInfo.refCategoryLandFactory)
    if aiBrain:GetCurrentUnits(iCategoryToBuild) >= 2 and iCategoryToBuild == M28UnitInfo.refCategoryLandFactory then
        iMaxAreaToSearch = 20
    end
    ACUBuildUnit(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearch, iMaxAreaToSearch * 2, M28Engineer.tiActionAdjacentCategory[(iEngineerActionOverride or M28Engineer.refActionBuildLandFactory)], M28UnitInfo.refCategoryEngineer)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData)
    --If have hydro under construction then assist the hydro if it's within build range; if not under construciton or out of build range then move towards it
    local sFunctionRef = 'ACUActionAssistHydro'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Redundancy - make sure we have hydros in this LZ:
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oACU:GetPosition(), true, oACU)
    if bDebugMessages == true then LOG(sFunctionRef..': Do we have hydro loations in iPlateau '..iPlateau..'; iLZ='..iLandZone..': Table empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]))) end
    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]) == false then
        local tNearestHydro
        local iNearestHydro = 10000
        local iCurDist
        local iBuildRange = oACU:GetBlueprint().Economy.MaxBuildDistance
        local iMinRangeToAssist = iBuildRange + 10
        for iHydro, tHydro in tLZOrWZData[M28Map.subrefHydroLocations] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tHydro, oACU:GetPosition())
            if iCurDist < iNearestHydro then iNearestHydro = iCurDist tNearestHydro = tHydro end
        end
        --If we are in range of a hydro then assist it (or wait until construction is started)
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if have hydro near enough to consider mvoing to and assisting, iNearestHydro='..iNearestHydro..'; iMinRangeToAssist='..iMinRangeToAssist) end
        if iNearestHydro < iMinRangeToAssist then
            local tUnderConstructionHydro = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryHydro, tNearestHydro, 5, 'Ally')
            local oUnderConstructionHydro
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of hydros around nearest hydro point empty='..tostring(M28Utilities.IsTableEmpty(tUnderConstructionHydro))) end
            if M28Utilities.IsTableEmpty(tUnderConstructionHydro) == false then
                for iHydro, oHydro in tUnderConstructionHydro do
                    if oHydro:GetFractionComplete() < 1 then
                        oUnderConstructionHydro = oHydro
                        break
                    end
                end
            end
            if oUnderConstructionHydro then
                M28Orders.IssueTrackedRepair(oACU, oUnderConstructionHydro, false, 'RH')
            else
                oACU['M28BOHydroWait'] = ( oACU['M28BOHydroWait'] or 0) + 1
                if  oACU['M28BOHydroWait'] >= 20 then
                    ACUActionBuildPower(aiBrain, oACU)
                else
                    --Stay where we are as maybe we are waiting for an engi to start construction
                    M28Orders.IssueTrackedMove(oACU, oACU:GetPosition(), 3, false, 'W4C')
                end
            end
        else
            --Move to be near hydro
            local tLocationNearHydro = M28Engineer.GetLocationToMoveForConstruction(oACU, tNearestHydro, 'ueb1102', -0.5, false)
            if tLocationNearHydro then
                M28Orders.IssueTrackedMove(oACU, tLocationNearHydro, 0.5, false, 'M2NH')
            else
                M28Orders.IssueTrackedMove(oACU, tNearestHydro, 0.5, false, 'M2H')
            end
        end
    else
        M28Utilities.ErrorHandler('Trying to buidl hydro when none nearby')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ACUActionBuildPower(aiBrain, oACU)
    local sFunctionRef = 'ACUActionBuildPower'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCategoryToBuild = M28UnitInfo.refCategoryPower
    local iMaxAreaToSearch = 16
    local iOptionalAdjacencyCategory
    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) > 0 then iOptionalAdjacencyCategory = M28UnitInfo.refCategoryAirFactory
    elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= 11 then iOptionalAdjacencyCategory = M28UnitInfo.refCategoryLandFactory
    end
    if bDebugMessages == true then LOG(sFunctionRef..': About to tell ACU to build power; is optional adjacency category nil='..tostring(iOptionalAdjacencyCategory == nil)) end
    ACUBuildUnit(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearch, iMaxAreaToSearch * 3, iOptionalAdjacencyCategory, nil)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ACUActionBuildMex(aiBrain, oACU, iAreaToSearchOverride)
    local sFunctionRef = 'ACUActionBuildMex'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iMaxAreaToSearch = iAreaToSearchOverride
    --Increase search range if still doing initial build order, as this suggests we have mexes in our initial land zone that we havent built on yet
    if not(iMaxAreaToSearch) then
        if oACU[refbDoingInitialBuildOrder] then
            if aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 12 then iMaxAreaToSearch = 50
            elseif aiBrain[M28Economy.refiGrossMassBaseIncome] < 6 then iMaxAreaToSearch = 30
            end
        else
            iMaxAreaToSearch = 20
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': About to tell ACU to build a mex, iMaxAreaToSearch='..iMaxAreaToSearch..'; iAreaToSearchOverride='..(iAreaToSearchOverride or 'nil')) end
    ACUBuildUnit(aiBrain, oACU, M28UnitInfo.refCategoryMex, iMaxAreaToSearch, iMaxAreaToSearch * 2, nil, nil)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetACUEarlyGameOrders(aiBrain, oACU)
    local sFunctionRef = 'GetACUEarlyGameOrders'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Are we already building something?
    if bDebugMessages == true then LOG(sFunctionRef..': ACU unit state='..M28UnitInfo.GetUnitState(oACU)) end
    if not(oACU:IsUnitState('Building')) and not(oACU:IsUnitState('Repairing')) then
        local iPlateauOrZero, iLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oACU:GetPosition())
        local tLZOrWZData
        local tLZOrWZTeamData
        if iPlateauOrZero == 0 then
            tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLZOrWZ]][M28Map.subrefPondWaterZones][iLZOrWZ]
            tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][aiBrain.M28Team]
        else
            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLZOrWZ]
            tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
        end

        --local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oACU:GetPosition(), true, oACU)

        if bDebugMessages == true then LOG(sFunctionRef..': iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLZOrWZ='..(iLZOrWZ or 'nil')..'; ACU pos='..repru(oACU:GetPosition())) end
        if (iPlateauOrZero or 0) > 0 and iLZOrWZ > 0 then
            --Do we want to build a mex, hydro or factory?
            if bDebugMessages == true then LOG(sFunctionRef..': Current land factories='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory)..'; Gross energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; Gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]) end
            local iMinEnergyPerTickWanted = 14 --i.e. 6 T1 PGens given ACU gives 2 E
            local iCurLandFactories = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory)
            if iCurLandFactories == 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Want ACU to build land factory') end
                ACUActionBuildFactory(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryLandFactory)
                --do we have unbuilt nearby mexes (within 2 of ACU build range)? if so then build on them
            elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 12 and ConsiderBuildingMex(tLZOrWZData, tLZOrWZTeamData, oACU, 2) then
                --Do nothing - have bene given an order to build a neaby mex
            elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= iMinEnergyPerTickWanted then

                --Do we want to build a hydro (so get mexes first then hydro) or build pgen?

                if bDebugMessages == true then LOG(sFunctionRef..': Will adjust build order depending on if have hydro nearby. Is table of land zone hydros empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]))) end
                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]) then
                    --Per discord gameplay and training pinned build order for going land facs with no hydro:
                    --ACU:      Landfac - 2 PG - 2 Mex - 1 PG - 2 Mex - 3 PG - Landfac - PG - Landfac
                    if bDebugMessages == true then LOG(sFunctionRef..': No hydro locations so will build power or mex depending on income') end
                    if aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 6 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to build initial PGens') end
                        ACUActionBuildPower(aiBrain, oACU)
                    else
                        local iMexInLandZone = 0
                        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZMexLocations]) == false then iMexInLandZone = table.getn(tLZOrWZData[M28Map.subrefLZMexLocations]) end
                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding on ACU action for where no hydro nearby, gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; Gross energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; iMexInLandZone='..iMexInLandZone..'; iMinEnergyPerTickWanted='..iMinEnergyPerTickWanted..'; iCurLandFactories='..iCurLandFactories) end
                        if aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(2, iMexInLandZone) * 0.2 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Want at least 2 mexes') end
                            ACUActionBuildMex(aiBrain, oACU)

                        elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 8 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Want at least 4 PGens') end
                            ACUActionBuildPower(aiBrain, oACU)
                        elseif aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(4, iMexInLandZone) * 0.2 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Want up to 4 mexes') end
                            ACUActionBuildMex(aiBrain, oACU)
                        elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] < iMinEnergyPerTickWanted then
                            if bDebugMessages == true then LOG(sFunctionRef..': Want basic level of power') end
                            ACUActionBuildPower(aiBrain, oACU)
                        elseif iCurLandFactories < 2 and iCurLandFactories + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) < 3 and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] and M28Conditions.WantMoreFactories(aiBrain.M28Team, iPlateauOrZero, iLZOrWZ) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Want 2 land factories') end
                            ACUActionBuildFactory(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData)
                        elseif aiBrain[M28Economy.refiGrossMassBaseIncome] < iMexInLandZone * 0.2 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to build on every mex in land zone') end
                            ACUActionBuildMex(aiBrain, oACU)
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': No more initial BO actions so aborting initial build order') end
                            --No more actions so abort initial BO
                            oACU[refbDoingInitialBuildOrder] = false
                        end
                    end

                    --Redundancy if failed to get orer from the above
                    if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) and oACU[refbDoingInitialBuildOrder] then
                        --No hydro nearby - try building power; then try building mex; then cancel initial build order
                        ACUActionBuildMex(aiBrain, oACU)
                        if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) then
                            ACUActionBuildPower(aiBrain, oACU)
                            if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) then
                                oACU[refbDoingInitialBuildOrder] = false
                            end
                        end
                    end
                else --Have a hydro so get more mexes initially
                    --Max mex to build
                    local iMexInLandZone = 0
                    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZMexLocations]) == false then iMexInLandZone = table.getn(tLZOrWZData[M28Map.subrefLZMexLocations]) end
                    if bDebugMessages == true then LOG(sFunctionRef..': Hydro is nearby, Gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; iMexInLandZone='..iMexInLandZone..'; Gross base energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]) end
                    if aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(4, iMexInLandZone) * 0.2 then
                        if bDebugMessages == true then LOG(sFunctionRef..': We ahve mexes in land zone and we havent built on all of them so will build a mex') end
                        ACUActionBuildMex(aiBrain, oACU)
                        if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) then M28Utilities.ErrorHandler('ACU wants to build a mex but failed to find anywhere') end
                    elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 10 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try to assist a hydro nearby') end
                        ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData)
                    else
                        --Have base level of power suggesting already have hydro
                        if bDebugMessages == true then LOG(sFunctionRef..': Want more power to reach a base level') end
                        ACUActionBuildPower(aiBrain, oACU)
                    end

                    --Redundancy if fail to get order from above
                    if bDebugMessages == true then LOG(sFunctionRef..': Is ACU table of last orders empty after attempting above='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))) end
                    if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) and oACU[refbDoingInitialBuildOrder] then
                        --Is it just that we want to assist a hydro and engineers havent started one yet? If so then check if we have an engineer assigned to build one, and check the game time
                        if GetGameTimeSeconds() <= 180 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 10 and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]) == false then
                            ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData)
                            if bDebugMessages == true then LOG(sFunctionRef..': Assuming we are waiting for an engi to start on building a hydro, or we have no nearby mexes to our ACU') end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Failed to get order from above so will resort to backup logic') end
                            --No hydro nearby - try building power; then try building mex; then cancel initial build order
                            ACUActionBuildMex(aiBrain, oACU)
                            if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) then
                                ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData)
                                if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) then
                                    ACUActionBuildPower(aiBrain, oACU)
                                    if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) then
                                        oACU[refbDoingInitialBuildOrder] = false
                                    end
                                end
                            end
                        end
                    end
                end
            else
                --Have initial power and mexes built, get second factory now
                if iCurLandFactories < 2 and M28Conditions.WantMoreFactories(aiBrain.M28Team, iPlateauOrZero, iLZOrWZ) and iCurLandFactories + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) < 3 then
                    ACUActionBuildFactory(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData)
                else
                    local iMexInLandZone = 0
                    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZMexLocations]) == false then iMexInLandZone = table.getn(tLZOrWZData[M28Map.subrefLZMexLocations]) end
                    if aiBrain[M28Economy.refiGrossMassBaseIncome] < iMexInLandZone * 0.2 then
                        ACUActionBuildMex(aiBrain, oACU)
                    else
                        --Finish the initial BO
                        oACU[refbDoingInitialBuildOrder] = false
                    end
                end
            end
        else
            --ACU is underwater so presumably water based start position

            if (iLZOrWZ or 0) == 0 then

                --Go to the midpoint of the nearest zone that can find
                --Move to midpoint
                M28Orders.IssueTrackedMove(oACU, tLZOrWZData[M28Map.subrefMidpoint], 1, false, 'FindValidLoc', false)
                M28Utilities.ErrorHandler('ACU showing as not being on a land zone, but doesnt have a water zone either, will try moving to midpoint of nearest land or water zone')
            else
                oACU[refbStartedUnderwater] = true
                --Are in a water zone - build a naval fac and build on any unbuilt mexes before marking initial BO as being  complete
                local iCurNavalFactories = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalFactory)
                if bDebugMessages == true then LOG(sFunctionRef..': iCurNavalFactories='..iCurNavalFactories..'; Is table of unbuilt mex locations empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]))..'; Gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; Gross energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; Is table of hydro locations empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]))) end
                if iCurNavalFactories == 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want ACU to build land factory') end
                    ACUActionBuildFactory(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryNavalFactory, M28Engineer.refActionBuildNavalFactory)
                else
                    --Build mexes if nearby assuming we have nearby hydr; assist hydro if we have hydro
                    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false and (aiBrain[M28Economy.refiGrossMassBaseIncome] < 0.8 or aiBrain[M28Economy.refiGrossEnergyBaseIncome] > 10) then
                        if bDebugMessages == true then LOG(sFunctionRef..': We have unbuilt mexes in water zone and our income seems less than 4 mex equiv, so will build mexes') end
                        ACUActionBuildMex(aiBrain, oACU)
                    elseif M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]) == false and aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 10 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try to assist a hydro nearby') end
                        ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData)
                    elseif M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false then
                        ACUActionBuildMex(aiBrain, oACU)
                    else
                        oACU[refbDoingInitialBuildOrder] = false
                    end
                end
            end

        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Are building so wont give any new orders') end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, is ACU table of last orders empty='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetUpgradePathForACU(oACU)
    --Records the order of upgrades we will want for the ACU
    local sFunctionRef = 'GetUpgradePathForACU'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if oACU[refbStartedUnderwater] then

        if EntityCategoryContains(categories.UEF, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'ResourceAllocation', 'Shield'}
        elseif EntityCategoryContains(categories.AEON, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'ResourceAllocation', 'ResourceAllocationAdvanced'}
        elseif EntityCategoryContains(categories.CYBRAN, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'NaniteTorpedoTube', 'StealthGenerator'}
        elseif EntityCategoryContains(categories.SERAPHIM, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'ResourceAllocation', 'ResourceAllocationAdvanced'}
        end
    else
        if EntityCategoryContains(categories.UEF, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'HeavyAntiMatterCannon', 'DamageStabilization', 'Shield'}
        elseif EntityCategoryContains(categories.AEON, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'CrysalisBeam', 'HeatSink', 'Shield'}
        elseif EntityCategoryContains(categories.CYBRAN, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'CoolingUpgrade', 'StealthGenerator'}
        elseif EntityCategoryContains(categories.SERAPHIM, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'RateOfFire', 'AdvancedEngineering'}
        end
    end

    --Check all of these are options (in case a mod has changed them)
    local oBP = oACU:GetBlueprint()
    if M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) == false then
        for iUpgradeWanted, sUpgradeWanted in oACU[reftPreferredUpgrades] do
            if M28Utilities.IsTableEmpty(oBP.Enhancements[sUpgradeWanted]) then
                oACU[reftPreferredUpgrades] = {}
                break
            end
        end
    end
    if M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) then
        --Find the cheapest upgrade that boosts either rate of fire or range (if didnt start underwater) or that boosts build power (if started underwater)
        oACU[reftPreferredUpgrades] = {}
        local iLowestMassCost = 1000000
        local sLowestUpgrade
        for sUpgrade, tUpgrade in oACU:GetBlueprint().Enhancements do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering sUpgrade='..sUpgrade..'; tUpgrade='..reprs(tUpgrade)) end
            if (oACU[refbStartedUnderwater] and (tUpgrade.NewBuildRate or 0) > 10) or (tUpgrade.NewMaxRadius or tUpgrade.NewRateOfFire) then
                if tUpgrade.BuildCostMass < iLowestMassCost and not(tUpgrade.Prerequisite) then
                    sLowestUpgrade = sUpgrade
                    iLowestMassCost = tUpgrade.BuildCostMass
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a new preferred upgrade '..sUpgrade..'; iLowestMassCost='..iLowestMassCost) end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished considering the cheapest gun improving upgrade, sLowestUpgrade='..(sLowestUpgrade or 'nil')) end
        if sLowestUpgrade then oACU[reftPreferredUpgrades] = {sLowestUpgrade} end
    end

    --Remove any upgrades that we already have
    if M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) == false then
        local tPreRequisites = {}
        local bCheckForPrerequisites
        if oACU[refiUpgradeCount] > 0 then
            for iEntry, sEnhancement in oACU[reftPreferredUpgrades] do
                if oBP.Enhancements[sEnhancement].Prerequisite and oACU:HasEnhancement(sEnhancement) then
                    table.insert(tPreRequisites, oBP.Enhancements[sEnhancement].Prerequisite)
                    bCheckForPrerequisites = true
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if sEnhancement '..sEnhancement..' has prerequisite, BP Preq val='..(oBP.Enhancements[sEnhancement].Prerequisite or 'nil')) end
            end
        end
        local bHavePrerequisite

        local iRevisedIndex = 1
        local iTableSize = table.getn(oACU[reftPreferredUpgrades])

        --First check if we have any upgrades that have prerequiites, in which case we want to remove those prerequisites first
        for iOrigIndex=1, iTableSize do
            if oACU[reftPreferredUpgrades][iOrigIndex] then
                if not(oACU:HasEnhancement(oACU[reftPreferredUpgrades][iOrigIndex])) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                    --Check this isnt a prerequisite of an enhancement we have
                    bHavePrerequisite = false
                    if bCheckForPrerequisites then
                        for iEntry, sPreRequisite in tPreRequisites do
                            if sPreRequisite == oACU[reftPreferredUpgrades][iOrigIndex] then
                                bHavePrerequisite = true
                                break
                            end
                        end
                    end
                    if bHavePrerequisite then
                        oACU[reftPreferredUpgrades][iOrigIndex] = nil;
                    else

                        --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                        if (iOrigIndex ~= iRevisedIndex) then
                            oACU[reftPreferredUpgrades][iRevisedIndex] = oACU[reftPreferredUpgrades][iOrigIndex];
                            oACU[reftPreferredUpgrades][iOrigIndex] = nil;
                        end
                        iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                    end
                else
                    oACU[reftPreferredUpgrades][iOrigIndex] = nil;
                end
            end
        end
    end
end

function GetACUUpgradeWanted(oACU)
    --Returns nil if cantr find anything
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetACUUpgradeWanted'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local sUpgradeWanted

    --If we were to get an upgrade, what upgrade would it be?
    if not(oACU[reftPreferredUpgrades]) then
        GetUpgradePathForACU(oACU)
    end
    local aiBrain = oACU:GetAIBrain()
    local iTeam = aiBrain.M28Team
    if M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) == false and not(M28Conditions.HaveLowPower(iTeam)) then

        local sPotentialUpgrade = oACU[reftPreferredUpgrades][1]
        if sPotentialUpgrade then
            local tEnhancement = oACU:GetBlueprint().Enhancements[sPotentialUpgrade]
            --Do we have the eco to support the upgrade?
            if bDebugMessages == true then LOG(sFunctionRef..': Considering sPotentialUpgrade='..sPotentialUpgrade..'; for ACU '..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' for brain '..oACU:GetAIBrain().Nickname..'; tEnhancement='..reprs(tEnhancement)) end
            local iBuildRate = oACU:GetBlueprint().Economy.BuildRate
            if aiBrain.CheatEnabled then iBuildRate = iBuildRate * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier] end
            local iMassCostPerTick = 0.1 * tEnhancement.BuildCostMass / (tEnhancement.BuildTime / iBuildRate)
            local iEnergyCostPerTick = 0.1 * tEnhancement.BuildCostEnergy / (tEnhancement.BuildTime / iBuildRate)
            --Do we have enough gross energy?
            local iActiveACUUpgrades = 0
            local iResourceFactor
            if aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] then
                iResourceFactor = 1
            elseif aiBrain[M28Map.refbCanPathToEnemyBaseWithAmphibious] then
                iResourceFactor = 2
            else
                iResourceFactor = 4 --Cant path to enemy except with air
            end
            if oACU[refiUpgradeCount] >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 2 then iResourceFactor = iResourceFactor * 1.3 end
            if oACU[refbStartedUnderwater] and (tEnhancement.ProductionPerSecondEnergy or 0) > 20 then iResourceFactor = 0.5 end
            local iDistToEnemyBase
            local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oACU:GetPosition())
            if iPlateauOrZero == 0 then
                iDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam][M28Map.reftClosestEnemyBase])
            else
                iDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.reftClosestEnemyBase])
            end
            if iDistToEnemyBase >= 400 then iResourceFactor = iResourceFactor * 1.5 end
            if oACU[refiUpgradeCount] > 0 then
                if oACU[refiUpgradeCount] >= 2 and M28Conditions.HaveLowMass(aiBrain) then iResourceFactor = iResourceFactor * 2
                else iResourceFactor = iResourceFactor * 1.25
                end
            end

            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingACUs]) == false then iActiveACUUpgrades = table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingACUs]) end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have enough resources to get this upgrade, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; Net mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]..'; Other active upgrades='..iActiveACUUpgrades..'; Is safe to get upgrade='..tostring(M28Conditions.SafeToUpgradeUnit(oACU))..'; iEnergyCostPerTick='..iEnergyCostPerTick..'; iMassCostPerTick='..iMassCostPerTick..'; iResourceFactor'..iResourceFactor..'; iDistToEnemyBase='..iDistToEnemyBase..'; oACU[refiUpgradeCount]='..oACU[refiUpgradeCount]..'; aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]='..tostring(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand])..'; Have low mass='..tostring(M28Conditions.HaveLowMass(aiBrain))) end
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 45 * iActiveACUUpgrades * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] + iResourceFactor * iEnergyCostPerTick * 1.35 then
                --Do we have enough gross mass?
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= iActiveACUUpgrades * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] + iResourceFactor * 2.5 * iMassCostPerTick * 2 then
                    --Do we have enough net energy?
                    if (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= iActiveACUUpgrades * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] + iResourceFactor * 100 * iEnergyCostPerTick * 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 5) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= iEnergyCostPerTick * math.min(2.5, iResourceFactor * 0.4) then
                        --Do we have enoguh net mass?
                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= iActiveACUUpgrades * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] + iResourceFactor * 3.5 * iMassCostPerTick * 3 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= iMassCostPerTick * math.min(2.5, iResourceFactor * 0.4) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= math.min(3, iResourceFactor) * tEnhancement.BuildCostMass * 0.5 then
                            sUpgradeWanted = sPotentialUpgrade
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return sUpgradeWanted
end

function DoesACUWantToRun(iPlateau, iLandZone, tLZData, tLZTeamData, oACU)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DoesACUWantToRun'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bWantToRun = false
    --Dont run if in core base unless low health or close to the rally point
    if bDebugMessages == true then LOG(sFunctionRef..': Is ACU in core base='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])..' iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; oACU='..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..'; M28Team.tTeamData[aiBrain.M28Team][M28Team.refbDangerousForACUs]='..tostring(M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refbDangerousForACUs] or false)..'; Does enemy have sub='..tostring(M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refbEnemyHasSub] or false)) end
    if tLZTeamData[M28Map.subrefLZbCoreBase] and (oACU[refbUseACUAggressively] or (M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.4 and oACU[refiUpgradeCount] > 0 or not(M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refbEnemyHasUpgradedACU])) or M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= 15) then
        if bDebugMessages == true then LOG(sFunctionRef..': Are in core base with some health so dont want to run') end
    else
        --Run if on low health or shield
        local iACUThreat = (M28UnitInfo.GetCombatThreatRating({ oACU}, false) or 0)
        local bAgainstEnemyACUAndMightWin = false

        --If we are closer to enemy base then require a greater threat differential
        local iDistToFriendlyBase
        local iDistToEnemyBase
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftClosestFriendlyBase]) == false then
            iDistToFriendlyBase = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], oACU:GetPosition())
            iDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], oACU:GetPosition())
        else
            --May e.g. be underwater and not have a LZ
            iDistToFriendlyBase = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M28Map.PlayerStartPoints[oACU:GetAIBrain():GetArmyIndex()])
            iDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M28Map.GetPrimaryEnemyBaseLocation(oACU:GetAIBrain()))
        end
        local iPercentageToFriendlyBase = iDistToFriendlyBase / (iDistToFriendlyBase + iDistToEnemyBase)

        if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 then
            local tEnemyACU = EntityCategoryFilterDown(categories.COMMAND, tLZTeamData[M28Map.subrefTEnemyUnits])
            if M28Utilities.IsTableEmpty(tEnemyACU) == false then
                if table.getn(tEnemyACU) == 1 then
                    if (tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0) + iACUThreat > 1.05 * (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) then
                        --If we are closer to enemy base then require a greater threat differential
                        if iPercentageToFriendlyBase < 0.6 or tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] + iACUThreat > 1.25 * tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] then
                            --Dont do this if enemy has air to ground threat and we dont have >= this in MAA
                            if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] == 0 or tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] >= 0.25 * tLZTeamData[M28Map.refiEnemyAirToGroundThreat] then
                                bAgainstEnemyACUAndMightWin = true
                            end
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iACUThreat='..(iACUThreat or 'nil')..'; LZ enemy combat total='..(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; bOneEnemyACUInSameLZ='..tostring(bAgainstEnemyACUAndMightWin or false)..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]='..(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 'nil')..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 'nil')) end
        if (iACUThreat <= 500 or (iACUThreat <= 600 and (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 80)) and (not(bAgainstEnemyACUAndMightWin) or (oACU[refbUseACUAggressively] and (iACUThreat + (tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0) + 250 < (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)))) then
            if bDebugMessages == true then LOG(sFunctionRef..': ACU has low threat so want to run') end
            bWantToRun = true
        else
            local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oACU, true)
            if bDebugMessages == true then LOG(sFunctionRef..'; iCurSHield='..iCurShield..'; iMaxShield='..iMaxShield) end
            if iMaxShield > 0 and iCurShield <= (iMaxShield * 0.1) then
                if bDebugMessages == true then LOG(sFunctionRef..': ACU shield is less than 10% so want to run') end
                bWantToRun = true
            else
                local iHealthPercent = M28UnitInfo.GetUnitHealthPercent(oACU)
                local iPercentMod = 1
                if oACU[refbUseACUAggressively] then iPercentMod = 0.5 end
                if bDebugMessages == true then LOG(sFunctionRef..': iHealthPercent='..iHealthPercent) end
                if (iHealthPercent <= 0.6 * iPercentMod or (iHealthPercent <= 0.75 * iPercentMod and (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 80)) and (not(bAgainstEnemyACUAndMightWin) or iHealthPercent <= 0.5 * iPercentMod) then
                    if bDebugMessages == true then LOG(sFunctionRef..': ACU is injured so want to run') end
                    bWantToRun = true
                else
                    --Do we have a land zone?
                    if iLandZone > 0 then
                        local iEnemyAirToGroundNearbyThreat = tLZTeamData[M28Map.refiEnemyAirToGroundThreat]
                        --If there are big enemy threats then run if we arent adjacnet to a core LZ
                        local bAdjacentToCoreLZ = false
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][oACU:GetAIBrain().M28Team][M28Map.subrefLZbCoreBase] then bAdjacentToCoreLZ = true end
                                iEnemyAirToGroundNearbyThreat = iEnemyAirToGroundNearbyThreat + M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][oACU:GetAIBrain().M28Team][M28Map.refiEnemyAirToGroundThreat]
                            end
                        end

                        if M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refbDangerousForACUs] then
                            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) then
                                if bDebugMessages == true then LOG(sFunctionRef..': No adjacent land zones and dangerous for ACU so want to run') end
                                bWantToRun = true
                            else
                                if not(bAdjacentToCoreLZ) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Not adjacent to core LZ so want to run as it is dangerous for ACUs now') end
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                    bWantToRun = true
                                end
                            end

                        end
                        if not(bWantToRun) then

                            --If significant air to ground threat and not in adjacent to core base LZ then also run
                            if iEnemyAirToGroundNearbyThreat > 0 and not(bAdjacentToCoreLZ) and (iMaxShield == 0 or tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < tLZTeamData[M28Map.refiEnemyAirToGroundThreat] * 0.5) and (iEnemyAirToGroundNearbyThreat > 150 or not(oACU[refbUseACUAggressively])) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Significant air to ground threat so want to run') end
                                bWantToRun = true
                            else
                                local iEnemyNearbyThreat = (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                                local iTeam = oACU:GetAIBrain().M28Team
                                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                    for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Adding threat for iAdjLZ='..iAdjLZ..' with threat '..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal]) end
                                        iEnemyNearbyThreat = iEnemyNearbyThreat + M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal]
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': iEnemyNearbyThreat='..iEnemyNearbyThreat..'; iACUThreat='..iACUThreat..'; bAgainstEnemyACUAndMightWin='..tostring(bAgainstEnemyACUAndMightWin or false)..'; iPercentageToFriendlyBase='..iPercentageToFriendlyBase..'; bAdjacentToCoreLZ='..tostring(bAdjacentToCoreLZ)) end
                                --Run if enemy has a really large threat (regardless of if we think we can beat it)
                                if iEnemyNearbyThreat > math.min(iACUThreat * 2, 6000) and (iEnemyNearbyThreat > iACUThreat * 3 or ((not(bAgainstEnemyACUAndMightWin) and iPercentageToFriendlyBase >= 0.35 and not(bAdjacentToCoreLZ) and not(oACU[refbUseACUAggressively])))) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy has too large a threat so will run') end
                                    bWantToRun = true
                                else
                                    --Run if we dont have enough threat in this LZ to easily beat enemy threat in all adjacent LZs
                                    local iACUFactor = 0.5
                                    if bAgainstEnemyACUAndMightWin then iACUFactor = 1
                                    elseif bAdjacentToCoreLZ then iACUFactor = 0.9
                                    elseif iPercentageToFriendlyBase <= 0.4 then iACUFactor = 0.8
                                    end

                                    if not(oACU[refbUseACUAggressively]) and (iACUThreat * iACUFactor + (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0) < iEnemyNearbyThreat or (iACUThreat + (tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0) < iEnemyNearbyThreat)) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': iACUFactor='..iACUFactor..'; tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]='..(tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 'nil')..'; iEnemyNearbyThreat='..iEnemyNearbyThreat..'; Ally mobile DF total='..(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0)) end
                                        bWantToRun = true
                                    else
                                        --If enemy units are between us and the closest friendly base then also want to run
                                        local iACUDistToClosestFriendlyBase = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                                        if iEnemyNearbyThreat > 800 or (iEnemyNearbyThreat > 400 and not(oACU[refbUseACUAggressively])) then
                                            local tEnemyCombatUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandCombat,  tLZTeamData[M28Map.subrefTEnemyUnits])
                                            if M28Utilities.IsTableEmpty(tEnemyCombatUnits) == false then
                                                for iUnit, oUnit in tEnemyCombatUnits do
                                                    if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) < iACUDistToClosestFriendlyBase then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': iEnemyNearbyThreat='..iEnemyNearbyThreat..'; iACUDistToClosestFriendlyBase='..iACUDistToClosestFriendlyBase..'; Nearest enemy threat='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Dist of that to our base='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])) end
                                                        bWantToRun = true
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    else
                        --No land zone - if we have no order then return to base
                        if oACU[M28Orders.refiOrderCount] == 0 then
                            bWantToRun = true
                        end
                    end
                end
            end
        end
    end
    if bWantToRun then
        --Record the zone that we are in, and that we were traveling to, as running from
        if not(oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iLandZone]) then
            if not(oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau]) then
                if not(oACU[reftiTimeLastRanFromZoneByPlateau]) then oACU[reftiTimeLastRanFromZoneByPlateau] = {} end
                oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau] = {}
            end
        end
        oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iLandZone] = GetGameTimeSeconds()
        if oACU[refiTimeLastToldToMoveToZone] and GetGameTimeSeconds() - oACU[refiTimeLastToldToMoveToZone] <= 10 then
            local iTargetPlateau = oACU[refiLastPlateauAndZoneToMoveTo][1]
            local iTargetLZ = oACU[refiLastPlateauAndZoneToMoveTo][2]
            if not(oACU[reftiTimeLastRanFromZoneByPlateau][iTargetPlateau][iTargetLZ]) then
                if not(oACU[reftiTimeLastRanFromZoneByPlateau][iTargetPlateau]) then
                    if not(oACU[reftiTimeLastRanFromZoneByPlateau]) then oACU[reftiTimeLastRanFromZoneByPlateau] = {} end
                    oACU[reftiTimeLastRanFromZoneByPlateau][iTargetPlateau] = {}
                end
            end
            oACU[reftiTimeLastRanFromZoneByPlateau][iTargetPlateau][iTargetLZ] = GetGameTimeSeconds()
        end

    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bWantToRun='..tostring(bWantToRun)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bWantToRun
end

function DoesACUWantToReturnToCoreBase(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)
    --Returns true if want ACU to return to the core base - to be used when ACU is facing critical threat that could kill it vs the normal 'does acu want to run' where ACU might return to an island sub-base
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DoesACUWantToReturnToCoreBase'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iTeam = oACU:GetAIBrain().M28Team

    --If big threat or ACU very low health then retreat
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for ACU '..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' owned by '..oACU:GetAIBrain().Nickname..' on team '..iTeam..'; Dangerous for ACUs='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs])..'; ACU health percent='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; Air to ground threat='..tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat]) end
    if M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs] or M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.4 or tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] >= 2500 then
        if bDebugMessages == true then LOG(sFunctionRef..': Is dangerous for ACU or low health or large enemy air to ground threat so returning to base') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    else
        --Run if enemy has an ACU with upgrades or is upgrading and we have no upgrades
        if not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU] and oACU[refiUpgradeCount] == 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': Enemy ACU has upgrade and we dont so return to base') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        else

            --Run if we are underwater or on a different island to our core base and enemy has subs
            local bWaterIsDangerous = M28Team.tTeamData[iTeam][M28Team.refbEnemyHasSub]
            if not(bWaterIsDangerous) then
                bWaterIsDangerous = not(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoEnemyTorpBombers]))
                if not(bWaterIsDangerous) then
                    --If enemy has T3 air or T2 navy then treat water as dangerous for ACU
                    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech] >= 2 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 then
                        bWaterIsDangerous = true
                    elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 2 and M28Team.tAirSubteamData[oACU:GetAIBrain().M28AirSubteam][M28Team.refbFarBehindOnAir] then
                        bWaterIsDangerous = true
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bWaterIsDangerous='..tostring(bWaterIsDangerous)..'; Is ACU underwtaer='..tostring(M28UnitInfo.IsUnitUnderwater(oACU))) end
            if bWaterIsDangerous then
                --If ACU has 3+ upgrades and its movement target isn't more than 60% away from our base or 200 if higher, then dont run
                local bWantACUToRun = false
                if M28UnitInfo.IsUnitUnderwater(oACU) then
                    bWantACUToRun = true
                else
                    local iNearestBaseIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZOrWZTeamData[M28Map.reftClosestFriendlyBase])
                    local iCurIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, oACU:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': iNearestBaseIsland='..(iNearestBaseIsland or 'nil')..'; iCurIsland='..(iCurIsland or 'nil')) end
                    if not(iNearestBaseIsland == iCurIsland) then

                        bWantACUToRun = true
                    end
                end
                if bWantACUToRun and oACU[refiUpgradeCount] >= 3 and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.95 then
                    local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
                    if bDebugMessages == true then LOG(sFunctionRef..': repru(tLZData[M28Map.subrefMidpoint])='..repru(tLZOrWZData[M28Map.subrefMidpoint])..'; iPlateau='..(iPlateauOrZero or 'nil')..'; iLandZone='..(iLandOrWaterZone or 'nil')..'Is ACU underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oACU))..'; tLastOrder='..reprs(tLastOrder)) end
                    local iDistToBase
                    --Get nearest base to us
                    local tNearestFriendlyBase
                    local tNearestEnemyBase
                    if tLZOrWZTeamData[M28Map.reftClosestFriendlyBase] then
                        tNearestFriendlyBase = {tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][1], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][2], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][3]}
                        tNearestEnemyBase = {tLZOrWZTeamData[M28Map.reftClosestEnemyBase][1], tLZOrWZTeamData[M28Map.reftClosestEnemyBase][2], tLZOrWZTeamData[M28Map.reftClosestEnemyBase][3]}
                    else
                        --Use our start position
                        local aiBrain = oACU:GetAIBrain()
                        local iStartPositionX, iStartPositionZ = aiBrain:GetArmyStartPos()
                        tNearestFriendlyBase = { iStartPositionX, GetTerrainHeight(iStartPositionX, iStartPositionZ), iStartPositionZ }
                        tNearestEnemyBase = aiBrain[M28Overseer.refoNearestEnemyBrain][M28Overseer.refoNearestEnemyBrain]
                    end

                    if tLastOrder and M28Utilities.IsTableEmpty(tLastOrder[M28Orders.subreftOrderPosition]) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': tNearestFriendlyBase='..repru(tNearestFriendlyBase)..'; tLastOrder[M28Orders.subreftOrderPosition]='..repru(tLastOrder[M28Orders.subreftOrderPosition])) end
                        iDistToBase = M28Utilities.GetDistanceBetweenPositions(tNearestFriendlyBase, tLastOrder[M28Orders.subreftOrderPosition])
                    else
                        iDistToBase = M28Utilities.GetDistanceBetweenPositions(tNearestFriendlyBase, oACU:GetPosition())
                    end
                    if iDistToBase <= math.max(250, M28Utilities.GetDistanceBetweenPositions(tNearestEnemyBase, tNearestFriendlyBase) * 0.5) then
                        bWantACUToRun = false
                    end
                end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return bWantACUToRun
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GiveOverchargeOrderIfRelevant(tLZData, tLZTeamData, oACU)
    --Are there enemies in this LZ or adjacent, and do we have the energy to overcharge?
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GiveOverchargeOrderIfRelevant'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; DO we have enemies in this or adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ])..'; Can we use overcharge='..tostring(M28Conditions.CanUnitUseOvercharge(oACU:GetAIBrain(), oACU))) end

    if (tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) and M28Conditions.CanUnitUseOvercharge(oACU:GetAIBrain(), oACU) then
        local oUnitToOvercharge = M28Micro.GetOverchargeTarget(tLZData, oACU:GetAIBrain(), oACU)
        if bDebugMessages == true then LOG(sFunctionRef..': Do we have a valid OC target='..tostring(M28UnitInfo.IsUnitValid(oUnitToOvercharge))) end
        if oUnitToOvercharge then
            M28Orders.IssueTrackedOvercharge(oACU, oUnitToOvercharge, false, 'OC', true)
            if bDebugMessages == true then LOG(sFunctionRef..': Have just told ACU '..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' owned by '..oACU:GetAIBrain().Nickname..' to overcharge '..oUnitToOvercharge.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToOvercharge)) end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function AttackNearestEnemyWithACU(iPlateau, iLandZone, tLZData, tLZTeamData, oACU)
    --Attack move to the nearest enemy if we arent in range of it or retreat if we are in range of it
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AttackNearestEnemyWithACU'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local oEnemyToTarget
    local iCurDist
    local iClosestDist = 100000
    local tUnitsToTarget

    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
        tUnitsToTarget = tLZTeamData[M28Map.reftoNearestDFEnemies]
    elseif M28Utilities.IsTableEmpty(tLZData[M28Map.subrefTEnemyUnits]) == false then
        tUnitsToTarget = tLZData[M28Map.subrefTEnemyUnits]
    else
        tUnitsToTarget = oACU:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure, oACU:GetPosition(), 60, 'Enemy')
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Is table of units to target empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToTarget))) end
    if M28Utilities.IsTableEmpty(tUnitsToTarget) == false then
        local sPathing = M28Map.refPathingTypeAmphibious
        local iUnitPlateau, iUnitZone
        local bUnitInFurtherAwayZoneWeRanFrom
        local iStartPlateau, iStartZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tLZTeamData[M28Map.reftClosestFriendlyBase])
        local iACUZoneTravelDistToBase
        if iStartPlateau > 0 and iStartZone > 0 then iACUZoneTravelDistToBase = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iStartZone) end
        for iUnit, oUnit in tUnitsToTarget do
            if M28UnitInfo.IsUnitValid(oUnit) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                --Is unit in a zone that we have recently run from and that zone is further from our base than our current position?
                iUnitPlateau, iUnitZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                bUnitInFurtherAwayZoneWeRanFrom = false
                if iUnitPlateau > 0 and iUnitZone > 0 and (oACU[reftiTimeLastRanFromZoneByPlateau][iUnitPlateau][iUnitZone] and GetGameTimeSeconds() - oACU[reftiTimeLastRanFromZoneByPlateau][iUnitPlateau][iUnitZone] < 30) or (oACU[refiLastPlateauAndZoneToAttackUnitIn][2] == iUnitZone and oACU[refiLastPlateauAndZoneToAttackUnitIn][1] == iUnitPlateau and GetGameTimeSeconds() - (oACU[refiTimeLastToldToAttackUnitInOtherZone] or -100) < 30) then
                    --Unit in zone we ran from, dont want to attack it unless zone is closer to our base than our current zone
                    if iACUZoneTravelDistToBase and M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iUnitZone) > iACUZoneTravelDistToBase then
                        bUnitInFurtherAwayZoneWeRanFrom = true
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..M28Utilities.GetTravelDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition(), sPathing)..'; bUnitInFurtherAwayZoneWeRanFrom='..tostring(bUnitInFurtherAwayZoneWeRanFrom)..'; iUnitZone='..(iUnitZone or 'nil')..'; refiLastPlateauAndZoneToAttackUnitIn='..reprs(oACU[refiLastPlateauAndZoneToAttackUnitIn])..'; refiTimeLastToldToAttackUnitInOtherZone='..reprs(oACU[refiTimeLastToldToAttackUnitInOtherZone])) end
                if not(bUnitInFurtherAwayZoneWeRanFrom) then
                    --iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition())
                    iCurDist = M28Utilities.GetTravelDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition(), sPathing)
                    if iCurDist and iCurDist < iClosestDist then
                        iClosestDist = iCurDist
                        oEnemyToTarget = oUnit
                    end
                end
            end
        end
        if oEnemyToTarget then
            local iUnitPlateau, iUnitZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oEnemyToTarget:GetPosition())
            if iUnitZone > 0 then
                if not(oACU[refiLastPlateauAndZoneToAttackUnitIn]) then oACU[refiLastPlateauAndZoneToAttackUnitIn] = {} end
                oACU[refiTimeLastToldToAttackUnitInOtherZone] = GetGameTimeSeconds()
                oACU[refiLastPlateauAndZoneToAttackUnitIn] = {iUnitPlateau, iUnitZone}
            end
            if oACU[M28UnitInfo.refbLastShotBlocked] then
                --Shot blocked, but we must think we can win the fight or we would be running, so move towards enemy
                M28Orders.IssueTrackedMove(oACU, oEnemyToTarget:GetPosition(), 5, false, 'ACUBl', false)
            else
                local iDistToBeInRange = 1.5
                local iEnemyHighestDFInThisLZ = 0
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) == false then
                    for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] do
                        if iThreat >= 20 then iEnemyHighestDFInThisLZ = math.max(iEnemyHighestDFInThisLZ, iRange) end
                    end
                end

                if oACU[M28UnitInfo.refiDFRange] <= iEnemyHighestDFInThisLZ then iDistToBeInRange = 2.5
                elseif oACU[M28UnitInfo.refiDFRange] - 8 >= iEnemyHighestDFInThisLZ then
                    --If nearest enemy unit isnt facing us then increase dist to be in range
                    if M28Utilities.GetAngleDifference(M28UnitInfo.GetUnitFacingAngle(oEnemyToTarget), M28Utilities.GetAngleFromAToB(oEnemyToTarget:GetPosition(), oACU:GetPosition())) >= 55 then
                        iDistToBeInRange = 2.5
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': oEnemyToTarget='..oEnemyToTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToTarget)..'; iClosestDist='..iClosestDist..'; iDistToBeInRange='..iDistToBeInRange..'; ACU DF range='..(oACU[M28UnitInfo.refiDFRange] or 0)) end
                if iClosestDist and iClosestDist + iDistToBeInRange <= oACU[M28UnitInfo.refiDFRange]  then
                    --Retreat temporarily
                    local tRallyPoint = M28Land.GetNearestLandRallyPoint(tLZData, oACU:GetAIBrain().M28Team, iPlateau, iLandZone, 2, true)
                    M28Orders.IssueTrackedMove(oACU, tRallyPoint, 6, false, 'ACUKit', false)
                else
                    --Attack-move towards enemy
                    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Will attack-move to enemy target unless have active micro, oEnemyToTarget='..oEnemyToTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToTarget)..'; refbSpecialMicroActive='..tostring(oACU[M28UnitInfo.refbSpecialMicroActive] or false)) end
                    M28Orders.IssueTrackedAggressiveMove(oACU, oEnemyToTarget:GetPosition(), 5, false, 'ACUAM', false)
                end
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

    if oEnemyToTarget then return true else return false end
end

function ConsiderBuildingMex(tLZOrWZData, tLZOrWZTeamData, oACU, iOptionalMaxDistanceFromBuildRangeToConsider)
    --Do we have unclaimed mexes in the LZ? If so then build a mex on them.  However first check we dont alreayd have engineers trying to do this

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderBuildingMex'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oACU:GetPosition())
        LOG(sFunctionRef..': Do we have any unbuilt locations for this LZ, iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..' - is table empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]))..'; Is table of part built mexes empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes])))
    end
    local tPotentialLocations = {}
    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false then
        for iEntry, tLocation in tLZOrWZData[M28Map.subrefMexUnbuiltLocations]  do
            table.insert(tPotentialLocations, tLocation)
        end
    end
    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
        for iEntry, oMex in tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes] do
            if bDebugMessages == true then LOG(sFunctionRef..': Adding part build mex at position '..repru(oMex:GetPosition())..' to list of potential locations') end
            table.insert(tPotentialLocations, oMex:GetPosition())
        end
    end
    if M28Utilities.IsTableEmpty(tPotentialLocations) == false then
        --Check how close the mexes are - e.g. if calling this for higher priority orders we only want to consider mexes near to our build range
        local bHaveMexesWithinMaxDistanceToConsider = false
        local bHaveMexWithinACUBuildRange = false
        local iSearchRange
        local iACUBuildRange = oACU:GetBlueprint().Economy.MaxBuildDistance
        if iOptionalMaxDistanceFromBuildRangeToConsider then
            iSearchRange = iACUBuildRange + iOptionalMaxDistanceFromBuildRangeToConsider
        else
            iSearchRange = 60
        end
        if not(iOptionalMaxDistanceFromBuildRangeToConsider) then bHaveMexesWithinMaxDistanceToConsider = true
        else
            for iEntry, tLocation in tPotentialLocations do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering tLocation='..repru(tLocation)..'; iSearchRange='..iSearchRange..'; Distance to ACU='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLocation)) end
                if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLocation) <= iSearchRange then
                    bHaveMexesWithinMaxDistanceToConsider = true
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': TIme='..GetGameTimeSeconds()..'; bHaveMexesWithinMaxDistanceToConsider='..tostring(bHaveMexesWithinMaxDistanceToConsider)..'; iSearchRange='..iSearchRange..'; iOptionalMaxDistanceFromBuildRangeToConsider='..(iOptionalMaxDistanceFromBuildRangeToConsider or 'nil')) end
        if bHaveMexesWithinMaxDistanceToConsider then
            for iEntry, tLocation in tPotentialLocations do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering location '..repru(tLocation)..'; Dist to ACU='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLocation)..'; iACUBuildRange='..iACUBuildRange) end
                if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLocation) <= iACUBuildRange then
                    bHaveMexWithinACUBuildRange = true
                    break
                end
            end
            if bHaveMexWithinACUBuildRange then iSearchRange = iACUBuildRange end

            local bHaveEngineersAssignedAlready = false
            local tEngisInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits])

            if M28Utilities.IsTableEmpty(tEngisInLZ) == false then
                for iEngi, oEngi in tEngisInLZ do
                    if oEngi[M28Engineer.refiAssignedAction] == M28Engineer.refActionBuildMex or oEngi[M28Engineer.refiAssignedAction] == M28Engineer.refActionCompletePartBuiltMex then
                        bHaveEngineersAssignedAlready = true
                        break
                    end
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': bHaveMexWithinACUBuildRange='..tostring(bHaveMexWithinACUBuildRange)..'; bHaveEngineersAssignedAlready='..tostring(bHaveEngineersAssignedAlready)) end
            if not(bHaveEngineersAssignedAlready) or bHaveMexWithinACUBuildRange then
                ACUActionBuildMex(oACU:GetAIBrain(), oACU, iSearchRange)
                local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
                if bDebugMessages == true then LOG(sFunctionRef..': Have tried telling ACU to build mex, tLastOrder='..reprs(tLastOrder)) end
                if tLastOrder and (tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueRepair) then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, did not give build mex order') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function ConsiderNearbyReclaim(iPlateau, iLandZone, tLZData, tLZTeamData, oACU, bOnlyConsiderIfInBuildRange)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderNearbyReclaim'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTotalReclaimWanted
    local iIndividualReclaimThreshold
    if bOnlyConsiderIfInBuildRange then
        if oACU[refiUpgradeCount] > 0 and not(oACU:HasEnhancement('AdvancedEngineering')) then
            if (tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) or not(M28Conditions.TeamHasLowMass(oACU:GetAIBrain().M28Team)) then
                iTotalReclaimWanted = 200
                iIndividualReclaimThreshold = 24
            else
                iTotalReclaimWanted = 80
                iIndividualReclaimThreshold = 15
            end
            if oACU[refiUpgradeCount] >= 2 and (oACU[refiUpgradeCount] >= 3 or not(EntityCategoryContains(categories.AEON, oACU.UnitId))) then
                iTotalReclaimWanted = iTotalReclaimWanted * 1.5
            end
        else
            if M28Conditions.TeamHasLowMass(oACU:GetAIBrain().M28Team) then
                iTotalReclaimWanted = 25
                iIndividualReclaimThreshold = 10
            else
                iTotalReclaimWanted = 40
                iIndividualReclaimThreshold = 10
            end
        end
    else
        if M28Conditions.TeamHasLowMass(oACU:GetAIBrain().M28Team) then
            iTotalReclaimWanted = 75
            iIndividualReclaimThreshold = 20
        else
            iTotalReclaimWanted = 125
            iIndividualReclaimThreshold = 25
        end
        if tLZTeamData[M28Map.subrefLZbCoreBase] and (GetGameTimeSeconds() <= 300 and M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.subrefiTeamGrossMass]) <= 5 then iTotalReclaimWanted = iTotalReclaimWanted * 2 end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': LZ reclaim mass='..tLZData[M28Map.subrefTotalMassReclaim]..'; Team mass % stored='..M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.subrefiTeamLowestMassPercentStored]..'; iTotalReclaimWanted='..iTotalReclaimWanted..'; iIndividualReclaimThreshold='..iIndividualReclaimThreshold..'; bOnlyConsiderIfInBuildRange='..tostring(bOnlyConsiderIfInBuildRange or false)) end
    if tLZData[M28Map.subrefTotalMassReclaim] >= iTotalReclaimWanted and M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.subrefiTeamLowestMassPercentStored] <= 0.6 then
        --If any reclaim of iIndividualReclaimThreshold+ value then get ACU to reclaim
        M28Engineer.GetEngineerToReclaimNearbyArea(oACU, 1, tLZTeamData, iPlateau, iLandZone, false, (bOnlyConsiderIfInBuildRange or false), iIndividualReclaimThreshold)
        if bDebugMessages == true then LOG(sFunctionRef..': ACU last order after checking for reclaim in area='..reprs(oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]])) end
        local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
        if tLastOrder and tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueReclaim then
            if bDebugMessages == true then LOG(sFunctionRef..': ACU has a reclaim order so will stop') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function MoveToOtherLandZone(iPlateau, tLZData, iLandZone, oACU)
    --COnsiders the land zone we want to support with the ACU - get the LZ within 175 travel distance that has the greatest value, wants DF support, and has less than 800 enemy threat in it
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MoveToOtherLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iLZToMoveTo
    local iTeam = oACU:GetAIBrain().M28Team
    local iAdjLZ
    if bDebugMessages == true then LOG(sFunctionRef..': Will consider moving to another LZ for ACU '..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' owned by '..oACU:GetAIBrain().Nickname..'; Is table of pathing to other LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]))) end
    local iHighValueDistanceThreshold = 175
    local iLowerPriorityDistanceThreshold = 300
    local iLastPathedZoneTravelDist
    local iRecentLandZoneRef
    local iSecondsToIgnoreZonesRecentlyRunFrom = 30
    if bDebugMessages == true then LOG(sFunctionRef..': Time ACU last had order to move to zone='..(oACU[refiTimeLastToldToMoveToZone] or 'nil')..'; oACU[refiLastPlateauAndZoneToMoveTo]='..repru(oACU[refiLastPlateauAndZoneToMoveTo])) end
    if GetGameTimeSeconds() - (oACU[refiTimeLastToldToMoveToZone] or -100) <= 10 then
        iRecentLandZoneRef = oACU[refiLastPlateauAndZoneToMoveTo][2]
        iLastPathedZoneTravelDist = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iRecentLandZoneRef)

        iHighValueDistanceThreshold = math.max(iHighValueDistanceThreshold, (iLastPathedZoneTravelDist or 190) + 1)
        iLowerPriorityDistanceThreshold = math.max(iLowerPriorityDistanceThreshold, (iLastPathedZoneTravelDist or 315) + 1)
        if bDebugMessages == true then LOG(sFunctionRef..': Recently tried to travel to land zone '..(iRecentLandZoneRef or 'nil')..'; iHighValueDistanceThreshold='..iHighValueDistanceThreshold..'; iLowerPriorityDistanceThreshold='..iLowerPriorityDistanceThreshold..'; iLastPathedZoneTravelDist='..(iLastPathedZoneTravelDist or 'nil')) end
    end
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
        local iHighestValueAmount = 0
        local iCurValue
        for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
            iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; Travel dist='..tPathingDetails[M28Map.subrefLZTravelDist]..'; Does it want DF support='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport])) end
            if tPathingDetails[M28Map.subrefLZTravelDist] < iHighValueDistanceThreshold then
                if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport] then
                    iCurValue = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTValue]
                    if iAdjLZ == iRecentLandZoneRef then iCurValue = iCurValue * 1.05 + 25 end
                    if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTValue] > iHighestValueAmount then
                        --Have we run from this zone recently?
                        if not(oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iAdjLZ]) or GetGameTimeSeconds() - oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iAdjLZ] > iSecondsToIgnoreZonesRecentlyRunFrom then
                            if not(oACU[refiLastPlateauAndZoneToAttackUnitIn][2] == iAdjLZ) or not(oACU[refiLastPlateauAndZoneToAttackUnitIn][1] == iPlateau) or GetGameTimeSeconds() - (oACU[refiTimeLastToldToAttackUnitInOtherZone] or -100) > 30 then
                                iHighestValueAmount = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTValue]
                                iLZToMoveTo = iAdjLZ
                            end
                        end
                    end
                end
            else
                break
            end
        end
        if not(iLZToMoveTo) then
            --Are there any LZs nearby with unclaimed mexes or enemy ground units?
            local iNearestPotentialExpansionPoint
            local iPlannedTargetDist
            for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                if bDebugMessages == true then LOG(sFunctionRef..': Considering any LZs that have enemies, tPathingDetails[M28Map.subrefLZTravelDist]='..tPathingDetails[M28Map.subrefLZTravelDist]..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]))..'; Is table of unbuilt locations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMexUnbuiltLocations]))..'; time last ran from iAdjZ='..(oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iAdjLZ] or 'nil')..'; oACU[refiLastPlateauAndZoneToAttackUnitIn]='..repru(oACU[refiLastPlateauAndZoneToAttackUnitIn])..'; oACU[refiTimeLastToldToAttackUnitInOtherZone]='..(oACU[refiTimeLastToldToAttackUnitInOtherZone] or 'nil')) end
                if tPathingDetails[M28Map.subrefLZTravelDist] < iLowerPriorityDistanceThreshold then
                    if not(oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iAdjLZ]) or GetGameTimeSeconds() - oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iAdjLZ] > iSecondsToIgnoreZonesRecentlyRunFrom then
                        if not(oACU[refiLastPlateauAndZoneToAttackUnitIn][2] == iAdjLZ) or not(oACU[refiLastPlateauAndZoneToAttackUnitIn][1] == iPlateau) or GetGameTimeSeconds() - (oACU[refiTimeLastToldToAttackUnitInOtherZone] or -100) > 30 then
                            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false or M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMexUnbuiltLocations]) == false then
                                iLZToMoveTo = iAdjLZ
                                iPlannedTargetDist = tPathingDetails[M28Map.subrefLZTravelDist]
                            elseif not(iNearestPotentialExpansionPoint) and (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefTotalMassReclaim] >= 1000 or (M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMexUnbuiltLocations]) == false and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZMexCount] >= 3)) then
                                iNearestPotentialExpansionPoint = iAdjLZ
                            end
                            if tPathingDetails[M28Map.subrefLZTravelDist] > iHighValueDistanceThreshold and iNearestPotentialExpansionPoint then
                                iLZToMoveTo = iNearestPotentialExpansionPoint
                                iPlannedTargetDist = tPathingDetails[M28Map.subrefLZTravelDist]
                                break
                            end
                        end
                    end
                else
                    --Nearest place of interest is so far away we might as well keep ACU at base
                    break
                end
            end
            if iLZToMoveTo and iRecentLandZoneRef and not(iRecentLandZoneRef == iLZToMoveTo) then
                --dont change our target if our current target is suitable still - this is to avoid cases where the land zone we move to has another land zone slightly closer to its midpoint but in the opposite direction, leading to the ACU stuck in an infinite loop going back and forth between two conflicting land zones whenever its current LZ changes
                local tPrevLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iRecentLandZoneRef]
                local tPrevLZTeamData = tPrevLZData[M28Map.subrefLZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': iLZToMoveTo before adj='..iLZToMoveTo..'; iRecentLandZoneRef='..iRecentLandZoneRef..'; iPlannedTargetDist='..iPlannedTargetDist..'; iLastPathedZoneTravelDist='..iLastPathedZoneTravelDist..'; tPrevLZTeamData[M28Map.subrefTEnemyUnits]='..tostring(M28Utilities.IsTableEmpty(tPrevLZTeamData[M28Map.subrefTEnemyUnits]))..'; Mass reclaim='..(tPrevLZData[M28Map.subrefTotalMassReclaim] or 0)..'; Is table of unbuilt mexes empty='..tostring(M28Utilities.IsTableEmpty(tPrevLZData[M28Map.subrefMexUnbuiltLocations]))) end
                if iPlannedTargetDist + 50 >= iLastPathedZoneTravelDist then
                    if M28Utilities.IsTableEmpty(tPrevLZTeamData[M28Map.subrefTEnemyUnits]) == false or tPrevLZData[M28Map.subrefTotalMassReclaim] >= 1000 or M28Utilities.IsTableEmpty(tPrevLZData[M28Map.subrefMexUnbuiltLocations]) == false then
                        iLZToMoveTo = iRecentLandZoneRef
                        if bDebugMessages == true then LOG(sFunctionRef..': Will retain previous expansion target as it still seems okish') end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering whether to move to a land zone on the same island, iLZToMoveTo='..(iLZToMoveTo or 'nil')..'; Does enemy have sub='..tostring(M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refbEnemyHasSub] or false)) end

    if not(iLZToMoveTo) and not(oACU:GetAIBrain()[M28Map.refbCanPathToEnemyBaseWithLand]) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false
            and not(M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refbEnemyHasSub]) then
        local bIslandHasUnclaimedMexesOrEnemies
        local iSearchRange = 300
        if GetGameTimeSeconds() <= 600 and math.max(M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech], M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech], M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech]) <= 1 then
            iSearchRange = 400
        end

        for iEntry, tSubtable in tLZData[M28Map.subrefLZPathingToOtherIslands] do
            if tSubtable[M28Map.subrefIslandTravelDist] <= iSearchRange then
                if oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][tSubtable[M28Map.subrefIslandClosestLZRef]] and GetGameTimeSeconds() - oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][tSubtable[M28Map.subrefIslandClosestLZRef]] > iSecondsToIgnoreZonesRecentlyRunFrom then
                    --Are there any unclaimed mexes on the LZ?
                    bIslandHasUnclaimedMexesOrEnemies = false
                    local tIslandLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefIslandClosestLZRef]]
                    if M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefMexUnbuiltLocations]) == false or M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                        bIslandHasUnclaimedMexesOrEnemies = true
                    else
                        if M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                            for iPathingRef, tPathingDetails in tIslandLZData[M28Map.subrefLZPathingToOtherLandZones] do
                                iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering any LZs on target island that have unclaimed mexes or enemies, Is table of unbuilt locations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMexUnbuiltLocations]))..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]))) end
                                if tPathingDetails[M28Map.subrefLZTravelDist] < (iSearchRange + 150) then
                                    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false or M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMexUnbuiltLocations]) == false then
                                        bIslandHasUnclaimedMexesOrEnemies = true
                                        break
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering for land zone '..tSubtable[M28Map.subrefIslandClosestLZRef]..'; bIslandHasUnclaimedMexesOrEnemies='..tostring(bIslandHasUnclaimedMexesOrEnemies)) end
                    if bIslandHasUnclaimedMexesOrEnemies then
                        iLZToMoveTo = tSubtable[M28Map.subrefIslandClosestLZRef]
                    end
                end
            end
        end
    end
    if iLZToMoveTo then
        M28Orders.IssueTrackedMove(oACU, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZToMoveTo][M28Map.subrefMidpoint], 6, false, 'ACMLZ'..iLZToMoveTo, false)
        oACU[refiTimeLastToldToMoveToZone] = GetGameTimeSeconds()
        oACU[refiLastPlateauAndZoneToMoveTo] = {iPlateau, iLZToMoveTo}
        if bDebugMessages == true then LOG(sFunctionRef..': Telling ACU to move to zone '..iLZToMoveTo..' at time='..GetGameTimeSeconds()) end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if iLZToMoveTo then return true else return false end
end

function UpdateACULandOrWaterZoneAssignment(oACU, iPlateauOrZero, iLandOrWaterZone, tLZOrWZTeamData)
    local sFunctionRef = 'UpdateACULandOrWaterZoneAssignment'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Update ACU tracking
    if oACU[reftiCurAssignedPlateauAndZone] then
        --Is the actual LZ and plateau the same? If not, then need to update tracking
        if oACU[reftiCurAssignedPlateauAndZone][1] == iPlateauOrZero and oACU[reftiCurAssignedPlateauAndZone][iLandOrWaterZone] == iLandOrWaterZone then
            --Do nothing
        else
            local iTeam = oACU:GetAIBrain().M28Team
            if iLandZone > 0 then --No point updating if we dont have a valid land zone
                oACU[reftiLastAssignedPlateauAndZone] = {oACU[reftiCurAssignedPlateauAndZone][1], oACU[reftiCurAssignedPlateauAndZone][2]}
                oACU[reftiCurAssignedPlateauAndZone] = {iPlateauOrZero, iLandOrWaterZone}
                if (oACU[reftiLastAssignedPlateauAndZone][2] or 0) > 0 then
                    local tPrevLZOrWZTeamData
                    if oACU[reftiLastAssignedPlateauAndZone][1] > 0 then
                        tPrevLZOrWZTeamData = M28Map.tAllPlateaus[oACU[reftiLastAssignedPlateauAndZone][1]][M28Map.subrefPlateauLandZones][oACU[reftiLastAssignedPlateauAndZone][2]][M28Map.subrefLZTeamData][iTeam]
                    else
                        tPrevLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[oACU[reftiLastAssignedPlateauAndZone][2]]][M28Map.subrefPondWaterZones][oACU[reftiLastAssignedPlateauAndZone][2]][M28Map.subrefWZTeamData][iTeam]
                    end

                    --Check we are in the table
                    if M28Utilities.IsTableEmpty(tPrevLZOrWZTeamData[M28Map.subrefAlliedACU]) == false then
                        for iRecordedACU, oRecordedACU in tPrevLZOrWZTeamData[M28Map.subrefAlliedACU] do
                            if oRecordedACU == oACU then
                                table.remove(tPrevLZOrWZTeamData[M28Map.subrefAlliedACU], iRecordedACU)
                                break
                            end
                        end
                    end
                end
                local bAlreadyRecorded = false --Redundancy - we shouldnt have scenario where we are already recorded
                if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefAlliedACU]) == false then
                    for iRecordedACU, oRecordedACU in tLZOrWZTeamData[M28Map.subrefAlliedACU] do
                        if oRecordedACU == oACU then
                            bAlreadyRecorded = true
                            break
                        end
                    end
                end
                if not(bAlreadyRecorded) then
                    if not(tLZOrWZTeamData[M28Map.subrefAlliedACU]) then tLZOrWZTeamData[M28Map.subrefAlliedACU] = {} end
                    table.insert(tLZOrWZTeamData[M28Map.subrefAlliedACU], oACU)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderGettingExtraLandFactory(tLZData, tLZTeamData, oACU, iPlateau, iLandZone)
    local sFunctionRef = 'ConsiderGettingExtraLandFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; ACU upgrade count='..oACU[refiUpgradeCount]..'; Is ACU in core base='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])..'; Plateau-LZ='..iPlateau..'-'..(iLandZone or 'nil')..'; Brain mass stored='..oACU:GetAIBrain():GetEconomyStored('MASS')..'; Want more factories for this LZ='..tostring(M28Conditions.WantMoreFactories(oACU:GetAIBrain().M28Team, iPlateau, iLandZone))) end

    if oACU[refiUpgradeCount] == 0 and tLZTeamData[M28Map.subrefLZbCoreBase] and oACU:GetAIBrain():GetEconomyStored('MASS') >= 220 and M28Conditions.WantMoreFactories(oACU:GetAIBrain().M28Team, iPlateau, iLandZone) then
        --We think we want another land factory; however dont do this if we will use up our current mass in 20s or less, or we have 4+ land factories, or we are at T2
        local iTeam = oACU:GetAIBrain().M28Team
        if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) then
            --DO nothing for now
        else
            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] <= 1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= -0.5 then
                local tExistingFactoriesInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                local iExistingFactories = 0
                if tExistingFactoriesInLZ then iExistingFactories = table.getn(tExistingFactoriesInLZ) end
                if bDebugMessages == true then LOG(sFunctionRef..': iExistingFactories='..iExistingFactories..'; If < 4 then will try and build another') end
                if iExistingFactories < 4 then
                    ACUActionBuildFactory(oACU:GetAIBrain(), oACU, tLZData, tLZTeamData)
                    --Check if we have an order as a result of this to build something
                    local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
                    if bDebugMessages == true then LOG(sFunctionRef..': Just told ACU to try and build a factory, last order='..reprs(tLastOrder)) end
                    if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueRepair or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueGuard then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return true
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function GetACUOrder(aiBrain, oACU)
    local sFunctionRef = 'GetACUOrder'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oACU:GetPosition())
    local tLZOrWZData
    local tLZOrWZTeamData
    local iTeam = oACU:GetAIBrain().M28Team
    if iPlateauOrZero == 0 then
        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
    else
        tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
    end


    --local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oACU:GetPosition(), true, oACU)
    --local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    --local tLZTeamData = tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
    UpdateACULandOrWaterZoneAssignment(oACU, iPlateauOrZero, iLandOrWaterZone, tLZOrWZTeamData)

    --Refresh ACU last orders as some functions will check last order to decide if it was given an order
    M28Orders.UpdateRecordedOrders(oACU)


    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, time='..GetGameTimeSeconds()..'; oACU[refbDoingInitialBuildOrder]='..tostring(oACU[refbDoingInitialBuildOrder])..'; ACU unit state='..M28UnitInfo.GetUnitState(oACU)..'; iPlateau='..(iPlateauOrZero or 'nil')..'; iLandZone='..(iLandOrWaterZone or 'nil')..'; Can ACU use overcharge='..tostring(M28Conditions.CanUnitUseOvercharge(oACU:GetAIBrain(), oACU))..'; ACU position='..repru(oACU:GetPosition())..'; ACU Orders (before updates)='..reprs(oACU[M28Orders.reftiLastOrders])..'; Is special micro active='..tostring(oACU[M28UnitInfo.refbSpecialMicroActive] or false)..'; Time to stop micro='..(oACU[M28UnitInfo.refiGameTimeToResetMicroActive] or 'nil')..'; Brian nickname='..aiBrain.Nickname) end

    --Is the ACU busy with something?
    if oACU:IsUnitState('Upgrading') then
        --Do nothing unless in a very dangerous situation
        if bDebugMessages == true then LOG(sFunctionRef..': ACU upgrading so will only cancel if in dangerous situation. is ACU doing initial BO='..tostring(oACU[refbDoingInitialBuildOrder])) end
        if not(oACU[refbDoingInitialBuildOrder]) then
            if bDebugMessages == true then LOG(sFunctionRef..': ACU is upgrading') end
            if DoesACUWantToReturnToCoreBase(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                --Are we in a different LZ to core base, and have enemy threat or are on <60% health with less health than our upgrade progress?
                if not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and not(tLZOrWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) then
                    local iACUHealthPercent = M28UnitInfo.GetUnitHealthPercent(oACU)
                    if iACUHealthPercent < 0.6 and (1 - iACUHealthPercent) + 0.1 > oACU:GetWorkProgress() then
                        --Cancel upgrade
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to cancel ACU upgrade') end
                        M28Orders.IssueTrackedMove(oACU, M28Map.PlayerStartPoints[oACU:GetAIBrain():GetArmyIndex()], 5, false, 'CURun')
                    end
                end

            end
        end
    elseif GiveOverchargeOrderIfRelevant(tLZOrWZData, tLZOrWZTeamData, oACU) then
        --when an overcharge shot is fired it triggers this code to run again so no need to queue things up afterwards
        if bDebugMessages == true then LOG(sFunctionRef..': Have just givne overcharge order') end
    elseif oACU[M28UnitInfo.refbSpecialMicroActive] then
        --Do nothing
        if bDebugMessages == true then LOG(sFunctionRef..': ACU has special micro active, Time remaining='..(oACU[M28UnitInfo.refiGameTimeToResetMicroActive] or 0) - GetGameTimeSeconds()) end
        if GetGameTimeSeconds() > (oACU[M28UnitInfo.refiGameTimeToResetMicroActive] or 0) then
            oACU[M28UnitInfo.refbSpecialMicroActive] = false
        end
        --Are there enemies in the same LZ as the ACU? If so then consider action for these
    else
        local bProceedWithLogic = true
        if oACU[refbDoingInitialBuildOrder] then
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) then
                bProceedWithLogic = false
                GetACUEarlyGameOrders(aiBrain, oACU) --Avoid some scenarios where ACU might get stuck in 'run to core zone' mode
                if bDebugMessages == true then LOG(sFunctionRef..': No enemies in LZ and ACU doing initial order so referred to early game order logic') end
            elseif (iLandOrWaterZone or 0) == 0 then
                bProceedWithLogic = false
                GetACUEarlyGameOrders(aiBrain, oACU) --backup which should ahve ACU move if it doesnt seem to be on a land or water zone
                if bDebugMessages == true then LOG(sFunctionRef..': ACU not in land zone and is doing initial order so referred to early game order logic') end
            end
            if not(oACU[refbDoingInitialBuildOrder]) then bProceedWithLogic = true end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': oACU[refbDoingInitialBuildOrder]='..tostring(oACU[refbDoingInitialBuildOrder] or false)..'; bProceedWithLogic='..tostring(bProceedWithLogic or false)..'; Is table of enemy units for this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]))) end
        if bProceedWithLogic then
            --Special case - rebuilding destroyed base (relevant for teamgame) - if ACU at core base, and has no factories, then build a factory
            --Cant just use factory count in case we have plateaus/islands that have factories on them
            if bDebugMessages == true then LOG(sFunctionRef..': Considerinb brain '..aiBrain.Nickname..' at time '..GetGameTimeSeconds()..'; Current factories='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory)..'; In core LZ='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase])..'; Enemies in this LZ='..tostring(tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])..'; aiBrain[M28Economy.refiOurHighestAirFactoryTech]='..(aiBrain[M28Economy.refiOurHighestAirFactoryTech] or 'nil')) end
            if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and not(tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and ((aiBrain[M28Economy.refiOurHighestAirFactoryTech] or 0) <= 1 or aiBrain[M28Economy.refiOurHighestLandFactoryTech] == 0) then
                if bDebugMessages == true then LOG(sFunctionRef..': Do we have factories of any type in this LZ? Is table empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits]) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits])))..'; aiBrain[M28Economy.refiOurHighestLandFactoryTech]='..aiBrain[M28Economy.refiOurHighestLandFactoryTech]) end
                local bWantAnotherFactory
                if aiBrain[M28Economy.refiOurHighestLandFactoryTech] == 0 then bWantAnotherFactory = true
                elseif M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits]) then bWantAnotherFactory = true
                elseif M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
                    local bHaveHQFactoriesInZone = false
                    --local bHaveHQFactoriesWeOwnInZone = false

                    local tFactoriesInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory - categories.SUPPORTFACTORY, tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits])

                    if M28Utilities.IsTableEmpty(tFactoriesInLZ) == false then
                        for iFactory, oFactory in tFactoriesInLZ do
                            if oFactory:GetFractionComplete() >= 1 then
                                bHaveHQFactoriesInZone = true
                                break
                                --if oFactory:GetAIBrain() == aiBrain then bHaveHQFactoriesWeOwnInZone = true
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': bHaveHQFactoriesInZone='..tostring(bHaveHQFactoriesInZone)) end
                    if not(bHaveHQFactoriesInZone) then bWantAnotherFactory = true end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Do we want another factory='..tostring(bWantAnotherFactory)) end
                if bWantAnotherFactory then
                    if iPlateauOrZero > 0 then
                        ACUActionBuildFactory(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryLandFactory, M28Engineer.refActionBuildLandFactory)
                    else
                        ACUActionBuildFactory(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryNavalFactory, M28Engineer.refActionBuildNavalFactory)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': WIll try and rebuild base by building a factory') end
                    bProceedWithLogic = false
                end
            end

            if bProceedWithLogic then
                if DoesACUWantToReturnToCoreBase(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) and not(oACU:IsUnitState('Building') and tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZData[M28Map.subrefMidpoint]) <= 10) then
                    --Go to core base
                    local tRallyPoint

                    if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
                        local tFixedShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits])
                        if M28Utilities.IsTableEmpty(tFixedShields) == false then
                            local iNearestDist = 10000
                            local iCurDist
                            local oNearestUnit
                            for iUnit, oUnit in tFixedShields do
                                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())
                                    if iCurDist < iNearestDist then
                                        iNearestDist = iCurDist
                                        oNearestUnit = oUnit
                                    end
                                end
                            end

                            if oNearestUnit then tRallyPoint = oNearestUnit:GetPosition() end
                        end
                    end
                    if not(tRallyPoint) then tRallyPoint = M28Map.PlayerStartPoints[oACU:GetAIBrain():GetArmyIndex()] end
                    if not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and not(tLZOrWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) then

                        M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'Runa')
                        if bDebugMessages == true then LOG(sFunctionRef..': Sending ACU to core base') end
                    else
                        --Consider attacking nearby enemies if no enemy experimental
                        local iNearestEnemyExperimental = 1000
                        local iCurDist
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
                            for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())
                                if iCurDist < iNearestEnemyExperimental then iNearestEnemyExperimental = iCurDist end
                            end
                        end
                        if iNearestEnemyExperimental <= 150 or M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.6 then
                            M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'Runb')
                        else
                            if tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] and AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                                --Do nothing
                            else
                                if not(ConsiderNearbyReclaim(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, true)) then
                                    local sUpgradeToGet = GetACUUpgradeWanted(oACU)
                                    if sUpgradeToGet and not(M28Conditions.HaveLowMass(aiBrain)) and not(M28Conditions.HaveLowPower(aiBrain)) then
                                        --Are we safe to get the upgrade here? if not then retreat
                                        if M28Conditions.SafeToUpgradeUnit(oACU) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Safe to get upgrade so will proceed with upgrading ACU') end
                                            M28Orders.IssueTrackedEnhancement(oACU, sUpgradeToGet, false, 'ACUUp')
                                        else
                                            M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'Runc')
                                        end
                                    else
                                        M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'Rund')
                                    end
                                end
                            end
                        end
                    end
                elseif DoesACUWantToRun(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) and not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZData[M28Map.subrefMidpoint]) <= 10) then
                    oACU[refiTimeLastWantedToRun] = GetGameTimeSeconds()
                    --Retreat to nearest rally (unless we arent in a land zone in which case head towards core base)

                    local tRallyPoint
                    if iLandOrWaterZone > 0 and iPlateauOrZero > 0 then
                        --Are we on a different island to our base, and want to move back there?

                        tRallyPoint = M28Land.GetNearestLandRallyPoint(tLZOrWZData, iTeam, iPlateauOrZero, iLandOrWaterZone, 2, true)

                    else tRallyPoint = M28Map.PlayerStartPoints[oACU:GetAIBrain():GetArmyIndex()]
                    end
                    M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'Run')
                    if bDebugMessages == true then LOG(sFunctionRef..': Telling ACU to run') end
                else
                    --Part-built or unbuilt mex in build range of ACU when no enemies in the LZ
                    if bDebugMessages == true then LOG(sFunctionRef..': Will consider building mex if one is almost in build range and no enemy combat threat in this LZ/WZ, threat='..tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]) end
                    if tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 or not(ConsiderBuildingMex(tLZOrWZData, tLZOrWZTeamData, oACU, 2)) then
                        --Priority reclaim - if reclaim that is in ACU build radius and have <30% mass stored even if nearby enemies, if have no upgrade or T2 upgrade
                        if bDebugMessages == true then LOG(sFunctionRef..': About to check for priority reclaim, mass stored%='..aiBrain:GetEconomyStoredRatio('MASS')..'; ACU upgrade count='..oACU[refiUpgradeCount]..'; Does ACU have adanced engineering='..tostring(oACU:HasEnhancement('AdvancedEngineering'))..'; ACU health %='..M28UnitInfo.GetUnitHealthPercent(oACU)) end
                        if aiBrain:GetEconomyStoredRatio('MASS') < 0.3 and (oACU[refiUpgradeCount] == 0 or oACU:HasEnhancement('AdvancedEngineering')) and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.9 and
                                ConsiderNearbyReclaim(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, true) then
                            --ACU wants to get reclaim
                            if bDebugMessages == true then LOG(sFunctionRef..': ACU will get reclaim') end
                        else

                            --Check if our economy is so good that we want to run next cycle
                            if not(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs]) and (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] >= 30 or aiBrain[M28Economy.refiGrossMassBaseIncome] >= 12) then
                                --Consider running if enemy is at T3 or has large air to ground threat, or we have built ltos of T3
                                if M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] >= 3 or M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestEnemyAirTech] >= 3 or M28Team.tTeamData[aiBrain.M28Team][M28Team.refbBuiltLotsOfT3Combat] or M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftTeamEngineersBuildingExperimentals]) == false then
                                    M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs] = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Dangerous for ACU due to general mass income level so will retreat with ACU if not in adjacent LZ from now on. M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]..'; M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestEnemyAirTech]='..M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestEnemyAirTech]..'; M28Team.tTeamData[aiBrain.M28Team][M28Team.refbBuiltLotsOfT3Combat]='..tostring(M28Team.tTeamData[aiBrain.M28Team][M28Team.refbBuiltLotsOfT3Combat])..'; Is table of engis building experimetnals empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftTeamEngineersBuildingExperimentals]))) end
                                end
                            end

                            --If have orders for ACU but no land zone then wait until it is in a land zone again
                            if not(iLandOrWaterZone) or (iPlateauOrZero == 0 and not(tLZOrWZTeamData[M28Map.subrefWZbContainsUnderwaterStart])) then
                                if bDebugMessages == true then LOG(sFunctionRef..': ACU isnt in a land zone, if has no orders will tell it to retreat to start position, oACU[M28Orders.refiOrderCount]='..oACU[M28Orders.refiOrderCount]..'; ACU unit state='..M28UnitInfo.GetUnitState(oACU)..'; reprs of last order='..reprs(oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]])) end
                                if oACU[M28Orders.refiOrderCount] == 0 then
                                    M28Orders.IssueTrackedMove(oACU, M28Map.PlayerStartPoints[oACU:GetAIBrain():GetArmyIndex()], 5, false, 'NLZRun')
                                elseif oACU:IsUnitState('Attacking') and M28UnitInfo.IsUnitUnderwater(oACU) and not(tLZOrWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) then
                                    --Came across rare issue where ACU has attack-move order, that doesnt get refreshed, but ACU gets stuck not moving in the water, its unit state when this happened was attacking, and its last order was refiOrderIssueAggressiveMove; the below is a workaround as in some cases want ACU to advance where this is the case, in others want it to retreat
                                    local iCurWaterZone = M28Map.GetWaterZoneFromPosition(oACU:GetPosition())
                                    if M28UnitInfo.GetUnitHealthPercent(oACU) < 0.95 or not(iCurWaterZone) then
                                        M28Orders.IssueTrackedMove(oACU, M28Map.PlayerStartPoints[oACU:GetAIBrain():GetArmyIndex()], 5, false, 'NLZRn')
                                    else
                                        --Look for nearest land zone and move here
                                        local iPond = M28Map.tiPondByWaterZone[iCurWaterZone]
                                        local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iCurWaterZone]
                                        local tLZMidpointToMoveTo
                                        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
                                            for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                                                local tAltLZ = M28Map.tAllPlateaus[tSubtable[M28Map.subrefWPlatAndLZNumber][1]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefWPlatAndLZNumber][2]]
                                                if tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsSupport] then
                                                    tLZMidpointToMoveTo = tAltLZ[M28Map.subrefMidpoint]
                                                    break
                                                end
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': tLZMidpointToMoveTo after checking if have adjacent land zones that want support='..repru(tLZMidpointToMoveTo)) end
                                        if not(tLZMidpointToMoveTo) then tLZMidpointToMoveTo = M28Map.PlayerStartPoints[oACU:GetAIBrain():GetArmyIndex()] end
                                        M28Orders.IssueTrackedMove(oACU, tLZMidpointToMoveTo, 5, false, 'ACUWtr')

                                    end
                                end
                            else
                                --Are there enemies in this LZ? If so then attack them
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy units for this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]))) end
                                if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) == false and iPlateauOrZero > 0 and AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                                    --(Do nothing further - will ahve given the order)
                                else
                                    if oACU[refbDoingInitialBuildOrder] then
                                        GetACUEarlyGameOrders(aiBrain, oACU)

                                        --Have we finished our initial build order? (even if we stil lahve some early game orders)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Checking if have finished initial build order, Economy stored mass='..aiBrain:GetEconomyStored('MASS')..'; Gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; Gross energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]) end
                                        if not(oACU:IsUnitState('Building')) and aiBrain:GetEconomyStored('MASS') == 0 and aiBrain[M28Economy.refiGrossMassBaseIncome] >= 0.3 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 15 then
                                            bDoingInitialBuildOrder = false
                                        end
                                    else
                                        --If we are reclaiming or building then dont do anything
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef..': Arent doing initial build order and dont want to run, ACU unit state='..M28UnitInfo.GetUnitState(oACU)..'; Brain mass stored%='..aiBrain:GetEconomyStoredRatio('MASS')..'; If are nearby enemies then will list out, is table of nearby enemies empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]))..'; oACU[M28UnitInfo.refiDFRange]='..(oACU[M28UnitInfo.refiDFRange] or 'nil')..'; ACU position='..repru(oACU:GetPosition())..'; ACU team='..oACU:GetAIBrain().M28Team)
                                            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                                                LOG(sFunctionRef..': are we close to nearby units='..tostring(M28Conditions.CloseToEnemyUnit(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftoNearestDFEnemies], 12 , aiBrain.M28Team, true, math.max(25, oACU[M28UnitInfo.refiDFRange] + 12))))
                                                for iUnit, oUnit in tLZOrWZTeamData[M28Map.reftoNearestDFEnemies] do
                                                    LOG(sFunctionRef..': Entry '..iUnit..' is unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' which is '..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition())..' with range '..(oUnit[M28UnitInfo.refiDFRange] or 'nil'))
                                                end
                                            end
                                        end
                                        --Is there an enemy unit nearby that we want to attack?
                                        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) == false and M28Conditions.CloseToEnemyUnit(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftoNearestDFEnemies], 12 , aiBrain.M28Team, true, math.max(25, oACU[M28UnitInfo.refiDFRange] + 12)) and AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Are close to enemy units so will attack rather than considering upgrades or building mexes etc.') end                        else
                                            if bDebugMessages == true then LOG(sFunctionRef..': Checking if ACU unit state not important so we can consider doing other things, ACU state='..M28UnitInfo.GetUnitState(oACU)..'; Mass stored ratio='..aiBrain:GetEconomyStoredRatio('MASS')..'; Is unit state building='..tostring(oACU:IsUnitState('Building'))..'; Is unit state repairing='..tostring(oACU:IsUnitState('Repairing'))..'; Is unit state reclaiming='..tostring(oACU:IsUnitState('Reclaiming'))..'; Is unit state guarding='..tostring(oACU:IsUnitState('Guarding'))) end
                                            if not(oACU:IsUnitState('Building')) and (not(oACU:IsUnitState('Repairing')) or oACU:IsUnitState('Guarding')) and (not(oACU:IsUnitState('Reclaiming')) or aiBrain:GetEconomyStoredRatio('MASS') >= 0.8) and not(oACU:IsUnitState('Capturing')) then
                                                --Do we want to get an upgrade?
                                                local sUpgradeToGet = GetACUUpgradeWanted(oACU)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Do we have an upgrade we want to get? sUpgradeToGet='..(sUpgradeToGet or 'nil')) end
                                                if sUpgradeToGet then
                                                    --Are we safe to get the upgrade here? if not then retreat
                                                    if M28Conditions.SafeToUpgradeUnit(oACU) then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Safe to get upgrade so will proceed with upgrading ACU') end
                                                        M28Orders.IssueTrackedEnhancement(oACU, sUpgradeToGet, false, 'ACUUp')
                                                    else
                                                        --Retreat
                                                        local tRallyPoint = M28Land.GetNearestLandRallyPoint(tLZOrWZData, oACU:GetAIBrain().M28Team, iPlateauOrZero, iLandOrWaterZone, 2)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Not safe to get upgrade so want to retreat until it is. tRallyPoint='..repru(tRallyPoint)..'; ACU position='..repru(oACU:GetPosition())) end
                                                        M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'R4U')
                                                    end
                                                else
                                                    --We dont want an upgrade, and have no enemies in this LZ, but there might be enemies nearby (e.g. in an adjacent land zone); there might also be mexes to build or reclaim to get in this LZ - decide on what we want to do
                                                    --Does the LZ have uncalimed mexes?
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will consider if we want to build a mex if there are any unclaimed') end
                                                    if not(ConsiderBuildingMex(tLZOrWZData, tLZOrWZTeamData, oACU)) then
                                                        --Water zone specific - if underwater and is an underwater start position then do nothing
                                                        if iPlateauOrZero > 0 or not(tLZOrWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) then

                                                            --Do we want another land factory?
                                                            if bDebugMessages == true then LOG(sFunctionRef..': No mexes to build ni this LZ, seeing if we want another land factory') end
                                                            if not(ConsiderGettingExtraLandFactory(tLZOrWZData, tLZOrWZTeamData, oACU, iPlateauOrZero, iLandOrWaterZone)) then

                                                                local bOnlyConsiderInBuildRange = false
                                                                if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and (not(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) or (GetGameTimeSeconds() <= 300 and aiBrain[M28Economy.refiGrossMassBaseIncome] <= 4)) then bOnlyConsiderInBuildRange = true end
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Dont want to build mex, will cehck if want to get reclaim, bOnlyConsiderInBuildRange='..tostring(bOnlyConsiderInBuildRange)) end
                                                                if not(ConsiderNearbyReclaim(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, bOnlyConsiderInBuildRange)) then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Dont want to get reclaim, will see if want to attack adjacent enemies; are there adjacent enemies='..tostring(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]='..tostring(tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ])) end
                                                                    if tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                                                                        --Do nothing - will have given the order
                                                                    else
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Will consider moving to another land zone as nothing to do in this one') end
                                                                        if not(MoveToOtherLandZone(iPlateauOrZero, tLZOrWZData, iLandOrWaterZone, oACU)) then

                                                                            --Backup - assist nearest factory
                                                                            if bDebugMessages == true then LOG(sFunctionRef..': ACU no longer doing iniitial BO; Will give backup assist factory order if not building or guarding, ACU unit state='..M28UnitInfo.GetUnitState(oACU)) end
                                                                            if not(oACU:IsUnitState('Building')) and not(oACU:IsUnitState('Guarding')) then
                                                                                local tAllFactories = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryFactory, false, true)
                                                                                if M28Utilities.IsTableEmpty(tAllFactories) == false then
                                                                                    local oNearestFactory = M28Utilities.GetNearestUnit(tAllFactories, oACU:GetPosition(), true, M28Map.refPathingTypeHover)
                                                                                    if M28UnitInfo.IsUnitValid(oNearestFactory) then
                                                                                        M28Orders.IssueTrackedGuard(oACU, oNearestFactory, false)
                                                                                    end
                                                                                end
                                                                            end
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DoWeStillWantToBeAggressiveWithACU(oACU)
    --Intended for early game mostly on smaller maps to make ACU more aggressive
    local bStillBeAggressive = true
    local aiBrain = oACU:GetAIBrain()
    local iTeam = aiBrain.M28Team
    if M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs] then
        bStillBeAggressive = false
    else
        --If significant time elapsed then remove this flag
        if GetGameTimeSeconds() >= 600 then
            bStillBeAggressive = false
        else
            if M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.3 then bStillBeAggressive = false
            elseif aiBrain[M28Economy.refiOurHighestFactoryTechLevel] >= 2 or aiBrain[M28Economy.refiGrossMassBaseIncome] >= 5 then
                bStillBeAggressive = false
            elseif M28Map.iMapSize > 512 then
                bStillBeAggressive = false
            elseif not(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) then
                bStillBeAggressive = false
            elseif M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU] then
                bStillBeAggressive = false
            elseif M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat) >= 50 then
                bStillBeAggressive = false
            end
        end
    end

    return bStillBeAggressive
end

function ManageACU(aiBrain)
    local sFunctionRef = 'ManageACU'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --First get our ACU
    local oACU
    while not(oACU) do
        local tOurACU = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
        if M28Utilities.IsTableEmpty(tOurACU) == false then
            for _, oUnit in tOurACU do
                oACU = oUnit
                break
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Looking for ACU that we own, is oACU valid='..tostring(M28UnitInfo.IsUnitValid(oACU))) end
        if oACU then
            oACU[refbDoingInitialBuildOrder] = true
            break
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    --Wait until ok for us to give orders
    while (GetGameTimeSeconds() <= 4.5) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    --Campaign specific - check if friendly units should gift to M28AI
    if M28Map.bIsCampaignMap then
        ForkThread(M28Overseer.CheckForAlliedCampaignUnitsToShareAtGameStart, oACU:GetAIBrain())
    end

    --Make sure ACU is recorded
    M28Team.AssignUnitToLandZoneOrPond(aiBrain, oACU, false, false, true)
    oACU[refiUpgradeCount] = 0
    oACU[refbUseACUAggressively] = true
    while M28UnitInfo.IsUnitValid(oACU) do
        if oACU[refbUseACUAggressively] then
            oACU[refbUseACUAggressively] = DoWeStillWantToBeAggressiveWithACU(oACU)
        end

        ForkThread(GetACUOrder, aiBrain, oACU)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
end

