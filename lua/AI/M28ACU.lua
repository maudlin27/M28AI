---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 08:29
---
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')

--ACU specific variables against the ACU
refbTreatingAsACU = 'M28ACUTreatACU' --true if are running ACU logic on this unit - e.g. for campagins where are given SACU but not an ACU
refbDoingInitialBuildOrder = 'M28ACUInitialBO'
reftPreferredUpgrades = 'M28ACUPreferredUpgrades' --table of the enhancement IDs in the order that we want to get them (which is updated to remove any upgrades we already have as and when we get them)
refiUpgradeCount = 'M28ACUUpgradeCount' --Number of upgrades the ACU has
refiTimeLastWantedToRun = 'M28ACUTimeLastWantedToRun' --gametimeseconds that last wanted to run
reftiLastAssignedPlateauAndZone = 'M28ACULastPlateauAndLZ' --Records the last plateau and LZ/WZ that we were assigned to; if in WZ then plateau is 0
reftiCurAssignedPlateauAndZone = 'M28ACUCurPlateauAndLZ' --Records the current plateau and LZ/WZ that we are assigned to, if we are in a valid LZ/WZ; if WZ then plateau is 0
refbStartedUnderwater = 'M28ACUStartUnderwater' --true if ACU started underwater
refiTimeLastToldToMoveToZone = 'M28ACUTimeLastMoveZone' --gametime last told to move to a zone
refiLastPlateauAndZoneToMoveTo = 'M28ACULastZoneToMove' --PlateauOrZero and Land/Water zone ref if given move to zone order
refiTimeLastToldToAttackUnitInOtherZone = 'M28ACUTimeLastAttackUnit'
refiLastPlateauAndZoneToAttackUnitIn = 'M28ACULastZoneToAttack' --PlateauOrZero and Land/Water zone ref if given move to zone order in order to attack a unit
reftiTimeLastRanFromZoneByPlateau = 'M28ACUTimeLastRanByZone' --[x] is plateau or zero, [y] is the zone (currently only have logic for LZs though), returns gametimeseconds that last ran when in that zone
refbUseACUAggressively = true
reftSpecialObjectiveMoveLocation = 'M28ACUObjMoveLoc' --If has a value, ACU will move here
refbACUHasTeleport = 'M28ACUHasTel' --true if ACU has teleport (will assume it also has good gun upgrade) - used to impact on telesnipe logic
refbPlanningToGetTeleport = 'M28ACUPlanningTeleport' --true if are planning on getting teleport upgrade on the ACU

--ACU related variables against the ACU's brain
refoPrimaryACU = 'M28PrimACU' --ACU unit for the brain; recorded against aibrain
refbACUHasBeenGivenABuildOrderRecently = 'M28ACUBuildR' --true if ACU has been given a build order recently

function ACUBuildUnit(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearchForAdjacencyAndUnderConstruction, iMaxAreaToSearchForBuildLocation, iOptionalAdjacencyCategory, iOptionalCategoryBuiltUnitCanBuild)
    local sFunctionRef = 'ACUBuildUnit'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Do we have a nearby unit of the type we want to build under construction?
    local tNearbyUnitsOfCategoryToBuild = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, oACU:GetPosition(), iMaxAreaToSearchForAdjacencyAndUnderConstruction, 'Ally')
    local oNearestPartComplete

    if M28Utilities.IsTableEmpty(tNearbyUnitsOfCategoryToBuild) == false then
        local iClosestUnit = 10000
        local iCurDist
        for _, oUnit in tNearbyUnitsOfCategoryToBuild do
            if oUnit:GetFractionComplete() < 1 and not(oUnit[M28Engineer.refbDontIncludeAsPartCompleteBuildingForConstruction]) then --Dont want to assist shields for shield defence
                iCurDist = M28Utilities.GetTravelDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition(), M28Map.refPathingTypeAmphibious)
                if iCurDist < iClosestUnit then
                    oNearestPartComplete = oUnit
                    iClosestUnit = iCurDist
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; brain='..aiBrain.Nickname..'; ACU='..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..'; Is tNearbyUnitsOfCategoryToBuild empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnitsOfCategoryToBuild))..'; Is oNearestPartComplete valid='..tostring(M28UnitInfo.IsUnitValid(oNearestPartComplete))..'; ACU position='..repru(oACU:GetPosition())) end
    if M28UnitInfo.IsUnitValid(oNearestPartComplete) then
        if bDebugMessages == true then LOG(sFunctionRef..': Will assist part complete building='..oNearestPartComplete.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestPartComplete)) end
        local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
        --if not(tLastOrder[M28Orders.subrefoOrderUnitTarget] == oNearestPartComplete) then --Dont need this step, as the order already takes this into account, and reissues once we get within build range
        M28Orders.IssueTrackedRepair(oACU, oNearestPartComplete, false, 'ACUComplB', false)
        --M28Orders.IssueTrackedGuard(oACU, oNearestPartComplete, false)
        --end

    else
        --No nearby under construction factory, so build one unless we allready have a queued orer to build one
        oACU[refbACUHasBeenGivenABuildOrderRecently] = true
        local bAlreadyHaveOrder = false
        M28Orders.UpdateRecordedOrders(oACU)
        local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
        --NOTE: Dont do location check, as we will exclude queued locations; i.e. first time this runs ACU queues land fac; second time it runs if it looks for a location to build it treats the first location as unavailable (due to the queued order) so tries somewhere else
        if tLastOrder[M28Orders.subrefsOrderBlueprint] and EntityCategoryContains(iCategoryToBuild, tLastOrder[M28Orders.subrefsOrderBlueprint]) then
            bAlreadyHaveOrder = true
        end
        if bDebugMessages == true then LOG(sFunctionRef..': tLastOrder='..reprs(tLastOrder)..'; bAlreadyHaveOrder='..tostring(bAlreadyHaveOrder)) end
        if not(bAlreadyHaveOrder) then
            local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oACU:GetPosition(), true, oACU:GetAIBrain().M28Team)
                                                                                --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerActionForDebug, iCategoryToBuild, iMaxAreaToSearch,                                   iCatToBuildBy,              tAlternativePositionToLookFrom, bLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData)
            local sBlueprint, tBuildLocation =                       M28Engineer.GetBlueprintAndLocationToBuild(aiBrain, oACU,        nil,                            iCategoryToBuild, iMaxAreaToSearchForAdjacencyAndUnderConstruction, iOptionalAdjacencyCategory, nil,                            false,                      nil,         iOptionalCategoryBuiltUnitCanBuild,    nil,                        tLZData, tLZTeamData)
            if not(tBuildLocation) then sBlueprint, tBuildLocation = M28Engineer.GetBlueprintAndLocationToBuild(aiBrain, oACU,          nil,                        iCategoryToBuild,    iMaxAreaToSearchForBuildLocation,                  nil,                         nil,                           false,                      nil,         iOptionalCategoryBuiltUnitCanBuild, nil,                           tLZData, tLZTeamData) end
            if bDebugMessages == true then
                local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oACU:GetPosition())
                LOG(sFunctionRef..': Blueprint to build='..(sBlueprint or 'nil')..'; tBuildLocation='..repru(tBuildLocation)..'; ACU plateau and land zone based on cur position='..iPlateauOrZero..'; Land or water zone='..(iLandOrWaterZone or 'nil')..'; iMaxAreaToSearchForBuildLocation='..(iMaxAreaToSearchForBuildLocation or 'nil')..'; was iOptionalAdjacencyCategory nil='..tostring(iOptionalAdjacencyCategory == nil)..'; tLZData midpoint='..repru(tLZData[M28Map.subrefMidpoint])..'; Is team data empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData)))
                if sBlueprint and tBuildLocation then
                    LOG(sFunctionRef..': Can build structure at target='..tostring(aiBrain:CanBuildStructureAt(sBlueprint, tBuildLocation)))
                end
            end
            if sBlueprint and tBuildLocation then
                --If our last order was to build this unit (ignoring location)
                --Move to the target and then build on it
                local tMoveTarget = M28Engineer.GetLocationToMoveForConstruction(oACU, tBuildLocation, sBlueprint)
                if tMoveTarget then
                    --IssueTrackedMoveAndBuild(oUnit, tBuildLocation, sOrderBlueprint, tMoveTarget, iDistanceToReorderMoveTarget, bAddToExistingQueue)
                    M28Orders.IssueTrackedMoveAndBuild(oACU, tBuildLocation, sBlueprint, tMoveTarget, 2, false)
                else
                    M28Orders.IssueTrackedBuild(oACU, tBuildLocation, sBlueprint, false)
                end
            else
                --M28Orders.UpdateRecordedOrders(oACU) --now are doing this earlier on
            end
        else
            --Consider reissuing the same order if we are close
            if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to reissue order to build, last order position='..repru(tLastOrder[M28Orders.subreftOrderPosition])..'; Dist to ACU position='..M28Utilities.GetDistanceBetweenPositions(tLastOrder[M28Orders.subreftOrderPosition], oACU:GetPosition())..'; BUilding radius+ACU build distance - 0.1='..(oACU:GetBlueprint().Economy.MaxBuildDistance + M28UnitInfo.GetBuildingSize(tLastOrder[M28Orders.subrefsOrderBlueprint]) * 0.5 - 0.1)) end
            if M28Utilities.IsTableEmpty(tLastOrder[M28Orders.subreftOrderPosition]) == false and M28Utilities.GetDistanceBetweenPositions(tLastOrder[M28Orders.subreftOrderPosition], oACU:GetPosition()) <= oACU:GetBlueprint().Economy.MaxBuildDistance + M28UnitInfo.GetBuildingSize(tLastOrder[M28Orders.subrefsOrderBlueprint]) * 0.5 - 0.1 then
                if bDebugMessages == true then LOG(sFunctionRef..': Will attempt to reissue build order') end
                M28Orders.IssueTrackedClearCommands(oACU)
                M28Orders.IssueTrackedBuild(oACU, tLastOrder[M28Orders.subreftOrderPosition], tLastOrder[M28Orders.subrefsOrderBlueprint], false)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLandOrWaterZone, tLZData, tLZTeamData, iFactoryCategoryOverride, iEngineerActionOverride)
    local sFunctionRef = 'ACUActionBuildFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iMaxAreaToSearch = 35
    local iCategoryToBuild
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for aiBrain '..aiBrain.Nickname..' at time '..GetGameTimeSeconds()) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) and GetGameTimeSeconds() >= 60 and iPlateauOrZero > 0 and tLZTeamData[M28Map.subrefLZbCoreBase] then M28Utilities.ErrorHandler('Empty allied units table, iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Is LZTeamData empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData))) end
    if iFactoryCategoryOverride then iCategoryToBuild = iFactoryCategoryOverride
    else
        local iTeam = oACU:GetAIBrain().M28Team
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if we want to build an air factory, do we want air instead of land='..tostring(M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData))..'; Is tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits] empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))..'; tLZTeamData[CoreBase]='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])) end
        if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) then iCategoryToBuild = M28UnitInfo.refCategoryAirFactory
        else iCategoryToBuild = M28UnitInfo.refCategoryLandFactory
        end
    end
    --= (iFactoryCategoryOverride or M28UnitInfo.refCategoryLandFactory)
    if iCategoryToBuild == M28UnitInfo.refCategoryLandFactory then
        local iCurLandFacs = aiBrain:GetCurrentUnits(iCategoryToBuild)
        if iCurLandFacs >= 2 then
            iMaxAreaToSearch = 20
        elseif iCurLandFacs == 0 then
            iMaxAreaToSearch = oACU:GetBlueprint().Economy.MaxBuildDistance + M28UnitInfo.GetBuildingSize('ueb0101') * 0.5 + 1 --are ok with moving a very small distance to start building if it means we get adjacency
        end
    end
    local iSearchSegments = 20
    if iPlateauOrZero == 0 then
        iSearchSegments = 50
        if M28Map.bIsCampaignMap then
            iSearchSegments = iSearchSegments * 5
            if iEngineerActionOverride == M28Engineer.refActionBuildNavalFactory and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalFactory) == 0 then
                iSearchSegments = iSearchSegments * 2
            end
        end --Issue on Aeon mission 1 where ACU doesnt build because it hasnt searched through enough of the segments
    end
    --Start of game - first factory - massively increase search segments
    if M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryFactory) == 0 and GetGameTimeSeconds() <= 10 then
        local iSegmentRef
        if iPlateauOrZero == 0 then
            iSegmentRef = M28Map.subrefWZSegments
        else
            iSegmentRef = M28Map.subrefLZSegments
        end
        local iTotalSegments = table.getn(tLZData[iSegmentRef])
        local iSegmentStart = (tLZData[M28Map.subrefiLastSegmentEntryConsideredForBuilding] or 0)
        if iSegmentStart < iTotalSegments * 0.75 then
            iSearchSegments = math.max(iSearchSegments, iTotalSegments * 0.75 - iSegmentStart)
        end
    end
    if M28Overseer.refiRoughTotalUnitsInGame <= 500 then iSearchSegments = iSearchSegments * 2 end

    if bDebugMessages == true then LOG(sFunctionRef..': Will try and search for '..iSearchSegments..' in iLandOrWaterZone='..iLandOrWaterZone..' so ACU is picking from best location for factory') end
    M28Engineer.SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iSearchSegments)
    ACUBuildUnit(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearch, iMaxAreaToSearch * 2, M28Engineer.tiActionAdjacentCategory[(iEngineerActionOverride or M28Engineer.refActionBuildLandFactory)], M28UnitInfo.refCategoryEngineer)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData, oOptionalUnderConstructionHydro)
    --If have hydro under construction then assist the hydro if it's within build range; if not under construciton or out of build range then move towards it
    local sFunctionRef = 'ACUActionAssistHydro'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Redundancy - make sure we have hydros in this LZ:
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oACU:GetPosition(), true, oACU)
    if bDebugMessages == true then LOG(sFunctionRef..': Do we have hydro loations in iPlateau '..iPlateau..'; iLZ='..iLandZone..': Table empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]))) end
    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]) == false or oOptionalUnderConstructionHydro then
        local tNearestHydro
        local iNearestHydro = 10000
        local iCurDist
        local iBuildRange = oACU:GetBlueprint().Economy.MaxBuildDistance
        local iMinRangeToAssist = iBuildRange + 10
        local oNearestUnderConstructionHydro
        local iCompletedHydroCount = 0
        if not(oOptionalUnderConstructionHydro) or oOptionalUnderConstructionHydro:GetFractionComplete() == 1 then
            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroUnbuiltLocations]) == false then
                for iHydro, tHydro in tLZOrWZData[M28Map.subrefHydroLocations] do
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tHydro, oACU:GetPosition())
                    if iCurDist < iNearestHydro then iNearestHydro = iCurDist tNearestHydro = tHydro end
                end
            end
            local tNearbyHydro = EntityCategoryFilterDown(M28UnitInfo.refCategoryHydro, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tNearbyHydro) == false then
                for iHydro, oHydro in tNearbyHydro do
                    if M28UnitInfo.IsUnitValid(oHydro) then
                        if oHydro:GetFractionComplete() < 1 then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oHydro:GetPosition(), oACU:GetPosition())
                            if iCurDist < iNearestHydro then
                                iNearestHydro = iCurDist
                                tNearestHydro = oHydro:GetPosition()
                                oNearestUnderConstructionHydro = oHydro
                            end
                        else
                            iCompletedHydroCount = iCompletedHydroCount + 1
                        end
                    end
                end
            end
        else
            tNearestHydro = oOptionalUnderConstructionHydro:GetPosition()
            iNearestHydro = M28Utilities.GetDistanceBetweenPositions(oOptionalUnderConstructionHydro:GetPosition(), oACU:GetPosition())

        end
        --If we are in range of a hydro then assist it (or wait until construction is started)
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if have hydro near enough to consider mvoing to and assisting, iNearestHydro='..iNearestHydro..'; iMinRangeToAssist='..iMinRangeToAssist) end
        if iNearestHydro < iMinRangeToAssist then

            local oUnderConstructionHydro = oOptionalUnderConstructionHydro or oNearestUnderConstructionHydro
            if not(oUnderConstructionHydro) then
                local tUnderConstructionHydro = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryHydro, tNearestHydro, 5, 'Ally')
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of hydros around nearest hydro point empty='..tostring(M28Utilities.IsTableEmpty(tUnderConstructionHydro))) end
                if M28Utilities.IsTableEmpty(tUnderConstructionHydro) == false then
                    for iHydro, oHydro in tUnderConstructionHydro do
                        if oHydro:GetFractionComplete() < 1 then
                            oUnderConstructionHydro = oHydro
                            break
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': oUnderConstructionHydro='..(oUnderConstructionHydro.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnderConstructionHydro) or 'nil')) end
            if oUnderConstructionHydro and oUnderConstructionHydro:GetFractionComplete() < 1 then
                M28Orders.IssueTrackedRepair(oACU, oUnderConstructionHydro, false, 'RH')
            elseif not(oUnderConstructionHydro) then
                oACU['M28BOHydroWait'] = ( oACU['M28BOHydroWait'] or 0) + 1
                if  oACU['M28BOHydroWait'] >= 20 then
                    ACUActionBuildPower(aiBrain, oACU)
                else
                    --Stay where we are as maybe we are waiting for an engi to start construction
                    M28Orders.IssueTrackedMove(oACU, oACU:GetPosition(), 3, false, 'W4C')
                end
            end
        elseif tNearestHydro and (iCompletedHydroCount == 0 or table.getn(tLZOrWZData[M28Map.subrefHydroLocations]) > iCompletedHydroCount) then
            --Move to be near hydro
            local tLocationNearHydro = M28Engineer.GetLocationToMoveForConstruction(oACU, tNearestHydro, 'ueb1102', -0.5, false)
            if tLocationNearHydro then
                M28Orders.IssueTrackedMove(oACU, tLocationNearHydro, 0.5, false, 'M2NH')
            else
                M28Orders.IssueTrackedMove(oACU, tNearestHydro, 0.5, false, 'M2H')
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': No nearby hydro for ACU - e.g. might hapepn if called this as a redundancy action') end
        end
    else
        M28Utilities.ErrorHandler('Trying to buidl hydro when none nearby')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ACUActionBuildPower(aiBrain, oACU)
    local sFunctionRef = 'ACUActionBuildPower'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCategoryToBuild = M28UnitInfo.refCategoryPower
    local iMaxAreaToSearch = 16
    local iOptionalAdjacencyCategory
    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) > 0 then iOptionalAdjacencyCategory = M28UnitInfo.refCategoryAirFactory
    elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= 11 then iOptionalAdjacencyCategory = M28UnitInfo.refCategoryLandFactory
    end
    if bDebugMessages == true then LOG(sFunctionRef..': About to tell ACU to build power; is optional adjacency category nil='..tostring(iOptionalAdjacencyCategory == nil)) end
    ACUBuildUnit(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearch, iMaxAreaToSearch * 3, iOptionalAdjacencyCategory, nil)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ACUActionBuildMex(aiBrain, oACU, iAreaToSearchOverride)
    local sFunctionRef = 'ACUActionBuildMex'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iMaxAreaToSearch = iAreaToSearchOverride
    --Increase search range if still doing initial build order, as this suggests we have mexes in our initial land zone that we havent built on yet
    if not(iMaxAreaToSearch) then
        if oACU[refbDoingInitialBuildOrder] then
            if aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 12 then iMaxAreaToSearch = 50
            elseif aiBrain[M28Economy.refiGrossMassBaseIncome] < 6 then iMaxAreaToSearch = 30
            end
        else
            iMaxAreaToSearch = 20
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': About to tell ACU to build a mex, iMaxAreaToSearch='..iMaxAreaToSearch..'; iAreaToSearchOverride='..(iAreaToSearchOverride or 'nil')) end
    ACUBuildUnit(aiBrain, oACU, M28UnitInfo.refCategoryMex, iMaxAreaToSearch, iMaxAreaToSearch * 2, nil, nil)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MoveACUToNearbyWaterForFactory(aiBrain, oACU, tLZOrWZData)
    local sFunctionRef = 'MoveACUToNearbyWaterForFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTeam = aiBrain.M28Team

    --Get the first WZ that has a naval fac build location
    local iClosestWZRefWithBuild
    local iClosestWZRefWithoutBuild
    local iClosestWZWithBuildLocation = 100000
    local iClosestWZWithoutBuildLocation = 100000
    for iEntry, tSubtable in tLZOrWZData[M28Map.subrefAdjacentWaterZones] do
        local iAdjWZ = tSubtable[M28Map.subrefAWZRef]
        local tAdjWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ]
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to move to adjacent water zone '..iAdjWZ..'; Midpoint='..repru(tAdjWZData[M28Map.subrefMidpoint])..'; Straight line dist to ACU='..M28Utilities.GetDistanceBetweenPositions(tAdjWZData[M28Map.subrefMidpoint], oACU:GetPosition())..'; AWZ dist='..tSubtable[M28Map.subrefAWZDistance]..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAdjWZData[M28Map.subrefMidpoint]))) end
        if M28Conditions.IsLocationInPlayableArea(tAdjWZData[M28Map.subrefMidpoint]) then
            local tAdjWZTeamData = tAdjWZData[M28Map.subrefWZTeamData][iTeam]
            if bDebugMessages == true then LOG(sFunctionRef..': Does WZ contain naval build location='..tostring(tAdjWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation])) end
            if tAdjWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation] then
                if tSubtable[M28Map.subrefAWZDistance] < iClosestWZWithBuildLocation then
                    iClosestWZWithBuildLocation = tSubtable[M28Map.subrefAWZDistance]
                    iClosestWZRefWithBuild = iAdjWZ
                end
            else
                if tSubtable[M28Map.subrefAWZDistance] < iClosestWZWithoutBuildLocation then
                    iClosestWZWithoutBuildLocation = tSubtable[M28Map.subrefAWZDistance]
                    iClosestWZRefWithoutBuild = iAdjWZ
                end
            end
        end
    end
    local iOtherWZWanted = (iClosestWZRefWithBuild or iClosestWZRefWithoutBuild)
    if not(iOtherWZWanted) and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
        --Search all water zones
        for iEntry, tSubtable in tLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
            if tSubtable[M28Map.subrefbIsWaterZone] then
                local iAdjPond = tSubtable[M28Map.subrefiPlateauOrPond]
                local iOtherWZ = tSubtable[M28Map.subrefiLandOrWaterZoneRef]
                local tOtherWZData = M28Map.tPondDetails[iAdjPond][M28Map.subrefPondWaterZones][iOtherWZ]
                if bDebugMessages == true then LOG(sFunctionRef..': considering iOtherWZ='..iOtherWZ..'; Midpoint='..repru(tOtherWZData[M28Map.subrefMidpoint])..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tOtherWZData[M28Map.subrefMidpoint]))) end
                if M28Conditions.IsLocationInPlayableArea(tOtherWZData[M28Map.subrefMidpoint]) then
                    iOtherWZWanted = iOtherWZ
                    break
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for adjacent water zone to move to, iOtherWZWanted='..(iOtherWZWanted or 'nil')..'; ACU pos='..repru(oACU:GetPosition())) end
    if iOtherWZWanted then
        local tAdjWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iOtherWZWanted]][M28Map.subrefPondWaterZones][iOtherWZWanted]
        M28Orders.IssueTrackedMove(oACU, tAdjWZData[M28Map.subrefMidpoint], 2, false, 'MoveToWZ'..iOtherWZWanted, false)
    else
        local tPotentialDestination = M28Map.GetNearestWaterToBuildNavalFactoryInPlayableArea(aiBrain, oACU:GetPosition(), 8, nil, nil, true)
        if bDebugMessages == true then LOG(sFunctionRef..': Potential water destination to move to='..repru(tPotentialDestination)) end
        if tPotentialDestination then
            M28Orders.IssueTrackedMove(oACU, tPotentialDestination, 2, false, 'MoveToNBL', false)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetLowMexMapEarlyACUOrder(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData)
    local sFunctionRef = 'GetLowMexMapEarlyACUOrder'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, aiBrain[M28Economy.refiGrossEnergyBaseIncome]='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; aiBrain[M28Economy.refiGrossMassBaseIncome]='..aiBrain[M28Economy.refiGrossMassBaseIncome]) end

    --more specific initial build order
    local iMexInLandZone = 0
    local iResourceMod = aiBrain[M28Economy.refiBrainResourceMultiplier]
    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZMexLocations]) == false then iMexInLandZone = table.getn(tLZOrWZData[M28Map.subrefLZMexLocations]) end
    if aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(4, iMexInLandZone) * 0.2 * iResourceMod then
        ACUActionBuildMex(aiBrain, oACU)
        --want 40 energy for every 2 mass
    elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] < math.max(8, math.min(25, aiBrain[M28Economy.refiGrossMassBaseIncome] * 14)) then
        local bHydroBuildOrder = false
        local tClosestHydroToACU
        local iClosestDistToACU = 100000
        local iCurHydroDist
        local bHaveUnderConstructionFirstHydro = false
        local oOptionalUnderConstructionHydro --used for redundancy
        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]) == false then
            for iEntry, tHydro in tLZOrWZData[M28Map.subrefHydroLocations] do
                if bDebugMessages == true then LOG(sFunctionRef..': Travel dist to hydro='..M28Utilities.GetTravelDistanceBetweenPositions(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()], tHydro, M28Map.refPathingTypeLand)) end
                if M28Utilities.GetTravelDistanceBetweenPositions(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()], tHydro, M28Map.refPathingTypeLand) <= 125 then --further than normal since we are in low mass scenario
                    bHydroBuildOrder = true
                    iCurHydroDist = M28Utilities.GetTravelDistanceBetweenPositions(tHydro, oACU:GetPosition(), M28Map.refPathingTypeLand)
                    if iCurHydroDist < iClosestDistToACU then
                        iClosestDistToACU = iCurHydroDist
                        tClosestHydroToACU = {tHydro[1], tHydro[2], tHydro[3]}
                    end
                end
            end
        end
        if bHydroBuildOrder and aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= 10 then --have a hydro in the zone but havent built it yet, so want to build hydro
            ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData, oOptionalUnderConstructionHydro)
        else
            ACUActionBuildPower(aiBrain, oACU)
        end
    else
        --Build factory if dont have one and have lots of mass stored, or there are other mexes we want to get
        local iCurFactories = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory)
        if bDebugMessages == true then LOG(sFunctionRef..': iCurFactories='..iCurFactories..'; GetMexesNotNearPlayerStartingZone='..M28Conditions.GetMexesNotNearPlayerStartingZone()) end
        if iCurFactories == 0 and (aiBrain:GetEconomyStoredRatio('MASS') >= 0.95 or tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] > 0) then
            ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryLandFactory)
        elseif iCurFactories == 0 and M28Conditions.GetMexesNotNearPlayerStartingZone() > 0 then
            ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryLandFactory)
        else
            --Attack (further away) nearby units
            if not(AttackNearestEnemyWithACU(iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, oACU, 100)) then
                --Get any reclaim, if any
                if not(ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, oACU, false, 1)) then

                    --Assist upgrade if we have any
                    local oUnitToAssist
                    local iHighestFractionComplete = 0
                    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefActiveUpgrades]) == false then
                        for iUpgrading, oUpgrading in  tLZOrWZTeamData[M28Map.subrefActiveUpgrades] do
                            if M28UnitInfo.IsUnitValid(oUpgrading) then
                                if oUpgrading:GetWorkProgress() < 1 and oUpgrading:GetWorkProgress() > iHighestFractionComplete then
                                    iHighestFractionComplete = oUpgrading:GetWorkProgress()
                                    oUnitToAssist = oUpgrading
                                end
                            end
                        end
                    end
                    if oUnitToAssist then
                        if oUnitToAssist:GetFractionComplete() < 1 then
                            M28Orders.IssueTrackedRepair(oACU, oUnitToAssist, false, 'LMTR', false)
                            if bDebugMessages == true then LOG(sFunctionRef..': Just given repair order to oUnitToAssist') end
                        else
                            M28Orders.IssueTrackedGuard(oACU, oUnitToAssist, false, 'LMGB', false)
                            if bDebugMessages == true then LOG(sFunctionRef..': Just given guard order to oUnitToAssist') end
                        end
                    end
                end
            end
        end

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetACUEarlyGameOrders(aiBrain, oACU)
    local sFunctionRef = 'GetACUEarlyGameOrders'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iPlateauOrZero, iLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oACU:GetPosition())


    local tLZOrWZData
    local tLZOrWZTeamData
    local iTeam = oACU:GetAIBrain().M28Team
    local iResourceMod = aiBrain[M28Economy.refiBrainResourceMultiplier]
    --if aiBrain.CheatEnabled then iResourceMod = M28Team.tTeamData[aiBrain.M28Team][M28Team.refiHighestBrainResourceMultipler] end
    if iPlateauOrZero == 0 then
        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLZOrWZ]][M28Map.subrefPondWaterZones][iLZOrWZ]
        tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][aiBrain.M28Team]
    else
        tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLZOrWZ]
        tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Considering ACU for brain '..oACU:GetAIBrain().Nickname..'; Time='..GetGameTimeSeconds()..'; ACU state='..M28UnitInfo.GetUnitState(oACU)..'; iPlateauOrZero='..iPlateauOrZero..'; iLZOrWZ='..(iLZOrWZ or 'nil')..'; Hover label at position='..NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oACU:GetPosition())..'; ACU position='..repru(oACU:GetPosition())) end

    --Nearby enemy units in other land zone if we already have a complete land factory
    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory) >= 1 and iPlateauOrZero > 0 and AttackNearestEnemyWithACU(iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, oACU, 40) then
        if bDebugMessages == true then LOG(sFunctionRef..': ACU has enemies within 40 of it so will attack as we already have a factory complete') end
    else

        --Are we already building something?
        if bDebugMessages == true then LOG(sFunctionRef..': ACU unit state='..M28UnitInfo.GetUnitState(oACU)) end
        if not(oACU:IsUnitState('Building')) and not(oACU:IsUnitState('Repairing')) and (aiBrain:GetEconomyStoredRatio('MASS') <= 0.95 or not(oACU:IsUnitState('Reclaiming'))) then

            M28Air.UpdateTransportLocationShortlist(iTeam) --Redundancy

            --local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oACU:GetPosition(), true, oACU)

            if bDebugMessages == true then LOG(sFunctionRef..': iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLZOrWZ='..(iLZOrWZ or 'nil')..'; ACU pos='..repru(oACU:GetPosition())) end
            if (iPlateauOrZero or 0) > 0 and iLZOrWZ > 0 then
                --Do we want to build a mex, hydro or factory?
                if bDebugMessages == true then LOG(sFunctionRef..': Current land factories='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory)..'; Gross energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; Gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]) end
                local iMinEnergyPerTickWanted = 14 * iResourceMod --i.e. 6 T1 PGens given ACU gives 2 E
                --Large maps - consider going 2nd air instead of 2nd land
                local bGoSecondAir = false
                local iLandTravelDistanceToEnemyBase = 100000
                local iEnemyIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZOrWZTeamData[M28Map.reftClosestEnemyBase])
                local iOurIsland = tLZOrWZData[M28Map.subrefLZIslandRef]
                if iOurIsland > 0 and iOurIsland == iEnemyIsland then
                    local iEnemyPlateau, iEnemyLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tLZOrWZTeamData[M28Map.reftClosestEnemyBase])
                    if iEnemyLandZone > 0 then iLandTravelDistanceToEnemyBase = M28Map.GetTravelDistanceBetweenLandZones(iEnemyPlateau, iLZOrWZ, iEnemyLandZone) end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to go second air, map size='..(M28Map.iMapSize or 'nil')..'; iLandTravelDistanceToEnemyBase='..(iLandTravelDistanceToEnemyBase or 'nil')..'; Is table of potential drop zones empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau]))..'; Is transport island shortlist empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftTransportIslandDropShortlist]))..'; Travel distance using nearest allied and enemy base='..(M28Utilities.GetTravelDistanceBetweenPositions(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], tLZOrWZTeamData[M28Map.reftClosestEnemyBase], M28Map.refPathingTypeLand) or 'nil')) end
                if M28Map.iMapSize >= 512 and (M28Map.iMapSize > 512 or iLandTravelDistanceToEnemyBase > 280) and iPlateauOrZero > 0 and (M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau]) == false or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftTransportIslandDropShortlist]) == false) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Going second air due to map size or travel distance, unless have lots of mass stored and wnat a land fac quickly to spend the mass') end
                    if aiBrain:GetEconomyStoredRatio('MASS') >= 0.4 and M28Map.iMapSize <= 800 and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] and iLandTravelDistanceToEnemyBase <= 600 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory) < 2 then
                        --Dont go second air
                    else
                        bGoSecondAir = true
                    end
                end
                if not(bGoSecondAir) and M28Map.iMapSize >= 512 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveBrains]) == false and table.getn(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveBrains]) >= 2 then
                    --Still consider going 2nd air if have teammates between us and enemy (all teammates, not just M28 teammates) and are on a 10km+ map
                    if tLZOrWZTeamData[M28Map.refbBaseInSafePosition] then
                        bGoSecondAir = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Will go second air for brain '..aiBrain.Nickname) end
                    end

                end
                if bGoSecondAir then
                    if bDebugMessages == true then LOG(sFunctionRef..': Going second air, net energy base income='..aiBrain[M28Economy.refiNetEnergyBaseIncome]..'; Energy stored='..aiBrain:GetEconomyStored('ENERGY')) end
                    if aiBrain[M28Economy.refiNetEnergyBaseIncome] >= 4.5 and aiBrain:GetEconomyStored('ENERGY') >= 1800 then
                        iMinEnergyPerTickWanted = 20 * math.min(iResourceMod, aiBrain[M28Economy.refiBrainBuildRateMultiplier]) --Can get away with 4 pgens in some casese, even if engineers have managed to get some tree reclaim
                    else
                        iMinEnergyPerTickWanted = 22 * math.min(iResourceMod, aiBrain[M28Economy.refiBrainBuildRateMultiplier]) --ACU gives 2E, want equiv of 10 PGens, assuming build rate is same as resource rate
                    end
                end
                local iFactoryCap = 4 --redundancy - only intend to use in very low mass scenarios that arent low mex maps
                if aiBrain[M28Economy.refiGrossMassBaseIncome] < 0.8 * aiBrain[M28Economy.refiBrainBuildRateMultiplier] and (tLZOrWZData[M28Map.subrefLZMexCount] or 0) <= 2 and aiBrain:GetEconomyStoredRatio('MASS') < 0.3 then
                    iMinEnergyPerTickWanted = 6 * aiBrain[M28Economy.refiBrainBuildRateMultiplier]
                    iFactoryCap = 1
                end
                local iCurLandFactories = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory)
                if bDebugMessages == true then LOG(sFunctionRef..': iCurLandFactories='..iCurLandFactories..'; AIr factories='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory)..'; iFactoryCap='..iFactoryCap) end
                if M28Map.bIsLowMexMap and GetGameTimeSeconds() <= 1800 and tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] == 0 then
                    GetLowMexMapEarlyACUOrder(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData)
                else
                    if iCurLandFactories == 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want ACU to build land factory') end
                        ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryLandFactory)
                        --do we have unbuilt nearby mexes (within 2 of ACU build range)? if so then build on them
                    elseif aiBrain.CheatEnabled and iResourceMod >= 1.3 and aiBrain:GetEconomyStored('MASS') >= 90 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] < iMinEnergyPerTickWanted and ((iResourceMod >= 1.5 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 6 * M28Team.tTeamData[aiBrain.M28Team][M28Team.refiHighestBrainResourceMultipler]) or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower) == 0) and (tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] or 0) >= 2 then
                        --Build a couple of PGen even if nearby hydro given cheat mult
                        ACUActionBuildPower(aiBrain, oACU)
                    elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 12 * iResourceMod and ConsiderBuildingMex(tLZOrWZData, tLZOrWZTeamData, oACU, 2) then
                        --Do nothing - have bene given an order to build a neaby mex
                    elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] < iMinEnergyPerTickWanted then

                        --Do we want to build a hydro (so get mexes first then hydro) or build pgen?


                        local bHydroBuildOrder = false
                        --On crag dunes the hydro travel distance is 102 away and going for early hydro (with 4 mexes) causes power stall; top players BO appears to be normal no-hydro BO
                        --For theta passage the travel distance is 62.5
                        --For Cadmium green its 51.9
                        local tClosestHydroToACU
                        local iClosestDistToACU = 100000

                        local iCurHydroDist
                        local bHaveUnderConstructionFirstHydro = false
                        local oOptionalUnderConstructionHydro --used for redundancy
                        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]) == false then

                            for iEntry, tHydro in tLZOrWZData[M28Map.subrefHydroLocations] do
                                if bDebugMessages == true then LOG(sFunctionRef..': Travel dist to hydro='..M28Utilities.GetTravelDistanceBetweenPositions(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()], tHydro, M28Map.refPathingTypeLand)) end
                                if M28Utilities.GetTravelDistanceBetweenPositions(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()], tHydro, M28Map.refPathingTypeLand) <= 90 then --Open palms is 85.65
                                    bHydroBuildOrder = true
                                    iCurHydroDist = M28Utilities.GetTravelDistanceBetweenPositions(tHydro, oACU:GetPosition(), M28Map.refPathingTypeLand)
                                    if iCurHydroDist < iClosestDistToACU then
                                        iClosestDistToACU = iCurHydroDist
                                        tClosestHydroToACU = {tHydro[1], tHydro[2], tHydro[3]}
                                    end
                                end
                            end
                        end
                        if not(bHydroBuildOrder) then
                            --Redundancy 1 incase have a hydro registered to core zone instead of nearby and we ahve travlled to nearby zone
                            local tNearbyHydro = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryHydro, oACU:GetPosition(), 35, 'Ally')
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby hydros empty='..tostring(M28Utilities.IsTableEmpty(tNearbyHydro))) end
                            local oCompleteHydro
                            if M28Utilities.IsTableEmpty(tNearbyHydro) == false then

                                for iHydro, oHydro in tNearbyHydro do
                                    if oHydro:GetAIBrain() == aiBrain and oHydro:GetFractionComplete() < 1 then
                                        iCurHydroDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oHydro:GetPosition())
                                        if iCurHydroDist < iClosestDistToACU then
                                            iClosestDistToACU = iCurHydroDist
                                            tClosestHydroToACU = oHydro:GetPosition()
                                            oOptionalUnderConstructionHydro = oHydro
                                        end
                                    else
                                        oCompleteHydro = oHydro
                                    end
                                end
                            end
                            if not(oOptionalUnderConstructionHydro) and oCompleteHydro then
                                iClosestDistToACU = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oCompleteHydro:GetPosition())
                                tClosestHydroToACU = oCompleteHydro:GetPosition()
                                bHydroBuildOrder = true
                            elseif oOptionalUnderConstructionHydro then bHydroBuildOrder = true
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Will adjust build order depending on if have hydro nearby. Is table of land zone hydros empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]))..'; bHydroBuildOrder='..tostring(bHydroBuildOrder)) end
                        if not(bHydroBuildOrder) then
                            --Per discord gameplay and training pinned build order for going land facs with no hydro:
                            --ACU:      Landfac - 2 PG - 2 Mex - 1 PG - 2 Mex - 3 PG - Landfac - PG - Landfac
                            if bDebugMessages == true then LOG(sFunctionRef..': No hydro locations so will build power or mex depending on income') end
                            if aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 6 * iResourceMod then
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to build initial PGens') end
                                ACUActionBuildPower(aiBrain, oACU)
                            else
                                local iMexInLandZone = 0
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZMexLocations]) == false then iMexInLandZone = table.getn(tLZOrWZData[M28Map.subrefLZMexLocations]) end
                                local iMaxMexesBeforeHydro = 4
                                if iMexInLandZone > 4 and aiBrain:GetEconomyStored('MASS') >= 25 then iMaxMexesBeforeHydro = 3 end
                                if bDebugMessages == true then LOG(sFunctionRef..': Deciding on ACU action for where no hydro nearby, gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; Gross energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; iMexInLandZone='..iMexInLandZone..'; iMinEnergyPerTickWanted='..iMinEnergyPerTickWanted..'; iCurLandFactories='..iCurLandFactories) end
                                if aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(2, iMexInLandZone) * 0.2 * iResourceMod then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want at least 2 mexes') end
                                    ACUActionBuildMex(aiBrain, oACU)

                                elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 8 * iResourceMod then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want at least 4 PGens') end
                                    ACUActionBuildPower(aiBrain, oACU)
                                elseif aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(iMaxMexesBeforeHydro, iMexInLandZone) * 0.2 * iResourceMod then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want up to iMaxMexesBeforeHydro='..iMaxMexesBeforeHydro..' mexes') end
                                    ACUActionBuildMex(aiBrain, oACU)
                                elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] < iMinEnergyPerTickWanted and ((aiBrain:GetEconomyStoredRatio('ENERGY') <= 0.6 or (aiBrain:GetEconomyStoredRatio('ENERGY') <= 0.75 and aiBrain[M28Economy.refiNetEnergyBaseIncome] <= 3) or (aiBrain[M28Economy.refiNetEnergyBaseIncome] <= 1.5 and (aiBrain[M28Economy.refiNetEnergyBaseIncome] < 0.5 or aiBrain:GetEconomyStoredRatio('ENERGY') <= 0.98)) or aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= math.max(12 * aiBrain[M28Economy.refiBrainBuildRateMultiplier], iMinEnergyPerTickWanted * 0.75)) or aiBrain:GetEconomyStoredRatio('MASS') >= 0.35) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want basic level of power, energy stored='..aiBrain:GetEconomyStoredRatio('ENERGY')..'; Net income='..aiBrain[M28Economy.refiNetEnergyBaseIncome]..'; Gross inc='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; Mass %='..aiBrain:GetEconomyStoredRatio('MASS')) end
                                    ACUActionBuildPower(aiBrain, oACU)
                                    --below are redundancy - if we have min energy per tick wanted then wouldn't expect below to trigger
                                elseif aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(4, iMexInLandZone) * 0.2 * iResourceMod then
                                    --e.g. if went 3 mex hydro then want to get 4th mex before factory
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want up to 4 mexes') end
                                    ACUActionBuildMex(aiBrain, oACU)
                                elseif iCurLandFactories < 2 and iCurLandFactories + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) < 3 and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] and M28Conditions.WantMoreFactories(aiBrain.M28Team, iPlateauOrZero, iLZOrWZ) then
                                    if bGoSecondAir then
                                        ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryAirFactory, M28Engineer.refActionBuildAirFactory)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to go second air') end
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want 2 land factories') end
                                        ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData)
                                    end
                                elseif aiBrain[M28Economy.refiGrossMassBaseIncome] < iMexInLandZone * 0.2 * iResourceMod then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to build on every mex in land zone') end
                                    ACUActionBuildMex(aiBrain, oACU)
                                elseif iCurLandFactories < 2 and M28Map.iMapSize <= 512 and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] and aiBrain:GetEconomyStored('MASS') >= 40 and iPlateauOrZero > 0 and (aiBrain:GetEconomyStored('MASS') >= 200 or M28Conditions.WantMoreFactories(iTeam, iPlateauOrZero, iLZOrWZ)) and not(M28Overseer.bNoRushActive) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have 2 land facs yet so will get another') end
                                    --ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLandOrWaterZone, tLZData, tLZTeamData, iFactoryCategoryOverride, iEngineerActionOverride)
                                    ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData,     M28UnitInfo.refCategoryLandFactory, M28Engineer.refActionBuildLandFactory)

                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': We dont have the min level of power that we want yet') end
                                    ACUActionBuildPower(aiBrain, oACU)
                                end
                            end

                            --Redundancy if failed to get orer from the above
                            if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) and oACU[refbDoingInitialBuildOrder] then
                                --No hydro nearby - try building power; then try building mex; then cancel initial build order
                                ACUActionBuildMex(aiBrain, oACU)
                                if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) then
                                    ACUActionBuildPower(aiBrain, oACU)
                                    if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) then
                                        oACU[refbDoingInitialBuildOrder] = false
                                    end
                                end
                            end
                        else --Have a hydro so get more mexes initially
                            --Max mex to build
                            local iHydroDistToStart = M28Utilities.GetDistanceBetweenPositions(tClosestHydroToACU, tLZOrWZData[M28Map.subrefMidpoint])
                            local iMexInLandZone = 0
                            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZMexLocations]) == false then iMexInLandZone = table.getn(tLZOrWZData[M28Map.subrefLZMexLocations]) end
                            if bDebugMessages == true then LOG(sFunctionRef..': Hydro is nearby, Gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; iMexInLandZone='..iMexInLandZone..'; Gross base energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; Dist of closest hydro='..iHydroDistToStart) end
                            --Do we have a hydro underconstruction in this land zone?
                            if aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 12 * iResourceMod then
                                local tHydroInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryHydro, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                if M28Utilities.IsTableEmpty(tHydroInZone) == false then
                                    bHaveUnderConstructionFirstHydro = true
                                    for iHydro, oHydro in tHydroInZone do
                                        if oHydro:GetFractionComplete() == 1 and oHydro:GetAIBrain() == aiBrain then
                                            bHaveUnderConstructionFirstHydro = false
                                            break
                                        end
                                    end
                                end
                            end
                            local iMexCap = 4
                            if iHydroDistToStart >= 75 then iMexCap = 3 end --e.g. Verdant Valley - dist is c.95, and we power-stall if going for 4 mexes (even after getting 4 trees).  Theta passage dist is 32
                            local bHaveUnbuiltMexNearHydro = false
                            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false then
                                local iDistanceThreshold = 80 - 5 * (tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3])

                                for iMex, tMex in tLZOrWZData[M28Map.subrefMexUnbuiltLocations] do
                                    if M28Utilities.GetTravelDistanceBetweenPositions(tMex, tClosestHydroToACU, M28Map.refPathingTypeLand) <= iDistanceThreshold then
                                        bHaveUnbuiltMexNearHydro = true
                                    end
                                end
                            end

                            if bHaveUnderConstructionFirstHydro and (aiBrain[M28Economy.refiGrossMassBaseIncome] >= 1.2 * iResourceMod or tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] >= math.min(3, iMexInLandZone)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have underconstruction hydro and equiv of 3 mexes or every mex in zone so will try and assist it') end
                                ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData, oOptionalUnderConstructionHydro)
                            elseif bHaveUnbuiltMexNearHydro and aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(iMexCap, iMexInLandZone) * 0.2 * aiBrain[M28Economy.refiBrainBuildRateMultiplier] or (aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(4, iMexInLandZone) * 0.2 * iResourceMod and aiBrain:GetEconomyStored('MASS') < 100) then
                                if bDebugMessages == true then LOG(sFunctionRef..': We ahve mexes in land zone and we havent built on all of them so will build a mex') end
                                ACUActionBuildMex(aiBrain, oACU)
                                if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) then M28Utilities.ErrorHandler('ACU wants to build a mex but failed to find anywhere') end
                            elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 10 * iResourceMod and (iResourceMod <= 1.7 or aiBrain:GetEconomyStored('MASS') <= 80) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will try to assist a hydro nearby') end
                                ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData, oOptionalUnderConstructionHydro)
                            else --We ahve alreadyu confirmed we have < min energy per tick wanted earlier, so want to build pgen
                                --Have base level of power suggesting already have hydro but we still want a bit more power
                                if bDebugMessages == true then LOG(sFunctionRef..': Want more power to reach a base level') end
                                ACUActionBuildPower(aiBrain, oACU)
                            end

                            --Redundancy if fail to get order from above
                            if bDebugMessages == true then LOG(sFunctionRef..': Is ACU table of last orders empty after attempting above='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))..'; Does ACU have a valid order='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))) end
                            if not(M28Conditions.DoesACUHaveValidOrder(oACU)) and oACU[refbDoingInitialBuildOrder] then
                                --Is it just that we want to assist a hydro and engineers havent started one yet? If so then check if we have an engineer assigned to build one, and check the game time
                                if GetGameTimeSeconds() <= 180 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 10 * iResourceMod and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]) == false then
                                    ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData, oOptionalUnderConstructionHydro)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Assuming we are waiting for an engi to start on building a hydro, or we have no nearby mexes to our ACU') end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': Failed to get order from above so will resort to backup logic') end
                                    --No hydro nearby - try building power; then try building mex; then cancel initial build order
                                    ACUActionBuildMex(aiBrain, oACU)
                                    if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then
                                        ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData)
                                        if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then
                                            ACUActionBuildPower(aiBrain, oACU)
                                            if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then
                                                if not(M28Map.bIsCampaignMap) or GetGameTimeSeconds() <= 540 then oACU[refbDoingInitialBuildOrder] = false end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    else
                        --Have initial power and mexes built, get second factory now subject to the cap
                        if iCurLandFactories + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) < iFactoryCap then
                            local bWantAirFactory = M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZOrWZData, tLZOrWZTeamData)
                            if bDebugMessages == true then LOG(sFunctionRef..': Checking if want more factories, iCurLandFactories='..iCurLandFactories..'; Want more factories='..tostring(M28Conditions.WantMoreFactories(aiBrain.M28Team, iPlateauOrZero, iLZOrWZ))..'; Cur air factories='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory)) end
                            if bGoSecondAir and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) == 0 then
                                ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryAirFactory, M28Engineer.refActionBuildAirFactory)
                                if bDebugMessages == true then LOG(sFunctionRef..': Want ACU to go second air') end
                            elseif iCurLandFactories < 2 and M28Conditions.WantMoreFactories(aiBrain.M28Team, iPlateauOrZero, iLZOrWZ) and iCurLandFactories + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) < 3 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to g et a second land factory or air factory') end
                                if bWantAirFactory then
                                    ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData,     M28UnitInfo.refCategoryAirFactory, M28Engineer.refActionBuildAirFactory)
                                else
                                    ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData,     M28UnitInfo.refCategoryLandFactory, M28Engineer.refActionBuildLandFactory)
                                end
                            elseif iCurLandFactories < 2 and M28Map.iMapSize <= 512 and aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] and aiBrain:GetEconomyStored('MASS') >= 40 and iPlateauOrZero > 0 and (aiBrain:GetEconomyStored('MASS') >= 200 or M28Conditions.WantMoreFactories(iTeam, iPlateauOrZero, iLZOrWZ)) and not(M28Overseer.bNoRushActive) and iCurLandFactories + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) < 2 then
                                --ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLandOrWaterZone, tLZData, tLZTeamData, iFactoryCategoryOverride, iEngineerActionOverride)
                                if bDebugMessages == true then LOG(sFunctionRef..': Dont have 2 land facs yet so will get another') end
                                if bWantAirFactory then
                                    ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData,     M28UnitInfo.refCategoryAirFactory, M28Engineer.refActionBuildAirFactory)
                                else
                                    ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData,     M28UnitInfo.refCategoryLandFactory, M28Engineer.refActionBuildLandFactory)
                                end
                            else
                                local iMexInLandZone = 0
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZMexLocations]) == false then iMexInLandZone = table.getn(tLZOrWZData[M28Map.subrefLZMexLocations]) end
                                if bDebugMessages == true then LOG(sFunctionRef..': Checking if want to build more mexes, iMexInLandZone='..iMexInLandZone..'; Mex count for LZ='..tLZOrWZData[M28Map.subrefLZMexCount]..'; Gross mass='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; iResourceMod='..iResourceMod..'; Is table of unbuilt mexes empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]))..'; Mex count by tech='..repru(tLZOrWZTeamData[M28Map.subrefMexCountByTech])..'; iCurLandFactories='..iCurLandFactories..'; iCurAirFactories='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory)) end
                                if aiBrain[M28Economy.refiGrossMassBaseIncome] < iMexInLandZone * 0.2 * iResourceMod and (aiBrain:GetEconomyStoredRatio('MASS') <= 0.9 or aiBrain:GetEconomyStored('MASS') < 100)  then
                                    ACUActionBuildMex(aiBrain, oACU)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will try building another mex') end
                                    --Third factory if overflowing mass or have quite a bit stored
                                elseif iCurLandFactories < 3 and (M28Map.iMapSize <= 512 and (M28Map.iMapSize <= 256 or M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] == 1)) and aiBrain:GetEconomyStored('MASS') >= 250 or (aiBrain:GetEconomyStoredRatio('MASS') >= 0.9 and aiBrain:GetEconomyStored('MASS') >= 100) and iCurLandFactories + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) < 4 and M28Conditions.WantMoreFactories(iTeam, iPlateauOrZero, iLZOrWZ) then

                                    if bWantAirFactory then
                                        ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData,     M28UnitInfo.refCategoryAirFactory, M28Engineer.refActionBuildAirFactory)
                                    else
                                        ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData,     M28UnitInfo.refCategoryLandFactory, M28Engineer.refActionBuildLandFactory)
                                    end
                                    --If we are overflowing mass and have a unit upgrading in the zone then assist that instead (e.g. intended for maps where loads of reclaim that causes us to overflow)
                                else
                                    local oUnitToAssist
                                    if aiBrain:GetEconomyStoredRatio('MASS') >= 0.9 and aiBrain:GetEconomyStored('MASS') >= 100 and tLZOrWZData[M28Map.subrefTotalMassReclaim] >= 1000 and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefActiveUpgrades]) == false then
                                        local iHighestFractionComplete = 0
                                        local oUnitToAssist
                                        for iUpgrading, oUpgrading in  tLZOrWZTeamData[M28Map.subrefActiveUpgrades] do
                                            if M28UnitInfo.IsUnitValid(oUpgrading) then
                                                if oUpgrading:GetWorkProgress() < 1 and oUpgrading:GetWorkProgress() > iHighestFractionComplete then
                                                    iHighestFractionComplete = oUpgrading:GetWorkProgress()
                                                    oUnitToAssist = oUpgrading
                                                end
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': oUnitToAssist='..(oUnitToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitToAssist) or 'nil')) end
                                    if M28UnitInfo.IsUnitValid(oUnitToAssist) then
                                        M28Orders.IssueTrackedGuard(oACU, oUnitToAssist, false, 'ACUEGAssist', false)
                                    elseif M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false and tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] < iMexInLandZone then
                                        ACUActionBuildMex(aiBrain, oACU)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try building more mexes') end
                                    else
                                        --Finish the initial BO
                                        oACU[refbDoingInitialBuildOrder] = false
                                        if bDebugMessages == true then LOG(sFunctionRef..': Finishing initial build order') end
                                    end
                                end
                            end
                        else
                            --Have the power and factories that we want; if there are mexes in the zone then build them; if not then finish initial build order
                            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false and tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] < tLZOrWZData[M28Map.subrefLZMexCount] then
                                ACUActionBuildMex(aiBrain, oACU)
                                if bDebugMessages == true then LOG(sFunctionRef..': Low factory BO Will try building more mexes') end
                            else
                                --Finish the initial BO
                                oACU[refbDoingInitialBuildOrder] = false
                                if bDebugMessages == true then LOG(sFunctionRef..': Low factory BO Finishing initial build order') end
                            end
                        end
                    end
                end
                --backup in case of unit restrictions (campaign) or e.g. far away mex that we dont want to build
                if bDebugMessages == true then LOG(sFunctionRef..': Campaign redundancy for if ACU has no order, reprs of last orders='..reprs(oACU[M28Orders.reftiLastOrders])..'; oACU[refbDoingInitialBuildOrder]='..tostring(oACU[refbDoingInitialBuildOrder])..'; M28Map.bIsCampaignMap='..tostring(M28Map.bIsCampaignMap)..'; Is table of last orders empty='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))) end
                if not(M28Conditions.DoesACUHaveValidOrder(oACU)) and oACU[refbDoingInitialBuildOrder] and (not(M28Map.bIsLowMexMap) or aiBrain:GetEconomyStoredRatio('MASS') >= 0.95) then
                    --Build mex if any available mex locations in zone
                    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false then
                        ACUActionBuildMex(aiBrain, oACU)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Redundancy - Attempted to build mex if there were any unbuilt locations, IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations])='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]))..', is table of last orders empty='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))..'; DoesACUHaveValidOrder(oACU)='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))) end
                    if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then
                        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]) == false then ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData) end
                        if bDebugMessages == true then LOG(sFunctionRef..': Redundancy - Attempted to assist hydro, is table of last orders empty='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))..'; DoesACUHaveValidOrder(oACU)='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))) end
                        if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then
                            local iCurPower =  aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPower) + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryHydro) * 5
                            if iCurPower <= 7 or (iCurPower <= 13 and aiBrain:GetEconomyStoredRatio('MASS') >= 0.25 and aiBrain:GetEconomyStoredRatio('ENERGY') <= 0.95) then
                                ACUActionBuildPower(aiBrain, oACU)
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Redundancy - Attempted to build power, is table of last orders empty='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))..'; DoesACUHaveValidOrder(oACU)='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))..'; Cur factory count='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory)) end
                            if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then

                                if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory) < 3 then
                                    if aiBrain:GetEconomyStoredRatio('MASS') >= 0.2 and aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.8 then
                                        ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryLandFactory, M28Engineer.refActionBuildLandFactory)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Redundancy - Attempted to build land factory, is table of last orders empty='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))..'; DoesACUHaveValidOrder(oACU)='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))) end
                                        if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then
                                            ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryAirFactory, M28Engineer.refActionBuildAirFactory)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Redundancy - Attempted to build air factory, is table of last orders empty='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))..'; DoesACUHaveValidOrder(oACU)='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))) end
                                            if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then
                                                ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryNavalFactory, M28Engineer.refActionBuildNavalFactory)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Redundancy - Attempted to build naval factory, is table of last orders empty='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))..'; DoesACUHaveValidOrder(oACU)='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))) end
                                                if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then
                                                    --Are we capable of building a naval factory yet?
                                                    --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition,               oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
                                                    local sNavalFacBP = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryNavalFactory, oACU)
                                                    if sNavalFacBP then

                                                        --Do we have an adjacent water zone? If so then move here as might be Aeon M1 where can only build naval fac)
                                                        if iPlateauOrZero > 0 and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]) == false then
                                                            MoveACUToNearbyWaterForFactory(aiBrain, oACU, tLZOrWZData)

                                                        else
                                                            M28Utilities.ErrorHandler('Unable to get any action for ACU owned by brain '..aiBrain.Nickname)
                                                        end
                                                    else
                                                        --Campaign specific - might have strange restrictions early game, so hide this message initially
                                                        if not(M28Map.bIsCampaignMap) or GetGameTimeSeconds() >= 300 then
                                                            M28Utilities.ErrorHandler('Unable to get early game action for ACU')
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            else
                --ACU is underwater so presumably water based start position

                if (iLZOrWZ or 0) == 0 then

                    --Go to the midpoint of the nearest zone that can find
                    --Move to midpoint
                    M28Orders.IssueTrackedMove(oACU, tLZOrWZData[M28Map.subrefMidpoint], 1, false, 'FindValidLoc', false)
                    M28Utilities.ErrorHandler('ACU showing as not being on a land zone, but doesnt have a water zone either, will try moving to midpoint of nearest land or water zone')
                else
                    oACU[refbStartedUnderwater] = true
                    --Are in a water zone - build a naval fac and build on any unbuilt mexes before marking initial BO as being  complete
                    local iCurNavalFactories = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalFactory)
                    if bDebugMessages == true then LOG(sFunctionRef..': iCurNavalFactories='..iCurNavalFactories..'; Is table of unbuilt mex locations empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]))..'; Gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; Gross energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; Is table of hydro locations empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]))) end
                    if iCurNavalFactories == 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want ACU to build land factory') end
                        ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLZOrWZ, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryNavalFactory, M28Engineer.refActionBuildNavalFactory)
                    else
                        --Build mexes if nearby assuming we have nearby hydr; assist hydro if we have hydro
                        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false and (aiBrain[M28Economy.refiGrossMassBaseIncome] < 0.8 * iResourceMod or aiBrain[M28Economy.refiGrossEnergyBaseIncome] > 10 * iResourceMod) then
                            if bDebugMessages == true then LOG(sFunctionRef..': We have unbuilt mexes in water zone and our income seems less than 4 mex equiv, so will build mexes') end
                            ACUActionBuildMex(aiBrain, oACU)
                        elseif M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]) == false and aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 10 * iResourceMod then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will try to assist a hydro nearby') end
                            ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData)
                        elseif M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false then
                            ACUActionBuildMex(aiBrain, oACU)
                        else
                            oACU[refbDoingInitialBuildOrder] = false
                        end
                    end
                end

            end
        else
            --Rare case where ACU and engieners start building pgen at the same time, leading to them both building separately to each other; solution - if ACU fraction complete is <10%, switch to the engi built one if it is in the build range
            local oACUFocusUnit = oACU:GetFocusUnit()
            if bDebugMessages == true then LOG(sFunctionRef..': Are building so wont give any new orders subject to Pgen execption and reclaiming wreck mass exception. is oACUFocusUnit valid='..tostring(M28UnitInfo.IsUnitValid(oACUFocusUnit)))
                if M28UnitInfo.IsUnitValid(oACUFocusUnit) then LOG(sFunctionRef..': Focus unit='..oACUFocusUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACUFocusUnit)..'; Fraction complete='..oACUFocusUnit:GetFractionComplete()..'; ACU work progress='..oACU:GetWorkProgress()) end
            end
            --If about to overflow mass, dont have a valid unit being built, and we have at least 1 factory in the zone, then build power or do nothing
            if not(M28UnitInfo.IsUnitValid(oACUFocusUnit)) and aiBrain:GetEconomyStoredRatio('MASS') >= 0.95 and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false then
                --Are overflowing mass presumably from trying to build on a wreck - either build power or (if we have lots of power) clear orders
                if bDebugMessages == true then LOG(sFunctionRef..': Will try either clearing commands or building power') end
                if aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 80 then
                    M28Orders.IssueTrackedClearCommands(oACU)
                else
                    --Is there an under construction hydro in this zone? if so assist it, otherwise build a pgen
                    local bHaveUnderConstructionFirstHydro = false
                    local oOptionalUnderConstructionHydro
                    local tHydroInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryHydro, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tHydroInZone) == false then
                        for iHydro, oHydro in tHydroInZone do
                            if oHydro:GetFractionComplete() < 1 and oHydro:GetAIBrain() == aiBrain then
                                bHaveUnderConstructionFirstHydro = true
                                oOptionalUnderConstructionHydro = oHydro
                                break
                            end
                        end
                    end
                    if bHaveUnderConstructionFirstHydro then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to assist hydro') end
                        ACUActionAssistHydro(aiBrain, oACU, tLZOrWZData, tLZOrWZTeamData, oOptionalUnderConstructionHydro)
                    else
                        ACUActionBuildPower(aiBrain, oACU)
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to build power') end
                    end
                end


            elseif EntityCategoryContains(M28UnitInfo.refCategoryPower * categories.TECH1, oACUFocusUnit.UnitId) and aiBrain:GetEconomyStored('ENERGY') < 1500 and oACUFocusUnit:GetFractionComplete() < 0.1 then
                local tNearbyPower = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryPower * categories.TECH1, oACU:GetPosition(), oACU:GetBlueprint().Economy.MaxBuildDistance + M28UnitInfo.GetBuildingSize(oACUFocusUnit.UnitId), 'Ally')
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby power empty='..tostring(M28Utilities.IsTableEmpty(tNearbyPower))) end
                if M28Utilities.IsTableEmpty(tNearbyPower) == false and table.getn(tNearbyPower) >= 2 then
                    local tEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    local tPowerBuiltByEngineers = {}
                    local oCurFocusUnit
                    if M28Utilities.IsTableEmpty(tEngineers) == false then
                        for iEngineer, oEngineer in tEngineers do
                            if M28UnitInfo.IsUnitValid(oEngineer) and oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionBuildPower then
                                oCurFocusUnit = oEngineer:GetFocusUnit()
                                if EntityCategoryContains(M28UnitInfo.refCategoryPower * categories.TECH1, oCurFocusUnit.UnitId) then
                                    table.insert(tPowerBuiltByEngineers, oCurFocusUnit)
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': is table of power built by engineers empty='..tostring(M28Utilities.IsTableEmpty(tPowerBuiltByEngineers))) end
                    if M28Utilities.IsTableEmpty(tPowerBuiltByEngineers) == false then
                        --Do we have any engineers building the ACU focus unit?
                        local bEngineersBuildingACUPower = false
                        for iUnit, oUnit in tPowerBuiltByEngineers do
                            if oUnit == oACUFocusUnit then bEngineersBuildingACUPower = true break end
                        end
                        if not(bEngineersBuildingACUPower) then
                            local bHaveEngineersBuildingThisPower
                            local iMostCompletePower = 0
                            local oPowerToSwitchTo
                            for iUnit, oUnit in tNearbyPower do
                                if not(oUnit == oACUFocusUnit) then
                                    --Do we have engineers building this power?
                                    bHaveEngineersBuildingThisPower = false
                                    for iPower, oPower in tPowerBuiltByEngineers do
                                        if oPower == oUnit then
                                            bHaveEngineersBuildingThisPower = true
                                            break
                                        end
                                    end
                                    if bHaveEngineersBuildingThisPower then
                                        if oUnit:GetFractionComplete() > iMostCompletePower then
                                            iMostCompletePower = oUnit:GetFractionComplete()
                                            oPowerToSwitchTo = oUnit
                                        end
                                    end
                                end
                            end
                            if oPowerToSwitchTo then
                                M28Orders.IssueTrackedRepair(oACU, oPowerToSwitchTo, false, 'EGPwrR', false)
                            end
                        end
                    end
                end
                --Hydro and power-stalling and tree reclaim within build area - reclaim trees
            elseif aiBrain:GetEconomyStored('ENERGY') <= 30 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 10 then
                local iReclaimSegmentX, iReclaimSegmentZ = M28Map.GetReclaimSegmentsFromLocation(oACU:GetPosition())
                if bDebugMessages == true then LOG(sFunctionRef..': Are power stalling, will see if energy reclaim nearby, energy in segment are in='..M28Map.tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][M28Map.refSegmentReclaimTotalEnergy]) end
                if M28Map.tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][M28Map.refSegmentReclaimTotalEnergy] > 10 then
                    local iBuildRange = oACU:GetBlueprint().Economy.MaxBuildDistance
                    local rNearbyRect = M28Utilities.GetRectAroundLocation(oACU:GetPosition(), iBuildRange)
                    local tReclaimables = M28Map.GetReclaimInRectangle(4, rNearbyRect, false)
                    if M28Utilities.IsTableEmpty(tReclaimables) == false then
                        local tWrecksToReclaim = {}
                        for iWreck, oWreck in tReclaimables do
                            if (oWreck.MaxEnergyReclaim or 0) >= 10 and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oWreck.CachePosition) <= iBuildRange then
                                table.insert(tWrecksToReclaim, oWreck)
                            end
                        end
                        if M28Utilities.IsTableEmpty(tWrecksToReclaim) == false then
                            M28Orders.IssueTrackedClearCommands(oACU)
                            for iWreck, oWreck in tWrecksToReclaim do
                                M28Orders.IssueTrackedReclaim(oACU, oWreck, true, 'ACUTree', false)
                            end
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, is ACU table of last orders empty='..tostring(M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]))..'; Does ACU have valid order='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetUpgradePathForACU(oACU, bWantToDoTeleSnipe)
    --Records the order of upgrades we will want for the ACU
    local sFunctionRef = 'GetUpgradePathForACU'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; oACU='..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' owned by brain '..oACU:GetAIBrain().Nickname..'; oACU[refbStartedUnderwater]='..tostring(oACU[refbStartedUnderwater] or false)) end
    local oBP = oACU:GetBlueprint()

    if (bWantToDoTeleSnipe or (oACU[refbPlanningToGetTeleport] and (oACU:HasEnhancement('MicrowaveLaserGenerator') or oACU:HasEnhancement('Teleporter') or oACU:HasEnhancement('BlastAttack')))) and oBP.Enhancements['Teleporter'] then
        if EntityCategoryContains(categories.CYBRAN, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'CoolingUpgrade', 'MicrowaveLaserGenerator', 'Teleporter'}
        elseif EntityCategoryContains(categories.SERAPHIM, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'RateOfFire', 'BlastAttack', 'Teleporter'}
        else M28Utilities.ErrorHandler('Trying to do telesnipe without a cybran or seraphim ACU')
        end
    elseif oACU[refbStartedUnderwater] then

        if EntityCategoryContains(categories.UEF, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'ResourceAllocation', 'Shield'}
        elseif EntityCategoryContains(categories.AEON, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'ResourceAllocation', 'ResourceAllocationAdvanced'}
        elseif EntityCategoryContains(categories.CYBRAN, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'NaniteTorpedoTube', 'StealthGenerator'}
        elseif EntityCategoryContains(categories.SERAPHIM, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'AdvancedEngineering', 'ResourceAllocation', 'ResourceAllocationAdvanced'}
        end
    else
        if EntityCategoryContains(categories.UEF, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'HeavyAntiMatterCannon', 'DamageStabilization', 'Shield'}
        elseif EntityCategoryContains(categories.AEON, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'CrysalisBeam', 'HeatSink', 'Shield'}
        elseif EntityCategoryContains(categories.CYBRAN, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'CoolingUpgrade', 'StealthGenerator'}
            --FAF upcoming balance patch expected 15th July to introduce nano upgrade for Cybran
            if oBP.Enhancements['SelfRepairSystem'] then table.insert( oACU[reftPreferredUpgrades], 'SelfRepairSystem') end
        elseif EntityCategoryContains(categories.SERAPHIM, oACU.UnitId) then
            oACU[reftPreferredUpgrades] = {'RateOfFire', 'AdvancedEngineering'}
        end
    end

    --Check all of these are options (in case a mod has changed them)
    local tRestrictedEnhancements = import("/lua/enhancementcommon.lua").GetRestricted()
    local bCheckForRestrictions = not (M28Utilities.IsTableEmpty(tRestrictedEnhancements))
    local bInvalidUpgrade

    if M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) == false then
        local tiEntriesToRemove = {}
        for iUpgradeWanted, sUpgradeWanted in oACU[reftPreferredUpgrades] do
            bInvalidUpgrade = false
            if M28Utilities.IsTableEmpty(oBP.Enhancements[sUpgradeWanted]) then
                bInvalidUpgrade = true
                oACU[reftPreferredUpgrades] = {}
                break
            elseif bCheckForRestrictions then
                --If we cant get the first upgrade, then cancel all upgrades; otherwise just remove the later upgrade that we cant get
                if tRestrictedEnhancements[sUpgradeWanted] then
                    bInvalidUpgrade = true
                end
            end
            if bInvalidUpgrade then
                if iUpgradeWanted <= 1 then
                    oACU[reftPreferredUpgrades] = {}
                    break
                else
                    table.insert(tiEntriesToRemove, iUpgradeWanted)
                end
            end
        end
        if M28Utilities.IsTableEmpty(tiEntriesToRemove) == false then
            local iTotalEntriesToRemove = table.getn(tiEntriesToRemove)
            for iCurEntry = iTotalEntriesToRemove, 1, -1 do
                table.remove(oACU[reftPreferredUpgrades], tiEntriesToRemove[iCurEntry])
            end
        end
    end
    if M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) then
        --Find the cheapest upgrade that boosts either rate of fire or range (if didnt start underwater) or that boosts build power (if started underwater)
        oACU[reftPreferredUpgrades] = {}
        local iLowestMassCost = 1000000
        local sLowestUpgrade
        for sUpgrade, tUpgrade in oBP.Enhancements do
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Considering sUpgrade=' .. sUpgrade .. '; tUpgrade=' .. reprs(tUpgrade))
            end
            if (oACU[refbStartedUnderwater] and (tUpgrade.NewBuildRate or 0) > 10) or (tUpgrade.NewMaxRadius or tUpgrade.NewRateOfFire) then
                if tUpgrade.BuildCostMass < iLowestMassCost and not (tUpgrade.Prerequisite) and not (tRestrictedEnhancements[sUpgrade]) then
                    sLowestUpgrade = sUpgrade
                    iLowestMassCost = tUpgrade.BuildCostMass
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Have a new preferred upgrade ' .. sUpgrade .. '; iLowestMassCost=' .. iLowestMassCost)
                    end
                end
            end
        end
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Finished considering the cheapest gun improving upgrade, sLowestUpgrade=' .. (sLowestUpgrade or 'nil'))
        end
        if sLowestUpgrade then
            oACU[reftPreferredUpgrades] = { sLowestUpgrade }
            --Further backup - sometimes (e.g. cmapaign) RAS might be available but gun isnt
        elseif oBP.Enhancements['ResourceAllocation'] and not (tRestrictedEnhancements['ResourceAllocation']) then
            oACU[reftPreferredUpgrades] = { 'ResourceAllocation' }
        end
    end
    --Campaign specific - add RAS upgrade if we only have 1 upgrade
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Campaign specific - considering adding RAS upgrade; is preferred upgrades nil=' .. tostring(oACU[reftPreferredUpgrades]))
        if oACU[reftPreferredUpgrades] then
            LOG(sFunctionRef .. ': Upgrade size=' .. table.getn(oACU[reftPreferredUpgrades]))
        end
    end
    if oACU[refiUpgradeCount] > 0 and oACU[reftPreferredUpgrades] and table.getn(oACU[reftPreferredUpgrades]) <= 2 and (EntityCategoryContains(categories.AEON, oACU.UnitId) or table.getn(oACU[reftPreferredUpgrades]) <= 1) and oBP.Enhancements['ResourceAllocation'] and not (tRestrictedEnhancements['ResourceAllocation']) then
        table.insert(oACU[reftPreferredUpgrades], 'ResourceAllocation')
    end

    --Remove any upgrades that we already have
    if M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) == false then
        local tObsoletePreRequisites = {}
        local bCheckForObsoletePrerequisites
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Considering upgrades already have for oACU ' .. oACU.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oACU) .. ' owned by ' .. oACU:GetAIBrain().Nickname .. '; Upgrade count=' .. (oACU[refiUpgradeCount] or 'nil'))
        end
        if oACU[refiUpgradeCount] > 0 then
            for iEntry, sEnhancement in oACU[reftPreferredUpgrades] do
                if oBP.Enhancements[sEnhancement].Prerequisite and oACU:HasEnhancement(sEnhancement) then
                    table.insert(tObsoletePreRequisites, oBP.Enhancements[sEnhancement].Prerequisite)
                    bCheckForObsoletePrerequisites = true
                end
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Considering if sEnhancement ' .. sEnhancement .. ' has prerequisite, BP Preq val=' .. (oBP.Enhancements[sEnhancement].Prerequisite or 'nil'))
                end
            end
        end
        local bUpgradeIsObsolete

        local iRevisedIndex = 1
        local iTableSize = table.getn(oACU[reftPreferredUpgrades])

        --First check if we have any upgrades that have prerequiites, in which case we want to remove those prerequisites first
        for iOrigIndex = 1, iTableSize do
            if oACU[reftPreferredUpgrades][iOrigIndex] then
                if not (oACU:HasEnhancement(oACU[reftPreferredUpgrades][iOrigIndex])) and (not (oACU[M28UnitInfo.reftiTimeOfLastEnhancementComplete][reftPreferredUpgrades[iOrigIndex]]) or GetGameTimeSeconds() - (oACU[M28UnitInfo.reftiTimeOfLastEnhancementComplete][reftPreferredUpgrades[iOrigIndex]] or -1) >= 0.5) then
                    --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                    --We dont have this enhancement; however we might have one that supercedes this, in which case also want to remove it
                    bUpgradeIsObsolete = false
                    if bCheckForObsoletePrerequisites then
                        for iEntry, sPreRequisite in tObsoletePreRequisites do
                            if sPreRequisite == oACU[reftPreferredUpgrades][iOrigIndex] then
                                bUpgradeIsObsolete = true
                                break
                            end
                        end
                    end
                    if bUpgradeIsObsolete then
                        oACU[reftPreferredUpgrades][iOrigIndex] = nil;
                    else

                        --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                        if (iOrigIndex ~= iRevisedIndex) then
                            oACU[reftPreferredUpgrades][iRevisedIndex] = oACU[reftPreferredUpgrades][iOrigIndex];
                            oACU[reftPreferredUpgrades][iOrigIndex] = nil;
                        end
                        iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                    end
                else
                    oACU[reftPreferredUpgrades][iOrigIndex] = nil;
                end
            end
        end

    end
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': End of code, oACU[reftPreferredUpgrades]=' .. repru(oACU[reftPreferredUpgrades]))
    end
end

function GetACUUpgradeWanted(oACU, bWantToDoTeleSnipe)
    --Returns nil if cantr find anything
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetACUUpgradeWanted'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local sUpgradeWanted

    --If we were to get an upgrade, what upgrade would it be?
    if not(oACU[reftPreferredUpgrades]) or (oACU[reftPreferredUpgrades][1] and oACU:HasEnhancement(oACU[reftPreferredUpgrades][1])) or bWantToDoTeleSnipe then
        GetUpgradePathForACU(oACU, bWantToDoTeleSnipe)
    end
    local aiBrain = oACU:GetAIBrain()
    local iTeam = aiBrain.M28Team
    if bDebugMessages == true then LOG(sFunctionRef..': oACU[reftPreferredUpgrades]='..repru(oACU[reftPreferredUpgrades])..'; Have low power='..tostring(M28Conditions.HaveLowPower(iTeam))) end
    if M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) == false and not(M28Conditions.HaveLowPower(iTeam)) then

        local sPotentialUpgrade = oACU[reftPreferredUpgrades][1]
        if sPotentialUpgrade then
            if bWantToDoTeleSnipe then sUpgradeWanted = sPotentialUpgrade
            else
                local tEnhancement = oACU:GetBlueprint().Enhancements[sPotentialUpgrade]
                --Do we have the eco to support the upgrade?
                if bDebugMessages == true then LOG(sFunctionRef..': Considering sPotentialUpgrade='..sPotentialUpgrade..'; for ACU '..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' for brain '..oACU:GetAIBrain().Nickname..'; tEnhancement='..reprs(tEnhancement)) end
                local iBuildRate = oACU:GetBlueprint().Economy.BuildRate
                if aiBrain.CheatEnabled then iBuildRate = iBuildRate * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier] end
                local iMassCostPerTick = 0.1 * tEnhancement.BuildCostMass / (tEnhancement.BuildTime / iBuildRate)
                local iEnergyCostPerTick = 0.1 * tEnhancement.BuildCostEnergy / (tEnhancement.BuildTime / iBuildRate)
                --Do we have enough gross energy?
                local iActiveACUUpgrades = 0
                local iResourceFactor
                if aiBrain[M28Map.refbCanPathToEnemyBaseWithLand] then
                    iResourceFactor = 1
                elseif aiBrain[M28Map.refbCanPathToEnemyBaseWithAmphibious] then
                    iResourceFactor = 2
                else
                    iResourceFactor = 4 --Cant path to enemy except with air
                end
                if oACU[refiUpgradeCount] >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 2 then iResourceFactor = iResourceFactor * 1.3
                elseif oACU[refiUpgradeCount] == 0 and GetGameTimeSeconds() >= 600 then iResourceFactor = iResourceFactor * 0.5
                end
                if M28Map.bIsCampaignMap and GetGameTimeSeconds() >= 480 then
                    iResourceFactor = iResourceFactor * 0.5
                    if GetGameTimeSeconds() >= 1200 then
                        iResourceFactor = iResourceFactor * 0.5
                        if (tEnhancement.ProductionPerSecondMass or 0) > 0 and (tEnhancement.ProductionPerSecondEnergy or 0) > 0 and GetGameTimeSeconds() >= 1800 then iResourceFactor = iResourceFactor * 0.2 end --Campaign - even if have really poor eco want to get RAS upgrade
                    end
                end
                if oACU[refbStartedUnderwater] and (tEnhancement.ProductionPerSecondEnergy or 0) > 20 then iResourceFactor = 0.5 end
                local iDistToEnemyBase
                local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oACU:GetPosition())
                if iPlateauOrZero == 0 then
                    iDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam][M28Map.reftClosestEnemyBase])
                else
                    iDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.reftClosestEnemyBase])
                end
                if iDistToEnemyBase >= 400 then iResourceFactor = iResourceFactor * 1.5 end
                if oACU[refiUpgradeCount] > 0 then
                    if oACU[refiUpgradeCount] >= 2 and M28Conditions.HaveLowMass(aiBrain) then iResourceFactor = iResourceFactor * 2
                    else iResourceFactor = iResourceFactor * 1.25
                    end
                end
                if M28Overseer.bNoRushActive and M28Overseer.iNoRushTimer - GetGameTimeSeconds() > 120 then
                    if M28Conditions.HaveLowMass(aiBrain) or M28Conditions.HaveLowPower(aiBrain.M28Team) then
                        iResourceFactor = iResourceFactor * 2.5
                    else iResourceFactor = iResourceFactor * 1.75
                    end
                end
                if aiBrain[M28Factory.refiHighestFactoryBuildCount] >= 20 + 10 * oACU[refiUpgradeCount] then

                    if M28Map.bIsCampaignMap then
                        iResourceFactor = iResourceFactor * 0.7
                    else
                        iResourceFactor = iResourceFactor * 0.8
                    end
                    if aiBrain[M28Factory.refiHighestFactoryBuildCount] >= 30 + 15 * oACU[refiUpgradeCount] then
                        if M28Map.bIsCampaignMap then
                            iResourceFactor = iResourceFactor * 0.7
                            if aiBrain[M28Factory.refiHighestFactoryBuildCount] >= 60 then iResourceFactor = iResourceFactor * 0.75 end
                        else
                            iResourceFactor = iResourceFactor * 0.85
                        end

                    end
                end

                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingACUs]) == false then iActiveACUUpgrades = table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingACUs]) end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have enough resources to get this upgrade, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; Net mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]..'; Other active upgrades='..iActiveACUUpgrades..'; Is safe to get upgrade='..tostring(M28Conditions.SafeToUpgradeUnit(oACU))..'; iEnergyCostPerTick='..iEnergyCostPerTick..'; iMassCostPerTick='..iMassCostPerTick..'; iResourceFactor'..iResourceFactor..'; iDistToEnemyBase='..iDistToEnemyBase..'; oACU[refiUpgradeCount]='..oACU[refiUpgradeCount]..'; aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]='..tostring(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand])..'; Have low mass='..tostring(M28Conditions.HaveLowMass(aiBrain))..'; iResourceFactor='..iResourceFactor..'; aiBrain[M28Factory.refiHighestFactoryBuildCount]='..aiBrain[M28Factory.refiHighestFactoryBuildCount]) end
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= (45 * iActiveACUUpgrades * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] + iEnergyCostPerTick * 1.35) * iResourceFactor then
                    --Do we have enough gross mass?
                    if bDebugMessages == true then LOG(sFunctionRef..': Have enough gross energy, do we have enough gross mass?') end
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= (iActiveACUUpgrades * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] + 2.5 * iMassCostPerTick * 2) * iResourceFactor then
                        --Do we have enough net energy?
                        if bDebugMessages == true then LOG(sFunctionRef..': Have enough gross mass, do we have enough net energy?') end
                        if (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= (iActiveACUUpgrades * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] + 100 * iEnergyCostPerTick * 2) * iResourceFactor and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 5 * iResourceFactor) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= iEnergyCostPerTick * math.min(2.5, iResourceFactor * 0.4) then
                            --Do we have enoguh net mass?
                            if bDebugMessages == true then LOG(sFunctionRef..': Have enough net energy, do we have enough net mass or so much gross mass that we can still proceed?') end
                            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= (iActiveACUUpgrades * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] + 3.5 * iMassCostPerTick * 3) * iResourceFactor or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= iMassCostPerTick * math.min(2.5, iResourceFactor * 0.4) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= math.min(3, iResourceFactor) * tEnhancement.BuildCostMass * 0.5 or (M28Map.bIsCampaignMap and aiBrain[M28Factory.refiHighestFactoryBuildCount] >= 30) then
                                --Require T3 mex if 3rd+ upgrade and the upgrade has a significant cost
                                if oACU[refiUpgradeCount] < 2 or tEnhancement.BuildCostMass <= 800 or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryT3Mex) > 1 then
                                    sUpgradeWanted = sPotentialUpgrade
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef..': End of code, sUpgradeWanted='..(sUpgradeWanted or 'nil'))
        if sUpgradeWanted then
            LOG(sFunctionRef..': Does ACU have this enhancement='..tostring(oACU:HasEnhancement(sUpgradeWanted)))
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return sUpgradeWanted
end

function DoesACUWantToRun(iPlateau, iLandZone, tLZData, tLZTeamData, oACU)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DoesACUWantToRun'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bWantToRun = false
    --Dont run if in core base unless low health or close to the rally point
    if bDebugMessages == true then LOG(sFunctionRef..': Is ACU in core base='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])..' iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; oACU='..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..'; M28Team.tTeamData[aiBrain.M28Team][M28Team.refbDangerousForACUs]='..tostring(M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refbDangerousForACUs] or false)..'; Does enemy have sub='..tostring(M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refbEnemyHasSub] or false)..'; Dist to midpoint='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZData[M28Map.subrefMidpoint])) end
    if tLZTeamData[M28Map.subrefLZbCoreBase] and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.2 and (oACU[refbUseACUAggressively] or (M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.4 and (oACU[refiUpgradeCount] > 0 or not(M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refbEnemyHasUpgradedACU])) and (false and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.75 or M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= 70)) or M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= 15) then
        if bDebugMessages == true then LOG(sFunctionRef..': Are in core base with some health so dont want to run') end
    else

        local iACUThreat = (M28UnitInfo.GetCombatThreatRating({ oACU}, false) or 0)
        --Dont run if building T1 mex and almost done, assuming our health is ok
        if iACUThreat >= 400 and (oACU:IsUnitState('Building') or oACU:IsUnitState('Repairing')) and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= math.max(1500, iACUThreat * 1.5) and M28UnitInfo.IsUnitValid(oACU:GetFocusUnit()) and EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oACU:GetFocusUnit()) and oACU:GetFocusUnit():GetFractionComplete() >= 0.7 then
            --Dont run - might as well finish mex as a small chance we wont run for long, the mex might absorb some damage, and the mex may generate a small bit of mass before dying
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and complete construciton of mex') end
        else
            --Run if on low health or shield
            local bAgainstEnemyACUAndMightWin = false

            --If we are closer to enemy base then require a greater threat differential
            local iDistToFriendlyBase
            local iDistToEnemyBase
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftClosestFriendlyBase]) == false then
                iDistToFriendlyBase = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], oACU:GetPosition())
                iDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], oACU:GetPosition())
            else
                --May e.g. be underwater and not have a LZ
                iDistToFriendlyBase = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M28Map.PlayerStartPoints[oACU:GetAIBrain():GetArmyIndex()])
                iDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M28Map.GetPrimaryEnemyBaseLocation(oACU:GetAIBrain()))
            end
            local iPercentageToFriendlyBase = iDistToFriendlyBase / (iDistToFriendlyBase + iDistToEnemyBase)

            if tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 then
                local tEnemyACU = EntityCategoryFilterDown(categories.COMMAND, tLZTeamData[M28Map.subrefTEnemyUnits])
                if M28Utilities.IsTableEmpty(tEnemyACU) == false then
                    if table.getn(tEnemyACU) == 1 then
                        if (tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0) + iACUThreat > 1.05 * (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) then
                            --If we are closer to enemy base then require a greater threat differential
                            if iPercentageToFriendlyBase < 0.6 or tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] + iACUThreat > 1.25 * tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] then
                                --Dont do this if enemy has air to ground threat and we dont have >= this in MAA
                                if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] == 0 or tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] >= 0.25 * tLZTeamData[M28Map.refiEnemyAirToGroundThreat] then
                                    bAgainstEnemyACUAndMightWin = true
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iACUThreat='..(iACUThreat or 'nil')..'; LZ enemy combat total='..(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; bOneEnemyACUInSameLZ='..tostring(bAgainstEnemyACUAndMightWin or false)..'; tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]='..(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 'nil')..'; tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]='..(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 'nil')) end
            if (iACUThreat <= 500 or (iACUThreat <= 600 and (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 80)) and (not(bAgainstEnemyACUAndMightWin) or (oACU[refbUseACUAggressively] and (iACUThreat + (tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0) + 250 < (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)))) then
                if bDebugMessages == true then LOG(sFunctionRef..': ACU has low threat so want to run') end
                bWantToRun = true
            else
                local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oACU, true)
                if bDebugMessages == true then LOG(sFunctionRef..'; iCurSHield='..iCurShield..'; iMaxShield='..iMaxShield) end
                if iMaxShield > 0 and iCurShield <= (iMaxShield * 0.1) then
                    if bDebugMessages == true then LOG(sFunctionRef..': ACU shield is less than 10% so want to run') end
                    bWantToRun = true
                else
                    local iHealthPercent = M28UnitInfo.GetUnitHealthPercent(oACU)
                    local iPercentMod = 1
                    if oACU[refbUseACUAggressively] then iPercentMod = 0.5 end
                    if bDebugMessages == true then LOG(sFunctionRef..': iHealthPercent='..iHealthPercent) end
                    if (iHealthPercent <= 0.6 * iPercentMod or (iHealthPercent <= 0.75 * iPercentMod and (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 80)) and (not(bAgainstEnemyACUAndMightWin) or iHealthPercent <= 0.5 * iPercentMod) then
                        if bDebugMessages == true then LOG(sFunctionRef..': ACU is injured so want to run') end
                        bWantToRun = true
                    else
                        --Do we have a land zone?
                        if iLandZone > 0 then
                            local iEnemyAirToGroundNearbyThreat = tLZTeamData[M28Map.refiEnemyAirToGroundThreat]
                            local iFriendlyAAThreat = tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]
                            --If there are big enemy threats then run if we arent adjacnet to a core LZ
                            local bAdjacentToCoreLZ = false
                            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][oACU:GetAIBrain().M28Team]
                                    if tAdjLZTeamData[M28Map.subrefLZbCoreBase] then bAdjacentToCoreLZ = true end
                                    iEnemyAirToGroundNearbyThreat = iEnemyAirToGroundNearbyThreat + tAdjLZTeamData[M28Map.refiEnemyAirToGroundThreat]
                                    iFriendlyAAThreat = iFriendlyAAThreat + tAdjLZTeamData[M28Map.subrefLZThreatAllyMAA]
                                end
                            end

                            if M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refbDangerousForACUs] then
                                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': No adjacent land zones and dangerous for ACU so want to run') end
                                    bWantToRun = true
                                else
                                    if not(bAdjacentToCoreLZ) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Not adjacent to core LZ so want to run as it is dangerous for ACUs now') end
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        bWantToRun = true
                                    end
                                end

                            end
                            if not(bWantToRun) then
                                if bDebugMessages == true then LOG(sFunctionRef..': deciding if want to run from air, iEnemyAirToGroundNearbyThreat='..iEnemyAirToGroundNearbyThreat..'; iFriendlyAAThreat='..(iFriendlyAAThreat or 'nil')..'; iPercentageToFriendlyBase='..(iPercentageToFriendlyBase or 'nil')..'; iDistToFriendlyBase='..(iDistToFriendlyBase or 'nil')..'; Enemy team air to ground threat='..(M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refiEnemyAirToGroundThreat] or 'nil')..'; ACU health percent='..M28UnitInfo.GetUnitHealthPercent(oACU)) end
                                --If significant air to ground threat and not in adjacent to core base LZ then also run; however adjust if have nearby MAA
                                if (iEnemyAirToGroundNearbyThreat > (iFriendlyAAThreat or 0) * 2.5 or iEnemyAirToGroundNearbyThreat >= 1000) and not(bAdjacentToCoreLZ) and (iMaxShield == 0 or tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < tLZTeamData[M28Map.refiEnemyAirToGroundThreat] * 0.5) and (iEnemyAirToGroundNearbyThreat > 150 or not(oACU[refbUseACUAggressively])) and (iEnemyAirToGroundNearbyThreat >= 300 or M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refiEnemyAirToGroundThreat] >= 400 or iDistToFriendlyBase >= 300 or iPercentageToFriendlyBase > 0.5 or M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.75) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Significant air to ground threat so want to run, iFriendlyAAThreat='..(iFriendlyAAThreat or 0)) end
                                    bWantToRun = true
                                else
                                    local iEnemyNearbyThreat = (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                                    local iTeam = oACU:GetAIBrain().M28Team
                                    local iAllyNearbyThreat = math.max(0, (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0) - iACUThreat)
                                    local iAllyAdjacentZoneThreat = 0
                                    local iBestEnemyDFRange = (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0)
                                    local iMaxLRThreat = (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0)
                                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                        --First get best enemy nearby range

                                        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                            local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                            iBestEnemyDFRange = math.max(iBestEnemyDFRange, (tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0))
                                            if bDebugMessages == true then LOG(sFunctionRef..': Adding threat for iAdjLZ='..iAdjLZ..' with threat '..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal]..'; mobile DF='..(tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 'nil')..'; Mobile indirect='..(tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)..'; subrefiNearbyEnemyLongRangeThreat='..(tAdjLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 'nil')) end
                                            iEnemyNearbyThreat = iEnemyNearbyThreat + (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                                            iMaxLRThreat = math.max(iMaxLRThreat, (tAdjLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0))
                                            --Include adjacent enemies assuming ACU has enough health that they are likely to be able to arrive
                                            if iHealthPercent >= 0.65 and (iHealthPercent >= 0.8 or oACU[refbUseACUAggressively] or M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1) then
                                                iAllyAdjacentZoneThreat = iAllyAdjacentZoneThreat + ((tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0) + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)) * 0.9
                                            end

                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': iBestEnemyDFRange='..iBestEnemyDFRange..'; oACU[M28UnitInfo.refiDFRange]='..oACU[M28UnitInfo.refiDFRange]..'; iAllyNearbyThreat pre update for adj='..iAllyNearbyThreat..'; iAllyAdjacentZoneThreat='..iAllyAdjacentZoneThreat) end
                                        --Include ally threat if we arent outranged or our relatively near our base with a gun upgrade
                                        if (iBestEnemyDFRange <= oACU[M28UnitInfo.refiDFRange] and (oACU[refbUseACUAggressively] or M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1)) or (iPercentageToFriendlyBase <= 0.4 and iDistToFriendlyBase <= 275 and oACU[refiUpgradeCount] >= 1 and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.75)  then
                                            --Have nearby allies so can be more aggressive
                                            iAllyNearbyThreat = iAllyNearbyThreat + iAllyAdjacentZoneThreat
                                        end
                                    end
                                    iEnemyNearbyThreat = iEnemyNearbyThreat + iMaxLRThreat
                                    if bDebugMessages == true then LOG(sFunctionRef..': iEnemyNearbyThreat='..iEnemyNearbyThreat..'; iACUThreat='..iACUThreat..'; bAgainstEnemyACUAndMightWin='..tostring(bAgainstEnemyACUAndMightWin or false)..'; iPercentageToFriendlyBase='..iPercentageToFriendlyBase..'; bAdjacentToCoreLZ='..tostring(bAdjacentToCoreLZ)..'; iAllyNearbyThreat='..iAllyNearbyThreat..'; iMaxLRThreat='..iMaxLRThreat) end
                                    --Run if enemy has a really large threat (regardless of if we think we can beat it)
                                    if iEnemyNearbyThreat > math.min(math.max(iACUThreat * 2, iACUThreat * 0.75 + iAllyNearbyThreat), 4000 + 2000 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and (iEnemyNearbyThreat > math.max(iACUThreat * 3, iACUThreat + iAllyNearbyThreat) or ((not(bAgainstEnemyACUAndMightWin) and iPercentageToFriendlyBase >= 0.35 and not(bAdjacentToCoreLZ) and not(oACU[refbUseACUAggressively])))) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy has too large a threat so will run') end
                                        bWantToRun = true
                                    else
                                        --Run if we dont have enough threat to easily beat enemy threat in all adjacent LZs
                                        local iACUFactor = 0.5
                                        if bAgainstEnemyACUAndMightWin then iACUFactor = 1
                                        elseif bAdjacentToCoreLZ then iACUFactor = 0.9
                                        elseif iPercentageToFriendlyBase <= 0.4 then iACUFactor = 0.8
                                        elseif iPercentageToFriendlyBase <= 0.6 then
                                            if M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.9 then iACUFactor = 0.7
                                            else iACUFactor = 0.6
                                            end
                                        end
                                        --Increase ACU factor if we have gun and good health, and enemy lacks T3 land/high health units
                                        if M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.8 and oACU[refiUpgradeCount] >= 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] < 3 and  M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] < 3 and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] <= 1500 then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Guncom with decent health and enemy doesnt have T3 land or air or significant air to ground threat so increasing factor') end
                                            iACUFactor = iACUFactor * 1.1
                                            if iPercentageToFriendlyBase <= 0.45 then
                                                iACUFactor = iACUFactor * 1.1
                                            end
                                        end


                                        --NOTE: subrefLZTThreatAllyCombatTotal includes the ACU threat
                                        if not(oACU[refbUseACUAggressively]) and (iACUThreat * iACUFactor + iAllyNearbyThreat < iEnemyNearbyThreat) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': iACUThreat='..iACUThreat..'; iACUFactor='..iACUFactor..'; tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]='..(tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 'nil')..'; iEnemyNearbyThreat='..iEnemyNearbyThreat..'; Ally mobile DF total='..(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0)..'; iAllyNearbyThreat='..iAllyNearbyThreat) end
                                            bWantToRun = true
                                        else
                                            --If enemy has an upgrading or upgraded ACU relatively nearby and we dont have any upgrades then run - think we already ahve this covered in earlier step
                                            --[[local bEnemyHasNearbyUpgradedACU = false
                                            local iCurEnemyACUDist
                                            if oACU[refiUpgradeCount] == 0 and M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU] then
                                                local iClosestEnemyACU = 10000

                                                for iEnemyACU, oEnemyACU in M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs] do
                                                    iCurEnemyACUDist = M28Utilities.GetDistanceBetweenPositions(oEnemyACU:GetPosition(), oACU:GetPosition())
                                                    if iCurEnemyACUDist < iClosestEnemyACU then iClosestEnemyACU = iCurEnemyACUDist end
                                                end
                                                if iClosestEnemyACU <= 54 then bEnemyHasNearbyUpgradedACU = true end
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Checking if enemy has nearby guncom, ACU upgrade count='..oACU[refiUpgradeCount]..'; Enemy has upgraded ACU='..tostring(M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU])..'; iClosestEnemyACU='..(iClosestEnemyACU or 'nil')..'; bEnemyHasNearbyUpgradedACU='..tostring(bEnemyHasNearbyUpgradedACU)) end
                                            if bEnemyHasNearbyUpgradedACU then
                                                bWantToRun = true
                                            else--]]

                                            --If enemy units are between us and the closest friendly base then also want to run; also run if enemy has multiple T2+ PD as part of the enemy threat and we lack upgrades
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if should run from PD or if enemies closer to our base than we are, iEnemyNearbyThreat='..(iEnemyNearbyThreat or 'nil')..'; oACU[refbUseACUAggressively]='..tostring(oACU[refbUseACUAggressively] or false)..'; ACU upgrade count='..oACU[refiUpgradeCount]..'; tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] ='..(tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 'nil')) end
                                            if iEnemyNearbyThreat > 800 or (iEnemyNearbyThreat > 400 and not(oACU[refbUseACUAggressively])) then
                                                --Enemy PD check - if enemy has T2+/long range PD and we lack 3 upgrades, then make it more likely we run
                                                local iAggressiveFactor = 1
                                                if oACU[refbUseACUAggressively] and iPercentageToFriendlyBase >= 0.3 then iAggressiveFactor = 1.5 end
                                                if iEnemyNearbyThreat >= 1200 and oACU[refiUpgradeCount] < 3 and iEnemyNearbyThreat / iAggressiveFactor > (iACUThreat * iACUFactor + iAllyNearbyThreat) then
                                                    local iBestEnemyThreatRange = 0
                                                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                                                        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                                                            iBestEnemyThreatRange = math.max(iBestEnemyThreatRange, iRange)
                                                        end
                                                    end
                                                    if iBestEnemyThreatRange < 40 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                                        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                                            local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                                            if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
                                                                for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                                                                    iBestEnemyThreatRange = math.max(iBestEnemyThreatRange, iRange)
                                                                end
                                                            end
                                                        end
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Checking highest enemy PD range nearby, iBestEnemyThreatRange='..(iBestEnemyThreatRange or 'nil')) end
                                                    if iBestEnemyThreatRange >= 40 then
                                                        bWantToRun = true
                                                    end
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if want to run due to PD, bWantToRun='..tostring(bWantToRun)..'; iAggressiveFactor='..iAggressiveFactor) end
                                                if not(bWantToRun) then
                                                    local iACUDistToClosestFriendlyBase = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])
                                                    local tEnemyCombatUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandCombat,  tLZTeamData[M28Map.subrefTEnemyUnits])
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will check if we have enemy units in this zone that are closer to our base than our ACU and which are in range of our ACU (i.e. suggesting enemy is trying to ambush/kill our ACU - dont want to just run if they are closer to base as zone might be large and ACU could e.g. be approaching the units from another direction so we want acu to attack them), is table of enemy combat units empty='..tostring(M28Utilities.IsTableEmpty(tEnemyCombatUnits))) end
                                                    if M28Utilities.IsTableEmpty(tEnemyCombatUnits) == false then
                                                        for iUnit, oUnit in tEnemyCombatUnits do
                                                            if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase]) < iACUDistToClosestFriendlyBase then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': iEnemyNearbyThreat='..iEnemyNearbyThreat..'; iACUDistToClosestFriendlyBase='..iACUDistToClosestFriendlyBase..'; Nearest enemy threat='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Dist of that to our base='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZTeamData[M28Map.reftClosestFriendlyBase])) end
                                                                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition()) <= oACU[M28UnitInfo.refiDFRange] - 3 then
                                                                    bWantToRun = true
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        else
                            --No land zone - if we have no order then return to base
                            if oACU[M28Orders.refiOrderCount] == 0 then
                                bWantToRun = true
                            end
                        end
                    end
                end
            end
        end
    end
    if bWantToRun then
        --Record the zone that we are in, and that we were traveling to, as running from
        if not(oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iLandZone]) then
            if not(oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau]) then
                if not(oACU[reftiTimeLastRanFromZoneByPlateau]) then oACU[reftiTimeLastRanFromZoneByPlateau] = {} end
                oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau] = {}
            end
        end
        oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iLandZone] = GetGameTimeSeconds()
        if oACU[refiTimeLastToldToMoveToZone] and GetGameTimeSeconds() - oACU[refiTimeLastToldToMoveToZone] <= 10 then
            local iTargetPlateau = oACU[refiLastPlateauAndZoneToMoveTo][1]
            local iTargetLZ = oACU[refiLastPlateauAndZoneToMoveTo][2]
            if not(oACU[reftiTimeLastRanFromZoneByPlateau][iTargetPlateau][iTargetLZ]) then
                if not(oACU[reftiTimeLastRanFromZoneByPlateau][iTargetPlateau]) then
                    if not(oACU[reftiTimeLastRanFromZoneByPlateau]) then oACU[reftiTimeLastRanFromZoneByPlateau] = {} end
                    oACU[reftiTimeLastRanFromZoneByPlateau][iTargetPlateau] = {}
                end
            end
            oACU[reftiTimeLastRanFromZoneByPlateau][iTargetPlateau][iTargetLZ] = GetGameTimeSeconds()
        end

    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bWantToRun='..tostring(bWantToRun)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bWantToRun
end

function DoesACUWantToReturnToCoreBase(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)
    --Returns true if want ACU to return to the core base - to be used when ACU is facing critical threat that could kill it vs the normal 'does acu want to run' where ACU might return to an island sub-base
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DoesACUWantToReturnToCoreBase'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iTeam = oACU:GetAIBrain().M28Team

    --If big threat or ACU very low health then retreat
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for ACU '..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' owned by '..oACU:GetAIBrain().Nickname..' on team '..iTeam..'; Dangerous for ACUs='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs])..'; ACU health percent='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; Air to ground threat='..tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat]) end
    if M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs] or M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.4 or tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] >= 2500 then
        if bDebugMessages == true then LOG(sFunctionRef..': Is dangerous for ACU or low health or large enemy air to ground threat so returning to base') end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    else
        --Run if enemy has an ACU with upgrades or is upgrading and we have no upgrades
        if not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU] and oACU[refiUpgradeCount] == 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': Enemy ACU has upgrade and we dont so return to base unless are in a core expansion and enemy ACU is far away, tLZOrWZTeamData[M28Map.subrefLZCoreExpansion]='..tostring(tLZOrWZTeamData[M28Map.subrefLZCoreExpansion] or false)..'; Enemies in adj zone='..tostring(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
            if tLZOrWZTeamData[M28Map.subrefLZCoreExpansion] and tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and GetGameTimeSeconds() <= 840 then
                local iClosestEnemyACU = 10000
                local iCurDist
                for iEnemyACU, oEnemyACU in M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs] do
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oEnemyACU:GetPosition())
                    if iCurDist < iClosestEnemyACU then iClosestEnemyACU = iCurDist end
                end
                if iClosestEnemyACU <= 175 then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                else
                    --Do nothing
                end
            else
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            end
        end

        --Run if we are underwater or on a different island to our core base and enemy has subs
        local bWaterIsDangerous = M28Team.tTeamData[iTeam][M28Team.refbEnemyHasSub]
        if not(bWaterIsDangerous) then
            bWaterIsDangerous = not(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoEnemyTorpBombers]))
            if not(bWaterIsDangerous) then
                --If enemy has T3 air or T2 navy then treat water as dangerous for ACU
                if M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech] >= 2 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 then
                    bWaterIsDangerous = true
                elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 2 and M28Team.tAirSubteamData[oACU:GetAIBrain().M28AirSubteam][M28Team.refbFarBehindOnAir] then
                    bWaterIsDangerous = true
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bWaterIsDangerous='..tostring(bWaterIsDangerous)..'; Is ACU underwtaer='..tostring(M28UnitInfo.IsUnitUnderwater(oACU))) end
        if bWaterIsDangerous then
            --If ACU has 3+ upgrades and its movement target isn't more than 60% away from our base or 200 if higher, then dont run
            local bWantACUToRun = false
            if M28UnitInfo.IsUnitUnderwater(oACU) then
                bWantACUToRun = true
            else
                local iNearestBaseIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZOrWZTeamData[M28Map.reftClosestFriendlyBase])
                local iCurIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, oACU:GetPosition())
                if bDebugMessages == true then LOG(sFunctionRef..': iNearestBaseIsland='..(iNearestBaseIsland or 'nil')..'; iCurIsland='..(iCurIsland or 'nil')) end
                if not(iNearestBaseIsland == iCurIsland) then

                    bWantACUToRun = true
                end
            end
            if bWantACUToRun and oACU[refiUpgradeCount] >= 3 and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.95 then
                local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
                if bDebugMessages == true then LOG(sFunctionRef..': repru(tLZData[M28Map.subrefMidpoint])='..repru(tLZOrWZData[M28Map.subrefMidpoint])..'; iPlateau='..(iPlateauOrZero or 'nil')..'; iLandZone='..(iLandOrWaterZone or 'nil')..'Is ACU underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oACU))..'; tLastOrder='..reprs(tLastOrder)) end
                local iDistToBase
                --Get nearest base to us
                local tNearestFriendlyBase
                local tNearestEnemyBase
                if tLZOrWZTeamData[M28Map.reftClosestFriendlyBase] then
                    tNearestFriendlyBase = {tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][1], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][2], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][3]}
                    tNearestEnemyBase = {tLZOrWZTeamData[M28Map.reftClosestEnemyBase][1], tLZOrWZTeamData[M28Map.reftClosestEnemyBase][2], tLZOrWZTeamData[M28Map.reftClosestEnemyBase][3]}
                else
                    --Use our start position
                    local aiBrain = oACU:GetAIBrain()
                    local iStartPositionX, iStartPositionZ = aiBrain:GetArmyStartPos()
                    tNearestFriendlyBase = { iStartPositionX, GetTerrainHeight(iStartPositionX, iStartPositionZ), iStartPositionZ }
                    tNearestEnemyBase = aiBrain[M28Overseer.refoNearestEnemyBrain][M28Overseer.refoNearestEnemyBrain]
                end

                if tLastOrder and M28Utilities.IsTableEmpty(tLastOrder[M28Orders.subreftOrderPosition]) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': tNearestFriendlyBase='..repru(tNearestFriendlyBase)..'; tLastOrder[M28Orders.subreftOrderPosition]='..repru(tLastOrder[M28Orders.subreftOrderPosition])) end
                    iDistToBase = M28Utilities.GetDistanceBetweenPositions(tNearestFriendlyBase, tLastOrder[M28Orders.subreftOrderPosition])
                else
                    iDistToBase = M28Utilities.GetDistanceBetweenPositions(tNearestFriendlyBase, oACU:GetPosition())
                end
                if iDistToBase <= math.max(250, M28Utilities.GetDistanceBetweenPositions(tNearestEnemyBase, tNearestFriendlyBase) * 0.5) then
                    bWantACUToRun = false
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return bWantACUToRun
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GiveOverchargeOrderIfRelevant(tLZData, tLZTeamData, oACU, iPlateauOrZero, iLandOrWaterZone)
    --Are there enemies in this LZ or adjacent, and do we have the energy to overcharge?
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GiveOverchargeOrderIfRelevant'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; DO we have enemies in this or adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ])..'; Can we use overcharge='..tostring(M28Conditions.CanUnitUseOvercharge(oACU:GetAIBrain(), oACU))..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')) end

    if iPlateauOrZero > 0 and ((tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) and M28Conditions.CanUnitUseOvercharge(oACU:GetAIBrain(), oACU, tLZTeamData)) then
        --Dont overcharge if have teleport as can affect targeting and delay the return jump
        if not(oACU[refbACUHasTeleport]) then
            local bDoesACUWantToRun = DoesACUWantToRun(iPlateauOrZero, iLandOrWaterZone, tLZData, tLZTeamData, oACU)
            local oUnitToOvercharge = M28Micro.GetOverchargeTarget(tLZData, oACU:GetAIBrain(), oACU, bDoesACUWantToRun)
            if bDebugMessages == true then LOG(sFunctionRef..': Do we have a valid OC target='..tostring(M28UnitInfo.IsUnitValid(oUnitToOvercharge))) end
            if oUnitToOvercharge then
                M28Orders.IssueTrackedOvercharge(oACU, oUnitToOvercharge, false, 'OC', true)
                if bDebugMessages == true then LOG(sFunctionRef..': Have just told ACU '..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' owned by '..oACU:GetAIBrain().Nickname..' to overcharge '..oUnitToOvercharge.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToOvercharge)) end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function AttackNearestEnemyWithACU(iPlateau, iLandZone, tLZData, tLZTeamData, oACU, iOptionalDistThresholdOverride)
    --Attack move to the nearest enemy if we arent in range of it or retreat if we are in range of it
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AttackNearestEnemyWithACU'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local oEnemyToTarget
    local iCurDist

    local tUnitsToTarget
    local aiBrain = oACU:GetAIBrain()
    local iTeam = aiBrain.M28Team
    local iDistThreshold
    if iOptionalDistThresholdOverride then iDistThreshold = iOptionalDistThresholdOverride
    else
        if oACU[refiUpgradeCount] > 0 then iDistThreshold = 70
        else iDistThreshold = 60
        end
    end

    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
        tUnitsToTarget = tLZTeamData[M28Map.reftoNearestDFEnemies]
        iDistThreshold = iDistThreshold + 10
    elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
        tUnitsToTarget = tLZTeamData[M28Map.subrefTEnemyUnits]
        iDistThreshold = iDistThreshold + 10
    else
        --Search adjacent land zones for enemy units if none in this zone, and consider if they are within 60 of ACU position
        tUnitsToTarget = {}
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    for iUnit, oUnit in tAdjLZTeamData[M28Map.subrefTEnemyUnits] do
                        if M28UnitInfo.IsUnitValid(oUnit) and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition()) <= iDistThreshold then
                            table.insert(tUnitsToTarget, oUnit)
                        end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tUnitsToTarget) then
            tUnitsToTarget = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure, oACU:GetPosition(), iDistThreshold, 'Enemy')
        end
    end

    local iClosestDist = iDistThreshold + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Is table of units to target empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToTarget))..'; Is tLZTeamData[M28Map.reftoNearestDFEnemies] empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]))..'; iClosestDist='..iClosestDist) end
    if M28Utilities.IsTableEmpty(tUnitsToTarget) == false then
        local sPathing = M28Map.refPathingTypeAmphibious
        local iUnitPlateau, iUnitZone
        local bUnitInFurtherAwayZoneWeRanFrom
        local iStartPlateau, iStartZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tLZTeamData[M28Map.reftClosestFriendlyBase])
        local iACUZoneTravelDistToBase
        if iStartPlateau > 0 and iStartZone > 0 then iACUZoneTravelDistToBase = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iStartZone) end
        local iUnitInZoneRanFromDistThresholdIfOutrange = oACU[M28UnitInfo.refiDFRange] + 7
        local iUnitInZoneRanFromDistThresholdIfDontOutrange = oACU[M28UnitInfo.refiDFRange] + 2
        local iRanFromDistThreshold
        for iUnit, oUnit in tUnitsToTarget do
            if M28UnitInfo.IsUnitValid(oUnit) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                --Is unit in a zone that we have recently run from and that zone is further from our base than our current position?
                iUnitPlateau, iUnitZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                bUnitInFurtherAwayZoneWeRanFrom = false
                if iUnitPlateau > 0 and iUnitZone > 0 and (oACU[reftiTimeLastRanFromZoneByPlateau][iUnitPlateau][iUnitZone] and GetGameTimeSeconds() - oACU[reftiTimeLastRanFromZoneByPlateau][iUnitPlateau][iUnitZone] < 30) or (oACU[refiLastPlateauAndZoneToAttackUnitIn][2] == iUnitZone and oACU[refiLastPlateauAndZoneToAttackUnitIn][1] == iUnitPlateau and GetGameTimeSeconds() - (oACU[refiTimeLastToldToAttackUnitInOtherZone] or -100) < 30) then
                    --Unit in zone we ran from, dont want to attack it unless zone is closer to our base than our current zone, or enemy is close
                    if iACUZoneTravelDistToBase and not(tLZTeamData[M28Map.subrefLZbCoreBase]) then
                        if oUnit[M28UnitInfo.refiCombatRange] >= oACU[M28UnitInfo.refiDFRange] then
                            iRanFromDistThreshold = iUnitInZoneRanFromDistThresholdIfDontOutrange
                        else
                            iRanFromDistThreshold = iUnitInZoneRanFromDistThresholdIfOutrange
                        end

                        if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition()) >= iRanFromDistThreshold and M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iUnitZone) > iACUZoneTravelDistToBase then
                            bUnitInFurtherAwayZoneWeRanFrom = true
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..M28Utilities.GetTravelDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition(), sPathing)..'; bUnitInFurtherAwayZoneWeRanFrom='..tostring(bUnitInFurtherAwayZoneWeRanFrom)..'; iUnitZone='..(iUnitZone or 'nil')..'; refiLastPlateauAndZoneToAttackUnitIn='..reprs(oACU[refiLastPlateauAndZoneToAttackUnitIn])..'; refiTimeLastToldToAttackUnitInOtherZone='..reprs(oACU[refiTimeLastToldToAttackUnitInOtherZone])) end
                if not(bUnitInFurtherAwayZoneWeRanFrom) then
                    --iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition())
                    iCurDist = M28Utilities.GetTravelDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition(), sPathing)
                    if iCurDist and iCurDist < iClosestDist then
                        iClosestDist = iCurDist
                        oEnemyToTarget = oUnit
                    end
                end
            end
        end
        if oEnemyToTarget then
            local iUnitPlateau, iUnitZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oEnemyToTarget:GetPosition())
            if iUnitZone > 0 then
                if not(oACU[refiLastPlateauAndZoneToAttackUnitIn]) then oACU[refiLastPlateauAndZoneToAttackUnitIn] = {} end
                oACU[refiTimeLastToldToAttackUnitInOtherZone] = GetGameTimeSeconds()
                oACU[refiLastPlateauAndZoneToAttackUnitIn] = {iUnitPlateau, iUnitZone}
            end
            if oACU[M28UnitInfo.refbLastShotBlocked] then
                --Shot blocked, but we must think we can win the fight or we would be running, so move towards enemy
                M28Orders.IssueTrackedMove(oACU, oEnemyToTarget:GetPosition(), 5, false, 'ACUBl', false)
            else
                local iDistToBeInRange = 1.5
                local iEnemyHighestDFInThisLZ = 0
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) == false then
                    for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] do
                        if iThreat >= 20 then
                            iEnemyHighestDFInThisLZ = math.max(iEnemyHighestDFInThisLZ, iRange)
                        end
                    end
                end

                if oACU[M28UnitInfo.refiDFRange] <= iEnemyHighestDFInThisLZ then iDistToBeInRange = 2.5
                elseif oACU[M28UnitInfo.refiDFRange] - 6 >= iEnemyHighestDFInThisLZ then
                    --If nearest enemy unit isnt facing us then increase dist to be in range
                    local iAngleDif = M28Utilities.GetAngleDifference(M28UnitInfo.GetUnitFacingAngle(oEnemyToTarget), M28Utilities.GetAngleFromAToB(oEnemyToTarget:GetPosition(), oACU:GetPosition()))
                    if iAngleDif >= 55 then
                        iDistToBeInRange = 2.5
                    elseif iAngleDif <= 10 and oEnemyToTarget:IsUnitState('Moving') then
                        iDistToBeInRange = 0.25
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iAngleDif='..iAngleDif..'; iDistToBeInRange='..iDistToBeInRange) end
                end
                local iStraightLineDist = M28Utilities.GetDistanceBetweenPositions(oEnemyToTarget:GetPosition(), oACU:GetPosition())
                if bDebugMessages == true then LOG(sFunctionRef..': oEnemyToTarget='..oEnemyToTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToTarget)..'; iClosestDist='..iClosestDist..'; iDistToBeInRange='..iDistToBeInRange..'; ACU DF range='..(oACU[M28UnitInfo.refiDFRange] or 0)..'; ACU position='..repru(oACU:GetPosition())..'; Enemy unit to target='..repru(oEnemyToTarget:GetPosition())..'; Dist betweeh tnem straight line='..M28Utilities.GetDistanceBetweenPositions(oEnemyToTarget:GetPosition(), oACU:GetPosition())..'; ACU health percent='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; Enemy combat total='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]) end
                if iStraightLineDist + iDistToBeInRange <= oACU[M28UnitInfo.refiDFRange] and (M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.75 or tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 165) then
                    --Retreat temporarily - if aren't in a core zone then retreat to rally point
                    local tRallyPoint
                    if tLZTeamData[M28Map.subrefLZbCoreBase] then
                        --Retreat from nearest enemy
                        local iAngleFromEnemyToACU = M28Utilities.GetAngleFromAToB(oEnemyToTarget:GetPosition(), oACU:GetPosition())
                        tRallyPoint = M28Utilities.MoveInDirection(oACU:GetPosition(), iAngleFromEnemyToACU, 6, true, true, M28Map.bIsCampaignMap)
                        --Check this is in the same plateau, otherwise move it
                        local iRallyPlateau = NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, tRallyPoint)
                        if iRallyPlateau == iPlateau then
                            --Do nothing
                        else
                            local bHavePlateauInSameArea = false
                            --Search for position in the same plateau
                            for iAngleAdjust = -20, 20, 20 do
                                for iDist = 7, 28, 7 do
                                    tRallyPoint = M28Utilities.MoveInDirection(oACU:GetPosition(), iAngleAdjust + iAngleFromEnemyToACU, 6, true, true, M28Map.bIsCampaignMap)
                                    iRallyPlateau = NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tRallyPoint)
                                    if iRallyPlateau == iPlateau then
                                        bHavePlateauInSameArea = true
                                        break
                                    end
                                end
                                if bHavePlateauInSameArea then break end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Are in core zone so will move away from nearest enemy, tRallyPoint='..repru(tRallyPoint)) end
                    else
                        tRallyPoint = M28Land.GetNearestLandRallyPoint(tLZData, oACU:GetAIBrain().M28Team, iPlateau, iLandZone, 2, true)
                    end
                    M28Orders.IssueTrackedMove(oACU, tRallyPoint, 6, false, 'ACUKit', false)
                else
                    --Attack-move towards enemy
                    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Will attack-move to enemy target unless have active micro, oEnemyToTarget='..oEnemyToTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToTarget)..'; refbSpecialMicroActive='..tostring(oACU[M28UnitInfo.refbSpecialMicroActive] or false)) end
                    M28Orders.IssueTrackedAggressiveMove(oACU, oEnemyToTarget:GetPosition(), 5, false, 'ACUAM', false)
                end
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

    if oEnemyToTarget then return true else return false end
end

function ConsiderBuildingMex(tLZOrWZData, tLZOrWZTeamData, oACU, iOptionalMaxDistanceFromBuildRangeToConsider)
    --Do we have unclaimed mexes in the LZ? If so then build a mex on them.  However first check we dont alreayd have engineers trying to do this. also exception if we are overflowing mass and are in a core base

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderBuildingMex'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain = oACU:GetAIBrain()

    if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and aiBrain:GetEconomyStoredRatio('MASS') >= 0.9 and aiBrain:GetEconomyStored('MASS') >= 100 then
        if bDebugMessages == true then LOG(sFunctionRef..': Mass overflow scenario - dont want to build mex, as would rather get factory or assist something building') end
    else
        if bDebugMessages == true then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oACU:GetPosition())
            LOG(sFunctionRef..': Do we have any unbuilt locations for this LZ, iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..' - is table empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]))..'; Is table of part built mexes empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes])))
        end
        local tPotentialLocations = {}
        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) == false then
            for iEntry, tLocation in tLZOrWZData[M28Map.subrefMexUnbuiltLocations]  do
                table.insert(tPotentialLocations, tLocation)
            end
        end
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
            for iEntry, oMex in tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes] do
                if bDebugMessages == true then LOG(sFunctionRef..': Adding part build mex at position '..repru(oMex:GetPosition())..' to list of potential locations') end
                table.insert(tPotentialLocations, oMex:GetPosition())
            end
        end
        if M28Utilities.IsTableEmpty(tPotentialLocations) == false then
            --Check how close the mexes are - e.g. if calling this for higher priority orders we only want to consider mexes near to our build range
            local bHaveMexesWithinMaxDistanceToConsider = false
            local bHaveMexWithinACUBuildRange = false
            local iSearchRange
            local iACUBuildRange = oACU:GetBlueprint().Economy.MaxBuildDistance
            if iOptionalMaxDistanceFromBuildRangeToConsider then
                iSearchRange = iACUBuildRange + iOptionalMaxDistanceFromBuildRangeToConsider
            else
                iSearchRange = 60
            end
            if not(iOptionalMaxDistanceFromBuildRangeToConsider) then bHaveMexesWithinMaxDistanceToConsider = true
            else
                for iEntry, tLocation in tPotentialLocations do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering tLocation='..repru(tLocation)..'; iSearchRange='..iSearchRange..'; Distance to ACU='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLocation)) end
                    if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLocation) <= iSearchRange then
                        bHaveMexesWithinMaxDistanceToConsider = true
                        break
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': TIme='..GetGameTimeSeconds()..'; bHaveMexesWithinMaxDistanceToConsider='..tostring(bHaveMexesWithinMaxDistanceToConsider)..'; iSearchRange='..iSearchRange..'; iOptionalMaxDistanceFromBuildRangeToConsider='..(iOptionalMaxDistanceFromBuildRangeToConsider or 'nil')) end
            if bHaveMexesWithinMaxDistanceToConsider then
                for iEntry, tLocation in tPotentialLocations do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering location '..repru(tLocation)..'; Dist to ACU='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLocation)..'; iACUBuildRange='..iACUBuildRange) end
                    if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLocation) <= iACUBuildRange then
                        bHaveMexWithinACUBuildRange = true
                        break
                    end
                end
                if bHaveMexWithinACUBuildRange then iSearchRange = iACUBuildRange end

                local bHaveEngineersAssignedAlready = false
                local tEngisInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])

                if M28Utilities.IsTableEmpty(tEngisInLZ) == false then
                    for iEngi, oEngi in tEngisInLZ do
                        if oEngi[M28Engineer.refiAssignedAction] == M28Engineer.refActionBuildMex or oEngi[M28Engineer.refiAssignedAction] == M28Engineer.refActionCompletePartBuiltMex then
                            bHaveEngineersAssignedAlready = true
                            break
                        end
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': bHaveMexWithinACUBuildRange='..tostring(bHaveMexWithinACUBuildRange)..'; bHaveEngineersAssignedAlready='..tostring(bHaveEngineersAssignedAlready)) end
                if not(bHaveEngineersAssignedAlready) or bHaveMexWithinACUBuildRange then
                    ACUActionBuildMex(oACU:GetAIBrain(), oACU, iSearchRange)
                    local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
                    if bDebugMessages == true then LOG(sFunctionRef..': Have tried telling ACU to build mex, tLastOrder='..reprs(tLastOrder)) end
                    if tLastOrder and (tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueRepair) then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return true
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, did not give build mex order') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function ConsiderNearbyReclaimForACUOrEngineer(iPlateau, iLandZone, tLZData, tLZTeamData, oEngineer, bOnlyConsiderIfInBuildRange, iIndividualReclaimThresholdOverride)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderNearbyReclaimForACUOrEngineer'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iTotalReclaimWanted
    local iIndividualReclaimThreshold
    local bGetEnergy = false
    if bOnlyConsiderIfInBuildRange then
        if (oEngineer[refiUpgradeCount] or 0) > 0 and not(oEngineer:HasEnhancement('AdvancedEngineering')) then
            if (tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) or not(M28Conditions.TeamHasLowMass(oEngineer:GetAIBrain().M28Team)) then
                iTotalReclaimWanted = 200
                iIndividualReclaimThreshold = iIndividualReclaimThresholdOverride or 24
            else
                iTotalReclaimWanted = 80
                iIndividualReclaimThreshold = iIndividualReclaimThresholdOverride or 15
            end
            if oEngineer[refiUpgradeCount] >= 2 and (oEngineer[refiUpgradeCount] >= 3 or not(EntityCategoryContains(categories.AEON, oEngineer.UnitId))) then
                iTotalReclaimWanted = iTotalReclaimWanted * 1.5
            end
        else
            if M28Conditions.TeamHasLowMass(oEngineer:GetAIBrain().M28Team) then
                iTotalReclaimWanted = 25
                iIndividualReclaimThreshold = iIndividualReclaimThresholdOverride or 10
            else
                iTotalReclaimWanted = 40
                iIndividualReclaimThreshold = iIndividualReclaimThresholdOverride or 10
            end
        end
        if oEngineer:GetAIBrain():GetEconomyStored('ENERGY') <= 50 then
            bGetEnergy = true
            iTotalReclaimWanted = 15
            iIndividualReclaimThreshold = iIndividualReclaimThresholdOverride or 15
        end
    else
        if M28Conditions.TeamHasLowMass(oEngineer:GetAIBrain().M28Team) then
            iTotalReclaimWanted = 75
            iIndividualReclaimThreshold = 20
        else
            iTotalReclaimWanted = 125
            iIndividualReclaimThreshold = 25
        end
        if tLZTeamData[M28Map.subrefLZbCoreBase] and (GetGameTimeSeconds() <= 300 and M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subrefiTeamGrossMass]) <= 5 then iTotalReclaimWanted = iTotalReclaimWanted * 2 end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': LZ reclaim mass='..tLZData[M28Map.subrefTotalMassReclaim]..'; Team mass % stored='..M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subrefiTeamLowestMassPercentStored]..'; iTotalReclaimWanted='..iTotalReclaimWanted..'; iIndividualReclaimThreshold='..iIndividualReclaimThreshold..'; bOnlyConsiderIfInBuildRange='..tostring(bOnlyConsiderIfInBuildRange or false)) end

    if (bGetEnergy and tLZData[M28Map.subrefLZTotalEnergyReclaim] >= iTotalReclaimWanted) or (not(bGetEnergy) and tLZData[M28Map.subrefTotalMassReclaim] >= iTotalReclaimWanted and M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subrefiTeamLowestMassPercentStored] <= 0.6) then
        --If any reclaim of iIndividualReclaimThreshold+ value then get ACU to reclaim
        M28Engineer.GetEngineerToReclaimNearbyArea(oEngineer, 1, tLZTeamData, iPlateau, iLandZone, bGetEnergy, (bOnlyConsiderIfInBuildRange or false), iIndividualReclaimThreshold)
        if bDebugMessages == true then LOG(sFunctionRef..': ACU last order after checking for reclaim in area='..reprs(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]])) end
        local tLastOrder = oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]]
        if tLastOrder and tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueReclaim then
            if bDebugMessages == true then LOG(sFunctionRef..': ACU has a reclaim order so will stop') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function MoveToOtherLandZone(iPlateau, tLZData, iLandZone, oACU)
    --COnsiders the land zone we want to support with the ACU - get the LZ within 175 travel distance that has the greatest value, wants DF support, and has less than 800 enemy threat in it
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MoveToOtherLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iLZToMoveTo
    local iTeam = oACU:GetAIBrain().M28Team
    local iAdjLZ
    if bDebugMessages == true then LOG(sFunctionRef..': Will consider moving to another LZ for ACU '..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' owned by '..oACU:GetAIBrain().Nickname..'; Is table of pathing to other LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]))) end
    local iHighValueDistanceThreshold = 175
    local iLowerPriorityDistanceThreshold = 300
    local iLastPathedZoneTravelDist
    local iRecentLandZoneRef
    local iSecondsToIgnoreZonesRecentlyRunFrom = 30
    if bDebugMessages == true then LOG(sFunctionRef..': Time ACU last had order to move to zone='..(oACU[refiTimeLastToldToMoveToZone] or 'nil')..'; oACU[refiLastPlateauAndZoneToMoveTo]='..repru(oACU[refiLastPlateauAndZoneToMoveTo])) end
    if GetGameTimeSeconds() - (oACU[refiTimeLastToldToMoveToZone] or -100) <= 10 then
        iRecentLandZoneRef = oACU[refiLastPlateauAndZoneToMoveTo][2]
        iLastPathedZoneTravelDist = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iRecentLandZoneRef)

        iHighValueDistanceThreshold = math.max(iHighValueDistanceThreshold, (iLastPathedZoneTravelDist or 190) + 1)
        iLowerPriorityDistanceThreshold = math.max(iLowerPriorityDistanceThreshold, (iLastPathedZoneTravelDist or 315) + 1)
        if bDebugMessages == true then LOG(sFunctionRef..': Recently tried to travel to land zone '..(iRecentLandZoneRef or 'nil')..'; iHighValueDistanceThreshold='..iHighValueDistanceThreshold..'; iLowerPriorityDistanceThreshold='..iLowerPriorityDistanceThreshold..'; iLastPathedZoneTravelDist='..(iLastPathedZoneTravelDist or 'nil')) end
    end
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
        local iHighestValueAmount = 0
        local iCurValue
        for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
            iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; Travel dist='..tPathingDetails[M28Map.subrefLZTravelDist]..'; Does it want DF support='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport])) end
            if tPathingDetails[M28Map.subrefLZTravelDist] < iHighValueDistanceThreshold then
                if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport] then
                    iCurValue = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTValue]
                    if iAdjLZ == iRecentLandZoneRef then iCurValue = iCurValue * 1.05 + 25 end
                    if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTValue] > iHighestValueAmount then
                        --Have we run from this zone recently?
                        if not(oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iAdjLZ]) or GetGameTimeSeconds() - oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iAdjLZ] > iSecondsToIgnoreZonesRecentlyRunFrom then
                            if not(oACU[refiLastPlateauAndZoneToAttackUnitIn][2] == iAdjLZ) or not(oACU[refiLastPlateauAndZoneToAttackUnitIn][1] == iPlateau) or GetGameTimeSeconds() - (oACU[refiTimeLastToldToAttackUnitInOtherZone] or -100) > 30 then
                                iHighestValueAmount = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTValue]
                                iLZToMoveTo = iAdjLZ
                            end
                        end
                    end
                end
            else
                break
            end
        end
        if not(iLZToMoveTo) then
            --Are there any LZs nearby with unclaimed mexes or enemy ground units?
            local iNearestPotentialExpansionPoint
            local iPlannedTargetDist
            for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                if bDebugMessages == true then LOG(sFunctionRef..': Considering any LZs that have enemies, tPathingDetails[M28Map.subrefLZTravelDist]='..tPathingDetails[M28Map.subrefLZTravelDist]..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]))..'; Is table of unbuilt locations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMexUnbuiltLocations]))..'; time last ran from iAdjZ='..(oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iAdjLZ] or 'nil')..'; oACU[refiLastPlateauAndZoneToAttackUnitIn]='..repru(oACU[refiLastPlateauAndZoneToAttackUnitIn])..'; oACU[refiTimeLastToldToAttackUnitInOtherZone]='..(oACU[refiTimeLastToldToAttackUnitInOtherZone] or 'nil')) end
                if tPathingDetails[M28Map.subrefLZTravelDist] < iLowerPriorityDistanceThreshold then
                    if not(oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iAdjLZ]) or GetGameTimeSeconds() - oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][iAdjLZ] > iSecondsToIgnoreZonesRecentlyRunFrom then
                        if not(oACU[refiLastPlateauAndZoneToAttackUnitIn][2] == iAdjLZ) or not(oACU[refiLastPlateauAndZoneToAttackUnitIn][1] == iPlateau) or GetGameTimeSeconds() - (oACU[refiTimeLastToldToAttackUnitInOtherZone] or -100) > 30 then
                            local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                            local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                            if (tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false) or (M28Utilities.IsTableEmpty(tAdjLZData[M28Map.subrefMexUnbuiltLocations]) == false and (not(tAdjLZTeamData[M28Map.subrefLZbCoreBase]) or M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryEngineer, tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))) then
                                iLZToMoveTo = iAdjLZ
                                iPlannedTargetDist = tPathingDetails[M28Map.subrefLZTravelDist]
                            elseif not(iNearestPotentialExpansionPoint) and (tAdjLZData[M28Map.subrefTotalMassReclaim] >= 1000 or (M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMexUnbuiltLocations]) == false and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZMexCount] >= 3 and not(tAdjLZTeamData[M28Map.subrefLZbCoreBase]))) then
                                iNearestPotentialExpansionPoint = iAdjLZ
                            end
                            if tPathingDetails[M28Map.subrefLZTravelDist] > iHighValueDistanceThreshold and iNearestPotentialExpansionPoint then
                                iLZToMoveTo = iNearestPotentialExpansionPoint
                                iPlannedTargetDist = tPathingDetails[M28Map.subrefLZTravelDist]
                                break
                            end
                        end
                    end
                else
                    --Nearest place of interest is so far away we might as well keep ACU at base
                    break
                end
            end
            if iLZToMoveTo and iRecentLandZoneRef and not(iRecentLandZoneRef == iLZToMoveTo) then
                --dont change our target if our current target is suitable still - this is to avoid cases where the land zone we move to has another land zone slightly closer to its midpoint but in the opposite direction, leading to the ACU stuck in an infinite loop going back and forth between two conflicting land zones whenever its current LZ changes
                local tPrevLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iRecentLandZoneRef]
                local tPrevLZTeamData = tPrevLZData[M28Map.subrefLZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': iLZToMoveTo before adj='..iLZToMoveTo..'; iRecentLandZoneRef='..iRecentLandZoneRef..'; iPlannedTargetDist='..iPlannedTargetDist..'; iLastPathedZoneTravelDist='..iLastPathedZoneTravelDist..'; tPrevLZTeamData[M28Map.subrefTEnemyUnits]='..tostring(M28Utilities.IsTableEmpty(tPrevLZTeamData[M28Map.subrefTEnemyUnits]))..'; Mass reclaim='..(tPrevLZData[M28Map.subrefTotalMassReclaim] or 0)..'; Is table of unbuilt mexes empty='..tostring(M28Utilities.IsTableEmpty(tPrevLZData[M28Map.subrefMexUnbuiltLocations]))) end
                if iPlannedTargetDist + 50 >= iLastPathedZoneTravelDist then
                    if M28Utilities.IsTableEmpty(tPrevLZTeamData[M28Map.subrefTEnemyUnits]) == false or tPrevLZData[M28Map.subrefTotalMassReclaim] >= 1000 or M28Utilities.IsTableEmpty(tPrevLZData[M28Map.subrefMexUnbuiltLocations]) == false then
                        iLZToMoveTo = iRecentLandZoneRef
                        if bDebugMessages == true then LOG(sFunctionRef..': Will retain previous expansion target as it still seems okish') end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering whether to move to a land zone on the same island, iLZToMoveTo='..(iLZToMoveTo or 'nil')..'; Does enemy have sub='..tostring(M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refbEnemyHasSub] or false)) end

    if not(iLZToMoveTo) and not(oACU:GetAIBrain()[M28Map.refbCanPathToEnemyBaseWithLand]) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false
            and not(M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.refbEnemyHasSub]) then
        local bIslandHasUnclaimedMexesOrEnemies
        local iSearchRange = 300
        if GetGameTimeSeconds() <= 600 and math.max(M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech], M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech], M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech]) <= 1 then
            iSearchRange = 400
        end

        for iEntry, tSubtable in tLZData[M28Map.subrefLZPathingToOtherIslands] do
            if tSubtable[M28Map.subrefIslandTravelDist] <= iSearchRange then
                if oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][tSubtable[M28Map.subrefIslandClosestLZRef]] and GetGameTimeSeconds() - oACU[reftiTimeLastRanFromZoneByPlateau][iPlateau][tSubtable[M28Map.subrefIslandClosestLZRef]] > iSecondsToIgnoreZonesRecentlyRunFrom then
                    --Are there any unclaimed mexes on the LZ?
                    bIslandHasUnclaimedMexesOrEnemies = false
                    local tIslandLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefIslandClosestLZRef]]
                    if M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefMexUnbuiltLocations]) == false or M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                        bIslandHasUnclaimedMexesOrEnemies = true
                    else
                        if M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                            for iPathingRef, tPathingDetails in tIslandLZData[M28Map.subrefLZPathingToOtherLandZones] do
                                iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering any LZs on target island that have unclaimed mexes or enemies, Is table of unbuilt locations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMexUnbuiltLocations]))..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]))) end
                                if tPathingDetails[M28Map.subrefLZTravelDist] < (iSearchRange + 150) then
                                    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false or M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMexUnbuiltLocations]) == false then
                                        bIslandHasUnclaimedMexesOrEnemies = true
                                        break
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering for land zone '..tSubtable[M28Map.subrefIslandClosestLZRef]..'; bIslandHasUnclaimedMexesOrEnemies='..tostring(bIslandHasUnclaimedMexesOrEnemies)) end
                    if bIslandHasUnclaimedMexesOrEnemies then
                        iLZToMoveTo = tSubtable[M28Map.subrefIslandClosestLZRef]
                    end
                end
            end
        end
    end
    if iLZToMoveTo then
        if M28Overseer.bNoRushActive and not(M28Conditions.IsLocationInNoRushArea(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZToMoveTo][M28Map.subrefMidpoint])) then
            iLZToMoveTo = nil
        else
            M28Orders.IssueTrackedMove(oACU, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZToMoveTo][M28Map.subrefMidpoint], 6, false, 'ACMLZ'..iLZToMoveTo, false)
            oACU[refiTimeLastToldToMoveToZone] = GetGameTimeSeconds()
            oACU[refiLastPlateauAndZoneToMoveTo] = {iPlateau, iLZToMoveTo}
            if bDebugMessages == true then LOG(sFunctionRef..': Telling ACU to move to zone '..iLZToMoveTo..' at time='..GetGameTimeSeconds()) end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if iLZToMoveTo then return true else return false end
end

function UpdateACULandOrWaterZoneAssignment(oACU, iPlateauOrZero, iLandOrWaterZone, tLZOrWZTeamData)
    local sFunctionRef = 'UpdateACULandOrWaterZoneAssignment'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Update ACU tracking
    --Is the actual LZ and plateau the same? If not, then need to update tracking
    if oACU[reftiCurAssignedPlateauAndZone][1] == iPlateauOrZero and oACU[reftiCurAssignedPlateauAndZone][iLandOrWaterZone] == iLandOrWaterZone then
        --Do nothing
    else
        local iTeam = oACU:GetAIBrain().M28Team
        if iLandOrWaterZone > 0 then --No point updating if we dont have a valid land zone
            oACU[reftiLastAssignedPlateauAndZone] = {oACU[reftiCurAssignedPlateauAndZone][1], oACU[reftiCurAssignedPlateauAndZone][2]}
            oACU[reftiCurAssignedPlateauAndZone] = {iPlateauOrZero, iLandOrWaterZone}
            if (oACU[reftiLastAssignedPlateauAndZone][2] or 0) > 0 then
                local tPrevLZOrWZTeamData
                if oACU[reftiLastAssignedPlateauAndZone][1] > 0 then
                    tPrevLZOrWZTeamData = M28Map.tAllPlateaus[oACU[reftiLastAssignedPlateauAndZone][1]][M28Map.subrefPlateauLandZones][oACU[reftiLastAssignedPlateauAndZone][2]][M28Map.subrefLZTeamData][iTeam]
                else
                    tPrevLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[oACU[reftiLastAssignedPlateauAndZone][2]]][M28Map.subrefPondWaterZones][oACU[reftiLastAssignedPlateauAndZone][2]][M28Map.subrefWZTeamData][iTeam]
                end

                --Check we are in the table
                if M28Utilities.IsTableEmpty(tPrevLZOrWZTeamData[M28Map.subrefAlliedACU]) == false then
                    for iRecordedACU, oRecordedACU in tPrevLZOrWZTeamData[M28Map.subrefAlliedACU] do
                        if oRecordedACU == oACU then
                            table.remove(tPrevLZOrWZTeamData[M28Map.subrefAlliedACU], iRecordedACU)
                            break
                        end
                    end
                end
            end
            local bAlreadyRecorded = false --Redundancy - we shouldnt have scenario where we are already recorded
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefAlliedACU]) == false then
                for iRecordedACU, oRecordedACU in tLZOrWZTeamData[M28Map.subrefAlliedACU] do
                    if oRecordedACU == oACU then
                        bAlreadyRecorded = true
                        break
                    end
                end
            end
            if not(bAlreadyRecorded) then
                if not(tLZOrWZTeamData[M28Map.subrefAlliedACU]) then tLZOrWZTeamData[M28Map.subrefAlliedACU] = {} end
                table.insert(tLZOrWZTeamData[M28Map.subrefAlliedACU], oACU)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderGettingExtraLandFactory(tLZData, tLZTeamData, oACU, iPlateau, iLandZone)
    local sFunctionRef = 'ConsiderGettingExtraLandFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; ACU upgrade count='..oACU[refiUpgradeCount]..'; Is ACU in core base='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])..'; Plateau-LZ='..iPlateau..'-'..(iLandZone or 'nil')..'; Brain mass stored='..oACU:GetAIBrain():GetEconomyStored('MASS')..'; Want more factories for this LZ='..tostring(M28Conditions.WantMoreFactories(oACU:GetAIBrain().M28Team, iPlateau, iLandZone))) end

    if oACU[refiUpgradeCount] == 0 and tLZTeamData[M28Map.subrefLZbCoreBase] and oACU:GetAIBrain():GetEconomyStored('MASS') >= 220 and M28Conditions.WantMoreFactories(oACU:GetAIBrain().M28Team, iPlateau, iLandZone) then
        --We think we want another land factory; however dont do this if we will use up our current mass in 20s or less, or we have 4+ land factories, or we are at T2
        local iTeam = oACU:GetAIBrain().M28Team
        if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) then
            --DO nothing for now
        else
            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] <= 1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= -0.5 then
                local tExistingFactoriesInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                local iExistingFactories = 0
                if tExistingFactoriesInLZ then iExistingFactories = table.getn(tExistingFactoriesInLZ) end
                if bDebugMessages == true then LOG(sFunctionRef..': iExistingFactories='..iExistingFactories..'; If < 4 then will try and build another') end
                if iExistingFactories < 4 then
                    ACUActionBuildFactory(oACU:GetAIBrain(), oACU, iPlateau, iLandZone, tLZData, tLZTeamData)
                    --Check if we have an order as a result of this to build something
                    local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
                    if bDebugMessages == true then LOG(sFunctionRef..': Just told ACU to try and build a factory, last order='..reprs(tLastOrder)) end
                    if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueRepair or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueGuard then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return true
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function ConsiderAttackingNearbyNavalUnits(tLZData, tLZTeamData, oACU, iRangeThresholdOverride)
    --If can find an enemy that it wants the ACU to attack/move towards, will give the ACU orders and return true
    local sFunctionRef = 'ConsiderAttackingNearbyNavalUnits'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iClosestEnemyToAttack = 100000
    local oClosestEnemyToAttack
    local tViaPointForClosestEnemy
    local iTeam = oACU:GetAIBrain().M28Team
    local iDistToACUThreshold = (iRangeThresholdOverride or 50)
    if tLZTeamData[M28Map.subrefLZbCoreBase] and not(iRangeThresholdOverride) then iDistToACUThreshold = iDistToACUThreshold + 25 end
    local iDistToLandThreshold = oACU[M28UnitInfo.refiDFRange] - 5
    local iCurDistToACU
    local bCanHitFromLand, iAngleFromACUToUnit, iTempSegmentX, iTempSegmentZ
    local tPotentialViaPoint
    local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..', iRangeThresholdOverride='..(iRangeThresholdOverride or 'nil')..'; iDistToLandThreshold='..iDistToLandThreshold..'; iDistToACUThreshold='..iDistToACUThreshold) end
    function ConsiderPotentialUnitTarget(oUnit)
        if M28UnitInfo.IsUnitValid(oUnit) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) and (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(oUnit:GetPosition())) then
            iCurDistToACU = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition())
            if bDebugMessages == true then LOG(sFunctionRef..': iCurDistToACU='..iCurDistToACU..'; iDistToACUThreshold='..iDistToACUThreshold..'; iClosestEnemyToAttack='..iClosestEnemyToAttack) end
            if iCurDistToACU <= iDistToACUThreshold and iCurDistToACU < iClosestEnemyToAttack then
                --If we move from the ACU until we are within ACU range of the unit, are we on land rather than water?
                bCanHitFromLand = false
                if iCurDistToACU <= iDistToLandThreshold then
                    bCanHitFromLand = true
                    tPotentialViaPoint = oUnit:GetPosition()
                else
                    iAngleFromACUToUnit = M28Utilities.GetAngleFromAToB(oACU:GetPosition(), oUnit:GetPosition())
                    tPotentialViaPoint = M28Utilities.MoveInDirection(oACU:GetPosition(), iAngleFromACUToUnit, iCurDistToACU - iDistToLandThreshold, true, true, true)
                    iTempSegmentX, iTempSegmentZ = M28Map.GetPathingSegmentFromPosition(tPotentialViaPoint)
                    if M28Map.tLandZoneBySegment[iTempSegmentX][iTempSegmentZ] then
                        bCanHitFromLand = true
                    elseif iCurDistToACU <= oACU[M28UnitInfo.refiDFRange] then
                        bCanHitFromLand = true
                        tPotentialViaPoint = oUnit:GetPosition()
                    end
                end
                if bCanHitFromLand then
                    iClosestEnemyToAttack = iCurDistToACU
                    oClosestEnemyToAttack = oUnit
                    tViaPointForClosestEnemy = {tPotentialViaPoint[1], tPotentialViaPoint[2], tPotentialViaPoint[3]}
                end
            end
        end
    end
    for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
        local iAdjWZ = tSubtable[M28Map.subrefAWZRef]
        local iPond = M28Map.tiPondByWaterZone[iAdjWZ]
        local tWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
        if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjWZ='..iAdjWZ..'; Enemy surface threat='.. tWZTeamData[M28Map.subrefWZThreatEnemySurface]..'; tWZTeamData[M28Map.subrefWZThreatEnemyAA]='..tWZTeamData[M28Map.subrefWZThreatEnemyAA]) end
        if (tWZTeamData[M28Map.subrefWZThreatEnemySurface] + tWZTeamData[M28Map.subrefWZThreatEnemyAA]) > 0 and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
            for iUnit, oUnit in tWZTeamData[M28Map.subrefTEnemyUnits] do
                if bDebugMessages == true then if M28UnitInfo.IsUnitValid(oUnit) then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is unit undetwater='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(oUnit:GetPosition()))) end end
                ConsiderPotentialUnitTarget(oUnit)
            end
            if not(oClosestEnemyToAttack) then
                --redundancy - use getunitsaroundpoint as sometimes can have nearby WZ that unit isnt showing in
                local aiBrain = oACU:GetAIBrain()
                local tNearbyNavalUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryAllAmphibiousAndNavy - categories.AMPHIBIOUS, oACU:GetPosition(), iDistToACUThreshold, 'Enemy')
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby enemy hover and surface navy empty='..tostring(M28Utilities.IsTableEmpty(tNearbyNavalUnits))) end
                if M28Utilities.IsTableEmpty(tNearbyNavalUnits) == false then
                    for iUnit, oUnit in tNearbyNavalUnits do
                        ConsiderPotentialUnitTarget(oUnit)
                    end
                end
            end
        end
    end

    if oClosestEnemyToAttack then
        --move towards the enemy unit if we are out of range or only just in range, otherwise attack (or ground attack) the enemy
        if bDebugMessages == true then LOG(sFunctionRef..': oClosestEnemyToAttack='..oClosestEnemyToAttack.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyToAttack)..'; iClosestEnemyToAttack='..iClosestEnemyToAttack..'; ACU range='..oACU[M28UnitInfo.refiDFRange]..'; Can see unit='..tostring(M28UnitInfo.CanSeeUnit(oACU:GetAIBrain(), oClosestEnemyToAttack, true))..'; Time since last weapon event='..GetGameTimeSeconds() - (oACU[M28UnitInfo.refiLastWeaponEvent] or -10)) end
        if iClosestEnemyToAttack <= iDistToLandThreshold then

            if M28UnitInfo.CanSeeUnit(oACU:GetAIBrain(), oClosestEnemyToAttack, true) and GetGameTimeSeconds() - (oACU[M28UnitInfo.refiLastWeaponEvent] or -10) <= 3 then
                M28Orders.IssueTrackedAttack(oACU, oClosestEnemyToAttack, false, 'NUAt', false)
            else
                M28Orders.IssueTrackedAggressiveMove(oACU, oClosestEnemyToAttack:GetPosition(), 1, false, 'NUAM', false)
                --M28Orders.IssueTrackedGroundAttack(oACU, oClosestEnemyToAttack:GetPosition(), 1, false, 'NuGA', false) --tried ground attack but on frigates it just means shotting the water
            end
        else
            if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tViaPointForClosestEnemy) >= 2 or GetGameTimeSeconds() - (oACU[M28UnitInfo.refiLastWeaponEvent] or -10) <= 2 then
                M28Orders.IssueTrackedMove(oACU, tViaPointForClosestEnemy, 1.5, false, 'NuMV', false) --Tried doing attack move but often ACU would just stand there with attackmove slightly infront of it, and do nothing while it takes fire, e.g. if enemy isnt visible
            else
                M28Orders.IssueTrackedMove(oACU, oClosestEnemyToAttack:GetPosition(), 1.5, false, 'NuMU', false) --Tried doing attack move but often ACU would just stand there with attackmove slightly infront of it, and do nothing while it takes fire, e.g. if enemy isnt visible
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ReturnACUToCoreBase(oACU, tLZOrWZData, tLZOrWZTeamData, aiBrain, iTeam, iPlateauOrZero, iLandOrWaterZone)
    local sFunctionRef = 'ReturnACUToCoreBase'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    oACU[refiTimeLastWantedToRun] = GetGameTimeSeconds()

    --Go to core base
    local tRallyPoint

    if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        local tFixedShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tFixedShields) == false then
            local iNearestDist = 10000
            local iCurDist
            local oNearestUnit
            for iUnit, oUnit in tFixedShields do
                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())
                    if iCurDist < iNearestDist then
                        iNearestDist = iCurDist
                        oNearestUnit = oUnit
                    end
                end
            end

            if oNearestUnit then
                if bDebugMessages == true then LOG(sFunctionRef..': Will set rally point to the nearest fixed shield, position='..repru(oNearestUnit:GetPosition())..'; Nearest unit='..oNearestUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestUnit)) end
                tRallyPoint = oNearestUnit:GetPosition()
            end
        end
    end
    if not(tRallyPoint) then
        if bDebugMessages == true then LOG(sFunctionRef..': No shields so will move ACU to start point') end
        tRallyPoint = M28Map.PlayerStartPoints[oACU:GetAIBrain():GetArmyIndex()]
    end
    if not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and not(tLZOrWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) then

        M28Orders.IssueTrackedMove(oACU, tRallyPoint, 3, false, 'Runa')
        if bDebugMessages == true then LOG(sFunctionRef..': Sending ACU to core base') end
    else
        --Consider attacking nearby enemies if no enemy experimental
        local iNearestEnemyExperimental = 1000
        local iCurDist
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
            for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())
                if iCurDist < iNearestEnemyExperimental then iNearestEnemyExperimental = iCurDist end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iNearestEnemyExperimental='..iNearestEnemyExperimental..'; ACU range='..oACU[M28UnitInfo.refiDFRange]..'; ACU health='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; ACU dist to rally='..M28Utilities.GetDistanceBetweenPositions(tRallyPoint, oACU:GetPosition())) end
        if (iNearestEnemyExperimental <= 150 and iNearestEnemyExperimental >= oACU[M28UnitInfo.refiDFRange] + 5) or (M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.6 and M28Utilities.GetDistanceBetweenPositions(tRallyPoint, oACU:GetPosition()) > 10) then
            M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'Runb')
        else
            if tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] and AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                --Do nothing
                if bDebugMessages == true then LOG(sFunctionRef..': Will attack nearby enemy units with ACU') end
            else
                --Are there nearby enemy naval units to attack?
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if are nearby naval threats to attack, is table of adjacent WZs empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]))..'; Do we lack torp bombers for enemy naval='..tostring(M28Team.tAirSubteamData[oACU:GetAIBrain().M28AirSubteam][M28Team.refbNoAvailableTorpsForEnemies])) end
                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]) == false and M28Team.tAirSubteamData[oACU:GetAIBrain().M28AirSubteam][M28Team.refbNoAvailableTorpsForEnemies] and ConsiderAttackingNearbyNavalUnits(tLZOrWZData, tLZOrWZTeamData, oACU, oACU[M28UnitInfo.refiDFRange] + 10) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will attack nearby naval threats') end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': No naval threats close enough to attack so will consider nearby reclaim') end
                    if not(ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, true)) then
                        local sUpgradeToGet = GetACUUpgradeWanted(oACU)
                        if sUpgradeToGet and not(M28Conditions.HaveLowMass(aiBrain)) and not(M28Conditions.HaveLowPower(aiBrain)) then
                            --Are we safe to get the upgrade here? if not then retreat
                            if M28Conditions.SafeToUpgradeUnit(oACU) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Safe to get upgrade so will proceed with upgrading ACU, sUpgradeToGet='..(sUpgradeToGet or 'nil')..' brain='..oACU:GetAIBrain().Nickname) end
                                M28Orders.IssueTrackedEnhancement(oACU, sUpgradeToGet, false, 'ACUUp')
                            else
                                M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'Runc')
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Dont want upgrade or reclaim, will look for buildings to assist. Is table of ugprades empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefActiveUpgrades]))..'; Have low mass='..tostring(M28Conditions.HaveLowMass(aiBrain))..'; Have low power='..tostring(M28Conditions.HaveLowPower(iTeam))) end
                            local oUnitToAssist
                            if (not(M28Conditions.HaveLowPower(iTeam)) or (aiBrain:GetEconomyStoredRatio('ENERGY') >= 1 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 25 and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]))) then
                                local bOnlyGetMexToAssist = M28Conditions.HaveLowMass(aiBrain)
                                local iHighestFractionComplete = 0

                                if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefActiveUpgrades]) == false then
                                    for iUpgrading, oUpgrading in  tLZOrWZTeamData[M28Map.subrefActiveUpgrades] do
                                        if M28UnitInfo.IsUnitValid(oUpgrading) then
                                            if oUpgrading:GetWorkProgress() < 1 and oUpgrading:GetWorkProgress() > iHighestFractionComplete then
                                                if not(bOnlyGetMexToAssist) or EntityCategoryContains(M28UnitInfo.refCategoryMex, oUpgrading.UnitId) then
                                                    iHighestFractionComplete = oUpgrading:GetWorkProgress()
                                                    oUnitToAssist = oUpgrading
                                                end
                                            end
                                        end
                                    end
                                end
                                if not(oUnitToAssist) and not(bOnlyGetMexToAssist) then
                                    --Do we have any part-complete buildings and dont have low mass? if so assist these
                                    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                        local tStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryExperimentalLevel, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                        if M28Utilities.IsTableEmpty(tStructures) == false then
                                            for iUnit, oUnit in tStructures do
                                                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() < 1 and oUnit:GetFractionComplete() > iHighestFractionComplete and not(oUnit[M28Engineer.refbDontIncludeAsPartCompleteBuildingForConstruction]) then
                                                    iHighestFractionComplete = oUnit:GetFractionComplete()
                                                    oUnitToAssist = oUnit
                                                end
                                            end
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': oUnitToAssist='..(oUnitToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitToAssist) or 'nil')..'; ACU last order reprs='..reprs(oACU[M28Orders.reftiLastOrders])) end
                            end
                            if oUnitToAssist then
                                if oUnitToAssist:GetFractionComplete() < 1 then
                                    M28Orders.IssueTrackedRepair(oACU, oUnitToAssist, false, 'ACUTR', false)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Just given repair order to oUnitToAssist') end
                                else
                                    M28Orders.IssueTrackedGuard(oACU, oUnitToAssist, false, 'ACUGB', false)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Just given guard order to oUnitToAssist') end
                                end
                            else
                                M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'Rund')
                            end

                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetBestTeleSnipeUnitTarget(oACU, iTeam)
    --Make sure we have a relatively recent target list since we are proceeding to teleport
    local sFunctionRef = 'GetBestTeleSnipeUnitTarget'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    M28Team.RefreshPotentialTeleSnipeTargets(iTeam, 1)
    local oTargetWanted
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of targets empty after forced refresh every 1s='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoPotentialTeleSnipeTargets]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoPotentialTeleSnipeTargets]) == false then
        local iHighestValueTarget = 0
        local iCurTargetValue
        for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftoPotentialTeleSnipeTargets] do
            if M28UnitInfo.IsUnitValid(oUnit) then
                if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                    iCurTargetValue = 20000 --will only have an ACU if in assassination mode
                    if table.getn(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) == 1 and ScenarioInfo.Options.Victory == "demoralization" and M28UnitInfo.GetCombatThreatRating({M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs][1]}, true) <= 4000 then
                        iCurTargetValue = 250000 --i.e. if we kill the ACU then it is better than killing a game ender (although will reduce to less than a gameender if it has high health)
                    end
                    local iUnitHealth = oUnit:GetHealth()
                    local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, true)
                    iUnitHealth = iUnitHealth + iCurShield
                    if iUnitHealth >= 15000 then
                        iCurTargetValue = 180000 --likely better to target a gameender than ACU if acu is high health
                        iCurTargetValue = iCurTargetValue - math.min(iCurTargetValue * 0.6, math.max((iUnitHealth - 15000) * 0.3))
                    end
                else
                    iCurTargetValue = oUnit:GetBlueprint().Economy.BuildCostMass * oUnit:GetFractionComplete()
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurTargetValue before shield adjust='..iCurTargetValue) end
                if iCurTargetValue > iHighestValueTarget then
                    --Reduce value by shields in the zone
                    local tUnitLZData, tUnitLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                    iCurTargetValue = iCurTargetValue - math.min(iCurTargetValue * 0.3, (tUnitLZTeamData[M28Map.subrefLZThreatEnemyShield] or 0))
                    if iCurTargetValue > iHighestValueTarget then
                        iHighestValueTarget = iCurTargetValue
                        oTargetWanted = oUnit
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording unit as oTargetWanted subject to any better ones, iHighestValueTarget='..iHighestValueTarget) end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oTargetWanted
end

function GetBestLocationForTeleSnipeTarget(oACU, oSnipeTarget, iTeam, bJustCheckIfLocationWithLowPDThreat)
    --oACU - if nil then will assume has a range of 30
    --bJustCheckIfLocationWithLowPDThreat - if true, then returns true if think there is a low PD threat location to teleport to


    local sFunctionRef = 'GetBestLocationForTeleSnipeTarget'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --We ahve a valid oSnipeTarget for oACU to teleport to and try and kill, now we want to refine the teleport destination, e.g. to avoid volatile units and PD
    local tBestTarget
    local bConsiderAvoidingVolatileUnits = true
    local iMinDistanceAway = 0
    local iDistFromAOEWanted = 2
    local iMaxDistFromTarget = (oACU[M28UnitInfo.refiDFRange] or 30) - 2
    if EntityCategoryContains(categories.MOBILE - M28UnitInfo.refCategoryScathis, oSnipeTarget.UnitId) then iMaxDistFromTarget = iMaxDistFromTarget - 8 end

    local iTargetPlateau, iTargetLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oSnipeTarget:GetPosition())

    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, oSnipeTarget='..oSnipeTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSnipeTarget)..'; Position='..repru(oSnipeTarget:GetPosition())..'; iTargetPlateau='..(iTargetPlateau or 'nil')..'; iTargetLandZone='..(iTargetLandZone or 'nil')) end
    if iTargetPlateau > 0 and (iTargetLandZone or 0) > 0 then
        local tTargetLZData = M28Map.tAllPlateaus[iTargetPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone]
        local tTargetLZTeamData = tTargetLZData[M28Map.subrefLZTeamData][iTeam]

        local tNearbyPD = {}
        local tCurZonePD = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD, tTargetLZTeamData[M28Map.subrefTEnemyUnits])
        if M28Utilities.IsTableEmpty(tCurZonePD) == false then
            for iUnit, oUnit in tCurZonePD do
                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then
                    table.insert(tNearbyPD, oUnit)
                end
            end
        end
        if M28Utilities.IsTableEmpty(tTargetLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in tTargetLZData[M28Map.subrefLZAdjacentLandZones] do
                local tAdjLZData = M28Map.tAllPlateaus[iTargetPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone]
                local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    local tAdjPD = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD, tAdjLZTeamData[M28Map.subrefTEnemyUnits])
                    if M28Utilities.IsTableEmpty(tAdjPD) == false then
                        for iPD, oPD in tAdjPD do
                            if M28UnitInfo.IsUnitValid(oPD) then
                                table.insert(tNearbyPD, oPD)
                            end
                        end
                    end
                end
            end
        end


        local tiApproxPDDPSByTech = {[1]=167,[2]=132,[3]=273, [4]=1000}
        local iCurDistToTarget
        function EstimatePDDPSNearLocation(tLocation, iDistanceThreshold)
            local iPDApproxDPS = 0
            if M28Utilities.IsTableEmpty(tNearbyPD) == false then
                for iUnit, oUnit in tNearbyPD do
                    iCurDistToTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLocation)
                    if iCurDistToTarget - oUnit[M28UnitInfo.refiDFRange] <= (iDistanceThreshold or 2) then
                        iPDApproxDPS = iPDApproxDPS + tiApproxPDDPSByTech[M28UnitInfo.GetUnitTechLevel(oUnit)]
                    end
                end
            end
            return iPDApproxDPS
        end

        --Get volatile units and PD in this and adjacent land zones so can factor in if alternative locations are more dangerous
        local tVolatileUnits = {}
        if not(bJustCheckIfLocationWithLowPDThreat) then
            local tPotentialVolatileUnits = EntityCategoryFilterDown(categories.VOLATILE * categories.STRUCTURE, tTargetLZTeamData[M28Map.subrefTEnemyUnits])
            if M28Utilities.IsTableEmpty(tPotentialVolatileUnits) == false then
                for iUnit, oUnit in tPotentialVolatileUnits do
                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then
                        local iDeathDamage, iDeathAOE, tDeathWeapon = M28UnitInfo.GetDeathWeaponDamageAOEAndTable(oUnit)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering volatile units in zone, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iDeathDamage='..iDeathDamage) end
                        if iDeathDamage >= 1250 then
                            table.insert(tVolatileUnits, oUnit)
                        end
                    end
                end
            end
        end

        function EstimateVolatileDamageNearLocation(tPotentialLocation, iOptionalAOEAdjust)
            local iVolatileDamage = 0
            if M28Utilities.IsTableEmpty(tVolatileUnits) == false then
                for iUnit, oUnit in tVolatileUnits do
                    iCurDistToTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tPotentialLocation)
                    local iDeathDamage, iDeathAOE, tDeathWeapon = M28UnitInfo.GetDeathWeaponDamageAOEAndTable(oUnit)
                    if bDebugMessages == true then LOG(sFunctionRef..': iCurDistToTarget='..iCurDistToTarget..'; iDeathDamage='..(iDeathDamage or 'nil')..'; iDeathAOE='..(iDeathAOE or 'nil')..'; iOptionalAOEAdjust='..(iOptionalAOEAdjust or 'nil')) end
                    if iCurDistToTarget <= 1 + iDeathAOE + (iOptionalAOEAdjust or 0) then
                        iVolatileDamage = iVolatileDamage + iDeathDamage
                    end
                end
            end
            return iVolatileDamage
        end
        local iBaseTargetPDDPS = EstimatePDDPSNearLocation(oSnipeTarget:GetPosition(), 6)
        local iBaseTargetVolatileDamage = 0

        local bKeepToCampaignPlayableArea = M28Map.bIsCampaignMap

        function IsPotentialAlternativeLocationTooDangerous(tPotentialLocation, iDistThreshold, iPDDPSThreshold, iOptionalVolatileTarget)
            --factors in tVolatileUnits, tPD, and general zone stats re dangerous units if the zone is different to the target unit (air to ground and mobile DF) to decide whether it is safe to teleport to a location
            local bDangerous = true
            local iPDDPS = EstimatePDDPSNearLocation(tPotentialLocation, iDistThreshold)
            if iPDDPS <= iPDDPSThreshold then
                if not(iOptionalVolatileTarget) then
                    bDangerous = false
                else
                    if EstimateVolatileDamageNearLocation(tPotentialLocation, iDistThreshold) <= iOptionalVolatileTarget then
                        bDangerous = false
                    end
                end
            end
            return bDangerous, iPDDPS
        end

        function UpdateBestTargetIfSafeLocationNearTargetUnit(oTargetUnit, iDistanceAwayMin, iDistanceAwayMax, iMaxPDDPS, iOptionalMaxVolatileDamage)
            --Try 8 different points around target to see if any of them are safer
            local iAngleInterval = 360 / 8
            local iDistFromSnipeTarget
            local bTargetWithinRange
            local iLeewayUntilOutOfRange
            local iPDDistThreshold
            local iDistanceInterval = iDistanceAwayMax - iDistanceAwayMin
            local iPDDPSThreshold = iMaxPDDPS
            if iDistanceInterval >= 4 then iDistanceInterval = 4 end
            if bDebugMessages == true then LOG(sFunctionRef..': Searching for safer locations to target oTargetUnit '..oTargetUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTargetUnit)..'; iDistanceAwayMin='..iDistanceAwayMin..'; iDistanceAwayMax='..iDistanceAwayMax..'; iOptionalMaxVolatileDamage='..(iOptionalMaxVolatileDamage or 'nil')) end
            for iDistanceAway = iDistanceAwayMin, iDistanceAwayMax, iDistanceInterval do
                for iCurAngle = iAngleInterval, 360, iAngleInterval do
                    local tPotentialTarget = M28Utilities.MoveInDirection(oTargetUnit:GetPosition(), iAngleInterval, iDistanceAway, true, false, bKeepToCampaignPlayableArea)
                    --Is this location actually within range of the snipe target?
                    iDistFromSnipeTarget = M28Utilities.GetDistanceBetweenPositions(tPotentialTarget, oSnipeTarget:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering tPotentialTarget='..repru(tPotentialTarget)..'; iDistanceAway='..iDistanceAway..'; iCurAngle='..iCurAngle..'; iDistFromSnipeTarget='..iDistFromSnipeTarget..'; iMaxDistFromTarget='..iMaxDistFromTarget) end
                    if iDistFromSnipeTarget < iMaxDistFromTarget then
                        bTargetWithinRange = false
                        iLeewayUntilOutOfRange = (oACU[M28UnitInfo.refiDFRange] or 30) - iDistFromSnipeTarget
                        iPDDistThreshold = 2
                        local tNearbyUnits = GetUnitsInRect(tPotentialTarget[1] - 1, tPotentialTarget[3] - 1, tPotentialTarget[1] + 1, tPotentialTarget[3] + 1)
                        if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                            local tNearbyStructures = EntityCategoryFilterDown(categories.STRUCTURE, tNearbyUnits)
                            if M28Utilities.IsTableEmpty(tNearbyStructures) == false then
                                for iUnit, oUnit in tNearbyStructures do
                                    iPDDistThreshold = math.max(iPDDistThreshold, M28UnitInfo.GetBuildingSize(oUnit.UnitId))
                                end
                            end
                        end

                        if iPDDistThreshold < iLeewayUntilOutOfRange then
                            bTargetWithinRange = true
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iPDDistThreshold='..iPDDistThreshold..'; iLeewayUntilOutOfRange='..iLeewayUntilOutOfRange..'; bTargetWithinRange='..tostring(bTargetWithinRange)) end
                        if bTargetWithinRange then
                            --Is PD threat from this location less than before?
                            local bAlternativeLocationDangerous, iPotentialPDDPS = IsPotentialAlternativeLocationTooDangerous(tPotentialTarget, iPDDistThreshold, iPDDPSThreshold, iOptionalMaxVolatileDamage)
                            if not(bAlternativeLocationDangerous) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have a new best target') end
                                tBestTarget = {tPotentialTarget[1], tPotentialTarget[2], tPotentialTarget[3]}
                                if iPotentialPDDPS <= 400 then
                                    break
                                else
                                    --Keep looking in case are locations with even less PD threat
                                    iPDDPSThreshold = math.min(iPotentialPDDPS, iPDDPSThreshold * 0.8)
                                end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Target not safe enough') end
                            end
                        end
                    end
                end
                if iDistanceInterval <= 0 or (tBestTarget and iPDDPSThreshold <= 400) then break end
            end
        end


        if bDebugMessages == true then LOG(sFunctionRef..': iBaseTargetPDDPS='..iBaseTargetPDDPS) end
        if iBaseTargetPDDPS >= 700 then
            --Want to search for locations with lower PD threat, if there are any
            local iTargetBuildingSize = M28UnitInfo.GetBuildingSize(oSnipeTarget.UnitId)
            if bDebugMessages == true then LOG(sFunctionRef..': Will look for targets that avoid PD, tBestTarget before change='..repru(tBestTarget)..'; iTargetBuildingSize='..iTargetBuildingSize..'; ACU DF range='..(oACU[M28UnitInfo.refiDFRange] or 30)) end
            local iMaxDPSWanted
            if bJustCheckIfLocationWithLowPDThreat then iMaxDPSWanted = 690 --Roughly 4 T1 pd
            else
                iMaxDPSWanted = iBaseTargetPDDPS * 0.8
            end
            local iVolatileHealthLevel = nil
            if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] == 1 and ScenarioInfo.Options.Victory == "demoralization" then iVolatileHealthLevel = 9000 end
            UpdateBestTargetIfSafeLocationNearTargetUnit(oSnipeTarget, iTargetBuildingSize, math.min(iMaxDistFromTarget, iTargetBuildingSize + 4 * 4, (oACU[M28UnitInfo.refiDFRange] or 30) - 6), iMaxDPSWanted, iVolatileHealthLevel)
            if bDebugMessages == true then LOG(sFunctionRef..': Attempted to change target to avoid PD, tBestTarget after change='..repru(tBestTarget)) end
            if bJustCheckIfLocationWithLowPDThreat and tBestTarget then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            end
        else
            if bJustCheckIfLocationWithLowPDThreat then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            else
                --avoid aoe on the target itself unless iti s a game ender with heavy shielding
                if not(EntityCategoryContains(categories.MOBILE - M28UnitInfo.refCategoryScathis, oSnipeTarget.UnitId)) then --(dont want to mvoe away from mobile units such as ACUs in case they then move out of our range; exceptino for scathis due to how slow it is and itneeding to pack up)
                    if not(EntityCategoryContains(M28UnitInfo.refCategoryGameEnder, oSnipeTarget.UnitId)) or (tTargetLZTeamData[M28Map.subrefLZThreatEnemyShield] or 0) <= 5000 or M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] == 1 then
                        --First move away if targeting a highly volatile unit that could kill us, and we outrange the volatile radius (e.g. paragon and yolona)
                        local iBaseTargetVolatileDamage, iDeathAOE, tDeathWeapon = M28UnitInfo.GetDeathWeaponDamageAOEAndTable(oSnipeTarget)
                        if tDeathWeapon and iBaseTargetVolatileDamage >= 1250 then
                            if iDeathAOE + iDistFromAOEWanted < (oACU[M28UnitInfo.refiDFRange] or 30) then --Energy storage is 1k damage; also no point avoiding if outside our range

                                iMinDistanceAway = iDeathAOE + iDistFromAOEWanted
                                if bDebugMessages == true then LOG(sFunctionRef..': Snipe target has death aoe we want to avoid, iMinDistanceAway='..iMinDistanceAway..'; iDeathAOE='..iDeathAOE..'; iBaseTargetVolatileDamage='..iBaseTargetVolatileDamage) end
                            else
                                bConsiderAvoidingVolatileUnits = false --No point avoiding things like t3 pgens if the target itself will kill us when it dies
                                if bDebugMessages == true then LOG(sFunctionRef..': We cant dodge target volatile explosion so will not bother trying to dodge other volatile units') end
                            end
                        end
                    end
                end


                if bConsiderAvoidingVolatileUnits then
                    if iMinDistanceAway > 0 then
                        --Snipe target is volatile, so try and avoid
                        if bDebugMessages == true then LOG(sFunctionRef..': Snipe target is volatile so will try and avoid') end
                        UpdateBestTargetIfSafeLocationNearTargetUnit(oSnipeTarget, iMinDistanceAway, math.min(iMinDistanceAway + 4, iMaxDistFromTarget), iBaseTargetPDDPS * 0.25, iBaseTargetVolatileDamage * 0.5)

                    else
                        --We arent trying to avoid explosion from the target itself so consider avoiding explosion from nearby T3 pgens
                        local iTargetBuildingSize = M28UnitInfo.GetBuildingSize(oSnipeTarget.UnitId)
                        iBaseTargetVolatileDamage = EstimateVolatileDamageNearLocation(oSnipeTarget:GetPosition(), iTargetBuildingSize)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to try and avoid nearby volatile units, iBaseTargetVolatileDamage='..iBaseTargetVolatileDamage..'; iTargetBuildingSize='..iTargetBuildingSize) end
                        if iBaseTargetVolatileDamage > 0 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will try searching for safer locations') end
                            UpdateBestTargetIfSafeLocationNearTargetUnit(oSnipeTarget, iTargetBuildingSize, math.min(iMaxDistFromTarget, iTargetBuildingSize + 4 * 2, (oACU[M28UnitInfo.refiDFRange] or 30) - 6), iBaseTargetPDDPS * 0.25, 2000)
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Near end of code, tBestTarget before applying default if it is nil='..repru(tBestTarget)) end
    if not(tBestTarget) then tBestTarget = oSnipeTarget:GetPosition() end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bJustCheckIfLocationWithLowPDThreat then return false
    else return tBestTarget
    end


end

function HaveTelesnipeAction(oACU, tLZOrWZData, tLZOrWZTeamData, aiBrain, iTeam, iPlateauOrZero, iLandOrWaterZone)
    local sFunctionRef = 'HaveTelesnipeAction'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bGivenACUOrder = false

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for brain '..aiBrain.Nickname..'; Does ACU have special micro active='..tostring(oACU[M28UnitInfo.refbSpecialMicroActive] or false)) end
    if not(oACU[M28UnitInfo.refbSpecialMicroActive]) then

        --First check if we want to get upgrades to enable a tele-snipe
        local sUpgradeWanted
        if not(oACU[refbACUHasTeleport]) and EntityCategoryContains(categories.CYBRAN + categories.SERAPHIM, oACU.UnitId) then
            if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 600 + 450 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                local bConsiderSniping = false
                function GetArtiEquivValue(oUnit)
                    local iArtiValue = 0
                    if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder - M28UnitInfo.refCategorySML, oUnit.UnitId) then
                        iArtiValue = 3
                    elseif EntityCategoryContains(M28UnitInfo.refCategorySML * categories.EXPERIMENTAL, oUnit.UnitId) then
                        iArtiValue = 2
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryNovaxCentre + M28UnitInfo.refCategorySatellite, oUnit.UnitId) then
                        iArtiValue = 0.6
                    else
                        iArtiValue = 1
                    end
                    return iArtiValue
                end
                local iEnemyArtiCount = 0
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure]) == false then
                    for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure] do
                        if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() >= 0.85 then
                            iEnemyArtiCount = iEnemyArtiCount + GetArtiEquivValue(oUnit)
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyMobileSatellites]) == false then
                    local iNovaxCount = 0
                    for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyMobileSatellites] do
                        iNovaxCount = iNovaxCount + GetArtiEquivValue(oUnit)
                    end
                    iEnemyArtiCount = math.max(iEnemyArtiCount, iNovaxCount)
                end

                if not(ScenarioInfo.Options.Victory == "demoralization") and (iEnemyArtiCount >= 2 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 2250) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Arent in assassination mode so will consider sniping') end
                    bConsiderSniping = true
                elseif M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 and (iEnemyArtiCount >= 2 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 2250) then
                    bConsiderSniping = true
                else
                    --Assassination, and down to last ACU, only go for telesnipe as a last resort
                    if iEnemyArtiCount >= 3 then
                        local iFriendlyArtiCount = 0
                        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                            local tFriendlyExperimentals = oBrain:GetListOfUnits(M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryNovaxCentre + M28UnitInfo.refCategoryFixedT3Arti, false, false)
                            for iUnit, oUnit in tFriendlyExperimentals do
                                if oUnit:GetFractionComplete() >= 0.4 then
                                    iFriendlyArtiCount = iFriendlyArtiCount + GetArtiEquivValue(oUnit)
                                end
                            end
                        end
                        if iFriendlyArtiCount < 2 and iEnemyArtiCount - iFriendlyArtiCount >= 3 then
                            bConsiderSniping = true
                        end
                    end
                end
                if bConsiderSniping then
                    --Only get teleport on seraphim if we have no cybran ACU; dont get teleport on either if we are already getting teleport (or have it) on another ACU
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        local tFriendlyACUs = oBrain:GetListOfUnits(categories.COMMAND * categories.CYBRAN + categories.COMMAND * categories.SERAPHIM, true, false)
                        if M28Utilities.IsTableEmpty(tFriendlyACUs) == false then
                            for iFriendlyACU, oFriendlyACU in tFriendlyACUs do
                                if not(oFriendlyACU == oACU) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if other ACUs are planning on getting teleport, ACU owned by brain '..oBrain.Nickname..': oFriendlyACU[refbPlanningToGetTeleport]='..tostring(oFriendlyACU[refbPlanningToGetTeleport] or false)..'; oFriendlyACU[refbACUHasTeleport]='..tostring(oFriendlyACU[refbACUHasTeleport])) end
                                    if oFriendlyACU[refbPlanningToGetTeleport] or oFriendlyACU[refbACUHasTeleport] then
                                        bConsiderSniping = false
                                        break
                                    elseif EntityCategoryContains(categories.CYBRAN, oFriendlyACU.UnitId) and EntityCategoryContains(categories.SERAPHIM, oACU.UnitId) then
                                        bConsiderSniping = false
                                        break
                                    end
                                end
                            end
                        end
                        if not(bConsiderSniping) then break end
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': bConsiderSniping='..tostring(bConsiderSniping)) end
                if bConsiderSniping then
                    --Do we have any viable targets?
                    M28Team.RefreshPotentialTeleSnipeTargets(iTeam)
                    if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to get teleport upgrade, Is table of potentail snipe targets empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoPotentialTeleSnipeTargets]))) end
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoPotentialTeleSnipeTargets]) == false then
                        sUpgradeWanted = GetACUUpgradeWanted(oACU, true)
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': sUpgradeWanted='..(sUpgradeWanted or 'nil')) end
        if sUpgradeWanted then
            oACU[refbPlanningToGetTeleport] = true
            bGivenACUOrder = true
            --Are we in core base? if not then move to core base
            if not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) then
                if bDebugMessages == true then LGO(sFunctionRef..': Will return ACU to core base') end
                ReturnACUToCoreBase(oACU, tLZOrWZData, tLZOrWZTeamData, aiBrain, iTeam, iPlateauOrZero, iLandOrWaterZone)
            else
                --Upgrade to telesnipe
                if bDebugMessages == true then LOG(sFunctionRef..': Will get telesnipe upgrade') end
                M28Orders.IssueTrackedEnhancement(oACU, sUpgradeWanted, false, 'ACUTeleU')
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Dont want to get upgrade, does ACU already have teleport='..tostring(oACU[refbACUHasTeleport] or false)) end
            if oACU[refbACUHasTeleport] then
                --Are we not in core base? Teleport to core base
                if bDebugMessages == true then LOG(sFunctionRef..': Are we in a core base='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase])) end
                if not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will teleport back to base') end
                    bGivenACUOrder = true
                    M28Orders.IssueTrackedTeleport(oACU, tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], 5, true, 'ACUTelB')
                else
                    --Do we have enough health to target
                    if M28UnitInfo.GetUnitHealthPercent(oACU) < 0.95 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to heal up first, health percent='..M28UnitInfo.GetUnitHealthPercent(oACU)) end
                        bGivenACUOrder = false --redundancy
                    else
                        M28Team.RefreshPotentialTeleSnipeTargets(iTeam)
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of telesnipe targets empty after refresh='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoPotentialTeleSnipeTargets]))) end
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoPotentialTeleSnipeTargets]) == false then
                            local oSnipeTarget = GetBestTeleSnipeUnitTarget(oACU, iTeam)
                            if bDebugMessages == true then LOG(sFunctionRef..': oSnipeTarget='..(oSnipeTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oSnipeTarget) or 'nil')..'; Is target valid='..tostring(M28UnitInfo.IsUnitValid(oSnipeTarget))) end
                            if not(M28UnitInfo.IsUnitValid(oSnipeTarget)) then
                                bGivenACUOrder = false --redundancy
                            else
                                local tTeleportTarget = GetBestLocationForTeleSnipeTarget(oACU, oSnipeTarget, iTeam)
                                M28Orders.IssueTrackedTeleport(oACU, tTeleportTarget, 5, true, 'ACUTelA')
                                if bDebugMessages == true then LOG(sFunctionRef..': Just tried to give ACU a teleport order') end
                                bGivenACUOrder = true
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bGivenACUOrder
end

function GetACUOrder(aiBrain, oACU)
    local sFunctionRef = 'GetACUOrder'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oACU:GetPosition())



    local tLZOrWZData
    local tLZOrWZTeamData
    local iTeam = oACU:GetAIBrain().M28Team
    if iPlateauOrZero == 0 then
        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
    else
        tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
    end
    tLZOrWZTeamData[M28Map.refbACUInTrouble] = false --will set to true later (if want ACU to run)

    --local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oACU:GetPosition(), true, oACU)
    --local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    --local tLZTeamData = tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
    UpdateACULandOrWaterZoneAssignment(oACU, iPlateauOrZero, iLandOrWaterZone, tLZOrWZTeamData)

    --Refresh ACU last orders as some functions will check last order to decide if it was given an order
    M28Orders.UpdateRecordedOrders(oACU)


    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code for brain '..oACU:GetAIBrain().Nickname..', ACU='..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..'; time='..GetGameTimeSeconds()..'; oACU[refbDoingInitialBuildOrder]='..tostring(oACU[refbDoingInitialBuildOrder])..'; ACU unit state='..M28UnitInfo.GetUnitState(oACU)..'; iPlateau='..(iPlateauOrZero or 'nil')..'; iLandZone='..(iLandOrWaterZone or 'nil')..'; Can ACU use overcharge='..tostring(M28Conditions.CanUnitUseOvercharge(oACU:GetAIBrain(), oACU))..'; ACU position='..repru(oACU:GetPosition())..'; ACU Orders (before updates)='..reprs(oACU[M28Orders.reftiLastOrders])..'; Is special micro active='..tostring(oACU[M28UnitInfo.refbSpecialMicroActive] or false)..'; Time to stop micro='..(oACU[M28UnitInfo.refiGameTimeToResetMicroActive] or 'nil')..'; Brian nickname='..aiBrain.Nickname..'; reftSpecialObjectiveMoveLocation='..repru(oACU[reftSpecialObjectiveMoveLocation])..'; Enemy combat threat='..(tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; Is table of unbuilt mexes empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefMexUnbuiltLocations]))) end

    --Is the ACU busy with something?
    if oACU:IsUnitState('Upgrading') then
        --Do nothing unless in a very dangerous situation
        if bDebugMessages == true then LOG(sFunctionRef..': ACU upgrading so will only cancel if in dangerous situation. is ACU doing initial BO='..tostring(oACU[refbDoingInitialBuildOrder])) end
        if not(oACU[refbDoingInitialBuildOrder]) then
            if bDebugMessages == true then LOG(sFunctionRef..': ACU is upgrading') end
            if DoesACUWantToReturnToCoreBase(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                ConsiderIfACUNeedsEmergencySupport(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)
                --Are we in a different LZ to core base, and have enemy threat or are on <60% health with less health than our upgrade progress?
                if not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and not(tLZOrWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) then
                    local iACUHealthPercent = M28UnitInfo.GetUnitHealthPercent(oACU)
                    if iACUHealthPercent < 0.6 and (1 - iACUHealthPercent) + 0.1 > oACU:GetWorkProgress() then
                        --Do we no longer consider this location safe?
                        if bDebugMessages == true then LOG(sFunctionRef..': ACU health relatively low, iACUHealthPercent='..iACUHealthPercent..'; Work progress='..oACU:GetWorkProgress()..'; woudl it be safe to start an ugprade here='..tostring(M28Conditions.SafeToUpgradeUnit(oACU))) end
                        if not(M28Conditions.SafeToUpgradeUnit(oACU)) then
                            --Cancel upgrade
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to cancel ACU upgrade') end
                            M28Orders.IssueTrackedMove(oACU, M28Map.PlayerStartPoints[oACU:GetAIBrain():GetArmyIndex()], 5, false, 'CURun')
                        end
                    end
                end

            end
        end
    elseif oACU:IsUnitState('Teleporting') then
        --Do nothing
        if bDebugMessages == true then LOG(sFunctionRef..': ACU is teleporting') end
    elseif GiveOverchargeOrderIfRelevant(tLZOrWZData, tLZOrWZTeamData, oACU, iPlateauOrZero, iLandOrWaterZone) then
        --when an overcharge shot is fired it triggers this code to run again so no need to queue things up afterwards
        if bDebugMessages == true then LOG(sFunctionRef..': Have just givne overcharge order') end
    elseif oACU[M28UnitInfo.refbSpecialMicroActive] then
        --Do nothing
        if bDebugMessages == true then LOG(sFunctionRef..': ACU has special micro active, Time remaining='..(oACU[M28UnitInfo.refiGameTimeToResetMicroActive] or 0) - GetGameTimeSeconds()) end
        if GetGameTimeSeconds() > (oACU[M28UnitInfo.refiGameTimeToResetMicroActive] or 0) then
            oACU[M28UnitInfo.refbSpecialMicroActive] = false
        end
        --Are there enemies in the same LZ as the ACU? If so then consider action for these
    else
        oACU[refbACUHasBeenGivenABuildOrderRecently] = false
        local bProceedWithLogic = true
        if oACU[refbDoingInitialBuildOrder] then
            if not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and GetGameTimeSeconds() >= 20 and DoesACUWantToReturnToCoreBase(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                ConsiderIfACUNeedsEmergencySupport(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)
                ReturnACUToCoreBase(oACU, tLZOrWZData, tLZOrWZTeamData, aiBrain, iTeam, iPlateauOrZero, iLandOrWaterZone)
                bProceedWithLogic = false
                if bDebugMessages == true then LOG(sFunctionRef..': Want to return to core base') end
            elseif M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) then
                bProceedWithLogic = false
                GetACUEarlyGameOrders(aiBrain, oACU) --Avoid some scenarios where ACU might get stuck in 'run to core zone' mode
                if bDebugMessages == true then LOG(sFunctionRef..': No enemies in LZ and ACU doing initial order so referred to early game order logic') end
            elseif (iLandOrWaterZone or 0) == 0 then
                bProceedWithLogic = false
                GetACUEarlyGameOrders(aiBrain, oACU) --backup which should ahve ACU move if it doesnt seem to be on a land or water zone
                if bDebugMessages == true then LOG(sFunctionRef..': ACU not in land zone and is doing initial order so referred to early game order logic') end
            elseif (iLandOrWaterZone or 0) > 0 and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                --Are enemies in this zone, decide if we want to attack them - get closest enemy to ACU, and ignore any structures that are more than 10 from being in range of ACU
                --Exception - we have no factory in this zone, and the enemy isn't a combat unit
                local iClosestDist = 100000
                local iClosestUntilInRange = 100000
                local iClosestMobileThreatUntilInRange = 100000
                local iCurDist, iCurDistUntilInRange, iCurRange
                local oClosestEnemyByDist
                local oClosestEnemyUntilInRange
                local oClosestMobileThreatUntilInRange
                for iUnit, oUnit in tLZOrWZTeamData[M28Map.subrefTEnemyUnits] do
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition())
                    iCurRange = math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0))
                    if iCurDist < iClosestDist then
                        iClosestDist = iCurDist
                        oClosestEnemyByDist = oUnit
                    end
                    iCurDistUntilInRange = iCurDist - iCurRange
                    if iCurDistUntilInRange < iClosestUntilInRange then
                        iClosestUntilInRange = iCurDistUntilInRange
                        oClosestEnemyUntilInRange = oUnit
                    end
                    if iCurDistUntilInRange < iClosestMobileThreatUntilInRange and iCurRange > 0 and EntityCategoryContains(categories.MOBILE, oUnit.UnitId) and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - M28UnitInfo.refCategoryCombatScout, oUnit.UnitId)) then
                        iClosestMobileThreatUntilInRange = iCurDistUntilInRange
                        oClosestMobileThreatUntilInRange = oUnit
                    end
                end
                local iOurRange = (oACU[M28UnitInfo.refiDFRange] or 0)
                if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to go with early game orders despite enemy having units in this zone, subrefTThreatEnemyCombatTotal='..(tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; iOurRange='..iOurRange..'; iClosestUntilInRange='..iClosestUntilInRange..'; iClosestMobileThreatUntilInRange='..iClosestMobileThreatUntilInRange) end
                --Ignore nearby enemy if will be a while before in our range, with the threshold depending on if it is is a mobile threat or not
                if iClosestUntilInRange > (iOurRange + 15) and iCurDistUntilInRange > 15 and iClosestMobileThreatUntilInRange > 25 then
                    bProceedWithLogic = false
                    GetACUEarlyGameOrders(aiBrain, oACU) --Avoid some scenarios where ACU might get stuck in 'run to core zone' mode
                elseif iClosestMobileThreatUntilInRange > 25 or (aiBrain[M28Economy.refiBrainBuildRateMultiplier] >= 3 and iClosestMobileThreatUntilInRange > 1) or aiBrain[M28Economy.refiBrainBuildRateMultiplier] >= 6 then
                    local tFactoriesOwned = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryFactory, false, true)
                    local bHaveNoFactory = true
                    if M28Utilities.IsTableEmpty(tFactoriesOwned) == false then
                        for iFactory, oFactory in tFactoriesOwned do
                            if oFactory:GetFractionComplete() == 1 then bHaveNoFactory = false break end
                        end
                    end
                    if bHaveNoFactory then
                        bProceedWithLogic = false
                        GetACUEarlyGameOrders(aiBrain, oACU) --Avoid some scenarios where ACU might get stuck in 'run to core zone' mode
                    elseif AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, 45) then
                        bProceedWithLogic = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Have enemies fairly close in this zone and have land fac so will attack') end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': Have a facotry, but nearby enemies arent close enough to attack with ACU using 45 distane threshold, will proceed with non-early game logic temporarily')
                    end
                elseif AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, 45) then
                    bProceedWithLogic = false
                    if bDebugMessages == true then LOG(sFunctionRef..': Have enemies close in this zone so will attack') end
                end
            end
            if not(oACU[refbDoingInitialBuildOrder]) then bProceedWithLogic = true end
        elseif oACU[reftSpecialObjectiveMoveLocation] then
            M28Orders.IssueTrackedMove(oACU, oACU[reftSpecialObjectiveMoveLocation], 3, false, 'ACUObj', false)
            bProceedWithLogic = false
        end
        if bDebugMessages == true then LOG(sFunctionRef..': oACU[refbDoingInitialBuildOrder]='..tostring(oACU[refbDoingInitialBuildOrder] or false)..'; bProceedWithLogic='..tostring(bProceedWithLogic or false)..'; Is table of enemy units for this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]))) end
        if bProceedWithLogic then
            --Special case - rebuilding destroyed base (relevant for teamgame) - if ACU at core base, and has no factories, then build a factory
            --Cant just use factory count in case we have plateaus/islands that have factories on them
            if bDebugMessages == true then LOG(sFunctionRef..': Considerinb brain '..aiBrain.Nickname..' at time '..GetGameTimeSeconds()..'; Current factories='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory)..'; In core LZ='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase])..'; Enemies in this LZ='..tostring(tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])..'; aiBrain[M28Economy.refiOurHighestAirFactoryTech]='..(aiBrain[M28Economy.refiOurHighestAirFactoryTech] or 'nil')) end
            if (iPlateauOrZero > 0 and not(tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and (tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or not(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])) and aiBrain[M28Economy.refiOurHighestLandFactoryTech] == 0) then
                if bDebugMessages == true then LOG(sFunctionRef..': Do we have factories of any type in this LZ? Is table empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))..'; aiBrain[M28Economy.refiOurHighestLandFactoryTech]='..aiBrain[M28Economy.refiOurHighestLandFactoryTech]) end
                local bWantAnotherFactory
                if aiBrain[M28Economy.refiOurHighestLandFactoryTech] == 0 then bWantAnotherFactory = true
                    --elseif M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) then bWantAnotherFactory = true
                elseif M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                    local bHaveHQFactoriesInZone = false
                    --local bHaveHQFactoriesWeOwnInZone = false

                    local tFactoriesInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory - categories.SUPPORTFACTORY, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])

                    if M28Utilities.IsTableEmpty(tFactoriesInLZ) == false then
                        for iFactory, oFactory in tFactoriesInLZ do
                            if oFactory:GetFractionComplete() >= 1 then
                                bHaveHQFactoriesInZone = true
                                break
                                --if oFactory:GetAIBrain() == aiBrain then bHaveHQFactoriesWeOwnInZone = true
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': bHaveHQFactoriesInZone='..tostring(bHaveHQFactoriesInZone)) end
                    if not(bHaveHQFactoriesInZone) then bWantAnotherFactory = true end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Do we want another factory='..tostring(bWantAnotherFactory)) end
                if bWantAnotherFactory then

                    ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryLandFactory, M28Engineer.refActionBuildLandFactory)


                    if bDebugMessages == true then LOG(sFunctionRef..': WIll try and rebuild base by building a factory') end
                    if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then
                        --Do we want to build an air fac?
                        local bHaveHQFactoriesInZone = false
                        local tFactoriesInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory - categories.SUPPORTFACTORY, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])

                        if M28Utilities.IsTableEmpty(tFactoriesInLZ) == false then
                            for iFactory, oFactory in tFactoriesInLZ do
                                if oFactory:GetFractionComplete() >= 1 then
                                    bHaveHQFactoriesInZone = true
                                    break
                                    --if oFactory:GetAIBrain() == aiBrain then bHaveHQFactoriesWeOwnInZone = true
                                end
                            end
                        end
                        if not(bHaveHQFactoriesInZone) then
                            ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryAirFactory, M28Engineer.refActionBuildAirFactory)
                            if not(M28Conditions.DoesACUHaveValidOrder(oACU)) then
                                --Move to WZ to build a naval factory if we have none and are adjacent to water
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]) == false and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalFactory) == 0 then
                                    MoveACUToNearbyWaterForFactory(aiBrain, oACU, tLZOrWZData)
                                    --Do we want more power?
                                elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 50 * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultipler] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.3 and not(M28Conditions.HaveLowMass(aiBrain)) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 2 and oACU:HasEnhancement('AdvancedEngineering'))) and (M28Conditions.WantMorePower(iTeam) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.7) then
                                    ACUActionBuildPower(aiBrain, oACU)
                                end
                            end
                        else
                            --Do we want more power?
                            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 50 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.3 and not(M28Conditions.HaveLowMass(aiBrain)) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 2 and oACU:HasEnhancement('AdvancedEngineering'))) and (M28Conditions.WantMorePower(iTeam) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.7) then
                                ACUActionBuildPower(aiBrain, oACU)
                            end
                        end
                    end
                    bProceedWithLogic = false
                end
            elseif iPlateauOrZero == 0 and (tLZOrWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] or M28Map.bIsCampaignMap) and aiBrain[M28Economy.refiOurHighestNavalFactoryTech] == 0 and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) then
                ACUActionBuildFactory(aiBrain, oACU, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, M28UnitInfo.refCategoryNavalFactory, M28Engineer.refActionBuildNavalFactory)
            end

            if bProceedWithLogic then
                --Special telesnipe logic (takes priorioty over running)
                if HaveTelesnipeAction(oACU, tLZOrWZData, tLZOrWZTeamData, aiBrain, iTeam, iPlateauOrZero, iLandOrWaterZone) then
                    if bDebugMessages == true then LOG(sFunctionRef..': ACU is proceeding with a telesnipe action') end
                else

                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if ACU wants to run, Does it want to return to core base='..tostring(DoesACUWantToReturnToCoreBase(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) or false)..'; ACU unit state='..M28UnitInfo.GetUnitState(oACU)..'; Is this core base='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or false)..'; Dist to midpoint='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZData[M28Map.subrefMidpoint])..'; Does ACU want to run='..tostring(DoesACUWantToRun(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) or false)) end
                    if not(oACU:IsUnitState('Building')) and DoesACUWantToReturnToCoreBase(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) and not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZData[M28Map.subrefMidpoint]) <= 10) then
                        ConsiderIfACUNeedsEmergencySupport(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)
                        if bDebugMessages == true then LOG(sFunctionRef..': ACU more than 10 from core base midpoint so will retreat there, ACU dist to this midpoint='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZData[M28Map.subrefMidpoint])..'; Is this core base='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase])) end
                        ReturnACUToCoreBase(oACU, tLZOrWZData, tLZOrWZTeamData, aiBrain, iTeam, iPlateauOrZero, iLandOrWaterZone)
                    elseif DoesACUWantToRun(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) and not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZData[M28Map.subrefMidpoint]) <= 10) then
                        ConsiderIfACUNeedsEmergencySupport(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)
                        oACU[refiTimeLastWantedToRun] = GetGameTimeSeconds()
                        --Retreat to nearest rally (unless we arent in a land zone in which case head towards core base)
                        local bConsiderMexesAndReclaim = false

                        local tRallyPoint
                        if iLandOrWaterZone > 0 and iPlateauOrZero > 0 then
                            --Are we on a different island to our base, and want to move back there?

                            tRallyPoint = M28Land.GetNearestLandRallyPoint(tLZOrWZData, iTeam, iPlateauOrZero, iLandOrWaterZone, 2, true)
                            --If the rally point takes us further away from the closest friendly base, and is more than 50 from the closest friendly base, then head towards the base (exception if rally point is a core base or is a location with friendly PD and/or factories or significantly friendly combat)
                            if M28Utilities.GetDistanceBetweenPositions(tRallyPoint, tLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) >= 50 then
                                local tRallyLZData, tRallyLZTeamData = M28Map.GetLandOrWaterZoneData(tRallyPoint, true, iTeam)

                                if not(tRallyLZTeamData[M28Map.subrefLZbCoreBase]) then
                                    local iRallyThreat = tRallyLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]
                                    if tRallyLZTeamData == tLZOrWZTeamData then iRallyThreat = iRallyThreat - M28UnitInfo.GetCombatThreatRating({oACU}, false, false, false, false, false, false, false, false) end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Rally point is more than 50 from closest friendly base, checking if threat is too low, iRallyThreat='..iRallyThreat..'; Is rally in a core expansion='..tostring(tRallyLZTeamData[M28Map.subrefLZCoreExpansion])) end
                                    if iRallyThreat <= 500 and (not(tRallyLZTeamData[M28Map.subrefLZCoreExpansion]) or tRallyLZTeamData[M28Map.subrefLZSValue] < 220) then --Only consider core expansion if it has significant structure value, e.g. similar to having 1 land factory
                                        if bDebugMessages == true then LOG(sFunctionRef..': Dist from rally to closest base='..M28Utilities.GetDistanceBetweenPositions(tRallyLZTeamData[M28Map.reftClosestFriendlyBase], tRallyLZData[M28Map.subrefMidpoint])..'; Dist from ACU to closest base='..M28Utilities.GetDistanceBetweenPositions(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], oACU:GetPosition())) end
                                        if M28Utilities.GetDistanceBetweenPositions(tRallyLZTeamData[M28Map.reftClosestFriendlyBase], tRallyLZData[M28Map.subrefMidpoint]) > M28Utilities.GetDistanceBetweenPositions(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], oACU:GetPosition()) then
                                            bConsiderMexesAndReclaim = false
                                            --Is our closest friendly base in the same plateau?
                                            local iClosestBasePlateauOrZero, iClosestBaseLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase])
                                            if iClosestBasePlateauOrZero == iPlateauOrZero then
                                                tRallyPoint = {tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][1], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][2], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][3]}
                                                if bDebugMessages == true then LOG(sFunctionRef..': Changed rally point to be the closest friendly base') end
                                            end
                                        end
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': Checking if rally LZ is same as ACU LZ, are they equal='..tostring(tRallyLZData == tLZOrWZData)) end
                                        if tRallyLZData == tLZOrWZData then
                                            if bDebugMessages == true then LOG(sFunctionRef..': ACU health%='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; iRallyThreat='..iRallyThreat) end
                                            if M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.5 and iRallyThreat < 100 then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Want to consider mexes and reclaim') end
                                                bConsiderMexesAndReclaim= true
                                            end
                                        end
                                    end
                                end
                            end
                            --[[GetTravelDistanceBetweenPositions(tStart, tEnd, sPathing)
                            local iTravelDistFromRallyToClosestFriendlyBase

                             = M28Utilities.GetTravelDist--]]


                        else tRallyPoint = M28Map.PlayerStartPoints[oACU:GetAIBrain():GetArmyIndex()]
                        end
                        --If we are already in the zone for the rally point and it has unbuilt mexes or significant reclaim then want to consider getting them
                        if not(bConsiderMexesAndReclaim) or (not(ConsiderBuildingMex(tLZOrWZData, tLZOrWZTeamData, oACU, 15)) and not(ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, M28UnitInfo.GetUnitHealthPercent(oACU) < 0.75, 20))) then
                            M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'Run')
                            if bDebugMessages == true then LOG(sFunctionRef..': Telling ACU to run; ACU orders after this='..reprs(oACU[M28Orders.reftiLastOrders])..'; Is micro active='..tostring(oACU[M28UnitInfo.refbSpecialMicroActive])..'; Nearest land rally point='..repru(M28Land.GetNearestLandRallyPoint(tLZOrWZData, iTeam, iPlateauOrZero, iLandOrWaterZone, 2, true))..'; Rally point='..repru(tRallyPoint)..'; Nearest friendly base='..repru(M28Map.PlayerStartPoints[oACU:GetAIBrain():GetArmyIndex()])..'; Dist from rally point to friendly base='..M28Utilities.GetDistanceBetweenPositions(tRallyPoint, M28Map.PlayerStartPoints[oACU:GetAIBrain():GetArmyIndex()])) end
                        elseif bDebugMessages == true then LOG(sFunctionRef..': Are either building mex or getting reclaim in this zone')
                        end
                    else
                        --Nearby enemy naval units
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if nearby naval units that should send ACU to try and fight; M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbNoAvailableTorpsForEnemies] ='..tostring(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbNoAvailableTorpsForEnemies])..'; ACU health='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; Is table of adjacent WZs empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]))) end
                        local iWaterZoneEnemyRangeOverride
                        if M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.3 then iWaterZoneEnemyRangeOverride = 10 end
                        if iPlateauOrZero > 0 and M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbNoAvailableTorpsForEnemies] and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefAdjacentWaterZones]) == false and ConsiderAttackingNearbyNavalUnits(tLZOrWZData, tLZOrWZTeamData, oACU, iWaterZoneEnemyRangeOverride) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Telling ACU to attack nearby enemy navla units') end

                        else
                            --Part-built or unbuilt mex in build range of ACU when no enemies in the LZ
                            if bDebugMessages == true then LOG(sFunctionRef..': Will consider building mex if one is almost in build range and no enemy combat threat in this LZ/WZ, or we outrange enemy and enemy isnt in our range; threat='..tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]) end
                            local bConsiderBuildingNearbyMex = true
                            --Part-built or unbuilt mex in build range of ACU when no enemies in the LZ
                            if bDebugMessages == true then LOG(sFunctionRef..': Will consider building mex if one is almost in build range and no enemy combat threat in this LZ/WZ, or we outrange enemy and enemy isnt in our range; threat='..tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]) end
                            local bConsiderBuildingNearbyMex = true
                            local iNearbyMexRangeThreshold = 2
                            if tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] == 0 then
                                --Do nothing - want to consider building mex
                            elseif tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 200 then
                                bConsiderBuildingNearbyMex = false
                                if bDebugMessages == true then LOG(sFunctionRef..':Too much threat in this zone') end
                            else
                                --Enemy has small threat, so might want to build mex rather than attack
                                if math.max(tLZOrWZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange], tLZOrWZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange], tLZOrWZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange]) >= oACU[M28UnitInfo.refiDFRange] then
                                    bConsiderBuildingNearbyMex = false
                                    if bDebugMessages == true then LOG(sFunctionRef..'; We dont outrange enemy so wont consider building mex') end
                                else
                                    --We outrange enemy, which is a small threat, so consider building mex instead of pursuing enemy
                                    local tClosestMex
                                    local iClosestMex = 10000
                                    local iCurDist
                                    if (oACU:IsUnitState('Building') or oACU:IsUnitState('Repairing')) and EntityCategoryContains(M28UnitInfo.refCategoryMex, oACU:GetFocusUnit().UnitId) then
                                        if M28Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat, oACU:GetPosition(), oACU[M28UnitInfo.refiDFRange], 'Enemy')) == false then
                                            bConsiderBuildingNearbyMex = false
                                        end
                                    elseif M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations]) then
                                        bConsiderBuildingNearbyMex = false
                                        if bDebugMessages == true then LOG(sFunctionRef..': No unbuilt locations for this zone') end
                                    else

                                        for iMex, tMex in tLZOrWZData[M28Map.subrefMexUnbuiltLocations] do
                                            iCurDist = M28Utilities.GetDistanceBetweenPositions(tMex, oACU:GetPosition())
                                            if iCurDist < iClosestMex then
                                                iClosestMex = iCurDist
                                                tClosestMex = {tMex[1], tMex[2], tMex[3]}
                                            end
                                        end
                                        if iClosestMex <= oACU[M28UnitInfo.refiDFRange] + iNearbyMexRangeThreshold then
                                            --Have an unbuilt mex in or near our build range, so now check if enemy is closer to the mex than we are/is in range of the mex
                                            local bEnemyAlmostInRangeOfMex = false
                                            for iUnit, oUnit in tLZOrWZTeamData[M28Map.subrefTEnemyUnits] do
                                                if M28UnitInfo.IsUnitValid(oUnit) then
                                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tClosestMex, oUnit:GetPosition())
                                                    if iCurDist - oUnit[M28UnitInfo.refiCombatRange] <= 2 then
                                                        bEnemyAlmostInRangeOfMex = true
                                                        break
                                                    end
                                                end
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': bEnemyAlmostInRangeOfMex='..tostring(bEnemyAlmostInRangeOfMex)) end
                                            if bEnemyAlmostInRangeOfMex then
                                                bConsiderBuildingNearbyMex = false
                                            end
                                        else
                                            bConsiderBuildingNearbyMex = false
                                        end
                                    end


                                end
                            end
                            --Part-built or unbuilt mex in build range of ACU when no enemies in the LZ
                            if bDebugMessages == true then LOG(sFunctionRef..': Will consider building mex if one is almost in build range and no enemy combat threat in this LZ/WZ, threat='..tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; bConsiderBuildingNearbyMex='..tostring(bConsiderBuildingNearbyMex)) end
                            if not(bConsiderBuildingNearbyMex) or not(ConsiderBuildingMex(tLZOrWZData, tLZOrWZTeamData, oACU, 2)) then
                                --Priority reclaim - if reclaim that is in ACU build radius and have <30% mass stored even if nearby enemies (provided arent in range, unless shot is blocked), if have no upgrade or T2 upgrade
                                if bDebugMessages == true then LOG(sFunctionRef..': About to check for priority reclaim, mass stored%='..aiBrain:GetEconomyStoredRatio('MASS')..'; ACU upgrade count='..oACU[refiUpgradeCount]..'; Does ACU have adanced engineering='..tostring(oACU:HasEnhancement('AdvancedEngineering'))..'; ACU health %='..M28UnitInfo.GetUnitHealthPercent(oACU)) end
                                if aiBrain:GetEconomyStoredRatio('MASS') < 0.3 and (oACU[refiUpgradeCount] == 0 or oACU:HasEnhancement('AdvancedEngineering')) and M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.9 and
                                        (oACU[M28UnitInfo.refbLastShotBlocked] or M28Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryNavalSurface, oACU:GetPosition(), oACU[M28UnitInfo.refiDFRange], 'Enemy'))) and
                                        ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, true) then
                                    --ACU wants to get reclaim
                                    if bDebugMessages == true then LOG(sFunctionRef..': ACU will get reclaim') end
                                else

                                    --Check if our economy is so good that we want to run next cycle if enemy has T3 land or air
                                    if not(M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs]) and (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] >= 30 or aiBrain[M28Economy.refiGrossMassBaseIncome] >= 16 or (aiBrain[M28Economy.refiGrossMassBaseIncome] >= 11 + oACU[refiUpgradeCount] and (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestEnemyAirTech] >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 or M28UnitInfo.GetUnitHealthPercent(oACU) < 0.8))) then
                                        --Consider running if enemy is at T3 or has large air to ground threat, or we have built ltos of T3
                                        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] >= 3 or M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestEnemyAirTech] >= 3 or M28Team.tTeamData[aiBrain.M28Team][M28Team.refbBuiltLotsOfT3Combat] or M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftTeamEngineersBuildingExperimentals]) == false then
                                            M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs] = true
                                            if bDebugMessages == true then LOG(sFunctionRef..': Dangerous for ACU due to general mass income level so will retreat with ACU if not in adjacent LZ from now on. M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]..'; M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestEnemyAirTech]='..M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestEnemyAirTech]..'; M28Team.tTeamData[aiBrain.M28Team][M28Team.refbBuiltLotsOfT3Combat]='..tostring(M28Team.tTeamData[aiBrain.M28Team][M28Team.refbBuiltLotsOfT3Combat])..'; Is table of engis building experimetnals empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftTeamEngineersBuildingExperimentals]))) end
                                        end
                                    end

                                    --If have orders for ACU but no land zone then wait until it is in a land zone again
                                    if not(iLandOrWaterZone) or (iPlateauOrZero == 0 and not(tLZOrWZTeamData[M28Map.subrefWZbContainsUnderwaterStart])) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': ACU isnt in a land zone, if has no orders will tell it to retreat to start position, oACU[M28Orders.refiOrderCount]='..oACU[M28Orders.refiOrderCount]..'; ACU unit state='..M28UnitInfo.GetUnitState(oACU)..'; reprs of last order='..reprs(oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]])) end
                                        if oACU[M28Orders.refiOrderCount] == 0 then
                                            M28Orders.IssueTrackedMove(oACU, M28Map.PlayerStartPoints[oACU:GetAIBrain():GetArmyIndex()], 5, false, 'NLZRun')
                                        elseif oACU:IsUnitState('Attacking') and M28UnitInfo.IsUnitUnderwater(oACU) and not(tLZOrWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) then
                                            --Came across rare issue where ACU has attack-move order, that doesnt get refreshed, but ACU gets stuck not moving in the water, its unit state when this happened was attacking, and its last order was refiOrderIssueAggressiveMove; the below is a workaround as in some cases want ACU to advance where this is the case, in others want it to retreat
                                            local iCurWaterZone = M28Map.GetWaterZoneFromPosition(oACU:GetPosition())
                                            if M28UnitInfo.GetUnitHealthPercent(oACU) < 0.95 or not(iCurWaterZone) then
                                                M28Orders.IssueTrackedMove(oACU, M28Map.PlayerStartPoints[oACU:GetAIBrain():GetArmyIndex()], 5, false, 'NLZRn')
                                            else
                                                --Look for nearest land zone and move here
                                                local iPond = M28Map.tiPondByWaterZone[iCurWaterZone]
                                                local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iCurWaterZone]
                                                local tLZMidpointToMoveTo
                                                if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
                                                    for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                                                        local tAltLZ = M28Map.tAllPlateaus[tSubtable[M28Map.subrefWPlatAndLZNumber][1]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefWPlatAndLZNumber][2]]
                                                        if tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsSupport] then
                                                            tLZMidpointToMoveTo = tAltLZ[M28Map.subrefMidpoint]
                                                            break
                                                        end
                                                    end
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': tLZMidpointToMoveTo after checking if have adjacent land zones that want support='..repru(tLZMidpointToMoveTo)) end
                                                if not(tLZMidpointToMoveTo) then tLZMidpointToMoveTo = M28Map.PlayerStartPoints[oACU:GetAIBrain():GetArmyIndex()] end
                                                M28Orders.IssueTrackedMove(oACU, tLZMidpointToMoveTo, 5, false, 'ACUWtr')

                                            end
                                        end
                                    else
                                        --Are there enemies in this LZ? If so then attack them
                                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy units for this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]))) end
                                        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) == false and iPlateauOrZero > 0 and AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                                            --(Do nothing further - will ahve given the order)
                                        else
                                            if oACU[refbDoingInitialBuildOrder] then
                                                GetACUEarlyGameOrders(aiBrain, oACU)

                                                --Have we finished our initial build order? (even if we stil lahve some early game orders)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Checking if have finished initial build order, Economy stored mass='..aiBrain:GetEconomyStored('MASS')..'; Gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; Gross energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]) end
                                                if not(oACU:IsUnitState('Building')) and aiBrain:GetEconomyStored('MASS') == 0 and aiBrain[M28Economy.refiGrossMassBaseIncome] >= 0.3 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 15 then
                                                    bDoingInitialBuildOrder = false
                                                end
                                            else
                                                --If we are reclaiming or building then dont do anything
                                                if bDebugMessages == true then
                                                    LOG(sFunctionRef..': Arent doing initial build order and dont want to run, ACU unit state='..M28UnitInfo.GetUnitState(oACU)..'; Brain mass stored%='..aiBrain:GetEconomyStoredRatio('MASS')..'; If are nearby enemies then will list out, is table of nearby enemies empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]))..'; oACU[M28UnitInfo.refiDFRange]='..(oACU[M28UnitInfo.refiDFRange] or 'nil')..'; ACU position='..repru(oACU:GetPosition())..'; ACU team='..oACU:GetAIBrain().M28Team)
                                                    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                                                        LOG(sFunctionRef..': are we close to nearby units='..tostring(M28Conditions.CloseToEnemyUnit(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftoNearestDFEnemies], 12 , aiBrain.M28Team, true, math.max(25, oACU[M28UnitInfo.refiDFRange] + 12))))
                                                        for iUnit, oUnit in tLZOrWZTeamData[M28Map.reftoNearestDFEnemies] do
                                                            LOG(sFunctionRef..': Entry '..iUnit..' is unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' which is '..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition())..' with range '..(oUnit[M28UnitInfo.refiDFRange] or 'nil'))
                                                        end
                                                    end
                                                end
                                                --No nearby enemies - consider building power if have low level of it and lots of mass
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want more power for high mass levels, Is table of nearest DF enemies empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]))..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; not(M28Conditions.HaveLowMass(aiBrain)='..tostring(not(M28Conditions.HaveLowMass(aiBrain)))..'; Want more power='..tostring(M28Conditions.WantMorePower(iTeam))) end
                                                if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 50 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.3 and not(M28Conditions.HaveLowMass(aiBrain)) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 2 and oACU:HasEnhancement('AdvancedEngineering'))) and (M28Conditions.WantMorePower(iTeam) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.7) then
                                                    ACUActionBuildPower(aiBrain, oACU)
                                                    --Is there an enemy unit nearby that we want to attack?
                                                elseif M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoNearestDFEnemies]) == false and M28Conditions.CloseToEnemyUnit(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftoNearestDFEnemies], 12 , aiBrain.M28Team, true, math.max(25, oACU[M28UnitInfo.refiDFRange] + 12)) and AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Are close to enemy units so will attack rather than considering upgrades or building mexes etc.') end
                                                else
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if ACU unit state not important so we can consider doing other things, ACU state='..M28UnitInfo.GetUnitState(oACU)..'; Mass stored ratio='..aiBrain:GetEconomyStoredRatio('MASS')..'; Is unit state building='..tostring(oACU:IsUnitState('Building'))..'; Is unit state repairing='..tostring(oACU:IsUnitState('Repairing'))..'; Is unit state reclaiming='..tostring(oACU:IsUnitState('Reclaiming'))..'; Is unit state guarding='..tostring(oACU:IsUnitState('Guarding'))) end
                                                    if not(oACU:IsUnitState('Building')) and (not(oACU:IsUnitState('Repairing')) or oACU:IsUnitState('Guarding')) and (not(oACU:IsUnitState('Reclaiming')) or aiBrain:GetEconomyStoredRatio('MASS') >= 0.8) and not(oACU:IsUnitState('Capturing')) then
                                                        --Do we want to get an upgrade?
                                                        local sUpgradeToGet = GetACUUpgradeWanted(oACU)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Do we have an upgrade we want to get? sUpgradeToGet='..(sUpgradeToGet or 'nil')) end
                                                        if sUpgradeToGet then
                                                            --Are we safe to get the upgrade here? if not then retreat
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Will check if safe to get upgrade for oACU, oACU='..(oACU.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oACU) or 'nil')..'; Brain='..oACU:GetAIBrain().Nickname) end
                                                            if M28Conditions.SafeToUpgradeUnit(oACU) then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Safe to get upgrade here so will proceed with upgrading ACU, sUpgradeToGet='..(sUpgradeToGet or 'nil')..' brain='..oACU:GetAIBrain().Nickname..'; Has enhancement='..tostring(oACU:HasEnhancement(sUpgradeToGet))) end
                                                                M28Orders.IssueTrackedEnhancement(oACU, sUpgradeToGet, false, 'ACUUp')
                                                            else
                                                                --Retreat
                                                                local tRallyPoint = M28Land.GetNearestLandRallyPoint(tLZOrWZData, oACU:GetAIBrain().M28Team, iPlateauOrZero, iLandOrWaterZone, 2)
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Not safe to get upgrade so want to retreat until it is. tRallyPoint='..repru(tRallyPoint)..'; ACU position='..repru(oACU:GetPosition())) end
                                                                M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'R4U')
                                                            end
                                                        else
                                                            --We dont want an upgrade, and have no enemies in this LZ, but there might be enemies nearby (e.g. in an adjacent land zone); there might also be mexes to build or reclaim to get in this LZ - decide on what we want to do
                                                            --Does the LZ have uncalimed mexes?
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Will consider if we want to build a mex if there are any unclaimed') end
                                                            if not(ConsiderBuildingMex(tLZOrWZData, tLZOrWZTeamData, oACU)) then
                                                                --Water zone specific - if underwater and is an underwater start position then do nothing
                                                                if iPlateauOrZero > 0 or not(tLZOrWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) then

                                                                    --Do we want another land factory?
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': No mexes to build ni this LZ, seeing if we want another land factory') end
                                                                    if not(ConsiderGettingExtraLandFactory(tLZOrWZData, tLZOrWZTeamData, oACU, iPlateauOrZero, iLandOrWaterZone)) then
                                                                        --Are there enemies in an adjacent LZ? in which case want to consider attacking them
                                                                        if ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, true) or (M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) == false and AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)) then
                                                                            if bDebugMessages == true then LOG(sFunctionRef..': Will try getting reclaim in range or attacking enemy in this zone') end
                                                                        else
                                                                            --ACU is in a zone with lots of reclaim - consider prioritising this over attacking nearby enemies
                                                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if reclaim in this zone valuable enough to focus on it instead of enemies; Cur mass stored='..aiBrain:GetEconomyStoredRatio('MASS')..'; Reclaim in zone='..tLZOrWZData[M28Map.subrefTotalMassReclaim]..'; S value of zone='..tLZOrWZTeamData[M28Map.subrefLZSValue]) end
                                                                            --Only consider reclaim if min value of a wreck is 40 - dont want to waste ACU time on harder to get reclaim
                                                                            if tLZOrWZData[M28Map.subrefTotalMassReclaim] >= 300 and not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and tLZOrWZTeamData[M28Map.subrefLZSValue] <= 200 and aiBrain:GetEconomyStoredRatio('MASS') <= 0.6 and ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, false, 40) then
                                                                                if bDebugMessages == true then LOG(sFunctionRef..': Lots of reclaim in area so will focus on that') end
                                                                            else
                                                                                if AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Attacking enemies in adjacent zone') end
                                                                                else
                                                                                    local bOnlyConsiderInBuildRange = false
                                                                                    if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and (not(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) or (GetGameTimeSeconds() <= 300 and aiBrain[M28Economy.refiGrossMassBaseIncome] <= 4)) then bOnlyConsiderInBuildRange = true end
                                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Dont want to build mex, will cehck if want to get reclaim, bOnlyConsiderInBuildRange='..tostring(bOnlyConsiderInBuildRange)) end
                                                                                    if not(ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU, bOnlyConsiderInBuildRange)) then
                                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Dont want to get reclaim, will see if want to attack adjacent enemies; are there adjacent enemies='..tostring(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]='..tostring(tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ])) end
                                                                                        if tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and AttackNearestEnemyWithACU(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU) then
                                                                                            --Do nothing - will have given the order
                                                                                        else
                                                                                            if bDebugMessages == true then LOG(sFunctionRef..': Will consider moving to another land zone as nothing to do in this one') end
                                                                                            if not(MoveToOtherLandZone(iPlateauOrZero, tLZOrWZData, iLandOrWaterZone, oACU)) then

                                                                                                --Backup - assist nearest factory
                                                                                                if bDebugMessages == true then LOG(sFunctionRef..': ACU no longer doing iniitial BO; Will give backup assist factory order if not building or guarding, ACU unit state='..M28UnitInfo.GetUnitState(oACU)) end
                                                                                                if not(oACU:IsUnitState('Building')) and not(oACU:IsUnitState('Guarding')) then
                                                                                                    local tAllFactories = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryFactory, false, true)
                                                                                                    if M28Utilities.IsTableEmpty(tAllFactories) == false then
                                                                                                        local oNearestFactory = M28Utilities.GetNearestUnit(tAllFactories, oACU:GetPosition(), true, M28Map.refPathingTypeHover)
                                                                                                        if M28UnitInfo.IsUnitValid(oNearestFactory) then
                                                                                                            M28Orders.IssueTrackedGuard(oACU, oNearestFactory, false)
                                                                                                        end
                                                                                                    end
                                                                                                end
                                                                                            end
                                                                                        end
                                                                                    end
                                                                                end
                                                                            end
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    if oACU[refbACUHasBeenGivenABuildOrderRecently] and not(M28Conditions.DoesACUHaveValidOrder(oACU)) then M28Engineer.ClearEngineerTracking(oACU) end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, does ACU have valid order='..tostring(M28Conditions.DoesACUHaveValidOrder(oACU))) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DoWeStillWantToBeAggressiveWithACU(oACU)
    --Intended for early game mostly on smaller maps to make ACU more aggressive
    local bStillBeAggressive = true
    local aiBrain = oACU:GetAIBrain()
    local iTeam = aiBrain.M28Team
    if M28Team.tTeamData[iTeam][M28Team.refbDangerousForACUs] then
        bStillBeAggressive = false
    else
        --If significant time elapsed then remove this flag, unless lots of reclaim in cur land zone
        local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oACU:GetPosition(), true, oACU:GetAIBrain().M28Team)
        if GetGameTimeSeconds() >= 600 and (GetGameTimeSeconds() >= 900 or tLZOrWZData[M28Map.subrefTotalMassReclaim] < 400) then
            bStillBeAggressive = false
        else
            local iThresholdFactor = 1 + (M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] - 1) * 0.25
            if tLZOrWZData[M28Map.subrefTotalMassReclaim] > 400 then iThresholdFactor = iThresholdFactor + 0.4 end
            if M28UnitInfo.GetUnitHealthPercent(oACU) <= 0.3 then bStillBeAggressive = false
            elseif aiBrain[M28Economy.refiGrossMassBaseIncome] >= 5 * iThresholdFactor or (aiBrain[M28Economy.refiOurHighestFactoryTechLevel] >= 2 and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryAllAir + M28UnitInfo.refCategoryLandCombat - categories.TECH1) >= 4) then
                bStillBeAggressive = false
            elseif M28Map.iMapSize > 512 then
                bStillBeAggressive = false
            elseif not(aiBrain[M28Map.refbCanPathToEnemyBaseWithLand]) then
                bStillBeAggressive = false
            elseif M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU] and oACU[refiUpgradeCount] == 0 then
                bStillBeAggressive = false
            elseif M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat) >= 50 * iThresholdFactor then
                bStillBeAggressive = false
            elseif M28Map.bIsCampaignMap then
                bStillBeAggressive = false
            end
        end
    end

    return bStillBeAggressive
end

function ManageACU(aiBrain, oACUOverride)
    local sFunctionRef = 'ManageACU'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --First get our ACU
    local oACU = oACUOverride
    local iWaitCount = 0
    local iACUSearchCategory = categories.COMMAND
    while not(oACU) do
        local tOurACU = aiBrain:GetListOfUnits(iACUSearchCategory, false, true)
        if M28Utilities.IsTableEmpty(tOurACU) == false then
            for _, oUnit in tOurACU do
                oACU = oUnit
                break
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Looking for ACU that we own, is oACU valid='..tostring(M28UnitInfo.IsUnitValid(oACU))) end
        if oACU then
            oACU[refbDoingInitialBuildOrder] = true
            break
        end
        iWaitCount = iWaitCount + 1
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if iWaitCount >= 360 then --No ACU after 6m, see if we have any SACU we could use instead
            iACUSearchCategory = iACUSearchCategory + categories.SUBCOMMANDER
            if iWaitCount >= 480 then
                iACUSearchCategory = iACUSearchCategory + M28UnitInfo.refCategoryEngineer
                if iWaitCount >= 600 then
                    M28Utilities.ErrorHandler('No ACU, SACU or engineer after '..iWaitCount..' ticks so will abort')
                    break
                end
            end
        end
    end

    if oACU then

        --Wait until ok for us to give orders
        if bDebugMessages == true then LOG(sFunctionRef..': Will wait until after 4.5s before giving ACU orders, gametime='..GetGameTimeSeconds()) end
        while (GetGameTimeSeconds() <= 4.5) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end

        --Campaign specific - check if friendly units should gift to M28AI
        if M28Map.bIsCampaignMap then
            ForkThread(M28Overseer.CheckForAlliedCampaignUnitsToShareAtGameStart, oACU:GetAIBrain())
        end

        if M28UnitInfo.IsUnitValid(oACU) and not(M28UnitInfo.IsUnitValid(aiBrain[refoPrimaryACU])) then
            aiBrain[refoPrimaryACU] = oACU
        end

        --Make sure ACU is recorded
        M28Team.AssignUnitToLandZoneOrPond(aiBrain, oACU, false, false, true)

        --Make sure we have recorded this zone as a core zone
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oACU:GetPosition())
        if iPlateauOrZero > 0 and (iLandOrWaterZone or 0) > 0 then

        end

        oACU[refiUpgradeCount] = 0
        oACU[refbUseACUAggressively] = true
        while M28UnitInfo.IsUnitValid(oACU) do
            oACU[refbTreatingAsACU] = true
            if oACU[refbUseACUAggressively] then
                oACU[refbUseACUAggressively] = DoWeStillWantToBeAggressiveWithACU(oACU)
            end

            ForkThread(GetACUOrder, aiBrain, oACU)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function ConsiderIfACUNeedsEmergencySupport(iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tLZOrWZTeamData, oACU)
    --Updates flag on the zone ACU is in to indicate it needs help from tanks (i.e. it's facing a ground based threat)
    local sFunctionRef = 'ConsiderIfACUNeedsEmergencySupport'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; Health percent='..M28UnitInfo.GetUnitHealthPercent(oACU)..'; Enemies in this or adjacent LZ='..tostring(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or false)..'; Core bse='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or false)) end
    if iPlateauOrZero > 0 and tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and M28UnitInfo.GetUnitHealthPercent(oACU) < 0.98 and not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) then
        --ACU is damaged to some extent, outside core zone, and there are enemy ground units nearby
        local iEnemyCombatThreat = (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
        local iTeam = oACU:GetAIBrain().M28Team
        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false then
            --Include enemy combat units in adjacent zones if they are close to the ACU
            local tEnemyUnitsNearby = {}
            local iDistThreshold = 30 --This much dist until the unit will be in range of ACU for it to be included
            for iEntry, iAdjLZ in tLZOrWZData[M28Map.subrefLZAdjacentLandZones] do
                local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                if (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) > 50 and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftoNearestCombatEnemies]) == false then
                    for iUnit, oUnit in tAdjLZTeamData[M28Map.reftoNearestCombatEnemies] do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[M28UnitInfo.refiDFRange]='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Dist to ACU='..M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition())) end
                            if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then
                                if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition()) - oUnit[M28UnitInfo.refiDFRange] <= iDistThreshold then
                                    table.insert(tEnemyUnitsNearby, oUnit)
                                end
                            end
                        end
                    end
                end
            end

            if M28Utilities.IsTableEmpty(tEnemyUnitsNearby) == false then
                iEnemyCombatThreat = iEnemyCombatThreat + M28UnitInfo.GetCombatThreatRating(tEnemyUnitsNearby, true, false, false, false, false, false, false)
            end
        end
        local iThreatRatio = 0.8
        if oACU[refbUseACUAggressively] then iThreatRatio = 1.1 end
        if M28UnitInfo.GetUnitHealthPercent(oACU) >= 0.75 then iThreatRatio = iThreatRatio * 1.26 end --i.e. if just us vs enemy ACU with similar stats shouldnt trigger unless our healt his getting low
        if bDebugMessages == true then LOG(sFunctionRef..': ACU threat='..M28UnitInfo.GetCombatThreatRating({oACU}, false, false)..'; iThreatRatio='..iThreatRatio..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; Is table of ACUs in the LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefAlliedACU]))) end
        if M28UnitInfo.GetCombatThreatRating({oACU}, false, false) * iThreatRatio < iEnemyCombatThreat then
            tLZOrWZTeamData[M28Map.refbACUInTrouble] = true
            local iACUValueIncrease = GetValueIncreaseForACUInTrouble(iTeam)
            tLZOrWZTeamData[M28Map.subrefLZTValue] = math.max((tLZOrWZTeamData[M28Map.subrefLZTValue] or 0), iACUValueIncrease)
            if bDebugMessages == true then LOG(sFunctionRef..': Flagging that ACU is in trouble, tLZTeamData[M28Map.subrefLZTValue]='..(tLZOrWZTeamData[M28Map.subrefLZTValue] or 'nil')) end
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefAlliedACU]) then M28Utilities.ErrorHandler('ACU in trouble but not recorded against this LZ') end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetValueIncreaseForACUInTrouble(iTeam)
    local iCurValue = 1000
    --Increase by more if in noshare or assassination
    if ScenarioInfo.Options.Victory == "demoralization" then
        if not(ScenarioInfo.Options.Share == 'FullShare') or M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] == 1 then
            iCurValue = iCurValue + 20000
        end
    end
    return iCurValue
end