---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 04/03/2023 08:22
---

local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
--local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')

--Unit variables
refiTimeOfLastWZAssignment = 'M28WZLastAssignmentTime' --GameTimeSeconds
refiCurrentWZAssignmentValue = 'M28WZAssignmentVal' --Value of current assignment
refiCurrentAssignmentWaterZone = 'M28WZCurAssign'
reftiRadarWaterZonesCoveredByTeam = 'M28RadarWZCovered' --against radar, [x] is the team number, returns table of water zones it provides the best intel for
reftiSonarWaterZonesCoveredByTeam = 'M28SonarWZCovered' --against radar, [x] is the team number, returns table of water zones it provides the best intel for
refiWZToMoveTo = 'M28WZToMoveTo' --e.g. aginast scouts
refbActiveRaider = 'M28NRaid' --true if raider
refiWZOfFactory = 'M28NRaFZ' --water zone of the factory that produced this raider - used so can track formerly active raiders
reftBlockedShotLocationByPond = 'M28BlShPn' --[x] is the pond ref; returns a position for where we think DF units should move to not have their shot blocked

--aiBrian variables
refiPriorityPondRef = 'M28PriorityPondRef' --against aibrain, returns the pond ref (naval segment group) that we think is most important to that aibrain (only recorded for M27 brains)
reftiPondThreatToUs = 'M28PondThreatToUs' --against aiBrain, [x] is the pond ref (naval segment group), returns the 'mex value' of that pond when considering mexes within 40% of our base (mod distance).  Only recorded for ponds where we have identified a naval yard build location
reftiPondValueToUs = 'M28PondValueToUs' --against aiBrain, [x] is the pond ref (naval segment group), returns the expected value of the pond if we have naval control of it (so ignores distance reductions that are used to decide if we want to build navy there in the first place)
refbEnemyNavyPreventingBuildingNavy = 'M28PondEnemyNavyNearBuildLocation' --against aibrain, true if enemy has navy near to the build location

--Global variables
tWZRefreshCountByTeam = {}
iLongRangeThreshold = 50 --I.e. units with this or better range get recorded in table of long range threats
iTicksPerNavyCycle = 11

tbBlueprintsAddedToTempTable = {} --[x] is the blueprintID, returns true if have shown a waraning message about the unit being in the temp unit table (so we dont fill up the log)

function GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNearestWaterRallyPoint'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; iPond='..(iPond or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'; iTeam='..(iTeam or 'nil')..'; Is table of rally points by pond for this pond empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond]) == false then
        local iCurDist
        local iClosestDist = 100000
        local iClosestWZRef

        for iEntry, iAltWZ in M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond] do
            if bDebugMessages == true then LOG(sFunctionRef..': Looking for rally point for iPond '..iPond..'; iWaterZone '..iWaterZone..'; Considering iAltWZ='..iAltWZ) end
            if iAltWZ == iWaterZone then
                iClosestWZRef = iAltWZ
                break
            else
                local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAltWZ]
                if tAltWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZbCoreBase] then
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], tAltWZData[M28Map.subrefMidpoint])
                    if iCurDist < iClosestDist then
                        iClosestDist = iCurDist
                        iClosestWZRef = iAltWZ
                    end
                end
            end
        end
        if not(iClosestWZRef) then iClosestWZRef = iWaterZone end
        --Land zone will consider moving 2 towards the rally ponit land zone; have left this out for water zones for now but could add in if it becomes an issue

        --Water zone specific - if we have a naval fac in this water zone, then choose that as the retreat point
        local tRallyWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iClosestWZRef]
        local tRallyWZTeamData = tRallyWZData[M28Map.subrefWZTeamData][iTeam]

        if M28Utilities.IsTableEmpty(tRallyWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            local tFriendlyFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryAllHQFactories,     tRallyWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tFriendlyFactories) == false then
                return M28Utilities.MoveInDirection(tFriendlyFactories[1]:GetPosition(), M28Utilities.GetAngleFromAToB(tFriendlyFactories[1]:GetPosition(), tRallyWZData[M28Map.subrefMidpoint]), 8, true, false, true)
            end
        end

        return {tRallyWZData[M28Map.subrefMidpoint][1], tRallyWZData[M28Map.subrefMidpoint][2], tRallyWZData[M28Map.subrefMidpoint][3]}
    else
        RefreshWaterRallyPoints(iTeam, iPond)
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond]) then
            M28Utilities.ErrorHandler('No rally point for Pond '..(iPond or 'nil')..' WZ'..(iWaterZone or 'nil')..'; iTeam='..iTeam..' even after refreshing, will return current midpoint', true)
        end
        return {tWZData[M28Map.subrefMidpoint][1], tWZData[M28Map.subrefMidpoint][2], tWZData[M28Map.subrefMidpoint][3]}
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshWaterRallyPoints(iTeam, iPond)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshWaterRallyPoints'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for team '..iTeam..' at time='..GetGameTimeSeconds()) end

    if not(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond]) then M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond] = {} end
    local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
    if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones]) then M28Utilities.ErrorHandler('No water zones listed for iPond='..iPond)
    else
        M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond] = {}
        for iWaterZone, tWZData in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones] do
            if tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZbCoreBase] then
                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tWZData[M28Map.subrefMidpoint]) then
                    table.insert(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond], iWaterZone)
                    if bDebugMessages == true then LOG(sFunctionRef..': Added iWaterZone='..(iWaterZone or 'nil')..' as a water zone rally for pond '..iPond..' based on core base flag') end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Considering pond '..iPond..'; Is table of water zone rally points by pond empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond]))) end
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond]) then
            --Dont have any core WZ, so need to pick the WZ whose midpoint is closest to a base - filter to just the water zones that are adjacent to a LZ unless are a campaign map in which case consider the closest WZ to the closest base
            local iCurDistToRallyLZ
            local iClosestDistToRallyLZ = 100000
            local iClosestWZRef
            local iPlateau
            for iWaterZone, tWZData in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones] do
                iPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tWZData[M28Map.subrefMidpoint])
                if iPlateau then break end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will see if nearby land zone rally points to any water zones, iPlateau='..(iPlateau or 'nil')..'; Is table of rally point land zones for this plateau empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau]))) end
            if iPlateau and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau]) == false then
                --For campaign maps check all zones, i..e will only do the 'consider zones with adjacent land zones' test for non-campaign maps only
                if bDontCheckPlayableArea then
                    for iWaterZone, tWZData in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones] do
                        --Does the WZ have adjacent LZ?
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iWaterZone='..iWaterZone..'; Is the table of adjacent land zones empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]))) end
                        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
                            --Search rally points for this plateau and get the closest
                            for iEntry, iAltLZ in M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau] do
                                iCurDistToRallyLZ = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAltLZ][M28Map.subrefMidpoint])
                                if bDebugMessages == true then LOG(sFunctionRef..': iCurDistToRallyLZ='..iCurDistToRallyLZ..'; iClosestDistToRallyLZ='..iClosestDistToRallyLZ) end
                                if iCurDistToRallyLZ < iClosestDistToRallyLZ then
                                    iClosestDistToRallyLZ = iCurDistToRallyLZ
                                    iClosestWZRef = iWaterZone
                                end
                            end
                        end
                    end
                end
            end
            --Check all zones without the 'adjacent to land zone' restriction if we dont have any water zone
            if bDebugMessages == true then LOG(sFunctionRef..': iClosestWZRef under default approach='..(iClosestWZRef or 'nil')..'; if is nil then will try every WZ and get closest to base') end
            if not(iClosestWZRef) then
                for iWaterZone, tWZData in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones] do
                    if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tWZData[M28Map.subrefMidpoint]) then
                        local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                        iCurDistToRallyLZ = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], tWZTeamData[M28Map.reftClosestFriendlyBase])
                        if iCurDistToRallyLZ < iClosestDistToRallyLZ then
                            iClosestDistToRallyLZ = iCurDistToRallyLZ
                            iClosestWZRef = iWaterZone
                        end
                    end
                end
            end

            if iClosestWZRef then
                table.insert(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond], iClosestWZRef)
                if bDebugMessages == true then LOG(sFunctionRef..': Added iClosestWZRef='..(iClosestWZRef or 'nil')..' as a water zone rally') end
            end
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef..': End of code, repru of rally points by pond '..iPond..' for team '..iTeam..'='..repru(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond]))
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateUnitPositionsAndWaterZone(aiBrain, tUnits, iTeam, iRecordedWaterZone, bUseLastKnownPosition, bAreAirUnits, tWZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
    --Similar to UpdateUnitPositionsAndLandZone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateUnitPositionsAndWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iRevisedIndex = 1
    local iTableSize = table.getn(tUnits)
    local iActualWaterZone
    local iUnitSegmentX, iUnitSegmentZ
    local UpdateUnitLastKnownPosition = M28Team.UpdateUnitLastKnownPosition
    local bUseActualPositionIfEnemy = false
    if not(bUseLastKnownPosition) or (tWZTeamData[M28Map.refiRadarCoverage] or 0) >= 100 then bUseActualPositionIfEnemy = true end
    if bUpdateTimeOfLastEnemyPositionCheck and not(bUseLastKnownPosition) then tWZTeamData[M28Map.subrefiTimeOfLastEnemyUnitPosUpdate] = GetGameTimeSeconds() end
    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, time='..GetGameTimeSeconds()..'; iRecordedWaterZone='..iRecordedWaterZone..'; iTableSize='..iTableSize) end
    for iOrigIndex=1, iTableSize do
        if not(tUnits[iOrigIndex]) or tUnits[iOrigIndex].Dead then
            --Remove the entry
            tUnits[iOrigIndex] = nil
            if bDebugMessages == true then LOG(sFunctionRef..': Unit '..(tUnits[iOrigIndex].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tUnits[iOrigIndex]) or 'nil')..' is dead so removing') end
        else
            --Unit still valid, does it have the right water zone?
            if bAreEnemyUnits or bUseLastKnownPosition then
                UpdateUnitLastKnownPosition(aiBrain, tUnits[iOrigIndex], bUseActualPositionIfEnemy, true)
            end

            if bUseLastKnownPosition then
                iUnitSegmentX, iUnitSegmentZ = M28Map.GetPathingSegmentFromPosition(tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][aiBrain.M28Team])
            else
                --Allied unit so can use actual position
                iUnitSegmentX, iUnitSegmentZ = M28Map.GetPathingSegmentFromPosition(tUnits[iOrigIndex]:GetPosition())
            end
            iActualWaterZone = M28Map.tWaterZoneBySegment[iUnitSegmentX][iUnitSegmentZ]
            if bDebugMessages == true then LOG(sFunctionRef..': iOrigIndex='..iOrigIndex..'; iRevisedIndex='..iRevisedIndex..'; Considering unit '..tUnits[iOrigIndex].UnitId..M28UnitInfo.GetUnitLifetimeCount(tUnits[iOrigIndex])..'; iActualWaterZone='..(iActualWaterZone or 'nil')..'; iRecordedWaterZone='..iRecordedWaterZone) end
            --Is the water zone correct?
            if iActualWaterZone == iRecordedWaterZone then
                --No change needed for unit
                if (iOrigIndex ~= iRevisedIndex) then
                    tUnits[iRevisedIndex] = tUnits[iOrigIndex]
                    tUnits[iOrigIndex] = nil
                end
                iRevisedIndex = iRevisedIndex + 1
                if bDebugMessages == true then LOG(sFunctionRef..': Unit is valid, so increasing revised index') end
            else
                local oUnitToAdd = tUnits[iOrigIndex]
                oUnitToAdd[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] = nil
                if iActualWaterZone > 0 then
                    --AddUnitToWaterZoneForBrain(aiBrain,        oUnit,      iWaterZone,      bIsEnemyAirUnit)
                    M28Team.AddUnitToWaterZoneForBrain(aiBrain, oUnitToAdd, iActualWaterZone, bAreAirUnits)
                else
                    --[[if bAreAirUnits then
                        --Add unit to table of air units without a plateau
                        M28Air.RecordEnemyAirUnitWithNoZone(iTeam, oUnitToAdd)
                    else--]]
                    --Not sure where to record unit so call main logic
                    M28Team.AssignUnitToLandZoneOrPond(aiBrain, oUnitToAdd, true)
                    --end
                end

                tUnits[iOrigIndex] = nil
                if bDebugMessages == true then LOG(sFunctionRef..': Unit not valid so not increasing revised index') end
            end
        end
    end
    if iRevisedIndex < iTableSize then
        --table.setn(tUnits, iRevisedIndex - 1)

        for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
            if bDebugMessages == true then LOG(sFunctionRef..': removing entry from zone, Entry='..(tUnits[iRemovalEntry].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tUnits[iRemovalEntry]) or 'nil')..'; iTableSize='..iTableSize..'; iRevisedIndex='..iRevisedIndex) end
            table.remove(tUnits, iRemovalEntry)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateIfWaterZoneWantsSupport(tWZTeamData, bWantCombatSupport)
    tWZTeamData[M28Map.subrefbWZWantsSupport] = bWantCombatSupport
    --Flag if the target WZ only has hover, or only has antinavy
    local bOnlyHover = false
    local bOnlySubmersible = false
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
        bOnlyHover = true
        bOnlySubmersible = true
        for iUnit, oUnit in tWZTeamData[M28Map.subrefTEnemyUnits] do
            --Check for hover
            if bOnlyHover and not(EntityCategoryContains(categories.HOVER, oUnit.UnitId)) then bOnlyHover = false end
            if bOnlySubmersible and not(M28UnitInfo.IsUnitUnderwater(oUnit)) then bOnlySubmersible = false end
        end
    end
    tWZTeamData[M28Map.subrefbWZOnlyHoverEnemies] = bOnlyHover
    tWZTeamData[M28Map.subrefbWZOnlySubmersibleEnemies] = bOnlySubmersible
end

function RemoveUnitFromAnyExistingLandOrWaterZoneItWasPreviouslyTravelingTo(oUnit, sRefForTableOfTravelingUnits)
    local iExistingWZ = oUnit[refiWZToMoveTo]
    local tiExistingPlateauAndLZ = oUnit[M28Land.reftiPlateauAndLZToMoveTo]
    local iTeam = oUnit:GetAIBrain().M28Team
    if iExistingWZ then
        local tExistingWZTeamData = M28Map.tPondDetails[iExistingWZ][M28Map.subrefPondWaterZones][iExistingWZ][M28Map.subrefWZTeamData][iTeam]
        if M28Utilities.IsTableEmpty(tExistingWZTeamData[sRefForTableOfTravelingUnits]) == false then
            for iExistingUnit, oExistingUnit in tExistingWZTeamData[sRefForTableOfTravelingUnits] do
                if oExistingUnit == oUnit then
                    table.remove(tExistingWZTeamData[sRefForTableOfTravelingUnits], iExistingUnit)
                    break
                end
            end
        end
    end
    if M28Utilities.IsTableEmpty(tiExistingPlateauAndLZ) == false then
        local iExistingPlateau = tiExistingPlateauAndLZ[1]
        local iExistingLZ = tiExistingPlateauAndLZ[2]
        local tExistingLZTeamData = M28Map.tAllPlateaus[iExistingPlateau][M28Map.subrefPlateauLandZones][iExistingLZ][M28Map.subrefLZTeamData][iTeam]
        if M28Utilities.IsTableEmpty(tExistingLZTeamData[sRefForTableOfTravelingUnits]) == false then
            for iExistingUnit, oExistingUnit in tExistingLZTeamData[sRefForTableOfTravelingUnits] do
                if oExistingUnit == oUnit then
                    table.remove(tExistingLZTeamData[sRefForTableOfTravelingUnits], iExistingUnit)
                    break
                end
            end
        end
    end
end

function GetUnitToTravelToWaterZone(oUnit, iTargetPond, iTargetWaterZone, subrefWZTUnitTypeTravelingHere)
    --Intended for non-engineer units (engineers are handled separately)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnitToTravelToLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; refiWZToMoveTo='..refiWZToMoveTo) end
    RemoveUnitFromAnyExistingLandOrWaterZoneItWasPreviouslyTravelingTo(oUnit, subrefWZTUnitTypeTravelingHere)

    oUnit[refiWZToMoveTo] = iTargetWaterZone
    oUnit[M28Land.reftiPlateauAndLZToMoveTo] = nil
    local iTeam = oUnit:GetAIBrain().M28Team

    local tWZData = M28Map.tPondDetails[iTargetPond][M28Map.subrefPondWaterZones][iTargetWaterZone]
    local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
    if not(tWZTeamData[subrefWZTUnitTypeTravelingHere]) then tWZTeamData[subrefWZTUnitTypeTravelingHere] = {} end
    table.insert(tWZTeamData[subrefWZTUnitTypeTravelingHere], oUnit)
    if bDebugMessages == true then LOG(sFunctionRef..': About to tell unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to go to iTargetPond='..iTargetPond..'; iTargetWaterZone='..iTargetWaterZone..'; midpoint of WZ='..repru(tWZData[M28Map.subrefMidpoint])) end
    local iOrderReissueDistToUse

    if EntityCategoryContains(categories.HOVER, oUnit.UnitId) then iOrderReissueDistToUse = 6
    else iOrderReissueDistToUse = 16
    end
    M28Orders.IssueTrackedMove(oUnit, tWZData[M28Map.subrefMidpoint], iOrderReissueDistToUse, false, 'NTWZ'..iTargetWaterZone)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RemoveUnitFromListOfUnitsTravelingToWaterZone(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RemoveUnitFromListOfUnitsTravelingToWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[refiWZToMoveTo]='..repru(oUnit[refiWZToMoveTo])) end
    if oUnit[refiWZToMoveTo] then
        local sUnitTableRef
        if EntityCategoryContains(M28UnitInfo.refCategoryLandScout + M28UnitInfo.refCategoryFrigate, oUnit.UnitId) then
            sUnitTableRef = M28Map.subrefTScoutsTravelingHere
        else
            M28Utilities.ErrorHandler('Need to add code for this unit category, will send unit info to log')
            LOG(sFunctionRef..': oUnit='..(oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)))
        end
        if sUnitTableRef then

            local iTargetWaterZone = oUnit[refiWZToMoveTo]
            local iTargetPond = M28Map.tiPondByWaterZone[iTargetWaterZone]
            local tTravelingUnits = M28Map.tPondDetails[iTargetPond][M28Map.subrefPondWaterZones][iTargetWaterZone][M28Map.subrefWZTeamData][oUnit:GetAIBrain().M28Team][sUnitTableRef]
            if M28Utilities.IsTableEmpty(tTravelingUnits) == false then
                for iTravelUnit, oTravelUnit in tTravelingUnits do
                    if oTravelUnit == oUnit then
                        table.remove(tTravelingUnits, iTravelUnit)
                        break
                    end
                end
            end
        end
        oUnit[refiWZToMoveTo] = nil
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function ManageAllWaterZones(aiBrain, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageAllWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iLastRefreshCount = (tWZRefreshCountByTeam[iTeam] or 1)
    local iCurRefreshCount = 0
    local iTicksToSpreadOver = iTicksPerNavyCycle
    local iRefreshThreshold = math.max(2, math.ceil(iLastRefreshCount * 0.95 / iTicksToSpreadOver))
    local iCurCycleRefreshCount = 0
    local iCurTicksWaited = 0

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Time='..GetGameTimeSeconds()) end

    --Cycle through water zones
    for iPond, tPondSubtable in M28Map.tPondDetails do
        RefreshWaterRallyPoints(iTeam, iPond)
        local bAlreadyUsingFrigatesAsScouts = M28Team.tTeamData[iTeam][M28Team.subrefbUseFrigatesAsScoutsByPond][iPond]
        local bHaveCoreWZWithAdjacentEnemies = false
        if M28Utilities.IsTableEmpty(tPondSubtable[M28Map.subrefPondWaterZones]) == false then
            for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
                local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': iPond='..iPond..'; iWaterZone='..iWaterZone..'; Is table of enemey units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]))..'; Is table of friendly units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
                --First check all units in here are alive
                if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                    --UpdateUnitPositionsAndWaterZone(aiBrain,              tUnits,                 iTeam, iRecordedWaterZone, bUseLastKnownPosition, bAreAirUnits, tWZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
                    UpdateUnitPositionsAndWaterZone(aiBrain, tWZTeamData[M28Map.subrefTEnemyUnits], iTeam, iWaterZone, true, false, tWZTeamData,        true,                               true)
                end
                if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]) == false then
                    iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false or GetGameTimeSeconds() - (tWZTeamData[M28Map.refiTimeOfLastAirUpdate] or -100) >= 30 then
                        tWZTeamData[M28Map.refiTimeOfLastAirUpdate] = GetGameTimeSeconds()
                        --UpdateUnitPositionsAndWaterZone(aiBrain, tUnits,                          iTeam, iRecordedWaterZone, bUseLastKnownPosition, bAreAirUnits, tWZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
                        UpdateUnitPositionsAndWaterZone(aiBrain, tWZTeamData[M28Map.reftWZEnemyAirUnits], iTeam, iWaterZone, false, true, tWZTeamData, false,                           true)
                    else
                        --UpdateUnitPositionsAndWaterZone(aiBrain, tUnits,                              iTeam, iRecordedWaterZone, bUseLastKnownPosition, bAreAirUnits, tWZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
                        UpdateUnitPositionsAndWaterZone(aiBrain, tWZTeamData[M28Map.reftWZEnemyAirUnits], iTeam, iWaterZone, true, true, tWZTeamData,       false                               ,true)
                    end
                end
                if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                    iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                    UpdateUnitPositionsAndWaterZone(aiBrain, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits], iTeam, iWaterZone, false, false, tWZTeamData)
                end

                ForkThread(ManageSpecificWaterZone, aiBrain, iTeam, iPond, iWaterZone)
                iCurCycleRefreshCount = iCurCycleRefreshCount + 1

                if iCurCycleRefreshCount >= iRefreshThreshold then
                    iCurRefreshCount = iCurRefreshCount + iCurCycleRefreshCount
                    iCurCycleRefreshCount = 0
                    if iCurTicksWaited < iTicksToSpreadOver then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        iCurTicksWaited = iCurTicksWaited + 1
                    end
                end
                if not(bAlreadyUsingFrigatesAsScouts) and not(bHaveCoreWZWithAdjacentEnemies) then
                    bHaveCoreWZWithAdjacentEnemies = tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Warning - no water zones found for pond '..iPond) end
        end
        --1-of flag in game where will switch to using frigates as scouts for a pond (done as 1-off as not sure if will cause issues with scout logic if switch between having frigates acting as scouts and then not later; would probably work ok though if after testing decide want to change
        if not(bAlreadyUsingFrigatesAsScouts) and not(bHaveCoreWZWithAdjacentEnemies) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 25 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] >= 3 and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryNavalSurface) >= 20 then
            M28Team.tTeamData[iTeam][M28Team.subrefbUseFrigatesAsScoutsByPond][iPond] = true
        end
    end
    iCurRefreshCount = iCurRefreshCount + iCurCycleRefreshCount
    tWZRefreshCountByTeam[iTeam] = iCurRefreshCount

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordAirThreatForWaterZone(tWZTeamData, iTeam, iPond, iWaterZone)
    --NOTE: M28Navy uses similar logic for RecordAirThreatForWaterZone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAirThreatForWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --GetAirThreatLevel(tUnits,                             bEnemyUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
    tWZTeamData[M28Map.refiEnemyAirToGroundThreat] = M28UnitInfo.GetAirThreatLevel(tWZTeamData[M28Map.reftWZEnemyAirUnits],     true,         false,          false,               true,                  false,              true)
    tWZTeamData[M28Map.refiEnemyAirAAThreat] = M28UnitInfo.GetAirThreatLevel(tWZTeamData[M28Map.reftWZEnemyAirUnits],           true,       true,               false,              false,              false,                   false)
    tWZTeamData[M28Map.refiEnemyAirOtherThreat] = M28UnitInfo.GetAirThreatLevel(tWZTeamData[M28Map.reftWZEnemyAirUnits],        true,       false,           false,              false,                  true,               false)

    if bDebugMessages == true then LOG(sFunctionRef..': Finished updating enemy air threat values for iTeam '..iTeam..' iPond '..iPond..'; iWaterZOne '..iWaterZone..'; AirToGround threat='.. tWZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Other air threat='..tWZTeamData[M28Map.refiEnemyAirOtherThreat]..'; Is table of enemy air units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]))..'; GameTime='..GetGameTimeSeconds()) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordGroundThreatForWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone)
    --Records the different types of threat for the water zone

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordGroundThreatForWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Track team total threat - first remove the previous entry, then add in the new entry
    --M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] - tWZTeamData[M28Map.subrefWZThreatAllyMobileDFTotal]
    --M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] - tWZTeamData[M28Map.subrefWZThreatAllyMobileIndirectTotal]
    --M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] - tWZTeamData[M28Map.subrefWZThreatAlliedAA]

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code time='..GetGameTimeSeconds()..' for iTeam='..iTeam..'; iPond='..iPond..'; iWaterZone='..iWaterZone..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]))) end

    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) then
        tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] = 0
        tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] = 0
        tWZTeamData[M28Map.subrefWZThreatEnemySurface] = 0
        tWZTeamData[M28Map.subrefWZThreatEnemyAA] = 0
        tWZTeamData[M28Map.subrefWZBestEnemyDFRange] = 0
        tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] = 0
        tWZTeamData[M28Map.subrefWZBestEnemySubmersibleRange] = 0
        tWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] = 0
        tWZTeamData[M28Map.subreftEnemyLongRangeUnits] = nil

    else
        --function GetCombatThreatRating(tUnits,                                                                                    bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, bBlueprintThreat)
        tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] = M28UnitInfo.GetCombatThreatRating(tWZTeamData[M28Map.subrefTEnemyUnits],  true,       false,              false,                      true,       false)
        tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] = M28UnitInfo.GetCombatThreatRating(tWZTeamData[M28Map.subrefTEnemyUnits], true,     false,              false,                      false,      false,          true)
        tWZTeamData[M28Map.subrefWZThreatEnemySurface] = M28UnitInfo.GetCombatThreatRating(tWZTeamData[M28Map.subrefTEnemyUnits],   true,       false,              false,                      false,      true,           false)
        --GetAirThreatLevel(tUnits, bEnemyUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
        tWZTeamData[M28Map.subrefWZThreatEnemyAA] = M28UnitInfo.GetAirThreatLevel(tWZTeamData[M28Map.subrefTEnemyUnits], true, false, true, false, false, false, false)
        tWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] = M28UnitInfo.GetMassCostOfUnits(EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tWZTeamData[M28Map.subrefTEnemyUnits]))
        tWZTeamData[M28Map.subreftEnemyLongRangeUnits] = {}
        local iLRThreshold = iLongRangeThreshold

        for iUnit, oUnit in tWZTeamData[M28Map.subrefTEnemyUnits] do
            if oUnit:GetFractionComplete() >= 0.95 and oUnit[M28UnitInfo.refiCombatRange] > 0 then
                if bDebugMessages == true then
                    local iUnitSegmentX, iUnitSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnit:GetPosition())
                    LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Anti navy range='..(oUnit[M28UnitInfo.refiAntiNavyRange] or 'nil')..'; Combat threat rating='..M28UnitInfo.GetCombatThreatRating({ oUnit }, true)..'; Submersible threat rating='..M28UnitInfo.GetCombatThreatRating({ oUnit }, true,     false,              false,                      false,      false,          true)..'; Unit SegX='..(iUnitSegmentX or 'nil')..'Z='..(iUnitSegmentZ or 'nil')..'; WZ at this segment='..(M28Map.tWaterZoneBySegment[iUnitSegmentX][iUnitSegmentZ] or 'nil')..'; LZ at this segment='..(M28Map.tLandZoneBySegment[iUnitSegmentX][iUnitSegmentZ] or 'nil')..'; is unit underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; unit position='..repru(oUnit:GetPosition())..'; water height='..M28Map.iMapWaterHeight..'; sizey='..(oUnit:GetBlueprint().SizeY or 0))
                end
                --Simplification to approach taken for land zone logic - will ignore threat (since only relevant for aeon land scout)
                if (oUnit[M28UnitInfo.refiDFRange] or 0) >  tWZTeamData[M28Map.subrefWZBestEnemyDFRange] then  tWZTeamData[M28Map.subrefWZBestEnemyDFRange] = oUnit[M28UnitInfo.refiDFRange] end
                if (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) >  tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] then
                    tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] = oUnit[M28UnitInfo.refiAntiNavyRange]
                end
                if (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > tWZTeamData[M28Map.subrefWZBestEnemySubmersibleRange] then
                    if EntityCategoryContains(categories.SUBMERSIBLE + categories.AMPHIBIOUS, oUnit.UnitId) or oUnit.UnitId == 'xrb2309' then
                        tWZTeamData[M28Map.subrefWZBestEnemySubmersibleRange] = oUnit[M28UnitInfo.refiAntiNavyRange]
                    end
                end
                if oUnit[M28UnitInfo.refiCombatRange] > iLRThreshold then
                    table.insert(tWZTeamData[M28Map.subreftEnemyLongRangeUnits], oUnit)
                end
            end
        end
    end
    tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] = tWZTeamData[M28Map.subrefWZThreatEnemySurface] + tWZTeamData[M28Map.subrefWZThreatEnemySubmersible]

    --Record allied unit data
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) then
        tWZTeamData[M28Map.subrefWZThreatAlliedAntiNavy] = 0
        tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] = 0
        tWZTeamData[M28Map.subrefWZThreatAlliedSurface] = 0
        tWZTeamData[M28Map.subrefWZThreatAlliedAA] = 0
        tWZTeamData[M28Map.subrefWZThreatAlliedMAA] = 0
        tWZTeamData[M28Map.subrefWZBestAlliedDFRange] = 0
        tWZTeamData[M28Map.subrefWZBestAlliedSubmersibleRange] = 0
    else
        --function GetCombatThreatRating(tUnits, bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, bBlueprintThreat)
        tWZTeamData[M28Map.subrefWZThreatAlliedAntiNavy] = M28UnitInfo.GetCombatThreatRating(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits], true, false, false, true, false)
        tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] = M28UnitInfo.GetCombatThreatRating(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits], true, false, false, false, false, true)
        tWZTeamData[M28Map.subrefWZThreatAlliedSurface] = M28UnitInfo.GetCombatThreatRating(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits], true, false, false, false, true, false)
        --GetAirThreatLevel(tUnits,                                                                                                                                                                 bAlliedUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
        tWZTeamData[M28Map.subrefWZThreatAlliedAA] = M28UnitInfo.GetAirThreatLevel(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits], true,           false,          true,                   false,              false,              false,              false)
        if tWZTeamData[M28Map.subrefWZThreatAlliedAA] > 0 then
            local tMobileNavy = EntityCategoryFilterDown(categories.MOBILE, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tMobileNavy) == false then
                tWZTeamData[M28Map.subrefWZThreatAlliedMAA] = M28UnitInfo.GetAirThreatLevel(tMobileNavy, true,           false,          true,                   false,              false,              false,              false)
            else
                tWZTeamData[M28Map.subrefWZThreatAlliedMAA] = 0
            end
        else
            tWZTeamData[M28Map.subrefWZThreatAlliedMAA] = 0
        end

        for iUnit, oUnit in tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do
            if oUnit:GetFractionComplete() >= 1 then
                if bDebugMessages == true then LOG(sFunctionRef..': Considering Allied unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Combat threat rating='..M28UnitInfo.GetCombatThreatRating({ oUnit }, true)) end

                if oUnit[M28UnitInfo.refiDFRange] >  tWZTeamData[M28Map.subrefWZBestAlliedDFRange] and not(M28UnitInfo.IsUnitUnderwater(oUnit)) and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit.UnitId)) and EntityCategoryContains(M28UnitInfo.refCategoryNavalSurface + categories.HOVER + M28UnitInfo.refCategorySeraphimDestroyer, oUnit.UnitId) then  tWZTeamData[M28Map.subrefWZBestAlliedDFRange] = oUnit[M28UnitInfo.refiDFRange] end
                if oUnit[M28UnitInfo.refiAntiNavyRange] >  tWZTeamData[M28Map.subrefWZBestAlliedSubmersibleRange] and EntityCategoryContains(M28UnitInfo.refCategorySubmarine, oUnit.UnitId) then  tWZTeamData[M28Map.subrefWZBestAlliedSubmersibleRange] = oUnit[M28UnitInfo.refiAntiNavyRange] end
            end
        end
    end
    tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] = tWZTeamData[M28Map.subrefWZThreatAlliedSurface] + tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible]

    --Decide what threat we want for this WZ
    local bNearbyEnemies = false
    local bAdjacentLowThreatEnemies = false

    if bDebugMessages == true then LOG(sFunctionRef..': Considering if enemy units in this or adjacent WZ, is table of enemy units for this WZ empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]))..'; Adjacent WZs='..repru(M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZOtherWaterZones]))) end
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Have enemies in this WZ so flagging that it has nearby enemies') end
        bNearbyEnemies = true
    else
        if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZAdjacentWaterZones]) == false then
            local iAdjWZ
            for _, iAdjWZ in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZAdjacentWaterZones] do
                --iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                --NEED to flag as nearby enemies if any enemy units in the WZ, or else can cause problems where we try to attack a unit in an adjacent water zone, and then think there is no such unit due to this flag if it is only based on combat threat
                if bDebugMessages == true then LOG(sFunctionRef..': Enemy combat threat for adjacent WZ iAdjWZ='..iAdjWZ..'; threat='..M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatEnemySurface]..'; is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits]))) end
                if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have enemies in the adjacent WZ '..iAdjWZ) end
                    bNearbyEnemies = true
                    if M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatEnemySurface] + M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatEnemySubmersible] <= 15 then
                        bAdjacentLowThreatEnemies = true
                    else
                        bAdjacentLowThreatEnemies = false
                    end
                    if not(bAdjacentLowThreatEnemies) then
                        break
                    end
                end
            end
        end
    end

    tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = bNearbyEnemies
    if bNearbyEnemies then
        if bAdjacentLowThreatEnemies then
            tWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] = false
            tWZTeamData[M28Map.subrefWZCombatThreatWanted] = math.max(15, tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 2)
        else
            tWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] = true
            tWZTeamData[M28Map.subrefWZCombatThreatWanted] = math.max(200, tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 2)
        end
    else
        tWZTeamData[M28Map.subrefWZCombatThreatWanted] = 0
        tWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] = false
    end

    --If we have no friendly combat units and enemy has combat threat, then request less MAA, or none if we have no non-MAA/scout units
    if bDebugMessages == true then LOG(sFunctionRef..': Setting the MAA level wanted for iWaterZone='..iWaterZone..'; tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]='..tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]..'; tWZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tWZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tWZTeamData[M28Map.refiEnemyAirOtherThreat]='..tWZTeamData[M28Map.refiEnemyAirOtherThreat]..'; Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
    if tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < 11 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= math.min(1500, tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 0.9) or tWZTeamData[M28Map.subrefWZbCoreBase] then
        tWZTeamData[M28Map.subrefWZMAAThreatWanted] = math.max(tWZTeamData[M28Map.refiEnemyAirToGroundThreat] * 0.65 + (tWZTeamData[M28Map.refiEnemyAirOtherThreat] + tWZTeamData[M28Map.refiEnemyAirAAThreat]) * 0.15, tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] * 0.1)
    elseif M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        local bHaveAlliedNonMAAOrScout = false
        local bHaveAlliedMAA = false
        for iUnit, oUnit in tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do
            if EntityCategoryContains(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryNavalSurface - M28UnitInfo.refCategoryMAA - M28UnitInfo.refCategoryLandScout, oUnit.UnitId) then
                bHaveAlliedNonMAAOrScout = true
                break
            elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryNavalAA, oUnit.UnitId) then
                bHaveAlliedMAA = true
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveAlliedMAA='..tostring(bHaveAlliedMAA)..'; bHaveAlliedNonMAAOrScout='..tostring(bHaveAlliedNonMAAOrScout)) end
        if bHaveAlliedNonMAAOrScout or (bHaveAlliedMAA and tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0) then
            --SIgnificantly less MAA for dealing with non-air to ground threats
            if tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                tWZTeamData[M28Map.subrefWZMAAThreatWanted] = math.max(tWZTeamData[M28Map.refiEnemyAirToGroundThreat], (tWZTeamData[M28Map.refiEnemyAirOtherThreat] + tWZTeamData[M28Map.refiEnemyAirAAThreat]) * 0.075, tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] * 0.2)
            else
                tWZTeamData[M28Map.subrefWZMAAThreatWanted] = math.max((tWZTeamData[M28Map.refiEnemyAirOtherThreat] + tWZTeamData[M28Map.refiEnemyAirAAThreat]) * 0.075, tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] * 0.1)
            end
        else
            tWZTeamData[M28Map.subrefWZMAAThreatWanted] = 0
        end
    else
        tWZTeamData[M28Map.subrefWZMAAThreatWanted] = 0
    end

    --Increase MAA wanted if we have ACU in the WZ
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefAlliedACU]) == false then
        local tiMAAByTechForACU = {100, 400, 1000}
        if tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
            tWZTeamData[M28Map.subrefWZMAAThreatWanted] = tWZTeamData[M28Map.subrefWZMAAThreatWanted] + math.min(1600, tiMAAByTechForACU[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2)
        else
            tWZTeamData[M28Map.subrefWZMAAThreatWanted] = tWZTeamData[M28Map.subrefWZMAAThreatWanted] + tiMAAByTechForACU[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
        end
    end

    --If have significant MAA wanted and a significant allied combat threat, then record as a high value WZ wanting MAA
    local iPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tWZData[M28Map.subrefMidpoint])
    if iPlateau then
        if tWZTeamData[M28Map.subrefWZMAAThreatWanted] - tWZTeamData[M28Map.subrefWZThreatAlliedAA] >= 1000 and tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= 1000 then
            if bDebugMessages == true then LOG(sFunctionRef..': Recording water zone wanting MAA for iWaterZone='..iWaterZone..'; iPlateau='..iPlateau..'; iPond='..iPond..'; Midpoint of waterzone='..repru(tWZData[M28Map.subrefMidpoint])) end
            M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau][iWaterZone] = true
        else
            M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau][iWaterZone] = nil
        end
    else
        M28Utilities.ErrorHandler('No plateau for pond '..(iPond or 'nil')..'; WZ'..(iWaterZone or 'nil'))
    end



    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bNearbyEnemies='..tostring(bNearbyEnemies)..'; Allied combat='..(tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 'nil')..'; tWZTeamData[M28Map.subrefWZMAAThreatWanted]='..tWZTeamData[M28Map.subrefWZMAAThreatWanted]..'; tWZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tWZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tWZTeamData[M28Map.refiEnemyAirOtherThreat]='..tWZTeamData[M28Map.refiEnemyAirOtherThreat]) end
    tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = bNearbyEnemies
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MoveToShieldTarget(oShield, tEnemyBase)
    local oBP = oShield:GetBlueprint()
    local iShieldDistanceWanted = math.max(3, oBP.Defense.Shield.ShieldSize * 0.5 - 1 - oBP.Physics.MaxSpeed - (oShield[M28Land.refoMobileShieldTarget]:GetBlueprint().Physics.MaxSpeed or 0))
    --Have an issue with larger shields like shield boats where the shield isn't maintained all the time; can afford to be a bit closer with a larger shield
    if iShieldDistanceWanted >= 10 then iShieldDistanceWanted = math.max(10, iShieldDistanceWanted * 0.66) end
    M28Orders.IssueTrackedMove(oShield, M28Utilities.MoveInDirection(oShield[M28Land.refoMobileShieldTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(tEnemyBase,oShield[M28Land.refoMobileShieldTarget]:GetPosition()), iShieldDistanceWanted, true, false, true), math.min(4, iShieldDistanceWanted - 1), false, 'WShU'..oShield[M28Land.refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield[M28Land.refoMobileShieldTarget]))
end

function MoveToStealthTarget(oStealth, tEnemyBase)
    local oBP = oStealth:GetBlueprint()
    local iStealthDistanceWanted = math.max(8, oBP.Intel.RadarStealthFieldRadius - 1 - oBP.Physics.MaxSpeed - (oStealth[M28Land.refoMobileStealthTarget]:GetBlueprint().Physics.MaxSpeed or 0))
    if iStealthDistanceWanted >= 10 then iStealthDistanceWanted = math.max(10, iStealthDistanceWanted * 0.66) end
    M28Orders.IssueTrackedMove(oStealth, M28Utilities.MoveInDirection(oStealth[M28Land.refoMobileStealthTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(tEnemyBase,oStealth[M28Land.refoMobileStealthTarget]:GetPosition()), iStealthDistanceWanted, true, false, true), math.min(4, iStealthDistanceWanted - 1), false, 'StU'..oStealth[M28Land.refoMobileStealthTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth[M28Land.refoMobileStealthTarget]))
end

function ShieldUnitsInWaterZone(tTeamTargetWZData, tShieldsToAssign, bAssignAllShields)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ShieldUnitsInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    
    local bNoUnitsWantingShielding = true
    if M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) and M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileShield]) then
        M28Utilities.ErrorHandler('Are trying to send mobile shields to support a water zone that has no allied combat units in it and no units wanting shielding')
    else
        if M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileShield]) == false then
            for iTarget, oTarget in tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileShield] do
                if not(oTarget[M28Land.refoAssignedMobileShield]) then
                    if M28Utilities.IsTableEmpty(tShieldsToAssign) then
                        bNoUnitsWantingShielding = false
                        break
                    else
                        --Assign the closest mobile shield
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iShield, oShield in tShieldsToAssign do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iShield='..iShield..'; Shield unit='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)) end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oTarget:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iShield
                            end
                            break
                        end
                        tShieldsToAssign[iClosestRef][M28Land.refoMobileShieldTarget] = oTarget
                        oTarget[M28Land.refoAssignedMobileShield] = tShieldsToAssign[iClosestRef]
                        MoveToShieldTarget(tShieldsToAssign[iClosestRef], tTeamTargetWZData[M28Map.reftClosestEnemyBase])
                        table.remove(tShieldsToAssign, iClosestRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have just removed shield with iClosestRef='..iClosestRef..' from the table of tShieldsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; size of table='..table.getn(tShieldsToAssign)) end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
            bNoUnitsWantingShielding = true
            if bAssignAllShields then
                --No units that want shielding - e.g. we might be telling mobile shields to defend here temporarily; dont assign the shields, instead just give them orders so they are still of some use
                if M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) == false then
                    for iTarget, oTarget in tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits] do
                        if not(oTarget[M28Land.refoAssignedMobileShield]) then --redundancy
                            --Assign the closest mobile shield
                            local iCurDist
                            local iClosestDist = 100000
                            local iClosestRef

                            for iShield, oShield in tShieldsToAssign do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iShield='..iShield..'; Shield unit='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)) end
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oTarget:GetPosition())
                                if iCurDist < iClosestDist then
                                    iClosestDist = iCurDist
                                    iClosestRef = iShield
                                end
                                break
                            end
                            --Dont record the shield as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoshieldtarget works
                            tShieldsToAssign[iClosestRef][M28Land.refoMobileShieldTarget] = oTarget
                            MoveToShieldTarget(tShieldsToAssign[iClosestRef], tTeamTargetWZData[M28Map.reftClosestEnemyBase])
                            tShieldsToAssign[iClosestRef][M28Land.refoMobileShieldTarget] = nil
                            table.remove(tShieldsToAssign, iClosestRef)
                            if bDebugMessages == true then LOG(sFunctionRef..': Backup shield assignment - Have removed shield with iClosestRef='..iClosestRef..' from the table of tShieldsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; size of table='..table.getn(tShieldsToAssign)) end
                            if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                        end
                    end

                    --Do we still have spare mobile shields?
                    if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                        --Get closest unit to enemy base and assign all remaining shields temporarily here
                        local iCurDist
                        local iClosestDist = 100000
                        local oClosestToEnemyBase

                        for iTarget, oTarget in tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits] do
                            if M28UnitInfo.IsUnitValid(oTarget) then
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), tTeamTargetWZData[M28Map.reftClosestEnemyBase])
                                if iCurDist < iClosestDist then
                                    iClosestDist = iCurDist
                                    oClosestToEnemyBase = oTarget
                                end
                            end
                        end
                        if oClosestToEnemyBase then
                            local tEnemyBase = tTeamTargetWZData[M28Map.reftClosestEnemyBase]
                            for iShield, oShield in tShieldsToAssign do
                                --Dont record the shield as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoshieldtarget works
                                if bDebugMessages == true then LOG(sFunctionRef..': About to tell shield '..(oShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oShield) or 'nil')..' to move towards oClosestToEnemyBase='..(oClosestToEnemyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase) or 'nil')) end
                                oShield[M28Land.refoMobileShieldTarget] = oClosestToEnemyBase
                                MoveToShieldTarget(oShield, tEnemyBase)
                                oShield[M28Land.refoMobileShieldTarget] = nil
                                if bDebugMessages == true then LOG(sFunctionRef..': Backup shield assignment - have told shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' to go to the closest enemy in this WZ to enemy base='..oClosestToEnemyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase)) end
                            end
                        elseif bDebugMessages == true then LOG(sFunctionRef..': No friendly units close to enemy base - assuming this is termpoary due to unit being destroyed')
                        end
                    end
                end
            end
        end
    end
    if bNoUnitsWantingShielding then
        --Flag that this WZ no longer wants mobile shields
        tTeamTargetWZData[M28Map.refbWZWantsMobileShield] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function StealthUnitsInWaterZone(tTeamTargetWZData, tStealthsToAssign, bAssignAllStealths)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'StealthUnitsInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local bNoUnitsWantingStealthing = true
    if M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) and M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileStealth]) then
        M28Utilities.ErrorHandler('Are trying to send mobile Stealths to support a water zone that has no allied combat units in it and no units wanting Stealthing')
    else
        if M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileStealth]) == false then
            for iTarget, oTarget in tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileStealth] do
                if not(oTarget[M28Land.refoAssignedMobileStealth]) then
                    if M28Utilities.IsTableEmpty(tStealthsToAssign) then
                        bNoUnitsWantingStealthing = false
                        break
                    else
                        --Assign the closest mobile Stealth
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iStealth, oStealth in tStealthsToAssign do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iStealth='..iStealth..'; Stealth unit='..oStealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth)) end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oStealth:GetPosition(), oTarget:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iStealth
                            end
                            break
                        end
                        tStealthsToAssign[iClosestRef][M28Land.refoMobileStealthTarget] = oTarget
                        oTarget[M28Land.refoAssignedMobileStealth] = tStealthsToAssign[iClosestRef]
                        MoveToStealthTarget(tStealthsToAssign[iClosestRef], tTeamTargetWZData[M28Map.reftClosestEnemyBase])
                        table.remove(tStealthsToAssign, iClosestRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have just removed Stealth with iClosestRef='..iClosestRef..' from the table of tStealthsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; size of table='..table.getn(tStealthsToAssign)) end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tStealthsToAssign) == false and bAssignAllStealths then
            bNoUnitsWantingStealthing = true
            --No units that want Stealthing - e.g. we might be telling mobile Stealths to defend here temporarily; dont assign the Stealths, instead just give them orders so they are still of some use
            if M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) == false then
                for iTarget, oTarget in tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits] do
                    if not(oTarget[M28Land.refoAssignedMobileStealth]) then --redundancy
                        --Assign the closest mobile Stealth
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iStealth, oStealth in tStealthsToAssign do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iStealth='..iStealth..'; Stealth unit='..oStealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth)) end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oStealth:GetPosition(), oTarget:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iStealth
                            end
                            break
                        end
                        --Dont record the Stealth as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoStealthtarget works
                        tStealthsToAssign[iClosestRef][M28Land.refoMobileStealthTarget] = oTarget
                        MoveToStealthTarget(tStealthsToAssign[iClosestRef], tTeamTargetWZData[M28Map.reftClosestEnemyBase])
                        tStealthsToAssign[iClosestRef][M28Land.refoMobileStealthTarget] = nil
                        table.remove(tStealthsToAssign, iClosestRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Backup Stealth assignment - Have removed Stealth with iClosestRef='..iClosestRef..' from the table of tStealthsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; size of table='..table.getn(tStealthsToAssign)) end
                        if M28Utilities.IsTableEmpty(tStealthsToAssign) then break end
                    end
                end

                --Do we still have spare mobile Stealths?
                if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                    --Get closest unit to enemy base and assign all remaining Stealths temporarily here
                    local iCurDist
                    local iClosestDist = 100000
                    local oClosestToEnemyBase

                    for iTarget, oTarget in tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits] do
                        if M28UnitInfo.IsUnitValid(oTarget) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), tTeamTargetWZData[M28Map.reftClosestEnemyBase])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oClosestToEnemyBase = oTarget
                            end
                        end
                    end
                    if oClosestToEnemyBase then
                        local tEnemyBase = tTeamTargetWZData[M28Map.reftClosestEnemyBase]
                        for iStealth, oStealth in tStealthsToAssign do
                            --Dont record the Stealth as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoStealthtarget works
                            if bDebugMessages == true then LOG(sFunctionRef..': About to tell Stealth '..(oStealth.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oStealth) or 'nil')..' to move towards oClosestToEnemyBase='..(oClosestToEnemyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase) or 'nil')) end
                            oStealth[M28Land.refoMobileStealthTarget] = oClosestToEnemyBase
                            MoveToStealthTarget(oStealth, tEnemyBase)
                            oStealth[M28Land.refoMobileStealthTarget] = nil
                            if bDebugMessages == true then LOG(sFunctionRef..': Backup Stealth assignment - have told Stealth '..oStealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth)..' to go to the closest enemy in this WZ to enemy base='..oClosestToEnemyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase)) end
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': No friendly units close to enemy base - assuming this is termpoary due to unit being destroyed')
                    end
                end
            end
        end
    end
    if bNoUnitsWantingStealthing then
        --Flag that this WZ no longer wants mobile Stealths
        tTeamTargetWZData[M28Map.refbWZWantsMobileStealth] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageMobileShieldsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tMobileShields)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMobileShieldsInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iWaterZone='..iWaterZone..'; Size of tMobileShields='..table.getn(tMobileShields)) end

    local iCurShield, iMaxShield
    local tShieldsToRetreat = {}
    local tShieldsToAssign = {}
    local tEnemyBase = tWZTeamData[M28Map.reftClosestEnemyBase]
    if M28Utilities.IsTableEmpty(tEnemyBase) then
        M28Utilities.ErrorHandler('Couldnt find enemy base, will try backup approach')
        local iCurDist
        local iClosestDist = 100000
        local oClosestBrain
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestBrain = oBrain
            end
        end
        tEnemyBase = M28Map.PlayerStartPoints[oClosestBrain:GetArmyIndex()]
    end

    for iUnit, oUnit in tMobileShields do
        iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, false)
        if bDebugMessages == true then LOG(sFunctionRef..': Considering what to do with unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurShield='..iCurShield..'; iMaxShield='..iMaxShield) end
        if not(oUnit[M28UnitInfo.refbEasyBrain]) and iCurShield < iMaxShield * 0.5 then
            --Retreat
            table.insert(tShieldsToRetreat, oUnit)
        elseif oUnit[M28Land.refoMobileShieldTarget] and M28UnitInfo.IsUnitValid(oUnit[M28Land.refoMobileShieldTarget]) then
            --make sure we are behind the target
            MoveToShieldTarget(oUnit, tEnemyBase)
        else
            table.insert(tShieldsToAssign, oUnit)
        end
    end
    if M28Utilities.IsTableEmpty(tShieldsToRetreat) == false then
        local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
        if bDebugMessages == true then LOG(sFunctionRef..': Will give orders to retreat, size of tShieldsToRetreat='..table.getn(tShieldsToRetreat)) end
        for iUnit, oUnit in tShieldsToRetreat do
            if bDebugMessages == true then
                local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, false)
                LOG(sFunctionRef..': About to tell unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to run due to a low shield. iCurShield='..iCurShield..'; iMaxShield='..iMaxShield)
            end
            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'WSRun'..iWaterZone)
        end
    end
    if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
        --Cycle through every water zone and record priority ones to shield
        if bDebugMessages == true then LOG(sFunctionRef..': Will give orders to tShieldsToAssign, size of table='..table.getn(tShieldsToAssign)) end
        local tiClosestWZWithNearbyThreat = {}
        local iClosestWZWithNoThreat
        local iClosestWZNotWantingShieldButWithUnits
        local iClosestWZWithAnyCombatUnits
        if not(tWZTeamData[M28Map.refbWZWantsMobileShield]) and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTAlliedCombatUnits]) == false then iClosestWZNotWantingShieldButWithUnits = iWaterZone end
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
            for iEntry, tPathingDetails in tWZData[M28Map.subrefWZOtherWaterZones] do
                local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tPathingDetails[M28Map.subrefWZAWZRef]][M28Map.subrefWZTeamData][iTeam]
                if tTeamTargetWZData[M28Map.refbWZWantsMobileShield] then
                    if tTeamTargetWZData[M28Map.refiEnemyAirToGroundThreat] > 0 or tTeamTargetWZData[M28Map.subrefTThreatEnemyCombatTotal] >= 40 then
                        ShieldUnitsInWaterZone(tTeamTargetWZData, tShieldsToAssign)
                        if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                    elseif M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefTEnemyUnits]) == false or tTeamTargetWZData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then
                        table.insert(tiClosestWZWithNearbyThreat, tPathingDetails[M28Map.subrefWZAWZRef])
                    elseif not(iClosestWZWithNoThreat) then iClosestWZWithNoThreat = tPathingDetails[M28Map.subrefWZAWZRef]
                    end
                elseif not(iClosestWZNotWantingShieldButWithUnits) then
                    if tTeamTargetWZData[M28Map.subrefbWZWantsSupport] and M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) == false then iClosestWZNotWantingShieldButWithUnits = tPathingDetails[M28Map.subrefWZAWZRef] end
                    if not(iClosestWZWithAnyCombatUnits) and M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) == false then iClosestWZWithAnyCombatUnits = tPathingDetails[M28Map.subrefWZAWZRef] end
                end

            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished checking other zones we can path to for units wanting shielding, is tShieldsToAssign empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; Is M28Utilities.IsTableEmpty(tiClosestWZWithNearbyThreat) empty='..tostring(M28Utilities.IsTableEmpty(tiClosestWZWithNearbyThreat))) end
        if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
            if M28Utilities.IsTableEmpty(tiClosestWZWithNearbyThreat) == false then
                for _, iTargetWZ in  tiClosestWZWithNearbyThreat do
                    local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iTargetWZ][M28Map.subrefWZTeamData][iTeam]
                    ShieldUnitsInWaterZone(tTeamTargetWZData, tShieldsToAssign)
                    if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                end
            end
            if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                if iClosestWZWithNoThreat then
                    local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iClosestWZWithNoThreat][M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Have mobile shields to assign, closest WZ='..iClosestWZWithNoThreat..'; DOes this WZ want mobile shields='..tostring(tTeamTargetWZData[M28Map.refbWZWantsMobileShield] or false)..'; is table of units wanting shielding empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileShield]))) end
                    ShieldUnitsInWaterZone(tTeamTargetWZData, tShieldsToAssign)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Is tShieldsToAssign empty after checking for closest WZ with no threat='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; iClosestWZNotWantingShieldButWithUnits='..(iClosestWZNotWantingShieldButWithUnits or 'nil')) end
                if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                    --Dont have any water zones that want a mobile shield, but we have mobile shields - find the closest WZ  that wants surface support and has DF or IF units, and send them here; if that's this WZ, then have them go to the unit closest to the enemy in this WZ, but without assigning them
                    if iClosestWZNotWantingShieldButWithUnits or iClosestWZWithAnyCombatUnits then
                        local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][(iClosestWZNotWantingShieldButWithUnits or iClosestWZWithAnyCombatUnits)][M28Map.subrefWZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Have mobile shields to assign, closest WZ with friendly combat units that wants more units='..(iClosestWZNotWantingShieldButWithUnits or 'nil')..'; iClosestWZWithAnyCombatUnits='..(iClosestWZWithAnyCombatUnits or 'nil')..'; DOes this WZ want mobile shields='..tostring(tTeamTargetWZData[M28Map.refbWZWantsMobileShield] or false)..'; is table of units wanting shielding empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileShield]))) end
                        ShieldUnitsInWaterZone(tTeamTargetWZData, tShieldsToAssign, true)
                    end
                    if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': couldnt find any water zones with friendly combat units of a high enough value so have nowhere to assign mobile shields/shield boats; will send them all to the nearest rally point instead') end
                        local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
                        for iUnit, oUnit in tShieldsToAssign do
                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'WSBckup'..iWaterZone)
                        end
                        M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoShieldBoatTargetsByPond][iPond] = GetGameTimeSeconds()

                    end

                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageMobileStealthsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tMobileStealths)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMobileStealthsInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iPond='..iPond..'; iWaterZone='..iWaterZone..'; Size of tMobileStealths='..table.getn(tMobileStealths)) end

    local tStealthsToAssign = {}
    local tEnemyBase = tWZTeamData[M28Map.reftClosestEnemyBase]
    if M28Utilities.IsTableEmpty(tEnemyBase) then
        M28Utilities.ErrorHandler('Couldnt find enemy base, will try backup approach')
        local iCurDist
        local iClosestDist = 100000
        local oClosestBrain
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestBrain = oBrain
            end
        end
        tEnemyBase = M28Map.PlayerStartPoints[oClosestBrain:GetArmyIndex()]
    end

    for iUnit, oUnit in tMobileStealths do
        if oUnit[M28Land.refoMobileStealthTarget] and M28UnitInfo.IsUnitValid(oUnit[M28Land.refoMobileStealthTarget]) then
            --make sure we are behind the target
            MoveToStealthTarget(oUnit, tEnemyBase)
        else
            table.insert(tStealthsToAssign, oUnit)
        end
    end
    if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
        --Cycle through every water zone and record priority ones to Stealth
        if bDebugMessages == true then LOG(sFunctionRef..': Will give orders to tStealthsToAssign, size of table='..table.getn(tStealthsToAssign)) end
        local tiClosestWZWithNearbyThreat = {}
        local iClosestWZWithNoThreat
        local iClosestWZNotWantingStealthButWithUnits
        local iClosestWZWithAnyCombatUnits
        if tWZTeamData[M28Map.subrefbWZWantsSupport] and not(tWZTeamData[M28Map.refbWZWantsMobileStealth]) and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTAlliedCombatUnits]) == false then iClosestWZNotWantingStealthButWithUnits = iWaterZone end
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
            for iEntry, tPathingDetails in tWZData[M28Map.subrefWZOtherWaterZones] do
                local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tPathingDetails[M28Map.subrefWZAWZRef]][M28Map.subrefWZTeamData][iTeam]
                if tTeamTargetWZData[M28Map.refbWZWantsMobileStealth] then
                    if tTeamTargetWZData[M28Map.refiEnemyAirToGroundThreat] > 0 or tTeamTargetWZData[M28Map.subrefTThreatEnemyCombatTotal] >= 40 then
                        StealthUnitsInWaterZone(tTeamTargetWZData, tStealthsToAssign)
                        if M28Utilities.IsTableEmpty(tStealthsToAssign) then break end
                    elseif M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefTEnemyUnits]) == false or tTeamTargetWZData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then
                        table.insert(tiClosestWZWithNearbyThreat, tPathingDetails[M28Map.subrefWZAWZRef])
                    elseif not(iClosestWZWithNoThreat) then iClosestWZWithNoThreat = tPathingDetails[M28Map.subrefWZAWZRef]
                    end
                elseif not(iClosestWZNotWantingStealthButWithUnits) then
                    if tTeamTargetWZData[M28Map.subrefbWZWantsSupport] and M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) == false then iClosestWZNotWantingStealthButWithUnits = tPathingDetails[M28Map.subrefWZAWZRef] end
                    if not(iClosestWZWithAnyCombatUnits) and M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) == false then iClosestWZWithAnyCombatUnits = tPathingDetails[M28Map.subrefWZAWZRef] end
                end

            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished checking other zones we can path to for units wanting Stealthing, is tStealthsToAssign empty='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; Is M28Utilities.IsTableEmpty(tiClosestWZWithNearbyThreat) empty='..tostring(M28Utilities.IsTableEmpty(tiClosestWZWithNearbyThreat))) end
        if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
            if M28Utilities.IsTableEmpty(tiClosestWZWithNearbyThreat) == false then
                for _, iTargetWZ in  tiClosestWZWithNearbyThreat do
                    local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iTargetWZ][M28Map.subrefWZTeamData][iTeam]
                    StealthUnitsInWaterZone(tTeamTargetWZData, tStealthsToAssign)
                    if M28Utilities.IsTableEmpty(tStealthsToAssign) then break end
                end
            end
            if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                if iClosestWZWithNoThreat then
                    local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iClosestWZWithNoThreat][M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Have mobile Stealths to assign, closest WZ='..iClosestWZWithNoThreat..'; DOes this WZ want mobile Stealths='..tostring(tTeamTargetWZData[M28Map.refbWZWantsMobileStealth] or false)..'; is table of units wanting Stealthing empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileStealth]))) end
                    StealthUnitsInWaterZone(tTeamTargetWZData, tStealthsToAssign)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Is tStealthsToAssign empty after checking for closest WZ with no threat='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; iClosestWZNotWantingStealthButWithUnits='..(iClosestWZNotWantingStealthButWithUnits or 'nil')) end
                if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                    --Dont have any water zones that want a mobile Stealth, but we have mobile Stealths - find the closest WZ  that wants DF support and has DF units, and send them here; if that's this WZ, then have them go to the unit closest to the enemy in this WZ, but without assigning them
                    M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoStealthBoatTargetsByPond][iPond] = GetGameTimeSeconds()
                    if iClosestWZNotWantingStealthButWithUnits or iClosestWZWithAnyCombatUnits then
                        local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][(iClosestWZNotWantingStealthButWithUnits or iClosestWZWithAnyCombatUnits)][M28Map.subrefWZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Have mobile Stealths to assign, closest WZ with friendly combat units that wants more units='..(iClosestWZNotWantingStealthButWithUnits or 'nil')..'; iClosestWZWithAnyCombatUnits='..(iClosestWZWithAnyCombatUnits or 'nil')..'; DOes this WZ want mobile Stealths='..tostring(tTeamTargetWZData[M28Map.refbWZWantsMobileStealth] or false)..'; is table of units wanting Stealthing empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileStealth]))) end
                        StealthUnitsInWaterZone(tTeamTargetWZData, tStealthsToAssign, true)
                    end
                    if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': couldnt find any water zones with friendly combat units so have nowhere to assign mobile Stealths; will send them all to the nearest rally point instead') end
                        local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
                        for iUnit, oUnit in tStealthsToAssign do
                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'SNtBckup'..iWaterZone)
                        end

                    end

                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordUnitAsReceivingWaterZoneAssignment(oUnit, iWaterZone, iCurWZValue)
    oUnit[refiCurrentWZAssignmentValue] = iCurWZValue
    oUnit[refiCurrentAssignmentWaterZone] = iWaterZone
    oUnit[refiTimeOfLastWZAssignment] = GetGameTimeSeconds()
    if oUnit[M28Land.refiCurrentAssignmentPlateauAndLZ] then
        oUnit[M28Land.refiCurrentAssignmentValue] = nil
        oUnit[M28Land.refiCurrentAssignmentPlateauAndLZ] = nil
    end
end

function MoveUnassignedLandUnits(tWZData, tWZTeamData, iPond, iWaterZone, iTeam, tAmphibiousUnits)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MoveUnassignedLandUnits'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Decides where to send any units that are part of this water zone (ignores those from an adjacent waterzone that were available)
    --local tAmphibiousLabelUnits = {}
    local tiUnitsInZoneByAmphibiousLabel = {}
    local iCurLabel
    local bAmphibiousCheck
    if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.AMPHIBIOUS, tAmphibiousUnits)) == false then
        bAmphibiousCheck = true
        --[[else
            iAmphibiousLabelWanted = tWZData[M28Map.refiMidpointAmphibiousLabel]
            if not(iAmphibiousLabelWanted) then iAmphibiousLabelWanted = -1 end --dont want to be nil as if target island also nil then we will think we can path there--]]
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for the game time='..GetGameTimeSeconds()..' and iWaterZone='..iWaterZone..', is tAmphibiousUnits empty='..tostring(M28Utilities.IsTableEmpty(tAmphibiousUnits))) end
    for iUnit, oUnit in tAmphibiousUnits do
        if oUnit[refiCurrentAssignmentWaterZone] == iWaterZone then
            if bAmphibiousCheck and EntityCategoryContains(categories.AMPHIBIOUS, oUnit.UnitId) then iCurLabel = (NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, oUnit:GetPosition()) or tWZData[M28Map.refiMidpointAmphibiousLabel] or 0)
            else
                iCurLabel = tWZData[M28Map.refiMidpointAmphibiousLabel]
            end
            if not(tiUnitsInZoneByAmphibiousLabel[iCurLabel]) then tiUnitsInZoneByAmphibiousLabel[iCurLabel] = {} end
            table.insert(tiUnitsInZoneByAmphibiousLabel[iCurLabel], oUnit)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; iCurLabel='..(iCurLabel or 'nil')..'; WZ label='..(tWZData[M28Map.refiMidpointAmphibiousLabel] or 'nil')..'; Amphibious label at position='.. (NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, oUnit:GetPosition())) or 'nil') end
    end
    if M28Utilities.IsTableEmpty(tiUnitsInZoneByAmphibiousLabel) == false then
        for iAmphibiousLabel, tAmphibiousLabelUnits in tiUnitsInZoneByAmphibiousLabel do

            --Find the nearest land zone wanting support:
            local iPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tWZData[M28Map.subrefMidpoint])
            if not(iPlateau) then
                M28Utilities.ErrorHandler('Dont have a plateau for midpoint of water zone '..(iWaterZone or 'nil')..' in iPond '..(iPond or 'nil'))
                --will still try and continue since have recorded plateau for the adjacent land zones anyway
            end
            local iLZToSupport

            --Does this WZ have adjacent LZ wanting support?
            local bDontCheckForPacifism = not(M28Overseer.bPacifistModeActive)
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
                for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                    local tAltLZ = M28Map.tAllPlateaus[tSubtable[M28Map.subrefWPlatAndLZNumber][1]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefWPlatAndLZNumber][2]]

                    if (bDontCheckForPacifism or not(tWZData[M28Map.subrefbPacifistArea])) and tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsSupport] then
                        if iAmphibiousLabel == tAltLZ[M28Map.refiMidpointAmphibiousLabel] then
                            iLZToSupport = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                            iPlateau = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                            break
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with iAmphibiousLabel='..iAmphibiousLabel..'; iLZToSupport after checking adjacent LZ to this WZ='..(iLZToSupport or 'nil')..'; did this WZ have adjacent LZ? is table empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]))..'; Time='..GetGameTimeSeconds()) end
            if not(iLZToSupport) then
                --Cycle through every other water zone and try the same thing
                local iCloserPlateauToEnemy, iCloserLandZoneToEnemy
                local iEnemyPlateau, iEnemyZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tWZTeamData[M28Map.reftClosestEnemyBase])
                local iMaxDistWantedToEnemyBase = math.max(50, M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], tWZTeamData[M28Map.reftClosestEnemyBase]) - 50)
                if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                    for iWZEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                        local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tWZSubtable[M28Map.subrefWZAWZRef]]
                        if bDebugMessages == true then LOG(sFunctionRef..'; Considering alt WZ='..tWZSubtable[M28Map.subrefWZAWZRef]..'; Is table of adjacent land zones empty='..tostring(M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefAdjacentLandZones]))) end
                        if M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefAdjacentLandZones]) == false then
                            for iEntry, tSubtable in tAltWZData[M28Map.subrefAdjacentLandZones] do
                                local tAltLZ = M28Map.tAllPlateaus[tSubtable[M28Map.subrefWPlatAndLZNumber][1]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefWPlatAndLZNumber][2]]
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent land zone '..tSubtable[M28Map.subrefWPlatAndLZNumber][2]..' in plateau '..tSubtable[M28Map.subrefWPlatAndLZNumber][1]..'; Does this zone want support='..tostring(tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsSupport])..'; Dist to enemy base='..M28Utilities.GetDistanceBetweenPositions(tWZTeamData[M28Map.reftClosestEnemyBase], tAltLZ[M28Map.subrefMidpoint])..'; iMaxDistWantedToEnemyBase='..iMaxDistWantedToEnemyBase) end
                                if (bDontCheckForPacifism or not(tAltLZ[M28Map.subrefbPacifistArea])) and tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsSupport] then
                                    if iAmphibiousLabel == tAltLZ[M28Map.refiMidpointAmphibiousLabel] then
                                        iLZToSupport = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                                        iPlateau = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                                        break
                                    end
                                    --redundancy - if we dont have any adjacent land zones wanting support, then just pick a land zone that is closer to the enemy base than the curent water zone (and just want the nearest ot this zone to avoid crossing most of the map just to turn up righta t the enem ybase)
                                elseif not(iCloserLandZoneToEnemy) and not(iLZToSupport) and iEnemyPlateau == tSubtable[M28Map.subrefWPlatAndLZNumber][1] and M28Utilities.GetDistanceBetweenPositions(tWZTeamData[M28Map.reftClosestEnemyBase], tAltLZ[M28Map.subrefMidpoint]) < iMaxDistWantedToEnemyBase then
                                    iCloserPlateauToEnemy = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                                    iCloserLandZoneToEnemy = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                                    if bDebugMessages == true then LOG(sFunctionRef..': Recording backup land zone to travel to='..tSubtable[M28Map.subrefWPlatAndLZNumber][2]..' in plateau '..tSubtable[M28Map.subrefWPlatAndLZNumber][1]) end
                                end
                            end
                        end
                        if iLZToSupport then break end
                    end
                    if not(iLZToSupport) and iCloserLandZoneToEnemy then
                        iLZToSupport = iCloserLandZoneToEnemy
                        iPlateau = iCloserPlateauToEnemy
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iLZToSupport after checking adjacent LZ to all other WZ='..(iLZToSupport or 'nil')) end
                if not(iLZToSupport) then
                    --Get the LZ of the closest base and dont try and do amphibious pathing check
                    iPlateau, iLZToSupport = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tWZTeamData[M28Map.reftClosestEnemyBase])
                    if bDebugMessages == true then LOG(sFunctionRef..': iLZToSupport after checking nearest enemy base land zone='..(iLZToSupport or 'nil')) end
                end
            end
            if not(iLZToSupport) then M28Utilities.ErrorHandler('Unable to find a LZ needing support for water zone '..iWaterZone..'; Pond '..iPond..'; only expected on maps with naval start points', true)
            else
                --We have a LZ to support - decide if we want to send our units there, or if we want to keep them in the water and build up forces
                --If the LZ is a core base LZ or adjacent to a LZ then support
                local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZToSupport]
                local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]

                local bAttackWithEverything = false

                if tLZTeamData[M28Map.subrefLZbCoreBase] or not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) or (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false) then
                    bAttackWithEverything = true
                    if bDebugMessages == true then LOG(sFunctionRef..': No dangerous enemies in this LZ or is a core base, or allied structures are here, so attack with everything. tLZTeamData[M28Map.subrefLZbCoreBase]='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])) end
                else
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                            local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                            if tAltLZTeamData[M28Map.subrefLZbCoreBase] or (M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tAltLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false) then
                                bAttackWithEverything = true
                            end
                        end
                    end
                end
                local iBestEnemyDFRange = 0
                if bDebugMessages == true then LOG(sFunctionRef..': bAttackWithEverything after checking if we want to support a core base/LZ with structures='..tostring(bAttackWithEverything)..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])..'; iLZToSupport='..(iLZToSupport or 'nil')) end
                if not(bAttackWithEverything) then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to check our threat vs enemy threat') end
                    --Do we want to send all units due to having more threat than enemy? Or only if we outrange?
                    local iOurCombatThreat = M28UnitInfo.GetCombatThreatRating(tAmphibiousLabelUnits) + tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]
                    --Calc enemy threat and range in this and adjacent LZs (and also factor in friendly threat in these LZs)
                    iBestEnemyDFRange = math.max(tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange], tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange])
                    local iEnemyCombatThreat = tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]
                    if bDebugMessages == true then LOG(sFunctionRef..': Will calculate enemy threat in range and in adjacent LZs vs friendly threat, based on just this zone iOurCombatThreat='..iOurCombatThreat..'; which includes allied combat threat in the LZ to support of '..(tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 'nil')..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; iLZToSupport='..iLZToSupport) end
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                            local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                            iBestEnemyDFRange = math.max(iBestEnemyDFRange, tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange], tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange])
                            iEnemyCombatThreat = iEnemyCombatThreat + (tAltLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                            iOurCombatThreat = iOurCombatThreat + (tAltLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; iEnemyCombatThreat cumulative='..iEnemyCombatThreat..'; iOurCombatThreat='..iOurCombatThreat) end
                        end
                    end
                    bAttackWithEverything = M28Conditions.HaveEnoughThreatToAttack(iPlateau, iLZToSupport, tLZData, tLZTeamData, iOurCombatThreat, iEnemyCombatThreat, 0, false, iTeam)
                    if not(bAttackWithEverything) then
                        --Check if we include nearby units whether we have enough threat, if we have a high enough value that worth considering
                        if iOurCombatThreat >= 500 then
                            local oClosestAmphibiousToMidpoint = M28Utilities.GetNearestUnit(tAmphibiousLabelUnits, tWZData[M28Map.subrefMidpoint])
                            if M28UnitInfo.IsUnitValid(oClosestAmphibiousToMidpoint) then --redundancy
                                local tNearbyAmphibious = oClosestAmphibiousToMidpoint:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryAmphibiousCombat, oClosestAmphibiousToMidpoint:GetPosition(), 60, 'Ally')
                                local iAltCombatThreat = M28UnitInfo.GetCombatThreatRating(tNearbyAmphibious)
                                if bDebugMessages == true then LOG(sFunctionRef..': iOurCombatThreat='..iOurCombatThreat..'; iAltCombatThreat='..iAltCombatThreat) end
                                if iAltCombatThreat > iOurCombatThreat then
                                    bAttackWithEverything = M28Conditions.HaveEnoughThreatToAttack(iPlateau, iLZToSupport, tLZData, tLZTeamData, iAltCombatThreat, iEnemyCombatThreat, 0, false, iTeam, 1.05)
                                end
                            end

                        end

                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if should attack with everything based on adjacent LZ threat, iOurCombatThreat='..iOurCombatThreat..'; iBestEnemyDFRange='..iBestEnemyDFRange..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; bAttackWithEverything='..tostring(bAttackWithEverything)) end
                end

                --Move units to the LZ to support if we outrange or have sufficient threat
                if bDebugMessages == true then LOG(sFunctionRef..': Will tell units to move to iLZToSupport='..iLZToSupport..'; on Plateau '..iPlateau..'; Dist to WZ midpoint='..M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZToSupport][M28Map.subrefMidpoint], tWZData[M28Map.subrefMidpoint])..'; bAttackWithEverything='..tostring(bAttackWithEverything)..'; iBestEnemyDFRange='..iBestEnemyDFRange..'; tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint])..'; iAmphibiousLabel='..iAmphibiousLabel..'; NavUtils result for amphibious label='..(NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, tLZData[M28Map.subrefMidpoint]) or 'nil')..'; tLZData[M28Map.refiMidpointAmphibiousLabel]='..(tLZData[M28Map.refiMidpointAmphibiousLabel] or 'nil')..'; tLZTeamData[M28Map.reftClosestEnemyBase]='..repru(tLZTeamData[M28Map.reftClosestEnemyBase])) end
                local tHoverDestination = tLZData[M28Map.subrefMidpoint]
                local tAmphibiousDestination
                if iAmphibiousLabel == tLZData[M28Map.refiMidpointAmphibiousLabel] then
                    tAmphibiousDestination = tLZData[M28Map.subrefMidpoint]
                else
                    tAmphibiousDestination = tLZTeamData[M28Map.reftClosestEnemyBase]
                end
                local tHoverRallyPoint
                local tAmphibiousRallyPoint
                --Retreat to base instead of water zone midpoint if the WZs in the pond are <=3 and the depth of the WZ midpoint isn't very large (to reduce risk wew e.g. have ythothas standing in water taking damage but not able to attack)
                if iAmphibiousLabel == tWZData[M28Map.refiMidpointAmphibiousLabel] and not(tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] > tWZTeamData[M28Map.subrefWZThreatAlliedAntiNavy]) and (M28Map.tPondDetails[iPond][M28Map.subrefPondWZCount] >= 3 or M28Map.iMapWaterHeight - GetTerrainHeight(tWZData[M28Map.subrefMidpoint][1],tWZData[M28Map.subrefMidpoint][3]) >= 6.25 or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental, tAmphibiousUnits))) then
                    tAmphibiousRallyPoint = {tWZData[M28Map.subrefMidpoint][1], tWZData[M28Map.subrefMidpoint][2], tWZData[M28Map.subrefMidpoint][3]}
                    if bDebugMessages == true then LOG(sFunctionRef..': Setting amphibious rally point to be the WZ midpoint') end
                else
                    tAmphibiousRallyPoint = {tWZTeamData[M28Map.reftClosestFriendlyBase][1], tWZTeamData[M28Map.reftClosestFriendlyBase][2], tWZTeamData[M28Map.reftClosestFriendlyBase][3]}
                    if bDebugMessages == true then LOG(sFunctionRef..': Setting amphibious rally point to be the closest friendly base') end
                end
                if not(bAttackWithEverything) then
                    --Decide if we want to consolidate hover(surface) units at the waterzone midpoint or not
                    local iClosestCombatEnemyDist = 100000
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestCombatEnemies]) == false then
                        for iEnemy, oEnemy in tLZTeamData[M28Map.reftoNearestCombatEnemies] do
                            iClosestCombatEnemyDist = math.min(iClosestCombatEnemyDist, M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), tAmphibiousRallyPoint))
                        end
                    end
                    if iClosestCombatEnemyDist - iBestEnemyDFRange <= 20 then
                        tHoverRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
                    else
                        --Safe to use amphibious rally point
                        tHoverRallyPoint = tAmphibiousRallyPoint
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': About to give units orders to advance ore retreat or consolidate, bAttackWithEverything='..tostring(bAttackWithEverything)..'; tAmphibiousRallyPoint='..repru(tAmphibiousRallyPoint)..'; tHoverRallyPoint='..repru(tHoverRallyPoint)..'; tAmphibiousDestination='..repru(tAmphibiousDestination)..'; tHoverDestination='..repru(tHoverDestination)..'; rMapPlayableArea='..repru(M28Map.rMapPlayableArea)..'; Amphibious label for amphibious destination='..(NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, tAmphibiousDestination) or 'nil')..'; Amphibious label of WZ midpoint='..(NavUtils.GetLabel('Amphibious', tWZData[M28Map.subrefMidpoint]) or 'nil')) end
                local iOrderReissueDistToUse
                local iResisueOrderDistanceHover = 16
                local iReissueOrderDistanceStandard = 6

                local iCurTime = math.floor(GetGameTimeSeconds())
                function IgnoreOrderDueToStuckUnit(oUnit)
                    if oUnit[M28UnitInfo.refbUnitStuckAlternating] then
                        if (not(oUnit[M28UnitInfo.refbEasyBrain]) or EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnit.UnitId)) and oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition] and M28Utilities.GetDistanceBetweenPositions(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition], oUnit:GetPosition()) >= 15 then
                            --Do nothing - want unit to reach its destination before it gets new orders
                            return true
                        end
                    end
                end

                for iUnit, oUnit in tAmphibiousLabelUnits do
                    if EntityCategoryContains(categories.HOVER, oUnit.UnitId) then iOrderReissueDistToUse = iResisueOrderDistanceHover
                    else iOrderReissueDistToUse = iReissueOrderDistanceStandard
                    end

                    if bAttackWithEverything or ((oUnit[M28UnitInfo.refiDFRange] or 0) > iBestEnemyDFRange and not(EntityCategoryContains(categories.AMPHIBIOUS, oUnit.UnitId))) then
                        if EntityCategoryContains(categories.AMPHIBIOUS, oUnit.UnitId) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Sending amphibious unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to go to amphibious destination; Unit last orders='..reprs(oUnit[M28Orders.reftiLastOrders])..'; Is command queue empty='..tostring(M28Utilities.IsTableEmpty(oUnit:GetCommandQueue()))) end
                            if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                M28Orders.IssueTrackedMove(oUnit, tAmphibiousDestination, iOrderReissueDistToUse, false, 'NMAToLZ'..iLZToSupport..'Fr'..iWaterZone)
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Sending hover unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to go to hover destination') end
                            if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                M28Orders.IssueTrackedMove(oUnit, tHoverDestination, iOrderReissueDistToUse, false, 'NMHToLZ'..iLZToSupport..'Fr'..iWaterZone)
                            end
                        end
                    else
                        if EntityCategoryContains(categories.AMPHIBIOUS, oUnit.UnitId) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Sending amphibious unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to go to amphibious rally point') end
                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, iOrderReissueDistToUse, false, 'NACons'..iWaterZone)
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Sending hover unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to go to hover rally point') end
                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                            M28Orders.IssueTrackedMove(oUnit, tHoverRallyPoint, iOrderReissueDistToUse, false, 'NHCons'..iWaterZone)
                        end
                    end
                end
            end
        end
    end
end

function ManageSpecificWaterZone(aiBrain, iTeam, iPond, iWaterZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageSpecificWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Record enemy threat
    local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
    local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at gametime='..GetGameTimeSeconds()..'; About to update threat for iPond='..iPond..'; iWaterZone='..iWaterZone..'; iTeam='..iTeam..'; Is WZData empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData))) end
    RecordGroundThreatForWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone)
    RecordAirThreatForWaterZone(tWZTeamData, iTeam, iPond, iWaterZone)

    tWZTeamData[M28Map.subrefWZTAlliedCombatUnits] = {}
    tWZTeamData[M28Map.reftoWZUnitsWantingMobileShield] = {}
    tWZTeamData[M28Map.refbWZWantsMobileShield] = false --will change later
    tWZTeamData[M28Map.reftoWZUnitsWantingMobileStealth] = {}
    tWZTeamData[M28Map.refbWZWantsMobileStealth] = false --will change later

    local tEngineers, tScouts, tMobileShields, tMobileStealths, tOtherUnitsToRetreat, tAvailableSubmarines
    local iCurShield, iMaxShield
    local bWaterZoneOrAdjHasUnitsWantingScout = false
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
    local bUpdateEnemyDataHere = true --Will handle this logic in logic for managing water zone units if htis is false
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        --Decide on what to do with units in this WZ
        local bUseFrigatesAsScouts = M28Team.tTeamData[iTeam][M28Team.subrefbUseFrigatesAsScoutsByPond][iPond]
        tEngineers = {}
        tScouts = {}
        tMobileShields = {}
        tMobileStealths = {}
        tOtherUnitsToRetreat = {} --Intended for e.g. fatboys and units with personal shield
        tAvailableSubmarines = {}
        local tAmphibiousUnits = {}
        local tAvailableCombatUnits = {}
        local tUnavailableUnitsInThisWZ = {}
        local tTempOtherUnits = {}
        local tAvailableMAA = {}
        local tMissileShips = {}
        local iCurWZValue = tWZTeamData[M28Map.subrefWZTValue]

        local iOurBestDFRange = 0
        local iOurBestIndirectRange = 0
        local bIncludeUnit

        local iEnemyOmniCoverage = M28Conditions.GetEnemyOmniCoverageOfZone(0, iWaterZone, iTeam)

        local iMobileShieldMassThreshold = 750 --When assigning mobile shields will also restrict further so e.g. seraphim mobile shields will have a higher threshold
        local iMobileShieldHigherMAAMassThreshold = 1500 --for if we have MAA and enemy doesnt have much air threat
        local iMobileStealthMassThreshold = 700 --will get adjusted further
        local iMobileStealthHigherMassThreshold = 1500 --i.e. wont stealth loyalists and titans
        local iUnitMassCost
        local iMobileStealthLowerThresholdCount = 0 --Used to avoid assigning too many mobile stealth at once to units not exceeding the higher mass threshold
        local iLZIslandGivingOrder, iLZIslandTravelingTo
        if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 600 and (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 2000 or tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0) then iMobileShieldHigherMAAMassThreshold = iMobileShieldMassThreshold end

        function RecordIfUnitWantsShieldOrStealth(oUnit)
            iUnitMassCost = (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
            if iUnitMassCost >= iMobileShieldMassThreshold and (iUnitMassCost >= iMobileShieldHigherMAAMassThreshold or iMobileShieldHigherMAAMassThreshold == iMobileShieldMassThreshold or not(EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId))) then
                table.insert(tWZTeamData[M28Map.reftoWZUnitsWantingMobileShield], oUnit)
            end
            if iEnemyOmniCoverage <= 20 then
                if iUnitMassCost >= iMobileStealthHigherMassThreshold then
                    table.insert(tWZTeamData[M28Map.reftoWZUnitsWantingMobileStealth], oUnit)
                elseif iUnitMassCost >= iMobileStealthMassThreshold and EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryIndirect - categories.TECH1, oUnit.UnitId) then
                    --Only say we want a mobile shield if the unit doesnt have one assigned
                    iMobileStealthLowerThresholdCount = iMobileStealthLowerThresholdCount + 1

                    if iMobileStealthLowerThresholdCount >= 3 or oUnit[M28Land.refoAssignedMobileStealth] then
                        iMobileStealthLowerThresholdCount = 0
                        table.insert(tWZTeamData[M28Map.reftoWZUnitsWantingMobileStealth], oUnit)
                    end
                end
            end
        end

        for iUnit, oUnit in tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do
            if oUnit:GetFractionComplete() == 1 then
                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Active raider='..tostring((oUnit[refbActiveRaider] or false))..'; oUnit[M28ACU.refbTreatingAsACU]='..tostring((oUnit[M28ACU.refbTreatingAsACU] or false))..'; Water zone='..iWaterZone..'; Time='..GetGameTimeSeconds()) end
                if oUnit[refbActiveRaider] then
                    --Consider if want shielding or stealth
                    RecordIfUnitWantsShieldOrStealth(oUnit)
                else
                    if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                        table.insert(tEngineers, oUnit)
                        bWaterZoneOrAdjHasUnitsWantingScout = true
                    elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) or oUnit[M28ACU.refbTreatingAsACU] then
                        --ACU logic - handled via M28ACU file, as amy not want to kite with it
                        bWaterZoneOrAdjHasUnitsWantingScout = true
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy * categories.MOBILE, oUnit.UnitId) then
                        if EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit.UnitId) or (bUseFrigatesAsScouts and EntityCategoryContains(M28UnitInfo.refCategoryFrigate, oUnit.UnitId)) then
                            table.insert(tScouts, oUnit)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryShieldBoat, oUnit.UnitId) then
                            table.insert(tMobileShields, oUnit)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryStealthBoat, oUnit.UnitId) then
                            table.insert(tMobileStealths, oUnit)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryNavalAA + M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategorySubmarine - categories.COMMAND - M28UnitInfo.refCategoryRASSACU, oUnit.UnitId) then
                            bIncludeUnit = false
                            bWaterZoneOrAdjHasUnitsWantingScout = true
                            --Is the unit available for use by this water zone?
                            --Is the unit's priority lower than this?
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if have available combat or MAA unit, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[refiCurrentWZAssignmentValue]='..(oUnit[refiCurrentWZAssignmentValue] or 'nil')..'; oUnit[refiCurrentAssignmentWaterZone]='..(oUnit[refiCurrentAssignmentWaterZone] or 'nil')..'; LZ assignment='..repru(oUnit[M28Land.refiCurrentAssignmentPlateauAndLZ])..'; Time since last WZ assignment='..(GetGameTimeSeconds() - (oUnit[refiTimeOfLastWZAssignment] or 0))..'; Does unit contain MAA category='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryNavalAA, oUnit.UnitId))) end
                            if (oUnit[refiCurrentWZAssignmentValue] or 0) < iCurWZValue or (oUnit[refiCurrentAssignmentWaterZone] == iWaterZone or (GetGameTimeSeconds() - (oUnit[refiTimeOfLastWZAssignment] or 0) >= 10 and not(oUnit[M28Land.refiCurrentAssignmentPlateauAndLZ]))) then
                                --Is it a unit with a shield that wants to retreat so its shield can regen?
                                iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, true)
                                if iMaxShield > 0 and iCurShield < iMaxShield * 0.35 and iMaxShield > oUnit:GetMaxHealth() * 0.8 then --primarily fatboy, but in theory could affect SACUs
                                    table.insert(tOtherUnitsToRetreat, oUnit)
                                    oUnit[refiCurrentWZAssignmentValue] = 100000
                                else
                                    bIncludeUnit = true
                                    if EntityCategoryContains(M28UnitInfo.refCategorySubmarine - M28UnitInfo.refCategorySeraphimDestroyer, oUnit.UnitId) then
                                        table.insert(tAvailableSubmarines, oUnit)
                                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryNavalAA, oUnit.UnitId) then
                                        table.insert(tAvailableMAA, oUnit)
                                    elseif ((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > 0) and EntityCategoryContains(M28UnitInfo.refCategoryNavalSurface + categories.HOVER - M28UnitInfo.refCategoryLandExperimental * categories.AMPHIBIOUS - M28UnitInfo.refCategoryLandCombat * categories.AMPHIBIOUS + M28UnitInfo.refCategorySeraphimDestroyer, oUnit.UnitId) then
                                        table.insert(tAvailableCombatUnits, oUnit)
                                        table.insert(tWZTeamData[M28Map.subrefWZTAlliedCombatUnits], oUnit)
                                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMissileShip, oUnit.UnitId) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Adding unit from this WZ to table of missile ships, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                        table.insert(tMissileShips, oUnit)
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have an amphibious unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; AntiNavyRange='..(oUnit[M28UnitInfo.refiAntiNavyRange] or 0)) end
                                        table.insert(tAmphibiousUnits, oUnit)
                                    end
                                    if bIncludeUnit then
                                        RecordUnitAsReceivingWaterZoneAssignment(oUnit, iWaterZone, iCurWZValue)
                                    end
                                end
                                --Is this a land unit traveling from 1 island to another island? In which case also want to consider
                            elseif oUnit[refiCurrentAssignmentWaterZone] == nil and oUnit[M28Land.refiCurrentAssignmentPlateauAndLZ][2] then
                                local tLastOrder = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]]
                                if tLastOrder and tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueMove then
                                    local tAssignmentLZData = M28Map.tAllPlateaus[oUnit[M28Land.refiCurrentAssignmentPlateauAndLZ][1]][M28Map.subrefPlateauLandZones][oUnit[M28Land.refiCurrentAssignmentPlateauAndLZ][2]]

                                    iLZIslandGivingOrder = NavUtils.GetLabel(M28Map.refPathingTypeLand, tAssignmentLZData[M28Map.subrefMidpoint])
                                    iLZIslandTravelingTo = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLastOrder[M28Orders.subreftOrderPosition])
                                    if iLZIslandTravelingTo and not(iLZIslandGivingOrder == iLZIslandTravelingTo) then
                                        bIncludeUnit = true
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have a unit that was given a plateau and LZ assignment and has no WZ assignment, Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iLZIslandGivingOrder='..(iLZIslandGivingOrder or 'nil')..'; iLZIslandTravelingTo='..(iLZIslandTravelingTo or 'nil')..'; bIncludeUnit='..tostring(bIncludeUnit)) end

                                end
                                if bIncludeUnit then
                                    if bIncludeUnit then
                                        RecordUnitAsReceivingWaterZoneAssignment(oUnit, iWaterZone, iCurWZValue)

                                    end
                                else
                                    table.insert(tUnavailableUnitsInThisWZ, oUnit)
                                end
                            else
                                table.insert(tUnavailableUnitsInThisWZ, oUnit)
                            end
                            RecordIfUnitWantsShieldOrStealth(oUnit)
                        end
                    elseif EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                        --Structure logic - handled separately e.g. via M28Factory for factories
                    else
                        table.insert(tTempOtherUnits, oUnit)
                        if not(tbBlueprintsAddedToTempTable[oUnit.UnitId]) then
                            M28Utilities.ErrorHandler('Adding unit ID '..oUnit.UnitId..' to table of temp other units - either the unit is a land unit really close to water that we incorrectly think is in water, or it is an amphibious/hover unit that has incorrect caterisation; if the unit runs out of orders then will send it to the rally point', true)
                            tbBlueprintsAddedToTempTable[oUnit.UnitId] = true
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of engineers empty='..tostring(M28Utilities.IsTableEmpty(tEngineers))..'; Is table of combat units just for this zone empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))) end

        --Mobile shield data:
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoWZUnitsWantingMobileShield]) == false then
            for iUnit, oUnit in tWZTeamData[M28Map.reftoWZUnitsWantingMobileShield] do
                if oUnit[M28Land.refoAssignedMobileShield] then
                    if not(M28UnitInfo.IsUnitValid(oUnit[M28Land.refoAssignedMobileShield])) then
                        oUnit[M28Land.refoAssignedMobileShield] = nil
                        tWZTeamData[M28Map.refbWZWantsMobileShield] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording that the water zone '..iWaterZone..' wants mobile shields as a unit that had a mobile shield no longerh as a valid one') end
                    end
                else
                    tWZTeamData[M28Map.refbWZWantsMobileShield] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording that the water zone '..iWaterZone..' wants mobile shields as it has a unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that doesnt have an assigned mobile shield yet') end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tMobileShields) == false then
            ManageMobileShieldsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tMobileShields)
        end
        --Mobile stealth data:
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoWZUnitsWantingMobileStealth]) == false then
            for iUnit, oUnit in tWZTeamData[M28Map.reftoWZUnitsWantingMobileStealth] do
                if iEnemyOmniCoverage > 20 then
                    if M28UnitInfo.IsUnitValid(oUnit[M28Land.refoAssignedMobileStealth]) then
                        oUnit[M28Land.refoAssignedMobileStealth][M28Land.refoMobileStealthTarget] = nil
                        oUnit[M28Land.refoAssignedMobileStealth] = nil
                    end
                elseif oUnit[M28Land.refoAssignedMobileStealth] then
                    if not(M28UnitInfo.IsUnitValid(oUnit[M28Land.refoAssignedMobileStealth])) then
                        oUnit[M28Land.refoAssignedMobileStealth] = nil
                        tWZTeamData[M28Map.refbWZWantsMobileStealth] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording that the water zone '..iWaterZone..' wants mobile Stealths as a unit that had a mobile Stealth no longerh as a valid one') end
                    end
                else
                    tWZTeamData[M28Map.refbWZWantsMobileStealth] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording that the water zone '..iWaterZone..' wants mobile Stealths as it has a unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that doesnt have an assigned mobile Stealth yet') end
                end
            end
            if iEnemyOmniCoverage > 20 then tWZTeamData[M28Map.refbWZWantsMobileStealth] = false end --redundancy
        end
        if M28Utilities.IsTableEmpty(tMobileStealths) == false then
            ManageMobileStealthsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tMobileStealths)
        end

        local iCurCombatThreat = tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]
        local iCurMAAThreat = tWZTeamData[M28Map.subrefWZThreatAlliedAA]

        local bConsiderAdjacentCombat = false
        local bConsiderAdjacentMAA = false
        if iCurCombatThreat < tWZTeamData[M28Map.subrefWZCombatThreatWanted] then bConsiderAdjacentCombat = true end
        if iCurMAAThreat < tWZTeamData[M28Map.subrefWZMAAThreatWanted] then bConsiderAdjacentMAA = true end


        --Add adjacent combat units if the water zone is lower priority than us and the adjacent WZ doesnt have combat units of a significant threat in it
        local iCurUnitThreat
        if bDebugMessages == true then LOG(sFunctionRef..': Will consider including adjacent combat units for WZ '..iWaterZone..' with iCurWZValue='..iCurWZValue..'; is table of adjacent WZs empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]))..'; bConsiderAdjacentCombat='..tostring(bConsiderAdjacentCombat)) end
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false and bConsiderAdjacentCombat then
            local iAdjWZ
            for iEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                local tAltWZTeam = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': iPond='..iPond..'; Base WZ='..iWaterZone..'; iAdjWZ='..iAdjWZ..'; WZTValue='..repru(tAltWZTeam[M28Map.subrefWZTValue])..'; Is table of allied combat units empty='..tostring(M28Utilities.IsTableEmpty(tAltWZTeam[M28Map.subrefWZTAlliedCombatUnits]))) end
                if not(bWaterZoneOrAdjHasUnitsWantingScout) and M28Utilities.IsTableEmpty(tAltWZTeam[M28Map.subrefWZTAlliedCombatUnits]) == false then bWaterZoneOrAdjHasUnitsWantingScout = true end
                if tAltWZTeam[M28Map.subrefWZTValue] < iCurWZValue and tAltWZTeam[M28Map.subrefTThreatEnemyCombatTotal] <= 50 and M28Utilities.IsTableEmpty(tAltWZTeam[M28Map.subrefWZTAlliedCombatUnits]) == false then
                    for iUnit, oUnit in tAltWZTeam[M28Map.subrefWZTAlliedCombatUnits] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to add adjacent WZ oUnit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' with cur assignment value '..(oUnit[refiCurrentWZAssignmentValue] or 0)..' and cur assignemnt WZ='..(oUnit[refiCurrentAssignmentWaterZone] or 'nil')) end
                        if not(oUnit.Dead) and not(oUnit[refbActiveRaider]) and ((oUnit[refiCurrentWZAssignmentValue] or 0) < iCurWZValue or (oUnit[refiCurrentAssignmentWaterZone] == iWaterZone)) then
                            --Combat unit related
                            if bConsiderAdjacentCombat and (oUnit[M28UnitInfo.refiDFRange] > 0 or oUnit[M28UnitInfo.refiAntiNavyRange] > 0) and not(EntityCategoryContains(M28UnitInfo.refCategoryCruiser, oUnit.UnitId)) then
                                table.insert(tAvailableCombatUnits, oUnit)
                                RecordUnitAsReceivingWaterZoneAssignment(oUnit, iWaterZone, iCurWZValue)

                                iCurUnitThreat = M28UnitInfo.GetCombatThreatRating({ oUnit })

                                if iCurUnitThreat > tWZTeamData[M28Map.subrefWZCombatThreatWanted] then
                                    bConsiderAdjacentCombat = false
                                    if not(bConsiderAdjacentMAA) then break end
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryNavalAA, oUnit.UnitId) then
                                table.insert(tAvailableMAA, oUnit)
                                RecordUnitAsReceivingWaterZoneAssignment(oUnit, iWaterZone, iCurWZValue)

                                iCurUnitThreat = M28UnitInfo.GetAirThreatLevel({ oUnit }, false, false, true)
                                iCurMAAThreat = iCurMAAThreat + iCurUnitThreat
                                if iCurMAAThreat > tWZTeamData[M28Map.subrefWZMAAThreatWanted] then
                                    bConsiderAdjacentMAA = false
                                    if not(bConsiderAdjacentCombat) then break end
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryMissileShip, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit from adj WZ to table of missile ships, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                table.insert(tMissileShips, oUnit)
                            end
                        end
                    end
                    if not(bConsiderAdjacentCombat) and not(bConsiderAdjacentMAA) then break end
                end
            end
        end

        if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false or M28Utilities.IsTableEmpty(tAvailableSubmarines) == false or M28Utilities.IsTableEmpty(tMissileShips) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': About to manage combat units in the WZ') end
            if tWZData[M28Map.subrefbPacifistArea] then
                if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
                    RetreatOtherUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableCombatUnits)
                end
                if M28Utilities.IsTableEmpty(tAvailableSubmarines) == false then
                    RetreatOtherUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableSubmarines)
                end
            else
                --ManageCombatUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableCombatUnits, tAvailableSubmarines, tUnavailableUnitsInThisWZ, tMissileShips)
                local tRemainingLandUnits = ManageCombatUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableCombatUnits, tAvailableSubmarines, tUnavailableUnitsInThisWZ, tMissileShips)
                if M28Utilities.IsTableEmpty(tRemainingLandUnits) == false then
                    for iUnit, oUnit in tRemainingLandUnits do
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of amphibious units from table of remaining land units') end
                        table.insert(tAmphibiousUnits, oUnit)
                    end
                end
                bUpdateEnemyDataHere = false
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of MAA empty='..tostring(M28Utilities.IsTableEmpty(tAvailableMAA))..'; Is table of entity filtered dow nto MAA empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMAA, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))) end
        if M28Utilities.IsTableEmpty(tAvailableMAA) == false then
            if tWZData[M28Map.subrefbPacifistArea] then
                RetreatOtherUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableMAA)
            else
                ManageMAAInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableMAA)
            end
        end

        if M28Utilities.IsTableEmpty(tOtherUnitsToRetreat) == false then
            RetreatOtherUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tOtherUnitsToRetreat)
        end

        if M28Utilities.IsTableEmpty(tTempOtherUnits) == false then
            --Likely have had land units that are on a location thought to be water due to flaws in the navigational mesh/pathfinding approach - only issue new orders if they have none
            local tRallyPoint = {tWZTeamData[M28Map.reftClosestFriendlyBase][1], tWZTeamData[M28Map.reftClosestFriendlyBase][2], tWZTeamData[M28Map.reftClosestFriendlyBase][3]}
            for iUnit, oUnit in tTempOtherUnits do
                M28Orders.UpdateRecordedOrders(oUnit)
                if oUnit[M28Orders.refiOrderCount] == 0 then
                    --Move to nearest allied base
                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 30, false, 'BckLRP')
                end
            end
        end

        --Decide where to send any unassigned land pathable units
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if have unassigned land pathable units, Is tAmphibiousUnits empty='..tostring(M28Utilities.IsTableEmpty(tAmphibiousUnits))) end
        if M28Utilities.IsTableEmpty(tAmphibiousUnits) == false then
            MoveUnassignedLandUnits(tWZData, tWZTeamData, iPond, iWaterZone, iTeam, tAmphibiousUnits)
        end

    end
    --Update enemy ranges for this WZ and decide if this WZ still wants support, if we havent run our main combat management logic
    if bDebugMessages == true then LOG(sFunctionRef..': Will update enemy data for this WZ if are enemies in this WZ. bUpdateEnemyDataHere='..tostring(bUpdateEnemyDataHere or false)) end
    if bUpdateEnemyDataHere then
        RecordClosestAdjacentRangesAndEnemies(tWZData, tWZTeamData, iPond, iWaterZone, iTeam)
        if bDebugMessages == true then LOG(sFunctionRef..': Deciding if want support, iWaterZone='..iWaterZone..'; tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]='..tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])..'; tWZTeamData[M28Map.subrefWZTValue]='..tWZTeamData[M28Map.subrefWZTValue]..'; Pacifist area='..tostring(tWZData[M28Map.subrefbPacifistArea])..'; Midpoint in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tWZData[M28Map.subrefMidpoint]))) end
        if tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] and tWZTeamData[M28Map.subrefWZTValue] >= 200 and not(tWZData[M28Map.subrefbPacifistArea]) then
            UpdateIfWaterZoneWantsSupport(tWZTeamData, true)
            if bDebugMessages == true then LOG(sFunctionRef..': Will update to flag this water zone wants combat support') end
        else
            UpdateIfWaterZoneWantsSupport(tWZTeamData, false)
            if bDebugMessages == true then LOG(sFunctionRef..': Dont want support') end
        end
    end
    --Handle engineers and even if no engineers still decide what engineers we would want for hte WZ
    M28Engineer.ConsiderLandOrWaterZoneEngineerAssignment(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tEngineers, true) --Should update the water zone engineer requirements, even if tEngineers itself is empty

    --Manage any scouts and flag if we need scouts (i.e. want to run this function even if we have no scouts)
    ManageWaterZoneScouts(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tScouts, bWaterZoneOrAdjHasUnitsWantingScout)

    --Treat omni as giving us visual
    if tWZTeamData[M28Map.refiOmniCoverage] > 40 then tWZTeamData[M28Map.refiTimeLastHadVisual] = GetGameTimeSeconds() end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iPond='..iPond..'; iWaterZone='..iWaterZone) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AssignValuesToWaterZones(iTeam)
    --Periodically cycles through every water zone and refreshes the unit details
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignValuesToWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        if bDebugMessages == true then LOG(sFunctionRef .. ': About to start the main loop for assigning values to water zones provided we have friendly M28 brains in the team ' .. iTeam .. '; is table empty=' .. tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))..'; Is M28Map.tPondDetails empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tPondDetails))) end
        local iCurValue
        local iBuildLocationSegmentX, iBuildLocationSegmentZ
        if M28Utilities.IsTableEmpty(M28Map.tPondDetails) == false then
            for iPond, tPondSubtable in M28Map.tPondDetails do
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iPond='..iPond..'; oBrain='..oBrain.Nickname..'; Does this brain have a build location for this pond='..repru(tPondSubtable[M28Map.subrefBuildLocationByStartPosition][oBrain:GetArmyIndex()])) end
                    if tPondSubtable[M28Map.subrefBuildLocationByStartPosition][oBrain:GetArmyIndex()] then
                        iBuildLocationSegmentX, iBuildLocationSegmentZ = M28Map.GetPathingSegmentFromPosition(tPondSubtable[M28Map.subrefBuildLocationByStartPosition][oBrain:GetArmyIndex()])
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering oBrain='..oBrain.Nickname..' on iTeam='..iTeam..'; iBuildLocationSegmentX='..iBuildLocationSegmentX..'; iBuildLocationSegmentZ='..iBuildLocationSegmentZ..'; Water zone for these segments='..M28Map.tWaterZoneBySegment[iBuildLocationSegmentX][iBuildLocationSegmentZ]..'; Is pond subtable empty='..tostring(M28Utilities.IsTableEmpty( tPondSubtable[M28Map.subrefPondWaterZones]))..'; Is WZ data empty='..tostring(M28Utilities.IsTableEmpty(tPondSubtable[M28Map.subrefPondWaterZones][M28Map.tWaterZoneBySegment[iBuildLocationSegmentX][iBuildLocationSegmentZ]]))) end
                        if M28Map.tWaterZoneBySegment[iBuildLocationSegmentX][iBuildLocationSegmentZ] then
                            local tWZData = tPondSubtable[M28Map.subrefPondWaterZones][M28Map.tWaterZoneBySegment[iBuildLocationSegmentX][iBuildLocationSegmentZ]]
                            if tWZData then
                                local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                                if not(tWZTeamData) then
                                    M28Team.SetWaterZoneDefaultTeamValues(tWZData, iTeam)
                                    M28Utilities.ErrorHandler('Have valid WZ data but not team data, for water zone '..(M28Map.tWaterZoneBySegment[iBuildLocationSegmentX][iBuildLocationSegmentZ] or 'nil')..'; will record teh default values for the water zone')
                                end
                                tWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation] = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Have flagged that water zone '..M28Map.tWaterZoneBySegment[iBuildLocationSegmentX][iBuildLocationSegmentZ]..'; Contains a naval build location') end

                            else
                                M28Utilities.ErrorHandler('Have empty tWZData for water zone '..(M28Map.tWaterZoneBySegment[iBuildLocationSegmentX][iBuildLocationSegmentZ] or 'nil'))
                            end
                        end
                    end

                end
            end


            while M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false do
                local iBaseCategory = M28UnitInfo.refCategoryNavalFactory
                for iPond, tPondSubtable in M28Map.tPondDetails do
                    if M28Utilities.IsTableEmpty(tPondSubtable[M28Map.subrefPondWaterZones]) == false then
                        for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
                            if bDebugMessages == true then LOG(sFunctionRef..': About to refresh value of iPond='..iPond..'; iWaterZone='..iWaterZone..' for team '..iTeam) end
                            --Decide on value of the water zone ignoring distance:
                            iCurValue = 1000
                            --Are we adjacent to a core base? If so increase the value; also increase value if we are a core base
                            local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                            if tWZTeamData[M28Map.subrefWZbCoreBase] then iCurValue = iCurValue * 2
                            elseif M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                                for iEntry, tAltWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                                    if M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tAltWZSubtable[M28Map.subrefWZAWZRef]][M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZbCoreBase] then
                                        iCurValue = iCurValue * 1.5
                                        break
                                    end
                                end
                            end

                            --Record the value
                            tWZTeamData[M28Map.subrefWZTValue] = iCurValue
                            tWZTeamData[M28Map.subrefWZbCoreBase] = nil

                            --Is this a core base water zone?
                            if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to set water zone '..iWaterZone..' in pond '..(M28Map.tiPondByWaterZone[iWaterZone] or 'nil')..' as a core base, does it contain naval build location='..tostring(tWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation])..'; M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]]='..(M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]] or 'nil')..'; Is table of allied units for this WZ empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subreftoLZOrWZAlliedUnits]))) end
                            if tWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation] and ((M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]] or 0) > 0 or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Setting iWaterZone='..iWaterZone..' to be a WZ core base as it contains a naval build location') end
                                tWZTeamData[M28Map.subrefWZbCoreBase] = true
                            elseif M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                local tFactories = EntityCategoryFilterDown(iBaseCategory, tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subreftoLZOrWZAlliedUnits])
                                if M28Utilities.IsTableEmpty(tFactories) == false then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Setting iWaterZone='..iWaterZone..' to be a WZ core base as it contains factories') end
                                    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZbCoreBase] = true
                                end
                            end

                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitTicks(1)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        end
                    end
                end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
        end
    else
        M28Utilities.ErrorHandler('No active M28 brain')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function WaterZoneOverseer(iTeam)
    --Periodically cycles through every water zone and refreshes the unit details
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'WaterZoneOverseer'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    while not(M28Map.bWaterZoneInitialCreation) or not(M28Map.bFirstM28TeamHasBeenInitialised) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if GetGameTimeSeconds() >= 60 then break end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitSeconds(1) --make sure other code such as team initialisation has run
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)

    if aiBrain.HostileCampaignAI and tonumber(ScenarioInfo.Options.CmpAIDelay) > GetGameTimeSeconds() + 1 then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(tonumber(ScenarioInfo.Options.CmpAIDelay) - GetGameTimeSeconds()-1.0)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    if bDebugMessages == true then LOG(sFunctionRef..': About to start the main loop for water zones provided we have friendly M28 brains in the team '..iTeam..'; is table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        if ScenarioInfo.OpEnded and M28Map.bIsCampaignMap and GetGameTimeSeconds() <= 120 then
            while ScenarioInfo.OpEnded do
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) then break end
            end
        end
        ForkThread(AssignValuesToWaterZones, iTeam)
    end

    while M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false do
        if ScenarioInfo.OpEnded and M28Map.bIsCampaignMap and GetGameTimeSeconds() <= 120 then
            while ScenarioInfo.OpEnded do
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) then break end
            end
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) then break end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Will call logic to refresh every unit in a water zone') end
        ForkThread(ManageAllWaterZones, aiBrain, iTeam)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if aiBrain.M28IsDefeated and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
            aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': About to restart the loop for team '..iTeam..'; aiBrain referred to='..(aiBrain.Nickname or 'nil')..'; Is table of active m28 brains='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordClosestAdjacentRangesAndEnemies(tWZData, tWZTeamData, iPond, iWaterZone, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordClosestAdjacentRangesAndEnemies'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    tWZTeamData[M28Map.reftoNearestCombatEnemies] = {}
    
    local iEnemyBestAntiNavyRange = 0
    local iEnemyBestCombatRange = 0
    local iBestEnemyUnderwaterRange = 0

    
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iTeam='..iTeam..'; iPond='..iPond..'; iWaterZone='..iWaterZone..'; Enemies in this or adjacent WZ='..tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])) end
    if tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then
        iEnemyBestAntiNavyRange = (tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] or 0)
        iEnemyBestCombatRange = math.max((tWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0), iEnemyBestAntiNavyRange)
        iBestEnemyUnderwaterRange = (tWZTeamData[M28Map.subrefWZBestEnemySubmersibleRange] or 0)


        --Adjust the ranges to factor in adjacent water zones
        local iLowestDistUntilInRange = 10000
        local oLowestDFDistUntilInRange
        local tMidpoint = tWZData[M28Map.subrefMidpoint]
        if M28Utilities.IsTableEmpty(tMidpoint) then
            --Got an error in coop so put in below as a redundancy in case had no midpoint (but couldve been another reason)
            M28Utilities.ErrorHandler('No midpoint for water zone '..iWaterZone..' for iPond='..iPond..'; will try and record again')
            M28Map.RecordMidpointMinAndMaxSegmentForWaterZone(iWaterZone, iPond, tWZData)
        end
        local iCurDistUntilInRange
        if bDebugMessages == true then LOG(sFunctionRef..': Best DF range for this zone only='..tWZTeamData[M28Map.subrefWZBestEnemyDFRange]..'; best antinavy='..tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange]..';  Is table of adjacent WZs empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]))) end
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
            for iEntry, iAdjWaterZone in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                iLowestDistUntilInRange = 10000
                oLowestDFDistUntilInRange = nil
                local tAltWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWaterZone][M28Map.subrefWZTeamData][iTeam]
                iEnemyBestAntiNavyRange = math.max(iEnemyBestAntiNavyRange, (tAltWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] or 0))
                iEnemyBestCombatRange = math.max(iEnemyBestCombatRange, iEnemyBestAntiNavyRange, (tAltWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0))
                iBestEnemyUnderwaterRange = math.max(iBestEnemyUnderwaterRange, (tAltWZTeamData[M28Map.subrefWZBestEnemySubmersibleRange] or 0))

                if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent WZ '..iAdjWaterZone..'; tAltWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange]='..tAltWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange]..'; tAltWZTeamData[M28Map.subrefWZBestEnemyDFRange]='..tAltWZTeamData[M28Map.subrefWZBestEnemyDFRange]) end
                if M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subrefTEnemyUnits]) == false and tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 10 then
                    for iUnit, oUnit in tAltWZTeamData[M28Map.subrefTEnemyUnits] do
                        if M28UnitInfo.IsUnitValid(oUnit) and (oUnit[M28UnitInfo.refiDFRange] > 0 or oUnit[M28UnitInfo.refiAntiNavyRange] > 0) and oUnit:GetFractionComplete() >= 0.95 then
                            iCurDistUntilInRange = M28Utilities.GetDistanceBetweenPositions((oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or oUnit:GetPosition()), tMidpoint) - math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiAntiNavyRange] or 0))
                            if iCurDistUntilInRange < iLowestDistUntilInRange then
                                oLowestDFDistUntilInRange = oUnit
                                iLowestDistUntilInRange = iCurDistUntilInRange
                            end
                        end
                    end
                end
                if oLowestDFDistUntilInRange  then
                    table.insert(tWZTeamData[M28Map.reftoNearestCombatEnemies], oLowestDFDistUntilInRange)
                end
            end
        end

        --Add all units from this zone into reftoNearestCombatEnemies
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false and tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] then
            for iUnit, oUnit in tWZTeamData[M28Map.subrefTEnemyUnits] do
                if oUnit[M28UnitInfo.refiDFRange] > 0 or oUnit[M28UnitInfo.refiAntiNavyRange] > 0 then
                    table.insert(tWZTeamData[M28Map.reftoNearestCombatEnemies], oUnit)
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iEnemyBestAntiNavyRange='..iEnemyBestAntiNavyRange..'; iEnemyBestCombatRange='..iEnemyBestCombatRange..'; iBestEnemyUnderwaterRange='..iBestEnemyUnderwaterRange) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iEnemyBestAntiNavyRange, iEnemyBestCombatRange, iBestEnemyUnderwaterRange
end

function ConsiderOrdersForUnitsWithNoTarget(tWZData, iPond, iWaterZone, iTeam, tSubmarinesWithNoTarget, tCombatUnitsWithNoTarget, tMissileShips)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderOrdersForUnitsWithNoTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Handles logic for deciding where to send units to support other water zones (or returns units that could be used to support land zones), and also to handle bombardment logic
    local tUnassignedLandUnits
    local iOrderReissueDistToUse
    local iResisueOrderDistanceHover = 16
    local iReissueOrderDistanceStandard = 6

    --Do we have adjacent zones wanting reinforcements?
    local iSubmersibleWZToSupport
    local iNoAntiNavyWZToSupport
    local iWZToSupport

    local tUnitsWithOnlyAntiNavy = tSubmarinesWithNoTarget
    if not(tUnitsWithOnlyAntiNavy) then tUnitsWithOnlyAntiNavy = {} end
    local tUnitsWithNoAntiNavy = {}
    local tUnitsWithAntiNavyAndSurface = {}
    local tPotentialBombardmentUnits
    if M28Utilities.IsTableEmpty(tCombatUnitsWithNoTarget) == false then
        for iUnit, oUnit in tCombatUnitsWithNoTarget do
            if (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) == 0 then
                table.insert(tUnitsWithNoAntiNavy, oUnit)
            else
                if (oUnit[M28UnitInfo.refiDFRange] or 0) == 0 then
                    table.insert(tUnitsWithOnlyAntiNavy, oUnit)
                else
                    table.insert(tUnitsWithAntiNavyAndSurface, oUnit)
                end
            end
        end
    end
    local bHaveSubs = not(M28Utilities.IsTableEmpty(tUnitsWithOnlyAntiNavy))


    if bDebugMessages == true then LOG(sFunctionRef..': Dont have any enemy units in this WZ or adjacent WZ, so will consider supporting other water zones, is table of other zones empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]))) end
    local bSupportLowValueRequests = true
    local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
    if tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] + tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] <= 400 then
        bSupportLowValueRequests = false
    end
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
        local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
        for iEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
            local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tWZSubtable[M28Map.subrefWZAWZRef]]
            if bDebugMessages == true then LOG(sFunctionRef..': Considering WZ '..tWZSubtable[M28Map.subrefWZAWZRef]..'; Is the midpoint in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAltWZData[M28Map.subrefMidpoint]))) end
            if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAltWZData[M28Map.subrefMidpoint]) then
                local tAltWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tWZSubtable[M28Map.subrefWZAWZRef]][M28Map.subrefWZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': Considering water zone '..tWZSubtable[M28Map.subrefWZAWZRef]..'; Does this want support='..tostring(tAltWZTeamData[M28Map.subrefbWZWantsSupport])..'; Combat threat wanted='..(tAltWZTeamData[M28Map.subrefWZCombatThreatWanted] or 'nil')) end
                if tAltWZTeamData[M28Map.subrefbWZWantsSupport] and (bSupportLowValueRequests or (tAltWZTeamData[M28Map.subrefWZCombatThreatWanted] or 0) >= 40) then
                    if not(iWZToSupport) then iWZToSupport = tWZSubtable[M28Map.subrefWZAWZRef] end
                    if bHaveSubs and not(iSubmersibleWZToSupport) then
                        if not(tAltWZTeamData[M28Map.subrefbWZOnlyHoverEnemies]) then
                            iSubmersibleWZToSupport = tWZSubtable[M28Map.subrefWZAWZRef]
                        end
                    end
                    if not(iNoAntiNavyWZToSupport) and not(tAltWZTeamData[M28Map.subrefbWZOnlySubmersibleEnemies]) then
                        iNoAntiNavyWZToSupport = tWZSubtable[M28Map.subrefWZAWZRef]
                    end
                    if iNoAntiNavyWZToSupport and iWZToSupport and (iSubmersibleWZToSupport or not(bHaveSubs)) then
                        break
                    end
                end
            end
        end
    end

    --Decide on what to do based on the units we have:
    --Subs
    if M28Utilities.IsTableEmpty(tUnitsWithOnlyAntiNavy) == false then
        --Subs - send to nearest WZ wanting sub support; if is none, then send to nearest WZ wanting support; if is none, then do nothing
        if bDebugMessages == true then LOG(sFunctionRef..': Sending subs to nearest WZ wanting sub support, or if none then nearest WZ wanting support, iSubmersibleWZToSupport='..(iSubmersibleWZToSupport or 'nil')..'; iWZToSupport='..(iWZToSupport or 'nil')) end
        if not(iSubmersibleWZToSupport) then iSubmersibleWZToSupport = iWZToSupport end
        if iSubmersibleWZToSupport then
            local tSupportWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iSubmersibleWZToSupport]
            for iUnit, oUnit in tUnitsWithOnlyAntiNavy do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering sub unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[refiCurrentWZAssignmentValue]='..oUnit[refiCurrentWZAssignmentValue]..'; oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam]='..oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam]..'; iWaterZone='..iWaterZone) end
                if not(oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iWaterZone) then
                    --Unit is from a different zone - need to change the value of its assignment so it is considered for orders by the zone that it is part of
                    oUnit[refiCurrentWZAssignmentValue] = 0
                else
                    M28Orders.IssueTrackedMove(oUnit, tSupportWZData[M28Map.subrefMidpoint], iReissueOrderDistanceStandard, false, 'NSDFMovWZ' .. iWZToSupport .. ';' .. iWaterZone)
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Have no WZ to support so no orders to give subs') end
        end
    end
    local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
    --Units with surface attack but no antinavy attack - switch to bombardment mode if nowhere to support; also use attack-move if have decent range and not blocked shot
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of units with no anti navy empty='..tostring(M28Utilities.IsTableEmpty(tUnitsWithNoAntiNavy))..'; iNoAntiNavyWZToSupport='..(iNoAntiNavyWZToSupport or 'nil')) end
    if M28Utilities.IsTableEmpty(tUnitsWithNoAntiNavy) == false then
        if not(iNoAntiNavyWZToSupport) then
            tUnassignedLandUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryAmphibiousCombat, tUnitsWithNoAntiNavy)
            tPotentialBombardmentUnits = EntityCategoryFilterDown(categories.ALLUNITS - M28UnitInfo.refCategoryAmphibiousCombat, tUnitsWithNoAntiNavy)
        else
            local tSupportWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iNoAntiNavyWZToSupport]
            if bDebugMessages == true then LOG(sFunctionRef..': Combat threat wanted by zone='..(tSupportWZData[M28Map.subrefWZCombatThreatWanted] or 'nil')) end
            for iUnit, oUnit in tUnitsWithNoAntiNavy do
                if bDebugMessages == true then LOG(sFunctionRef..': Getting unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to move to the support WZ='..iNoAntiNavyWZToSupport..' unless it is assigned to a dif zone to this, iWaterZone='..iWaterZone..'; oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam]='..oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam]) end
                if not(oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iWaterZone) then
                    --Unit is from a different zone - need to change the value of its assignment so it is considered for orders by the zone that it is part of
                    oUnit[refiCurrentWZAssignmentValue] = 0
                    if bDebugMessages == true then LOG(sFunctionRef..': Setting unit assignment value to 0') end
                else
                    if EntityCategoryContains(categories.HOVER, oUnit.UnitId) then iOrderReissueDistToUse = iResisueOrderDistanceHover
                    else iOrderReissueDistToUse = iReissueOrderDistanceStandard
                    end
                    if oUnit[M28UnitInfo.refiCombatRange] >= 40 and (not(oUnit[M28UnitInfo.refbLastShotBlocked]) or (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) <= 10 or GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) > 6) then
                        M28Orders.IssueTrackedAggressiveMove(oUnit, tSupportWZData[M28Map.subrefMidpoint], iOrderReissueDistToUse, false, 'NSFAMovWZ' .. iWZToSupport .. ';' .. iWaterZone)
                    else
                        M28Orders.IssueTrackedMove(oUnit, tSupportWZData[M28Map.subrefMidpoint], iOrderReissueDistToUse, false, 'NSFMovWZ' .. iWZToSupport .. ';' .. iWaterZone)
                    end
                end
            end
        end
    end

    --Units with both surface attack and antinavy attack
    if M28Utilities.IsTableEmpty(tUnitsWithAntiNavyAndSurface) == false then
        if not(iWZToSupport) then
            local tAmphibiousCombat = EntityCategoryFilterDown(M28UnitInfo.refCategoryAmphibiousCombat, tUnitsWithAntiNavyAndSurface)
            local tOtherNavy = EntityCategoryFilterDown(categories.ALLUNITS - M28UnitInfo.refCategoryAmphibiousCombat, tUnitsWithAntiNavyAndSurface)
            if not(tUnassignedLandUnits) then tUnassignedLandUnits = tAmphibiousCombat
            else
                if M28Utilities.IsTableEmpty(tAmphibiousCombat) == false then
                    for iUnit, oUnit in tAmphibiousCombat do
                        table.insert(tUnassignedLandUnits, oUnit)
                    end
                end
            end
            if not(tPotentialBombardmentUnits) then tPotentialBombardmentUnits = tOtherNavy
            else
                if M28Utilities.IsTableEmpty(tOtherNavy) == false then
                    for iUnit, oUnit in tOtherNavy do
                        table.insert(tPotentialBombardmentUnits, oUnit)
                    end
                end
            end
        else
            local tSupportWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWZToSupport]
            for iUnit, oUnit in tUnitsWithAntiNavyAndSurface do
                if not(oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iWaterZone) then
                    --Unit is from a different zone - need to change the value of its assignment so it is considered for orders by the zone that it is part of
                    oUnit[refiCurrentWZAssignmentValue] = 0
                else
                    if EntityCategoryContains(categories.HOVER, oUnit.UnitId) then iOrderReissueDistToUse = iResisueOrderDistanceHover
                    else iOrderReissueDistToUse = iReissueOrderDistanceStandard
                    end
                    M28Orders.IssueTrackedMove(oUnit, tSupportWZData[M28Map.subrefMidpoint], iOrderReissueDistToUse, false, 'NSFBMovWZ' .. iWZToSupport .. ';' .. iWaterZone)
                end
            end
        end
    end
    local bOnlyBombardmentIsMissileShip = false
    if M28Utilities.IsTableEmpty(tMissileShips) == false then
        if not(tPotentialBombardmentUnits) then
            tPotentialBombardmentUnits = tMissileShips
            bOnlyBombardmentIsMissileShip = true
        else
            for iUnit, oUnit in tMissileShips do
                table.insert(tPotentialBombardmentUnits, oUnit)
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Is table of bombardment units empty='..tostring(M28Utilities.IsTableEmpty(tPotentialBombardmentUnits))) end
    if M28Utilities.IsTableEmpty(tPotentialBombardmentUnits) == false then
        --consider doing via a separate function based on a set of units both to keep code tidy and incase we end up wanting to give certain untis bombardment orders from the main logic above
        --AssignBombardmentActions(tWZData, iPond, iWaterZone, iTeam, tPotentialBombardmentUnits, tbOptionalPlateauAndLandZonesToConsider, iOptionalRaidBaseWZ, bOptionalDontTreatAsBombardment)
        AssignBombardmentActions(tWZData, iPond, iWaterZone, iTeam, tPotentialBombardmentUnits,     nil,                                    nil,                bOnlyBombardmentIsMissileShip)
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tUnassignedLandUnits
end

function AssignBombardmentActions(tWZData, iPond, iWaterZone, iTeam, tPotentialBombardmentUnits, tbOptionalPlateauAndLandZonesToConsider, iOptionalRaidBaseWZ, bOptionalDontTreatAsBombardment)
    --tbOptionalPlateauAndLandZonesToConsider - if not empty, then will only consider targets in the same plateau and land zone as this (table which returns true for tbOptionalPlateauAndLandZonesToConsider[iPlateau][iLandZone])
    --iOptionalRaidBaseWZ - need to set if calling from raid logic so can refresh raid locations if no target
    --bOptionalDontTreatAsBombardment - further manual flag (if set to true) to not treat this as bombardment mode - e.g. for units like missile ships that only have a bombardment mode

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignBombardmentActions'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if M28Utilities.IsTableEmpty(tPotentialBombardmentUnits) == false and not(tbOptionalPlateauAndLandZonesToConsider) and not(iOptionalRaidBaseWZ) and not(bOptionalDontTreatAsBombardment) then
        M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBombardmentModeByPond] = GetGameTimeSeconds()
    end

    local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
    local iOurBestDFRange = tWZTeamData[M28Map.subrefWZBestAlliedDFRange]
    local iOurBestIndirectRange = 0
    --Get nearest friendly DF/IF unit near enemy base, and record max indirect range
    local iCurUnitDist
    local oClosestFriendlyUnitToEnemyBase
    local iClosestUnitDist = 100000
    local tClosestEnemyBase = tWZTeamData[M28Map.reftClosestEnemyBase]
    local tOurBase = {tWZTeamData[M28Map.reftClosestFriendlyBase][1], tWZTeamData[M28Map.reftClosestFriendlyBase][2], tWZTeamData[M28Map.reftClosestFriendlyBase][3]}
    local bConsiderGroundAttack = false

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; iPond='..iPond..'; iTeam='..iTeam..'; iOptionalRaidBaseWZ='..(iOptionalRaidBaseWZ or 'nil')) end
    for iUnit, oUnit in tPotentialBombardmentUnits do
        if not(oClosestFriendlyUnitToEnemyBase) then oClosestFriendlyUnitToEnemyBase = oUnit end --redundancy to make sure we always have a closest unit
        iOurBestIndirectRange = math.max(iOurBestIndirectRange, (oUnit[M28UnitInfo.refiIndirectRange] or 0))
        if (oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0 or (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then
            iCurUnitDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tClosestEnemyBase)
            if iCurUnitDist < iClosestUnitDist then
                iClosestUnitDist = iCurUnitDist
                oClosestFriendlyUnitToEnemyBase = oUnit
            end
        end
    end
    local tNonBombardmentRallyPoint = M28Utilities.MoveInDirection(oClosestFriendlyUnitToEnemyBase:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestFriendlyUnitToEnemyBase:GetPosition(), tWZTeamData[M28Map.reftClosestFriendlyBase]), 20, true, false, true)
    --Update the range to search for enemy units
    local iBombardmentSearchRange = math.max(22, (tWZTeamData[M28Map.refiLastBombardmentSearchRange] or 1))
    if iOurBestDFRange >= 60 then iBombardmentSearchRange = math.max(50, iBombardmentSearchRange) end
    if not(tWZTeamData[M28Map.refbLastBombardmentSearchRangeSuccess]) then
        iBombardmentSearchRange = iBombardmentSearchRange + 2
    end
    tWZTeamData[M28Map.refiLastBombardmentSearchRange] = iBombardmentSearchRange

    local iBombardmentBuildingCategory = M28UnitInfo.refCategoryStructure
    local bIgnoreLowThreats = false
    if tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= 6500 or iOurBestIndirectRange >= 175 then
        iBombardmentBuildingCategory = iBombardmentBuildingCategory - categories.TECH1 + M28UnitInfo.refCategoryTorpedoLauncher
    end

    local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
    if aiBrain then

        local iCurDist
        local iClosestMexDist = 100000
        local tBasePoint = tWZData[M28Map.subrefMidpoint]
        local iMaxSearchRange, iClosestMexRef
        local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
        local bTargetInDesiredZone = true

        --Cycle through mexes in this pond looking for mexes to bombard
        if bDebugMessages == true then LOG(sFunctionRef..': Searching for mexes in this pond to bombard, iPond='..iPond..'; iOurBestDFRange='..(iOurBestDFRange or 'nil')..'; iBombardmentSearchRange='..iBombardmentSearchRange..'; iOurBestIndirectRange='..(iOurBestIndirectRange or 'nil')) end
        if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo]) == false then
            for iMex, tMexInfo in M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo] do
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Considering mex at position '..repru(tMexInfo[M28Map.subrefMexLocation])..'; Mex DF distance='..tMexInfo[M28Map.subrefMexDFDistance]..'; Mex indirect distance='..tMexInfo[M28Map.subrefMexIndirectDistance]..'; Is underwater='..tostring(M28Map.IsUnderwater(tMexInfo[M28Map.subrefMexLocation]))..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tMexInfo[M28Map.subrefMexLocation]))..'; M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFUnblockedLocation]='..repru(M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFUnblockedLocation]))
                    if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFUnblockedLocation]) == false then
                        local iMexPlateauOrZero, iMexLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFUnblockedLocation])
                        LOG(sFunctionRef..': DF Unblocked location plateau and water zone ref: iMexPlateauOrZero='..(iMexPlateauOrZero or 'nil')..'; iMexLandOrWaterZone='..(iMexLandOrWaterZone or 'nil'))
                        if iMexPlateauOrZero == 0 and iMexLandOrWaterZone > 0 then
                            local iMexSegmentX, iMexSegmentZ = M28Map.GetPathingSegmentFromPosition(M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFUnblockedLocation])
                            LOG(sFunctionRef..': POnd ref for this blocked location='..(M28Map.tWaterZoneBySegment[iMexSegmentX][iMexSegmentZ] or 'nil'))
                        end
                    end
                end
                if tMexInfo[M28Map.subrefMexDFDistance] <= iOurBestDFRange or tMexInfo[M28Map.subrefMexIndirectDistance] <= iOurBestIndirectRange then
                    if not(M28Map.IsUnderwater(tMexInfo[M28Map.subrefMexLocation])) and (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tMexInfo[M28Map.subrefMexLocation])) then
                        if tbOptionalPlateauAndLandZonesToConsider then
                            local iMexPlateauOrZero, iMexLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tMexInfo[M28Map.subrefMexLocation])
                            bTargetInDesiredZone = (tbOptionalPlateauAndLandZonesToConsider[iMexPlateauOrZero][iMexLandOrWaterZone] or false)
                        end
                        if bTargetInDesiredZone then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(tMexInfo[M28Map.subrefMexLocation], tBasePoint)
                            if bDebugMessages == true then LOG(sFunctionRef .. ': iCurDist to our closest navla unit=' .. iCurDist .. '; iClosestMexDist=' .. iClosestMexDist) end
                            if iCurDist < iClosestMexDist then
                                --Does the enemy have any buildings near here?
                                iMaxSearchRange = 200
                                if tMexInfo[M28Map.subrefMexIndirectDistance] <= iOurBestIndirectRange then
                                    iMaxSearchRange = iOurBestIndirectRange - tMexInfo[M28Map.subrefMexIndirectDistance]
                                end
                                if tMexInfo[M28Map.subrefMexDFDistance] <= iOurBestDFRange and iOurBestDFRange >= iOurBestIndirectRange then
                                    iMaxSearchRange = iOurBestDFRange - tMexInfo[M28Map.subrefMexDFDistance]
                                end
                                iMaxSearchRange = math.max(2, iMaxSearchRange)
                                local tEnemyBuildings = aiBrain:GetUnitsAroundPoint(iBombardmentBuildingCategory, tMexInfo[M28Map.subrefMexLocation], math.min(iBombardmentSearchRange, iMaxSearchRange), 'Enemy')
                                if bDebugMessages == true then LOG(sFunctionRef .. ': Is table of enemy buildings around mex empty=' .. tostring(M28Utilities.IsTableEmpty(tEnemyBuildings))..'; iBombardmentSearchRange='..iBombardmentSearchRange..'; iMaxSearchRange='..iMaxSearchRange) end
                                if M28Utilities.IsTableEmpty(tEnemyBuildings) == false then
                                    iClosestMexDist = iCurDist
                                    iClosestMexRef = iMex
                                end
                            end
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for mexes to bombard, iClosestMexRef='..(iClosestMexRef or 'nil')) end
        if not (iClosestMexRef) and math.max(iOurBestDFRange, iOurBestIndirectRange) >= 60 then
            tWZTeamData[M28Map.refbLastBombardmentSearchRangeSuccess] = false
        else
            --Treat as success even if didnt find anything if have poor range
            tWZTeamData[M28Map.refbLastBombardmentSearchRangeSuccess] = true
        end

        --Get details of locations where shots shouldnt be blocked (if targeting mexes)
        local tClosestMex, iDFMinRange, iIndirectMinRange, tBlockedShotBaseMoveLocation
        if iClosestMexRef then
            tClosestMex = M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexLocation]
            --Attack-move to nearest mex; for units that wont be in range to attack the mex position, attack-move towards our base by 10 below the bombardment range
            iDFMinRange = M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFDistance]
            if iDFMinRange == 0 then
                iDFMinRange = 150
            end
            iIndirectMinRange = M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexIndirectDistance]
            if iIndirectMinRange == 0 then
                iIndirectMinRange = 150
            end
            tBlockedShotBaseMoveLocation = (M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFUnblockedLocation] or tClosestMex)

        else
            --tNonBombardmentRallyPoint = {tEnemyBase[1], tEnemyBase[2], tEnemyBase[3]}
            iDFMinRange = iOurBestDFRange
            iIndirectMinRange = math.min(120, iOurBestIndirectRange)
            if bDebugMessages == true then LOG(sFunctionRef..': No mexes to consider so will just have the enemy base as the main bombardment target') end
        end


        --Get the target
        local tBombardmentMainTarget
        if iClosestMexRef then tBombardmentMainTarget = {tClosestMex[1], tClosestMex[2], tClosestMex[3]}
        else
            tBombardmentMainTarget = {tWZTeamData[M28Map.reftClosestEnemyBase][1], tWZTeamData[M28Map.reftClosestEnemyBase][2], tWZTeamData[M28Map.reftClosestEnemyBase][3]}
        end
        --Adjust target if this is a campaign to just get the closest enemy unit that is in the playable area
        if bDebugMessages == true then LOG(sFunctionRef..': Is campaign map='..tostring(M28Map.bIsCampaignMap)..'; Cur bombardment location='..repru(tBombardmentMainTarget)..'; iClosestMexRef='..(iClosestMexRef or 'nil')..'; Is target in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tBombardmentMainTarget))) end
        local oClosestEnemyUnit
        if (tbOptionalPlateauAndLandZonesToConsider and not(iClosestMexRef)) or (M28Map.bIsCampaignMap and (not(iClosestMexRef) or not(M28Conditions.IsLocationInPlayableArea(tBombardmentMainTarget)))) then
            --First consider targeting something other than the nearest enemy base in campaign - e.g. cycle through all water zones and see if there are enemy structures that we can target
            --if not(iClosestMexRef) then
            function ConsiderAdjacentLandZonesForBombardment(tCurWZData)
                if bDebugMessages == true then LOG(sFunctionRef..': Is cur wz in playable area='..tostring(tCurWZData[M28Map.subrefMidpoint])) end
                if M28Conditions.IsLocationInPlayableArea(tCurWZData[M28Map.subrefMidpoint]) then
                    local iAdjLZ, iAdjPlateau, iCurDist
                    local iClosestDist = 100000
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of adjacent land zones empty='..tostring(M28Utilities.IsTableEmpty(tCurWZData[M28Map.subrefAdjacentLandZones]))) end
                    if M28Utilities.IsTableEmpty(tCurWZData[M28Map.subrefAdjacentLandZones]) == false then
                        for iEntry, tLZSubtable in tCurWZData[M28Map.subrefAdjacentLandZones] do
                            iAdjPlateau = tLZSubtable[M28Map.subrefWPlatAndLZNumber][1]
                            iAdjLZ = tLZSubtable[M28Map.subrefWPlatAndLZNumber][2]
                            if not(tbOptionalPlateauAndLandZonesToConsider) or tbOptionalPlateauAndLandZonesToConsider[iAdjPlateau][iAdjLZ] then
                                local tAdjLZData = M28Map.tAllPlateaus[iAdjPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjPlateau='..iAdjPlateau..'; iAdjLZ='..iAdjLZ..'; Is midpoint of this LZ in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]))) end
                                if M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]) then
                                    local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                                    if bDebugMessages == true then LOG(sFunctionRef..': Dangerous enemies in this LZ='..tostring(tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])..'; Enemy structure total mass='..tAdjLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]))) end
                                    if tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] or tAdjLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] >= 30 then
                                        --Get the closest enemy to here
                                        for iUnit, oUnit in tAdjLZTeamData[M28Map.subrefTEnemyUnits] do
                                            if M28UnitInfo.IsUnitValid(oUnit) then
                                                iCurDist = M28Utilities.GetDistanceBetweenPositions(tCurWZData[M28Map.subrefMidpoint], oUnit:GetPosition())
                                                if iCurDist < iClosestDist and M28Conditions.IsLocationInPlayableArea(oUnit:GetPosition()) then
                                                    iClosestDist = iCurDist
                                                    oClosestEnemyUnit = oUnit

                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            --First check adjacent land zones
            ConsiderAdjacentLandZonesForBombardment(tWZData)
            if not(oClosestEnemyUnit) then
                if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                    local iAdjWZ
                    for iWZEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                        iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                        local tAdjWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
                        if bDebugMessages == true then LOG(sFunctionRef..': About to consider if enmy land zones adjacent to iAdjWZ='..iAdjWZ..' have enemy units in them') end
                        ConsiderAdjacentLandZonesForBombardment(tAdjWZData)
                        if oClosestEnemyUnit then break end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking adjacent land zones for untis for bombardment. is oClosestEnemyUnit valid='..tostring(M28UnitInfo.IsUnitValid(oClosestEnemyUnit))..'; iOptionalRaidBaseWZ='..(iOptionalRaidBaseWZ or 'nil')) end
            if tbOptionalPlateauAndLandZonesToConsider and iOptionalRaidBaseWZ then
                local tRaidWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iOptionalRaidBaseWZ]][M28Map.subrefPondWaterZones][iOptionalRaidBaseWZ]
                local tRaidWZTeamData = tRaidWZData[M28Map.subrefWZTeamData][iTeam]
                if M28UnitInfo.IsUnitValid(tRaidWZTeamData[M28Map.refoLastRaidTarget]) then
                    if not(oClosestEnemyUnit) then
                        oClosestEnemyUnit = tRaidWZTeamData[M28Map.refoLastRaidTarget]
                        if bDebugMessages == true then LOG(sFunctionRef..': Setting closest enemy unit as the raid target') end
                    elseif tRaidWZTeamData[M28Map.refiMinRangeRaidingZone] and not(oClosestEnemyUnit == tRaidWZTeamData[M28Map.refoLastRaidTarget]) then
                        --Is the range to hit the raid target better than the closest enemy unit?
                        local iCurRangeRequired, iWZForShot = GetMinDFDistanceForShotFromWaterToHitUnit(aiBrain, tWZData[M28Map.subrefMidpoint], M28Map.tiPondByWaterZone[iOptionalRaidBaseWZ], oClosestEnemyUnit, tRaidWZTeamData[M28Map.refiMinRangeRaidingZone])
                        if bDebugMessages == true then LOG(sFunctionRef..': Are raiding, but closest enemy unit is different to the last raid target, oClosestEnemyUnit='..oClosestEnemyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyUnit)..'; tRaidWZTeamData[M28Map.refoLastRaidTarget]='..tRaidWZTeamData[M28Map.refoLastRaidTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(tRaidWZTeamData[M28Map.refoLastRaidTarget])..'; iCurRangeRequired for lcosest enemy='..iCurRangeRequired..'; tRaidWZTeamData[M28Map.refiMinRangeRaidingZone]='..tRaidWZTeamData[M28Map.refiMinRangeRaidingZone]) end
                        if iCurRangeRequired > tRaidWZTeamData[M28Map.refiMinRangeRaidingZone] then
                            oClosestEnemyUnit = tRaidWZTeamData[M28Map.refoLastRaidTarget]
                            if bDebugMessages == true then LOG(sFunctionRef..': Changing closest enemy unit to be the raid target') end
                        end
                    end
                end
            end
            if oClosestEnemyUnit then
                tBombardmentMainTarget = oClosestEnemyUnit:GetPosition()
                bConsiderGroundAttack = true
                --Adjust main target if units have had shots blocked against it before for which we have a blocked move location
                if bDebugMessages == true then LOG(sFunctionRef..': Will target closest enemy unit '..oClosestEnemyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyUnit)..'; Position of this='..repru(oClosestEnemyUnit:GetPosition())..'; oClosestEnemyUnit[reftBlockedShotLocationByPond]='..repru(oClosestEnemyUnit[reftBlockedShotLocationByPond])..'; iPond='..iPond) end
                if M28Utilities.IsTableEmpty(oClosestEnemyUnit[reftBlockedShotLocationByPond][iPond]) == false then
                    tBlockedShotBaseMoveLocation = {oClosestEnemyUnit[reftBlockedShotLocationByPond][iPond][1], oClosestEnemyUnit[reftBlockedShotLocationByPond][iPond][2], oClosestEnemyUnit[reftBlockedShotLocationByPond][iPond][3]}
                end
            elseif tbOptionalPlateauAndLandZonesToConsider then
                --Raiders - no targets so clear flag
                if not(iOptionalRaidBaseWZ) then M28Utilities.ErrorHandler('Failed to specify base WZ for raid logic')
                else
                    RefreshRaidingNavalLocations(iOptionalRaidBaseWZ, iTeam)
                end
            else

                --Dont have a valid closest enemy unit and are outside playable area
                --Adjust to the nearest location on map to the bombardment target

                --end
                local iInterval = 30
                local iDistFromBase = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], tBombardmentMainTarget)
                local iMaxDist = math.floor(iDistFromBase / iInterval) * iInterval
                local iAngleFromTargetToMidpoint = M28Utilities.GetAngleFromAToB(tWZData[M28Map.subrefMidpoint], tBombardmentMainTarget)
                if bDebugMessages == true then LOG(sFunctionRef..': Bombardment target is outside playable area so will try and adjust, playable area='..repru(M28Map.rMapPlayableArea)..'; Sync.NewPlayableArea='..repru(Sync.NewPlayableArea)) end
                for iCurDist = iInterval, iMaxDist, iInterval do
                    local tRevisedTarget = M28Utilities.MoveInDirection(tBombardmentMainTarget, iAngleFromTargetToMidpoint, iCurDist, true, false, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': iCurDist='..iCurDist..'; tRevisedTarget='..repru(tRevisedTarget)..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tRevisedTarget))) end
                    if tRevisedTarget and M28Conditions.IsLocationInPlayableArea(tRevisedTarget) then
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Adjusting bombardment target, iCurDist='..iCurDist..'; tRevisedTarget='..repru(tRevisedTarget)..'; tBombardmentMainTarget before adjust='..repru(tBombardmentMainTarget)..'; Map playable area='..repru(M28Map.rMapPlayableArea))
                            M28Utilities.DrawLocation(tRevisedTarget)
                        end
                        tBombardmentMainTarget = {tRevisedTarget[1], tRevisedTarget[2], tRevisedTarget[3]}
                        break
                    end
                end
            end
        end



        --Get nearby enemy defences
        local iSearchRange = math.max(iIndirectMinRange + 50, iDFMinRange + 50, 150)
        local tEnemyStructuresNearFrontUnit = aiBrain:GetUnitsAroundPoint(iBombardmentBuildingCategory, oClosestFriendlyUnitToEnemyBase:GetPosition(), iSearchRange, 'Enemy')
        local tEnemyDefences = {}
        if M28Utilities.IsTableEmpty(tEnemyStructuresNearFrontUnit) == false then
            tEnemyDefences = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD + M28UnitInfo.refCategoryFixedT2Arti, tEnemyStructuresNearFrontUnit)
        end
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
            --Probably easier to just cycle through enemy experimentals rather than adjacent land zones
            for iExperimental, oExperimental in M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
                if bDebugMessages == true then if M28UnitInfo.IsUnitValid(oExperimental) then LOG(sFunctionRef..': Dist from oExperimental to oClosestFriendlyUnitToEnemyBase='..M28Utilities.GetDistanceBetweenPositions(oExperimental:GetPosition(), oClosestFriendlyUnitToEnemyBase:GetPosition())..'; iSearchRange='..iSearchRange..'; Fraction complete='..oExperimental:GetFractionComplete()) end end
                if M28UnitInfo.IsUnitValid(oExperimental) and oExperimental:GetFractionComplete() >= 0.95 and M28Utilities.GetDistanceBetweenPositions(oExperimental:GetPosition(), oClosestFriendlyUnitToEnemyBase:GetPosition()) <= iSearchRange + 5 then
                    table.insert(tEnemyDefences, oExperimental)
                end
            end
        end

        local bCheckForBuildingsToAttack = true
        local bCheckForDefences = false
        local bRetreatUnit
        if M28Utilities.IsTableEmpty(tEnemyStructuresNearFrontUnit) then
            if bDebugMessages == true then LOG(sFunctionRef .. ': No enemy structures within a range of ' .. (math.max(iIndirectMinRange, iDFMinRange) + 50) .. ' of the unit closest to the enemy base. iIndirectMinRange=' .. iIndirectMinRange .. '; iDFMinRange=' .. iDFMinRange) end
            bCheckForBuildingsToAttack = false
        end
        --Add under construction experimentals to the buildings to attack
        local tEnemyExperimentals = aiBrain:GetUnitsAroundPoint(categories.EXPERIMENTAL - categories.STRUCTURE - M28UnitInfo.refCategorySatellite, oClosestFriendlyUnitToEnemyBase:GetPosition(), math.max(iIndirectMinRange + 50, iDFMinRange + 50, 150), 'Enemy')
        if M28Utilities.IsTableEmpty(tEnemyExperimentals) == false then
            for iEnemy, oEnemy in tEnemyExperimentals do
                if oEnemy:GetFractionComplete() < 0.98 then
                    table.insert(tEnemyStructuresNearFrontUnit, oEnemy)
                end
            end
        end

        bCheckForDefences = not (M28Utilities.IsTableEmpty(tEnemyDefences))
        local bCheckForSurfaceUnits = false
        local iSurfaceUnitRangeCap = 100 --Will only look this far and reduce ground unit range to this to stop us staying too far away
        local tPotentialNearbyOtherSurfaceThreats = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryIndirectT2Plus - categories.TECH1, oClosestFriendlyUnitToEnemyBase:GetPosition(), math.min(iSurfaceUnitRangeCap, math.max(math.min(50, iIndirectMinRange), iDFMinRange) + 15), 'Enemy')
        local tNearbyOtherSurfaceThreats = {}
        if bDebugMessages == true then LOG(sFunctionRef..': Is tPotentialNearbyOtherSurfaceThreats empty='..tostring(M28Utilities.IsTableEmpty(tPotentialNearbyOtherSurfaceThreats))) end
        if M28Utilities.IsTableEmpty(tPotentialNearbyOtherSurfaceThreats) == false then
            for iUnit, oUnit in tPotentialNearbyOtherSurfaceThreats do
                if not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                    table.insert(tNearbyOtherSurfaceThreats, oUnit)
                end
            end
            if M28Utilities.IsTableEmpty(tNearbyOtherSurfaceThreats) == false then
                bCheckForSurfaceUnits = true
            end
        end

        local oBuildingToAttack
        local iDefencesHeadroom
        local bBlockedSoMove = false --If unit shot is blocked and it should be able to hit the mex then have it move to where we thought the shot would be able to hit from
        local iBlockedAngleFromMexOrTarget
        local iBlockedDistanceFromMexOrTarget
        if tBlockedShotBaseMoveLocation then
            if bDebugMessages == true then LOG(sFunctionRef..': tBombardmentMainTarget='..repru(tBombardmentMainTarget)..'; tBlockedShotBaseMoveLocation='..repru(tBlockedShotBaseMoveLocation)..'; tClosestEnemyBase='..repru(tClosestEnemyBase)..'; tOurBase='..repru(tOurBase)) end
            iBlockedAngleFromMexOrTarget = M28Utilities.GetAngleFromAToB(tBombardmentMainTarget, tBlockedShotBaseMoveLocation)
            if bDebugMessages == true then LOG(sFunctionRef..': iBlockedAngleFromMexOrTarget='..iBlockedAngleFromMexOrTarget..'; tBombardmentMainTarget='..repru(tBombardmentMainTarget)..'; tBlockedShotBaseMoveLocation='..repru(tBlockedShotBaseMoveLocation)) end
            iBlockedDistanceFromMexOrTarget = M28Utilities.GetDistanceBetweenPositions(tBombardmentMainTarget, tBlockedShotBaseMoveLocation)
        end
        local bEnemyUnitsNearlyInRange
        local tPotentialEnemyUnits
        local bDontCheckIfTargetUnderwater
        local bHaveUnblockedBombardingBattleship

        if bDebugMessages == true then LOG(sFunctionRef .. ': About to search for bombardment targets, bCheckForBuildingsToAttack=' .. tostring(bCheckForBuildingsToAttack) .. '; tBombardmentMainTarget=' .. repru(tBombardmentMainTarget) .. '; tNonBombardmentRallyPoint=' .. repru(tNonBombardmentRallyPoint) .. '; iDFMinRange=' .. iDFMinRange .. '; iIndirectMinRange=' .. iIndirectMinRange..'; iBlockedAngleFromMexOrTarget='..(iBlockedAngleFromMexOrTarget or 'nil')..'; iBlockedDistanceFromMexOrTarget='..(iBlockedDistanceFromMexOrTarget or 'nil')..'; tBlockedShotBaseMoveLocation='..repru(tBlockedShotBaseMoveLocation)) end
        local tDefencesExclT2Arti
        if bCheckForDefences then
            tDefencesExclT2Arti = EntityCategoryFilterDown(categories.ALLUNITS - M28UnitInfo.refCategoryFixedT2Arti, tEnemyDefences)
        end
        local iCurEnemyRange
        local iCurEnemyDist
        function ConsiderRetreatingFromDefendingUnit(oUnit, oDefence)
            iCurEnemyRange = math.max((oDefence[M28UnitInfo.refiDFRange] or 0), (oDefence[M28UnitInfo.refiIndirectRange] or 0), (oDefence[M28UnitInfo.refiAntiNavyRange] or 0))
            iCurEnemyDist = M28Utilities.GetDistanceBetweenPositions(oDefence:GetPosition(), oUnit:GetPosition())
            if bDebugMessages == true then LOG(sFunctionRef .. ': Considering if oUnit=' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. ' is in range of oDefence=' .. oDefence.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oDefence) .. '; iCurEnemyRange=' .. (iCurEnemyRange or 'nil') .. '; iCurEnemyDist=' .. iCurEnemyDist .. '; Our DF/Indirect range=' .. math.max((oUnit[M28UnitInfo.refiIndirectRange] or 0), (oUnit[M28UnitInfo.refiDFRange] or 0))) end

            iDefencesHeadroom = math.min(iDefencesHeadroom, iCurEnemyDist - iCurEnemyRange)
            --Are we in range of enemy, or are we almost in range of enemy and outrange them?
            if iCurEnemyDist <= iCurEnemyRange or (iCurEnemyDist - 12 <= iCurEnemyRange and math.max((oUnit[M28UnitInfo.refiIndirectRange] or 0), (oUnit[M28UnitInfo.refiDFRange] or 0)) > (iCurEnemyRange or 0) and iCurEnemyDist < math.max((oUnit[M28UnitInfo.refiIndirectRange] or 0), (oUnit[M28UnitInfo.refiDFRange] or 0))) then
                --Move away unless are a battleship and the enemy is more than 100 away (unless is a T2 arti, since we likely outrange T2 arti)
                if not (iCurEnemyDist > 100 and EntityCategoryContains(M28UnitInfo.refCategoryMobileNavalSurface * categories.TECH3 * categories.BATTLESHIP, oUnit.UnitId) and ((math.max((oUnit[M28UnitInfo.refiIndirectRange] or 0), (oUnit[M28UnitInfo.refiDFRange] or 0)) <= iCurEnemyRange) or iCurEnemyDist > 120)) then
                    if bDebugMessages == true then LOG(sFunctionRef .. ': Want to retreat') end
                    bRetreatUnit = true
                end
            end
        end

        --Set the min range for units such as destroyers on high health to be treated as main bombardment units
        local iDFLowerMinRange =  iOurBestDFRange
        if iOurBestDFRange > 60 and (bCheckForBuildingsToAttack or bCheckForDefences or (oClosestEnemyUnit and NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, M28Utilities.MoveInDirection(oClosestEnemyUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestEnemyUnit:GetPosition(), tWZData[M28Map.subrefMidpoint]), 60, true)) == iPond)) then
            iDFLowerMinRange = 60
        end

        for iUnit, oUnit in tPotentialBombardmentUnits do
            bDontCheckIfTargetUnderwater = (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > 0
            if bDebugMessages == true then LOG(sFunctionRef .. ': Considering unit ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. '; is underwater=' .. tostring(M28UnitInfo.IsUnitUnderwater(oUnit)) .. '; oUnit[M28UnitInfo.refiDFRange]=' .. (oUnit[M28UnitInfo.refiDFRange] or 'nil') .. '; oUnit[M28UnitInfo.refiIndirectRange]=' .. (oUnit[M28UnitInfo.refiIndirectRange] or 'nil')..'; Unit position='..repru(oUnit:GetPosition())) end

            if not (M28UnitInfo.IsUnitUnderwater(oUnit)) then
                bRetreatUnit = false
                --Are we in range of enemy PD/T2 arti; or experimental that we outrange? If so then retreat
                if bCheckForDefences then

                    iDefencesHeadroom = 1000
                    if oUnit:GetHealth() >= 2100 and M28UnitInfo.GetUnitHealthPercent(oUnit) >= 0.35 then
                        if M28Utilities.IsTableEmpty(tDefencesExclT2Arti) == false then
                            for iDefence, oDefence in tDefencesExclT2Arti do
                                ConsiderRetreatingFromDefendingUnit(oUnit, oDefence)
                                if bRetreatUnit then break end
                            end
                        end
                    else
                        for iDefence, oDefence in tEnemyDefences do
                            ConsiderRetreatingFromDefendingUnit(oUnit, oDefence)
                            if bRetreatUnit then break end
                        end
                    end
                end
                if not(bRetreatUnit) and bCheckForSurfaceUnits then
                    local iCurEnemyRange
                    local iCurEnemyDist
                    iDefencesHeadroom = 1000
                    for iDefence, oDefence in tNearbyOtherSurfaceThreats do
                        iCurEnemyRange = math.min(iSurfaceUnitRangeCap, math.max((oDefence[M28UnitInfo.refiDFRange] or 0), (oDefence[M28UnitInfo.refiIndirectRange] or 0), (oDefence[M28UnitInfo.refiAntiNavyRange] or 0)))
                        iCurEnemyDist = M28Utilities.GetDistanceBetweenPositions(oDefence:GetPosition(), oUnit:GetPosition())
                        if bDebugMessages == true then LOG(sFunctionRef .. ': Considering if oUnit=' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. ' is in range of oDefence=' .. oDefence.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oDefence) .. '; iCurEnemyRange=' .. iCurEnemyRange .. '; iCurEnemyDist=' .. iCurEnemyDist .. '; Our DF/Indirect range=' .. math.max((oUnit[M28UnitInfo.refiIndirectRange] or 0), (oUnit[M28UnitInfo.refiDFRange] or 0))) end

                        iDefencesHeadroom = math.min(iDefencesHeadroom, iCurEnemyDist - iCurEnemyRange)
                        if iCurEnemyDist <= iCurEnemyRange + 10 and math.max((oUnit[M28UnitInfo.refiIndirectRange] or 0), (oUnit[M28UnitInfo.refiDFRange] or 0)) < (iCurEnemyRange or 0) then
                            --Move away unless are a battleship and the enemy is more than 100 away
                            bRetreatUnit = true
                            break
                        end
                    end
                end

                local bChangedBlockedLocation = false
                local tBlockedShotActualMoveLocation

                if bRetreatUnit then
                    if bDebugMessages == true then LOG(sFunctionRef .. ': WIll retreat ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. ' towards our base as we are too close to enemy PD') end

                    M28Orders.IssueTrackedMove(oUnit, tOurBase, 20, false, 'NBRetr')
                else
                    if (oUnit[M28UnitInfo.refiDFRange] or 0) >= iDFMinRange or (oUnit[M28UnitInfo.refiIndirectRange] or 0) >= iIndirectMinRange or ((oUnit[M28UnitInfo.refiDFRange] or 0) >= iDFLowerMinRange and M28UnitInfo.GetUnitHealthPercent(oUnit) >= 0.5) then
                        --Attack-move to target, unless we already have a structure in range or our shot is blocked
                        if bDebugMessages == true then LOG(sFunctionRef .. ': Checking if shot blocked for unit ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. '. tBlockedShotBaseMoveLocation=' .. repru(tBlockedShotBaseMoveLocation) .. '; oUnit[M28UnitInfo.refiDFRange]=' .. (oUnit[M28UnitInfo.refiDFRange] or 'nil') .. '; oUnit[M28UnitInfo.refiIndirectRange]=' .. (oUnit[M28UnitInfo.refiIndirectRange] or 'nil') .. '; oUnit[M28UnitInfo.refbLastShotBlocked]=' .. tostring(oUnit[M28UnitInfo.refbLastShotBlocked] or false)..'; Time of last unblocked shot='..(GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100))..'; Time since last refiLastWeaponEvent='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or -100)) end

                        if (oUnit[M28UnitInfo.refiDFRange] or 0) > (oUnit[M28UnitInfo.refiIndirectRange] or 0) and (oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or -100) < 6) and (tBlockedShotBaseMoveLocation or (tBombardmentMainTarget and (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and oClosestEnemyUnit and not(oClosestEnemyUnit[reftBlockedShotLocationByPond]) and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oClosestEnemyUnit.UnitId) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBombardmentMainTarget) - 5 <= (oUnit[M28UnitInfo.refiDFRange] or 0) and M28Utilities.GetRoughDistanceBetweenPositions(tBombardmentMainTarget, oClosestEnemyUnit:GetPosition()) <= 5))  then
                            bBlockedSoMove = true
                            --Get location this unit should move to
                            if M28Utilities.IsTableEmpty(tBlockedShotBaseMoveLocation) and oClosestEnemyUnit then
                                tBlockedShotBaseMoveLocation = GetDFShotBlockedLocationForBuildingAndPond(oClosestEnemyUnit, iPond)
                                if bDebugMessages == true then LOG(sFunctionRef..': Finished getting shot blocked position, tBlockedShotBaseMoveLocation='..repru(tBlockedShotBaseMoveLocation)) end
                            end
                            if M28Utilities.IsTableEmpty(tBlockedShotBaseMoveLocation) == false then
                                tBlockedShotActualMoveLocation = {tBlockedShotBaseMoveLocation[1], tBlockedShotBaseMoveLocation[2], tBlockedShotBaseMoveLocation[3]}
                                --Record that we have been blocked at this range if we are close to the angle wanted and have fired recenlty
                                local tBaseTargetPosition
                                if tClosestMex then tBaseTargetPosition = {tClosestMex[1], tClosestMex[2], tClosestMex[3]}
                                else
                                    tBaseTargetPosition = {tBombardmentMainTarget[1], tBombardmentMainTarget[2], tBombardmentMainTarget[3]}
                                    if not(iBlockedAngleFromMexOrTarget) then iBlockedAngleFromMexOrTarget = M28Utilities.GetAngleFromAToB(tBombardmentMainTarget, tBlockedShotBaseMoveLocation) end
                                    if not(iBlockedDistanceFromMexOrTarget) then iBlockedDistanceFromMexOrTarget = M28Utilities.GetDistanceBetweenPositions(tBombardmentMainTarget, tBlockedShotBaseMoveLocation) end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Shot is blocked for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; checking if we expected to be able to hit from here, and if so will increase the blocked distance. tClosestMex='..repru(tClosestMex)..'; tBaseTargetPosition='..repru(tBaseTargetPosition)..'; Time='..GetGameTimeSeconds()..'; oUnit[M28UnitInfo.refiTimeOfLastCheck]='..(oUnit[M28UnitInfo.refiTimeOfLastCheck] or 'nil'))
                                    if M28Utilities.IsTableEmpty(tBaseTargetPosition) == false then LOG(sFunctionRef..': Angle dif='..M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(tBaseTargetPosition, oUnit:GetPosition()), iBlockedAngleFromMexOrTarget)..'; iBlockedAngleFromMexOrTarget='..iBlockedAngleFromMexOrTarget..'; Angle from unit to tBaseTargetPosition (e.g. mex)='..M28Utilities.GetAngleFromAToB(tBaseTargetPosition, oUnit:GetPosition())) end
                                end
                                if M28Utilities.IsTableEmpty(tClosestMex) == false and tBaseTargetPosition and (oUnit[M28UnitInfo.refiIndirectRange] or 0) == 0 and oUnit[M28UnitInfo.refiDFRange] >= iDFMinRange and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or 0) <= 2 and M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(tBaseTargetPosition, oUnit:GetPosition()), iBlockedAngleFromMexOrTarget) <= 8 then
                                    local iDistToBlocked = M28Utilities.GetDistanceBetweenPositions(tBlockedShotActualMoveLocation, oUnit:GetPosition())
                                    if bDebugMessages == true then LOG(sFunctionRef..': iDistToBlocked='..(iDistToBlocked or 'nil')..'; tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexDFDistance]='..(M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFDistance] or 'nil')..'; iBlockedDistanceFromMexOrTarget (ie distance from the location to move to if shot is blocked, and the mex)='..(iBlockedDistanceFromMexOrTarget or 'nil')) end
                                    if iDistToBlocked <= 5 then
                                        local iCurBlockedDistance = math.max(iBlockedDistanceFromMexOrTarget + 2, (M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFDistance] or 0))
                                        local tPotentialUnblockedLocation = M28Utilities.MoveInDirection(tBaseTargetPosition, iBlockedAngleFromMexOrTarget, iCurBlockedDistance, true, false, true)
                                        local bUpdateMex = not(M28Utilities.IsTableEmpty(tClosestMex))
                                        while not(NavUtils.GetLabel(M28Map.refPathingTypeNavy, tPotentialUnblockedLocation) == iPond) do
                                            if bUpdateMex then
                                                M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFDistance] = iCurBlockedDistance
                                            end
                                            iCurBlockedDistance = iCurBlockedDistance + 2
                                            tPotentialUnblockedLocation = M28Utilities.MoveInDirection(tBaseTargetPosition, iBlockedAngleFromMexOrTarget, iCurBlockedDistance, true, false, true)

                                            if iCurBlockedDistance >= 200 then break end
                                        end

                                        if bUpdateMex then
                                            M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFUnblockedLocation] = {tPotentialUnblockedLocation[1], tPotentialUnblockedLocation[2], tPotentialUnblockedLocation[3]}
                                            if bDebugMessages == true then LOG(sFunctionRef..': Have changed the unblocked location by increasing the distance. New DF distance='..M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFDistance]) end
                                        end
                                        bChangedBlockedLocation = true
                                    end
                                elseif M28Utilities.IsTableEmpty(tClosestMex) then
                                    --Consider moving slightly further back from the shot blocked location if our range allows
                                    local iDistFromBlockedToTarget = M28Utilities.GetDistanceBetweenPositions(tBlockedShotActualMoveLocation, tBaseTargetPosition)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Distance between blocked move location and target='..iDistFromBlockedToTarget..'; Unit DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0)) end
                                    if iDistFromBlockedToTarget + 2 < (oUnit[M28UnitInfo.refiDFRange] or 0) then
                                        local iDistAway = math.min(iDistFromBlockedToTarget + 30, oUnit[M28UnitInfo.refiDFRange] -1)
                                        local tAltBlockedMoveLocation = M28Utilities.MoveInDirection(tBaseTargetPosition, M28Utilities.GetAngleFromAToB(tBaseTargetPosition, tBlockedShotActualMoveLocation), iDistAway, true, false, M28Map.bIsCampaignMap)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we can move further away than the blocked location, iDistAway='..iDistAway..'; iDistFromBlockedToTarget='..iDistFromBlockedToTarget..'; Pond label if move away='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tAltBlockedMoveLocation) or 'nil')..'; iPond='..iPond..'; tBlockedShotActualMoveLocation='..repru(tBlockedShotActualMoveLocation)..'; tAltBlockedMoveLocation='..repru(tAltBlockedMoveLocation)) end
                                        if tAltBlockedMoveLocation and NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tAltBlockedMoveLocation) == iPond then
                                            tBlockedShotActualMoveLocation = tAltBlockedMoveLocation
                                        end
                                    end
                                end

                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': Will move to tBlockedShotActualMoveLocation=' .. repru(tBlockedShotActualMoveLocation)..'; Dist from tBlockedShotActualMoveLocation='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBlockedShotActualMoveLocation)..'; will draw in blue')
                                    M28Utilities.DrawLocation(tBlockedShotActualMoveLocation)
                                end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Cant find blocked move location') end
                            end
                        else
                            --If have a battleship on bombardment duty and its shot isnt blocked and it has fired recently then record this so we know
                            if not(bHaveUnblockedBombardingBattleship) and bCheckForBuildingsToAttack and EntityCategoryContains(M28UnitInfo.refCategoryBattleship, oUnit.UnitId) and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or -100) <= 20 and not(oUnit[M28UnitInfo.refbLastShotBlocked]) then
                                bHaveUnblockedBombardingBattleship = true
                                if not(M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBattleshipBombardmentByPond]) then
                                    M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBattleshipBombardmentByPond] = {}
                                end
                                M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBattleshipBombardmentByPond][iPond] = GetGameTimeSeconds()
                            end

                            oBuildingToAttack = nil
                            local tBuildingToAttackMoveViaPoint
                            if bCheckForBuildingsToAttack then
                                local toBlockedBuildingsAndDistWithinRange = {}
                                local iRangeThreshold = 10
                                local iDistToPriority
                                local iClosestDist = 100000
                                if M28Utilities.IsTableEmpty(tEnemyStructuresNearFrontUnit) == false then
                                    for iPriority, oPriority in tEnemyStructuresNearFrontUnit do
                                        iDistToPriority = M28Utilities.GetDistanceBetweenPositions(oPriority:GetPosition(), oUnit:GetPosition())
                                        if iDistToPriority < iClosestDist then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering oPriority='..oPriority.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPriority)..'; iDistToPriority='..iDistToPriority..'; Is unit underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oPriority))) end
                                            if bDontCheckIfTargetUnderwater or not(M28UnitInfo.IsUnitUnderwater(oPriority)) then
                                                --Is our shot blocked if we try and shoot from either our current position (if in range and shot is blocked), or a similar angle if we arent in range?
                                                if (oUnit[M28UnitInfo.refiDFRange] or 0) > (oUnit[M28UnitInfo.refiIndirectRange] or 0) and ((oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 and iDistToPriority <= oUnit[M28UnitInfo.refiDFRange] and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or 0) <= 4) or M28Logic.IsShotBlocked(oUnit, oPriority)) then
                                                    --Blocked so dont want to try and attack this building
                                                    if bDebugMessages == true then LOG(sFunctionRef..': DF unit who we think will be blocked from firing at oPriority='..oPriority.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPriority)..' so will ignore oPriority') end
                                                    if iDistToPriority < (oUnit[M28UnitInfo.refiDFRange] or 0) - iRangeThreshold then
                                                        table.insert(toBlockedBuildingsAndDistWithinRange, {oPriority, (oUnit[M28UnitInfo.refiDFRange] or 0) - iDistToPriority})
                                                    end
                                                else
                                                    iClosestDist = iDistToPriority
                                                    oBuildingToAttack = oPriority
                                                end
                                            end
                                        end
                                    end
                                end

                                if bDebugMessages == true then
                                    if oBuildingToAttack then
                                        LOG(sFunctionRef .. ': Considering whether to attack oBuildingToAttack=' .. oBuildingToAttack.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oBuildingToAttack) .. '; Distance to it=' .. M28Utilities.GetDistanceBetweenPositions(oBuildingToAttack:GetPosition(), oUnit:GetPosition()) .. '; Our DF range=' .. (oUnit[M28UnitInfo.refiDFRange] or 'nil') .. '; Our Indirect range=' .. (oUnit[M28UnitInfo.refiIndirectRange] or 'nil'))
                                    else
                                        LOG(sFunctionRef..': Dont have a building to attack')
                                    end
                                end
                                if oBuildingToAttack and M28Utilities.GetDistanceBetweenPositions(oBuildingToAttack:GetPosition(), oUnit:GetPosition()) > math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0)) then
                                    --Not in range so dont give specific attack order
                                    oBuildingToAttack = nil
                                else
                                    --Consider overwriting with a priority target (e.g. TMD and shields)
                                    if iDefencesHeadroom >= 10 then
                                        local iPriorityCategory = M28UnitInfo.refCategoryFixedShield
                                        if EntityCategoryContains(M28UnitInfo.refCategoryMissileShip, oUnit.UnitId) then
                                            iPriorityCategory = iPriorityCategory + M28UnitInfo.refCategoryTMD
                                        end
                                        local tPriorityTargets = EntityCategoryFilterDown(iPriorityCategory, tEnemyStructuresNearFrontUnit)
                                        if M28Utilities.IsTableEmpty(tPriorityTargets) == false then

                                            for iPriority, oPriority in tPriorityTargets do
                                                iDistToPriority = M28Utilities.GetDistanceBetweenPositions(oPriority:GetPosition(), oUnit:GetPosition())
                                                if iDistToPriority < iClosestDist then
                                                    if bDontCheckIfTargetUnderwater or not(M28UnitInfo.IsUnitUnderwater(oPriority)) then
                                                        iClosestDist = iDistToPriority
                                                        if iDistToPriority - math.min(iDefencesHeadroom, 30) <= math.max((oUnit[M28UnitInfo.refiIndirectRange] or 0), (oUnit[M28UnitInfo.refiDFRange] or 0)) then
                                                            oBuildingToAttack = oPriority
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Is oBuildingToAttack valid='..tostring(M28UnitInfo.IsUnitValid(oBuildingToAttack))..'; Is table of blocked buildings empty='..tostring(M28Utilities.IsTableEmpty(toBlockedBuildingsAndDistWithinRange))) end
                                if not(oBuildingToAttack) and M28Utilities.IsTableEmpty(toBlockedBuildingsAndDistWithinRange) == false then
                                    --We have buildings that are within our DF range threshold - if we move back by the distance with which we are in range, is our shot still blocked?
                                    local iAngleFromBuilding
                                    local iFurthestInRange = 0
                                    for iEntry, tUnitAndDist in toBlockedBuildingsAndDistWithinRange do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..tUnitAndDist[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tUnitAndDist[1])..'; tUnitAndDist[2]='..tUnitAndDist[2]..'; iFurthestInRange='..iFurthestInRange) end
                                        if tUnitAndDist[2] > iFurthestInRange then
                                            iAngleFromBuilding = M28Utilities.GetAngleFromAToB(tUnitAndDist[1]:GetPosition(), oUnit:GetPosition())
                                            local tMoveViaPoint = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleFromBuilding, tUnitAndDist[2]-1, true, false, not(bDontCheckIfTargetUnderwater))
                                            if bDebugMessages == true then LOG(sFunctionRef..': tMoveViaPoint='..repru(tMoveViaPoint)..'; Cur poisition='..repru(oUnit:GetPosition())..'; Is shot blocked='..tostring(M28Logic.IsShotBlocked(oUnit, tUnitAndDist[1], false, tMoveViaPoint))..'; iPond='..iPond..'; Naval path label for move point='..NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tMoveViaPoint)) end
                                            if M28Utilities.IsTableEmpty( tMoveViaPoint) == false and iPond == NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tMoveViaPoint) and not(M28Logic.IsShotBlocked(oUnit, tUnitAndDist[1], false, tMoveViaPoint)) then
                                                iFurthestInRange = tUnitAndDist[2]
                                                oBuildingToAttack = tUnitAndDist[1]
                                                bBlockedSoMove = true
                                                tBlockedShotActualMoveLocation = {tMoveViaPoint[1], tMoveViaPoint[2], tMoveViaPoint[3]}
                                                if bDebugMessages == true then LOG(sFunctionRef..': Adding as a new building to attack') end
                                            end
                                        end
                                    end
                                end-- iRangeThreshold
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': is oBuildingToAttack valid='..tostring(M28UnitInfo.IsUnitValid(oBuildingToAttack))..'; bBlockedSoMove='..tostring(bBlockedSoMove)..'; tBlockedShotActualMoveLocation='..repru(tBlockedShotActualMoveLocation)..'; bConsiderGroundAttack='..tostring(bConsiderGroundAttack)) end
                        if not (oBuildingToAttack) or (bBlockedSoMove and tBlockedShotActualMoveLocation) then
                            --ToDo - figure out solution to both cliff temporarily blocking (where if we dont attack-move we are ok)
                            --ToDo - and the converse where we are ok but if we move towards the target a cliff ends up blocking us until we move further away
                            local oOptionalBombardLinkedTarget
                            if bBlockedSoMove and tBlockedShotActualMoveLocation then
                                if bDebugMessages == true then LOG(sFunctionRef..': Dist to move location='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBlockedShotActualMoveLocation)) end
                                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBlockedShotActualMoveLocation) <= 1.5 then --tried with <=1 but had issues with frigate on betrayal ocean not firing
                                    --Otherwise will just keep repeating order to move and end up not firing, when there's a chance firing shots might hit something (i.e. might be marginal whether hit cliff or not)
                                    M28Orders.IssueTrackedAggressiveMove(oUnit, tBlockedShotActualMoveLocation, 1.5, false, 'NBlckAM', false)
                                else
                                    M28Orders.IssueTrackedMove(oUnit, tBlockedShotActualMoveLocation, 1.5, false, 'NBlckM', false)
                                end
                            else
                                if bConsiderGroundAttack then
                                    --Change back to false if no units at the target
                                    bConsiderGroundAttack = false
                                    local tRect = M28Utilities.GetRectAroundLocation(tBombardmentMainTarget, 1)
                                    local tUnitsInRect = GetUnitsInRect(tRect)
                                    if bDebugMessages == true and oClosestEnemyUnit then LOG(sFunctionRef..': oClosestEnemyUnit position='..repru(oClosestEnemyUnit:GetPosition())..'; Is tUnitsInRect empty='..tostring(M28Utilities.IsTableEmpty(tUnitsInRect))..'; tBombardmentMainTarget='..repru(tBombardmentMainTarget)) end
                                    if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                                        for iUnit, oUnit in tUnitsInRect do
                                            if not(oUnit:GetAIBrain().M28Team == iTeam) and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) and not(M28UnitInfo.CanSeeUnit(aiBrain, oUnit)) then
                                                oOptionalBombardLinkedTarget = oUnit
                                                bConsiderGroundAttack = true
                                                break
                                            end
                                        end
                                    end
                                end
                                bEnemyUnitsNearlyInRange = false
                                if ((oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6) or (bIgnoreLowThreats and EntityCategoryContains(categories.TECH3 + M28UnitInfo.refCategoryMissileShip, oUnit.UnitId))) and M28Utilities.GetDistanceBetweenPositions(tBombardmentMainTarget, oUnit:GetPosition()) > math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0)) then
                                    --Check if enemy has non-air units near us that could hit us or if we can do an issuemove instead of attackmove to get within range of the desired location
                                    tPotentialEnemyUnits = aiBrain:GetUnitsAroundPoint(categories.DIRECTFIRE + categories.INDIRECTFIRE + categories.ANTINAVY - categories.AIR - M28UnitInfo.refCategoryFixedT3Arti - categories.SILO  - categories.UNSELECTABLE - categories.UNTARGETABLE, oUnit:GetPosition(), 100, 'Enemy')
                                    if M28Utilities.IsTableEmpty(tPotentialEnemyUnits) == false then
                                        for iEnemy, oEnemy in tPotentialEnemyUnits do
                                            if math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0)) + 5 <= M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition()) then
                                                bEnemyUnitsNearlyInRange = true
                                                if bDebugMessages == true then LOG(sFunctionRef..': oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..' is only '..M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())..' from us and ourDF  range is '..(oUnit[M28UnitInfo.refiDFRange] or 0)..' and indirect is '..(oUnit[M28UnitInfo.refiIndirectRange] or 0)..' so will use attack move instead of move') end
                                                break
                                            end
                                        end
                                    end
                                end
                                if bDebugMessages == true then
                                    LOG(sFunctionRef..': Will bombard the target wit hthis unit.  Considering whether to move or attack for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bIgnoreLowThreats='..tostring(bIgnoreLowThreats)..'; oUnit[M28UnitInfo.refbLastShotBlocked]='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked])..'; bEnemyUnitsNearlyInRange='..tostring(bEnemyUnitsNearlyInRange)..'; M28UnitInfo.GetUnitHealthPercent(oUnit)='..M28UnitInfo.GetUnitHealthPercent(oUnit)..'; tBombardmentMainTarget='..repru(tBombardmentMainTarget)..'; tBlockedShotBaseMoveLocation='..repru(tBlockedShotBaseMoveLocation))
                                    if oClosestEnemyUnit then LOG(sFunctionRef..': oClosestEnemyUnit position='..repru(oClosestEnemyUnit:GetPosition())..'; oClosestEnemyUnit='..oClosestEnemyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyUnit)) end
                                end
                                if (bIgnoreLowThreats or (oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6)) and (not(bEnemyUnitsNearlyInRange) or M28UnitInfo.GetUnitHealthPercent(oUnit) >= 0.75) then
                                    if oUnit[M28UnitInfo.refbLastShotBlocked] and M28Utilities.IsTableEmpty(tBlockedShotActualMoveLocation) == false then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Checking Dist to move location='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBlockedShotActualMoveLocation)) end
                                        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBlockedShotActualMoveLocation) <= 1.5 then --tried with <=1 but had issues with frigate on betrayal ocean not firing
                                            --Otherwise will just keep repeating order to move and end up not firing, when there's a chance firing shots might hit something (i.e. might be marginal whether hit cliff or not)
                                            M28Orders.IssueTrackedAggressiveMove(oUnit, tBlockedShotActualMoveLocation, 1.5, false, 'MABlbard', false)
                                        else
                                            M28Orders.IssueTrackedMove(oUnit, tBlockedShotActualMoveLocation, 1.5, false, 'MBlbard', false)
                                        end
                                    else
                                        M28Orders.IssueTrackedMove(oUnit, tBombardmentMainTarget, 10, false, 'MBombard', false)
                                    end
                                else
                                    if bConsiderGroundAttack and ((oUnit[M28UnitInfo.refiDFAOE] or 0) > 0 or (oUnit[M28UnitInfo.refiIndirectAOE] or 0) > 0) then
                                        M28Orders.IssueTrackedGroundAttack(oUnit, tBombardmentMainTarget, 1.5, false, 'AGBombrd', false, oOptionalBombardLinkedTarget)
                                    else
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, tBombardmentMainTarget, 10, false, 'ABombard', false)
                                    end
                                end
                            end
                        else
                            if bBlockedSoMove then --Redundancy (for if we somehow set this to true without a blocked location)
                                M28Orders.IssueTrackedMove(oUnit, tBombardmentMainTarget, 10, false, 'MBBombard', false)
                            else
                                if bDebugMessages == true then LOG(sFunctionRef .. ': Launching specific attack order on ' .. oBuildingToAttack.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oBuildingToAttack)..'; oUnit[M28UnitInfo.refbLastShotBlocked]='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked])) end
                                M28Orders.IssueTrackedAttack(oUnit, oBuildingToAttack, false, 'BAttack', false)
                            end
                        end
                    else
                        M28Orders.IssueTrackedMove(oUnit, tNonBombardmentRallyPoint, 10, false, 'SRSupport', false)
                    end
                end
            else
                M28Orders.IssueTrackedMove(oUnit, tNonBombardmentRallyPoint, 10, false, 'SRMSupport', false)
            end
        end
    else
        M28Utilities.ErrorHandler('No active M28 brain')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageCombatUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableCombatUnits, tAvailableSubmarines, tUnavailableUnitsInThisWZ, tMissileShips)
    --Handles logic for main combat units (direct and indirect fire mobile units) that are noted as available to the land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageCombatUnitsInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tUnassignedLandUnits
    if bDebugMessages == true then LOG(sFunctionRef..': start of code for time '..GetGameTimeSeconds()..', iTeam='..iTeam..'; iPond='..iPond..'; iWaterZone='..iWaterZone..'; Is table of available combat units empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))..'; Is table of available subs empty='..tostring(M28Utilities.IsTableEmpty(tAvailableSubmarines))..'; Are there enemy units in this or adjacent WZ='..tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])..'; Is table of missile ships empty='..tostring(M28Utilities.IsTableEmpty(tMissileShips))) end

    local bWantReinforcements = false

    --Record which untis in adjacent zones are nearest to us:
    local iEnemyBestAntiNavyRange, iEnemyBestCombatRange, iEnemyBestUnderwaterRange = RecordClosestAdjacentRangesAndEnemies(tWZData, tWZTeamData, iPond, iWaterZone, iTeam)
    local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)

    --If enemy has units in this or adjacent WZ, then decide what to do
    local oNearestEnemyToFriendlyBase
    local oNearestEnemySurfaceToFriendlyBase
    local oNearestEnemyNonHoverToFriendlyBase
    local iTargetZoneForNonHover = iWaterZone --Will update with the zone that the nearest non hover enemy is in, for calculating threats
    local iTargetZoneForSurface = iWaterZone --will update with the zone that the nearest surface enemy is in, for calculating threats

    local bUpdateNearestUnit = tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]
    local bCheckIfNearestUnitVisible = false
    local bMoveBlockedNotAttackMove = false
    local bEnemyHasNoCombatUnits

    local iReissueOrderDistanceStandard = 6
    local iResisueOrderDistanceHover = 15
    local iOrderReissueDistToUse = iReissueOrderDistanceStandard
    local tEnemySurfaceUnits = {}
    local tEnemyNonHoverUnits = {}

    --Run to nearest zone with ZZ (or if none, our naval fac) if enemy has air to ground threat here or in adjacent zone and we have no AA in this zone or adjacent to this zone
    local iEnemyAdjacentAirToGroundThreat = tWZTeamData[M28Map.refiEnemyAirToGroundThreat]
    local iFriendlyAdjacentAAThreat = tWZTeamData[M28Map.subrefWZThreatAlliedAA]
    local iCurTime = math.floor(GetGameTimeSeconds())

    function IgnoreOrderDueToStuckUnit(oUnit)
        if oUnit[M28UnitInfo.refbUnitStuckAlternating] then
            if (not(oUnit[M28UnitInfo.refbEasyBrain]) or EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnit.UnitId)) and oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition] and M28Utilities.GetDistanceBetweenPositions(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition], oUnit:GetPosition()) >= 15 then
                --Do nothing - want unit to reach its destination before it gets new orders
                return true
            end
        end
    end

    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
        for _, iAltWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
            local tAltWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAltWZ][M28Map.subrefWZTeamData][iTeam]
            iEnemyAdjacentAirToGroundThreat = iEnemyAdjacentAirToGroundThreat + tAltWZTeamData[M28Map.refiEnemyAirToGroundThreat]
            iFriendlyAdjacentAAThreat = iFriendlyAdjacentAAThreat + (tAltWZTeamData[M28Map.subrefWZThreatAlliedMAA] or 0) * 0.5 --Only factor in part of threat of nearby allied navy
        end
    end

    --Surface subs if enemy has airtoground in this zone (or nearby if it's a large threat)
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if should surface AA subs, iEnemyAdjacentAirToGroundThreat just from this zone='..iEnemyAdjacentAirToGroundThreat..'; Is table of available subs empty='..tostring(M28Utilities.IsTableEmpty(tAvailableSubmarines))) end
    if (iEnemyAdjacentAirToGroundThreat > 2000 or tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0) and M28Utilities.IsTableEmpty(tAvailableSubmarines) == false then
        local tAASubs = EntityCategoryFilterDown(categories.ANTIAIR, tAvailableSubmarines)
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of AA subs empty='..tostring(M28Utilities.IsTableEmpty(tAASubs))) end
        if M28Utilities.IsTableEmpty(tAASubs) == false then
            for iUnit, oUnit in tAASubs do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to surface unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is unit underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))) end
                if M28UnitInfo.IsUnitUnderwater(oUnit) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and surface the unit, is special micro active='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive])..'; Cur time='..GetGameTimeSeconds()..'; Time for micro to reset='..(oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] or 'nil')) end
                    M28UnitInfo.ToggleUnitDiveOrSurfaceStatus(oUnit) --wont do anything if special micro is active, and will set special micro to active if it does give the order
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if want to run from enemy AA iEnemyAdjacentAirToGroundThreat='..iEnemyAdjacentAirToGroundThreat..'; iFriendlyAdjacentAAThreat='..iFriendlyAdjacentAAThreat) end
    local iBestAvailableSubmarineRange = 0
    local bHaveRunFromAir = false
    if iEnemyAdjacentAirToGroundThreat > math.max(50, iFriendlyAdjacentAAThreat * 1.5) and iFriendlyAdjacentAAThreat < 1500 and not(M28Team.tTeamData[iTeam][M28Team.refbDontHaveBuildingsOrACUInPlayableArea]) then

        --Retreat to rally point
        if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
            if iEnemyAdjacentAirToGroundThreat - iFriendlyAdjacentAAThreat > 0 and iEnemyAdjacentAirToGroundThreat - iFriendlyAdjacentAAThreat > M28UnitInfo.GetMassCostOfUnits(tAvailableCombatUnits) * 0.05 then
                bHaveRunFromAir = true
                local tAmphibiousRallyPoint = {tWZTeamData[M28Map.reftClosestFriendlyBase][1], tWZTeamData[M28Map.reftClosestFriendlyBase][2], tWZTeamData[M28Map.reftClosestFriendlyBase][3]}
                for iUnit, oUnit in tAvailableCombatUnits do
                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                    if EntityCategoryContains(categories.AMPHIBIOUS + categories.HOVER, oUnit.UnitId) then
                        M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'WNRetrApA'..iWaterZone)
                    else
                        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'WNRetrFrA'..iWaterZone)
                    end
                end
            end
        else
            tAvailableCombatUnits = nil
        end

        if M28Utilities.IsTableEmpty(tAvailableSubmarines) == false then
            --Decide if we want to run from enemy air - only run if they have torp bombers
            if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want our subs to run from enemy, will depend on if they ahve torps, enemy torp total threat='..(M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] or 0)..'; iFriendlyAdjacentAAThreat='..iFriendlyAdjacentAAThreat..'; Available sub mass value='..M28UnitInfo.GetCombatThreatRating(tAvailableSubmarines, false, true)) end
            if (M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] or 0) > iFriendlyAdjacentAAThreat * 1.5 and M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] - iFriendlyAdjacentAAThreat >= 0.1 * M28UnitInfo.GetMassCostOfUnits(tAvailableSubmarines) then
                bHaveRunFromAir = true
                if bDebugMessages == true then LOG(sFunctionRef..': Will retreat to closest friendly base for amphibious unit, or rally point for subs') end
                local tAmphibiousRallyPoint = {tWZTeamData[M28Map.reftClosestFriendlyBase][1], tWZTeamData[M28Map.reftClosestFriendlyBase][2], tWZTeamData[M28Map.reftClosestFriendlyBase][3]}
                for iUnit, oUnit in tAvailableSubmarines do
                    --Only retreat units from this WZ
                    if oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iWaterZone then
                        oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                        if EntityCategoryContains(categories.AMPHIBIOUS + categories.HOVER, oUnit.UnitId) then --redundancy - wouldnt expect any subs to be amphibious or hover
                            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'WSRetrFrA'..iWaterZone)
                        else
                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'WSRetrFrA'..iWaterZone)
                        end
                    else
                        oUnit[refiCurrentWZAssignmentValue] = 0
                    end
                end
            elseif bDebugMessages == true then LOG(sFunctionRef..': Wont retreat subs as not enough for a torp bomber threat')
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Have told all units to run to tRallyPoint='..repru(tRallyPoint)) end
    end
    if not(bHaveRunFromAir) or M28Utilities.IsTableEmpty(tAvailableSubmarines) == false or M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false or M28Utilities.IsTableEmpty(tMissileShips) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': About to get nearest enemy units to midpoint, tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]='..tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])) end
        if tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then
            if M28Utilities.IsTableEmpty(tAvailableSubmarines) == false then
                for iUnit, oUnit in tAvailableSubmarines do
                    if (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > iBestAvailableSubmarineRange then
                        iBestAvailableSubmarineRange = oUnit[M28UnitInfo.refiAntiNavyRange]
                    end
                end
            end
            bEnemyHasNoCombatUnits = M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies])
            local iClosestDist = 100000
            local iClosestSurfaceDist = 100000
            local iClosestNonHoverDist = 100000

            local iCurDist
            local bDontCheckIfUnitInPlayableArea = not(M28Map.bIsCampaignMap)
            local iClosestToMidpointDist = 100000
            local iClosestSurfaceToMidpointDist = 100000
            local iClosestNonHoverToMidpointDist = 100000
            local iCurMidpointDist

            function ConsiderIfUnitIsClosest(oUnit, bDealingWithAdjZone)
                if bDontCheckIfUnitInPlayableArea or M28Conditions.IsLocationInPlayableArea(oUnit:GetPosition()) then
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tWZTeamData[M28Map.reftClosestFriendlyBase], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                    iCurMidpointDist = nil
                    if iCurDist < iClosestDist then
                        if bDealingWithAdjZone then
                            iCurMidpointDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                            if iCurMidpointDist <= iClosestToMidpointDist then
                                iClosestDist = iCurDist
                                oNearestEnemyToFriendlyBase = oUnit
                                iClosestToMidpointDist = iCurMidpointDist
                            end
                        else
                            iClosestDist = iCurDist
                            oNearestEnemyToFriendlyBase = oUnit
                        end


                    end
                    if iCurDist < iClosestSurfaceDist and not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                        if bDealingWithAdjZone then
                            if not(iCurMidpointDist) then iCurMidpointDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) end
                            if iCurMidpointDist <= iClosestSurfaceToMidpointDist then
                                iClosestSurfaceDist = iCurDist
                                oNearestEnemySurfaceToFriendlyBase = oUnit
                                iClosestSurfaceToMidpointDist = iCurMidpointDist
                            end
                        else
                            iClosestSurfaceDist = iCurDist
                            oNearestEnemySurfaceToFriendlyBase = oUnit
                        end
                        table.insert(tEnemySurfaceUnits, oUnit)
                    end
                    if iCurDist < iClosestNonHoverDist and not(EntityCategoryContains(categories.HOVER, oUnit.UnitId)) then
                        if bDealingWithAdjZone then
                            if not(iCurMidpointDist) then iCurMidpointDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) end
                            if iCurMidpointDist <= iClosestNonHoverToMidpointDist then
                                iClosestNonHoverDist = iCurDist
                                oNearestEnemyNonHoverToFriendlyBase = oUnit
                                iClosestNonHoverToMidpointDist = iCurMidpointDist
                            end
                        else
                            iClosestNonHoverDist = iCurDist
                            oNearestEnemyNonHoverToFriendlyBase = oUnit
                        end
                        table.insert(tEnemyNonHoverUnits, oUnit)
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..(iCurDist or 'nil')..'; iClosestDist='..iClosestDist..'; iClosestSurfaceDist='..iClosestSurfaceDist..'; iClosestNonHoverDist='..iClosestNonHoverDist..'; In playable area='..tostring(M28Conditions.IsLocationInPlayableArea(oUnit:GetPosition()))) end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy units in this zone') end
            for iUnit, oUnit in tWZTeamData[M28Map.subrefTEnemyUnits] do
                ConsiderIfUnitIsClosest(oUnit)
            end
            if oNearestEnemyToFriendlyBase then iClosestToMidpointDist = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tWZData[M28Map.subrefMidpoint]) end
            if oNearestEnemySurfaceToFriendlyBase then iClosestSurfaceToMidpointDist = M28Utilities.GetDistanceBetweenPositions(oNearestEnemySurfaceToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tWZData[M28Map.subrefMidpoint]) end
            if oNearestEnemyNonHoverToFriendlyBase then iClosestNonHoverToMidpointDist = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tWZData[M28Map.subrefMidpoint]) end

            if not(oNearestEnemyToFriendlyBase) then
                local iAdjWZ
                for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                    --iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                    if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent zone '..iAdjWZ..'; is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits]))) end
                        for iUnit, oUnit in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits] do
                            if M28UnitInfo.IsUnitValid(oUnit) then
                                ConsiderIfUnitIsClosest(oUnit, true)
                            end
                        end
                    end
                end
                if not(oNearestEnemyToFriendlyBase) then
                    if bDebugMessages == true then LOG(sFunctionRef..': WZ has flagged it has enemies here or in adjacent WZ but couldnt find any; iPond='..iPond..'; WZ='..iWaterZone) end
                    tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = false
                    tWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] = false
                end
            end

            --First consider submarines
            --Do we have shot blocked on non-skirmisher units, no indirect fire units, and have signficantly more threat than the enemy or are on an island beachhead? If so then move instead of attakc-moving when attacking
            if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to move blocked units instead of attack moving them, ally combat='..tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]..'; Enemy combat='..tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]) end
            if tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] > tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 3 then
                bMoveBlockedNotAttackMove = true
            end

            if tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 1.5 > M28UnitInfo.GetMassCostOfUnits(tAvailableCombatUnits) + M28UnitInfo.GetMassCostOfUnits(tAvailableSubmarines) then
                bWantReinforcements = true
                if bDebugMessages == true then LOG(sFunctionRef..': Want reinforcements as enemy combat exceeds our combat rating, tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Our combat units rating='..M28UnitInfo.GetCombatThreatRating(tAvailableCombatUnits, false, true)) end
            end

        end

        local tSubmarinesWithNoTarget
        local tCombatUnitsWithNoTarget
        if not(oNearestEnemyNonHoverToFriendlyBase) then tSubmarinesWithNoTarget = tAvailableSubmarines end
        if not(oNearestEnemyToFriendlyBase) then tCombatUnitsWithNoTarget = tAvailableCombatUnits end



        if bUpdateNearestUnit and oNearestEnemyToFriendlyBase then
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            if aiBrain then
                M28Team.UpdateUnitLastKnownPosition(aiBrain, oNearestEnemyToFriendlyBase, true)
                if oNearestEnemyNonHoverToFriendlyBase and not(oNearestEnemyNonHoverToFriendlyBase == oNearestEnemyToFriendlyBase) then M28Team.UpdateUnitLastKnownPosition(aiBrain, oNearestEnemyNonHoverToFriendlyBase, true) end
                if oNearestEnemySurfaceToFriendlyBase and not(oNearestEnemySurfaceToFriendlyBase == oNearestEnemyToFriendlyBase) then M28Team.UpdateUnitLastKnownPosition(aiBrain, oNearestEnemySurfaceToFriendlyBase) end
            end
        end

        local bMoveAntiNavyForwardsAsCantSee = false
        if oNearestEnemyNonHoverToFriendlyBase and tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] and tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] < tWZTeamData[M28Map.subrefWZThreatAlliedAntiNavy] then
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            if aiBrain then
                if not(M28UnitInfo.CanSeeUnit(aiBrain, oNearestEnemyNonHoverToFriendlyBase)) then
                    bMoveAntiNavyForwardsAsCantSee = true
                end
            end
        end


        --Calculate firendly and enemy threat values
        local iAdjacentAlliedSubmersibleThreat = 0 -- = tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible]
        local iAdjacentEnemyAntiNavyThreat = 0 -- = tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy]
        local iAdjacentAlliedCombatThreat = 0 --= tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]
        local iAdjacentEnemyCombatThreat = 0 --= tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]
        local iModForEnemyScenario2Threat = 0 --Will increase this if we are deciding whether to attack another zone and that other zone doesnt have friendly combat units in it
        --If no enemies in this zone, then focus on the zone with the nearest enemy unit
        if oNearestEnemySurfaceToFriendlyBase then
            local iNearestUnitPlateauOrZero, iNearestUnitLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oNearestEnemySurfaceToFriendlyBase:GetPosition())
            if iNearestUnitPlateauOrZero == 0 and (iNearestUnitLandOrWaterZone or 0) > 0 then
                iTargetZoneForSurface = iNearestUnitLandOrWaterZone
            end
        end
        if oNearestEnemyNonHoverToFriendlyBase then
            local iNearestUnitPlateauOrZero, iNearestUnitLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oNearestEnemyNonHoverToFriendlyBase:GetPosition())
            if iNearestUnitPlateauOrZero == 0 and (iNearestUnitLandOrWaterZone or 0) > 0 then
                iTargetZoneForNonHover = iNearestUnitLandOrWaterZone
            end
        end

        function IncludeThreatOfAdjacentZone(tBaseWZToUse, tAdjWZTeamData, iAdjWZ, bIncludeAdjacentAlliedSubmersibleThreat, bIncludeAdjacentEnemyAntiNavyThreat, bIncludeAdjacentAlliedCombatThreat, bIncludeAdjacentEnemyCombatThreat)
            --Updates the threat variables for enemies in adjacent zone, based on how close they are to being in range of tBaseWZToUse
            if M28Utilities.IsTableEmpty(tAdjWZTeamData[M28Map.subrefTEnemyUnits]) == false or M28Utilities.IsTableEmpty(tAdjWZTeamData[M28Map.subrefWZTAlliedCombatUnits]) == false then
                local iBaseFactor = 0.2
                local iAlliedFactor = 0.8
                if bIncludeAdjacentAlliedSubmersibleThreat then iAdjacentAlliedSubmersibleThreat = iAdjacentAlliedSubmersibleThreat + (tAdjWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] or 0) * iAlliedFactor end
                if bIncludeAdjacentEnemyAntiNavyThreat then iAdjacentEnemyAntiNavyThreat = iAdjacentEnemyAntiNavyThreat + (tAdjWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] or 0) * iBaseFactor end
                if bIncludeAdjacentAlliedCombatThreat then iAdjacentAlliedCombatThreat = iAdjacentAlliedCombatThreat + (tAdjWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0) * iAlliedFactor end
                if bIncludeAdjacentEnemyCombatThreat then iAdjacentEnemyCombatThreat = iAdjacentEnemyCombatThreat + (tAdjWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * iBaseFactor end
                if bDebugMessages == true then LOG(sFunctionRef..': Adjusting threat for adjacent zones, considering iAdjWZ='..iAdjWZ..', is table of LR units empty='..tostring(M28Utilities.IsTableEmpty(tAdjWZTeamData[M28Map.subreftEnemyLongRangeUnits]))..'; bIncludeAdjacentAlliedSubmersibleThreat='..tostring(bIncludeAdjacentAlliedSubmersibleThreat)..'; bIncludeAdjacentAlliedCombatThreat='..tostring(bIncludeAdjacentAlliedCombatThreat)..'; iAdjacentEnemyAntiNavyThreat before LR adjust='..iAdjacentEnemyAntiNavyThreat..'; iAdjacentEnemyCombatThreat='..iAdjacentEnemyCombatThreat) end
                if M28Utilities.IsTableEmpty(tAdjWZTeamData[M28Map.subreftEnemyLongRangeUnits]) == false then
                    local tLongRangeEnemiesAlmostInRange = {}
                    local iLRFactor = 1 - iBaseFactor
                    local iZoneMinX = tBaseWZToUse[M28Map.subrefPondMinX]
                    local iZoneMinZ = tBaseWZToUse[M28Map.subrefPondMinZ]
                    local iZoneMaxX = tBaseWZToUse[M28Map.subrefPondMaxX]
                    local iZoneMaxZ = tBaseWZToUse[M28Map.subrefPondMaxZ]
                    local iUnitDistAdjust
                    for iUnit, oUnit in tAdjWZTeamData[M28Map.subreftEnemyLongRangeUnits] do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            local tUnitPosition = oUnit:GetPosition()

                            if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) then
                                iUnitDistAdjust = oUnit[M28UnitInfo.refiCombatRange] - 8
                            else
                                iUnitDistAdjust = oUnit[M28UnitInfo.refiCombatRange] + 3
                            end
                            if tUnitPosition[1] + iUnitDistAdjust >= iZoneMinX and tUnitPosition[1] - iUnitDistAdjust <= iZoneMaxX
                                    and tUnitPosition[3] + iUnitDistAdjust >= iZoneMinZ and tUnitPosition[3] - iUnitDistAdjust <= iZoneMaxZ then
                                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit to long range enemies, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Position='..repru(oUnit:GetPosition())..'; iUnitDistAdjust='..iUnitDistAdjust..'; iZoneMinX='..iZoneMinX..';Z='..iZoneMinZ..'; MaxX='..iZoneMaxX..';Z='..iZoneMaxZ) end
                                table.insert(tLongRangeEnemiesAlmostInRange, oUnit)
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tLongRangeEnemiesAlmostInRange) == false then
                        --GetCombatThreatRating(tUnits, bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, bBlueprintThreat)
                        if bIncludeAdjacentEnemyAntiNavyThreat then iAdjacentEnemyAntiNavyThreat = iAdjacentEnemyAntiNavyThreat + M28UnitInfo.GetCombatThreatRating(tLongRangeEnemiesAlmostInRange, true, false, false, true) * iLRFactor end
                        if bIncludeAdjacentEnemyCombatThreat then iAdjacentEnemyCombatThreat = iAdjacentEnemyCombatThreat + M28UnitInfo.GetCombatThreatRating(tLongRangeEnemiesAlmostInRange, true, false, false, false, true) * iLRFactor end
                    end
                end

            end
        end


        --Calc threat differently for enemy antinavy threat if no targets for subs in this zone such that will want to try attacking an adjacent zone - i.e. want to predict whether we will still want to attack when our units are in the adjacent zone
        local bCalcAntiNavyThreatNormally = true
        if oNearestEnemyNonHoverToFriendlyBase and not(iTargetZoneForNonHover == iWaterZone) then
            bCalcAntiNavyThreatNormally = false
        end
        if not(bCalcAntiNavyThreatNormally) then
            local tTargetZoneWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iTargetZoneForNonHover]
            local tTargetZoneWZTeamData = tTargetZoneWZData[M28Map.subrefWZTeamData][iTeam]
            iAdjacentAlliedSubmersibleThreat = (tTargetZoneWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] or 0)
            iAdjacentEnemyAntiNavyThreat = (tTargetZoneWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] or 0)
            if bDebugMessages == true then LOG(sFunctionRef..': Nearest non hover threat is in zone '..iTargetZoneForNonHover..'; will use this as the base for deciding whether to attack with subs, repru(tTargetZoneWZData[M28Map.subrefWZAdjacentWaterZones])='..repru(tTargetZoneWZData[M28Map.subrefWZAdjacentWaterZones])) end
            if M28Utilities.IsTableEmpty(tTargetZoneWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                for _, iAdjWZ in tTargetZoneWZData[M28Map.subrefWZAdjacentWaterZones] do
                    local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                    IncludeThreatOfAdjacentZone(tTargetZoneWZData, tAdjWZTeamData, iAdjWZ, true, true, false, false)
                    --iAdjacentAlliedSubmersibleThreat = iAdjacentAlliedSubmersibleThreat + (tAdjWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] or 0)
                    --iAdjacentEnemyAntiNavyThreat = iAdjacentEnemyAntiNavyThreat + (tAdjWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] or 0)
                end
            end
            if M28Utilities.IsTableEmpty(tTargetZoneWZTeamData[M28Map.subrefWZTAlliedCombatUnits]) == false then
                iModForEnemyScenario2Threat = iModForEnemyScenario2Threat + 0.075
            end
        else
            iAdjacentAlliedSubmersibleThreat = (tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] or 0)
            iAdjacentEnemyAntiNavyThreat = (tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] or 0)
        end

        local bCalcCombatThreatNormally = true
        if oNearestEnemySurfaceToFriendlyBase and not(iTargetZoneForSurface == iWaterZone) then
            bCalcCombatThreatNormally = false
        end
        if not(bCalcCombatThreatNormally) then
            local tTargetZoneWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iTargetZoneForNonHover]
            local tTargetZoneWZTeamData = tTargetZoneWZData[M28Map.subrefWZTeamData][iTeam]
            iAdjacentAlliedCombatThreat = (tTargetZoneWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0)
            iAdjacentEnemyCombatThreat = (tTargetZoneWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)

            if M28Utilities.IsTableEmpty(tTargetZoneWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                for _, iAdjWZ in tTargetZoneWZData[M28Map.subrefWZAdjacentWaterZones] do
                    local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                    IncludeThreatOfAdjacentZone(tTargetZoneWZData, tAdjWZTeamData, iAdjWZ, false, false, true, true)
                    --iAdjacentAlliedCombatThreat = iAdjacentAlliedCombatThreat + (tAdjWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0)
                    --iAdjacentEnemyCombatThreat = iAdjacentEnemyCombatThreat + (tAdjWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                end
            end
            if M28Utilities.IsTableEmpty(tTargetZoneWZTeamData[M28Map.subrefWZTAlliedCombatUnits]) == false then
                iModForEnemyScenario2Threat = iModForEnemyScenario2Threat + 0.075
            end
        else
            iAdjacentAlliedCombatThreat = (tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0)
            iAdjacentEnemyCombatThreat = (tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
        end


        if bCalcAntiNavyThreatNormally or bCalcCombatThreatNormally then
            for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                IncludeThreatOfAdjacentZone(tWZData, tAdjWZTeamData, iAdjWZ, bCalcAntiNavyThreatNormally, bCalcAntiNavyThreatNormally, bCalcCombatThreatNormally, bCalcCombatThreatNormally)
            end
        end


        if bDebugMessages == true then LOG(sFunctionRef..': oNearestEnemyNonHoverToFriendlyBase='..(oNearestEnemyNonHoverToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyNonHoverToFriendlyBase) or 'nil')..'; Is table of avaialble subs empty='..tostring(M28Utilities.IsTableEmpty(tAvailableSubmarines))..'; tWZTeamData[M28Map.subrefWZBestAlliedSubmersibleRange]='..tWZTeamData[M28Map.subrefWZBestAlliedSubmersibleRange]..'; iEnemyBestAntiNavyRange='..iEnemyBestAntiNavyRange) end
        if oNearestEnemyNonHoverToFriendlyBase and M28Utilities.IsTableEmpty(tAvailableSubmarines) == false then
            local bAttackAndKite = false
            local iScenario1AntiNavyRangeThreshold = iEnemyBestAntiNavyRange
            if tWZTeamData[M28Map.subrefWZBestAlliedSubmersibleRange] > iEnemyBestAntiNavyRange then
                bAttackAndKite = true
            else
                --If closeest enemy is a non-hover unit and has significantly worse antinavy range than us, and nearest enemy with equal or better antinavy is
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we can still be aggressive if we outrange the nearest enemy to us, nearest enemy antinavy='..(oNearestEnemyToFriendlyBase[M28UnitInfo.refiAntiNavyRange] or 0)..'; iBestAvailableSubmarineRange='..iBestAvailableSubmarineRange..'; Is nearest enemy unit the nearest hover='..tostring(oNearestEnemyToFriendlyBase == oNearestEnemyNonHoverToFriendlyBase)) end
                if oNearestEnemyToFriendlyBase == oNearestEnemyNonHoverToFriendlyBase and (oNearestEnemyToFriendlyBase[M28UnitInfo.refiAntiNavyRange] or 0) < iBestAvailableSubmarineRange - 8 then
                    --Check for if the enemy has antinavy units that are close enough to this unit that they could support it
                    local bClosestUnitHasAntiNavyCover = false
                    local iAntiNavyThreshold = iBestAvailableSubmarineRange - 8
                    if M28Utilities.IsTableEmpty(tEnemyNonHoverUnits) == false then
                        local iDistToUnit
                        local iStructureThreshold = math.max(-10, -(iBestAvailableSubmarineRange - 10))
                        for iUnit, oUnit in tEnemyNonHoverUnits do
                            if (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) >= iAntiNavyThreshold then
                                iDistToUnit = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition()) - (oUnit[M28UnitInfo.refiAntiNavyRange] or 0)
                                if iDistToUnit <= 16 and (iDistToUnit <= iStructureThreshold or EntityCategoryContains(categories.MOBILE, oUnit.UnitId)) then --within 16 of being in range of the unit closest to our base
                                    bClosestUnitHasAntiNavyCover = true
                                    break
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy unit doesnt have good enough antinaavy range; bClosestUnitHasAntiNavyCover='..tostring(bClosestUnitHasAntiNavyCover)) end
                    if not(bClosestUnitHasAntiNavyCover) then
                        bAttackAndKite = true
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Checking if in scenario 1 or 2 for subs, tWZTeamData[M28Map.subrefWZbCoreBase]='..tostring(tWZTeamData[M28Map.subrefWZbCoreBase] or false)..'; tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible]='..tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible]..'; tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy]='..tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy]..'; tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]='..tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]..'; tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; iAdjacentAlliedSubmersibleThreat='..iAdjacentAlliedSubmersibleThreat..'; iAdjacentEnemyAntiNavyThreat='..iAdjacentEnemyAntiNavyThreat..'; iAdjacentAlliedCombatThreat='.. iAdjacentAlliedCombatThreat..'; iAdjacentEnemyCombatThreat='..iAdjacentEnemyCombatThreat..'; bAttackAndKite='..tostring(bAttackAndKite)) end
            if bAttackAndKite then
                --Scenario 1 - our subs outrange enemy antinavy
                local tOutrangedCombatUnits = {}
                local tUnitsToSupport = {}
                local bAttackWithOutrangedSubUnits = false
                if tWZTeamData[M28Map.subrefWZbCoreBase] then bAttackWithOutrangedSubUnits = true
                elseif tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] > tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] then bAttackWithOutrangedSubUnits = true
                end

                if M28Utilities.GetDistanceBetweenPositions(oNearestEnemyNonHoverToFriendlyBase:GetPosition(), oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) >= 10 then bCheckIfNearestUnitVisible = true end

                for iUnit, oUnit in tAvailableSubmarines do
                    if oUnit[M28UnitInfo.refiAntiNavyRange] > iScenario1AntiNavyRangeThreshold then
                        table.insert(tUnitsToSupport, oUnit)
                        --Seraphim sub and atlantis - make sure are submerged if no enemy AA threat
                        if EntityCategoryContains(categories.ANTIAIR, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbSpecialMicroActive]) and ((tWZTeamData[M28Map.refiEnemyAirToGroundThreat] == 0 and not(M28UnitInfo.IsUnitUnderwater(oUnit))) or (tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 and M28UnitInfo.IsUnitUnderwater(oUnit))) then
                            M28UnitInfo.ToggleUnitDiveOrSurfaceStatus(oUnit)
                            --Consider kiting logic unless want to use shot blocked override logic
                        elseif bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                            --If subs are really close to the target they wont fire, so add in a distance check
                            if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyNonHoverToFriendlyBase:GetPosition()) >= 3 then
                                M28Orders.IssueTrackedMove(oUnit, oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'NSBlckM'..iWaterZone)
                            else
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyNonHoverToFriendlyBase:GetPosition(), 3, false, 'NSBlckAM'..iWaterZone)
                            end
                            --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                            if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                        else
                            --Are we in range of any enemy, or are easy M28? Then attack move
                            if oUnit[M28UnitInfo.refbEasyBrain] or bMoveAntiNavyForwardsAsCantSee or bEnemyHasNoCombatUnits or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tEnemyNonHoverUnits, oUnit[M28UnitInfo.refiAntiNavyRange] * 0.94, iTeam, false)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Not in range of enemy yet, and we outrange enemy; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Antinavy range='..oUnit[M28UnitInfo.refiAntiNavyRange]..'; oNearestEnemyNonHoverToFriendlyBase='..oNearestEnemyNonHoverToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyNonHoverToFriendlyBase)..'; oNearestEnemyNonHoverToFriendlyBase antinavy range='..(oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.refiAntiNavyRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oNearestEnemyNonHoverToFriendlyBase:GetPosition())..'; Enemy last recorded position='..repru(oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; WZ midpoint position='..repru(tWZData[M28Map.subrefMidpoint])) end
                                --Not in range yet, so attack move to the nearest enemy
                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit[M28UnitInfo.refiAntiNavyRange] * 0.5, false, 'NSKAMve'..iWaterZone)
                                end
                            else
                                --Enemy has DF units and they are already in our range so retreat
                                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'NSKRetr'..iWaterZone)
                                --If enemy is able to shoot us then get DF support
                                if not(bAttackWithOutrangedSubUnits) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tEnemyNonHoverUnits, 4, iTeam, true) then
                                    bAttackWithOutrangedSubUnits = true
                                end
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                            end
                        end
                    else
                        if oUnit[M28UnitInfo.refiAntiNavyRange] > 0 then
                            --We dont outrange the enemy, but we do have other units that do
                            if EntityCategoryContains(categories.ANTIAIR, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbSpecialMicroActive]) and ((tWZTeamData[M28Map.refiEnemyAirToGroundThreat] == 0 and not(M28UnitInfo.IsUnitUnderwater(oUnit))) or (tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 and M28UnitInfo.IsUnitUnderwater(oUnit))) then
                                M28UnitInfo.ToggleUnitDiveOrSurfaceStatus(oUnit)
                            else
                                table.insert(tOutrangedCombatUnits, oUnit)
                            end
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tOutrangedCombatUnits) == false then
                    if bAttackWithOutrangedSubUnits then
                        for iUnit, oUnit in tOutrangedCombatUnits do
                            if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                                M28Orders.IssueTrackedMove(oUnit, oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'WSOBlckM'..iWaterZone)
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                            else
                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit[M28UnitInfo.refiAntiNavyRange] * 0.5, false, 'WSSRDFA'..iWaterZone)
                                end
                            end
                        end
                    else
                        if M28Utilities.IsTableEmpty(tUnitsToSupport) == false then
                            --Short range units can stay back and provide support - stay inbetween our long range units and the rally point
                            local iCurDist
                            local iClosestDist
                            local oClosestUnit
                            for iSRUnit, oSRUnit in tOutrangedCombatUnits do
                                iClosestDist = 100000
                                for iLRUnit, oLRUnit in tUnitsToSupport do
                                    iCurDist = M28Utilities.GetRoughDistanceBetweenPositions(oSRUnit:GetPosition(), oLRUnit:GetPosition())
                                    if iCurDist < iClosestDist then
                                        iClosestDist = iCurDist
                                        oClosestUnit = oLRUnit
                                    end
                                end
                                M28Orders.IssueTrackedMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), tRallyPoint), 5, true, false, true), 5, false, 'WSSRSup'..iWaterZone)
                            end
                        else
                            M28Utilities.ErrorHandler('We somehow think we outrange the enemy with subs, but have no subs units with a long range')
                        end
                    end
                end
            else
                --WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, bConsideringSubmarinesNotSurface, iOptionalThreatAbsolutePercentIncrease)
                if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to attack enemy even if outranged, iAdjacentAlliedSubmersibleThreat='..iAdjacentAlliedSubmersibleThreat..'; iAdjacentEnemyAntiNavyThreat='..iAdjacentEnemyAntiNavyThreat..'; iAdjacentAlliedCombatThreat='..iAdjacentAlliedCombatThreat..'; iAdjacentEnemyCombatThreat='..iAdjacentEnemyCombatThreat..'; iModForEnemyScenario2Threat='..iModForEnemyScenario2Threat..'; Want to attack='..tostring(M28Conditions.WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, true                             ,iModForEnemyScenario2Threat ))) end
                if M28Conditions.WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, true                             ,iModForEnemyScenario2Threat ) then
                    --SCENARIO 2 - We are either near our core naval factory or we have a greater threat than the enemy - attack
                    if bDebugMessages == true then LOG(sFunctionRef..': Are in scenario 2 for subs, bMoveBlockedNotAttackMove='..tostring(bMoveBlockedNotAttackMove or false)) end
                    for iUnit, oUnit in tAvailableSubmarines do
                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to move or attack move for sub '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[M28UnitInfo.refbLastShotBlocked]='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked])) end
                        if oNearestEnemyNonHoverToFriendlyBase and oUnit[M28UnitInfo.refiAntiNavyRange] - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyNonHoverToFriendlyBase:GetPosition()) <= 10 and EntityCategoryContains(categories.MOBILE, oNearestEnemyNonHoverToFriendlyBase.UnitId) then
                            M28Orders.IssueTrackedMove(oUnit, oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'SWSbMv'..iWaterZone)
                        elseif bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                            --If subs are really close to the target they wont fire, so add in a distance check
                            if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyNonHoverToFriendlyBase:GetPosition()) >= 3 then
                                M28Orders.IssueTrackedMove(oUnit, oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'SWBAWE'..iWaterZone)
                            else
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyNonHoverToFriendlyBase:GetPosition(), 3, false, 'SWBAMW'..iWaterZone)
                            end

                            --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                            if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                        else
                            if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'SWAWE'..iWaterZone)
                            end
                        end
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': In scenario 3 so will retreat') end
                    --Scenario 3 - want to retreat, or (if we have enough threat available to us) to rally in this zone
                    bWantReinforcements = true
                    local iAvailableSubmersibleThreat = M28UnitInfo.GetCombatThreatRating(tAvailableSubmarines, false, false, false, false, true, false, false)
                    local tSubRallyPoint
                    local sMessage
                    local bConsiderAmphibiousRally = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have enough threat to attack, will see if we want to consolidate in this zone, iAvailableSubmersibleThreat='..iAvailableSubmersibleThreat..'; iAdjacentAlliedSubmersibleThreat='..iAdjacentAlliedSubmersibleThreat..'; Want to attack with navy='..tostring(M28Conditions.WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iAvailableSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, true, iModForEnemyScenario2Threat ))) end
                    if iAvailableSubmersibleThreat > iAdjacentAlliedSubmersibleThreat * 1.1 and iAvailableSubmersibleThreat > (tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] or 0) * 2 and M28Conditions.WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iAvailableSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, true, iModForEnemyScenario2Threat ) then
                        sMessage = 'WSConsR'
                        tSubRallyPoint = {tWZData[M28Map.subrefMidpoint][1], tWZData[M28Map.subrefMidpoint][2], tWZData[M28Map.subrefMidpoint][3]}
                        bConsiderAmphibiousRally = false
                    else
                        sMessage = 'WSRetr'
                        tSubRallyPoint = tRallyPoint
                    end
                    local tAmphibiousRallyPoint = {tWZTeamData[M28Map.reftClosestFriendlyBase][1], tWZTeamData[M28Map.reftClosestFriendlyBase][2], tWZTeamData[M28Map.reftClosestFriendlyBase][3]}
                    for iUnit, oUnit in tAvailableSubmarines do
                        --Only retreat units from this WZ
                        if oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iWaterZone then
                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                            if bConsiderAmphibiousRally and EntityCategoryContains(categories.AMPHIBIOUS + categories.HOVER, oUnit.UnitId) then --redundancy - wouldnt expect a sub to be amphibious
                                M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, sMessage..'_AmphR'..iWaterZone)
                            else
                                M28Orders.IssueTrackedMove(oUnit, tSubRallyPoint, 6, false, sMessage..iWaterZone)
                            end
                        else
                            oUnit[refiCurrentWZAssignmentValue] = 0
                        end
                    end
                end
            end
        end


        --Now consider non-submarine combat units
        if bDebugMessages == true then LOG(sFunctionRef..': oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase) or 'nil')..'; Is table of available combat units empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))..'; oNearestEnemySurfaceToFriendlyBase='..(oNearestEnemySurfaceToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemySurfaceToFriendlyBase) or 'nil')) end
        if oNearestEnemyToFriendlyBase and M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
            local oEnemyToFocusOn

            local tCombatUnitsOfUse
            local tCombatUnitsNeedingAOEForSubs
            local bConsiderUsingAOE = false

            if oNearestEnemyNonHoverToFriendlyBase and (EntityCategoryContains(categories.SUBMERSIBLE, oNearestEnemyNonHoverToFriendlyBase.UnitId) or oNearestEnemyNonHoverToFriendlyBase.UnitId == 'xrb2308' or (M28Map.IsUnderwater({oNearestEnemyNonHoverToFriendlyBase:GetPosition()[1], oNearestEnemyNonHoverToFriendlyBase:GetPosition()[2] + (oNearestEnemyNonHoverToFriendlyBase:GetBlueprint().SizeY or 0) + 1.3, oNearestEnemyNonHoverToFriendlyBase:GetPosition()[3]}, false)) and not(M28Map.IsUnderwater({oNearestEnemyNonHoverToFriendlyBase:GetPosition()[1], oNearestEnemyNonHoverToFriendlyBase:GetPosition()[2] + 1.2 + (oNearestEnemyNonHoverToFriendlyBase:GetBlueprint().SizeY or 0) + 1.3, oNearestEnemyNonHoverToFriendlyBase:GetPosition()[3]}, false))) then
                bConsiderUsingAOE = true
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished considering if we want to use aoe to ground fire subs, bConsiderUsingAOE='..tostring(bConsiderUsingAOE)..'; oNearestEnemyNonHoverToFriendlyBase='..(oNearestEnemyNonHoverToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyNonHoverToFriendlyBase) or 'nil')..'; oNearestEnemySurfaceToFriendlyBase='..(oNearestEnemySurfaceToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemySurfaceToFriendlyBase) or 'nil'))
                if oNearestEnemyNonHoverToFriendlyBase then
                    LOG(sFunctionRef..': Is nearest enemy submersible='..tostring(EntityCategoryContains(categories.SUBMERSIBLE, oNearestEnemyNonHoverToFriendlyBase.UnitId))..'; Is nearest unit underwater='..tostring(not(M28Map.IsUnderwater({oNearestEnemyNonHoverToFriendlyBase:GetPosition()[1], oNearestEnemyNonHoverToFriendlyBase:GetPosition()[2] + 1.2 + (oNearestEnemyNonHoverToFriendlyBase:GetBlueprint().SizeY or 0) + 1.3, oNearestEnemyNonHoverToFriendlyBase:GetPosition()[3]}, false)))..'; Nearest enemy position='..repru(oNearestEnemyNonHoverToFriendlyBase:GetPosition())..'; Unit sizeY='..(oNearestEnemyNonHoverToFriendlyBase:GetBlueprint().SizeY or 'nil')..'; Water height='..M28Map.iMapWaterHeight)
                end
            end




            if bConsiderUsingAOE and (EntityCategoryContains(M28UnitInfo.refCategorySubmarine, oNearestEnemyNonHoverToFriendlyBase.UnitId) or not(oNearestEnemySurfaceToFriendlyBase)) then
                tCombatUnitsOfUse = {}
                tCombatUnitsWithNoTarget = {}
                tCombatUnitsNeedingAOEForSubs = {}
                for iUnit, oUnit in tAvailableCombatUnits do
                    if bConsiderUsingAOE and (oUnit[M28UnitInfo.refiDFAOE] or 0) >= 1.4 and oNearestEnemyNonHoverToFriendlyBase and ((oUnit[M28UnitInfo.refiAntiNavyRange] or 0) == 0 or EntityCategoryContains(M28UnitInfo.refCategoryBattleship, oUnit.UnitId)) then --Doing testing in sandbox, Aeon T2 destroyer aoe of 1.4 can kill subs, as can battleships, but other destroyers with aoe of 1 cant hit subs via ground fire
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with no antinavy range but aoe of '..(oUnit[M28UnitInfo.refiDFAOE] or 0)..' to tCombatUnitsNeedingAOEForSubs') end
                        table.insert(tCombatUnitsNeedingAOEForSubs, oUnit)
                    elseif (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with antinavy range '..oUnit[M28UnitInfo.refiAntiNavyRange]..' to combat units of use') end
                        table.insert(tCombatUnitsOfUse, oUnit)
                    else
                        table.insert(tCombatUnitsWithNoTarget, oUnit)
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with no antinavy range and aoe of '..(oUnit[M28UnitInfo.refiDFAOE] or 0)..' to tCombatUnitsWithNoTarget') end
                    end
                end
            else
                if oNearestEnemySurfaceToFriendlyBase then tCombatUnitsOfUse = tAvailableCombatUnits end
            end


            local iEnemyBestRange = math.max(tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange], tWZTeamData[M28Map.subrefWZBestEnemyDFRange], iEnemyBestAntiNavyRange, iEnemyBestCombatRange)
            local iAlliedBestAntiNavyRange = 0
            local iEnemyBestSumbersibleRange = (tWZTeamData[M28Map.subrefWZBestEnemySubmersibleRange] or 0)
            local iEnemyNearbySubmersibleThreat = tWZTeamData[M28Map.subrefWZThreatEnemySubmersible]
            for iUnit, oUnit in tAvailableCombatUnits do
                iAlliedBestAntiNavyRange = math.max(iAlliedBestAntiNavyRange, (oUnit[M28UnitInfo.refiAntiNavyRange] or 0))
                --If we have a battleship then treat our antinavy range as being equal to that of the battleship
                if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' DF AOE='..(oUnit[M28UnitInfo.refiDFAOE] or 0)..'; is battleship='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryBattleship, oUnit.UnitId))..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0)) end
                if (oUnit[M28UnitInfo.refiDFAOE] or 0) >= 2 and EntityCategoryContains(M28UnitInfo.refCategoryBattleship, oUnit.UnitId) then iAlliedBestAntiNavyRange = math.max(iAlliedBestAntiNavyRange, (oUnit[M28UnitInfo.refiDFRange] or 0)) end
            end
            local iOurAntiNavyThreat = M28UnitInfo.GetCombatThreatRating(tAvailableCombatUnits, false, false, false, true)
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                    local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                    iEnemyBestSumbersibleRange = math.max(iEnemyBestSumbersibleRange, (tAdjWZTeamData[M28Map.subrefWZBestEnemySubmersibleRange] or 0))
                    iEnemyNearbySubmersibleThreat = iEnemyNearbySubmersibleThreat + (tAdjWZTeamData[M28Map.subrefWZThreatEnemySubmersible] or 0)
                end
            end

            function KitingRetreatOfUnit(oUnit)
                --Enemy has DF units and they are already in our range so retreat
                if bDebugMessages == true then LOG(sFunctionRef..': Are close to enemies, iRangeToUseForChecks before reduction='..iRangeToUseForChecks..'; Unit combat range='..oUnit[M28UnitInfo.refiCombatRange]..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                --If we havent fired for a while and are in a core WZ then try an attack order instead
                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                if tWZTeamData[M28Map.subrefWZbCoreBase] and GetGameTimeSeconds() - 2 - (oUnit[M28UnitInfo.refiLastWeaponEvent] or -100) > oUnit[M28UnitInfo.refiTimeBetweenDFShots] and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint) <= 16 then
                    M28Orders.IssueTrackedAttack(oUnit, oEnemyToFocusOn, false, 'NotFirS', false)
                else
                    --Check rally point means we will actually be moving away from the closest enemy
                    local bRunFromNearestEnemy
                    if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                        local iAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())
                        local iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)

                        if bDebugMessages == true then LOG(sFunctionRef..': iAngleToNearestEnemy='..iAngleToNearestEnemy..'; iAngleToRally='..iAngleToRally..'; Angle dif='..M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToRally)..'; Nearest enemy='..oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) end
                        if M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToRally) <= 80 or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint) <= 9 then
                            local tKitingRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToNearestEnemy + 180, 10, true, false, M28Map.bIsCampaignMap)
                            if tKitingRetreatLocation then
                                local iKitingSegmentX, iKitingSegmentZ = M28Map.GetPathingSegmentFromPosition(tKitingRetreatLocation)
                                if M28Map.tPondBySegment[iKitingSegmentX][iKitingSegmentZ] == iPond then
                                    bRunFromNearestEnemy = true
                                    M28Orders.IssueTrackedMove(oUnit, tKitingRetreatLocation, iOrderReissueDistToUse, false, 'NKRetNrE'..iWaterZone)
                                end
                            end
                        end
                    end
                    if not(bRunFromNearestEnemy) then
                        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, iOrderReissueDistToUse, false, 'NKRetr'..iWaterZone)
                    end
                end
            end
            --if iEnemyBestAntiNavyRange > tWZTeamData[M28Map.

            if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we are in scenario 1, tWZTeamData[M28Map.subrefWZBestAlliedDFRange]='..tWZTeamData[M28Map.subrefWZBestAlliedDFRange]..'; iEnemyBestRange='..iEnemyBestRange..'; iEnemyNearbySubmersibleThreat='..iEnemyNearbySubmersibleThreat..'; iEnemyBestSumbersibleRange='..iEnemyBestSumbersibleRange..'; iAlliedBestAntiNavyRange='..iAlliedBestAntiNavyRange..'; iEnemyNearbySubmersibleThreat='..iEnemyNearbySubmersibleThreat..'; iOurAntiNavyThreat='..iOurAntiNavyThreat) end
            local bAreInScenario1 = false
            if M28Utilities.IsTableEmpty(tCombatUnitsOfUse) == false and tWZTeamData[M28Map.subrefWZBestAlliedDFRange] > iEnemyBestRange and (iEnemyNearbySubmersibleThreat < 500 or iEnemyBestSumbersibleRange < iAlliedBestAntiNavyRange or iOurAntiNavyThreat > iEnemyNearbySubmersibleThreat or tWZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > 5 * iEnemyNearbySubmersibleThreat or ((tWZTeamData[M28Map.subrefWZBestAlliedDFRange] > 100 and tWZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > math.max(18000, iEnemyNearbySubmersibleThreat * 2)))) then
                --Scenario 1 - our ships outrange enemy
                bAreInScenario1 = true
                local tOutrangedCombatUnits = {}
                local tUnitsToSupport = {}
                local bAttackWithOutrangedUnits = false
                if tWZTeamData[M28Map.subrefWZbCoreBase] then bAttackWithOutrangedUnits = true
                elseif tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] * 1.5 > tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] then bAttackWithOutrangedUnits = true
                end
                local bNearestEnemyToMidpointIsUnderwater = M28UnitInfo.IsUnitUnderwater(oNearestEnemyToFriendlyBase)
                local iRangeToUseForChecks
                local iEnemyAntiNavyOverride
                if bNearestEnemyToMidpointIsUnderwater and (oNearestEnemyToFriendlyBase[M28UnitInfo.refiAntiNavyRange] or 0) < iEnemyBestUnderwaterRange then
                    iEnemyAntiNavyOverride = (oNearestEnemyToFriendlyBase[M28UnitInfo.refiAntiNavyRange] or 0)
                end

                if M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) >= 10 then bCheckIfNearestUnitVisible = true end
                for iUnit, oUnit in tCombatUnitsOfUse do
                    local tEnemiesToConsider
                    if (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > 0 then
                        oEnemyToFocusOn = oNearestEnemyToFriendlyBase
                        tEnemiesToConsider =  tWZTeamData[M28Map.reftoNearestCombatEnemies]
                        if bNearestEnemyToMidpointIsUnderwater and (oEnemyToFocusOn[M28UnitInfo.refiAntiNavyRange] or 0) > 0 then iRangeToUseForChecks = oUnit[M28UnitInfo.refiAntiNavyRange]
                        else iRangeToUseForChecks = math.max(oUnit[M28UnitInfo.refiAntiNavyRange], (oUnit[M28UnitInfo.refiDFRange] or 0))
                        end
                    else
                        oEnemyToFocusOn = oNearestEnemySurfaceToFriendlyBase
                        tEnemiesToConsider = tEnemySurfaceUnits
                        iRangeToUseForChecks = (oUnit[M28UnitInfo.refiDFRange] or 0)
                    end
                    if EntityCategoryContains(categories.HOVER, oUnit.UnitId) then
                        iOrderReissueDistToUse = iResisueOrderDistanceHover
                    else iOrderReissueDistToUse = iReissueOrderDistanceStandard
                    end

                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if our unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' outrangs enemy, iRangeToUseForChecks='..iRangeToUseForChecks..'; iEnemyBestAntiNavyRange='..iEnemyBestAntiNavyRange..'; iEnemyBestUnderwaterRange='..iEnemyBestUnderwaterRange) end

                    if iRangeToUseForChecks > (iEnemyAntiNavyOverride or iEnemyBestUnderwaterRange) then
                        table.insert(tUnitsToSupport, oUnit)
                        --Consider kiting logic unless want to use shot blocked override logic
                        if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                            if bDebugMessages == true then LOG(sFunctionRef..': oEnemyToFocusOn='..oEnemyToFocusOn.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToFocusOn)..'; Blocked count='..(oEnemyToFocusOn[M28UnitInfo.refiTargetShotBlockedCount] or 0)) end
                            M28Orders.IssueTrackedMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iOrderReissueDistToUse, false, 'NSCBlckM'..iWaterZone)
                            --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                            if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                        else
                            if oUnit[M28UnitInfo.refbEasyBrain] and oEnemyToFocusOn then
                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(iOrderReissueDistToUse, (oUnit[M28UnitInfo.refiDFRange] or 0) * 0.5), false, 'NKAesMve'..iWaterZone)
                                end
                                --Are we in range of any enemy?
                                --CloseToEnemyUnit(tStartPosition, tUnitsToCheck,               iDistThreshold,             iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                            elseif bEnemyHasNoCombatUnits or (bMoveAntiNavyForwardsAsCantSee and (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > 0) or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tEnemiesToConsider, iRangeToUseForChecks * 0.90, iTeam,    false,                  nil,                    nil,                                oUnit)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Not in range of enemy yet, and we outrange enemy; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Antinavy range='..(oUnit[M28UnitInfo.refiAntiNavyRange] or 'nil')..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; oEnemyToFocusOn='..(oEnemyToFocusOn.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEnemyToFocusOn) or 'nil')..'; oEnemyToFocusOn antinavy range='..(oEnemyToFocusOn[M28UnitInfo.refiAntiNavyRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oEnemyToFocusOn:GetPosition())..'; Enemy last recorded position='..repru(oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; WZ midpoint position='..repru(tWZData[M28Map.subrefMidpoint])) end
                                --Not in range yet, so attack move to the nearest enemy

                                --If we have a long range unit, then check if we already have any high value targets in our range (as sometimes attack-move e.g. on a summit doesnt cause it to stop and fire when enemy is in range)

                                if oUnit[M28UnitInfo.refiCombatRange] >= 100 then
                                    if M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemyToFocusOn) and M28Utilities.GetDistanceBetweenPositions(oEnemyToFocusOn:GetPosition(), oUnit:GetPosition()) <= oUnit[M28UnitInfo.refiCombatRange] - 6 then --dont want to chase after enemy necessarily
                                        M28Orders.IssueTrackedAttack(oUnit, oEnemyToFocusOn, false, 'LRNAtE', false)
                                    else
                                        local tNearbyUnitsOfInterest = oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategorySkirmisher * categories.TECH3 + M28UnitInfo.refCategoryStructure - categories.TECH1 + M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryBattleship, oUnit:GetPosition(), oUnit[M28UnitInfo.refiCombatRange], 'Enemy')
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have a long range enemy unit, is table of nearby units of interest empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnitsOfInterest))) end
                                        if M28Utilities.IsTableEmpty(tNearbyUnitsOfInterest) == false then
                                            --if are fixed shields then target the closest one; otherwise if are T2 arti target them; otehrwise target highets value unit
                                            local oEnemyToTarget
                                            local tNearbyShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, tNearbyUnitsOfInterest)
                                            if M28Utilities.IsTableEmpty(tNearbyShields) == false then
                                                oEnemyToTarget = M28Utilities.GetNearestUnit(tNearbyShields, oUnit:GetPosition())
                                            else
                                                local tNearbyT2ArtiAndExperimentalStructure = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryExperimentalLevel * categories.STRUCTURE, tNearbyUnitsOfInterest)
                                                if M28Utilities.IsTableEmpty(tNearbyT2ArtiAndExperimentalStructure) == false then oEnemyToTarget = M28Utilities.GetNearestUnit(tNearbyT2ArtiAndExperimentalStructure, oUnit:GetPosition())
                                                else
                                                    --Target the highest value enemy (or shield if there is one)
                                                    local iHighestValueTarget = 0
                                                    local iCurValueTarget
                                                    for iEnemyTarget, oEnemyTarget in tNearbyUnitsOfInterest do
                                                        if not(M28UnitInfo.IsUnitUnderwater(oEnemyTarget)) then
                                                            iCurValueTarget = oEnemyTarget[M28UnitInfo.refiUnitMassCost]
                                                            if iCurValueTarget > iHighestValueTarget then
                                                                iHighestValueTarget = iCurValueTarget
                                                                oEnemyToTarget = oEnemyTarget
                                                            end
                                                        end
                                                        if oEnemyToTarget then
                                                            M28Orders.IssueTrackedAttack(oUnit, oEnemyToTarget, false, 'LRHVEn', false)
                                                        else
                                                            if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                                M28Orders.IssueTrackedAggressiveMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(iOrderReissueDistToUse, (oUnit[M28UnitInfo.refiDFRange] or 0) * 0.5), false, 'BSKAltM'..iWaterZone)
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        else
                                            if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                M28Orders.IssueTrackedAggressiveMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(iOrderReissueDistToUse, (oUnit[M28UnitInfo.refiDFRange] or 0) * 0.5), false, 'BSKAMve'..iWaterZone)
                                            end
                                        end
                                    end
                                else
                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(iOrderReissueDistToUse, (oUnit[M28UnitInfo.refiDFRange] or 0) * 0.5), false, 'NKAMve'..iWaterZone)
                                    end
                                end

                            else
                                KitingRetreatOfUnit(oUnit)

                                --If enemy is able to shoot us then get DF support
                                --CloseToEnemyUnit(tStartPosition, tUnitsToCheck,       iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                                if not(bAttackWithOutrangedUnits) and
                                        M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tEnemiesToConsider, 4,                  iTeam,  true                ,nil,                   nil,                                nil,                                        nil,                                true) then
                                    bAttackWithOutrangedUnits = true
                                end
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                            end
                        end
                    else
                        if oUnit[M28UnitInfo.refiAntiNavyRange] > 0 or oUnit[M28UnitInfo.refiDFRange] > 0 then
                            --We dont outrange the enemy, but we do have other units that do
                            table.insert(tOutrangedCombatUnits, oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding to table of outranged units') end
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tOutrangedCombatUnits) == false then
                    if bAttackWithOutrangedUnits then
                        local iOurRelevantRange
                        local iEnemyRelevantRange
                        local bEnemyToFocusOnIsUnderwater = M28UnitInfo.IsUnitUnderwater(oEnemyToFocusOn)
                        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                        local bCanSeeEnemy = M28UnitInfo.CanSeeUnit(aiBrain, oEnemyToFocusOn)
                        local bRetreatFromEnemy
                        local tTempRetreatLocation
                        local bCampaignMap = M28Map.bIsCampaignMap

                        if bEnemyToFocusOnIsUnderwater then
                            iEnemyRelevantRange = (oEnemyToFocusOn[M28UnitInfo.refiAntiNavyRange] or 0)
                        else
                            iEnemyRelevantRange = oEnemyToFocusOn[M28UnitInfo.refiCombatRange]
                        end
                        local iDistUntilEnemyOutOfRange = 0
                        for iUnit, oUnit in tOutrangedCombatUnits do
                            if EntityCategoryContains(categories.HOVER, oUnit.UnitId) then iOrderReissueDistToUse = iResisueOrderDistanceHover
                            else iOrderReissueDistToUse = iReissueOrderDistanceStandard
                            end

                            if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                                M28Orders.IssueTrackedMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iOrderReissueDistToUse, false, 'WOBlckM'..iWaterZone)
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                            else
                                bRetreatFromEnemy = false
                                if not(oUnit[M28UnitInfo.refbEasyBrain]) then
                                    if bCanSeeEnemy then
                                        --Are we already in range of the enemy to focus on and do we outrange it? if so then retreat slightly even if overall the enemy outranges us
                                        if bEnemyToFocusOnIsUnderwater then
                                            iOurRelevantRange = (oUnit[M28UnitInfo.refiAntiNavyRange] or 0)
                                        else
                                            iOurRelevantRange = oUnit[M28UnitInfo.refiCombatRange]
                                        end
                                        if bCanSeeEnemy and iOurRelevantRange >= iEnemyRelevantRange then
                                            iDistUntilEnemyOutOfRange = iOurRelevantRange - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn:GetPosition())
                                            if iDistUntilEnemyOutOfRange >= 3 then
                                                tTempRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oEnemyToFocusOn:GetPosition(), oUnit:GetPosition()), math.min(6, iDistUntilEnemyOutOfRange - 1.5), true, false, bCampaignMap)
                                                if NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tTempRetreatLocation) == iPond then
                                                    bRetreatFromEnemy = true
                                                end
                                            end
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': bCanSeeEnemy='..tostring(bCanSeeEnemy)..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iOurRelevantRange='..(iOurRelevantRange or 'nil')..'; iEnemyRelevantRange='..(iEnemyRelevantRange or 'nil')..'; Dist until out of range='..(iDistUntilEnemyOutOfRange or 'nil')..'; bRetreatFromEnemy='..tostring(bRetreatFromEnemy)) end
                                if bRetreatFromEnemy then
                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                    --IssueTrackedMove(oUnit, tOrderPosition, iDistanceToReissueOrder, bAddToExistingQueue, sOptionalOrderDesc, bOverrideMicroOrder)
                                    M28Orders.IssueTrackedMove(oUnit, tTempRetreatLocation, 1.5, false, 'WSRKitR'..iWaterZone, false)
                                else
                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(iOrderReissueDistToUse, (oUnit[M28UnitInfo.refiAntiNavyRange] or 0), (oUnit[M28UnitInfo.refiDFRange] or 0))* 0.5, false, 'WSRDFA'..iWaterZone)
                                    end
                                end
                            end
                        end
                    else
                        if M28Utilities.IsTableEmpty(tUnitsToSupport) == false then
                            --Short range units can stay back and provide support - stay inbetween our long range units and the rally point
                            local iCurDist
                            local iClosestDist
                            local oClosestUnit
                            for iSRUnit, oSRUnit in tOutrangedCombatUnits do
                                if EntityCategoryContains(categories.HOVER, oSRUnit.UnitId) then iOrderReissueDistToUse = iResisueOrderDistanceHover
                                else iOrderReissueDistToUse = iReissueOrderDistanceStandard
                                end
                                iClosestDist = 100000
                                for iLRUnit, oLRUnit in tUnitsToSupport do
                                    iCurDist = M28Utilities.GetRoughDistanceBetweenPositions(oSRUnit:GetPosition(), oLRUnit:GetPosition())
                                    if iCurDist < iClosestDist then
                                        iClosestDist = iCurDist
                                        oClosestUnit = oLRUnit
                                    end
                                end
                                M28Orders.IssueTrackedMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), tRallyPoint), 5, true, false, true), iOrderReissueDistToUse, false, 'WSRSup'..iWaterZone)
                            end
                        else
                            --Presumably we outrange if we include surface and antinavy but enemy only has submersed?
                            bAreInScenario1 = false

                            if bDebugMessages == true then
                                --List out every unit
                                LOG(sFunctionRef..': Will list out every unit in combat units of use, tWZTeamData[M28Map.subrefWZBestAlliedDFRange]='..(tWZTeamData[M28Map.subrefWZBestAlliedDFRange] or 'nil')..'; iEnemyBestAntiNavyRange='..(iEnemyBestAntiNavyRange or 'nil')..'; tWZTeamData[M28Map.subrefWZBestEnemyDFRange]='..(tWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 'nil')..'; iEnemyBestRange='..iEnemyBestRange)
                                for iUnit, oUnit in tCombatUnitsOfUse do
                                    LOG(sFunctionRef..': iUnit='..iUnit..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; AntiNavy range='..(oUnit[M28UnitInfo.refiAntiNavyRange] or 0)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0))
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bAreInScenario1 (and have already applied logic)='..tostring(bAreInScenario1)) end
            if not(bAreInScenario1) then
                if M28Utilities.IsTableEmpty(tCombatUnitsOfUse) == false then
                    --WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, bConsideringSubmarinesNotSurface, iOptionalThreatAbsolutePercentIncrease)
                    local bAreInScenario2 = M28Conditions.WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, false                               ,iModForEnemyScenario2Threat, iEnemyNearbySubmersibleThreat, iOurAntiNavyThreat)

                    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if are in scenario2, bAreInScenario2='..tostring(bAreInScenario2)..'; tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]='..tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]..'; tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Core WZ base='..tostring(tWZTeamData[M28Map.subrefWZbCoreBase])..'; iAdjacentAlliedCombatThreat='..iAdjacentAlliedCombatThreat..'; iAdjacentEnemyCombatThreat='..iAdjacentEnemyCombatThreat) end
                    if bAreInScenario2 then
                        --SCENARIO 2 - We either have enemies near our core naval factory or we have a greater threat than the enemy - attack
                        if bDebugMessages == true then
                            if M28UnitInfo.IsUnitValid(oNearestEnemyToFriendlyBase) then
                                LOG(sFunctionRef..': oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..'; position='..repru(oNearestEnemyToFriendlyBase:GetPosition())..'; Last known position='..repru(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Playable area='..repru(M28Map.rMapPlayableArea))
                                if M28UnitInfo.IsUnitValid(oNearestEnemySurfaceToFriendlyBase) then
                                    LOG(sFunctionRef..' oNearestEnemySurfaceToFriendlyBase='..oNearestEnemySurfaceToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemySurfaceToFriendlyBase)..'; Position='..repru(oNearestEnemySurfaceToFriendlyBase:GetPosition())..'; Last known position='..repru(oNearestEnemySurfaceToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]))
                                end
                            else
                                LOG(sFunctionRef..': Dont have a valid oNearestEnemyToFriendlyBase')
                            end
                        end
                        local bOutrangeClosestEnemy
                        local iDistUntilEnemyOutOfOurRange
                        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                        local bNearestEnemyToMidpointIsVisible = M28UnitInfo.CanSeeUnit(aiBrain, oNearestEnemyToFriendlyBase)
                        local bNearestEnemySurfaceIsVisible
                        if oNearestEnemySurfaceToFriendlyBase then bNearestEnemySurfaceIsVisible = M28UnitInfo.CanSeeUnit(aiBrain, oNearestEnemySurfaceToFriendlyBase) end
                        local bNearestEnemyIsUnderwater = M28UnitInfo.IsUnitUnderwater(oNearestEnemyToFriendlyBase)
                        local bNearestEnemyIsHover = EntityCategoryContains(categories.HOVER, oNearestEnemyToFriendlyBase.UnitId)
                        local iAmountWeOutrangeNearestEnemy
                        local bCheckPlayableArea = M28Map.bIsCampaignMap

                        for iUnit, oUnit in tCombatUnitsOfUse do
                            bOutrangeClosestEnemy = false
                            iDistUntilEnemyOutOfOurRange = 0
                            iAmountWeOutrangeNearestEnemy = 0
                            if (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > 0 then
                                oEnemyToFocusOn = oNearestEnemyToFriendlyBase

                                if bNearestEnemyToMidpointIsVisible then
                                    if bNearestEnemyIsUnderwater then
                                        iAmountWeOutrangeNearestEnemy = oUnit[M28UnitInfo.refiAntiNavyRange] - (oEnemyToFocusOn[M28UnitInfo.refiAntiNavyRange] or 0)
                                        if iAmountWeOutrangeNearestEnemy >= 2 then
                                            bOutrangeClosestEnemy = true
                                            iDistUntilEnemyOutOfOurRange = oUnit[M28UnitInfo.refiAntiNavyRange] - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn:GetPosition())
                                        end
                                    elseif bNearestEnemyIsHover then
                                        iAmountWeOutrangeNearestEnemy = (oUnit[M28UnitInfo.refiDFRange] or 0) - math.max((oEnemyToFocusOn[M28UnitInfo.refiDFRange] or 0), (oEnemyToFocusOn[M28UnitInfo.refiAntiNavyRange] or 0))
                                        if iAmountWeOutrangeNearestEnemy >= 2 then
                                            bOutrangeClosestEnemy = true
                                            iDistUntilEnemyOutOfOurRange = oUnit[M28UnitInfo.refiDFRange] - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn:GetPosition())
                                        end
                                    else
                                        iAmountWeOutrangeNearestEnemy = oUnit[M28UnitInfo.refiCombatRange] - math.max((oEnemyToFocusOn[M28UnitInfo.refiDFRange] or 0), (oEnemyToFocusOn[M28UnitInfo.refiAntiNavyRange] or 0))
                                        if iAmountWeOutrangeNearestEnemy >= 2 then
                                            bOutrangeClosestEnemy = true
                                            iDistUntilEnemyOutOfOurRange = oUnit[M28UnitInfo.refiCombatRange] - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn:GetPosition())
                                        end
                                    end
                                end
                            else
                                oEnemyToFocusOn = oNearestEnemySurfaceToFriendlyBase
                                if bNearestEnemySurfaceIsVisible then
                                    if bNearestEnemyIsHover then
                                        iAmountWeOutrangeNearestEnemy = (oUnit[M28UnitInfo.refiDFRange] or 0) - math.max((oEnemyToFocusOn[M28UnitInfo.refiDFRange] or 0), (oEnemyToFocusOn[M28UnitInfo.refiAntiNavyRange] or 0))
                                        if iAmountWeOutrangeNearestEnemy >= 2 then
                                            bOutrangeClosestEnemy = true
                                            iDistUntilEnemyOutOfOurRange = oUnit[M28UnitInfo.refiDFRange] - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn:GetPosition())
                                        end
                                    else
                                        iAmountWeOutrangeNearestEnemy = oUnit[M28UnitInfo.refiCombatRange] - math.max((oEnemyToFocusOn[M28UnitInfo.refiDFRange] or 0), (oEnemyToFocusOn[M28UnitInfo.refiAntiNavyRange] or 0))
                                        if iAmountWeOutrangeNearestEnemy >= 2 then
                                            bOutrangeClosestEnemy = true
                                            iDistUntilEnemyOutOfOurRange = oUnit[M28UnitInfo.refiCombatRange] - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn:GetPosition())
                                        end
                                    end
                                end
                            end

                            if EntityCategoryContains(categories.HOVER, oUnit.UnitId) then iOrderReissueDistToUse = iResisueOrderDistanceHover
                            else iOrderReissueDistToUse = iReissueOrderDistanceStandard
                            end

                            if bDebugMessages == true then LOG(sFunctionRef..': bOutrangeClosestEnemy (factoring in if we can see the unit)='..tostring(bOutrangeClosestEnemy)..'; iDistUntilEnemyOutOfOurRange'..iDistUntilEnemyOutOfOurRange) end

                            if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                                M28Orders.IssueTrackedMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iOrderReissueDistToUse, false, 'WBAWE'..iWaterZone)
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                            elseif iDistUntilEnemyOutOfOurRange >= 3 and not(oUnit[M28UnitInfo.refbEasyBrain]) then
                                --if we outrange the enemy we are focused on and are already in range then move back slightly even though we dont outrange the enemy as a whole
                                local tLocalisedKitingPosition = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oEnemyToFocusOn:GetPosition(), oUnit:GetPosition()), math.min(5, iDistUntilEnemyOutOfOurRange - 0.25), true, false, bCheckPlayableArea)
                                if NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tLocalisedKitingPosition) == iPond then
                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                    M28Orders.IssueTrackedMove(oUnit, tLocalisedKitingPosition, 1, false, 'WATKR'..iWaterZone)
                                else
                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iOrderReissueDistToUse, false, 'WATWE'..iWaterZone)
                                    end
                                end
                            else
                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iOrderReissueDistToUse, false, 'WAWE'..iWaterZone)
                                end
                            end
                        end
                    else
                        --Are we in the (rare) case where we have units with same DF range as enemy DF units, and enemy DF is due to torp launchers, while we have aoe attack, such that we could ground fire the torp launchers to outrange them?
                        --GetCombatThreatRating(tUnits,         bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, bBlueprintThreat)
                        local iAvailableCombatThreat = M28UnitInfo.GetCombatThreatRating(tCombatUnitsOfUse, false,          false,          false,                  false,          true,           false,          false)

                        local bAntiTorpLauncherMode = false
                        --Consider attacking if we outrange enemy DF units but not antinavy units, but we have better threat than their subersible threat (e.g. enemy threat is torp launchers, or units with weak antinavy attack)
                        if oNearestEnemySurfaceToFriendlyBase and iAvailableCombatThreat >= 1000 and tWZTeamData[M28Map.subrefWZBestAlliedDFRange] == iEnemyBestRange and tWZTeamData[M28Map.subrefWZBestAlliedDFRange] > tWZTeamData[M28Map.subrefWZBestEnemyDFRange] and (iEnemyBestSumbersibleRange < iAlliedBestAntiNavyRange or iOurAntiNavyThreat > iEnemyNearbySubmersibleThreat) and tWZTeamData[M28Map.subrefWZBestAlliedDFRange] >= 50 then
                            if bDebugMessages == true then LOG(sFunctionRef..': we might still consider attacking due to enemy range being torp launchers') end
                            local tLRUnits = {}
                            local tSRUnits = {}
                            local bUseAOEAttacks = false
                            local iNearestEnemyRangeThreshold = (oNearestEnemySurfaceToFriendlyBase[M28UnitInfo.refiCombatRange] or 0)
                            if tWZTeamData[M28Map.subrefWZBestAlliedDFRange] > iNearestEnemyRangeThreshold then
                                local bEnemyIsHover = EntityCategoryContains(categories.HOVER, oNearestEnemySurfaceToFriendlyBase.UnitId)
                                if bDebugMessages == true then LOG(sFunctionRef..': We outrange the enemy surface unit nearest midpoint so will assume it is the closest unit to us and attack') end
                                for iUnit, oUnit in tCombatUnitsOfUse do
                                    if oUnit[M28UnitInfo.refiCombatRange] > iNearestEnemyRangeThreshold and (not(bEnemyIsHover) or (oUnit[M28UnitInfo.refiDFRange] or 0) > iNearestEnemyRangeThreshold or (oUnit[M28UnitInfo.refiIndirectRange] or 0) > iNearestEnemyRangeThreshold) and not(oUnit:GetAIBrain().M28Easy) then
                                        table.insert(tLRUnits, oUnit)
                                    else
                                        table.insert(tSRUnits, oUnit)
                                    end
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryStructure, oNearestEnemySurfaceToFriendlyBase.UnitId) then
                                bUseAOEAttacks = true
                                if bDebugMessages == true then LOG(sFunctionRef..': The nearest enemy unit has equal range to our best range unit but is a structure, so we will attack it and try to ground fire if possible') end
                                for iUnit, oUnit in tCombatUnitsOfUse do
                                    if oUnit[M28UnitInfo.refiCombatRange] >= iNearestEnemyRangeThreshold and (oUnit[M28UnitInfo.refiDFAOE] or 0) > 0.1 then
                                        table.insert(tLRUnits, oUnit)
                                    else
                                        table.insert(tSRUnits, oUnit)
                                    end
                                end
                            end
                            local iClosestLRUnitDist = 10000
                            local oClosestLRUnit
                            if M28Utilities.IsTableEmpty(tLRUnits) == false then
                                --Special scenario
                                local oEnemyToFocusOn = oNearestEnemySurfaceToFriendlyBase
                                local iCurDist
                                bAntiTorpLauncherMode = true
                                if bDebugMessages == true then LOG(sFunctionRef..': About to enter special scenario mode for zone '..iWaterZone..', oEnemyToFocusOn='..oEnemyToFocusOn.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToFocusOn)) end
                                for iUnit, oUnit in tLRUnits do
                                    if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                                        M28Orders.IssueTrackedMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iOrderReissueDistToUse, false, 'NTorLBl'..iWaterZone)
                                        if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                                        if not(oEnemyToFocusOn) then
                                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(),  oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                                        end
                                    elseif not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(),  oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..iCurDist..'; Unit combat range='..oUnit[M28UnitInfo.refiCombatRange]..'; bUseAOEAttacks='..tostring(bUseAOEAttacks)) end
                                        if iCurDist < oUnit[M28UnitInfo.refiCombatRange] - 5 then
                                            --Kiting retreat
                                            KitingRetreatOfUnit(oUnit)
                                        else
                                            --Attack-move to the nearest enemy, unless we have AOE and enemy has same range as us, in which case check for nearest enemy unit and attack ground if it is a surface unit
                                            if bUseAOEAttacks then
                                                if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] == oEnemyToFocusOn) and not(M28UnitInfo.IsUnitUnderwater(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) then
                                                    --Attack the nearest enemy to us instead of the original target
                                                    if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId) and (oUnit[M28UnitInfo.refiCombatRange] or 0) <= (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiCombatRange] or 0) then
                                                        --Do aoe attack
                                                        local tGroundAttackTarget = M28Utilities.MoveInDirection(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), oUnit[M28UnitInfo.refiDFAOE] * 0.75, true)
                                                        M28Orders.IssueTrackedGroundAttack(oUnit, tGroundAttackTarget, oUnit[M28UnitInfo.refiDFAOE], false, 'NTorAOEGA', false, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Doing ground attack as oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]'..oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) end
                                                    else
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy isnt a structure so we will do attack move towards it, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]='..oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) end
                                                        --do attack move
                                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iOrderReissueDistToUse, false, 'NTorAOEAM'..iWaterZone)
                                                    end
                                                else
                                                    --do aoe attack
                                                    local tGroundAttackTarget = M28Utilities.MoveInDirection(oEnemyToFocusOn:GetPosition(), M28Utilities.GetAngleFromAToB(oEnemyToFocusOn:GetPosition(), oUnit:GetPosition()), oUnit[M28UnitInfo.refiDFAOE] * 0.75, true)
                                                    M28Orders.IssueTrackedGroundAttack(oUnit, tGroundAttackTarget, oUnit[M28UnitInfo.refiDFAOE], false, 'NTorAOEGA', false, oEnemyToFocusOn)
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Doing ground attack to attack the enemy') end
                                                end
                                            else
                                                if bDebugMessages == true then LOG(sFunctionRef..': Arent relying on aoe to attack') end
                                                M28Orders.IssueTrackedAggressiveMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iOrderReissueDistToUse, false, 'NTorLAM'..iWaterZone)
                                            end
                                        end
                                    end
                                    if iCurDist < iClosestLRUnitDist then
                                        iClosestLRUnitDist = iCurDist
                                        oClosestLRUnit = oUnit
                                    end
                                end

                                if oClosestLRUnit and M28Utilities.IsTableEmpty(tSRUnits) == false then
                                    local tSupportPosition = M28Utilities.MoveInDirection(oClosestLRUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestLRUnit:GetPosition(), tRallyPoint), 10, true)
                                    for iUnit, oUnit in tSRUnits do
                                        M28Orders.IssueTrackedMove(oUnit, tSupportPosition, 5, false, 'NTorSRSup'..iWaterZone, false)
                                    end
                                end

                                if bUpdateNearestUnit then
                                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                                        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                                        if aiBrain then
                                            M28Team.UpdateUnitLastKnownPosition(aiBrain, oNearestEnemyToFriendlyBase, true)
                                        end
                                    else
                                        M28Utilities.ErrorHandler('No active M28 brain')
                                    end
                                end
                                --if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                                --if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                            end
                        end

                        --Scenario 3 - want to retreat (but only retreat units from this WZ)
                        bWantReinforcements = true
                        if not(bAntiTorpLauncherMode) and M28Utilities.IsTableEmpty(tCombatUnitsOfUse) == false then
                            local tSubRallyPoint
                            local sMessage
                            local bConsiderAmphibiousRally = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Dont have enough threat to attack with surface naval units, will see if we want to consolidate in this zone, iAvailableCombatThreat='..iAvailableCombatThreat..'; iAdjacentAlliedCombatThreat='..iAdjacentAlliedCombatThreat..'; Want to attack with navy='..tostring(M28Conditions.WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAvailableCombatThreat, iAdjacentEnemyCombatThreat, true, iModForEnemyScenario2Threat, iEnemyNearbySubmersibleThreat,  iOurAntiNavyThreat ))) end
                            if iAvailableCombatThreat > iAdjacentAlliedCombatThreat and M28Conditions.WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAvailableCombatThreat, iAdjacentEnemyCombatThreat, true, iModForEnemyScenario2Threat, iEnemyNearbySubmersibleThreat,  iOurAntiNavyThreat) then
                                sMessage = 'WSfConsR'
                                tSubRallyPoint = {tWZData[M28Map.subrefMidpoint][1], tWZData[M28Map.subrefMidpoint][2], tWZData[M28Map.subrefMidpoint][3]}
                                bConsiderAmphibiousRally = false
                            else
                                sMessage = 'WSfRetr'
                                tSubRallyPoint = tRallyPoint
                            end
                            local tAmphibiousRallyPoint = {tWZTeamData[M28Map.reftClosestFriendlyBase][1], tWZTeamData[M28Map.reftClosestFriendlyBase][2], tWZTeamData[M28Map.reftClosestFriendlyBase][3]}

                            for iUnit, oUnit in tCombatUnitsOfUse do
                                if oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iWaterZone then
                                    if EntityCategoryContains(categories.HOVER, oUnit.UnitId) then iOrderReissueDistToUse = iResisueOrderDistanceHover
                                    else iOrderReissueDistToUse = iReissueOrderDistanceStandard
                                    end
                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                    if bConsiderAmphibiousRally and EntityCategoryContains(categories.AMPHIBIOUS + categories.HOVER, oUnit.UnitId) then --redundancy - wouldnt expect a sub to be amphibious
                                        M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, iOrderReissueDistToUse, false, sMessage..'_AmpR'..iWaterZone)
                                    else
                                        M28Orders.IssueTrackedMove(oUnit, tSubRallyPoint, iOrderReissueDistToUse, false, sMessage..iWaterZone)
                                    end
                                else
                                    oUnit[refiCurrentWZAssignmentValue] = 0
                                end
                            end
                        end
                    end
                end
            end

            --Ground fire subs
            if bDebugMessages == true then LOG(sFunctionRef..': Considering ground firing subs, is tCombatUnitsNeedingAOEForSubs empty='..tostring(M28Utilities.IsTableEmpty(tCombatUnitsNeedingAOEForSubs))..'; Is oNearestEnemyNonHoverToFriendlyBase nil='..tostring(oNearestEnemyNonHoverToFriendlyBase == nil)) end
            if M28Utilities.IsTableEmpty(tCombatUnitsNeedingAOEForSubs) == false and oNearestEnemyNonHoverToFriendlyBase then
                local tTargetPoint = oNearestEnemyNonHoverToFriendlyBase:GetPosition()
                tTargetPoint[2] = GetSurfaceHeight(tTargetPoint[1], tTargetPoint[3])
                for iUnit, oUnit in tCombatUnitsNeedingAOEForSubs do
                    --Ground fire the closest enemy unit
                    M28Orders.IssueTrackedGroundAttack(oUnit, tTargetPoint, 1, false, 'GrndFr', false)
                end
            end
        end

        --Missile ships - consider retreating from nearby enemy units
        local tMissileShipsToBombard = {}
        if M28Utilities.IsTableEmpty(tMissileShips) == false then
            if oNearestEnemyToFriendlyBase then
                for iUnit, oUnit in tMissileShips do
                    if M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition()) <= math.max(oUnit[M28UnitInfo.refiCombatRange] * 0.6, math.min(oUnit[M28UnitInfo.refiCombatRange] - 10, oNearestEnemyToFriendlyBase[M28UnitInfo.refiCombatRange] + 10, (tWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0) + 10)) then
                        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 5, false, 'MisRetr', false)
                    else
                        table.insert(tMissileShipsToBombard, oUnit)
                    end
                end
            else
                tMissileShipsToBombard = tMissileShips
            end
        end

        --Update if had visula of WZ recently
        if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
            tWZTeamData[M28Map.refiTimeLastHadVisual] = GetGameTimeSeconds()
        end


        if bDebugMessages == true then LOG(sFunctionRef..': Is table of subs with no target empty='..tostring(M28Utilities.IsTableEmpty(tSubmarinesWithNoTarget))..'; Is table of combat units with no target empty='..tostring(M28Utilities.IsTableEmpty(tCombatUnitsWithNoTarget))) end
        if M28Utilities.IsTableEmpty(tSubmarinesWithNoTarget) == false or M28Utilities.IsTableEmpty(tCombatUnitsWithNoTarget) == false or M28Utilities.IsTableEmpty(tMissileShipsToBombard) == false then
            --No enemies in the water zone or adjacent that can target so will look to reinforce another water zone
            --ConsiderOrdersForUnitsWithNoTarget(tWZData, iPond, iWaterZone, iTeam, tSubmarinesWithNoTarget, tCombatUnitsWithNoTarget, tMissileShips)
            tUnassignedLandUnits = ConsiderOrdersForUnitsWithNoTarget(tWZData, iPond, iWaterZone, iTeam, tSubmarinesWithNoTarget, tCombatUnitsWithNoTarget, tMissileShipsToBombard)
            if M28Utilities.IsTableEmpty(tSubmarinesWithNoTarget) == false then
                if not(M28Team.tTeamData[iTeam][M28Team.refiTimeLastNoSubCombatTargetByPond]) then M28Team.tTeamData[iTeam][M28Team.refiTimeLastNoSubCombatTargetByPond] = {} end
                M28Team.tTeamData[iTeam][M28Team.refiTimeLastNoSubCombatTargetByPond][iPond] = GetGameTimeSeconds()
            end
            if M28Utilities.IsTableEmpty(tCombatUnitsWithNoTarget) == false then
                if not(M28Team.tTeamData[iTeam][M28Team.refiTimeLastNoSurfaceCombatTargetByPond]) then M28Team.tTeamData[iTeam][M28Team.refiTimeLastNoSurfaceCombatTargetByPond] = {} end
                M28Team.tTeamData[iTeam][M28Team.refiTimeLastNoSurfaceCombatTargetByPond][iPond] = GetGameTimeSeconds()
            end
        end
    end

    --Override support if we couldnt find any enemies
    if bWantReinforcements and (not(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) or tWZData[M28Map.subrefbPacifistArea]) then bWantReinforcements = false end
    UpdateIfWaterZoneWantsSupport(tWZTeamData, bWantReinforcements)
    if bDebugMessages == true then LOG(sFunctionRef..': Just recorded if this WZ wants support, bWantReinforcements='..tostring(bWantReinforcements)..'; is tUnassignedLandUnits empty='..tostring(M28Utilities.IsTableEmpty(tUnassignedLandUnits))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tUnassignedLandUnits
end

function ManageMAAInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableMAA)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMAAInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
    local tAmphibiousRallyPoint = {tWZTeamData[M28Map.reftClosestFriendlyBase][1], tWZTeamData[M28Map.reftClosestFriendlyBase][2], tWZTeamData[M28Map.reftClosestFriendlyBase][3]}
    local iResisueOrderDistanceHover = 15

    --First split the MAA into those that need to run (due to being in range of DF units) and those that can advance
    local tAvailableSubjectToAA = {}
    local tMAAToAdvance = {}
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Time='..GetGameTimeSeconds()..' for iPond='..iPond..' iWaterZone '..iWaterZone..' iTeam '..iTeam..'; Is table of nearest combat enemies empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]))..'; Is subreftoAllNearbyEnemyT2ArtiUnits empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]))) end

    local tEnemyT2Arti = {}

    if M28Conditions.IsTableOfUnitsStillValid(tWZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) then
        for iUnit, oUnit in tWZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits] do
            if oUnit:GetFractionComplete() == 1 then
                table.insert(tEnemyT2Arti, oUnit)
            end
        end
    end
    local bCheckForT2Arti = not(M28Utilities.IsTableEmpty(tEnemyT2Arti))

    function RetreatUnitTowardsNavalOrAmphibiousRally(oUnit, sOrderDesc)
        if EntityCategoryContains(categories.AMPHIBIOUS + categories.HOVER, oUnit.UnitId) then
            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, iResisueOrderDistanceHover, false, (sOrderDesc or 'Run')..'A'..iWaterZone)
        else
            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, iResisueOrderDistanceHover, false, (sOrderDesc or 'Run')..'N'..iWaterZone)
        end
    end

    function DoesUnitWantToRunFromT2Arti(oUnit, iRunThreshold)
        if bCheckForT2Arti then --redundancy
            for iArti, oArti in tEnemyT2Arti do
                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oArti:GetPosition()) <= iRunThreshold + (oArti[M28UnitInfo.refiCombatRange] or 0) then
                    return true
                end
            end
        end
        return false
    end
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]) then
        --No DF enemies so treat all MAA as being available
        if bDebugMessages == true then LOG(sFunctionRef..': No nearby combat enemies so treating all MAA as being available unless in range of T2 arti, bCheckForT2Arti='..tostring(bCheckForT2Arti)) end
        if bCheckForT2Arti then
            for iUnit, oUnit in tAvailableMAA do
                if not(DoesUnitWantToRunFromT2Arti(oUnit, 10)) then
                    table.insert(tAvailableSubjectToAA, oUnit)
                else
                    RetreatUnitTowardsNavalOrAmphibiousRally(oUnit, 'RunT2Art')
                end
            end
        else
            tAvailableSubjectToAA = tAvailableMAA
        end

    else
        local iRunThreshold = 30
        if tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
            iRunThreshold = 15
        end
        for iUnit, oUnit in tAvailableMAA do
            --Run if within 30 of being in range of enemy combat
            if bDebugMessages == true then
                LOG(sFunctionRef..': MAA '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' - checking if is too close to enemy, is close='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tWZTeamData[M28Map.reftoNearestCombatEnemies], iRunThreshold, iTeam, true                    ,nil                        ,nil                            ,nil                                        ,nil                                    ,true))..'; iRunThreshold='..iRunThreshold..'; will run back if are too close; will list out enemy units and distance to us in a moment; Is unit too close to T2 arti='..tostring(DoesUnitWantToRunFromT2Arti(oUnit, 10)))
                for iEnemy, oEnemy in tWZTeamData[M28Map.reftoNearestCombatEnemies] do
                    LOG('oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; DF r ange='..(oEnemy[M28UnitInfo.refiDFRange] or 'nil')..'; Dist to this MAA unit='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Actual distance using actual position='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemy:GetPosition()))
                end
            end
            --                      CloseToEnemyUnit(tStartPosition, tUnitsToCheck,                             iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
            if M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tWZTeamData[M28Map.reftoNearestCombatEnemies], iRunThreshold, iTeam, true                    ,nil                        ,nil                            ,nil                                        ,nil                                    ,true) then
                RetreatUnitTowardsNavalOrAmphibiousRally(oUnit, 'RunDF')
            else
                --Check not in range of T2 arti
                if bCheckForT2Arti and DoesUnitWantToRunFromT2Arti(oUnit, 10) then
                    RetreatUnitTowardsNavalOrAmphibiousRally(oUnit, 'RunT2Art')
                else
                    table.insert(tAvailableSubjectToAA, oUnit)
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': is table of tAvailableSubjectToAA empty after running from DF threats='..tostring(M28Utilities.IsTableEmpty(tAvailableSubjectToAA))) end
    if M28Utilities.IsTableEmpty(tAvailableSubjectToAA) == false then
        --Retreat individual MAA units if in range of enemy air and enemy has high air to ground threat
        local tMAAToRunFromAir = {}
        local iEnemyAirToGroundThreat = tWZTeamData[M28Map.refiEnemyAirToGroundThreat]
        local iOurAAThreat = tWZTeamData[M28Map.subrefWZThreatAlliedAA]
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
            for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do --include half of the 'excess' enemy air to ground threat in adjacent zones
                local tAdjWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                iEnemyAirToGroundThreat = iEnemyAirToGroundThreat + ((tAdjWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) -  (tAdjWZTeamData[M28Map.subrefWZThreatAlliedAA] or 0) * 3)*0.5
            end
        end

        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
            for _, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                local tAdjLZTeamData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefWPlatAndLZNumber][1]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefWPlatAndLZNumber][2]][M28Map.subrefLZTeamData][iTeam]
                iEnemyAirToGroundThreat = iEnemyAirToGroundThreat + (tAdjLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) + (tAdjLZTeamData[M28Map.refiEnemyAirOtherThreat] or 0)
            end
        end
        local tEnemyAirToRunFrom
        if bDebugMessages == true then LOG(sFunctionRef..': iEnemyAirToGroundThreat='..iEnemyAirToGroundThreat..'; iOurAAThreat='..iOurAAThreat) end
        if iEnemyAirToGroundThreat > iOurAAThreat then
            --We may lose if our AA goes up against their air threat, so want to retreat any AA units that are reasonably in-range
            local iCategoriesToAvoid = M28UnitInfo.refCategoryAirToGround - M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL -M28UnitInfo.refCategoryBomber * categories.TECH3 --dont want to avoid t3 or exp bombers since they struggle to turn around
            if tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]) == false then
                tEnemyAirToRunFrom = EntityCategoryFilterDown(iCategoriesToAvoid, tWZTeamData[M28Map.reftWZEnemyAirUnits])
            end
            if not(tEnemyAirToRunFrom) then tEnemyAirToRunFrom = {} end
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do --include half of the 'excess' enemy air to ground threat in adjacent zones
                    local tAdjWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                    if tAdjWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 and   M28Utilities.IsTableEmpty(tAdjWZTeamData[M28Map.reftWZEnemyAirUnits]) == false then
                        local tAdditionalAirToRunFrom = EntityCategoryFilterDown(iCategoriesToAvoid, tAdjWZTeamData[M28Map.reftWZEnemyAirUnits])
                        if M28Utilities.IsTableEmpty(tAdditionalAirToRunFrom) == false then
                            for iUnit, oUnit in tAdditionalAirToRunFrom do
                                if M28UnitInfo.IsUnitValid(oUnit) then table.insert(tEnemyAirToRunFrom, oUnit) end
                            end
                        end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
                for _, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do --include half of the 'excess' enemy air to ground threat in adjacent zones
                    local tAdjLZTeamData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefWPlatAndLZNumber][1]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefWPlatAndLZNumber][2]][M28Map.subrefLZTeamData][iTeam]
                    if tAdjLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 and   M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftLZEnemyAirUnits]) == false then
                        local tAdditionalAirToRunFrom = EntityCategoryFilterDown(iCategoriesToAvoid, tAdjLZTeamData[M28Map.reftLZEnemyAirUnits])
                        if M28Utilities.IsTableEmpty(tAdditionalAirToRunFrom) == false then
                            for iUnit, oUnit in tAdditionalAirToRunFrom do
                                if M28UnitInfo.IsUnitValid(oUnit) then table.insert(tEnemyAirToRunFrom, oUnit) end
                            end
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is tEnemyAirToRunFrom empty='..tostring(M28Utilities.IsTableEmpty(tEnemyAirToRunFrom))) end
        if M28Utilities.IsTableEmpty(tEnemyAirToRunFrom) then
            tMAAToAdvance = tAvailableSubjectToAA
        else
            local iAttackMoveDistWithinRangeWanted = 4
            local iMoveDistWithinRange = 8

            local bAAInRange, iCurDistWithinRange
            for iMAA, oMAA in tAvailableSubjectToAA do
                bAAInRange = false
                for iAirUnit, oAirUnit in tEnemyAirToRunFrom do
                    iCurDistWithinRange = (oMAA[M28UnitInfo.refiAARange] or 0) - M28Utilities.GetDistanceBetweenPositions(oMAA:GetPosition(), oAirUnit:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oMAA='..oMAA.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMAA)..'; AA range='..(oMAA[M28UnitInfo.refiAARange] or 0)..'; oAirUnit='..oAirUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oAirUnit)..'; Dist to oAirUnit='..M28Utilities.GetDistanceBetweenPositions(oMAA:GetPosition(), oAirUnit:GetPosition())) end
                    if iCurDistWithinRange >= iAttackMoveDistWithinRangeWanted then
                        bAAInRange = true
                        if iCurDistWithinRange >= iMoveDistWithinRange then
                            --Move away
                            RetreatUnitTowardsNavalOrAmphibiousRally(oMAA, 'AAMPRun')
                        else
                            --Attack move away
                            if EntityCategoryContains(categories.AMPHIBIOUS + categories.HOVER, oMAA.UnitId) then
                                M28Orders.IssueTrackedAttackMove(oMAA, tAmphibiousRallyPoint, iResisueOrderDistanceHover, false, 'AAAPRun'..iWaterZone)
                            else
                                M28Orders.IssueTrackedAttackMove(oMAA, tRallyPoint, iResisueOrderDistanceHover, false, 'AAARun'..iWaterZone)
                            end
                        end
                        break
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': bAAInRange='..tostring(bAAInRange)) end
                if not(bAAInRange) then table.insert(tMAAToAdvance, oMAA) end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of tMAAToAdvance empty='..tostring(M28Utilities.IsTableEmpty(tMAAToAdvance))) end
    local bDontCheckIfUnitInPlayableArea = not(M28Map.bIsCampaignMap)
    --If enemy has air units in this zone then send the MAA to advance units towards it, but avoid enemy land units
    if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
        local bDontCheckIfInCampaignArea = not(M28Map.bIsCampaignMap)
        if bDebugMessages == true then LOG(sFunctionRef..': Number of MAA units to advance='..table.getn(tMAAToAdvance)..'; Is table of enemy air units for this WZ '..iWaterZone..' empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]))) end

        --Do we have missile based MAA in this list, and if so does the enemy have nearby structures of interest? (i.e. T2+ structures)
        local tCombatAAByOrigRef = {}
        local iBestRange = 0
        local iLowestBestRange = 1000 --i.e. of those that are more than the threshold (80 as of first draft), what is the worst range?
        local iClosestZoneWithStructuresDist = 10000
        local tClosestEnemyBuildingsOfInterest
        local oClosestEnemyStructureOfInterest
        local oEnemyStructureToTarget
        local oClosestModDistEnemyStructure -- will favour higher priority enemy targets that may not be the closest unit
        local iApproxDistUntilEnemyInRangeOfZone = 10000
        local iSurfaceRange

        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
            for iUnit, oUnit in tMAAToAdvance do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit combat range='..oUnit[M28UnitInfo.refiCombatRange]..'; Last shot blocked='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked] or false)) end
                if oUnit[M28UnitInfo.refiCombatRange] >= 80 then --covers cybran cruisers
                    iSurfaceRange = math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0))
                    if iSurfaceRange >= 80 then
                        if oUnit[M28UnitInfo.refbLastShotBlocked] and (oUnit[M28UnitInfo.refiIndirectRange] or 0) == 0 and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                            --Do nothing - direct fire cruiser whose shot is blocked so want to use like normal AA unit
                        else
                            tCombatAAByOrigRef[iUnit] = oUnit
                            if oUnit[M28UnitInfo.refiCombatRange] >= iBestRange then iBestRange = oUnit[M28UnitInfo.refiCombatRange] end
                        end
                        iLowestBestRange = math.min(iLowestBestRange, iSurfaceRange)
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for combat AA units, iBestRange='..iBestRange) end
            --if iBestRange >= 80 then
            --search for enemy buildings both for potential targets, and t2 arti/pd to retreat from
            local iDistanceThreshold = math.max(iBestRange + 90, 40+128)
            local bDontCheckPlayableArea = M28Map.bIsCampaignMap
            local iBestEnemyRangeForThisZone
            local iApproxMidpointAdjust

            local iClosestBuildingDist = 10000
            local iCurDist
            local iCurModDist
            local iClosestBuildingModDist = 10000
            local iZoneCountFromFirstBuilding = 0
            for iEntry, tSubtable in tWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                if tSubtable[M28Map.subrefiDistance] > iDistanceThreshold then
                    break
                else
                    if not(iApproxMidpointAdjust) then iApproxMidpointAdjust = tSubtable[M28Map.subrefiDistance] end --i.e. dist from the closest land/water zone midpoint to this midpoint will be used as a proxy to adjust the other distances, on the assumption that a unit in the closest zone to this could be firing at units in this zone
                    local tAltLZOrWZData
                    local tAltLZOrWZTeamData
                    iBestEnemyRangeForThisZone = 0
                    if tSubtable[M28Map.subrefbIsWaterZone] then --will check if it's in the same pond later on
                        tAltLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                        tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                        --Water zone - only consider DF+Antinayv range, not indirect fire since should be able to dodge most IF
                        iBestEnemyRangeForThisZone = math.max((tAltLZOrWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0), (tAltLZOrWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] or 0))
                    else
                        --Land zone
                        tAltLZOrWZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                        tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                        iBestEnemyRangeForThisZone = math.max((tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0), (tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0), (tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0))
                        if (tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] or 0) >= 200 then
                            iBestEnemyRangeForThisZone = math.max(iBestEnemyRangeForThisZone, 128)
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering entry '..iEntry..'; Is water zone='..tostring(tSubtable[M28Map.subrefbIsWaterZone])..'; PlateauOrPond='..tSubtable[M28Map.subrefiPlateauOrPond]..'; Zone ref='..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..'; In playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAltLZOrWZData[M28Map.subrefMidpoint]))..'; Enemy structure value='..(tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0)) end
                    --Get the closest enemy unit to thie midpoint of this zone if we have combat aa:
                    if (bDontCheckIfInCampaignArea or M28Conditions.IsLocationInPlayableArea(tAltLZOrWZData[M28Map.subrefMidpoint])) and iBestRange >= 80 and (tSubtable[M28Map.subrefiPlateauOrPond] == iPond or not(tSubtable[M28Map.subrefbIsWaterZone])) and iZoneCountFromFirstBuilding <= 8 then
                        if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAltLZOrWZData[M28Map.subrefMidpoint])) and (tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) >= 200 then
                            if oClosestEnemyStructureOfInterest then iZoneCountFromFirstBuilding = iZoneCountFromFirstBuilding + 1 end
                            tClosestEnemyBuildingsOfInterest = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure - categories.TECH1, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits])
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy buildsings empty='..tostring(M28Utilities.IsTableEmpty(tClosestEnemyBuildingsOfInterest))) end
                            if M28Utilities.IsTableEmpty(tClosestEnemyBuildingsOfInterest) == false then
                                if not(oClosestEnemyStructureOfInterest) then iClosestZoneWithStructuresDist = tSubtable[M28Map.subrefiDistance] end
                                --Get the closest enemy unit to thie midpoint of this zone if we have combat aa:

                                for iUnit, oUnit in tClosestEnemyBuildingsOfInterest do
                                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() >= 0.7 then
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tWZData[M28Map.subrefMidpoint])
                                        iCurModDist = iCurDist
                                        if EntityCategoryContains(categories.TECH3 + categories.EXPERIMENTAL + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryTMD, oUnit.UnitId) then
                                            iCurModDist = math.min(iCurModDist * 0.8, iCurModDist - 30)
                                        end
                                        if iCurDist < iClosestBuildingDist then
                                            iClosestBuildingDist = iCurDist
                                            oClosestEnemyStructureOfInterest = oUnit
                                        end
                                        if iCurModDist < iClosestBuildingModDist then
                                            iClosestBuildingModDist = iCurModDist
                                            oClosestModDistEnemyStructure = oUnit
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': iClosestZoneWithStructuresDist='..iClosestZoneWithStructuresDist..'; iClosestBuildingDist='..iClosestBuildingDist..'; oClosestEnemyStructureOfInterest='..oClosestEnemyStructureOfInterest.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyStructureOfInterest)) end
                            end
                        end
                    end
                    --Also record how close an enemy unit is to being in range of the midpoint of this zone
                    iApproxDistUntilEnemyInRangeOfZone = math.min(iApproxDistUntilEnemyInRangeOfZone, tSubtable[M28Map.subrefiDistance] - iApproxMidpointAdjust - iBestEnemyRangeForThisZone)
                end
            end

            if oClosestEnemyStructureOfInterest then
                --Switch closest enemy structure to closest mod dist enemy structure if we are likely to be in range of it
                if not(oClosestModDistEnemyStructure == oClosestEnemyStructureOfInterest) and iClosestBuildingModDist < iClosestBuildingDist then
                    --Are we in the same pond if we move towards this water zone midpoint?
                    local iActualDistToClosestModDist = M28Utilities.GetDistanceBetweenPositions(oClosestModDistEnemyStructure:GetPosition(), tWZData[M28Map.subrefMidpoint])
                    if iActualDistToClosestModDist <= iLowestBestRange then
                        oEnemyStructureToTarget = oClosestModDistEnemyStructure
                    else
                        local tPossibleAttackPoint = M28Utilities.MoveInDirection(oClosestModDistEnemyStructure:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestModDistEnemyStructure:GetPosition(), tWZData[M28Map.subrefMidpoint]), iActualDistToClosestModDist, true, false, false)
                        if NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tPossibleAttackPoint) == iPond then
                            oEnemyStructureToTarget = oClosestModDistEnemyStructure
                        else
                            oEnemyStructureToTarget = oClosestEnemyStructureOfInterest
                        end
                    end
                else
                    oEnemyStructureToTarget = oClosestEnemyStructureOfInterest
                end

                --Filter the combat MAA further to only include those who are either in range of oEnemyStructureToTarget, or would be in the same pond if they moved in range
                local iCurDist
                for iUnit, oUnit in tCombatAAByOrigRef do

                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oEnemyStructureToTarget:GetPosition(), oUnit:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if combat AA unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is in range of oEnemyStructureToTarget, CCombat range='..oUnit[M28UnitInfo.refiCombatRange]..'; iCurDist='..iCurDist) end
                    if iCurDist > oUnit[M28UnitInfo.refiCombatRange] then
                        local bHaveValidTarget = false
                        for iDistInterval = 0, 50, 10 do
                            local tPossibleFiringPoint = M28Utilities.MoveInDirection(oEnemyStructureToTarget:GetPosition(), M28Utilities.GetAngleFromAToB(oEnemyStructureToTarget:GetPosition(), oUnit:GetPosition()), oUnit[M28UnitInfo.refiCombatRange] - iDistInterval, true, false, false)
                            if NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tPossibleFiringPoint) == iPond then
                                bHaveValidTarget = true
                                break
                            end
                        end
                        if not(bHaveValidTarget) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Dont have valid firing point so removing combat unit') end
                            tCombatAAByOrigRef[iUnit] = nil
                        end
                    end
                end
            end
            --end
        else
            M28Air.RecordOtherLandAndWaterZonesByDistance(tWZData, tWZData[M28Map.subrefMidpoint])
        end
        function AttackWithCombatAA(bOptionalOnlyAttackIfInRange)
            --Assign any remaining combatAA to attack the nearest structure to them
            --First remove from the orig MAA list
            if bDebugMessages == true then LOG(sFunctionRef..': Will attack with all combat AA units') end
            local iTableSize = table.getn(tMAAToAdvance)
            local iRevisedIndex = 1
            for iOrigIndex=1, iTableSize do
                if tMAAToAdvance[iOrigIndex] then
                    if not(tCombatAAByOrigRef[iOrigIndex]) or(bOptionalOnlyAttackIfInRange and M28Utilities.GetDistanceBetweenPositions(tCombatAAByOrigRef[iOrigIndex]:GetPosition(), oEnemyStructureToTarget:GetPosition()) <= tCombatAAByOrigRef[iOrigIndex][M28UnitInfo.refiCombatRange]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                        --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                        if (iOrigIndex ~= iRevisedIndex) then
                            tMAAToAdvance[iRevisedIndex] = tMAAToAdvance[iOrigIndex];
                            tMAAToAdvance[iOrigIndex] = nil;
                        end
                        if bOptionalOnlyAttackIfInRange then tCombatAAByOrigRef[iOrigIndex] = nil end
                        iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                    else
                        tMAAToAdvance[iOrigIndex] = nil;
                    end
                end
            end
            if iRevisedIndex < iTableSize then
                --table.setn(tMAAToAdvance, iRevisedIndex - 1)
                for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
                    table.remove(tMAAToAdvance, iRemovalEntry)
                end
            end

            --Now assign the combat MAA to attack the enemy structure
            for iUnit, oUnit in tCombatAAByOrigRef do
                --Get the closest enemy structure to this unit and attack it, unless we may be in range of a unit that can hurt us and are more than 6 in range of this

                if iApproxDistUntilEnemyInRangeOfZone <= 5 and oUnit[M28UnitInfo.refiCombatRange] - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyStructureToTarget:GetPosition()) >= 6 then
                    --move away if same pond
                    local tTempRetreat = M28Utilities.MoveInDirection(oEnemyStructureToTarget:GetPosition(), M28Utilities.GetAngleFromAToB(oEnemyStructureToTarget:GetPosition(), oUnit:GetPosition()), oUnit[M28UnitInfo.refiCombatRange], true, false, M28Map.bIsCampaignMap)
                    if NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tTempRetreat) == iPond then
                        M28Orders.IssueTrackedMove(oUnit, tTempRetreat, 2, false, 'MAAReta', false)
                    else
                        M28Orders.IssueTrackedAttack(oUnit, oEnemyStructureToTarget, false, 'CrNRAtc', false)
                    end
                else
                    M28Orders.IssueTrackedAttack(oUnit, oEnemyStructureToTarget, false, 'CrSAtc', false)
                end
            end
        end

        local bConsiderAttackingStructuresInstead = false
        if M28UnitInfo.IsUnitValid(oEnemyStructureToTarget) and iClosestZoneWithStructuresDist < 500 and M28Utilities.IsTableEmpty(tCombatAAByOrigRef) == false and M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
            bConsiderAttackingStructuresInstead = true
        else
            tCombatAAByOrigRef = nil
        end

        local bGivenOrderToGoToEnemyAirUnit = false
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]) == false then
            --Move towards the nearest enemy air unit to the WZ midpoint, unless are a combat AA unit in range of enemy unit (in which case keep attacking it)
            if bConsiderAttackingStructuresInstead then
                AttackWithCombatAA(true) --Only attacks structures if are in range of them
            end

            if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                local oNearestEnemyToMidpoint
                local iClosestDist = 100000
                local iCurDist
                --Get closest enemy air unit
                for iUnit, oUnit in tWZTeamData[M28Map.reftWZEnemyAirUnits] do
                    if bDontCheckIfUnitInPlayableArea or M28Conditions.IsLocationInPlayableArea(oUnit:GetPosition()) then
                        if (oUnit[M28UnitInfo.refiTargetShotBlockedCount] or 0) >= 10 then --Have had 10 shots at this unit and they have all been blocked - want to treat it as invisible
                            --Dont include as ap otential nearest enemy
                            if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has a shot blocked count of '..(oUnit[M28UnitInfo.refiTargetShotBlockedCount] or 0)) end
                        else
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oNearestEnemyToMidpoint = oUnit
                            end
                        end
                    end
                end

                --Move towards the air unit
                if oNearestEnemyToMidpoint then
                    bGivenOrderToGoToEnemyAirUnit = true
                    local tOrderPosition = oNearestEnemyToMidpoint:GetPosition()
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..' Will order every MAA to move to oNearestEnemyToMidpoint='..oNearestEnemyToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint)..' at position '..repru(oNearestEnemyToMidpoint:GetPosition()))
                        M28Utilities.DrawLocation(tOrderPosition)
                    end

                    for iUnit, oUnit in tMAAToAdvance do
                        M28Orders.IssueTrackedMove(oUnit, tOrderPosition, iResisueOrderDistanceHover, false, 'NMNA')
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Will do reprs of orders of the first unit in tMAAToAdvance, '..tMAAToAdvance[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tMAAToAdvance[1])..': '..reprs(tMAAToAdvance[1][M28Orders.reftiLastOrders])) end
                end
            end
        end

        if not(bGivenOrderToGoToEnemyAirUnit) and M28Utilities.IsTableEmpty(tMAAToAdvance) == false then

            local tWZToReinforceModDistance = {}
            local iCurModDist
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': About to consider all other adjacent land zones to iWaterZone '..iWaterZone..' to reinforce with AA, reprs of tWZData[M28Map.subrefWZOtherWaterZones]='..reprs(tWZData[M28Map.subrefWZOtherWaterZones])) end

                local iAltWZ
                local bDontCheckInPlayableArea = not(M28Map.bIsCampaignMap)
                local iThresholdForAA = 100
                if M28Team.tTeamData[iTeam][M28Team.subrefbUseFrigatesAsScoutsByPond][iPond] and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] >= 2 then iThresholdForAA = 400 end
                for iEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                    iAltWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                    local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAltWZ]
                    if bDontCheckInPlayableArea or M28Conditions.IsLocationInPlayableArea(tAltWZData[M28Map.subrefMidpoint]) then
                        local tAltTeamWZData = tAltWZData[M28Map.subrefWZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to send MAA to assist alt WZ iAltWZ='..iAltWZ..'; tAltTeamWZData[M28Map.subrefWZMAAThreatWanted]='..tAltTeamWZData[M28Map.subrefWZMAAThreatWanted]..'; tAltTeamWZData[M28Map.subrefWZThreatAlliedAA]='..tAltTeamWZData[M28Map.subrefWZThreatAlliedAA]..'; Air to ground threat in this alt WZ='..tAltTeamWZData[M28Map.refiEnemyAirToGroundThreat]..'; Our allied surface threat in this WZ='..tWZTeamData[M28Map.subrefWZThreatAlliedSurface]) end
                        if tAltTeamWZData[M28Map.subrefWZMAAThreatWanted] > tAltTeamWZData[M28Map.subrefWZThreatAlliedAA] and (tAltTeamWZData[M28Map.subrefWZMAAThreatWanted] > iThresholdForAA or M28Utilities.IsTableEmpty(tAltTeamWZData[M28Map.reftWZEnemyAirUnits]) == false) then
                            iCurModDist = tWZSubtable[M28Map.subrefWZAWZDistance]
                            if tAltTeamWZData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                                iCurModDist = iCurModDist - 200
                                if tAltTeamWZData[M28Map.subrefWZTThreatAllyCombatTotal] > 0 then iCurModDist = iCurModDist - 35 end
                            elseif (tAltTeamWZData[M28Map.refiEnemyAirOtherThreat] + tAltTeamWZData[M28Map.refiEnemyAirAAThreat]) > 45 then iCurModDist = iCurModDist - 100
                            end
                            if bConsiderAttackingStructuresInstead and iClosestZoneWithStructuresDist > iCurModDist and M28Utilities.IsTableEmpty(tAltTeamWZData[M28Map.reftWZEnemyAirUnits]) then iCurModDist = iCurModDist + 100 end
                            if M28Utilities.IsTableEmpty(tAltTeamWZData[M28Map.subreftoLZOrWZAlliedUnits]) then iCurModDist = iCurModDist + 100 end
                            if tAltTeamWZData[M28Map.subrefTThreatEnemyCombatTotal] > 6 then
                                iCurModDist = iCurModDist + 50
                                if tAltTeamWZData[M28Map.subrefWZTThreatAllyCombatTotal] == 0 then
                                    iCurModDist = iCurModDist + 150
                                elseif tAltTeamWZData[M28Map.subrefTThreatEnemyCombatTotal] > tAltTeamWZData[M28Map.subrefWZTThreatAllyCombatTotal] then
                                    iCurModDist = iCurModDist + 75
                                end
                            end
                            if tAltTeamWZData[M28Map.subrefWZTThreatAllyCombatTotal] < iThresholdForAA and M28Utilities.IsTableEmpty(tAltTeamWZData[M28Map.reftWZEnemyAirUnits]) and tAltTeamWZData[M28Map.subrefWZMAAThreatWanted] < iThresholdForAA * 2 then iCurModDist = iCurModDist + 100 end
                            if bDebugMessages == true then LOG(sFunctionRef..': Recording iAltWZ '..iAltWZ..' with a mod dist of '..iCurModDist) end
                            tWZToReinforceModDistance[iAltWZ] = iCurModDist
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to send MAA to assist alt WZ iAltWZ, but it isnt in playable area, iAltWZ='..iAltWZ..'; In playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAltWZData[M28Map.subrefMidpoint]))) end
                    end
                end
                if M28Utilities.IsTableEmpty(tWZToReinforceModDistance) == false then

                    for iWZ, iModDist in M28Utilities.SortTableByValue(tWZToReinforceModDistance, false) do
                        if bConsiderAttackingStructuresInstead and iModDist > iClosestZoneWithStructuresDist then
                            if M28Utilities.IsTableEmpty(tCombatAAByOrigRef) == false then
                                AttackWithCombatAA()

                                if M28Utilities.IsTableEmpty(tMAAToAdvance) then break end
                            end
                        end
                        --SendMAAToSupportWaterZone(tMAAToAdvance, iPond, iTeam, iWZToSupport, iMAAFactorAdjust, iStartingWZ)
                        SendMAAToSupportWaterZone(tMAAToAdvance, iPond, iTeam, iWZ, nil,        iWaterZone, tCombatAAByOrigRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished sending MAA to support iWZ='..iWZ..'; Is table of MAA to advance empty yet='..tostring(M28Utilities.IsTableEmpty(tMAAToAdvance))) end
                        if M28Utilities.IsTableEmpty(tMAAToAdvance) then
                            break
                        end
                    end
                end

                if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                    --Do we have any combat AA units to attack with still?
                    if M28Utilities.IsTableEmpty(tCombatAAByOrigRef) == false then
                        AttackWithCombatAA()
                    end
                    if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                            for iEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                                iAltWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                                local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAltWZ]
                                if (bDontCheckIfInCampaignArea or M28Conditions.IsLocationInPlayableArea(tAltWZData[M28Map.subrefMidpoint])) then
                                    local tAltWZTeamData = tAltWZData[M28Map.subrefWZTeamData][iTeam]
                                    if M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false and tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] and tAltWZTeamData[M28Map.subrefWZThreatAlliedAA] < tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] * 0.4 then
                                        SendMAAToSupportWaterZone(tMAAToAdvance, iPond, iTeam, iAltWZ, nil, iWaterZone)
                                    end
                                end
                            end
                        end
                    end
                end



                --Do we have any MAA remaining after sending MAA to any WZ wanting support?
                if bDebugMessages == true then LOG(sFunctionRef..': Finished sending MAA to WZs wanting support, is table empty of MAA still to advance='..tostring(M28Utilities.IsTableEmpty(tMAAToAdvance))) end
                if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                    local iFactorAdjust
                    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                        for iEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                            iAltWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                            local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAltWZ]
                            if (bDontCheckIfInCampaignArea or M28Conditions.IsLocationInPlayableArea(tAltWZData[M28Map.subrefMidpoint])) then
                                local tAltWZTeamData = tAltWZData[M28Map.subrefWZTeamData][iTeam]
                                if tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] > 10 or tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < 10 then
                                    iFactorAdjust = 2
                                    if tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then iFactorAdjust = 4 end
                                    SendMAAToSupportWaterZone(tMAAToAdvance, iPond, iTeam, iAltWZ, iFactorAdjust, iWaterZone)
                                    if M28Utilities.IsTableEmpty(tMAAToAdvance) then break end
                                end
                            end
                        end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Still have spare MAA, will go to rally point') end
                for iUnit, oUnit in tMAAToAdvance do
                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, iResisueOrderDistanceHover, false, 'NBRtr'..iWaterZone)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SendMAAToSupportWaterZone(tMAAToAdvance, iPond, iTeam, iWZToSupport, iMAAFactorAdjust, iStartingWZ, tOptionalCombatAAByOrigRef)
    --Assigns MAA to the water zone up to the level at which the WZ doesnt want more MAA support, but increases the MAA wanted by the water zone by iMAAFactorAdjust (or 1 if not specified)
    --tOptionalCombatAAByOrigRef - if we have missile cruisers or cybran cruisers then want ot update this table if removing units from tMAAToAdvance
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SendMAAToSupportWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iResisueOrderDistanceHover = 20 --higher than normal

    local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWZToSupport]
    local tAltTeamWZData = tAltWZData[M28Map.subrefWZTeamData][iTeam]
    local tDistToTargetByRef = {}
    local tTargetPosition = tAltWZData[M28Map.subrefMidpoint]
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for iStartingWZ='..(iStartingWZ or 'nil')..' at time '..GetGameTimeSeconds()..'; iWZToSupport='..iWZToSupport..'; tAltTeamWZData[M28Map.subrefWZMAAThreatWanted]='..(tAltTeamWZData[M28Map.subrefWZMAAThreatWanted] or 'nil')) end
    if not(tAltTeamWZData[M28Map.subrefWZMAAThreatWanted]) or not(tAltTeamWZData[M28Map.subrefWZThreatAlliedAA]) then
        M28Utilities.ErrorHandler('Have nil MAA or AllyGroundAA threat for iWZToSupport='..(iWZToSupport or 'nil')..'; see log for more info')
        LOG(sFunctionRef..': MAA iTeam='..(iTeam or 'nil')..'; iPond='..(iPond or 'nil')..'; iWZToSupport='..(iWZToSupport or 'nil')..'; tAltTeamWZData[M28Map.subrefWZThreatAlliedAA]='..(tAltTeamWZData[M28Map.subrefWZThreatAlliedAA] or 'nil')..'; reprs of teamWZData='..reprs(tAltTeamWZData))
    else
        local iMAAThreatWanted = tAltTeamWZData[M28Map.subrefWZMAAThreatWanted] * (iMAAFactorAdjust or 1) - tAltTeamWZData[M28Map.subrefWZThreatAlliedAA]
        local tbRemovedMAAReferencesByRef = {}
        for iUnit, oUnit in tMAAToAdvance do
            if oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iStartingWZ then
                tDistToTargetByRef[iUnit] = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetPosition)
            else
                --Unit is from a different zone - need to change the value of its assignment so it is considered for orders by the zone that it is part of
                oUnit[refiCurrentWZAssignmentValue] = 0
                tbRemovedMAAReferencesByRef[iUnit] = true
            end
        end

        for iUnitRef, iDistance in M28Utilities.SortTableByValue(tDistToTargetByRef, false) do
            M28Orders.IssueTrackedMove(tMAAToAdvance[iUnitRef], tTargetPosition, iResisueOrderDistanceHover, false, 'NMVEWZ'..iWZToSupport)
            iMAAThreatWanted = iMAAThreatWanted - M28UnitInfo.GetAirThreatLevel({ tMAAToAdvance[iUnitRef] }, false, false, true, false, false, false)
            tbRemovedMAAReferencesByRef[iUnitRef] = true
            if iMAAThreatWanted < 0 then break end
        end
        if M28Utilities.IsTableEmpty(tbRemovedMAAReferencesByRef) == false then
            --Remove any MAA that have given orders from tMAAToAdvance:
            local iRevisedIndex = 1
            local iTableSize = table.getn(tMAAToAdvance)

            for iOrigIndex=1, iTableSize do
                if tMAAToAdvance[iOrigIndex] then
                    if not(tbRemovedMAAReferencesByRef[iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                        --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                        if (iOrigIndex ~= iRevisedIndex) then
                            tMAAToAdvance[iRevisedIndex] = tMAAToAdvance[iOrigIndex];
                            tMAAToAdvance[iOrigIndex] = nil;
                            if tOptionalCombatAAByOrigRef[iOrigIndex] then
                                tOptionalCombatAAByOrigRef[iRevisedIndex] = tOptionalCombatAAByOrigRef[iOrigIndex]
                                tOptionalCombatAAByOrigRef[iOrigIndex] = nil
                            end
                        end
                        iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                    else
                        tMAAToAdvance[iOrigIndex] = nil;
                        if tOptionalCombatAAByOrigRef then tOptionalCombatAAByOrigRef[iOrigIndex] = nil end
                    end
                end
            end
            if iRevisedIndex < iTableSize then
                --table.setn(tMAAToAdvance, iRevisedIndex - 1)
                for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
                    table.remove(tMAAToAdvance, iRemovalEntry)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RetreatOtherUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tOtherUnitsToRetreat)
    local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
    for iUnit, oUnit in tOtherUnitsToRetreat do
        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 16, false, 'NOtRet', false)
    end
end

function ManageWaterZoneScouts(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tScouts, bWaterZoneContainsNonScouts)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageWaterZoneScouts'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    tWZTeamData[M28Map.refbWantLandScout] = false
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want a land scout at time='..GetGameTimeSeconds()..' for iPond '..iPond..'; iWaterZone='..iWaterZone..'; nemy combat threat='..tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Is table of land scouts traveling here empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTScoutsTravelingHere]))..'; Is table of scouts currently in this WZ empty='..tostring(M28Utilities.IsTableEmpty(tScouts))) end

    --Refresh list of scouts traveling here
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTScoutsTravelingHere]) == false then
        local iTableSize = table.getn(tWZTeamData[M28Map.subrefTScoutsTravelingHere])
        for iCurEntry = iTableSize, 1, -1 do
            if not(M28UnitInfo.IsUnitValid(tWZTeamData[M28Map.subrefTScoutsTravelingHere][iCurEntry])) then
                table.remove(tWZTeamData[M28Map.subrefTScoutsTravelingHere], iCurEntry)
            end
        end
    end

    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTScoutsTravelingHere]) then
        --Want a land scout for htis land zone, unless we already have one traveling here; if we have available land scouts then will change this flag back to false
        if not(tWZData[M28Map.subrefbPacifistArea]) then
            if not(M28Map.bIsCampaignMap) or M28Conditions.IsLocationInPlayableArea(tWZData[M28Map.subrefMidpoint]) then
                tWZTeamData[M28Map.refbWantLandScout] = true
                if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; We want to get a scout for this WZ '..(iWaterZone or 'nil')..' on pond '..(iPond or 'nil')) end
            end
        end
    elseif bDebugMessages == true then
        LOG(sFunctionRef..': We have scouts traveling to this WZ so wont flag it needs more scouts. Will list out traveling scouts')
        for iUnit, oUnit in tWZTeamData[M28Map.subrefTScoutsTravelingHere] do
            LOG(sFunctionRef..': iUnit='..iUnit..'; oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit)))
        end
    end

    --Do we have any land scouts that are available? if so then assign to an adjacent land zone if the adjacent zone wants scouts
    if M28Utilities.IsTableEmpty(tScouts) == false then
        local tAvailableScouts = {}
        local bCheckForEnemies = false
        local tEnemyUnitTablesToConsider = {}
        --Check for neemies if there are any in this or adjacent land zone
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
            --if tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 then
            table.insert(tEnemyUnitTablesToConsider, tWZTeamData[M28Map.subrefTEnemyUnits])
        end
        if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZOtherWaterZones]) == false then
            local iAdjWZ
            for _, tWZSubtable in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZOtherWaterZones] do
                iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                if bDebugMessages == true then LOG(sFunctionRef..': Checking if enemies in iAdjWZ='..iAdjWZ..'; enemy combat total='..M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal]) end
                if M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] > 0 then
                    table.insert(tEnemyUnitTablesToConsider, M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits])
                end
            end
        end
        if M28Utilities.IsTableEmpty(tEnemyUnitTablesToConsider) == false then bCheckForEnemies = true end

        local oEnemyToRunFrom
        local oPrevEnemyToRunFrom
        local iRunThreshold = 20 --If get this close to being in range of an enemy should try to run
        if bDebugMessages == true then LOG(sFunctionRef..': About to consider orders for scouts in this WZ, size of tScouts='..table.getn(tScouts)..'; bCheckForEnemies='..tostring(bCheckForEnemies)..'; Enemy combat total='..tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]) end
        local iCurDist
        for iScout, oScout in tScouts do
            if bCheckForEnemies then
                oEnemyToRunFrom = nil
                if oPrevEnemyToRunFrom and M28Utilities.GetDistanceBetweenPositions(oPrevEnemyToRunFrom[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) - (oPrevEnemyToRunFrom[M28UnitInfo.refiDFRange] or 0) <= iRunThreshold then
                    --Run from same enemy
                    oEnemyToRunFrom = oPrevEnemyToRunFrom
                else
                    for iUnitTable, tUnitTable in tEnemyUnitTablesToConsider do
                        for iUnit, oUnit in tUnitTable do
                            if bDebugMessages == true then LOG(sFunctionRef..': Looking for enemy to run from for scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..', considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Unit position='..repru(oUnit:GetPosition())..'; Unit last known position='..repru(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Dist between last known position and scout='..M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition())..'; Unit range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; iRunThreshold='..iRunThreshold..'; Is distance within run threshold='..tostring(M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0) <= iRunThreshold)..'; bConsiderAttacking='..tostring(bConsiderAttacking)..'; Unit df range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Unit build range='..(oUnit:GetBlueprint().Economy.MaxBuildDistance or 'nil')) end
                            if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and not(oUnit == oPrevEnemyToRunFrom) then
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0)
                                if iCurDist <= iRunThreshold then
                                    oEnemyToRunFrom = oUnit
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to run from unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so will stop searching') end
                                    break
                                elseif bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is too far away for us to run from it, will keep looking')
                                end
                                --Check if about to get in range of engineer that can reclaim us - have done +8 as lower values resulted in some cases in the engineer being able to reclaim the scout
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) <= 8 + (oUnit:GetBlueprint().Economy.MaxBuildDistance or 3) then
                                oEnemyToRunFrom = oUnit
                                break
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Do we have a valid enemy unit to run from='..tostring(M28UnitInfo.IsUnitValid(oEnemyToRunFrom))..'; ENemy ID if any='..(oEnemyToRunFrom.UnitId or 'nil')) end
            end
            if oEnemyToRunFrom then
                tWZTeamData[M28Map.refbWantLandScout] = false
                if bDebugMessages == true then LOG(sFunctionRef..': Want scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..' to run from oEnemyToRunFrom '..oEnemyToRunFrom.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToRunFrom)..' unless iti s a combat scout vs an engineer/mex in a low threat WZ in which case want it to attack the unit; WZ combat total='..tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Scout DF range='..(oScout[M28UnitInfo.refiDFRange] or 'nil')..'; Do we have a combat scout='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryCombatScout, oScout.UnitId))..'; Distance to nearest enemy='..M28Utilities.GetDistanceBetweenPositions(oEnemyToRunFrom:GetPosition(), oScout:GetPosition())) end
                oPrevEnemyToRunFrom = oEnemyToRunFrom
                local iPlateau = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oScout:GetPosition())
                M28Land.RunFromEnemy(oScout, oEnemyToRunFrom, iTeam, iPlateau, 16)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': No nearby enemy to run from, Considering if scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..' is available; refiWZToMoveTo='..repru(oScout[refiWZToMoveTo])) end
                if oScout[refiWZToMoveTo] then
                    --Make scout available if its target WZ is this WZ
                    if oScout[refiWZToMoveTo] == iWaterZone then
                        --Clear this unit from list of traveling units, but dont make it available as want a slight delay, so want it to be available on the next cycle
                        if bDebugMessages == true then LOG(sFunctionRef..': Scout is traveling to this land zone and is here so will clear the trackers so next cycle it is shown as available') end
                        RemoveUnitFromListOfUnitsTravelingToWaterZone(oScout)
                        tWZTeamData[M28Map.refbWantLandScout] = false
                    else
                        --Scout should be traveling to another land zone - if it has no orders then refresh them
                        local iTravelPond = M28Map.tiPondByWaterZone[oScout[refiWZToMoveTo]]
                        if bDebugMessages == true then LOG(sFunctionRef..': Scout should travel to another water zone so order it to travel there, iTravelPond='..(iTravelPond or 'nil')..'; oScout[refiWZToMoveTo]='..(oScout[refiWZToMoveTo] or 'nil')..'; oScout='..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..'; Midpoint of WZ to move to='..repru(M28Map.tPondDetails[iTravelPond][M28Map.subrefPondWaterZones][oScout[refiWZToMoveTo]][M28Map.subrefMidpoint])) end
                        M28Orders.IssueTrackedMove(oScout, M28Map.tPondDetails[iTravelPond][M28Map.subrefPondWaterZones][oScout[refiWZToMoveTo]][M28Map.subrefMidpoint], 16, false, 'TWZ'..oScout[refiWZToMoveTo])
                    end
                elseif oScout[M28Land.reftiPlateauAndLZToMoveTo] then
                    --Scout is going to a land zone not a water zone
                    if bDebugMessages == true then LOG(sFunctionRef..': Scout should travel to another land zone so order it to travel there') end
                    M28Orders.IssueTrackedMove(oScout, M28Map.tAllPlateaus[oScout[M28Land.reftiPlateauAndLZToMoveTo][1]][M28Map.subrefPlateauLandZones][oScout[M28Land.reftiPlateauAndLZToMoveTo][2]][M28Map.subrefMidpoint], 16, false, 'NTLZ'..oScout[M28Land.reftiPlateauAndLZToMoveTo][2])
                else
                    --Scout has no nearby enemies to run from, and isnt traveling to a water zone, so it should be available for use
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont want to run or attack with scout and it isnt already assigned to another LZ or WZ so will aadd to table of available scouts, oScout='..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)) end
                    table.insert(tAvailableScouts, oScout)
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Is available scout table empty='..tostring(M28Utilities.IsTableEmpty(tAvailableScouts))) end

        if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
            --First assign any available scouts to adjacent water zones wanting scouts
            if bDebugMessages == true then LOG(sFunctionRef..': Will first allocate scouts to any adjacent land zones that want a scout. Is table of adj zones empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]))) end
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                local iAdjWZ
                for _, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                    iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                    local tWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Consideri niAdjWZ='..iAdjWZ..'; Does this WZ want land scout='..tostring(tWZTeamData[M28Map.refbWantLandScout] or false)..'; Is table of traveling scouts here empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTScoutsTravelingHere]))) end
                    if tWZTeamData[M28Map.refbWantLandScout] then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will send land scout '..tAvailableScouts[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tAvailableScouts[1])..' to go to adjacent water zone '..iAdjWZ) end


                        GetUnitToTravelToWaterZone(tAvailableScouts[1], iPond, iAdjWZ, M28Map.subrefTScoutsTravelingHere)
                        tWZTeamData[M28Map.refbWantLandScout] = false
                        table.remove(tAvailableScouts, 1)
                        if M28Utilities.IsTableEmpty(tAvailableScouts) then break end
                    end
                end

            end
            if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
                tWZTeamData[M28Map.refbWantLandScout] = false
                --If we are here then we still have available land scouts; if we have ap atrol path then patrol; if we have a mex then go here, if we have an adjcent zone go here, otherwise move randomly if we have no orders
                for iScout, oScout in tAvailableScouts do
                    if M28Utilities.IsTableEmpty(tWZData[M28Map.subreftPatrolPath]) == false then
                        --Patrol the water zone
                        M28Orders.PatrolPath(oScout, tWZData[M28Map.subreftPatrolPath], false, 'NSP'..iWaterZone)
                    else
                        --Do nothing if scout is moving as maybe it landed on a segment just out of the zone it shoudl have been in
                        if not(oScout:IsUnitState('Moving')) then
                            M28Orders.UpdateRecordedOrders(oScout)
                            if (oScout[M28Orders.refiOrderCount] or 0) == 0 then
                                --Want ot get somewhere to move to as a backup
                                --Do we have an adjacent WZ? If so move here
                                if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                                    GetUnitToTravelToWaterZone(tAvailableScouts[1], iPond, tWZData[M28Map.subrefWZOtherWaterZones][1][M28Map.subrefWZAWZRef], M28Map.subrefTScoutsTravelingHere)
                                else
                                    --No adjacent WZs, and no mexes in this WZ, so just move randomly
                                    M28Orders.IssueTrackedMove(oScout, M28Utilities.MoveInDirection(oScout:GetPosition(), math.random(1, 360), math.random(10, 30), true, false, true), 10, false, 'NBackupRnd')
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetWaterZoneToRunTo(iTeam, iPond, iCurWaterZone, sPathing, tOptionalStartPosition, tOptionalEnemyPositionToRunFrom)
    --Returns cur WZ if no WZ to run to, otherwise returns the land zone we think is best to run to from iCurLandZone
    --tOptionalStartPosition - if nil then will use midpoint of iCurLandZone
    --tOptionalEnemyPositionToRunFrom - if this is specified, then will pick al ocation based on angle from the start position to the location vs the start position angle to the enemy position to run to (so we run in the opposite direction to the enemy position if the opposite direction WZ is safe)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetWaterZoneToRunTo'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': iTeam='..iTeam..'; iPond='..iPond..'; iCurWaterZone='..iCurWaterZone..'; sPathing='..sPathing..'; tOptionalStartPosition='..repru(tOptionalStartPosition)..'; tOptionalEnemyPositionToRunFrom='..repru(tOptionalEnemyPositionToRunFrom)) end

    local tWZShortlist = {}
    local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iCurWaterZone]
    --See if there are any adjacent water zones without enemy units
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
        for iEntry, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
            if M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] == 0 then
                table.insert(tWZShortlist, iAdjWZ)
            end
        end
    end
    if M28Utilities.IsTableEmpty(tWZShortlist) then
        --Nowhere to run to
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return iCurWaterZone
    else
        local tStartPoint = (tOptionalStartPosition or tWZData[M28Map.subrefMidpoint])
        local iPreferredWZRef
        if tOptionalEnemyPositionToRunFrom then
            --Go to the angle furthest in angle away from the nearest enemy
            local iAngleToEnemy = M28Utilities.GetAngleFromAToB(tStartPoint, tOptionalEnemyPositionToRunFrom)
            local iCurAngleDif
            local iHighestAngleDif = 0
            for _, iPossibleWZ in tWZShortlist do
                iCurAngleDif = M28Utilities.GetAngleDifference(iAngleToEnemy, M28Utilities.GetAngleFromAToB(tStartPoint, M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iPossibleWZ][M28Map.subrefMidpoint]))
                if iCurAngleDif > iHighestAngleDif then
                    iHighestAngleDif = iCurAngleDif
                    iPreferredWZRef = iPossibleWZ
                end
            end
        else
            --dont have angle to nearest enemy so just pick the closest land zone

            local iClosestWZDistance = 100000
            local iCurDist
            for _, iPossibleWZ in tWZShortlist do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering distance from tStartPoint to iPossibleWZ '..(iPossibleWZ or 'nil')..'; Midpoint of that WZ='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleWZ][M28Map.subrefMidpoint])..'; iCurDist='..(M28Utilities.GetTravelDistanceBetweenPositions(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleWZ][M28Map.subrefMidpoint], sPathing) or 'nil')) end
                iCurDist = M28Utilities.GetTravelDistanceBetweenPositions(tStartPoint, M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iPossibleWZ][M28Map.subrefMidpoint], sPathing)
                --Backup - if the built in pathfinding doesnt htink we can path there (e.g. we are by a cliff) then use straight line distance
                if not(iCurDist) then iCurDist = M28Utilities.GetDistanceBetweenPositions(tStartPoint, M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iPossibleWZ][M28Map.subrefMidpoint]) + 30 end

                if iCurDist < iClosestWZDistance then
                    iClosestWZDistance = iCurDist
                    iPreferredWZRef = iPossibleWZ
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return (iPreferredWZRef or iCurWaterZone)
    end

end

function UpdateSonarCoverageForDestroyedSonar(oSonar)
    --Only track for water zones
    if M28Utilities.IsTableEmpty(oSonar[reftiSonarWaterZonesCoveredByTeam]) == false then
        for iTeam, tSonarData in oSonar[reftiSonarWaterZonesCoveredByTeam] do
            --local aiBrain = oSonar:GetAIBrain()
            --local iTeam = aiBrain.M28Team
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            if aiBrain then
                local iPond
                for iEntry, iWaterZone in tSonarData do
                    iPond = M28Map.tiPondByWaterZone[iWaterZone]
                    local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
                    local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                    if tWZTeamData[M28Map.refoBestSonar] == oSonar then
                        tWZTeamData[M28Map.refoBestSonar] = nil
                        tWZTeamData[M28Map.refiSonarCoverage] = 0
                        local tNearbySonar = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategorySonar, tWZData[M28Map.subrefMidpoint], 600, 'Ally')
                        local iCurIntelRange
                        local iBestIntelRange = 0
                        local oBestSonar
                        local iCurDist
                        local oBP
                        if M28Utilities.IsTableEmpty(tNearbySonar) == false then
                            for iUnit, oUnit in tNearbySonar do
                                oBP = oUnit:GetBlueprint()
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tWZData[M28Map.subrefMidpoint])
                                iCurIntelRange = (oBP.Intel.SonarRadius or 0) - iCurDist
                                if iCurIntelRange > iBestIntelRange then
                                    iBestIntelRange = iCurIntelRange
                                    oBestSonar = oUnit
                                end
                            end
                        end
                        if oBestSonar then
                            tWZTeamData[M28Map.refoBestSonar] = oBestSonar
                            tWZTeamData[M28Map.refiSonarCoverage] = iBestIntelRange
                            if not(oBestSonar[reftiSonarWaterZonesCoveredByTeam]) then oBestSonar[reftiSonarWaterZonesCoveredByTeam] = {} end
                            if not(oBestSonar[reftiSonarWaterZonesCoveredByTeam][iTeam]) then oBestSonar[reftiSonarWaterZonesCoveredByTeam][iTeam] = {} end
                            table.insert(oBestSonar[reftiSonarWaterZonesCoveredByTeam][iTeam], iWaterZone)
                        end
                    end
                end
            end
        end
    end
end

function UpdateZoneIntelForSonar(oSonar)
    --If just built Sonar then want to update all land zones for the team to indicate the intel coverage
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateZoneIntelForSonar'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iTeam = oSonar:GetAIBrain().M28Team
    if bDebugMessages == true then LOG(sFunctionRef..': Just built Sonar '..oSonar.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSonar)..' owned by '..oSonar:GetAIBrain().Nickname..' with M28Team '..iTeam..'; is the table of active m28 brains for this team empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        if not(oSonar['M28UpdatedIntel']) then
            oSonar['M28UpdatedIntel'] = true
            local oBP = oSonar:GetBlueprint()
            local iIntelRange = (oBP.Intel.SonarRadius or 0)
            local iCurIntelRange
            if bDebugMessages == true then LOG(sFunctionRef..': Sonar intel range='..iIntelRange) end
            if iIntelRange > 0 then
                --Update water zones
                for iPond, tPondSubtable in M28Map.tPondDetails do
                    if M28Utilities.IsTableEmpty(tPondSubtable[M28Map.subrefPondWaterZones]) == false then
                        for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do

                            local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering ater zone '..iWaterZone..' with sonar coverage='..tWZTeamData[M28Map.refiSonarCoverage]..'; iIntelRange='..iIntelRange) end
                            if tWZTeamData[M28Map.refiSonarCoverage] < iIntelRange then
                                iCurIntelRange = iIntelRange - M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oSonar:GetPosition())
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering iPond '..iPond..' Water zone '..iWaterZone..'; iCurIntelRange factoring in distance='..iCurIntelRange..'; Distance='..M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oSonar:GetPosition())..'; WZ current Sonar coverage='..tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiSonarCoverage]) end
                                if iCurIntelRange > tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiSonarCoverage] then
                                    --First remove this WZ from the existing (worse) Sonar if there was one
                                    if M28UnitInfo.IsUnitValid(tWZTeamData[M28Map.refoBestSonar]) then
                                        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.refoBestSonar][reftiSonarWaterZonesCoveredByTeam][iTeam]) == false then
                                            for iEntry, iRecordedWaterZone in tWZTeamData[M28Map.refoBestSonar][reftiSonarWaterZonesCoveredByTeam][iTeam] do
                                                if iRecordedWaterZone == iWaterZone then
                                                    table.remove(tWZTeamData[M28Map.refoBestSonar][reftiSonarWaterZonesCoveredByTeam][iTeam], iEntry)
                                                    break
                                                end
                                            end
                                        end
                                    end
                                    --Now assign this WZ to this Sonar as providing the best coverage
                                    tWZTeamData[M28Map.refiSonarCoverage] = iCurIntelRange
                                    tWZTeamData[M28Map.refoBestSonar] = oSonar
                                    if not(oSonar[reftiSonarWaterZonesCoveredByTeam]) then oSonar[reftiSonarWaterZonesCoveredByTeam] = {} end
                                    if not(oSonar[reftiSonarWaterZonesCoveredByTeam][iTeam]) then oSonar[reftiSonarWaterZonesCoveredByTeam][iTeam] = {} end
                                    table.insert(oSonar[reftiSonarWaterZonesCoveredByTeam][iTeam], iWaterZone)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished udpating for the new intel range, iWaterZone='..iWaterZone..'; tWZTeamData[M28Map.refiSonarCoverage]='..tWZTeamData[M28Map.refiSonarCoverage]) end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function DelayedCheckIfShouldSubmerge(oJustBuilt)
    --Call via fork thread just after unit is built
    WaitSeconds(3)
    if M28UnitInfo.IsUnitValid(oJustBuilt) then
        local bWantToBeUnderwater
        if EntityCategoryContains(M28UnitInfo.refCategorySeraphimDestroyer, oJustBuilt.UnitId) then
            bWantToBeUnderwater = false
        else
            bWantToBeUnderwater = true
        end
        if not(M28UnitInfo.IsUnitUnderwater(oJustBuilt) == bWantToBeUnderwater) then
            M28UnitInfo.ToggleUnitDiveOrSurfaceStatus(oJustBuilt)
        end
    end
end

function GetMinDFDistanceForShotFromWaterToHitUnit(aiBrain, tWZMidpoint, iPond, oTarget, iMaxDist)
    local iBestDist = 10000
    local iBaseAngle = M28Utilities.GetAngleFromAToB(oTarget:GetPosition(), tWZMidpoint)
    local tShotEndPosition = oTarget:GetPosition()
    local iTargetWZ
    tShotEndPosition[2] = tShotEndPosition[2] + math.max(0, ((oTarget:GetBlueprint().SizeY or 0.5) - 0.5 * 0.7))

    for iAngleAdjust = 0, 270, 90 do
        for iDFDistAdjust = 12, math.max(12, math.floor((iMaxDist / 6) * 6)), 6 do
            local tPossibleWaterPosition = M28Utilities.MoveInDirection(oTarget:GetPosition(), iBaseAngle + iAngleAdjust, iDFDistAdjust, true, true, false)
            if tPossibleWaterPosition and NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tPossibleWaterPosition) == iPond then
                local tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                iTargetWZ = M28Map.GetWaterZoneFromPosition(tShotStartPosition)
                if M28Map.tiPondByWaterZone[iTargetWZ] == iPond then
                    if not(M28Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, 1)) then
                        iBestDist = iDFDistAdjust
                        break
                    end
                end
            end
        end
        if iBestDist <= iMaxDist then break end
    end
    if iBestDist > iMaxDist then iTargetWZ = nil end

    return iBestDist, iTargetWZ
end

function GetDFShotBlockedLocationForBuildingAndPond(oUnit, iPond)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetDFShotBlockedLocationForBuildingAndPond'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(oUnit[reftBlockedShotLocationByPond][iPond]) then
        if not(oUnit[reftBlockedShotLocationByPond]) then oUnit[reftBlockedShotLocationByPond] = {} end
        local oDummyBrain = oUnit:GetAIBrain() --in case want to try the brain terrain blocking function later
        local tBasePosition = oUnit:GetPosition()
        local iAngleInterval = 360 / 24
        local tShotEndPosition = {tBasePosition[1], tBasePosition[2] + math.max(0, ((oUnit:GetBlueprint().SizeY or 0.5) - 0.5 * 0.7)), tBasePosition[3]}
        if bDebugMessages == true then LOG(sFunctionRef..': Looking for non shot blocked location for oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at position '..repru(oUnit:GetPosition())) end
        local bHaveMatch = false
        for iDFDist = 5, 150, 5 do
            for iCurAngle = iAngleInterval, 360, iAngleInterval do
                local tPossibleWaterPosition = M28Utilities.MoveInDirection(tBasePosition, iCurAngle, iDFDist, true, true, false)
                if bDebugMessages == true then
                    LOG(sFunctionRef..': iDFDist='..iDFDist..'; iCurAngle='..iCurAngle..'; tPossibleWaterPosition='..repru(tPossibleWaterPosition))
                    if tPossibleWaterPosition then LOG(sFunctionRef..': Terrain label for tPossibleWaterPosition='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tPossibleWaterPosition) or 'nil')..'; iPond='..iPond) end
                end
                if tPossibleWaterPosition and NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tPossibleWaterPosition) == iPond then
                    local tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                    if bDebugMessages == true then LOG(sFunctionRef..': Is line blocked='..tostring(M28Logic.IsLineBlocked(oDummyBrain, tShotStartPosition, tShotEndPosition, 1))..'; tShotStartPosition='..repru(tShotStartPosition)) end
                    if not(M28Logic.IsLineBlocked(oDummyBrain, tShotStartPosition, tShotEndPosition, 1)) then
                        oUnit[reftBlockedShotLocationByPond][iPond] = {tPossibleWaterPosition[1], tPossibleWaterPosition[2], tPossibleWaterPosition[3]}
                        bHaveMatch = true
                        break
                    end
                end
            end
            if bHaveMatch then break end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oUnit[reftBlockedShotLocationByPond][iPond]
end

function RefreshRaidingNavalLocations(iFactoryWaterZone, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshRaidingNavalLocations'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Find the land zone nearest to us with mexes that we think we can hit
    local iLandZoneToTarget
    local iPlateauToTarget
    local iStartPond = M28Map.tiPondByWaterZone[iFactoryWaterZone]
    local tStartWZData = M28Map.tPondDetails[iStartPond][M28Map.subrefPondWaterZones][iFactoryWaterZone]
    local tStartWZTeamData = tStartWZData[M28Map.subrefWZTeamData][iTeam]
    local iRangeWanted, iWZForShot, iAltMinRangeRequired, iSecondAltMinRangeRequired, iSecondWZForShot
    tStartWZTeamData[M28Map.refoLastRaidTarget] = nil
    if bDebugMessages == true then LOG(sFunctionRef..': Near start, iStartPond='..iStartPond..'; iFactoryWaterZone='..iFactoryWaterZone..'; iTeam='..iTeam..'; time since last had bombardment mode='..(M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBombardmentModeByPond][iStartPond] or 'nil')..'; Time='..GetGameTimeSeconds()) end
    local iAltWZForBombardment
    if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBombardmentModeByPond][iStartPond] or -100) >= 30 then --dont try raiding if we have been in bombardment mode recently
        local tbPlateauAndLandZonesConsidered = {}
        local tAcceptableRangesByTech = {[0]=26,[1]=26,[2]=60,[3]=110, [4]=110}
        local tiMaxThreatByTech = {[0]=300,[1]=300,[2]=1000,[3]=2000,[4]=2000}
        local tiMinStructureValueWanted = {[0]=300,[1]=300,[2]=500,[3]=1000,[4]=1000} --if no mexes then will still attack if have this much S value
        local iStructureValueWanted = tiMinStructureValueWanted[(tStartWZTeamData[M28Map.refiRaidTechLevel] or 0)]
        local iHighestAcceptableRange = tAcceptableRangesByTech[(tStartWZTeamData[M28Map.refiRaidTechLevel] or 0)]
        local iMaxNavalThreat = tiMaxThreatByTech[(tStartWZTeamData[M28Map.refiRaidTechLevel] or 0)]
        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
        function GetAdjacentZoneToTarget(iWaterZone)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering land zones adjacent to iWaterZone '..iWaterZone..'; Pond for this zone='..M28Map.tiPondByWaterZone[iWaterZone]..'; iStartPond='..iStartPond) end
            if M28Map.tiPondByWaterZone[iWaterZone] == iStartPond then
                local tCurWZData = M28Map.tPondDetails[iStartPond][M28Map.subrefPondWaterZones][iWaterZone]
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of adjacent land zones empty='..tostring(M28Utilities.IsTableEmpty(tCurWZData[M28Map.subrefAdjacentLandZones]))) end
                if M28Utilities.IsTableEmpty(tCurWZData[M28Map.subrefAdjacentLandZones]) == false then
                    local tCurWZTeamData = tCurWZData[M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy combat total in this WZ='..(tCurWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)..'; iMaxNavalThreat='..iMaxNavalThreat) end
                    if (tCurWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) <= iMaxNavalThreat then
                        for iAdjEntry, tAdjSubtable in tCurWZData[M28Map.subrefAdjacentLandZones] do
                            local iCurPlateau = tAdjSubtable[M28Map.subrefWPlatAndLZNumber][1]
                            local iCurLandZone = tAdjSubtable[M28Map.subrefWPlatAndLZNumber][2]
                            if not(tbPlateauAndLandZonesConsidered[iCurPlateau][iCurLandZone]) then
                                if not(tbPlateauAndLandZonesConsidered[iCurPlateau]) then tbPlateauAndLandZonesConsidered[iCurPlateau] = {} end
                                tbPlateauAndLandZonesConsidered[iCurPlateau][iCurLandZone] = true
                                local tCurLZData = M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLandZone]
                                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tCurLZData[M28Map.subrefMidpoint]) then
                                    local tCurLZTeamData = tCurLZData[M28Map.subrefLZTeamData][iTeam]
                                    local iZoneEnemyStructureMassValue = 0
                                    local tZoneStructures
                                    if M28Utilities.IsTableEmpty(tCurLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                                        tZoneStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tCurLZTeamData[M28Map.subrefTEnemyUnits])
                                        if M28Utilities.IsTableEmpty(tZoneStructures) == false then
                                            iZoneEnemyStructureMassValue = M28UnitInfo.GetMassCostOfUnits(tZoneStructures)
                                            local tMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tZoneStructures)
                                            if M28Utilities.IsTableEmpty(tMexes) == false then
                                                iZoneEnemyStructureMassValue = iZoneEnemyStructureMassValue + 300 * table.getn(tMexes)
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to target plateau '..iCurPlateau..'; LZ'..iCurLandZone..'; Friendly LZ S value='..(tCurLZTeamData[M28Map.subrefLZSValue] or 0)..'; Is table of mex locations empty='..tostring(M28Utilities.IsTableEmpty(tCurLZData[M28Map.subrefLZMexLocations]))..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tCurLZTeamData[M28Map.subrefTEnemyUnits]))..'; iZoneEnemyStructureMassValue='..iZoneEnemyStructureMassValue..'; iStructureValueWanted='..iStructureValueWanted) end
                                    if iZoneEnemyStructureMassValue >= 10 and iStructureValueWanted then
                                        --Check enemy has mexes or high S value
                                        if iZoneEnemyStructureMassValue >= iStructureValueWanted or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryPD, tCurLZTeamData[M28Map.subrefTEnemyUnits])) == false then
                                            --Check the enemy range isn't too much
                                            local iShortestRangeRequired = math.max((tCurLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0), (tCurLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0), (tCurLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0))
                                            if bDebugMessages == true then LOG(sFunctionRef..': iShortestRangeRequired='..iShortestRangeRequired..'; Best mobile DF range='..tCurLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]..'; Best indirect='..tCurLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange]..'; Best structureDF='..tCurLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange]..'; iHighestAcceptableRange='..iHighestAcceptableRange) end
                                            if iShortestRangeRequired <= iHighestAcceptableRange then
                                                --Determine the water zone path to get here, and the enemy water threat along that path
                                                local tWZPath = GetWaterZonePathToWaterOrAdjacentLandZone(iFactoryWaterZone, iCurPlateau, iCurLandZone)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Is  tWZPath empty='..tostring(M28Utilities.IsTableEmpty(tWZPath))) end
                                                if M28Utilities.IsTableEmpty(tWZPath) == false then
                                                    local iEnemyThreat = (tCurWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                                                    local bPathInPlayableArea = true
                                                    for iEntry, iPathZone in tWZPath do
                                                        local tWZPathData = M28Map.tPondDetails[iStartPond][M28Map.subrefPondWaterZones][iPathZone]
                                                        local tWZPathTeamData = tWZPathData[M28Map.subrefWZTeamData][iTeam]
                                                        iEnemyThreat = iEnemyThreat + (tWZPathTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                                                        if iEnemyThreat > iMaxNavalThreat then break end
                                                        if not(bDontCheckPlayableArea) and not(M28Conditions.IsLocationInPlayableArea(tWZPathData[M28Map.subrefMidpoint])) then
                                                            bPathInPlayableArea = false
                                                            break
                                                        end
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..'; iEnemyThreat='..iEnemyThreat..'; iMaxNavalThreat='..iMaxNavalThreat) end
                                                    if iEnemyThreat <= iMaxNavalThreat and bPathInPlayableArea then
                                                        --No significant water threat, consider the closest enemy building to the last water zone path entry, and the max range required to attack.  To keep things simple, for now will only consider the closest unit and if shot is blocked for it (rather than every unit)
                                                        local tEnemyStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tCurLZTeamData[M28Map.subrefTEnemyUnits])
                                                        if M28Conditions.IsTableOfUnitsStillValid(tEnemyStructures) then
                                                            --Want both the closest and furthest unti since on some islands units might be at the rear of the island so furthest from our water zone, yet close to water, hence still worth considering as a target
                                                            local oClosestEnemyStructure -- = M28Utilities.GetNearestUnit(tEnemyStructures, tCurWZData[M28Map.subrefMidpoint])
                                                            local oFurthestEnemyStructure, iCurDist
                                                            local iClosestDist = 10000
                                                            local iFurthestDist = 0
                                                            for iUnit, oUnit in tEnemyStructures do
                                                                iCurDist = M28Utilities.GetDistanceBetweenPositions(tCurWZData[M28Map.subrefMidpoint], oUnit:GetPosition())
                                                                if iCurDist < iClosestDist then
                                                                    oClosestEnemyStructure = oUnit
                                                                    iClosestDist = iCurDist
                                                                end
                                                                if iCurDist > iFurthestDist then
                                                                    iFurthestDist = iCurDist
                                                                    oFurthestEnemyStructure = oUnit
                                                                end
                                                            end
                                                            if M28UnitInfo.IsUnitValid(oClosestEnemyStructure) and (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(oClosestEnemyStructure:GetPosition())) then
                                                                iWZForShot = nil
                                                                if oClosestEnemyStructure == oFurthestEnemyStructure then
                                                                    iAltMinRangeRequired, iWZForShot = GetMinDFDistanceForShotFromWaterToHitUnit(aiBrain, tCurWZData[M28Map.subrefMidpoint], iStartPond, oClosestEnemyStructure, iHighestAcceptableRange)
                                                                    iShortestRangeRequired = math.max(iShortestRangeRequired, iAltMinRangeRequired)
                                                                else
                                                                    iAltMinRangeRequired, iWZForShot = GetMinDFDistanceForShotFromWaterToHitUnit(aiBrain, tCurWZData[M28Map.subrefMidpoint], iStartPond, oClosestEnemyStructure, iHighestAcceptableRange)
                                                                    iSecondAltMinRangeRequired, iSecondWZForShot = GetMinDFDistanceForShotFromWaterToHitUnit(aiBrain, tCurWZData[M28Map.subrefMidpoint], iStartPond, oFurthestEnemyStructure, iHighestAcceptableRange)
                                                                    if iWZForShot == iSecondWZForShot then
                                                                        --Want the lowest range of the two options
                                                                        iShortestRangeRequired = math.max(iShortestRangeRequired, math.min(iAltMinRangeRequired, iSecondAltMinRangeRequired))
                                                                    elseif (iAltMinRangeRequired <= 150 and iSecondAltMinRangeRequired > 150) then
                                                                        --Want the first choice
                                                                        iShortestRangeRequired = math.max(iShortestRangeRequired, iAltMinRangeRequired)
                                                                    elseif (iSecondAltMinRangeRequired <= 150 and iAltMinRangeRequired > 150) then
                                                                        iWZForShot = iSecondWZForShot
                                                                        iShortestRangeRequired = math.max(iShortestRangeRequired, iSecondAltMinRangeRequired)
                                                                    end
                                                                end
                                                                if bDebugMessages == true then LOG(sFunctionRef..': oClosestEnemyStructure='..oClosestEnemyStructure.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyStructure)..'; iShortestRangeRequired='..iShortestRangeRequired..'; iHighestAcceptableRange='..iHighestAcceptableRange..'; oFurthestEnemyStructure='..oFurthestEnemyStructure.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFurthestEnemyStructure)) end
                                                                if iShortestRangeRequired <= iHighestAcceptableRange then
                                                                    tStartWZTeamData[M28Map.refoLastRaidTarget] = oClosestEnemyStructure
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Have a valid target for raiding, iWZForShot='..iWZForShot) end
                                                                    return iCurPlateau, iCurLandZone, iShortestRangeRequired, iWZForShot
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        iPlateauToTarget, iLandZoneToTarget, iRangeWanted, iAltWZForBombardment = GetAdjacentZoneToTarget(iFactoryWaterZone)
        if not(iLandZoneToTarget) then
            if M28Utilities.IsTableEmpty(tStartWZData[M28Map.subrefWZOtherWaterZones]) == false then
                for iEntry, tSubtable in tStartWZData[M28Map.subrefWZOtherWaterZones] do
                    iPlateauToTarget, iLandZoneToTarget, iRangeWanted, iAltWZForBombardment = GetAdjacentZoneToTarget(tSubtable[M28Map.subrefWZAWZRef])
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering land zones adjacent to WZ '..tSubtable[M28Map.subrefWZAWZRef]..'; iLandZoneToTarget='..(iLandZoneToTarget or 'nil')..'; iPlateauToTarget='..(iPlateauToTarget or 'nil')) end
                    if iLandZoneToTarget then break end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iPlateauToTarget='..(iPlateauToTarget or 'nil')..'; iLandZoneToTarget='..(iLandZoneToTarget or 'nil')..'; iAltWZForBombardment='..(iAltWZForBombardment or 'nil')..'; ') end
    if iPlateauToTarget then
        tStartWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone] = {iPlateauToTarget, iLandZoneToTarget}
        tStartWZTeamData[M28Map.refiMinRangeRaidingZone] = iRangeWanted
        tStartWZTeamData[M28Map.refiRaidWZForBombardment] = iAltWZForBombardment
    else
        tStartWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone] = nil
        tStartWZTeamData[M28Map.refiMinRangeRaidingZone] = nil
        tStartWZTeamData[M28Map.refiRaidWZForBombardment] = nil
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetWaterZonePathToWaterOrAdjacentLandZone(iStartWaterZone, iTargetPlateauOrZero, iTargetLandOrWaterZone)
    --Returns the water zones to travel across (excluding iStartWaterZone) to get from iStartWaterZone to either hte target water zone, or (if it's a land zone) the closest water zone adjacent to the target land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetWaterZonePathToWaterOrAdjacentLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iStartPond = M28Map.tiPondByWaterZone[iStartWaterZone]
    local tStartWZData = M28Map.tPondDetails[iStartPond][M28Map.subrefPondWaterZones][iStartWaterZone]
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iStartWaterZone='..iStartWaterZone..'; iTargetPlateauOrZero='..iTargetPlateauOrZero..'; iTargetLandOrWaterZone='..iTargetLandOrWaterZone..'; Is pathing table empty='..tostring(M28Utilities.IsTableEmpty(tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone][iTargetPlateauOrZero][iTargetLandOrWaterZone]))) end
    if not(tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone][iTargetPlateauOrZero][iTargetLandOrWaterZone]) then
        if not(tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone][iTargetPlateauOrZero]) then
            if not(tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone]) then tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone] = {} end
            tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone][iTargetPlateauOrZero] = {}
        end
        tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone][iTargetPlateauOrZero][iTargetLandOrWaterZone] = {}
        local bValidLocation = false
        local iTargetWaterZone --if targetin land zone, this is the closest water zone in the same pond
        --Is the target in the same pond, or adjacent to a zone in the same pond?
        if iTargetPlateauOrZero == 0 then
            if M28Map.tiPondByWaterZone[iTargetLandOrWaterZone] == iStartPond then
                bValidLocation = true
                iTargetWaterZone = iTargetLandOrWaterZone
            end
        else
            --Dealing with a land zone, check for adjacent water zones
            local tTargetLZData = M28Map.tAllPlateaus[iTargetPlateauOrZero][M28Map.subrefPlateauLandZones][iTargetLandOrWaterZone]
            if M28Utilities.IsTableEmpty(tTargetLZData[M28Map.subrefAdjacentWaterZones]) == false then
                local iClosestAdjWZDist = 10000
                local iCurDist
                for iEntry, tSubtable in tTargetLZData[M28Map.subrefAdjacentWaterZones] do
                    if M28Map.tiPondByWaterZone[tSubtable[M28Map.subrefAWZRef]] == iStartPond then
                        iCurDist = tSubtable[M28Map.subrefAWZDistance]
                        if iCurDist < iClosestAdjWZDist then
                            iClosestAdjWZDist = iCurDist
                            iTargetWaterZone = tSubtable[M28Map.subrefAWZRef]
                            bValidLocation = true
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bValidLocation='..tostring(bValidLocation or false)..'; iTargetWaterZone='..(iTargetWaterZone or 'nil')) end
        if bValidLocation and iTargetWaterZone then
            local tTargetWZData = M28Map.tPondDetails[iStartPond][M28Map.subrefPondWaterZones][iTargetWaterZone]
            local tFullPath, iPathSize, iDistance = NavUtils.PathTo(M28Map.refPathingTypeNavy, tStartWZData[M28Map.subrefMidpoint], tTargetWZData[M28Map.subrefMidpoint], nil)
            local tbZoneConsidered = {[iStartWaterZone] = true, [iTargetWaterZone] = true}
            local iCurWZ
            if M28Utilities.IsTableEmpty(tFullPath) == false then
                for iEntry, tPosition in tFullPath do
                    iCurWZ = M28Map.GetWaterZoneFromPosition(tPosition)
                    if not(tbZoneConsidered[iCurWZ]) then
                        tbZoneConsidered[iCurWZ] = true
                        table.insert(tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone][iTargetPlateauOrZero][iTargetLandOrWaterZone], iCurWZ)
                    end
                end
            end
            table.insert(tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone][iTargetPlateauOrZero][iTargetLandOrWaterZone], iTargetWaterZone)
            if bDebugMessages == true then LOG(sFunctionRef..': Finished recording path for iTargetLandOrWaterZone='..iTargetLandOrWaterZone..'; Path='..repru(tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone][iTargetPlateauOrZero][iTargetLandOrWaterZone])) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone][iTargetPlateauOrZero][iTargetLandOrWaterZone]
end

function CheckWaterZoneForRaiders(iWaterZone, tWZTeamData, iFactoryWaterZone, tFactoryWZTeamData, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckWaterZoneForRaiders'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        local tPotentialRaiders = EntityCategoryFilterDown(M28UnitInfo.refCategoryBombardment, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of potentail raiders empty='..tostring(M28Utilities.IsTableEmpty(tPotentialRaiders))..' for iWaterZone='..iWaterZone) end
        if M28Conditions.IsTableOfUnitsStillValid(tPotentialRaiders) then
            for iRaider, oRaider in tPotentialRaiders do
                if oRaider[refiWZOfFactory] == iFactoryWaterZone and not(oRaider[refbActiveRaider]) and oRaider[M28UnitInfo.refiCombatRange] >= tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone] then
                    AddUnitToRaiders(oRaider, iFactoryWaterZone, iTeam, tFactoryWZTeamData)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageWaterZoneRaiders(iFactoryWaterZone, iTeam, tFactoryWZData, tFactoryWZTeamData)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageWaterZoneRaiders'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(tFactoryWZTeamData[M28Map.refbActiveRaiderLogic]) then
        tFactoryWZTeamData[M28Map.refbActiveRaiderLogic] = true
        local iPrevRangeWanted = 10000 --tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone]
        local iPrevRaidTargetPlateau --= tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][1]
        local iPrevRaidTargetZone --= tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][2]
        local tWZRaidingPath
        local iPond = M28Map.tiPondByWaterZone[iFactoryWaterZone]

        while M28Conditions.IsTableOfUnitsStillValid(tFactoryWZTeamData[M28Map.reftoWZRaiders]) do
            --First check we have a valid location to raid, and all our raiders have sufficient range:
            if bDebugMessages == true then LOG(sFunctionRef..': Start of loop for iFactoryWaterZone '..iFactoryWaterZone..', closest plateau and land zone for raiding='..repru(tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone])..'; Are there enemis in wz adjacent to factory='..tostring(tFactoryWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ])..'; Time='..GetGameTimeSeconds()..'; Is raid target valid='..tostring(M28UnitInfo.IsUnitValid(tFactoryWZTeamData[M28Map.refoLastRaidTarget]))..'; Raid target='..(tFactoryWZTeamData[M28Map.refoLastRaidTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tFactoryWZTeamData[M28Map.refoLastRaidTarget]) or 'nil')..' Range wanted='..(tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone] or 'nil')..'; refiRaidWZForBombardment='..(tFactoryWZTeamData[M28Map.refiRaidWZForBombardment] or 'nil')) end

            if tFactoryWZTeamData[M28Map.refoLastRaidTarget] and not(M28UnitInfo.IsUnitValid(tFactoryWZTeamData[M28Map.refoLastRaidTarget])) then
                tFactoryWZTeamData[M28Map.refoLastRaidTarget] = nil
                RefreshRaidingNavalLocations(iFactoryWaterZone, iTeam)
                if bDebugMessages == true then LOG(sFunctionRef..': Finished refreshing naval locations') end
            elseif not(tFactoryWZTeamData[M28Map.refiRaidWZForBombardment]) then
                RefreshRaidingNavalLocations(iFactoryWaterZone, iTeam)
            end

            if M28Utilities.IsTableEmpty(tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone]) or tFactoryWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] then
                --Clear raiders
                local tRaiderTable = tFactoryWZTeamData[M28Map.reftoWZRaiders]
                for iCurRaider = table.getn(tFactoryWZTeamData[M28Map.reftoWZRaiders]), 1, -1 do
                    if bDebugMessages == true then LOG(sFunctionRef..'; Removing unit '..(tFactoryWZTeamData[M28Map.reftoWZRaiders][iCurRaider].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tFactoryWZTeamData[M28Map.reftoWZRaiders][iCurRaider]) or 'nil')..' from table of active raiders') end
                    RemoveUnitFromRaiders(tFactoryWZTeamData[M28Map.reftoWZRaiders], iCurRaider)
                end
                tFactoryWZTeamData[M28Map.reftoWZRaiders] = { }
                if bDebugMessages == true then LOG(sFunctionRef..': Cleared table of raiders') end
                break
            elseif tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone] > iPrevRangeWanted then
                --Remove any units with too little range
                for iCurRaider = table.getn(tFactoryWZTeamData[M28Map.reftoWZRaiders]), 1, -1 do
                    if tFactoryWZTeamData[M28Map.reftoWZRaiders][iCurRaider][M28UnitInfo.refiCombatRange] < tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone] then
                        RemoveUnitFromRaiders(tFactoryWZTeamData[M28Map.reftoWZRaiders], iCurRaider)
                    end
                end
                if M28Utilities.IsTableEmpty(tFactoryWZTeamData[M28Map.reftoWZRaiders]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Revmoed raiders with insufficient range, tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone]='..tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone]..'; now have no raiders that are suiable') end
                    break
                end
            elseif (tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone] or 10000) < iPrevRangeWanted then
                --Consider adding units from around the factory that used to be raiders if they now have sufficient range
                if bDebugMessages == true then LOG(sFunctionRef..': Will search around original water zone '..(iFactoryWaterZone or 'nil')..' for raiders with a range of at least '..(tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone] or 'nil')) end
                CheckWaterZoneForRaiders(iFactoryWaterZone, tFactoryWZTeamData, iFactoryWaterZone, tFactoryWZTeamData, iTeam)
                if M28Utilities.IsTableEmpty(tFactoryWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                    for iEntry, iAdjWZ in tFactoryWZData[M28Map.subrefWZAdjacentWaterZones] do
                        local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                        CheckWaterZoneForRaiders(iAdjWZ, tAdjWZTeamData, iFactoryWaterZone, tFactoryWZTeamData, iTeam)
                    end
                end
            end

            --Update the raiding path from the orig naval factory to the target
            if not(iPrevRaidTargetZone == tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][2]) or not(iPrevRaidTargetPlateau == tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][1]) then
                tWZRaidingPath = nil
                iPrevRaidTargetPlateau = tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][1]
                iPrevRaidTargetZone = tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][2]
            end
            iPrevRangeWanted = tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone]
            if not(tWZRaidingPath) then
                tWZRaidingPath = GetWaterZonePathToWaterOrAdjacentLandZone(iFactoryWaterZone, tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][1], tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][2])
            end
            if bDebugMessages == true then LOG(sFunctionRef..': tWZRaidingPath='..repru(tWZRaidingPath)..'; Is table of raiders empty='..tostring(M28Utilities.IsTableEmpty(tFactoryWZTeamData[M28Map.reftoWZRaiders]))..'; Are there dangerous enemies in an adjacent WZ='..tostring((tFactoryWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]))..'; Time='..GetGameTimeSeconds()..'; tFactoryWZTeamData[M28Map.refiRaidWZForBombardment]='..(tFactoryWZTeamData[M28Map.refiRaidWZForBombardment] or 'nil')) end
            if tWZRaidingPath then
                --Next check the total enemy naval threat from the base WZ to the raid destination or if we have enemies in the base WZ; if it is too much, then free up these units temporarily to help with normal combat duties
                if bDebugMessages == true then LOG(sFunctionRef..': is table of raiders empty='..tostring(M28Utilities.IsTableEmpty(tFactoryWZTeamData[M28Map.reftoWZRaiders]))) end
                if M28Utilities.IsTableEmpty(tFactoryWZTeamData[M28Map.reftoWZRaiders]) == false then
                    --Record every water zone along the path; then for any unit not in one of these zones, figure out the closest such water zone (with a bonus for those closer to the destination) and travel there
                    local tbWaterZonesInPath = {[iFactoryWaterZone] = true}
                    local toUnitsToAttack = {}

                    for iEntry, iZone in tWZRaidingPath do
                        table.insert(tbWaterZonesInPath, iZone)
                    end
                    local iLastZone = tFactoryWZTeamData[M28Map.refiRaidWZForBombardment] --tWZRaidingPath[table.getn(tWZRaidingPath)]
                    local iCurWZ
                    local iTargetWZPond = M28Map.tiPondByWaterZone[iLastZone]
                    local tTargetWZData = M28Map.tPondDetails[iTargetWZPond][M28Map.subrefPondWaterZones][iLastZone]

                    for iCurRaider = table.getn(tFactoryWZTeamData[M28Map.reftoWZRaiders]), 1, -1 do
                        local oUnit = tFactoryWZTeamData[M28Map.reftoWZRaiders][iCurRaider]
                        iCurWZ = M28Map.GetWaterZoneFromPosition(oUnit:GetPosition())
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering orders for raider oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurWZ='..(iCurWZ or 'nil')..'; iLastZone='..iLastZone..'; Active raider='..tostring(oUnit[refbActiveRaider])) end
                        if not(iCurWZ) then
                            M28Orders.UpdateRecordedOrders(oUnit)
                            if (oUnit[M28Orders.refiOrderCount] or 0) == 0 then
                                RemoveUnitFromRaiders(tFactoryWZTeamData[M28Map.reftoWZRaiders], iCurRaider)
                            end
                        else
                            if iCurWZ == iLastZone then
                                --Are at the target, can try to attack the enemy
                                table.insert(toUnitsToAttack, oUnit)
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Have unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' who is currently in water zone '..iCurWZ..' and wants to get to WZ '..iLastZone..' so will have it move to that midpoint. oRaider[refbActiveRaider]='..tostring(oUnit[refbActiveRaider] or false)) end
                                --Move towards the last zone, attack-move if shot not blocked
                                if oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                                    M28Orders.IssueTrackedAttackMove(oUnit, tTargetWZData[M28Map.subrefMidpoint], 10, false, 'RaidMT'..iLastZone, false)
                                else
                                    M28Orders.IssueTrackedAggressiveMove(oUnit, tTargetWZData[M28Map.subrefMidpoint], 10, false, 'RaidAMT'..iLastZone, false)
                                end
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(toUnitsToAttack) == false then
                        local tbPlateauAndZones = {}
                        tbPlateauAndZones[tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][1]] = {}
                        tbPlateauAndZones[tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][1]][tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][2]] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Have '..table.getn(toUnitsToAttack)..' units which will assign bombardment actions for the water zone '..iLastZone..'; tFactoryWZTeamData[M28Map.refiRaidWZForBombardment]='..(tFactoryWZTeamData[M28Map.refiRaidWZForBombardment] or 'nil')) end
                        --AssignBombardmentActions(tWZData,     iPond,      iWaterZone,     iTeam, tPotentialBombardmentUnits, tbOptionalPlateauAndLandZonesToConsider,                  iOptionalRaidBaseWZ)
                        AssignBombardmentActions(tTargetWZData, iPond, iTargetWZPond, iTeam, toUnitsToAttack,           tbPlateauAndZones, tFactoryWZTeamData[M28Map.refiRaidWZForBombardment])
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': have no units that are in the final zone to attack with') end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': end of loop, will wait 1 second') end

            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    end
    tFactoryWZTeamData[M28Map.refbActiveRaiderLogic] = false
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RemoveUnitFromRaiders(tWZRaiderTable, iCurEntry)
    --Cycle through the table in reverse order to avoid issues
    tWZRaiderTable[iCurEntry][refbActiveRaider] = false
    table.remove(tWZRaiderTable, iCurEntry)
end

function AddUnitToRaiders(oRaider, iFactoryWaterZone, iTeam, tFactoryWZTeamData)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddUnitToRaiders'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    oRaider[refbActiveRaider] = true
    oRaider[refiWZOfFactory] = iFactoryWaterZone --redundancy (are already setting when unit is created)
    if not(tFactoryWZTeamData[M28Map.reftoWZRaiders]) then
        tFactoryWZTeamData[M28Map.reftoWZRaiders] = {}
    end
    table.insert(tFactoryWZTeamData[M28Map.reftoWZRaiders], oRaider)
    if bDebugMessages == true then
        LOG(sFunctionRef..': Just added raider '..oRaider.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRaider)..' to table of raiders for iFactoryWaterZone='..iFactoryWaterZone..'; Time='..GetGameTimeSeconds())
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderAssigningRaidingNavalUnit(oRaider, oFactory)
    --First refresh potential raiding (mini bombardment) locations
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderAssigningRaidingNavalUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iFactoryWaterZone = M28Map.GetWaterZoneFromPosition(oFactory:GetPosition())
    if iFactoryWaterZone then
        local tFactoryWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iFactoryWaterZone]][M28Map.subrefPondWaterZones][iFactoryWaterZone]
        local iTeam = oFactory:GetAIBrain().M28Team
        local tFactoryWZTeamData = tFactoryWZData[M28Map.subrefWZTeamData][iTeam]
        RefreshRaidingNavalLocations(iFactoryWaterZone, iTeam)
        local iLifetimeCount = M28UnitInfo.GetUnitLifetimeCount(oRaider)
        --Assign every 4th unit to bombardment if we have somewhere to bombard
        if math.floor(iLifetimeCount / 4) == iLifetimeCount / 4 then
            tFactoryWZTeamData[M28Map.refiRaidTechLevel] = math.max((tFactoryWZTeamData[M28Map.refiRaidTechLevel] or 0), M28UnitInfo.GetUnitTechLevel(oRaider))
            oRaider[refiWZOfFactory] = iFactoryWaterZone --so this unit will be considered for raiding later if its range becomes sufficient
            --Does this unit have sufficient range to be a bombardment unit?
            --[[refiClosestRaidingPlateauAndLandZone = 'WZClRLZ' --returns {Plateau, LandZone} if htere is a land zone we want to consider as a raiding target
            --            refiMinRangeRaidingZone = 'WZClRng' --returns the min range we want raiding naval units to have to join the raid on the land zone--]]
            if M28Utilities.IsTableEmpty(tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone]) == false and oRaider[M28UnitInfo.refiCombatRange] >= tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone] then
                AddUnitToRaiders(oRaider, iFactoryWaterZone, iTeam, tFactoryWZTeamData)
            end
        end
        if not(tFactoryWZTeamData[M28Map.refbActiveRaiderLogic]) and M28Utilities.IsTableEmpty(tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone]) == false then --check units in this zone in case we have overlooked any (e.g. due to logic previously resetting)
            CheckWaterZoneForRaiders(iFactoryWaterZone, tFactoryWZTeamData, iFactoryWaterZone, tFactoryWZTeamData, iTeam)
        end

        ForkThread(ManageWaterZoneRaiders, iFactoryWaterZone, iTeam, tFactoryWZData, tFactoryWZTeamData) --So we can pick up any former raiders that are now available for raiding
        --Forked above to avoid affecting profiling

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end