---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 04/03/2023 08:22
---

local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local NavUtils = M28Utilities.NavUtils
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
--local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')

--Unit variables
refiTimeOfLastWZAssignment = 'M28WZLastAssignmentTime' --GameTimeSeconds
refiCurrentWZAssignmentValue = 'M28WZAssignmentVal' --Value of current assignment
refiCurrentAssignmentWaterZone = 'M28WZCurAssign'
reftiRadarWaterZonesCoveredByTeam = 'M28RadarWZCovered' --against radar, [x] is the team number, returns table of water zones it provides the best intel for
reftiSonarWaterZonesCoveredByTeam = 'M28SonarWZCovered' --against radar, [x] is the team number, returns table of water zones it provides the best intel for
refiWZToMoveTo = 'M28WZToMoveTo' --e.g. aginast scouts
refbActiveRaider = 'M28NRaid' --true if raider
refiWZOfFactory = 'M28NRaFZ' --water zone of the factory that produced this raider - used so can track formerly active raiders
reftBlockedShotLocationByPond = 'M28BlShPn' --[x] is the pond ref; returns a position for where we think DF units should move to not have their shot blocked
refbSpecialStuckTrackingActive = 'M28NStcTr' --true if we are considering if the unit is stuck

--aiBrian variables
refiPriorityPondRef = 'M28PriorityPondRef' --against aibrain, returns the pond ref (naval segment group) that we think is most important to that aibrain (only recorded for M27 brains)
reftiPondThreatToUs = 'M28PondThreatToUs' --against aiBrain, [x] is the pond ref (naval segment group), returns the 'mex value' of that pond when considering mexes within 40% of our base (mod distance).  Only recorded for ponds where we have identified a naval yard build location
reftiPondValueToUs = 'M28PondValueToUs' --against aiBrain, [x] is the pond ref (naval segment group), returns the expected value of the pond if we have naval control of it (so ignores distance reductions that are used to decide if we want to build navy there in the first place)
refbEnemyNavyPreventingBuildingNavy = 'M28PondEnemyNavyNearBuildLocation' --against aibrain, true if enemy has navy near to the build location

--Global variables
tWZRefreshCountByTeam = {}
iLongRangeThreshold = 50 --I.e. units with this or better range get recorded in table of long range threats
iTicksPerNavyCycle = 11
iCurTime = 0 --used due to local variable limit - will be updated with math.floor(getgametimeseconds())
iRetreatFromAirDuration = 60 --number of seconds units should be wary of a zone due to an enemy air threat

tbBlueprintsAddedToTempTable = {} --[x] is the blueprintID, returns true if have shown a waraning message about the unit being in the temp unit table (so we dont fill up the log)

--References to help with limit on variables
refiMaxDist = 0
refiClosestDist = 0
refiClosestSurfaceDist = 0
refiClosestNonHoverDist = 0
refiCurDist = 0
refiCurMidpointDist = 0
refiCurRangeAdjustedDist = 0
refiCurAntiNavyRangeAdjustedDist = 0
refiOverallClosestNonHoverRangeDist = 0
refiClosestSurfaceToMidpointDist = 0
refiClosestNonHoverToMidpointDist = 0
refiClosestSurfaceToMidpointByRange = 0
refiClosestNonHoverToMidpointByRange = 0
refiOverallClosestSurfaceRangeDist = 0

function GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNearestWaterRallyPoint'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; iPond='..(iPond or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'; iTeam='..(iTeam or 'nil')..'; Is table of rally points by pond for this pond empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond]) == false then
        local iCurDist
        local iClosestDist = 100000
        local iClosestWZRef

        for iEntry, iAltWZ in M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond] do
            if bDebugMessages == true then LOG(sFunctionRef..': Looking for rally point for iPond '..iPond..'; iWaterZone '..iWaterZone..'; Considering iAltWZ='..iAltWZ) end
            if iAltWZ == iWaterZone then
                iClosestWZRef = iAltWZ
                break
            else
                local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAltWZ]
                if tAltWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZbCoreBase] then
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], tAltWZData[M28Map.subrefMidpoint])
                    if iCurDist < iClosestDist then
                        iClosestDist = iCurDist
                        iClosestWZRef = iAltWZ
                    end
                end
            end
        end
        if not(iClosestWZRef) then iClosestWZRef = iWaterZone end
        --Land zone will consider moving 2 towards the rally ponit land zone; have left this out for water zones for now but could add in if it becomes an issue

        --Water zone specific - if we have a naval fac in this water zone, then choose that as the retreat point
        local tRallyWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iClosestWZRef]
        local tRallyWZTeamData = tRallyWZData[M28Map.subrefWZTeamData][iTeam]
        if bDebugMessages == true then LOG(sFunctionRef..': iClosestWZRef for iWaterZone'..iWaterZone..' is '..iClosestWZRef..'; Is table of allied units empty for this water zone='..tostring(M28Utilities.IsTableEmpty(tRallyWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))..'; Midpoint of this zone='..repru(tRallyWZData[M28Map.subrefMidpoint])) end
        if M28Utilities.IsTableEmpty(tRallyWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            local tFriendlyFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryAllHQFactories,     tRallyWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tFriendlyFactories) == false then
                local tMoveInDirection = M28Utilities.MoveInDirection(tFriendlyFactories[1]:GetPosition(), M28Utilities.GetAngleFromAToB(tFriendlyFactories[1]:GetPosition(), tRallyWZData[M28Map.subrefMidpoint]), 8, true, false, true)
                if bDebugMessages == true then LOG(sFunctionRef..': Want to move towards rally if possible, tMoveInDirection='..repru(tMoveInDirection)..'; Is this in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tMoveInDirection))) end
                if M28Utilities.IsTableEmpty(tMoveInDirection) and M28Conditions.IsLocationInPlayableArea(tMoveInDirection) then
                    return tMoveInDirection
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Couldnt find valid location to move towards so will just go with midpoint') end
                end
            end
        end

        return {tRallyWZData[M28Map.subrefMidpoint][1], tRallyWZData[M28Map.subrefMidpoint][2], tRallyWZData[M28Map.subrefMidpoint][3]}
    else
        RefreshWaterRallyPoints(iTeam, iPond)
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond]) then
            M28Utilities.ErrorHandler('No rally point for Pond '..(iPond or 'nil')..' WZ'..(iWaterZone or 'nil')..'; iTeam='..iTeam..' even after refreshing, will return current midpoint', true)
        end
        return {tWZData[M28Map.subrefMidpoint][1], tWZData[M28Map.subrefMidpoint][2], tWZData[M28Map.subrefMidpoint][3]}
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshWaterRallyPoints(iTeam, iPond)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshWaterRallyPoints'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for team '..iTeam..' at time='..GetGameTimeSeconds()) end

    if not(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond]) then M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond] = {} end
    local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
    if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones]) then M28Utilities.ErrorHandler('No water zones listed for iPond='..iPond)
    else
        M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond] = {}
        for iWaterZone, tWZData in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones] do
            if tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZbCoreBase] then
                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tWZData[M28Map.subrefMidpoint]) then
                    table.insert(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond], iWaterZone)
                    if bDebugMessages == true then LOG(sFunctionRef..': Added iWaterZone='..(iWaterZone or 'nil')..' as a water zone rally for pond '..iPond..' based on core base flag') end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Considering pond '..iPond..'; Is table of water zone rally points by pond empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond]))) end
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond]) then
            --Dont have any core WZ, so need to pick the WZ whose midpoint is closest to a base - filter to just the water zones that are adjacent to a LZ unless are a campaign map in which case consider the closest WZ to the closest base
            local iCurDistToRallyLZ
            local iClosestDistToRallyLZ = 100000
            local iClosestWZRef
            local iPlateau
            for iWaterZone, tWZData in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones] do
                iPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tWZData[M28Map.subrefMidpoint])
                if iPlateau then break end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will see if nearby land zone rally points to any water zones, iPlateau='..(iPlateau or 'nil')..'; Is table of rally point land zones for this plateau empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau]))) end
            if iPlateau and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau]) == false then
                --For campaign maps check all zones, i..e will only do the 'consider zones with adjacent land zones' test for non-campaign maps only
                if bDontCheckPlayableArea then
                    for iWaterZone, tWZData in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones] do
                        --Does the WZ have adjacent LZ?
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iWaterZone='..iWaterZone..'; Is the table of adjacent land zones empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]))) end
                        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
                            --Search rally points for this plateau and get the closest
                            for iEntry, iAltLZ in M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau] do
                                iCurDistToRallyLZ = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAltLZ][M28Map.subrefMidpoint])
                                if bDebugMessages == true then LOG(sFunctionRef..': iCurDistToRallyLZ='..iCurDistToRallyLZ..'; iClosestDistToRallyLZ='..iClosestDistToRallyLZ) end
                                if iCurDistToRallyLZ < iClosestDistToRallyLZ then
                                    iClosestDistToRallyLZ = iCurDistToRallyLZ
                                    iClosestWZRef = iWaterZone
                                end
                            end
                        end
                    end
                end
            end
            --Check all zones without the 'adjacent to land zone' restriction if we dont have any water zone
            if bDebugMessages == true then LOG(sFunctionRef..': iClosestWZRef under default approach='..(iClosestWZRef or 'nil')..'; if is nil then will try every WZ and get closest to base') end
            if not(iClosestWZRef) then
                for iWaterZone, tWZData in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones] do
                    if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tWZData[M28Map.subrefMidpoint]) then
                        local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                        iCurDistToRallyLZ = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], tWZTeamData[M28Map.reftClosestFriendlyBase])
                        if iCurDistToRallyLZ < iClosestDistToRallyLZ then
                            iClosestDistToRallyLZ = iCurDistToRallyLZ
                            iClosestWZRef = iWaterZone
                        end
                    end
                end
            end

            if iClosestWZRef then
                table.insert(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond], iClosestWZRef)
                if bDebugMessages == true then LOG(sFunctionRef..': Added iClosestWZRef='..(iClosestWZRef or 'nil')..' as a water zone rally') end
            end
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef..': End of code, repru of rally points by pond '..iPond..' for team '..iTeam..'='..repru(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond]))
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateUnitPositionsAndWaterZone(aiBrain, tUnits, iTeam, iRecordedWaterZone, bUseLastKnownPosition, bAreAirUnits, tWZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
    --Similar to UpdateUnitPositionsAndLandZone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateUnitPositionsAndWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iRevisedIndex = 1
    local iTableSize = table.getn(tUnits)
    local iActualWaterZone
    local iUnitSegmentX, iUnitSegmentZ
    local UpdateUnitLastKnownPosition = M28Team.UpdateUnitLastKnownPosition
    local bUseActualPositionIfEnemy = false
    if not(bUseLastKnownPosition) or (tWZTeamData[M28Map.refiRadarCoverage] or 0) >= 100 then bUseActualPositionIfEnemy = true end
    if bUpdateTimeOfLastEnemyPositionCheck and not(bUseLastKnownPosition) then tWZTeamData[M28Map.subrefiTimeOfLastEnemyUnitPosUpdate] = GetGameTimeSeconds() end
    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, time='..GetGameTimeSeconds()..'; iRecordedWaterZone='..iRecordedWaterZone..'; iTableSize='..iTableSize) end
    for iOrigIndex=1, iTableSize do
        if not(tUnits[iOrigIndex]) or tUnits[iOrigIndex].Dead then
            --Remove the entry
            tUnits[iOrigIndex] = nil
            if bDebugMessages == true then LOG(sFunctionRef..': Unit '..(tUnits[iOrigIndex].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tUnits[iOrigIndex]) or 'nil')..' is dead so removing') end
        else
            --Unit still valid, does it have the right water zone?
            if bAreEnemyUnits or bUseLastKnownPosition then
                UpdateUnitLastKnownPosition(aiBrain, tUnits[iOrigIndex], bUseActualPositionIfEnemy, true)
            end

            if bUseLastKnownPosition then
                iUnitSegmentX, iUnitSegmentZ = M28Map.GetPathingSegmentFromPosition(tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][aiBrain.M28Team])
            else
                --Allied unit so can use actual position
                iUnitSegmentX, iUnitSegmentZ = M28Map.GetPathingSegmentFromPosition(tUnits[iOrigIndex]:GetPosition())
            end
            iActualWaterZone = M28Map.tWaterZoneBySegment[iUnitSegmentX][iUnitSegmentZ]
            if bDebugMessages == true then LOG(sFunctionRef..': iOrigIndex='..iOrigIndex..'; iRevisedIndex='..iRevisedIndex..'; Considering unit '..tUnits[iOrigIndex].UnitId..M28UnitInfo.GetUnitLifetimeCount(tUnits[iOrigIndex])..'; iActualWaterZone='..(iActualWaterZone or 'nil')..'; iRecordedWaterZone='..iRecordedWaterZone) end
            --Is the water zone correct?
            if iActualWaterZone == iRecordedWaterZone then
                --No change needed for unit
                if (iOrigIndex ~= iRevisedIndex) then
                    tUnits[iRevisedIndex] = tUnits[iOrigIndex]
                    tUnits[iOrigIndex] = nil
                end
                iRevisedIndex = iRevisedIndex + 1
                if bDebugMessages == true then LOG(sFunctionRef..': Unit is valid, so increasing revised index') end
            else
                local oUnitToAdd = tUnits[iOrigIndex]
                oUnitToAdd[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] = nil
                if iActualWaterZone > 0 then
                    --AddUnitToWaterZoneForBrain(aiBrain,        oUnit,      iWaterZone,      bIsEnemyAirUnit)
                    M28Team.AddUnitToWaterZoneForBrain(aiBrain, oUnitToAdd, iActualWaterZone, bAreAirUnits)
                else
                    --[[if bAreAirUnits then
                        --Add unit to table of air units without a plateau
                        M28Air.RecordEnemyAirUnitWithNoZone(iTeam, oUnitToAdd)
                    else--]]
                    --Not sure where to record unit so call main logic
                    M28Team.AssignUnitToLandZoneOrPond(aiBrain, oUnitToAdd, true)
                    --end
                end

                tUnits[iOrigIndex] = nil
                if bDebugMessages == true then LOG(sFunctionRef..': Unit not valid so not increasing revised index') end
            end
        end
    end
    if iRevisedIndex < iTableSize then
        --table.setn(tUnits, iRevisedIndex - 1)

        for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
            if bDebugMessages == true then LOG(sFunctionRef..': removing entry from zone, Entry='..(tUnits[iRemovalEntry].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tUnits[iRemovalEntry]) or 'nil')..'; iTableSize='..iTableSize..'; iRevisedIndex='..iRevisedIndex) end
            table.remove(tUnits, iRemovalEntry)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateIfWaterZoneWantsSupport(tWZTeamData, bWantCombatSupport)
    tWZTeamData[M28Map.subrefbWZWantsSupport] = bWantCombatSupport
    --Flag if the target WZ only has hover, or only has antinavy
    local bOnlyHover = false
    local bOnlySubmersible = false
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
        bOnlyHover = true
        bOnlySubmersible = true
        for iUnit, oUnit in tWZTeamData[M28Map.subrefTEnemyUnits] do
            --Check for hover
            if bOnlyHover and not(EntityCategoryContains(categories.HOVER, oUnit.UnitId)) then bOnlyHover = false end
            if bOnlySubmersible and not(M28UnitInfo.IsUnitUnderwater(oUnit)) then bOnlySubmersible = false end
        end
    end
    tWZTeamData[M28Map.subrefbWZOnlyHoverEnemies] = bOnlyHover
    tWZTeamData[M28Map.subrefbWZOnlySubmersibleEnemies] = bOnlySubmersible
end

function RemoveUnitFromAnyExistingLandOrWaterZoneItWasPreviouslyTravelingTo(oUnit, sRefForTableOfTravelingUnits)
    local iExistingWZ = oUnit[refiWZToMoveTo]
    local tiExistingPlateauAndLZ = oUnit[M28Land.reftiPlateauAndLZToMoveTo]
    local iTeam = oUnit:GetAIBrain().M28Team
    if iExistingWZ then
        local tExistingWZTeamData = M28Map.tPondDetails[iExistingWZ][M28Map.subrefPondWaterZones][iExistingWZ][M28Map.subrefWZTeamData][iTeam]
        if M28Utilities.IsTableEmpty(tExistingWZTeamData[sRefForTableOfTravelingUnits]) == false then
            for iExistingUnit, oExistingUnit in tExistingWZTeamData[sRefForTableOfTravelingUnits] do
                if oExistingUnit == oUnit then
                    table.remove(tExistingWZTeamData[sRefForTableOfTravelingUnits], iExistingUnit)
                    break
                end
            end
        end
    end
    if M28Utilities.IsTableEmpty(tiExistingPlateauAndLZ) == false then
        local iExistingPlateau = tiExistingPlateauAndLZ[1]
        local iExistingLZ = tiExistingPlateauAndLZ[2]
        local tExistingLZTeamData = M28Map.tAllPlateaus[iExistingPlateau][M28Map.subrefPlateauLandZones][iExistingLZ][M28Map.subrefLZTeamData][iTeam]
        if M28Utilities.IsTableEmpty(tExistingLZTeamData[sRefForTableOfTravelingUnits]) == false then
            for iExistingUnit, oExistingUnit in tExistingLZTeamData[sRefForTableOfTravelingUnits] do
                if oExistingUnit == oUnit then
                    table.remove(tExistingLZTeamData[sRefForTableOfTravelingUnits], iExistingUnit)
                    break
                end
            end
        end
    end
end

function GetUnitToTravelToWaterZone(oUnit, iTargetPond, iTargetWaterZone, subrefWZTUnitTypeTravelingHere)
    --Intended for non-engineer units (engineers are handled separately)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnitToTravelToLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; refiWZToMoveTo='..refiWZToMoveTo) end
    RemoveUnitFromAnyExistingLandOrWaterZoneItWasPreviouslyTravelingTo(oUnit, subrefWZTUnitTypeTravelingHere)

    oUnit[refiWZToMoveTo] = iTargetWaterZone
    oUnit[M28Land.reftiPlateauAndLZToMoveTo] = nil
    local iTeam = oUnit:GetAIBrain().M28Team

    local tWZData = M28Map.tPondDetails[iTargetPond][M28Map.subrefPondWaterZones][iTargetWaterZone]
    local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
    if not(tWZTeamData[subrefWZTUnitTypeTravelingHere]) then tWZTeamData[subrefWZTUnitTypeTravelingHere] = {} end
    table.insert(tWZTeamData[subrefWZTUnitTypeTravelingHere], oUnit)
    if bDebugMessages == true then LOG(sFunctionRef..': About to tell unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to go to iTargetPond='..iTargetPond..'; iTargetWaterZone='..iTargetWaterZone..'; midpoint of WZ='..repru(tWZData[M28Map.subrefMidpoint])) end
    local iOrderReissueDistToUse

    if EntityCategoryContains(categories.HOVER, oUnit.UnitId) then iOrderReissueDistToUse = 6
    else iOrderReissueDistToUse = 16
    end
    M28Orders.IssueTrackedMove(oUnit, tWZData[M28Map.subrefMidpoint], iOrderReissueDistToUse, false, 'NTWZ'..iTargetWaterZone)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RemoveUnitFromListOfUnitsTravelingToWaterZone(oUnit, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RemoveUnitFromListOfUnitsTravelingToWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[refiWZToMoveTo]='..repru(oUnit[refiWZToMoveTo])) end
    if oUnit[refiWZToMoveTo] then
        local sUnitTableRef
        if EntityCategoryContains(M28UnitInfo.refCategoryLandScout + M28UnitInfo.refCategoryFrigate, oUnit.UnitId) then
            sUnitTableRef = M28Map.subrefTScoutsTravelingHere
        else
            M28Utilities.ErrorHandler('Need to add code for this unit category, will send unit info to log')
            LOG(sFunctionRef..': oUnit='..(oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)))
        end
        if sUnitTableRef then

            local iTargetWaterZone = oUnit[refiWZToMoveTo]
            local iTargetPond = M28Map.tiPondByWaterZone[iTargetWaterZone]
            local tTravelingUnits = M28Map.tPondDetails[iTargetPond][M28Map.subrefPondWaterZones][iTargetWaterZone][M28Map.subrefWZTeamData][iTeam][sUnitTableRef]
            if M28Utilities.IsTableEmpty(tTravelingUnits) == false then
                for iTravelUnit, oTravelUnit in tTravelingUnits do
                    if oTravelUnit == oUnit then
                        table.remove(tTravelingUnits, iTravelUnit)
                        break
                    end
                end
            end
        end
        oUnit[refiWZToMoveTo] = nil
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function ManageAllWaterZones(aiBrain, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageAllWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iLastRefreshCount = (tWZRefreshCountByTeam[iTeam] or 1)
    local iCurRefreshCount = 0
    local iTicksToSpreadOver = iTicksPerNavyCycle
    local iRefreshThreshold = math.max(2, math.ceil(iLastRefreshCount * 0.95 / iTicksToSpreadOver))
    local iCurCycleRefreshCount = 0
    local iCurTicksWaited = 0



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Time='..GetGameTimeSeconds()) end

    --Cycle through water zones
    for iPond, tPondSubtable in M28Map.tPondDetails do
        RefreshWaterRallyPoints(iTeam, iPond)
        local bAlreadyUsingFrigatesAsScouts = M28Team.tTeamData[iTeam][M28Team.subrefbUseFrigatesAsScoutsByPond][iPond]
        local bHaveCoreWZWithAdjacentEnemies = false
        if M28Utilities.IsTableEmpty(tPondSubtable[M28Map.subrefPondWaterZones]) == false then
            for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
                local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': iPond='..iPond..'; iWaterZone='..iWaterZone..'; Is table of enemey units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]))..'; Is table of friendly units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
                --First check all units in here are alive
                if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                end
                if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]) == false then
                    iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                end
                if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                    iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                end

                ForkThread(ManageSpecificWaterZone, aiBrain, iTeam, iPond, iWaterZone)
                iCurCycleRefreshCount = iCurCycleRefreshCount + 1

                if iCurCycleRefreshCount >= iRefreshThreshold then
                    iCurRefreshCount = iCurRefreshCount + iCurCycleRefreshCount
                    iCurCycleRefreshCount = 0
                    if iCurTicksWaited < iTicksToSpreadOver then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        iCurTicksWaited = iCurTicksWaited + 1
                        if not(aiBrain) or aiBrain.M28IsDefeated then
                            aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                            if not(aiBrain) or aiBrain.M28IsDefeated then
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return nil
                            end
                        end
                    end
                end
                if not(bAlreadyUsingFrigatesAsScouts) and not(bHaveCoreWZWithAdjacentEnemies) then
                    bHaveCoreWZWithAdjacentEnemies = tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Warning - no water zones found for pond '..iPond) end
        end
        --1-of flag in game where will switch to using frigates as scouts for a pond (done as 1-off as not sure if will cause issues with scout logic if switch between having frigates acting as scouts and then not later; would probably work ok though if after testing decide want to change
        if not(bAlreadyUsingFrigatesAsScouts) and not(bHaveCoreWZWithAdjacentEnemies) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 25 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] >= 3 and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryNavalSurface) >= 20 then
            M28Team.tTeamData[iTeam][M28Team.subrefbUseFrigatesAsScoutsByPond][iPond] = true
        end
    end
    iCurRefreshCount = iCurRefreshCount + iCurCycleRefreshCount
    tWZRefreshCountByTeam[iTeam] = iCurRefreshCount

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordAirThreatForWaterZone(tWZTeamData, iTeam, iPond, iWaterZone)
    --NOTE: M28Navy uses similar logic for RecordAirThreatForWaterZone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAirThreatForWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then
        local iCurPlateau, iCurZone
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]) then LOG(sFunctionRef..': No enemy air units for this WZ')
        else
            for iUnit, oUnit in tWZTeamData[M28Map.reftWZEnemyAirUnits] do
                iCurPlateau, iCurZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                LOG(sFunctionRef..': Air to ground threat for oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'='..M28UnitInfo.GetAirThreatLevel({ oUnit},     true,         false,          false,               true,                  false,              true)..'; Unit position='..repru(oUnit:GetPosition())..'; iCurPlateau='..(iCurPlateau or 'nil')..'; iCurZone='..(iCurZone or 'nil'))
            end
        end

    end
    --GetAirThreatLevel(                                                            tUnits,                             bEnemyUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
    tWZTeamData[M28Map.refiEnemyAirToGroundThreat] = M28UnitInfo.GetAirThreatLevel(tWZTeamData[M28Map.reftWZEnemyAirUnits],     true,         false,          false,               true,                  false,              true)
    tWZTeamData[M28Map.refiEnemyAirAAThreat] = M28UnitInfo.GetAirThreatLevel(tWZTeamData[M28Map.reftWZEnemyAirUnits],           true,       true,               false,              false,              false,                   false)
    tWZTeamData[M28Map.refiEnemyAirOtherThreat] = M28UnitInfo.GetAirThreatLevel(tWZTeamData[M28Map.reftWZEnemyAirUnits],        true,       false,           false,              false,                  true,               false)

    if bDebugMessages == true then LOG(sFunctionRef..': Finished updating enemy air threat values for iTeam '..iTeam..' iPond '..iPond..'; iWaterZOne '..iWaterZone..'; AirToGround threat='.. tWZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Other air threat='..tWZTeamData[M28Map.refiEnemyAirOtherThreat]..'; Is table of enemy air units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]))..'; GameTime='..GetGameTimeSeconds()) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordGroundThreatForWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone)
    --Records the different types of threat for the water zone

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordGroundThreatForWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Track team total threat - first remove the previous entry, then add in the new entry
    --M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] - tWZTeamData[M28Map.subrefWZThreatAllyMobileDFTotal]
    --M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] - tWZTeamData[M28Map.subrefWZThreatAllyMobileIndirectTotal]
    --M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] - tWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA]

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code time='..GetGameTimeSeconds()..' for iTeam='..iTeam..'; iPond='..iPond..'; iWaterZone='..iWaterZone..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]))) end

    tWZTeamData[M28Map.subrefThreatEnemyShield] = 0 --will change later on
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) then
        tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] = 0
        tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] = 0
        tWZTeamData[M28Map.subrefWZThreatEnemySurface] = 0
        tWZTeamData[M28Map.subrefiThreatEnemyGroundAA] = 0
        tWZTeamData[M28Map.subrefWZBestEnemyDFRange] = 0
        tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] = 0
        tWZTeamData[M28Map.subrefWZBestEnemySubmersibleRange] = 0
        tWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] = 0
        tWZTeamData[M28Map.subreftEnemyLongRangeUnits] = nil
        tWZTeamData[M28Map.refiEnemyTorpDefenceCount] = 0
    else
        local iTorpDefenceSurfaceCount = 0
        tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] = M28UnitInfo.GetCombatThreatRating(tWZTeamData[M28Map.subrefTEnemyUnits],  true,       false,              false,                      true,       false)
        tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] = M28UnitInfo.GetCombatThreatRating(tWZTeamData[M28Map.subrefTEnemyUnits], true,     false,              false,                      false,      false,          true)
        local iBaseSubmersibleThreat = (tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] or 0)
        --function                                                   GetCombatThreatRating(tUnits,                          bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, bBlueprintThreat)
        tWZTeamData[M28Map.subrefWZThreatEnemySurface] = M28UnitInfo.GetCombatThreatRating(tWZTeamData[M28Map.subrefTEnemyUnits],   true,       false,              false,                      false,      true,           false)
        --GetAirThreatLevel(tUnits, bEnemyUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
        tWZTeamData[M28Map.subrefiThreatEnemyGroundAA] = M28UnitInfo.GetAirThreatLevel(tWZTeamData[M28Map.subrefTEnemyUnits], true, false, true, false, false, false, false)
        tWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] = M28UnitInfo.GetMassCostOfUnits(EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tWZTeamData[M28Map.subrefTEnemyUnits]), true)
        tWZTeamData[M28Map.subreftEnemyLongRangeUnits] = {}
        local iTorpDefenceCount = 0
        local iLRThreshold = iLongRangeThreshold
        local iCurShield, iMaxShield, iThreatFactor
        for iUnit, oUnit in tWZTeamData[M28Map.subrefTEnemyUnits] do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering ranges and underwater mex threat adjustments for WZ'..iWaterZone..', oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is underwtaer='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))) end
            if oUnit:GetFractionComplete() >= 0.95 and oUnit[M28UnitInfo.refiCombatRange] > 0 then
                if bDebugMessages == true then
                    local iUnitSegmentX, iUnitSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnit:GetPosition())
                    LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Anti navy range='..(oUnit[M28UnitInfo.refiAntiNavyRange] or 'nil')..'; Combat threat rating='..M28UnitInfo.GetCombatThreatRating({ oUnit }, true)..'; Surface threat rating='..M28UnitInfo.GetCombatThreatRating({ oUnit },   true,       false,              false,                      false,      true,           false)..';  Submersible threat rating='..M28UnitInfo.GetCombatThreatRating({ oUnit }, true,     false,              false,                      false,      false,          true)..'; Unit SegX='..(iUnitSegmentX or 'nil')..'Z='..(iUnitSegmentZ or 'nil')..'; WZ at this segment='..(M28Map.tWaterZoneBySegment[iUnitSegmentX][iUnitSegmentZ] or 'nil')..'; LZ at this segment='..(M28Map.tLandZoneBySegment[iUnitSegmentX][iUnitSegmentZ] or 'nil')..'; is unit underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; unit position='..repru(oUnit:GetPosition())..'; water height='..M28Map.iMapWaterHeight..'; sizey='..(oUnit:GetBlueprint().SizeY or 0))
                end
                if oUnit[M28UnitInfo.refiTorpedoDefenceCount] then iTorpDefenceCount = iTorpDefenceCount + oUnit[M28UnitInfo.refiTorpedoDefenceCount] end
                --Simplification to approach taken for land zone logic - will ignore threat (since only relevant for aeon land scout)
                if (oUnit[M28UnitInfo.refiDFRange] or 0) >  tWZTeamData[M28Map.subrefWZBestEnemyDFRange] then  tWZTeamData[M28Map.subrefWZBestEnemyDFRange] = oUnit[M28UnitInfo.refiDFRange] end
                if (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) >  tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] then
                    tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] = oUnit[M28UnitInfo.refiAntiNavyRange]
                end
                if (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > tWZTeamData[M28Map.subrefWZBestEnemySubmersibleRange] then
                    if EntityCategoryContains(categories.SUBMERSIBLE + M28UnitInfo.refCategoryAmphibious, oUnit.UnitId) or oUnit.UnitId == 'xrb2309' then
                        tWZTeamData[M28Map.subrefWZBestEnemySubmersibleRange] = oUnit[M28UnitInfo.refiAntiNavyRange]
                    end
                end
                if oUnit[M28UnitInfo.refiCombatRange] > iLRThreshold then
                    table.insert(tWZTeamData[M28Map.subreftEnemyLongRangeUnits], oUnit)
                end
            elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) and M28UnitInfo.IsUnitUnderwater(oUnit) then
                --Give a token submersible threat for underwater mexes so we build subs to stop
                tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] = iBaseSubmersibleThreat + 10
                if bDebugMessages == true then LOG(sFunctionRef..': Increasing submersible threat by 10 for underwater mex, tWZTeamData[M28Map.subrefWZThreatEnemySubmersible]='..tWZTeamData[M28Map.subrefWZThreatEnemySubmersible]) end
            end
            if oUnit.MyShield and oUnit:GetFractionComplete() >= 0.95 and EntityCategoryContains(M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryMobileLandShield, oUnit.UnitId) then
                iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, true)
                iThreatFactor = math.max(0.1, iCurShield /  iMaxShield)
                tWZTeamData[M28Map.subrefThreatEnemyShield] = tWZTeamData[M28Map.subrefThreatEnemyShield] + iThreatFactor * (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
            end
        end
        tWZTeamData[M28Map.refiEnemyTorpDefenceCount] = iTorpDefenceCount
        if (tWZTeamData[M28Map.subrefThreatEnemyShield] or 0) >= 50 then
            local iMaxShieldRating
            if tWZTeamData[M28Map.subrefThreatEnemyShield] >= 4000 then
                if M28Utilities.bLoudModActive then
                    iMaxShieldRating = tWZTeamData[M28Map.subrefThreatEnemyShield]
                else
                    iMaxShieldRating = math.min(3200 + (tWZTeamData[M28Map.subrefThreatEnemyShield] - 4000) * 0.4, 7000) --shields wont be able to cover everywhere, and more than one shield has lower value due to FAF anti-shield stacking
                end
            else
                iMaxShieldRating = tWZTeamData[M28Map.subrefThreatEnemyShield]
            end
            if M28Utilities.bLoudModActive then
                iMaxShieldRating = iMaxShieldRating + 0.5 * math.min(5000, tWZTeamData[M28Map.subrefThreatEnemyShield]) --shields are really good in LOUD
            end
            local iShieldMaxFactor = 1
            if M28Utilities.bQuietModActive then iShieldMaxFactor = 1.75 --mobile shields likely to have better recharge rates than FAF, and wouldn't expect shield structures in water
            elseif M28Utilities.bLoudModActive then iShieldMaxFactor = 4
            end
            if not(iMaxShieldRating) then
                M28Utilities.ErrorHandler('Dont have a max shield rating for Pond '..iPond..'WZ'..iWaterZone..'; tWZTeamData[M28Map.subrefThreatEnemyShield]='..(tWZTeamData[M28Map.subrefThreatEnemyShield] or 'nil')..'; will use gross WZ value')
                iMaxShieldRating = (tWZTeamData[M28Map.subrefThreatEnemyShield] or 0)
            end
            tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] = tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] + math.min(tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] * iShieldMaxFactor, iMaxShieldRating)
            tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] = math.max( tWZTeamData[M28Map.subrefWZThreatEnemySubmersible], iBaseSubmersibleThreat + math.min(iBaseSubmersibleThreat * iShieldMaxFactor, iMaxShieldRating))
            tWZTeamData[M28Map.subrefWZThreatEnemySurface] = tWZTeamData[M28Map.subrefWZThreatEnemySurface] + math.min(tWZTeamData[M28Map.subrefWZThreatEnemySurface] * iShieldMaxFactor, iMaxShieldRating)
            tWZTeamData[M28Map.subrefiThreatEnemyGroundAA] = tWZTeamData[M28Map.subrefiThreatEnemyGroundAA] + math.min(tWZTeamData[M28Map.subrefiThreatEnemyGroundAA] * iShieldMaxFactor, iMaxShieldRating)
        end
        --If enemy has antinavy surface combat units then increase submersible threat
        if iTorpDefenceSurfaceCount > 0 and tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] > 50 then
            tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] = math.max(tWZTeamData[M28Map.subrefWZThreatEnemySubmersible], math.min(iBaseSubmersibleThreat * 3, tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] + iTorpDefenceSurfaceCount * 200))
        end
    end

    tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] = tWZTeamData[M28Map.subrefWZThreatEnemySurface] + tWZTeamData[M28Map.subrefWZThreatEnemySubmersible]

    --Record allied unit data
    tWZTeamData[M28Map.subrefWZBestAlliedDFRange] = 0
    tWZTeamData[M28Map.subrefWZBestAlliedSubmersibleRange] = 0


    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) then
        tWZTeamData[M28Map.subrefWZThreatAlliedAntiNavy] = 0
        tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] = 0
        tWZTeamData[M28Map.subrefWZThreatAlliedSurface] = 0
        tWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] = 0
        tWZTeamData[M28Map.subrefWZThreatAlliedMAA] = 0
        tWZTeamData[M28Map.subrefWZTThreatAllyLauncherDefenceTotal] = 0
    else
        --function GetCombatThreatRating(tUnits, bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, bBlueprintThreat)

        tWZTeamData[M28Map.subrefWZThreatAlliedAntiNavy] = M28UnitInfo.GetCombatThreatRating(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits], false, false, false, true, false)
        tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] = M28UnitInfo.GetCombatThreatRating(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits], false, false, false, false, false, true)
        tWZTeamData[M28Map.subrefWZThreatAlliedSurface] = M28UnitInfo.GetCombatThreatRating(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits], false, false, false, false, true, false)
        --GetAirThreatLevel(tUnits,                                                                                               bEnemyUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
        tWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] = M28UnitInfo.GetAirThreatLevel(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits], false,           false,          true,                   false,              false,              false,              false)

        if tWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] > 0 then
            local tMobileNavy = EntityCategoryFilterDown(categories.MOBILE, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tMobileNavy) == false then
                tWZTeamData[M28Map.subrefWZThreatAlliedMAA] = M28UnitInfo.GetAirThreatLevel(tMobileNavy, false,           false,          true,                   false,              false,              false,              false)
            else
                tWZTeamData[M28Map.subrefWZThreatAlliedMAA] = 0
            end
        else
            tWZTeamData[M28Map.subrefWZThreatAlliedMAA] = 0
        end
        if bDebugMessages == true then LOG(sFunctionRef..': subrefWZThreatAlliedAntiNavy='..tWZTeamData[M28Map.subrefWZThreatAlliedAntiNavy]..'; subrefWZThreatAlliedSubmersible='..tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible]..'; subrefWZThreatAlliedSurface='..tWZTeamData[M28Map.subrefWZThreatAlliedSurface]..'; subrefLZOrWZThreatAllyGroundAA='..tWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA]..'; subrefWZThreatAlliedMAA='..tWZTeamData[M28Map.subrefWZThreatAlliedMAA]..'; AA threat re-running='..M28UnitInfo.GetAirThreatLevel(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits], true,           false,          true,                   false,              false,              false,              false)) end
        local toFriendlyDefences = {}
        for iUnit, oUnit in tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do
            if oUnit:GetFractionComplete() >= 1 then
                if bDebugMessages == true then LOG(sFunctionRef..': Considering Allied unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Combat threat rating='..M28UnitInfo.GetCombatThreatRating({ oUnit }, true)..'; Antinavy range='..(oUnit[M28UnitInfo.refiAntiNavyRange] or 0)..'; Is this a sub='..tostring(EntityCategoryContains(M28UnitInfo.refCategorySubmarine, oUnit.UnitId))..'; AA threat level of this unit='..M28UnitInfo.GetAirThreatLevel({ oUnit }, true,           false,          true,                   false,              false,              false,              false)) end

                if oUnit[M28UnitInfo.refiDFRange] >  tWZTeamData[M28Map.subrefWZBestAlliedDFRange] and not(M28UnitInfo.IsUnitUnderwater(oUnit)) and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit.UnitId)) and EntityCategoryContains(M28UnitInfo.refCategoryNavalSurface + categories.HOVER + M28UnitInfo.refCategorySeraphimDestroyer + categories.uas0401, oUnit.UnitId) then  tWZTeamData[M28Map.subrefWZBestAlliedDFRange] = oUnit[M28UnitInfo.refiDFRange] end
                if oUnit[M28UnitInfo.refiAntiNavyRange] >  tWZTeamData[M28Map.subrefWZBestAlliedSubmersibleRange] and EntityCategoryContains(M28UnitInfo.refCategorySubmarine, oUnit.UnitId) then
                    tWZTeamData[M28Map.subrefWZBestAlliedSubmersibleRange] = oUnit[M28UnitInfo.refiAntiNavyRange]
                end
                if (oUnit[M28UnitInfo.refiDFRange] > 0 or oUnit[M28UnitInfo.refiAntiNavyRange]) and not(EntityCategoryContains(categories.MOBILE, oUnit.UnitId)) then
                    table.insert(toFriendlyDefences, oUnit)
                end
            elseif bDebugMessages == true then LOG(sFunctionRef..': Unit isnt yet complete, fraction complete='..oUnit:GetFractionComplete()..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Combat threat rating='..M28UnitInfo.GetCombatThreatRating({ oUnit }, true)..'; Antinavy range='..(oUnit[M28UnitInfo.refiAntiNavyRange] or 0)..'; Is this a sub='..tostring(EntityCategoryContains(M28UnitInfo.refCategorySubmarine, oUnit.UnitId))..'; AA threat level of this unit='..M28UnitInfo.GetAirThreatLevel({ oUnit }, true,           false,          true,                   false,              false,              false,              false))
            end
        end
        if M28Utilities.IsTableEmpty(toFriendlyDefences) == false then
            tWZTeamData[M28Map.subrefWZTThreatAllyLauncherDefenceTotal] = M28UnitInfo.GetCombatThreatRating(toFriendlyDefences, false, false, false, false, true, false, false)
        else
            tWZTeamData[M28Map.subrefWZTThreatAllyLauncherDefenceTotal] = 0
        end
    end
    tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] = tWZTeamData[M28Map.subrefWZThreatAlliedSurface] + tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible]

    --Decide what threat we want for this WZ
    local bNearbyEnemies = false
    local bAdjacentLowThreatEnemies = false

    if bDebugMessages == true then LOG(sFunctionRef..': Considering if enemy units in this or adjacent WZ, is table of enemy units for this WZ empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]))..'; Adjacent WZs='..repru(M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZOtherWaterZones]))) end
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Have enemies in this WZ so flagging that it has nearby enemies') end
        bNearbyEnemies = true
    else
        if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZAdjacentWaterZones]) == false then
            local iAdjWZ
            for _, iAdjWZ in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZAdjacentWaterZones] do
                --iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                --NEED to flag as nearby enemies if any enemy units in the WZ, or else can cause problems where we try to attack a unit in an adjacent water zone, and then think there is no such unit due to this flag if it is only based on combat threat
                if bDebugMessages == true then LOG(sFunctionRef..': Enemy combat threat for adjacent WZ iAdjWZ='..iAdjWZ..'; threat='..M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatEnemySurface]..'; is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits]))) end
                if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have enemies in the adjacent WZ '..iAdjWZ) end
                    bNearbyEnemies = true
                    if M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatEnemySurface] + M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatEnemySubmersible] <= 15 then
                        bAdjacentLowThreatEnemies = true
                    else
                        bAdjacentLowThreatEnemies = false
                    end
                    if not(bAdjacentLowThreatEnemies) then
                        break
                    end
                end
            end
        end
    end

    tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = bNearbyEnemies
    if bNearbyEnemies then
        if bAdjacentLowThreatEnemies then
            tWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] = false
            tWZTeamData[M28Map.subrefWZCombatThreatWanted] = math.max(15, tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 2)
        else
            tWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] = true
            tWZTeamData[M28Map.subrefWZCombatThreatWanted] = math.max(200, tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 2)
        end
    else
        tWZTeamData[M28Map.subrefWZCombatThreatWanted] = 0
        tWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] = false
    end

    --If we have no friendly combat units and enemy has combat threat, then request less MAA, or none if we have no non-MAA/scout units
    if bDebugMessages == true then LOG(sFunctionRef..': Setting the MAA level wanted for iWaterZone='..iWaterZone..'; tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..(tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]='..(tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 'nil')..'; tWZTeamData[M28Map.refiEnemyAirToGroundThreat]='..(tWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 'nil')..'; tWZTeamData[M28Map.refiEnemyAirOtherThreat]='..(tWZTeamData[M28Map.refiEnemyAirOtherThreat] or 'nil')..'; Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
    if tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < 11 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= math.min(1500, tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 0.9) or tWZTeamData[M28Map.subrefWZbCoreBase] then
        tWZTeamData[M28Map.subrefWZMAAThreatWanted] = math.max(tWZTeamData[M28Map.refiEnemyAirToGroundThreat] * 1.25 + (tWZTeamData[M28Map.refiEnemyAirOtherThreat] + tWZTeamData[M28Map.refiEnemyAirAAThreat]) * 0.2, tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] * 0.1)

    elseif M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        local bHaveAlliedNonMAAOrScout = false
        local bHaveAlliedMAA = false
        for iUnit, oUnit in tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do
            if EntityCategoryContains(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryNavalSurface - M28UnitInfo.refCategoryMAA - M28UnitInfo.refCategoryLandScout, oUnit.UnitId) then
                bHaveAlliedNonMAAOrScout = true
                break
            elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryNavalAA, oUnit.UnitId) then
                bHaveAlliedMAA = true
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveAlliedMAA='..tostring(bHaveAlliedMAA)..'; bHaveAlliedNonMAAOrScout='..tostring(bHaveAlliedNonMAAOrScout)) end
        if bHaveAlliedNonMAAOrScout or (tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 and (bHaveAlliedMAA or tWZTeamData[M28Map.subrefWZThreatAlliedSurface] > tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal])) then
            --SIgnificantly less MAA for dealing with non-air to ground threats
            if tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                tWZTeamData[M28Map.subrefWZMAAThreatWanted] = math.max(tWZTeamData[M28Map.refiEnemyAirToGroundThreat], (tWZTeamData[M28Map.refiEnemyAirOtherThreat] + tWZTeamData[M28Map.refiEnemyAirAAThreat]) * 0.075, tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] * 0.2)
            else
                tWZTeamData[M28Map.subrefWZMAAThreatWanted] = math.max((tWZTeamData[M28Map.refiEnemyAirOtherThreat] + tWZTeamData[M28Map.refiEnemyAirAAThreat]) * 0.075, tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] * 0.1)
            end
        else
            tWZTeamData[M28Map.subrefWZMAAThreatWanted] = 0
        end
    else
        tWZTeamData[M28Map.subrefWZMAAThreatWanted] = 0
    end

    --Increase MAA wanted if we have ACU in the WZ
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefAlliedACU]) == false then
        local tiMAAByTechForACU = {100, 400, 1000}
        if tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
            tWZTeamData[M28Map.subrefWZMAAThreatWanted] = tWZTeamData[M28Map.subrefWZMAAThreatWanted] + math.min(1600, tiMAAByTechForACU[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2)
        else
            tWZTeamData[M28Map.subrefWZMAAThreatWanted] = tWZTeamData[M28Map.subrefWZMAAThreatWanted] + tiMAAByTechForACU[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
        end
    end

    --If have significant MAA wanted and a significant allied combat threat, then record as a high value WZ wanting MAA
    local iPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tWZData[M28Map.subrefMidpoint])
    if iPlateau then
        if bDebugMessages == true then LOG('About to decide whether to record as high value WZ wanting MAA, running for iTeam='..iTeam..'; iPlateau='..iPlateau..'; iWaterZone='..iWaterZone) end
        if not(M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau]) then M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau] = {} end
        if tWZTeamData[M28Map.subrefWZMAAThreatWanted] - tWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] >= 1000 and tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= 1000 then
            if bDebugMessages == true then LOG(sFunctionRef..': Recording water zone wanting MAA for iWaterZone='..iWaterZone..'; iPlateau='..iPlateau..'; iPond='..iPond..'; Midpoint of waterzone='..repru(tWZData[M28Map.subrefMidpoint])) end
            M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau][iWaterZone] = true
        else
            M28Team.tTeamData[iTeam][M28Team.subrefiWaterZonesWantingSignificantMAAByPlateau][iPlateau][iWaterZone] = nil
        end
    else
        M28Utilities.ErrorHandler('No plateau for pond '..(iPond or 'nil')..'; WZ'..(iWaterZone or 'nil'))
    end



    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bNearbyEnemies='..tostring(bNearbyEnemies)..'; Allied combat='..(tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 'nil')..'; tWZTeamData[M28Map.subrefWZMAAThreatWanted]='..tWZTeamData[M28Map.subrefWZMAAThreatWanted]..'; tWZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tWZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tWZTeamData[M28Map.refiEnemyAirOtherThreat]='..tWZTeamData[M28Map.refiEnemyAirOtherThreat]..'; tWZTeamData[M28Map.refiEnemyTorpDefenceCount]='..(tWZTeamData[M28Map.refiEnemyTorpDefenceCount] or 'nil')) end
    tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = bNearbyEnemies
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MoveToShieldTarget(oShield, tEnemyBase)
    local oBP = oShield:GetBlueprint()
    local iShieldDistanceWanted = math.max(3, oBP.Defense.Shield.ShieldSize * 0.5 - 1 - oBP.Physics.MaxSpeed - (oShield[M28Land.refoMobileShieldTarget]:GetBlueprint().Physics.MaxSpeed or 0))
    --Have an issue with larger shields like shield boats where the shield isn't maintained all the time; can afford to be a bit closer with a larger shield
    if iShieldDistanceWanted >= 10 then iShieldDistanceWanted = math.max(10, iShieldDistanceWanted * 0.66) end
    M28Orders.IssueTrackedMove(oShield, M28Utilities.MoveInDirection(oShield[M28Land.refoMobileShieldTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(tEnemyBase,oShield[M28Land.refoMobileShieldTarget]:GetPosition()), iShieldDistanceWanted, true, false, true), math.min(4, iShieldDistanceWanted - 1), false, 'WShU'..oShield[M28Land.refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield[M28Land.refoMobileShieldTarget]))
end

function MoveToStealthTarget(oStealth, tEnemyBase)
    local oBP = oStealth:GetBlueprint()
    local iStealthDistanceWanted = math.max(8, oBP.Intel.RadarStealthFieldRadius - 1 - oBP.Physics.MaxSpeed - (oStealth[M28Land.refoMobileStealthTarget]:GetBlueprint().Physics.MaxSpeed or 0))
    if iStealthDistanceWanted >= 10 then iStealthDistanceWanted = math.max(10, iStealthDistanceWanted * 0.66) end
    M28Orders.IssueTrackedMove(oStealth, M28Utilities.MoveInDirection(oStealth[M28Land.refoMobileStealthTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(tEnemyBase,oStealth[M28Land.refoMobileStealthTarget]:GetPosition()), iStealthDistanceWanted, true, false, true), math.min(4, iStealthDistanceWanted - 1), false, 'StU'..oStealth[M28Land.refoMobileStealthTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth[M28Land.refoMobileStealthTarget]))
end

function ShieldUnitsInWaterZone(tTeamTargetWZData, tShieldsToAssign, bAssignAllShields)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ShieldUnitsInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    
    local bNoUnitsWantingShielding = true
    if M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) and M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileShield]) then
        M28Utilities.ErrorHandler('Are trying to send mobile shields to support a water zone that has no allied combat units in it and no units wanting shielding')
    else
        if M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileShield]) == false then
            for iTarget, oTarget in tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileShield] do
                if not(oTarget[M28Land.refoAssignedMobileShield]) then
                    if M28Utilities.IsTableEmpty(tShieldsToAssign) then
                        bNoUnitsWantingShielding = false
                        break
                    else
                        --Assign the closest mobile shield
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iShield, oShield in tShieldsToAssign do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iShield='..iShield..'; Shield unit='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)) end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oTarget:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iShield
                            end
                            break
                        end
                        tShieldsToAssign[iClosestRef][M28Land.refoMobileShieldTarget] = oTarget
                        oTarget[M28Land.refoAssignedMobileShield] = tShieldsToAssign[iClosestRef]
                        MoveToShieldTarget(tShieldsToAssign[iClosestRef], tTeamTargetWZData[M28Map.reftClosestEnemyBase])
                        table.remove(tShieldsToAssign, iClosestRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have just removed shield with iClosestRef='..iClosestRef..' from the table of tShieldsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; size of table='..table.getn(tShieldsToAssign)) end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
            bNoUnitsWantingShielding = true
            if bAssignAllShields then
                --No units that want shielding - e.g. we might be telling mobile shields to defend here temporarily; dont assign the shields, instead just give them orders so they are still of some use
                if M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) == false then
                    for iTarget, oTarget in tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits] do
                        if not(oTarget[M28Land.refoAssignedMobileShield]) then --redundancy
                            --Assign the closest mobile shield
                            local iCurDist
                            local iClosestDist = 100000
                            local iClosestRef

                            for iShield, oShield in tShieldsToAssign do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iShield='..iShield..'; Shield unit='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)) end
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oTarget:GetPosition())
                                if iCurDist < iClosestDist then
                                    iClosestDist = iCurDist
                                    iClosestRef = iShield
                                end
                                break
                            end
                            --Dont record the shield as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoshieldtarget works
                            tShieldsToAssign[iClosestRef][M28Land.refoMobileShieldTarget] = oTarget
                            MoveToShieldTarget(tShieldsToAssign[iClosestRef], tTeamTargetWZData[M28Map.reftClosestEnemyBase])
                            tShieldsToAssign[iClosestRef][M28Land.refoMobileShieldTarget] = nil
                            table.remove(tShieldsToAssign, iClosestRef)
                            if bDebugMessages == true then LOG(sFunctionRef..': Backup shield assignment - Have removed shield with iClosestRef='..iClosestRef..' from the table of tShieldsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; size of table='..table.getn(tShieldsToAssign)) end
                            if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                        end
                    end

                    --Do we still have spare mobile shields?
                    if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                        --Get closest unit to enemy base and assign all remaining shields temporarily here
                        local iCurDist
                        local iClosestDist = 100000
                        local oClosestToEnemyBase

                        for iTarget, oTarget in tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits] do
                            if M28UnitInfo.IsUnitValid(oTarget) then
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), tTeamTargetWZData[M28Map.reftClosestEnemyBase])
                                if iCurDist < iClosestDist then
                                    iClosestDist = iCurDist
                                    oClosestToEnemyBase = oTarget
                                end
                            end
                        end
                        if oClosestToEnemyBase then
                            local tEnemyBase = tTeamTargetWZData[M28Map.reftClosestEnemyBase]
                            for iShield, oShield in tShieldsToAssign do
                                --Dont record the shield as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoshieldtarget works
                                if bDebugMessages == true then LOG(sFunctionRef..': About to tell shield '..(oShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oShield) or 'nil')..' to move towards oClosestToEnemyBase='..(oClosestToEnemyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase) or 'nil')) end
                                oShield[M28Land.refoMobileShieldTarget] = oClosestToEnemyBase
                                MoveToShieldTarget(oShield, tEnemyBase)
                                oShield[M28Land.refoMobileShieldTarget] = nil
                                if bDebugMessages == true then LOG(sFunctionRef..': Backup shield assignment - have told shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' to go to the closest enemy in this WZ to enemy base='..oClosestToEnemyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase)) end
                            end
                        elseif bDebugMessages == true then LOG(sFunctionRef..': No friendly units close to enemy base - assuming this is termpoary due to unit being destroyed')
                        end
                    end
                end
            end
        end
    end
    if bNoUnitsWantingShielding then
        --Flag that this WZ no longer wants mobile shields
        tTeamTargetWZData[M28Map.refbWZWantsMobileShield] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function StealthUnitsInWaterZone(tTeamTargetWZData, tStealthsToAssign, bAssignAllStealths)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'StealthUnitsInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local bNoUnitsWantingStealthing = true
    if M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) and M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileStealth]) then
        M28Utilities.ErrorHandler('Are trying to send mobile Stealths to support a water zone that has no allied combat units in it and no units wanting Stealthing')
    else
        if M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileStealth]) == false then
            for iTarget, oTarget in tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileStealth] do
                if not(oTarget[M28Land.refoAssignedMobileStealth]) then
                    if M28Utilities.IsTableEmpty(tStealthsToAssign) then
                        bNoUnitsWantingStealthing = false
                        break
                    else
                        --Assign the closest mobile Stealth
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iStealth, oStealth in tStealthsToAssign do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iStealth='..iStealth..'; Stealth unit='..oStealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth)) end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oStealth:GetPosition(), oTarget:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iStealth
                            end
                            break
                        end
                        tStealthsToAssign[iClosestRef][M28Land.refoMobileStealthTarget] = oTarget
                        oTarget[M28Land.refoAssignedMobileStealth] = tStealthsToAssign[iClosestRef]
                        MoveToStealthTarget(tStealthsToAssign[iClosestRef], tTeamTargetWZData[M28Map.reftClosestEnemyBase])
                        table.remove(tStealthsToAssign, iClosestRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have just removed Stealth with iClosestRef='..iClosestRef..' from the table of tStealthsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; size of table='..table.getn(tStealthsToAssign)) end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tStealthsToAssign) == false and bAssignAllStealths then
            bNoUnitsWantingStealthing = true
            --No units that want Stealthing - e.g. we might be telling mobile Stealths to defend here temporarily; dont assign the Stealths, instead just give them orders so they are still of some use
            if M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) == false then
                for iTarget, oTarget in tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits] do
                    if not(oTarget[M28Land.refoAssignedMobileStealth]) then --redundancy
                        --Assign the closest mobile Stealth
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iStealth, oStealth in tStealthsToAssign do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iStealth='..iStealth..'; Stealth unit='..oStealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth)) end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oStealth:GetPosition(), oTarget:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iStealth
                            end
                            break
                        end
                        --Dont record the Stealth as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoStealthtarget works
                        tStealthsToAssign[iClosestRef][M28Land.refoMobileStealthTarget] = oTarget
                        MoveToStealthTarget(tStealthsToAssign[iClosestRef], tTeamTargetWZData[M28Map.reftClosestEnemyBase])
                        tStealthsToAssign[iClosestRef][M28Land.refoMobileStealthTarget] = nil
                        table.remove(tStealthsToAssign, iClosestRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Backup Stealth assignment - Have removed Stealth with iClosestRef='..iClosestRef..' from the table of tStealthsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; size of table='..table.getn(tStealthsToAssign)) end
                        if M28Utilities.IsTableEmpty(tStealthsToAssign) then break end
                    end
                end

                --Do we still have spare mobile Stealths?
                if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                    --Get closest unit to enemy base and assign all remaining Stealths temporarily here
                    local iCurDist
                    local iClosestDist = 100000
                    local oClosestToEnemyBase

                    for iTarget, oTarget in tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits] do
                        if M28UnitInfo.IsUnitValid(oTarget) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), tTeamTargetWZData[M28Map.reftClosestEnemyBase])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oClosestToEnemyBase = oTarget
                            end
                        end
                    end
                    if oClosestToEnemyBase then
                        local tEnemyBase = tTeamTargetWZData[M28Map.reftClosestEnemyBase]
                        for iStealth, oStealth in tStealthsToAssign do
                            --Dont record the Stealth as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoStealthtarget works
                            if bDebugMessages == true then LOG(sFunctionRef..': About to tell Stealth '..(oStealth.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oStealth) or 'nil')..' to move towards oClosestToEnemyBase='..(oClosestToEnemyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase) or 'nil')) end
                            oStealth[M28Land.refoMobileStealthTarget] = oClosestToEnemyBase
                            MoveToStealthTarget(oStealth, tEnemyBase)
                            oStealth[M28Land.refoMobileStealthTarget] = nil
                            if bDebugMessages == true then LOG(sFunctionRef..': Backup Stealth assignment - have told Stealth '..oStealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth)..' to go to the closest enemy in this WZ to enemy base='..oClosestToEnemyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase)) end
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': No friendly units close to enemy base - assuming this is termpoary due to unit being destroyed')
                    end
                end
            end
        end
    end
    if bNoUnitsWantingStealthing then
        --Flag that this WZ no longer wants mobile Stealths
        tTeamTargetWZData[M28Map.refbWZWantsMobileStealth] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageMobileShieldsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tMobileShields)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMobileShieldsInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iWaterZone='..iWaterZone..'; Size of tMobileShields='..table.getn(tMobileShields)) end

    local iCurShield, iMaxShield
    local tShieldsToRetreat = {}
    local tShieldsToAssign = {}
    local tEnemyBase = tWZTeamData[M28Map.reftClosestEnemyBase]
    if M28Utilities.IsTableEmpty(tEnemyBase) then
        M28Utilities.ErrorHandler('Couldnt find enemy base, will try backup approach')
        local iCurDist
        local iClosestDist = 100000
        local oClosestBrain
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestBrain = oBrain
            end
        end
        tEnemyBase = M28Map.PlayerStartPoints[oClosestBrain:GetArmyIndex()]
    end

    for iUnit, oUnit in tMobileShields do
        iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, false)
        if bDebugMessages == true then LOG(sFunctionRef..': Considering what to do with unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurShield='..iCurShield..'; iMaxShield='..iMaxShield) end
        if not(oUnit[M28UnitInfo.refbEasyBrain]) and iCurShield < iMaxShield * 0.5 then
            --Retreat
            table.insert(tShieldsToRetreat, oUnit)
        elseif oUnit[M28Land.refoMobileShieldTarget] and M28UnitInfo.IsUnitValid(oUnit[M28Land.refoMobileShieldTarget]) then
            --make sure we are behind the target
            MoveToShieldTarget(oUnit, tEnemyBase)
        else
            table.insert(tShieldsToAssign, oUnit)
        end
    end
    if M28Utilities.IsTableEmpty(tShieldsToRetreat) == false then
        local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
        if bDebugMessages == true then LOG(sFunctionRef..': Will give orders to retreat, size of tShieldsToRetreat='..table.getn(tShieldsToRetreat)) end
        for iUnit, oUnit in tShieldsToRetreat do
            if bDebugMessages == true then
                local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, false)
                LOG(sFunctionRef..': About to tell unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to run due to a low shield. iCurShield='..iCurShield..'; iMaxShield='..iMaxShield)
            end
            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'WSRun'..iWaterZone)
        end
    end
    if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
        --Cycle through every water zone and record priority ones to shield
        if bDebugMessages == true then LOG(sFunctionRef..': Will give orders to tShieldsToAssign, size of table='..table.getn(tShieldsToAssign)) end
        local tiClosestWZWithNearbyThreat = {}
        local iClosestWZWithNoThreat
        local iClosestWZNotWantingShieldButWithUnits
        local iClosestWZWithAnyCombatUnits
        if not(tWZTeamData[M28Map.refbWZWantsMobileShield]) and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTAlliedCombatUnits]) == false then iClosestWZNotWantingShieldButWithUnits = iWaterZone end
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
            for iEntry, tPathingDetails in tWZData[M28Map.subrefWZOtherWaterZones] do
                local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tPathingDetails[M28Map.subrefWZAWZRef]][M28Map.subrefWZTeamData][iTeam]
                if tTeamTargetWZData[M28Map.refbWZWantsMobileShield] then
                    if tTeamTargetWZData[M28Map.refiEnemyAirToGroundThreat] > 0 or tTeamTargetWZData[M28Map.subrefTThreatEnemyCombatTotal] >= 40 then
                        ShieldUnitsInWaterZone(tTeamTargetWZData, tShieldsToAssign)
                        if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                    elseif M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefTEnemyUnits]) == false or tTeamTargetWZData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then
                        table.insert(tiClosestWZWithNearbyThreat, tPathingDetails[M28Map.subrefWZAWZRef])
                    elseif not(iClosestWZWithNoThreat) then iClosestWZWithNoThreat = tPathingDetails[M28Map.subrefWZAWZRef]
                    end
                elseif not(iClosestWZNotWantingShieldButWithUnits) then
                    if tTeamTargetWZData[M28Map.subrefbWZWantsSupport] and M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) == false then iClosestWZNotWantingShieldButWithUnits = tPathingDetails[M28Map.subrefWZAWZRef] end
                    if not(iClosestWZWithAnyCombatUnits) and M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) == false then iClosestWZWithAnyCombatUnits = tPathingDetails[M28Map.subrefWZAWZRef] end
                end

            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished checking other zones we can path to for units wanting shielding, is tShieldsToAssign empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; Is M28Utilities.IsTableEmpty(tiClosestWZWithNearbyThreat) empty='..tostring(M28Utilities.IsTableEmpty(tiClosestWZWithNearbyThreat))) end
        if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
            if M28Utilities.IsTableEmpty(tiClosestWZWithNearbyThreat) == false then
                for _, iTargetWZ in  tiClosestWZWithNearbyThreat do
                    local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iTargetWZ][M28Map.subrefWZTeamData][iTeam]
                    ShieldUnitsInWaterZone(tTeamTargetWZData, tShieldsToAssign)
                    if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                end
            end
            if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                if iClosestWZWithNoThreat then
                    local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iClosestWZWithNoThreat][M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Have mobile shields to assign, closest WZ='..iClosestWZWithNoThreat..'; DOes this WZ want mobile shields='..tostring(tTeamTargetWZData[M28Map.refbWZWantsMobileShield] or false)..'; is table of units wanting shielding empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileShield]))) end
                    ShieldUnitsInWaterZone(tTeamTargetWZData, tShieldsToAssign)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Is tShieldsToAssign empty after checking for closest WZ with no threat='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; iClosestWZNotWantingShieldButWithUnits='..(iClosestWZNotWantingShieldButWithUnits or 'nil')) end
                if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                    --Dont have any water zones that want a mobile shield, but we have mobile shields - find the closest WZ  that wants surface support and has DF or IF units, and send them here; if that's this WZ, then have them go to the unit closest to the enemy in this WZ, but without assigning them
                    if iClosestWZNotWantingShieldButWithUnits or iClosestWZWithAnyCombatUnits then
                        local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][(iClosestWZNotWantingShieldButWithUnits or iClosestWZWithAnyCombatUnits)][M28Map.subrefWZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Have mobile shields to assign, closest WZ with friendly combat units that wants more units='..(iClosestWZNotWantingShieldButWithUnits or 'nil')..'; iClosestWZWithAnyCombatUnits='..(iClosestWZWithAnyCombatUnits or 'nil')..'; DOes this WZ want mobile shields='..tostring(tTeamTargetWZData[M28Map.refbWZWantsMobileShield] or false)..'; is table of units wanting shielding empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileShield]))) end
                        ShieldUnitsInWaterZone(tTeamTargetWZData, tShieldsToAssign, true)
                    end
                    if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                        local tHoverShields = EntityCategoryFilterDown(categories.HOVER + M28UnitInfo.refCategoryAmphibious, tShieldsToAssign)
                        if M28Utilities.IsTableEmpty(tHoverShields) == false then
                            tShieldsToAssign = EntityCategoryFilterDown(categories.ALLUNITS - categories.HOVER - M28UnitInfo.refCategoryAmphibious, tShieldsToAssign)
                            --Cycle through nearby zones looking for those wanting shielding
                            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
                                if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
                                    for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                                        local tAltLZ = M28Map.tAllPlateaus[tSubtable[M28Map.subrefWPlatAndLZNumber][1]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefWPlatAndLZNumber][2]]
                                        local tAltLZTeamData = tAltLZ[M28Map.subrefLZTeamData][iTeam]
                                        if tAltLZTeamData[M28Map.refbLZWantsMobileShield] then
                                            M28Land.ShieldUnitsInLandZone(tAltLZTeamData, tHoverShields, false)
                                        end
                                    end
                                end
                                if M28Utilities.IsTableEmpty(tHoverShields) == false then
                                    for iHoverShield, oHoverShield in tHoverShields do
                                        table.insert(tShieldsToAssign, oHoverShield)
                                    end
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': couldnt find any water zones with friendly combat units of a high enough value so have nowhere to assign mobile shields/shield boats; will send them all to the nearest rally point instead') end
                            local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
                            for iUnit, oUnit in tShieldsToAssign do
                                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'WSBckup'..iWaterZone)
                            end
                            M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoShieldBoatTargetsByPond][iPond] = GetGameTimeSeconds()
                        end

                    end

                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageMobileStealthsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tMobileStealths)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMobileStealthsInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iPond='..iPond..'; iWaterZone='..iWaterZone..'; Size of tMobileStealths='..table.getn(tMobileStealths)) end

    local tStealthsToAssign = {}
    local tEnemyBase = tWZTeamData[M28Map.reftClosestEnemyBase]
    if M28Utilities.IsTableEmpty(tEnemyBase) then
        M28Utilities.ErrorHandler('Couldnt find enemy base, will try backup approach')
        local iCurDist
        local iClosestDist = 100000
        local oClosestBrain
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestBrain = oBrain
            end
        end
        tEnemyBase = M28Map.PlayerStartPoints[oClosestBrain:GetArmyIndex()]
    end

    for iUnit, oUnit in tMobileStealths do
        if oUnit[M28Land.refoMobileStealthTarget] and M28UnitInfo.IsUnitValid(oUnit[M28Land.refoMobileStealthTarget]) then
            --make sure we are behind the target
            MoveToStealthTarget(oUnit, tEnemyBase)
        else
            table.insert(tStealthsToAssign, oUnit)
        end
    end
    if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
        --Cycle through every water zone and record priority ones to Stealth
        if bDebugMessages == true then LOG(sFunctionRef..': Will give orders to tStealthsToAssign, size of table='..table.getn(tStealthsToAssign)) end
        local tiClosestWZWithNearbyThreat = {}
        local iClosestWZWithNoThreat
        local iClosestWZNotWantingStealthButWithUnits
        local iClosestWZWithAnyCombatUnits
        if tWZTeamData[M28Map.subrefbWZWantsSupport] and not(tWZTeamData[M28Map.refbWZWantsMobileStealth]) and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTAlliedCombatUnits]) == false then iClosestWZNotWantingStealthButWithUnits = iWaterZone end
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
            for iEntry, tPathingDetails in tWZData[M28Map.subrefWZOtherWaterZones] do
                local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tPathingDetails[M28Map.subrefWZAWZRef]][M28Map.subrefWZTeamData][iTeam]
                if tTeamTargetWZData[M28Map.refbWZWantsMobileStealth] then
                    if tTeamTargetWZData[M28Map.refiEnemyAirToGroundThreat] > 0 or tTeamTargetWZData[M28Map.subrefTThreatEnemyCombatTotal] >= 40 then
                        StealthUnitsInWaterZone(tTeamTargetWZData, tStealthsToAssign)
                        if M28Utilities.IsTableEmpty(tStealthsToAssign) then break end
                    elseif M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefTEnemyUnits]) == false or tTeamTargetWZData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then
                        table.insert(tiClosestWZWithNearbyThreat, tPathingDetails[M28Map.subrefWZAWZRef])
                    elseif not(iClosestWZWithNoThreat) then iClosestWZWithNoThreat = tPathingDetails[M28Map.subrefWZAWZRef]
                    end
                elseif not(iClosestWZNotWantingStealthButWithUnits) then
                    if tTeamTargetWZData[M28Map.subrefbWZWantsSupport] and M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) == false then iClosestWZNotWantingStealthButWithUnits = tPathingDetails[M28Map.subrefWZAWZRef] end
                    if not(iClosestWZWithAnyCombatUnits) and M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) == false then iClosestWZWithAnyCombatUnits = tPathingDetails[M28Map.subrefWZAWZRef] end
                end

            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished checking other zones we can path to for units wanting Stealthing, is tStealthsToAssign empty='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; Is M28Utilities.IsTableEmpty(tiClosestWZWithNearbyThreat) empty='..tostring(M28Utilities.IsTableEmpty(tiClosestWZWithNearbyThreat))) end
        if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
            if M28Utilities.IsTableEmpty(tiClosestWZWithNearbyThreat) == false then
                for _, iTargetWZ in  tiClosestWZWithNearbyThreat do
                    local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iTargetWZ][M28Map.subrefWZTeamData][iTeam]
                    StealthUnitsInWaterZone(tTeamTargetWZData, tStealthsToAssign)
                    if M28Utilities.IsTableEmpty(tStealthsToAssign) then break end
                end
            end
            if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                if iClosestWZWithNoThreat then
                    local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iClosestWZWithNoThreat][M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Have mobile Stealths to assign, closest WZ='..iClosestWZWithNoThreat..'; DOes this WZ want mobile Stealths='..tostring(tTeamTargetWZData[M28Map.refbWZWantsMobileStealth] or false)..'; is table of units wanting Stealthing empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileStealth]))) end
                    StealthUnitsInWaterZone(tTeamTargetWZData, tStealthsToAssign)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Is tStealthsToAssign empty after checking for closest WZ with no threat='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; iClosestWZNotWantingStealthButWithUnits='..(iClosestWZNotWantingStealthButWithUnits or 'nil')) end
                if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                    --Dont have any water zones that want a mobile Stealth, but we have mobile Stealths - find the closest WZ  that wants DF support and has DF units, and send them here; if that's this WZ, then have them go to the unit closest to the enemy in this WZ, but without assigning them
                    M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoStealthBoatTargetsByPond][iPond] = GetGameTimeSeconds()
                    if iClosestWZNotWantingStealthButWithUnits or iClosestWZWithAnyCombatUnits then
                        local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][(iClosestWZNotWantingStealthButWithUnits or iClosestWZWithAnyCombatUnits)][M28Map.subrefWZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Have mobile Stealths to assign, closest WZ with friendly combat units that wants more units='..(iClosestWZNotWantingStealthButWithUnits or 'nil')..'; iClosestWZWithAnyCombatUnits='..(iClosestWZWithAnyCombatUnits or 'nil')..'; DOes this WZ want mobile Stealths='..tostring(tTeamTargetWZData[M28Map.refbWZWantsMobileStealth] or false)..'; is table of units wanting Stealthing empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileStealth]))) end
                        StealthUnitsInWaterZone(tTeamTargetWZData, tStealthsToAssign, true)
                    end
                    if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': couldnt find any water zones with friendly combat units so have nowhere to assign mobile Stealths; will send them all to the nearest rally point instead') end
                        local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
                        for iUnit, oUnit in tStealthsToAssign do
                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'SNtBckup'..iWaterZone)
                        end

                    end

                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordUnitAsReceivingWaterZoneAssignment(oUnit, iWaterZone, iCurWZValue)
    oUnit[refiCurrentWZAssignmentValue] = iCurWZValue
    oUnit[refiCurrentAssignmentWaterZone] = iWaterZone
    oUnit[refiTimeOfLastWZAssignment] = GetGameTimeSeconds()
    if oUnit[M28Land.refiCurrentAssignmentPlateauAndLZ] then
        oUnit[M28Land.refiCurrentAssignmentValue] = nil
        oUnit[M28Land.refiCurrentAssignmentPlateauAndLZ] = nil
    end
end

function MoveUnassignedLandUnits(tWZData, tWZTeamData, iPond, iWaterZone, iTeam, tAmphibiousUnits)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MoveUnassignedLandUnits'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Decides where to send any units that are part of this water zone (ignores those from an adjacent waterzone that were available)
    --local tAmphibiousLabelUnits = {}
    local tiUnitsInZoneByAmphibiousLabel = {}
    local iCurLabel
    local bAmphibiousCheck
    if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryAmphibious, tAmphibiousUnits)) == false then
        bAmphibiousCheck = true
        --[[else
            iAmphibiousLabelWanted = tWZData[M28Map.refiMidpointAmphibiousLabel]
            if not(iAmphibiousLabelWanted) then iAmphibiousLabelWanted = -1 end --dont want to be nil as if target island also nil then we will think we can path there--]]
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for the game time='..GetGameTimeSeconds()..' and iWaterZone='..iWaterZone..', is tAmphibiousUnits empty='..tostring(M28Utilities.IsTableEmpty(tAmphibiousUnits))) end
    for iUnit, oUnit in tAmphibiousUnits do
        if oUnit[refiCurrentAssignmentWaterZone] == iWaterZone and M28UnitInfo.IsUnitValid(oUnit) then --Unit valid check for redundancy due to error message that got
            if bAmphibiousCheck and EntityCategoryContains(M28UnitInfo.refCategoryAmphibious, oUnit.UnitId) then iCurLabel = (NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, oUnit:GetPosition()) or tWZData[M28Map.refiMidpointAmphibiousLabel] or 0)
            else
                iCurLabel = tWZData[M28Map.refiMidpointAmphibiousLabel]
            end
            if not(tiUnitsInZoneByAmphibiousLabel[iCurLabel]) then tiUnitsInZoneByAmphibiousLabel[iCurLabel] = {} end
            table.insert(tiUnitsInZoneByAmphibiousLabel[iCurLabel], oUnit)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; iCurLabel='..(iCurLabel or 'nil')..'; WZ label='..(tWZData[M28Map.refiMidpointAmphibiousLabel] or 'nil')..'; Amphibious label at position='.. (NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, oUnit:GetPosition())) or 'nil') end
    end
    if M28Utilities.IsTableEmpty(tiUnitsInZoneByAmphibiousLabel) == false then
        for iAmphibiousLabel, tAmphibiousLabelUnits in tiUnitsInZoneByAmphibiousLabel do

            --Find the nearest land zone wanting support:
            local iPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tWZData[M28Map.subrefMidpoint])
            if not(iPlateau) then
                M28Utilities.ErrorHandler('Dont have a plateau for midpoint of water zone '..(iWaterZone or 'nil')..' in iPond '..(iPond or 'nil'))
                --will still try and continue since have recorded plateau for the adjacent land zones anyway
            end
            local iLZToSupport

            --Does this WZ have adjacent LZ wanting support?
            local bDontCheckForPacifism = not(M28Overseer.bPacifistModeActive)
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
                for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                    local tAltLZ = M28Map.tAllPlateaus[tSubtable[M28Map.subrefWPlatAndLZNumber][1]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefWPlatAndLZNumber][2]]

                    if (bDontCheckForPacifism or not(tWZData[M28Map.subrefbPacifistArea])) and tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsSupport] then
                        if iAmphibiousLabel == tAltLZ[M28Map.refiMidpointAmphibiousLabel] then
                            iLZToSupport = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                            iPlateau = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                            break
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with iAmphibiousLabel='..iAmphibiousLabel..'; iLZToSupport after checking adjacent LZ to this WZ='..(iLZToSupport or 'nil')..'; did this WZ have adjacent LZ? is table empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]))..'; Time='..GetGameTimeSeconds()) end
            if not(iLZToSupport) then
                --Cycle through every other water zone and try the same thing
                local iCloserPlateauToEnemy, iCloserLandZoneToEnemy
                local iEnemyPlateau, iEnemyZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tWZTeamData[M28Map.reftClosestEnemyBase])
                local iMaxDistWantedToEnemyBase = math.max(50, M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], tWZTeamData[M28Map.reftClosestEnemyBase]) - 50)
                if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                    for iWZEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                        local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tWZSubtable[M28Map.subrefWZAWZRef]]
                        if bDebugMessages == true then LOG(sFunctionRef..'; Considering alt WZ='..tWZSubtable[M28Map.subrefWZAWZRef]..'; Is table of adjacent land zones empty='..tostring(M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefAdjacentLandZones]))) end
                        if M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefAdjacentLandZones]) == false then
                            for iEntry, tSubtable in tAltWZData[M28Map.subrefAdjacentLandZones] do
                                local tAltLZ = M28Map.tAllPlateaus[tSubtable[M28Map.subrefWPlatAndLZNumber][1]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefWPlatAndLZNumber][2]]
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent land zone '..tSubtable[M28Map.subrefWPlatAndLZNumber][2]..' in plateau '..tSubtable[M28Map.subrefWPlatAndLZNumber][1]..'; Does this zone want support='..tostring(tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsSupport])..'; Dist to enemy base='..M28Utilities.GetDistanceBetweenPositions(tWZTeamData[M28Map.reftClosestEnemyBase], tAltLZ[M28Map.subrefMidpoint])..'; iMaxDistWantedToEnemyBase='..iMaxDistWantedToEnemyBase) end
                                if (bDontCheckForPacifism or not(tAltLZ[M28Map.subrefbPacifistArea])) and tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsSupport] then
                                    if iAmphibiousLabel == tAltLZ[M28Map.refiMidpointAmphibiousLabel] then
                                        iLZToSupport = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                                        iPlateau = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                                        break
                                    end
                                    --redundancy - if we dont have any adjacent land zones wanting support, then just pick a land zone that is closer to the enemy base than the curent water zone (and just want the nearest ot this zone to avoid crossing most of the map just to turn up righta t the enem ybase)
                                elseif not(iCloserLandZoneToEnemy) and not(iLZToSupport) and iEnemyPlateau == tSubtable[M28Map.subrefWPlatAndLZNumber][1] and M28Utilities.GetDistanceBetweenPositions(tWZTeamData[M28Map.reftClosestEnemyBase], tAltLZ[M28Map.subrefMidpoint]) < iMaxDistWantedToEnemyBase then
                                    iCloserPlateauToEnemy = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                                    iCloserLandZoneToEnemy = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                                    if bDebugMessages == true then LOG(sFunctionRef..': Recording backup land zone to travel to='..tSubtable[M28Map.subrefWPlatAndLZNumber][2]..' in plateau '..tSubtable[M28Map.subrefWPlatAndLZNumber][1]) end
                                end
                            end
                        end
                        if iLZToSupport then break end
                    end
                    if not(iLZToSupport) and iCloserLandZoneToEnemy then
                        iLZToSupport = iCloserLandZoneToEnemy
                        iPlateau = iCloserPlateauToEnemy
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iLZToSupport after checking adjacent LZ to all other WZ='..(iLZToSupport or 'nil')) end
                if not(iLZToSupport) then
                    --Get the LZ of the closest base and dont try and do amphibious pathing check
                    iPlateau, iLZToSupport = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tWZTeamData[M28Map.reftClosestEnemyBase])
                    if bDebugMessages == true then LOG(sFunctionRef..': iLZToSupport after checking nearest enemy base land zone='..(iLZToSupport or 'nil')) end
                end
            end
            if not(iLZToSupport) then M28Utilities.ErrorHandler('Unable to find a LZ needing support for water zone '..iWaterZone..'; Pond '..iPond..'; only expected on maps with naval start points', true)
            else
                --We have a LZ to support - decide if we want to send our units there, or if we want to keep them in the water and build up forces
                --If the LZ is a core base LZ or adjacent to a LZ then support
                local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZToSupport]
                local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]

                local bAttackWithEverything = false

                if tLZTeamData[M28Map.subrefLZbCoreBase] or not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) or (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false) then
                    bAttackWithEverything = true
                    if bDebugMessages == true then LOG(sFunctionRef..': No dangerous enemies in this LZ or is a core base, or allied structures are here, so attack with everything. tLZTeamData[M28Map.subrefLZbCoreBase]='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])) end
                else
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                            local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                            if tAltLZTeamData[M28Map.subrefLZbCoreBase] or (M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tAltLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false) then
                                bAttackWithEverything = true
                            end
                        end
                    end
                end
                local iBestEnemyDFRange = 0
                if bDebugMessages == true then LOG(sFunctionRef..': bAttackWithEverything after checking if we want to support a core base/LZ with structures='..tostring(bAttackWithEverything)..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])..'; iLZToSupport='..(iLZToSupport or 'nil')) end
                if not(bAttackWithEverything) then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to check our threat vs enemy threat') end
                    --Do we want to send all units due to having more threat than enemy? Or only if we outrange?
                    local iOurCombatThreat = M28UnitInfo.GetCombatThreatRating(tAmphibiousLabelUnits) + tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]
                    --Calc enemy threat and range in this and adjacent LZs (and also factor in friendly threat in these LZs)
                    iBestEnemyDFRange = math.max(tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange], tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange])
                    local iEnemyCombatThreat = tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]
                    if bDebugMessages == true then LOG(sFunctionRef..': Will calculate enemy threat in range and in adjacent LZs vs friendly threat, based on just this zone iOurCombatThreat='..iOurCombatThreat..'; which includes allied combat threat in the LZ to support of '..(tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 'nil')..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; iLZToSupport='..iLZToSupport) end
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                            local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                            iBestEnemyDFRange = math.max(iBestEnemyDFRange, tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange], tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange])
                            iEnemyCombatThreat = iEnemyCombatThreat + (tAltLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                            iOurCombatThreat = iOurCombatThreat + (tAltLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; iEnemyCombatThreat cumulative='..iEnemyCombatThreat..'; iOurCombatThreat='..iOurCombatThreat) end
                        end
                    end
                    bAttackWithEverything = M28Conditions.HaveEnoughThreatToAttack(iPlateau, iLZToSupport, tLZData, tLZTeamData, iOurCombatThreat, iEnemyCombatThreat, 0, false, iTeam)
                    if not(bAttackWithEverything) then
                        --Check if we include nearby units whether we have enough threat, if we have a high enough value that worth considering
                        if iOurCombatThreat >= 500 then
                            local oClosestAmphibiousToMidpoint = M28Utilities.GetNearestUnit(tAmphibiousLabelUnits, tWZData[M28Map.subrefMidpoint])
                            if M28UnitInfo.IsUnitValid(oClosestAmphibiousToMidpoint) then --redundancy
                                local tNearbyAmphibious = oClosestAmphibiousToMidpoint:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryAmphibiousCombat, oClosestAmphibiousToMidpoint:GetPosition(), 60, 'Ally')
                                local iAltCombatThreat = M28UnitInfo.GetCombatThreatRating(tNearbyAmphibious)
                                if bDebugMessages == true then LOG(sFunctionRef..': iOurCombatThreat='..iOurCombatThreat..'; iAltCombatThreat='..iAltCombatThreat) end
                                if iAltCombatThreat > iOurCombatThreat then
                                    bAttackWithEverything = M28Conditions.HaveEnoughThreatToAttack(iPlateau, iLZToSupport, tLZData, tLZTeamData, iAltCombatThreat, iEnemyCombatThreat, 0, false, iTeam, 1.05)
                                end
                            end

                        end

                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if should attack with everything based on adjacent LZ threat, iOurCombatThreat='..iOurCombatThreat..'; iBestEnemyDFRange='..iBestEnemyDFRange..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; bAttackWithEverything='..tostring(bAttackWithEverything)) end
                end

                --Move units to the LZ to support if we outrange or have sufficient threat
                if bDebugMessages == true then LOG(sFunctionRef..': Will tell units to move to iLZToSupport='..iLZToSupport..'; on Plateau '..iPlateau..'; Dist to WZ midpoint='..M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZToSupport][M28Map.subrefMidpoint], tWZData[M28Map.subrefMidpoint])..'; bAttackWithEverything='..tostring(bAttackWithEverything)..'; iBestEnemyDFRange='..iBestEnemyDFRange..'; tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint])..'; iAmphibiousLabel='..iAmphibiousLabel..'; NavUtils result for amphibious label='..(NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, tLZData[M28Map.subrefMidpoint]) or 'nil')..'; tLZData[M28Map.refiMidpointAmphibiousLabel]='..(tLZData[M28Map.refiMidpointAmphibiousLabel] or 'nil')..'; tLZTeamData[M28Map.reftClosestEnemyBase]='..repru(tLZTeamData[M28Map.reftClosestEnemyBase])) end
                local tHoverDestination = tLZData[M28Map.subrefMidpoint]
                local tAmphibiousDestination
                if iAmphibiousLabel == tLZData[M28Map.refiMidpointAmphibiousLabel] then
                    tAmphibiousDestination = tLZData[M28Map.subrefMidpoint]
                else
                    tAmphibiousDestination = tLZTeamData[M28Map.reftClosestEnemyBase]
                end
                local tHoverRallyPoint
                local tAmphibiousRallyPoint
                --Retreat to base instead of water zone midpoint if the WZs in the pond are <=3 and the depth of the WZ midpoint isn't very large (to reduce risk wew e.g. have ythothas standing in water taking damage but not able to attack)
                if iAmphibiousLabel == tWZData[M28Map.refiMidpointAmphibiousLabel] and not(tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] > tWZTeamData[M28Map.subrefWZThreatAlliedAntiNavy]) and (M28Map.tPondDetails[iPond][M28Map.subrefPondWZCount] >= 3 or M28Map.iMapWaterHeight - GetTerrainHeight(tWZData[M28Map.subrefMidpoint][1],tWZData[M28Map.subrefMidpoint][3]) >= 6.25 or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental, tAmphibiousUnits))) then
                    tAmphibiousRallyPoint = {tWZData[M28Map.subrefMidpoint][1], tWZData[M28Map.subrefMidpoint][2], tWZData[M28Map.subrefMidpoint][3]}
                    if bDebugMessages == true then LOG(sFunctionRef..': Setting amphibious rally point to be the WZ midpoint') end
                else
                    tAmphibiousRallyPoint = {tWZTeamData[M28Map.reftClosestFriendlyBase][1], tWZTeamData[M28Map.reftClosestFriendlyBase][2], tWZTeamData[M28Map.reftClosestFriendlyBase][3]}
                    if bDebugMessages == true then LOG(sFunctionRef..': Setting amphibious rally point to be the closest friendly base') end
                end
                if not(bAttackWithEverything) then
                    --Decide if we want to consolidate hover(surface) units at the waterzone midpoint or not
                    local iClosestCombatEnemyDist = 100000
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestCombatEnemies]) == false then
                        for iEnemy, oEnemy in tLZTeamData[M28Map.reftoNearestCombatEnemies] do
                            iClosestCombatEnemyDist = math.min(iClosestCombatEnemyDist, M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), tAmphibiousRallyPoint))
                        end
                    end
                    if iClosestCombatEnemyDist - iBestEnemyDFRange <= 20 then
                        tHoverRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
                    else
                        --Safe to use amphibious rally point
                        tHoverRallyPoint = tAmphibiousRallyPoint
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': About to give units orders to advance ore retreat or consolidate, bAttackWithEverything='..tostring(bAttackWithEverything)..'; tAmphibiousRallyPoint='..repru(tAmphibiousRallyPoint)..'; tHoverRallyPoint='..repru(tHoverRallyPoint)..'; tAmphibiousDestination='..repru(tAmphibiousDestination)..'; tHoverDestination='..repru(tHoverDestination)..'; rMapPlayableArea='..repru(M28Map.rMapPlayableArea)..'; Amphibious label for amphibious destination='..(NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, tAmphibiousDestination) or 'nil')..'; Amphibious label of WZ midpoint='..(NavUtils.GetLabel('Amphibious', tWZData[M28Map.subrefMidpoint]) or 'nil')) end
                local iOrderReissueDistToUse
                local iResisueOrderDistanceHover = 16
                local iReissueOrderDistanceStandard = 6

                local iCurTime = math.floor(GetGameTimeSeconds())
                function IgnoreOrderDueToStuckUnit(oUnit)
                    if oUnit[M28UnitInfo.refbUnitStuckAlternating] then
                        if (not(oUnit[M28UnitInfo.refbEasyBrain]) or EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnit.UnitId)) and oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition] and M28Utilities.GetDistanceBetweenPositions(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition], oUnit:GetPosition()) >= 15 then
                            --Do nothing - want unit to reach its destination before it gets new orders
                            return true
                        end
                    end
                end

                for iUnit, oUnit in tAmphibiousLabelUnits do
                    if EntityCategoryContains(categories.HOVER, oUnit.UnitId) then iOrderReissueDistToUse = iResisueOrderDistanceHover
                    else iOrderReissueDistToUse = iReissueOrderDistanceStandard
                    end

                    if bAttackWithEverything or ((oUnit[M28UnitInfo.refiDFRange] or 0) > iBestEnemyDFRange and not(EntityCategoryContains(M28UnitInfo.refCategoryAmphibious, oUnit.UnitId))) then
                        if EntityCategoryContains(M28UnitInfo.refCategoryAmphibious, oUnit.UnitId) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Sending amphibious unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to go to amphibious destination; Unit last orders='..reprs(oUnit[M28Orders.reftiLastOrders])..'; Is command queue empty='..tostring(M28Utilities.IsTableEmpty(oUnit:GetCommandQueue()))) end
                            if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Land zone of last order='..(M28Map.GetLandZoneFromPosition(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]) or 'nil')..'; Last order position='..repru(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition])..'; Unit LC='..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit mass cost='..(oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))..'; Unit DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Unit antinavy='..(oUnit[M28UnitInfo.refiAntiNavyRange] or 0)) end
                                if (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) >= 10000 and (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and M28UnitInfo.GetUnitLifetimeCount(oUnit) <= 3 and M28Utilities.IsTableEmpty(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]) == false and M28Map.GetLandZoneFromPosition(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]) then
                                    --Attack-move if we were traveling to a land zone and it isnt that far away
                                    local iDistToLastOrder = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(),oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition])
                                    if iDistToLastOrder <= 125 then
                                        --M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(),oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]) <= 125 then
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition], iOrderReissueDistToUse, false, 'NACsEA'..iWaterZone)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Exp wants to move somewhere to support but land target htat isnt too far away so will go there') end
                                    else
                                        local iAngleToLastOrder = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition])
                                        local bHaveLandZoneNearby = false
                                        local iAmphibPathingRef = NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, oUnit:GetPosition())
                                        for iDist = 125, 25, -25 do
                                            local tInbetweenPosition = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToLastOrder, iDist, true, true, false)

                                            if M28Utilities.IsTableEmpty(tInbetweenPosition) and M28Map.GetLandZoneFromPosition(tInbetweenPosition) and NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, tInbetweenPosition) == iAmphibPathingRef then
                                                bHaveLandZoneNearby = true
                                                break
                                            end
                                        end
                                        if bHaveLandZoneNearby then
                                            if bDebugMessages == true then LOG(sFunctionRef..': will proceed to land for Exp instead of moving') end
                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition], iOrderReissueDistToUse, false, 'NACsEA'..iWaterZone)
                                        else
                                            --No land zone nearby - still consider attackmoving if enemy has dangerous enemy in our range
                                            local bNearbySignificantValueEnemy
                                            if not(oUnit[M28UnitInfo.refbLastShotBlocked]) then
                                                local tNearbyEnemies = oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategoryStructure + categories.HOVER + M28UnitInfo.refCategoryMobileLand - categories.AMPHIBIOUS - categories.TECH1, oUnit:GetPosition(), oUnit[M28UnitInfo.refiDFRange], 'Enemy')
                                                if M28Utilities.IsTableEmpty(tNearbyEnemies) == false then
                                                    for iEnemy, oEnemy in tNearbyEnemies do
                                                        if (oEnemy[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oEnemy)) >= 1000 then
                                                            bNearbySignificantValueEnemy = true
                                                            break
                                                        end
                                                    end
                                                end
                                            end
                                            if bNearbySignificantValueEnemy then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Significant value enemy in our DF range so will attack-move to the amphibious destination') end
                                                M28Orders.IssueTrackedAggressiveMove(oUnit, tAmphibiousDestination, iOrderReissueDistToUse, false, 'NMAMToLZ'..iLZToSupport..'Fr'..iWaterZone)
                                            else
                                                if bDebugMessages == true then LOG(sFunctionRef..': Sending exp to move, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to go to amphibious rally point') end
                                                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                                M28Orders.IssueTrackedMove(oUnit, tAmphibiousDestination, iOrderReissueDistToUse, false, 'NMAEToLZ'..iLZToSupport..'Fr'..iWaterZone)
                                            end
                                        end
                                    end
                                else
                                    M28Orders.IssueTrackedMove(oUnit, tAmphibiousDestination, iOrderReissueDistToUse, false, 'NMAToLZ'..iLZToSupport..'Fr'..iWaterZone)
                                end
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Sending hover unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to go to hover destination') end
                            if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                M28Orders.IssueTrackedMove(oUnit, tHoverDestination, iOrderReissueDistToUse, false, 'NMHToLZ'..iLZToSupport..'Fr'..iWaterZone)
                            end
                        end
                    else
                        if EntityCategoryContains(M28UnitInfo.refCategoryAmphibious, oUnit.UnitId) then
                            --Land experimental exception - make landfall if we are close and were headed there
                            if bDebugMessages == true then LOG(sFunctionRef..': Land zone of last order='..(M28Map.GetLandZoneFromPosition(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]) or 'nil')..'; Last order position='..repru(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition])..'; Unit LC='..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit mass cost='..(oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))..'; Unit DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Unit antinavy='..(oUnit[M28UnitInfo.refiAntiNavyRange] or 0)) end
                            if M28UnitInfo.GetUnitLifetimeCount(oUnit) <= 3 and (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) >= 10000 and (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) == 0 and M28Utilities.IsTableEmpty(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]) == false and M28Map.GetLandZoneFromPosition(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]) then
                                local iDistToLastOrder = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(),oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition])
                                if iDistToLastOrder <= 125 then
                                    --M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(),oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]) <= 125 then
                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition], iOrderReissueDistToUse, false, 'NACsEA'..iWaterZone)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Exp wants to consolidate but land target htat isnt too far away so will go there') end
                                else
                                    local iAngleToLastOrder = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition])
                                    local bHaveLandZoneNearby = false
                                    local iAmphibPathingRef = NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, oUnit:GetPosition())
                                    for iDist = 125, 25, -25 do
                                        local tInbetweenPosition = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToLastOrder, iDist, true, true, false)

                                        if M28Utilities.IsTableEmpty(tInbetweenPosition) and M28Map.GetLandZoneFromPosition(tInbetweenPosition) and NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, tInbetweenPosition) == iAmphibPathingRef then
                                            bHaveLandZoneNearby = true
                                            break
                                        end
                                    end
                                    if bHaveLandZoneNearby then
                                        if bDebugMessages == true then LOG(sFunctionRef..': will proceed to land for Exp instead of consolidating') end
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition], iOrderReissueDistToUse, false, 'NACsEA'..iWaterZone)
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': Sending exp to consolidate, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to go to amphibious rally point') end
                                        oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                        M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, iOrderReissueDistToUse, false, 'NAECons'..iWaterZone)
                                    end
                                end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Sending amphibious unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to go to amphibious rally point') end
                                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, iOrderReissueDistToUse, false, 'NACons'..iWaterZone)
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Sending hover unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to go to hover rally point') end
                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                            M28Orders.IssueTrackedMove(oUnit, tHoverRallyPoint, iOrderReissueDistToUse, false, 'NHCons'..iWaterZone)
                        end
                    end
                end
            end
        end
    end
end

function ManageSpecificWaterZone(aiBrain, iTeam, iPond, iWaterZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageSpecificWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(aiBrain) or aiBrain.M28IsDefeated then
        --if Brain hasn't died in the last couple of ticks then give error message
        if GetGameTimeSeconds() - (M28Overseer.iTimeLastPlayerDefeat or 0) >= 0.3 then M28Utilities.ErrorHandler('Trying to run M28 logic on a defeated brain') end
        aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        if not(aiBrain) or aiBrain.M28IsDefeated then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return nil
        end
    end

    --Record enemy threat
    local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
    local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at gametime='..GetGameTimeSeconds()..'; About to update threat for iPond='..iPond..'; iWaterZone='..iWaterZone..'; iTeam='..iTeam..'; Is WZData empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData))..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]))..'; Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))..'; Is table of enemy air empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]))..'; Is this a core base='..tostring(tWZTeamData[M28Map.subrefWZbCoreBase] or false)) end


    --Update unit positions and if still valid
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
        --UpdateUnitPositionsAndWaterZone(aiBrain,              tUnits,                 iTeam, iRecordedWaterZone, bUseLastKnownPosition, bAreAirUnits, tWZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
        UpdateUnitPositionsAndWaterZone(aiBrain, tWZTeamData[M28Map.subrefTEnemyUnits], iTeam, iWaterZone, true, false, tWZTeamData,        true,                               true)
    end
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]) == false then
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false or GetGameTimeSeconds() - (tWZTeamData[M28Map.refiTimeOfLastAirUpdate] or -100) >= 30 then
            if bDebugMessages == true then LOG(sFunctionRef..': Will do a detailed update of enemy air units based on actual position') end
            tWZTeamData[M28Map.refiTimeOfLastAirUpdate] = GetGameTimeSeconds()
            --UpdateUnitPositionsAndWaterZone(aiBrain, tUnits,                          iTeam, iRecordedWaterZone, bUseLastKnownPosition, bAreAirUnits, tWZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
            UpdateUnitPositionsAndWaterZone(aiBrain, tWZTeamData[M28Map.reftWZEnemyAirUnits], iTeam, iWaterZone, false, true, tWZTeamData, false,                           true)
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Will do an update of enemy air units based on last known position as we lack friendly units in this zone and have recently done a more detailed update') end
            --UpdateUnitPositionsAndWaterZone(aiBrain, tUnits,                              iTeam, iRecordedWaterZone, bUseLastKnownPosition, bAreAirUnits, tWZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
            UpdateUnitPositionsAndWaterZone(aiBrain, tWZTeamData[M28Map.reftWZEnemyAirUnits], iTeam, iWaterZone, true, true, tWZTeamData,       false                               ,true)
        end
    end
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        UpdateUnitPositionsAndWaterZone(aiBrain, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits], iTeam, iWaterZone, false, false, tWZTeamData)
    end

    RecordAirThreatForWaterZone(tWZTeamData, iTeam, iPond, iWaterZone) --need to call first since ground threat references air threat for certain values when determining subrefWZMAAThreatWanted
    RecordGroundThreatForWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone)

    tWZTeamData[M28Map.subrefWZTAlliedCombatUnits] = {}
    tWZTeamData[M28Map.reftoWZUnitsWantingMobileShield] = {}
    tWZTeamData[M28Map.refbWZWantsMobileShield] = false --will change later
    tWZTeamData[M28Map.reftoWZUnitsWantingMobileStealth] = {}
    tWZTeamData[M28Map.refbWZWantsMobileStealth] = false --will change later

    local tEngineers, tScouts, tMobileShields, tMobileStealths, tOtherUnitsToRetreat, tAvailableSubmarines
    local iCurShield, iMaxShield
    local bWaterZoneOrAdjHasUnitsWantingScout = false
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
    local bUpdateEnemyDataHere = true --Will handle this logic in logic for managing water zone units if htis is false
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        --Decide on what to do with units in this WZ
        local bUseFrigatesAsScouts = M28Team.tTeamData[iTeam][M28Team.subrefbUseFrigatesAsScoutsByPond][iPond]
        tEngineers = {}
        tScouts = {}
        tMobileShields = {}
        tMobileStealths = {}
        tOtherUnitsToRetreat = {} --Intended for e.g. fatboys and units with personal shield
        tAvailableSubmarines = {}
        local tSACUsToGoToWaterZone, tSACUs
        local tAmphibiousUnits = {}
        local tAvailableCombatUnits = {}
        local tUnavailableUnitsInThisWZ = {}
        local tTempOtherUnits = {}
        local tAvailableMAA = {}
        local tMissileShips = {}
        local iCurWZValue = tWZTeamData[M28Map.subrefWZTValue]

        local bIncludeUnit

        local iEnemyOmniCoverage = M28Conditions.GetEnemyOmniCoverageOfZone(0, iWaterZone, iTeam)

        local iMobileShieldMassThreshold = 750 --When assigning mobile shields will also restrict further so e.g. seraphim mobile shields will have a higher threshold
        local iMobileShieldHigherMAAMassThreshold = 1500 --for if we have MAA and enemy doesnt have much air threat
        local iMobileStealthMassThreshold = 700 --will get adjusted further
        local iMobileStealthHigherMassThreshold = 1500 --i.e. wont stealth loyalists and titans
        local iUnitMassCost
        local iMobileStealthLowerThresholdCount = 0 --Used to avoid assigning too many mobile stealth at once to units not exceeding the higher mass threshold
        local iLZIslandGivingOrder, iLZIslandTravelingTo
        if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 600 and (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 2000 or tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0) then iMobileShieldHigherMAAMassThreshold = iMobileShieldMassThreshold end
        local iShieldCategory = M28UnitInfo.refCategoryShieldBoat + M28UnitInfo.refCategoryMobileLandShield * categories.TECH3 * categories.HOVER
        --if water isnt too deep include amphibious T3 mobile shields (e.g. LOUD modded unit)
        if GetSurfaceHeight(M28Map.tPondDetails[iPond][M28Map.subrefPondMidpoint][1],  M28Map.tPondDetails[iPond][M28Map.subrefPondMidpoint][3]) - GetTerrainHeight(M28Map.tPondDetails[iPond][M28Map.subrefPondMidpoint][1],  M28Map.tPondDetails[iPond][M28Map.subrefPondMidpoint][3]) <= 10 then
            iShieldCategory = iShieldCategory + categories.TECH3 * categories.AMPHIBIOUS * M28UnitInfo.refCategoryMobileLandShield
            if bDebugMessages == true then LOG(sFunctionRef..': If amphibious t3 shields are an option then these should be included for shield management') end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Difference between surface height and terrain height for pond midpoint='..GetSurfaceHeight(M28Map.tPondDetails[iPond][M28Map.subrefPondMidpoint][1],  M28Map.tPondDetails[iPond][M28Map.subrefPondMidpoint][3]) - GetTerrainHeight(M28Map.tPondDetails[iPond][M28Map.subrefPondMidpoint][1],  M28Map.tPondDetails[iPond][M28Map.subrefPondMidpoint][3])) end

        function RecordIfUnitWantsShieldOrStealth(oUnit)
            iUnitMassCost = (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
            if iUnitMassCost >= iMobileShieldMassThreshold and (iUnitMassCost >= iMobileShieldHigherMAAMassThreshold or iMobileShieldHigherMAAMassThreshold == iMobileShieldMassThreshold or not(EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId))) then
                table.insert(tWZTeamData[M28Map.reftoWZUnitsWantingMobileShield], oUnit)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if this unit wants mobile stealth, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iUnitMassCost='..iUnitMassCost..'; iMobileStealthHigherMassThreshold='..iMobileStealthHigherMassThreshold..'; Is this T2+ IF or skirmisher='..tostring(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryIndirect - categories.TECH1, oUnit.UnitId))) end
            if iEnemyOmniCoverage <= 20 then
                if iUnitMassCost >= iMobileStealthHigherMassThreshold then
                    table.insert(tWZTeamData[M28Map.reftoWZUnitsWantingMobileStealth], oUnit)
                elseif iUnitMassCost >= iMobileStealthMassThreshold and EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryIndirect - categories.TECH1, oUnit.UnitId) then
                    --Only say we want a mobile shield if the unit doesnt have one assigned
                    iMobileStealthLowerThresholdCount = iMobileStealthLowerThresholdCount + 1

                    if iMobileStealthLowerThresholdCount >= 3 or oUnit[M28Land.refoAssignedMobileStealth] then
                        iMobileStealthLowerThresholdCount = 0
                        table.insert(tWZTeamData[M28Map.reftoWZUnitsWantingMobileStealth], oUnit)
                    end
                end
            end
        end
        local bConsiderStuckLogic = (tWZTeamData[M28Map.subrefWZbCoreBase] and not(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones])))
        for iUnit, oUnit in tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do
            if oUnit:GetFractionComplete() == 1 then
                if bDebugMessages == true then LOG(sFunctionRef..': Considering in this WZ unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Active raider='..tostring((oUnit[refbActiveRaider] or false))..'; oUnit[M28ACU.refbTreatingAsACU]='..tostring((oUnit[M28ACU.refbTreatingAsACU] or false))..'; Water zone='..iWaterZone..'; Mobile navyoramhiborhover='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy * categories.MOBILE, oUnit.UnitId))..'; Antinavy='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAntiNavy, oUnit.UnitId))..'; Navy category='..tostring(EntityCategoryContains(categories.NAVAL, oUnit.UnitId))..'; submarine='..tostring(EntityCategoryContains(M28UnitInfo.refCategorySubmarine, oUnit.UnitId))..'; Does it contain the main combat unit grouping of categories='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryNavalAA + M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategorySubmarine - categories.COMMAND - M28UnitInfo.refCategoryRASSACU, oUnit.UnitId))..'; Is this a T3 mobile shield or shield boat='..tostring(EntityCategoryContains(iShieldCategory, oUnit.UnitId))..'; Time='..GetGameTimeSeconds()) end

                --Special anti-stuck logic for T3 naval units (which are more prone to getting stuck)
                if bConsiderStuckLogic and EntityCategoryContains(categories.TECH3 * M28UnitInfo.refCategoryNavalSurface, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbSpecialMicroActive]) and (not(oUnit[M28UnitInfo.refiLastWeaponEvent]) or GetGameTimeSeconds() - oUnit[M28UnitInfo.refiLastWeaponEvent] >= 30) and (not(oUnit[M28UnitInfo.refiTimeLastTriedRetreating]) or GetGameTimeSeconds() - oUnit[M28UnitInfo.refiTimeLastTriedRetreating] >= 30) and not(oUnit[refbSpecialStuckTrackingActive]) then
                    ForkThread(MonitorNavalUnitToSeeIfStuck, oUnit, iWaterZone)
                end
                if oUnit[M28UnitInfo.refiSACUWaterZoneTarget] then
                    if iWaterZone == oUnit[M28UnitInfo.refiSACUWaterZoneTarget] then
                        if not(tSACUs) then tSACUs = {} end
                        table.insert(tSACUs, oUnit)
                    else
                        if not(tSACUsToGoToWaterZone) then tSACUsToGoToWaterZone = {} end
                        table.insert(tSACUsToGoToWaterZone, oUnit)
                    end
                elseif oUnit[refbActiveRaider] then
                    --Consider if want shielding or stealth
                    RecordIfUnitWantsShieldOrStealth(oUnit)
                    if bDebugMessages == true then LOG(sFunctionRef..': active raider so will just consider if want shield or stealth') end
                else
                    if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                        table.insert(tEngineers, oUnit)
                        bWaterZoneOrAdjHasUnitsWantingScout = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Engineer recorded') end
                    elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) or oUnit[M28ACU.refbTreatingAsACU] then
                        --ACU logic - handled via M28ACU file, as amy not want to kite with it
                        bWaterZoneOrAdjHasUnitsWantingScout = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Have an ACU so wont manage here') end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy * categories.MOBILE, oUnit.UnitId) then
                        if EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit.UnitId) or (bUseFrigatesAsScouts and EntityCategoryContains(M28UnitInfo.refCategoryFrigate, oUnit.UnitId)) then
                            table.insert(tScouts, oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Including as a land scout') end
                        elseif EntityCategoryContains(iShieldCategory, oUnit.UnitId) then
                            table.insert(tMobileShields, oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Including as a mobile shield') end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryStealthBoat, oUnit.UnitId) then
                            table.insert(tMobileStealths, oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Including as a mobile stealth') end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryNavalAA + M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategorySubmarine - categories.COMMAND - M28UnitInfo.refCategoryRASSACU, oUnit.UnitId) then
                            bIncludeUnit = false
                            bWaterZoneOrAdjHasUnitsWantingScout = true
                            --Is the unit available for use by this water zone?
                            --Is the unit's priority lower than this?
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if have available combat or MAA unit, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[refiCurrentWZAssignmentValue]='..(oUnit[refiCurrentWZAssignmentValue] or 'nil')..'; oUnit[refiCurrentAssignmentWaterZone]='..(oUnit[refiCurrentAssignmentWaterZone] or 'nil')..'; LZ assignment='..repru(oUnit[M28Land.refiCurrentAssignmentPlateauAndLZ])..'; Time since last WZ assignment='..(GetGameTimeSeconds() - (oUnit[refiTimeOfLastWZAssignment] or 0))..'; Does unit contain MAA category='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryNavalAA, oUnit.UnitId))) end
                            if (oUnit[refiCurrentWZAssignmentValue] or 0) < iCurWZValue or (oUnit[refiCurrentAssignmentWaterZone] == iWaterZone or (GetGameTimeSeconds() - (oUnit[refiTimeOfLastWZAssignment] or 0) >= 10 and not(oUnit[M28Land.refiCurrentAssignmentPlateauAndLZ]))) then
                                --Is it a unit with a shield that wants to retreat so its shield can regen?
                                iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, true)
                                if iMaxShield > 0 and iCurShield < iMaxShield * 0.35 and iMaxShield > oUnit:GetMaxHealth() * 0.8 then --primarily fatboy, but in theory could affect SACUs
                                    table.insert(tOtherUnitsToRetreat, oUnit)
                                    oUnit[refiCurrentWZAssignmentValue] = 100000
                                else
                                    bIncludeUnit = true
                                    if EntityCategoryContains(M28UnitInfo.refCategorySubmarine - M28UnitInfo.refCategorySeraphimDestroyer - categories.uas0401, oUnit.UnitId) then
                                        table.insert(tAvailableSubmarines, oUnit)
                                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryNavalAA, oUnit.UnitId) then
                                        table.insert(tAvailableMAA, oUnit)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Adding unit to available MAA') end
                                    elseif ((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > 0) and EntityCategoryContains(M28UnitInfo.refCategoryNavalSurface + categories.HOVER - M28UnitInfo.refCategoryLandExperimental * M28UnitInfo.refCategoryAmphibious - M28UnitInfo.refCategoryLandCombat * categories.AMPHIBIOUS + M28UnitInfo.refCategorySeraphimDestroyer + categories.uas0401, oUnit.UnitId) then
                                        table.insert(tAvailableCombatUnits, oUnit)
                                        table.insert(tWZTeamData[M28Map.subrefWZTAlliedCombatUnits], oUnit)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Adding unit to table of available combat units') end
                                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMissileShip, oUnit.UnitId) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Adding unit from this WZ to table of missile ships, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                        table.insert(tMissileShips, oUnit)
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have an amphibious unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; AntiNavyRange='..(oUnit[M28UnitInfo.refiAntiNavyRange] or 0)) end
                                        table.insert(tAmphibiousUnits, oUnit)
                                    end
                                    if bIncludeUnit then
                                        RecordUnitAsReceivingWaterZoneAssignment(oUnit, iWaterZone, iCurWZValue)
                                    end
                                end
                                --Is this a land unit traveling from 1 island to another island? In which case also want to consider
                            elseif oUnit[refiCurrentAssignmentWaterZone] == nil and oUnit[M28Land.refiCurrentAssignmentPlateauAndLZ][2] then
                                local tLastOrder = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]]
                                if tLastOrder and tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueMove then
                                    local tAssignmentLZData = M28Map.tAllPlateaus[oUnit[M28Land.refiCurrentAssignmentPlateauAndLZ][1]][M28Map.subrefPlateauLandZones][oUnit[M28Land.refiCurrentAssignmentPlateauAndLZ][2]]

                                    iLZIslandGivingOrder = NavUtils.GetLabel(M28Map.refPathingTypeLand, tAssignmentLZData[M28Map.subrefMidpoint])
                                    iLZIslandTravelingTo = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLastOrder[M28Orders.subreftOrderPosition])
                                    if iLZIslandTravelingTo and not(iLZIslandGivingOrder == iLZIslandTravelingTo) then
                                        bIncludeUnit = true
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have a unit that was given a plateau and LZ assignment and has no WZ assignment, Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iLZIslandGivingOrder='..(iLZIslandGivingOrder or 'nil')..'; iLZIslandTravelingTo='..(iLZIslandTravelingTo or 'nil')..'; bIncludeUnit='..tostring(bIncludeUnit)) end

                                end
                                if bIncludeUnit then
                                    RecordUnitAsReceivingWaterZoneAssignment(oUnit, iWaterZone, iCurWZValue)
                                else
                                    table.insert(tUnavailableUnitsInThisWZ, oUnit)
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Think we have a land unit traveling from 1 island to another, bIncludeUnit='..tostring(bIncludeUnit)..'; if include will record unit as receiving assignment from this zone, otherwise treat as unavailable') end
                            else
                                table.insert(tUnavailableUnitsInThisWZ, oUnit)
                            end
                            RecordIfUnitWantsShieldOrStealth(oUnit)
                        end
                    elseif EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                        --Structure logic - handled separately e.g. via M28Factory for factories
                        if bDebugMessages == true then LOG(sFunctionRef..': Have a building so ignoring') end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Other logic, considering if to add to temp unit table, unit state='..M28UnitInfo.GetUnitState(oUnit)..'; Is it attached='..tostring(oUnit:IsUnitState('Attached'))) end
                        if not(oUnit:IsUnitState('Attached')) then
                            table.insert(tTempOtherUnits, oUnit)
                            if not(tbBlueprintsAddedToTempTable[oUnit.UnitId]) then
                                M28Utilities.ErrorHandler('Adding unit ID '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..' currently recorded in WZ '..iWaterZone..' with unit state='..M28UnitInfo.GetUnitState(oUnit)..' to table of temp other units - either the unit is a land unit really close to water that we incorrectly think is in water, or it is an amphibious/hover unit that has incorrect caterisation; if the unit runs out of orders then will send it to the rally point', true)
                                if bDebugMessages == true then M28Map.DrawSpecificWaterZone(iWaterZone) end
                                tbBlueprintsAddedToTempTable[oUnit.UnitId] = true
                            end
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of engineers empty='..tostring(M28Utilities.IsTableEmpty(tEngineers))..'; Is table of combat units just for this zone empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))) end

        --Mobile shield data:
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoWZUnitsWantingMobileShield]) == false then
            for iUnit, oUnit in tWZTeamData[M28Map.reftoWZUnitsWantingMobileShield] do
                if oUnit[M28Land.refoAssignedMobileShield] then
                    if not(M28UnitInfo.IsUnitValid(oUnit[M28Land.refoAssignedMobileShield])) then
                        oUnit[M28Land.refoAssignedMobileShield] = nil
                        tWZTeamData[M28Map.refbWZWantsMobileShield] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording that the water zone '..iWaterZone..' wants mobile shields as a unit that had a mobile shield no longerh as a valid one') end
                    end
                else
                    tWZTeamData[M28Map.refbWZWantsMobileShield] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording that the water zone '..iWaterZone..' wants mobile shields as it has a unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that doesnt have an assigned mobile shield yet') end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of tMobileShields empty='..tostring(M28Utilities.IsTableEmpty(tMobileShields))..'; Is table of units wanting mobile stealth empty='..tostring(tWZTeamData[M28Map.reftoWZUnitsWantingMobileStealth])..'; iEnemyOmniCoverage='..iEnemyOmniCoverage) end
        if M28Utilities.IsTableEmpty(tMobileShields) == false then
            ManageMobileShieldsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tMobileShields)
        end
        --Mobile stealth data:
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoWZUnitsWantingMobileStealth]) == false then
            for iUnit, oUnit in tWZTeamData[M28Map.reftoWZUnitsWantingMobileStealth] do
                if iEnemyOmniCoverage > 20 then
                    if M28UnitInfo.IsUnitValid(oUnit[M28Land.refoAssignedMobileStealth]) then
                        oUnit[M28Land.refoAssignedMobileStealth][M28Land.refoMobileStealthTarget] = nil
                        oUnit[M28Land.refoAssignedMobileStealth] = nil
                    end
                elseif oUnit[M28Land.refoAssignedMobileStealth] then
                    if not(M28UnitInfo.IsUnitValid(oUnit[M28Land.refoAssignedMobileStealth])) then
                        oUnit[M28Land.refoAssignedMobileStealth] = nil
                        tWZTeamData[M28Map.refbWZWantsMobileStealth] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording that the water zone '..iWaterZone..' wants mobile Stealths as a unit that had a mobile Stealth no longerh as a valid one') end
                    end
                else
                    tWZTeamData[M28Map.refbWZWantsMobileStealth] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording that the water zone '..iWaterZone..' wants mobile Stealths as it has a unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that doesnt have an assigned mobile Stealth yet') end
                end
            end
            if iEnemyOmniCoverage > 20 then tWZTeamData[M28Map.refbWZWantsMobileStealth] = false end --redundancy
        end
        if M28Utilities.IsTableEmpty(tMobileStealths) == false then
            ManageMobileStealthsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tMobileStealths)
        end

        local iCurCombatThreat = tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]
        local iCurMAAThreat = tWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA]

        local bConsiderAdjacentCombat = false
        local bConsiderAdjacentMAA = false
        if iCurCombatThreat < tWZTeamData[M28Map.subrefWZCombatThreatWanted] then bConsiderAdjacentCombat = true end
        if iCurMAAThreat < tWZTeamData[M28Map.subrefWZMAAThreatWanted] then bConsiderAdjacentMAA = true end


        --Add adjacent combat units if the water zone is lower priority than us and the adjacent WZ doesnt have combat units of a significant threat in it
        local iCurUnitThreat
        if bDebugMessages == true then LOG(sFunctionRef..': Will consider including adjacent combat units for WZ '..iWaterZone..' with iCurWZValue='..iCurWZValue..'; is table of adjacent WZs empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]))..'; bConsiderAdjacentCombat='..tostring(bConsiderAdjacentCombat)) end
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false and bConsiderAdjacentCombat then
            local iAdjWZ
            for iEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                local tAltWZTeam = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': iPond='..iPond..'; Base WZ='..iWaterZone..'; iAdjWZ='..iAdjWZ..'; WZTValue='..repru(tAltWZTeam[M28Map.subrefWZTValue])..'; Is table of allied combat units empty='..tostring(M28Utilities.IsTableEmpty(tAltWZTeam[M28Map.subrefWZTAlliedCombatUnits]))) end
                if not(bWaterZoneOrAdjHasUnitsWantingScout) and M28Utilities.IsTableEmpty(tAltWZTeam[M28Map.subrefWZTAlliedCombatUnits]) == false then bWaterZoneOrAdjHasUnitsWantingScout = true end
                if tAltWZTeam[M28Map.subrefWZTValue] < iCurWZValue and tAltWZTeam[M28Map.subrefTThreatEnemyCombatTotal] <= 50 and M28Utilities.IsTableEmpty(tAltWZTeam[M28Map.subrefWZTAlliedCombatUnits]) == false then
                    for iUnit, oUnit in tAltWZTeam[M28Map.subrefWZTAlliedCombatUnits] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to add adjacent WZ oUnit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' with cur assignment value '..(oUnit[refiCurrentWZAssignmentValue] or 0)..' and cur assignemnt WZ='..(oUnit[refiCurrentAssignmentWaterZone] or 'nil')..'; oUnit[M28UnitInfo.refiSACUWaterZoneTarget]='..(oUnit[M28UnitInfo.refiSACUWaterZoneTarget] or 'nil')) end
                        if not(oUnit.Dead) and not(oUnit[refbActiveRaider]) and ((oUnit[refiCurrentWZAssignmentValue] or 0) < iCurWZValue or (oUnit[refiCurrentAssignmentWaterZone] == iWaterZone)) and oUnit:GetFractionComplete() == 1 then
                            if oUnit[M28UnitInfo.refiSACUWaterZoneTarget] then
                                --Do nothing - dont want to give orders to adjacent zone SACUs
                                --Combat unit related
                            elseif bConsiderAdjacentCombat and (oUnit[M28UnitInfo.refiDFRange] > 0 or oUnit[M28UnitInfo.refiAntiNavyRange] > 0) and not(EntityCategoryContains(M28UnitInfo.refCategoryCruiser, oUnit.UnitId)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit from adj WZ to available combat units') end
                                table.insert(tAvailableCombatUnits, oUnit)
                                RecordUnitAsReceivingWaterZoneAssignment(oUnit, iWaterZone, iCurWZValue)

                                iCurUnitThreat = M28UnitInfo.GetCombatThreatRating({ oUnit })

                                if iCurUnitThreat > tWZTeamData[M28Map.subrefWZCombatThreatWanted] then
                                    bConsiderAdjacentCombat = false
                                    if not(bConsiderAdjacentMAA) then break end
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryNavalAA, oUnit.UnitId) then
                                table.insert(tAvailableMAA, oUnit)
                                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit from adj WZ to available MAA') end
                                RecordUnitAsReceivingWaterZoneAssignment(oUnit, iWaterZone, iCurWZValue)

                                iCurUnitThreat = M28UnitInfo.GetAirThreatLevel({ oUnit }, false, false, true)
                                iCurMAAThreat = iCurMAAThreat + iCurUnitThreat
                                if iCurMAAThreat > tWZTeamData[M28Map.subrefWZMAAThreatWanted] then
                                    bConsiderAdjacentMAA = false
                                    if not(bConsiderAdjacentCombat) then break end
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryMissileShip, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit from adj WZ to table of missile ships, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                table.insert(tMissileShips, oUnit)
                            end
                        end
                    end
                    if not(bConsiderAdjacentCombat) and not(bConsiderAdjacentMAA) then break end
                end
            end
        end

        if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false or M28Utilities.IsTableEmpty(tAvailableSubmarines) == false or M28Utilities.IsTableEmpty(tMissileShips) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': About to manage combat units in the WZ') end
            if tWZData[M28Map.subrefbPacifistArea] then
                if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
                    RetreatOtherUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableCombatUnits)
                end
                if M28Utilities.IsTableEmpty(tAvailableSubmarines) == false then
                    RetreatOtherUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableSubmarines)
                end
            else
                --ManageCombatUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableCombatUnits, tAvailableSubmarines, tUnavailableUnitsInThisWZ, tMissileShips)
                local tRemainingLandUnits = ManageCombatUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableCombatUnits, tAvailableSubmarines, tUnavailableUnitsInThisWZ, tMissileShips)
                if M28Utilities.IsTableEmpty(tRemainingLandUnits) == false then
                    for iUnit, oUnit in tRemainingLandUnits do
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of amphibious units from table of remaining land units') end
                        table.insert(tAmphibiousUnits, oUnit)
                    end
                end
                bUpdateEnemyDataHere = false
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of MAA empty='..tostring(M28Utilities.IsTableEmpty(tAvailableMAA))..'; Is table of entity filtered dow nto MAA empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMAA, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))) end
        if tWZTeamData[M28Map.refiMAACombatRangeWithoutTarget] then tWZTeamData[M28Map.refiMAACombatRangeWithoutTarget] = nil end
        if M28Utilities.IsTableEmpty(tAvailableMAA) == false then
            if tWZData[M28Map.subrefbPacifistArea] then
                RetreatOtherUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableMAA)
            else
                ManageMAAInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableMAA)
            end
        end

        if M28Utilities.IsTableEmpty(tOtherUnitsToRetreat) == false then
            RetreatOtherUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tOtherUnitsToRetreat)
        end

        if M28Utilities.IsTableEmpty(tTempOtherUnits) == false then
            --Likely have had land units that are on a location thought to be water due to flaws in the navigational mesh/pathfinding approach - only issue new orders if they have none
            local tRallyPoint = {tWZTeamData[M28Map.reftClosestFriendlyBase][1], tWZTeamData[M28Map.reftClosestFriendlyBase][2], tWZTeamData[M28Map.reftClosestFriendlyBase][3]}
            for iUnit, oUnit in tTempOtherUnits do
                M28Orders.UpdateRecordedOrders(oUnit)
                if oUnit[M28Orders.refiOrderCount] == 0 then
                    --Move to nearest allied base
                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 30, false, 'BckLRP')
                end
            end
        end

        --Decide where to send any unassigned land pathable units
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if have unassigned land pathable units, Is tAmphibiousUnits empty='..tostring(M28Utilities.IsTableEmpty(tAmphibiousUnits))) end
        if M28Utilities.IsTableEmpty(tAmphibiousUnits) == false then
            MoveUnassignedLandUnits(tWZData, tWZTeamData, iPond, iWaterZone, iTeam, tAmphibiousUnits)
        end

        --SACUs
        if tSACUsToGoToWaterZone then
            M28Land.SendSACUsToWaterZone(tSACUsToGoToWaterZone, tWZTeamData)
        end
        if tSACUs then
            ManageSACUsInWaterZone(tSACUs, tWZData, tWZTeamData, iPond, iWaterZone, iTeam)
        end

    end
    --Update enemy ranges for this WZ and decide if this WZ still wants support, if we havent run our main combat management logic
    if bDebugMessages == true then LOG(sFunctionRef..': Will update enemy data for this WZ if are enemies in this WZ. bUpdateEnemyDataHere='..tostring(bUpdateEnemyDataHere or false)) end
    if bUpdateEnemyDataHere then
        RecordClosestAdjacentRangesAndEnemies(tWZData, tWZTeamData, iPond, iWaterZone, iTeam)
        if bDebugMessages == true then LOG(sFunctionRef..': Deciding if want support, iWaterZone='..iWaterZone..'; tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]='..tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])..'; tWZTeamData[M28Map.subrefWZTValue]='..tWZTeamData[M28Map.subrefWZTValue]..'; Pacifist area='..tostring(tWZData[M28Map.subrefbPacifistArea])..'; Midpoint in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tWZData[M28Map.subrefMidpoint]))) end
        if tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] and tWZTeamData[M28Map.subrefWZTValue] >= 200 and not(tWZData[M28Map.subrefbPacifistArea]) then
            UpdateIfWaterZoneWantsSupport(tWZTeamData, true)
            if bDebugMessages == true then LOG(sFunctionRef..': Will update to flag this water zone wants combat support') end
        else
            UpdateIfWaterZoneWantsSupport(tWZTeamData, false)
            if bDebugMessages == true then LOG(sFunctionRef..': Dont want support') end
        end
    end
    --Handle engineers and even if no engineers still decide what engineers we would want for hte WZ
    M28Engineer.ConsiderLandOrWaterZoneEngineerAssignment(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tEngineers, true) --Should update the water zone engineer requirements, even if tEngineers itself is empty

    --Manage any scouts and flag if we need scouts (i.e. want to run this function even if we have no scouts)
    ManageWaterZoneScouts(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tScouts, bWaterZoneOrAdjHasUnitsWantingScout)

    --Treat omni as giving us visual
    if tWZTeamData[M28Map.refiOmniCoverage] > 40 then tWZTeamData[M28Map.refiTimeLastHadVisual] = GetGameTimeSeconds() end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iPond='..iPond..'; iWaterZone='..iWaterZone) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function FlagWaterZoneStartPositions(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'FlagWaterZoneStartPositions'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28Utilities.IsTableEmpty(M28Map.tPondDetails) == false then
        local iBuildLocationSegmentX, iBuildLocationSegmentZ
        for iPond, tPondSubtable in M28Map.tPondDetails do
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iPond='..iPond..'; oBrain='..oBrain.Nickname..'; Does this brain have a build location for this pond='..repru(tPondSubtable[M28Map.subrefBuildLocationByStartPosition][oBrain:GetArmyIndex()])) end
                if tPondSubtable[M28Map.subrefBuildLocationByStartPosition][oBrain:GetArmyIndex()] then
                    iBuildLocationSegmentX, iBuildLocationSegmentZ = M28Map.GetPathingSegmentFromPosition(tPondSubtable[M28Map.subrefBuildLocationByStartPosition][oBrain:GetArmyIndex()])
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oBrain='..oBrain.Nickname..' on iTeam='..iTeam..'; iBuildLocationSegmentX='..iBuildLocationSegmentX..'; iBuildLocationSegmentZ='..iBuildLocationSegmentZ..'; Water zone for these segments='..M28Map.tWaterZoneBySegment[iBuildLocationSegmentX][iBuildLocationSegmentZ]..'; Is pond subtable empty='..tostring(M28Utilities.IsTableEmpty( tPondSubtable[M28Map.subrefPondWaterZones]))..'; Is WZ data empty='..tostring(M28Utilities.IsTableEmpty(tPondSubtable[M28Map.subrefPondWaterZones][M28Map.tWaterZoneBySegment[iBuildLocationSegmentX][iBuildLocationSegmentZ]]))) end
                    if M28Map.tWaterZoneBySegment[iBuildLocationSegmentX][iBuildLocationSegmentZ] then
                        local iWaterZone = M28Map.tWaterZoneBySegment[iBuildLocationSegmentX][iBuildLocationSegmentZ]
                        local tWZData = tPondSubtable[M28Map.subrefPondWaterZones][iWaterZone]
                        if tWZData then
                            local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                            if not(tWZTeamData) then
                                M28Team.SetWaterZoneDefaultTeamValues(tWZData, iTeam)
                                M28Utilities.ErrorHandler('Have valid WZ data but not team data, for water zone '..(iWaterZone or 'nil')..'; will record teh default values for the water zone')
                            end
                            tWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation] = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Have flagged that water zone '..iWaterZone..' in pond '..iPond..'; Contains a naval build location for team '..iTeam..', subrefWZbContainsNavalBuildLocation='..tostring(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZbContainsNavalBuildLocation] or false)) end

                        else
                            M28Utilities.ErrorHandler('Have empty tWZData for water zone '..(M28Map.tWaterZoneBySegment[iBuildLocationSegmentX][iBuildLocationSegmentZ] or 'nil')..' in pond '..iPond..' for iTeam='..iTeam..'; Expected pond for WZ='..(M28Map.tiPondByWaterZone[iWaterZone] or 'nil'))
                        end
                    end
                end

            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AssignValuesToWaterZones(iTeam)
    --Periodically cycles through every water zone and refreshes the unit details
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignValuesToWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        if bDebugMessages == true then LOG(sFunctionRef .. ': About to start the main loop for assigning values to water zones provided we have friendly M28 brains in the team ' .. iTeam .. '; is table empty=' .. tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))..'; Is M28Map.tPondDetails empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tPondDetails))) end
        local iCurValue
        if M28Utilities.IsTableEmpty(M28Map.tPondDetails) == false then
            FlagWaterZoneStartPositions(iTeam)


            while M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false do
                local iBaseCategory = M28UnitInfo.refCategoryNavalFactory
                for iPond, tPondSubtable in M28Map.tPondDetails do
                    if M28Utilities.IsTableEmpty(tPondSubtable[M28Map.subrefPondWaterZones]) == false then
                        for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
                            if bDebugMessages == true then LOG(sFunctionRef..': About to refresh value of iPond='..iPond..'; iWaterZone='..iWaterZone..' for team '..iTeam) end
                            --Decide on value of the water zone ignoring distance:
                            iCurValue = 1000
                            --Are we adjacent to a core base? If so increase the value; also increase value if we are a core base
                            local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                            if tWZTeamData[M28Map.subrefWZbCoreBase] then iCurValue = iCurValue * 2
                            elseif M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                                for iEntry, tAltWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                                    if M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tAltWZSubtable[M28Map.subrefWZAWZRef]][M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZbCoreBase] then
                                        iCurValue = iCurValue * 1.5
                                        break
                                    end
                                end
                            end

                            --Record the value
                            tWZTeamData[M28Map.subrefWZTValue] = iCurValue
                            tWZTeamData[M28Map.subrefWZbCoreBase] = nil

                            --Is this a core base water zone?
                            if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to set water zone '..iWaterZone..' in pond '..(M28Map.tiPondByWaterZone[iWaterZone] or 'nil')..' as a core base, does it contain naval build location='..tostring(tWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation])..'; M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]]='..(M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]] or 'nil')..'; Is table of allied units for this WZ empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subreftoLZOrWZAlliedUnits]))..'; iTeam='..iTeam..'; tWZTeamData[M28Map.subrefWZFactoryDestroyedCount]='..(tWZTeamData[M28Map.subrefWZFactoryDestroyedCount] or 'nil')) end
                            if tWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation] and (tWZTeamData[M28Map.subrefWZFactoryDestroyedCount] or 0) < 1 and ((M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]] or 0) > 0 or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Setting iWaterZone='..iWaterZone..' to be a WZ core base as it contains a naval build location') end
                                tWZTeamData[M28Map.subrefWZbCoreBase] = true
                            elseif M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                local tFactories = EntityCategoryFilterDown(iBaseCategory, tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subreftoLZOrWZAlliedUnits])
                                if M28Utilities.IsTableEmpty(tFactories) == false then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Setting iWaterZone='..iWaterZone..' to be a WZ core base as it contains factories') end
                                    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZbCoreBase] = true
                                end
                            end

                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitTicks(1)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        end
                    end
                end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
        end
    else
        M28Utilities.ErrorHandler('No active M28 brain')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function WaterZoneOverseer(iTeam)
    --Periodically cycles through every water zone and refreshes the unit details
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'WaterZoneOverseer'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    while not(M28Map.bWaterZoneInitialCreation) or not(M28Map.bFirstM28TeamHasBeenInitialised) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if GetGameTimeSeconds() >= 60 then break end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitSeconds(1) --make sure other code such as team initialisation has run
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)

    if aiBrain.HostileCampaignAI and tonumber(ScenarioInfo.Options.CmpAIDelay) > GetGameTimeSeconds() + 1 then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(tonumber(ScenarioInfo.Options.CmpAIDelay) - GetGameTimeSeconds()-1.0)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    if bDebugMessages == true then LOG(sFunctionRef..': About to start the main loop for water zones provided we have friendly M28 brains in the team '..iTeam..'; is table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        if ScenarioInfo.OpEnded and M28Map.bIsCampaignMap and GetGameTimeSeconds() <= 120 then
            while ScenarioInfo.OpEnded do
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) then break end
            end
        end
        ForkThread(AssignValuesToWaterZones, iTeam)
    end

    while M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false do
        if ScenarioInfo.OpEnded and M28Map.bIsCampaignMap and GetGameTimeSeconds() <= 120 then
            while ScenarioInfo.OpEnded do
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) then break end
            end
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) then break end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Will call logic to refresh every unit in a water zone') end
        ForkThread(ManageAllWaterZones, aiBrain, iTeam)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if aiBrain.M28IsDefeated and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
            aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': About to restart the loop for team '..iTeam..'; aiBrain referred to='..(aiBrain.Nickname or 'nil')..'; Is table of active m28 brains='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordClosestAdjacentRangesAndEnemies(tWZData, tWZTeamData, iPond, iWaterZone, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordClosestAdjacentRangesAndEnemies'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    tWZTeamData[M28Map.reftoNearestCombatEnemies] = {}

    local iEnemyBestAntiNavyRange = 0
    local iEnemyBestCombatRange = 0
    local iBestEnemyUnderwaterRange = 0


    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iTeam='..iTeam..'; iPond='..iPond..'; iWaterZone='..iWaterZone..'; Enemies in this or adjacent WZ='..tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])) end
    local iCurDistUntilInRange
    local iBaseWZMaxRadius = math.max(tWZData[M28Map.subrefWZMaxSegX] - tWZData[M28Map.subrefWZMinSegX], tWZData[M28Map.subrefWZMaxSegZ] - tWZData[M28Map.subrefWZMinSegZ])*M28Map.iLandZoneSegmentSize * 0.5
    local iDistThresholdToAlwaysInclude = iBaseWZMaxRadius + 20 --+20 to give an allowance since we will want to retreat before certain units get in range; also will be some cases where we are ordering a unit in an adjacent water zone
    local iLowestDistUntilInRange = 10000
    local oLowestDFDistUntilInRange
    if tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then
        iEnemyBestAntiNavyRange = (tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] or 0)
        iEnemyBestCombatRange = math.max((tWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0), iEnemyBestAntiNavyRange)
        iBestEnemyUnderwaterRange = (tWZTeamData[M28Map.subrefWZBestEnemySubmersibleRange] or 0)


        --Adjust the ranges to factor in adjacent water zones
        local tMidpoint = tWZData[M28Map.subrefMidpoint]
        if M28Utilities.IsTableEmpty(tMidpoint) then
            --Got an error in coop so put in below as a redundancy in case had no midpoint (but couldve been another reason)
            M28Utilities.ErrorHandler('No midpoint for water zone '..iWaterZone..' for iPond='..iPond..'; will try and record again')
            M28Map.RecordMidpointMinAndMaxSegmentForWaterZone(iWaterZone, iPond, tWZData)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Best DF range for this zone only='..tWZTeamData[M28Map.subrefWZBestEnemyDFRange]..'; best antinavy='..tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange]..';  Is table of adjacent WZs empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]))) end

        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': iBaseWZMaxRadius='..iBaseWZMaxRadius..'; iDistThresholdToAlwaysInclude='..iDistThresholdToAlwaysInclude) end
            for iEntry, iAdjWaterZone in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                iLowestDistUntilInRange = 10000
                oLowestDFDistUntilInRange = nil
                local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWaterZone]
                local tAltWZTeamData = tAltWZData[M28Map.subrefWZTeamData][iTeam]
                iEnemyBestAntiNavyRange = math.max(iEnemyBestAntiNavyRange, (tAltWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] or 0))
                iEnemyBestCombatRange = math.max(iEnemyBestCombatRange, iEnemyBestAntiNavyRange, (tAltWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0))
                iBestEnemyUnderwaterRange = math.max(iBestEnemyUnderwaterRange, (tAltWZTeamData[M28Map.subrefWZBestEnemySubmersibleRange] or 0))

                if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent WZ '..iAdjWaterZone..'; tAltWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange]='..tAltWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange]..'; tAltWZTeamData[M28Map.subrefWZBestEnemyDFRange]='..tAltWZTeamData[M28Map.subrefWZBestEnemyDFRange]..'; Enemy combat total='..(tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')) end
                if M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subrefTEnemyUnits]) == false and tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 10 then
                    if bDebugMessages == true then LOG(sFunctionRef..': iDistThresholdToAlwaysInclude='..iDistThresholdToAlwaysInclude..'; Adj WZ segX size='..(tAltWZData[M28Map.subrefWZMaxSegX] - tAltWZData[M28Map.subrefWZMinSegX])..'; Base WZ segX size='..(tWZData[M28Map.subrefWZMaxSegX] - tWZData[M28Map.subrefWZMinSegX])..'; Adj WZ segZ size='..(tAltWZData[M28Map.subrefWZMaxSegZ] - tAltWZData[M28Map.subrefWZMinSegZ])..'; Base WZ segZ size='..(tWZData[M28Map.subrefWZMaxSegZ] - tWZData[M28Map.subrefWZMinSegZ])..'; Land zone seg size='..M28Map.iLandZoneSegmentSize) end
                    for iUnit, oUnit in tAltWZTeamData[M28Map.subrefTEnemyUnits] do
                        if M28UnitInfo.IsUnitValid(oUnit) and (oUnit[M28UnitInfo.refiDFRange] > 0 or oUnit[M28UnitInfo.refiAntiNavyRange] > 0) and oUnit:GetFractionComplete() >= 0.95 then
                            iCurDistUntilInRange = M28Utilities.GetDistanceBetweenPositions((oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or oUnit:GetPosition()), tMidpoint) - math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiAntiNavyRange] or 0))
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit in adj zone='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDistUntilInRange='..iCurDistUntilInRange..'; iLowestDistUntilInRange='..iLowestDistUntilInRange..'; Actual dist to midpoint ignoring range='..M28Utilities.GetDistanceBetweenPositions((oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or oUnit:GetPosition()), tMidpoint)..'; AdjWZ X segment size='..(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWaterZone][M28Map.subrefWZMaxSegX] - M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWaterZone][M28Map.subrefWZMinSegX])*M28Map.iLandZoneSegmentSize..'; Base WZ Xsize='..(tWZData[M28Map.subrefWZMaxSegX] - tWZData[M28Map.subrefWZMinSegX])*M28Map.iLandZoneSegmentSize..'; iDistThresholdToAlwaysInclude='..iDistThresholdToAlwaysInclude ) end
                            if iCurDistUntilInRange < iLowestDistUntilInRange then
                                if iCurDistUntilInRange < iDistThresholdToAlwaysInclude then
                                    if iLowestDistUntilInRange > iDistThresholdToAlwaysInclude then
                                        iLowestDistUntilInRange = iDistThresholdToAlwaysInclude
                                        oLowestDFDistUntilInRange = nil
                                    end
                                    table.insert(tWZTeamData[M28Map.reftoNearestCombatEnemies], oUnit)
                                else
                                    oLowestDFDistUntilInRange = oUnit
                                    iLowestDistUntilInRange = iCurDistUntilInRange
                                end
                            end
                        end
                    end
                end
                if oLowestDFDistUntilInRange  then
                    table.insert(tWZTeamData[M28Map.reftoNearestCombatEnemies], oLowestDFDistUntilInRange)
                end
            end
        end

        --Add all units from this zone into reftoNearestCombatEnemies
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false and tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] then
            for iUnit, oUnit in tWZTeamData[M28Map.subrefTEnemyUnits] do
                if oUnit[M28UnitInfo.refiDFRange] > 0 or oUnit[M28UnitInfo.refiAntiNavyRange] > 0 then
                    table.insert(tWZTeamData[M28Map.reftoNearestCombatEnemies], oUnit)
                end
            end
        end
    end
    --Consider adding enemy shore based long ranged DF units here
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false and tWZData[M28Map.subrefMidpoint] then
        oLowestDFDistUntilInRange = nil
        local iRangeThresholdToInclude = math.min(64, iEnemyBestCombatRange + 1)
        for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
            iLowestDistUntilInRange = 10000
            local tAdjLZTeamData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefWPlatAndLZNumber][1]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefWPlatAndLZNumber][2]][M28Map.subrefLZTeamData][iTeam]
            if tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] >= iRangeThresholdToInclude or tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] >= iRangeThresholdToInclude then
                if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                    for iUnit, oUnit in tAdjLZTeamData[M28Map.reftoNearestDFEnemies] do
                        if oUnit[M28UnitInfo.refiDFRange] > iRangeThresholdToInclude and not(oUnit.Dead) then
                            iCurDistUntilInRange = M28Utilities.GetDistanceBetweenPositions((oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or oUnit:GetPosition()), tWZData[M28Map.subrefMidpoint]) - oUnit[M28UnitInfo.refiDFRange]
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy DF unit in adj land zone='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDistUntilInRange='..iCurDistUntilInRange..'; iLowestDistUntilInRange='..iLowestDistUntilInRange..'; Actual dist to midpoint ignoring range='..M28Utilities.GetDistanceBetweenPositions((oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or oUnit:GetPosition()), tWZData[M28Map.subrefMidpoint])..'; iDistThresholdToAlwaysInclude='..iDistThresholdToAlwaysInclude ) end
                            if iCurDistUntilInRange < iLowestDistUntilInRange then
                                if iCurDistUntilInRange < iDistThresholdToAlwaysInclude then
                                    if iLowestDistUntilInRange > iDistThresholdToAlwaysInclude then
                                        iLowestDistUntilInRange = iDistThresholdToAlwaysInclude
                                        oLowestDFDistUntilInRange = nil
                                    end
                                    table.insert(tWZTeamData[M28Map.reftoNearestCombatEnemies], oUnit)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Added unit to table of nearest combat enemies as it is within the distance to always include') end
                                else
                                    oLowestDFDistUntilInRange = oUnit
                                    iLowestDistUntilInRange = iCurDistUntilInRange
                                    if bDebugMessages == true then LOG(sFunctionRef..': Recording as oLowestDFDistUntilInRange, subject to another closer unit') end
                                end
                                iEnemyBestCombatRange = math.max(iEnemyBestCombatRange, oUnit[M28UnitInfo.refiDFRange])
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iEnemyBestCombatRange after considering adjacent land zone '..tSubtable[M28Map.subrefWPlatAndLZNumber][2]..'='..iEnemyBestCombatRange..'; tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]='..(tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 'nil')..'; tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange]='..(tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 'nil')) end
        end
        if oLowestDFDistUntilInRange  then
            table.insert(tWZTeamData[M28Map.reftoNearestCombatEnemies], oLowestDFDistUntilInRange)
            if bDebugMessages == true then LOG(sFunctionRef..': Adding oLowestDFDistUntilInRange='..oLowestDFDistUntilInRange.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLowestDFDistUntilInRange)..' to nearest combat enemies') end
        end
    end
    if iEnemyBestCombatRange > 1000 then M28Utilities.ErrorHandler('Enemy somehow calculated to have more than 1k range, iWaterZone='..iWaterZone) end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iEnemyBestAntiNavyRange='..iEnemyBestAntiNavyRange..'; iEnemyBestCombatRange='..iEnemyBestCombatRange..'; iBestEnemyUnderwaterRange='..iBestEnemyUnderwaterRange) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iEnemyBestAntiNavyRange, iEnemyBestCombatRange, iBestEnemyUnderwaterRange
end

function ConsiderOrdersForUnitsWithNoTarget(tWZData, iPond, iWaterZone, iTeam, tSubmarinesWithNoTarget, tCombatUnitsWithNoTarget, tMissileShips)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderOrdersForUnitsWithNoTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Handles logic for deciding where to send units to support other water zones (or returns units that could be used to support land zones), and also to handle bombardment logic
    local tUnassignedLandUnits
    local iOrderReissueDistToUse
    local iResisueOrderDistanceHover = 16
    local iReissueOrderDistanceStandard = 6

    --Do we have adjacent zones wanting reinforcements?
    local iSubmersibleWZToSupport
    local iNoAntiNavyWZToSupport
    local iWZToSupport

    local tUnitsWithOnlyAntiNavy = tSubmarinesWithNoTarget
    if not(tUnitsWithOnlyAntiNavy) then tUnitsWithOnlyAntiNavy = {} end
    local tUnitsWithNoAntiNavy = {}
    local tUnitsWithAntiNavyAndSurface = {}
    local tPotentialBombardmentUnits
    if M28Utilities.IsTableEmpty(tCombatUnitsWithNoTarget) == false then
        for iUnit, oUnit in tCombatUnitsWithNoTarget do
            if (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) == 0 then
                table.insert(tUnitsWithNoAntiNavy, oUnit)
            else
                if (oUnit[M28UnitInfo.refiDFRange] or 0) == 0 then
                    table.insert(tUnitsWithOnlyAntiNavy, oUnit)
                else
                    table.insert(tUnitsWithAntiNavyAndSurface, oUnit)
                end
            end
        end
    end
    local bHaveSubs = not(M28Utilities.IsTableEmpty(tUnitsWithOnlyAntiNavy))


    if bDebugMessages == true then LOG(sFunctionRef..': Dont have any enemy units in this WZ or adjacent WZ, so will consider supporting other water zones, is table of other zones empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]))) end
    local bSupportLowValueRequests = true
    local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
    if tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] + tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] <= 400 then
        bSupportLowValueRequests = false
    end
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
        local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
        for iEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
            local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tWZSubtable[M28Map.subrefWZAWZRef]]
            if bDebugMessages == true then LOG(sFunctionRef..': Considering WZ '..tWZSubtable[M28Map.subrefWZAWZRef]..'; Is the midpoint in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAltWZData[M28Map.subrefMidpoint]))) end
            if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAltWZData[M28Map.subrefMidpoint]) then
                local tAltWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tWZSubtable[M28Map.subrefWZAWZRef]][M28Map.subrefWZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': Considering water zone '..tWZSubtable[M28Map.subrefWZAWZRef]..'; Does this want support='..tostring(tAltWZTeamData[M28Map.subrefbWZWantsSupport])..'; Combat threat wanted='..(tAltWZTeamData[M28Map.subrefWZCombatThreatWanted] or 'nil')) end
                if tAltWZTeamData[M28Map.subrefbWZWantsSupport] and (bSupportLowValueRequests or (tAltWZTeamData[M28Map.subrefWZCombatThreatWanted] or 0) >= 40) then
                    if not(iWZToSupport) then iWZToSupport = tWZSubtable[M28Map.subrefWZAWZRef] end
                    if bHaveSubs and not(iSubmersibleWZToSupport) then
                        if not(tAltWZTeamData[M28Map.subrefbWZOnlyHoverEnemies]) then
                            iSubmersibleWZToSupport = tWZSubtable[M28Map.subrefWZAWZRef]
                        end
                    end
                    if not(iNoAntiNavyWZToSupport) and not(tAltWZTeamData[M28Map.subrefbWZOnlySubmersibleEnemies]) then
                        iNoAntiNavyWZToSupport = tWZSubtable[M28Map.subrefWZAWZRef]
                    end
                    if iNoAntiNavyWZToSupport and iWZToSupport and (iSubmersibleWZToSupport or not(bHaveSubs)) then
                        break
                    end
                end
            end
        end
    end

    --Decide on what to do based on the units we have:
    --Subs
    if M28Utilities.IsTableEmpty(tUnitsWithOnlyAntiNavy) == false then
        --Subs - send to nearest WZ wanting sub support; if is none, then send to nearest WZ wanting support; if is none, then do nothing
        if bDebugMessages == true then LOG(sFunctionRef..': Sending subs to nearest WZ wanting sub support, or if none then nearest WZ wanting support, iSubmersibleWZToSupport='..(iSubmersibleWZToSupport or 'nil')..'; iWZToSupport='..(iWZToSupport or 'nil')) end
        if not(iSubmersibleWZToSupport) then iSubmersibleWZToSupport = iWZToSupport end
        if iSubmersibleWZToSupport then
            local tSupportWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iSubmersibleWZToSupport]
            for iUnit, oUnit in tUnitsWithOnlyAntiNavy do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering sub unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[refiCurrentWZAssignmentValue]='..oUnit[refiCurrentWZAssignmentValue]..'; oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam]='..oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam]..'; iWaterZone='..iWaterZone) end
                if not(oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iWaterZone) then
                    --Unit is from a different zone - need to change the value of its assignment so it is considered for orders by the zone that it is part of
                    oUnit[refiCurrentWZAssignmentValue] = 0
                else
                    M28Orders.IssueTrackedMove(oUnit, tSupportWZData[M28Map.subrefMidpoint], iReissueOrderDistanceStandard, false, 'NSDFMovWZ' .. iWZToSupport .. ';' .. iWaterZone)
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Have no WZ to support so no orders to give subs') end
        end
    end
    local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
    --Units with surface attack but no antinavy attack - switch to bombardment mode if nowhere to support; also use attack-move if have decent range and not blocked shot
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of units with no anti navy empty='..tostring(M28Utilities.IsTableEmpty(tUnitsWithNoAntiNavy))..'; iNoAntiNavyWZToSupport='..(iNoAntiNavyWZToSupport or 'nil')) end
    if M28Utilities.IsTableEmpty(tUnitsWithNoAntiNavy) == false then
        if not(iNoAntiNavyWZToSupport) then
            tUnassignedLandUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryAmphibiousCombat, tUnitsWithNoAntiNavy)
            tPotentialBombardmentUnits = EntityCategoryFilterDown(categories.ALLUNITS - M28UnitInfo.refCategoryAmphibiousCombat, tUnitsWithNoAntiNavy)
        else
            local tSupportWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iNoAntiNavyWZToSupport]
            if bDebugMessages == true then LOG(sFunctionRef..': Combat threat wanted by zone='..(tSupportWZData[M28Map.subrefWZCombatThreatWanted] or 'nil')) end
            for iUnit, oUnit in tUnitsWithNoAntiNavy do
                if bDebugMessages == true then LOG(sFunctionRef..': Getting unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to move to the support WZ='..iNoAntiNavyWZToSupport..' unless it is assigned to a dif zone to this, iWaterZone='..iWaterZone..'; oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam]='..oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam]) end
                if not(oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iWaterZone) then
                    --Unit is from a different zone - need to change the value of its assignment so it is considered for orders by the zone that it is part of
                    oUnit[refiCurrentWZAssignmentValue] = 0
                    if bDebugMessages == true then LOG(sFunctionRef..': Setting unit assignment value to 0') end
                else
                    if EntityCategoryContains(categories.HOVER, oUnit.UnitId) then iOrderReissueDistToUse = iResisueOrderDistanceHover
                    else iOrderReissueDistToUse = iReissueOrderDistanceStandard
                    end
                    if oUnit[M28UnitInfo.refiCombatRange] >= 40 and (not(oUnit[M28UnitInfo.refbLastShotBlocked]) or (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) <= 10 or GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) > 6) then
                        M28Orders.IssueTrackedAggressiveMove(oUnit, tSupportWZData[M28Map.subrefMidpoint], iOrderReissueDistToUse, false, 'NSFAMovWZ' .. iWZToSupport .. ';' .. iWaterZone)
                    else
                        M28Orders.IssueTrackedMove(oUnit, tSupportWZData[M28Map.subrefMidpoint], iOrderReissueDistToUse, false, 'NSFMovWZ' .. iWZToSupport .. ';' .. iWaterZone)
                    end
                end
            end
        end
    end

    --Units with both surface attack and antinavy attack
    if M28Utilities.IsTableEmpty(tUnitsWithAntiNavyAndSurface) == false then
        if not(iWZToSupport) then
            local tAmphibiousCombat = EntityCategoryFilterDown(M28UnitInfo.refCategoryAmphibiousCombat, tUnitsWithAntiNavyAndSurface)
            local tOtherNavy = EntityCategoryFilterDown(categories.ALLUNITS - M28UnitInfo.refCategoryAmphibiousCombat, tUnitsWithAntiNavyAndSurface)
            if not(tUnassignedLandUnits) then tUnassignedLandUnits = tAmphibiousCombat
            else
                if M28Utilities.IsTableEmpty(tAmphibiousCombat) == false then
                    for iUnit, oUnit in tAmphibiousCombat do
                        table.insert(tUnassignedLandUnits, oUnit)
                    end
                end
            end
            if not(tPotentialBombardmentUnits) then tPotentialBombardmentUnits = tOtherNavy
            else
                if M28Utilities.IsTableEmpty(tOtherNavy) == false then
                    for iUnit, oUnit in tOtherNavy do
                        table.insert(tPotentialBombardmentUnits, oUnit)
                    end
                end
            end
        else
            local tSupportWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWZToSupport]
            for iUnit, oUnit in tUnitsWithAntiNavyAndSurface do
                if not(oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iWaterZone) then
                    --Unit is from a different zone - need to change the value of its assignment so it is considered for orders by the zone that it is part of
                    oUnit[refiCurrentWZAssignmentValue] = 0
                else
                    if EntityCategoryContains(categories.HOVER, oUnit.UnitId) then iOrderReissueDistToUse = iResisueOrderDistanceHover
                    else iOrderReissueDistToUse = iReissueOrderDistanceStandard
                    end
                    M28Orders.IssueTrackedMove(oUnit, tSupportWZData[M28Map.subrefMidpoint], iOrderReissueDistToUse, false, 'NSFBMovWZ' .. iWZToSupport .. ';' .. iWaterZone)
                end
            end
        end
    end
    local bOnlyBombardmentIsMissileShip = false
    if M28Utilities.IsTableEmpty(tMissileShips) == false then
        if not(tPotentialBombardmentUnits) then
            tPotentialBombardmentUnits = tMissileShips
            bOnlyBombardmentIsMissileShip = true
        else
            for iUnit, oUnit in tMissileShips do
                table.insert(tPotentialBombardmentUnits, oUnit)
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Is table of bombardment units empty='..tostring(M28Utilities.IsTableEmpty(tPotentialBombardmentUnits))) end
    if M28Utilities.IsTableEmpty(tPotentialBombardmentUnits) == false then
        --consider doing via a separate function based on a set of units both to keep code tidy and incase we end up wanting to give certain untis bombardment orders from the main logic above
        --AssignBombardmentActions(tWZData, iPond, iWaterZone, iTeam, tPotentialBombardmentUnits, tbOptionalPlateauAndLandZonesToConsider, iOptionalRaidBaseWZ, bOptionalDontTreatAsBombardment)
        AssignBombardmentActions(tWZData, iPond, iWaterZone, iTeam, tPotentialBombardmentUnits,     nil,                                    nil,                bOnlyBombardmentIsMissileShip)
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tUnassignedLandUnits
end

function AssignBombardmentActions(tWZData, iPond, iWaterZone, iTeam, tPotentialBombardmentUnits, tbOptionalPlateauAndLandZonesToConsider, iOptionalRaidBaseWZ, bOptionalDontTreatAsBombardment)
    --tbOptionalPlateauAndLandZonesToConsider - if not empty, then will only consider targets in the same plateau and land zone as this (table which returns true for tbOptionalPlateauAndLandZonesToConsider[iPlateau][iLandZone])
    --iOptionalRaidBaseWZ - need to set if calling from raid logic so can refresh raid locations if no target
    --bOptionalDontTreatAsBombardment - further manual flag (if set to true) to not treat this as bombardment mode - e.g. for units like missile ships that only have a bombardment mode

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignBombardmentActions'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if M28Utilities.IsTableEmpty(tPotentialBombardmentUnits) == false and not(tbOptionalPlateauAndLandZonesToConsider) and not(iOptionalRaidBaseWZ) and not(bOptionalDontTreatAsBombardment) then
        M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBombardmentModeByPond] = GetGameTimeSeconds()
    end

    local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
    --Campaign specific - if have pacifist zones adjacent to here then dont do bomardment
    if M28Overseer.bPacifistModeActive and M28Conditions.AdjacentToPacifistZone(0, iWaterZone) then
        if bDebugMessages == true then LOG(sFunctionRef..': Considering water zone '..iWaterZone..'; Has a nearby pacifist zone so will abort bombardment logic, time='..GetGameTimeSeconds()) end
        local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
        for iUnit, oUnit in tPotentialBombardmentUnits do
            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 5, false, 'PacifistRal', false)
        end
    else
        local bGetDFRangeOfBombardmentUnits = false
        local iOurBestDFRange = tWZTeamData[M28Map.subrefWZBestAlliedDFRange]
        if tWZTeamData[M28Map.refiMAACombatRangeWithoutTarget] and iOurBestDFRange <= tWZTeamData[M28Map.refiMAACombatRangeWithoutTarget] then
            bGetDFRangeOfBombardmentUnits = true
            iOurBestDFRange = 0
        end
        local iOurBestIndirectRange = 0
        --Get nearest friendly DF/IF unit near enemy base, and record max indirect range
        local iCurUnitDist
        local oClosestFriendlyUnitToEnemyBase
        local iClosestUnitDist = 100000
        local tClosestEnemyBase = tWZTeamData[M28Map.reftClosestEnemyBase]
        local tOurBase = {tWZTeamData[M28Map.reftClosestFriendlyBase][1], tWZTeamData[M28Map.reftClosestFriendlyBase][2], tWZTeamData[M28Map.reftClosestFriendlyBase][3]}
        local bConsiderGroundAttack = false

        for iUnit, oUnit in tPotentialBombardmentUnits do
            if not(oClosestFriendlyUnitToEnemyBase) then oClosestFriendlyUnitToEnemyBase = oUnit end --redundancy to make sure we always have a closest unit
            iOurBestIndirectRange = math.max(iOurBestIndirectRange, (oUnit[M28UnitInfo.refiIndirectRange] or 0))
            if (oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0 or (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then
                if bGetDFRangeOfBombardmentUnits then iOurBestDFRange = math.max(iOurBestDFRange,(oUnit[M28UnitInfo.refiDFRange] or 0)) end
                iCurUnitDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tClosestEnemyBase)
                if iCurUnitDist < iClosestUnitDist then
                    iClosestUnitDist = iCurUnitDist
                    oClosestFriendlyUnitToEnemyBase = oUnit
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Near Start of code at time '..GetGameTimeSeconds()..'; iPond='..iPond..'; iTeam='..iTeam..'; iOptionalRaidBaseWZ='..(iOptionalRaidBaseWZ or 'nil')..'; tWZTeamData[M28Map.refiMAACombatRangeWithoutTarget]='..(tWZTeamData[M28Map.refiMAACombatRangeWithoutTarget] or 'nil')..'; bGetDFRangeOfBombardmentUnits='..tostring(bGetDFRangeOfBombardmentUnits)..'; iOurBestDFRange='..iOurBestDFRange) end
        local tNonBombardmentRallyPoint = M28Utilities.MoveInDirection(oClosestFriendlyUnitToEnemyBase:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestFriendlyUnitToEnemyBase:GetPosition(), tWZTeamData[M28Map.reftClosestFriendlyBase]), 20, true, false, true)
        --Update the range to search for enemy units
        local iBombardmentSearchRange = math.max(22, (tWZTeamData[M28Map.refiLastBombardmentSearchRange] or 1))
        if iOurBestDFRange >= 60 then iBombardmentSearchRange = math.max(50, iBombardmentSearchRange) end
        if not(tWZTeamData[M28Map.refbLastBombardmentSearchRangeSuccess]) then
            iBombardmentSearchRange = iBombardmentSearchRange + 2
        end
        tWZTeamData[M28Map.refiLastBombardmentSearchRange] = iBombardmentSearchRange

        local iBombardmentBuildingCategory = M28UnitInfo.refCategoryStructure
        local bIgnoreLowThreats = false
        if tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= 6500 or iOurBestIndirectRange >= 175 then
            iBombardmentBuildingCategory = iBombardmentBuildingCategory - categories.TECH1 + M28UnitInfo.refCategoryTorpedoLauncher + M28UnitInfo.refCategoryHoverPD
        end

        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        if aiBrain then

            local iCurDist
            local iClosestMexDist = 100000
            local tBasePoint = tWZData[M28Map.subrefMidpoint]
            local iMaxSearchRange, iClosestMexRef
            local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
            local bTargetInDesiredZone = true

            --Cycle through mexes in this pond looking for mexes to bombard
            if bDebugMessages == true then LOG(sFunctionRef..': Searching for mexes in this pond to bombard, iPond='..iPond..'; iOurBestDFRange='..(iOurBestDFRange or 'nil')..'; iBombardmentSearchRange='..iBombardmentSearchRange..'; iOurBestIndirectRange='..(iOurBestIndirectRange or 'nil')) end
            if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo]) == false then
                for iMex, tMexInfo in M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo] do
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Considering mex at position '..repru(tMexInfo[M28Map.subrefMexLocation])..'; Mex DF distance='..tMexInfo[M28Map.subrefMexDFDistance]..'; Mex indirect distance='..tMexInfo[M28Map.subrefMexIndirectDistance]..'; Is underwater='..tostring(M28Map.IsUnderwater(tMexInfo[M28Map.subrefMexLocation]))..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tMexInfo[M28Map.subrefMexLocation]))..'; M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFUnblockedLocation]='..repru(M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFUnblockedLocation]))
                        if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFUnblockedLocation]) == false then
                            local iMexPlateauOrZero, iMexLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFUnblockedLocation])
                            LOG(sFunctionRef..': DF Unblocked location plateau and water zone ref: iMexPlateauOrZero='..(iMexPlateauOrZero or 'nil')..'; iMexLandOrWaterZone='..(iMexLandOrWaterZone or 'nil'))
                            if iMexPlateauOrZero == 0 and iMexLandOrWaterZone > 0 then
                                local iMexSegmentX, iMexSegmentZ = M28Map.GetPathingSegmentFromPosition(M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFUnblockedLocation])
                                LOG(sFunctionRef..': POnd ref for this blocked location='..(M28Map.tWaterZoneBySegment[iMexSegmentX][iMexSegmentZ] or 'nil'))
                            end
                        end
                    end
                    if tMexInfo[M28Map.subrefMexDFDistance] <= iOurBestDFRange or tMexInfo[M28Map.subrefMexIndirectDistance] <= iOurBestIndirectRange then
                        if not(M28Map.IsUnderwater(tMexInfo[M28Map.subrefMexLocation])) and (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tMexInfo[M28Map.subrefMexLocation])) then
                            if tbOptionalPlateauAndLandZonesToConsider then
                                local iMexPlateauOrZero, iMexLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tMexInfo[M28Map.subrefMexLocation])
                                bTargetInDesiredZone = (tbOptionalPlateauAndLandZonesToConsider[iMexPlateauOrZero][iMexLandOrWaterZone] or false)
                            end
                            if bTargetInDesiredZone then
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(tMexInfo[M28Map.subrefMexLocation], tBasePoint)
                                if bDebugMessages == true then LOG(sFunctionRef .. ': iCurDist to our closest navla unit=' .. iCurDist .. '; iClosestMexDist=' .. iClosestMexDist) end
                                if iCurDist < iClosestMexDist then
                                    --Does the enemy have any buildings near here?
                                    iMaxSearchRange = 200
                                    if tMexInfo[M28Map.subrefMexIndirectDistance] <= iOurBestIndirectRange then
                                        iMaxSearchRange = iOurBestIndirectRange - tMexInfo[M28Map.subrefMexIndirectDistance]
                                    end
                                    if tMexInfo[M28Map.subrefMexDFDistance] <= iOurBestDFRange and iOurBestDFRange >= iOurBestIndirectRange then
                                        iMaxSearchRange = iOurBestDFRange - tMexInfo[M28Map.subrefMexDFDistance]
                                    end
                                    iMaxSearchRange = math.max(2, iMaxSearchRange)
                                    local tEnemyBuildings = aiBrain:GetUnitsAroundPoint(iBombardmentBuildingCategory, tMexInfo[M28Map.subrefMexLocation], math.min(iBombardmentSearchRange, iMaxSearchRange), 'Enemy')
                                    if bDebugMessages == true then LOG(sFunctionRef .. ': Is table of enemy buildings around mex empty=' .. tostring(M28Utilities.IsTableEmpty(tEnemyBuildings))..'; iBombardmentSearchRange='..iBombardmentSearchRange..'; iMaxSearchRange='..iMaxSearchRange) end
                                    if M28Utilities.IsTableEmpty(tEnemyBuildings) == false then
                                        iClosestMexDist = iCurDist
                                        iClosestMexRef = iMex
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for mexes to bombard, iClosestMexRef='..(iClosestMexRef or 'nil')) end
            if not (iClosestMexRef) and math.max(iOurBestDFRange, iOurBestIndirectRange) >= 60 then
                tWZTeamData[M28Map.refbLastBombardmentSearchRangeSuccess] = false
            else
                --Treat as success even if didnt find anything if have poor range
                tWZTeamData[M28Map.refbLastBombardmentSearchRangeSuccess] = true
            end

            --Get details of locations where shots shouldnt be blocked (if targeting mexes)
            local tClosestMex, iDFMinRange, iIndirectMinRange, tBlockedShotBaseMoveLocation
            if iClosestMexRef then
                tClosestMex = M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexLocation]
                --Attack-move to nearest mex; for units that wont be in range to attack the mex position, attack-move towards our base by 10 below the bombardment range
                iDFMinRange = M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFDistance]
                if iDFMinRange == 0 then
                    iDFMinRange = 150
                end
                iIndirectMinRange = M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexIndirectDistance]
                if iIndirectMinRange == 0 then
                    iIndirectMinRange = 150
                end
                tBlockedShotBaseMoveLocation = (M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFUnblockedLocation] or tClosestMex)

            else
                --tNonBombardmentRallyPoint = {tEnemyBase[1], tEnemyBase[2], tEnemyBase[3]}
                iDFMinRange = iOurBestDFRange
                iIndirectMinRange = math.min(120, iOurBestIndirectRange)
                if bDebugMessages == true then LOG(sFunctionRef..': No mexes to consider so will just have the enemy base as the main bombardment target') end
            end


            --Get the target
            local tBombardmentMainTarget
            if iClosestMexRef then tBombardmentMainTarget = {tClosestMex[1], tClosestMex[2], tClosestMex[3]}
            else
                tBombardmentMainTarget = {tWZTeamData[M28Map.reftClosestEnemyBase][1], tWZTeamData[M28Map.reftClosestEnemyBase][2], tWZTeamData[M28Map.reftClosestEnemyBase][3]}
            end
            --Adjust target if this is a campaign to just get the closest enemy unit that is in the playable area
            if bDebugMessages == true then LOG(sFunctionRef..': Is campaign map='..tostring(M28Map.bIsCampaignMap)..'; Cur bombardment location='..repru(tBombardmentMainTarget)..'; iClosestMexRef='..(iClosestMexRef or 'nil')..'; Is target in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tBombardmentMainTarget))) end
            local oClosestEnemyUnit
            if (tbOptionalPlateauAndLandZonesToConsider and not(iClosestMexRef)) or (M28Map.bIsCampaignMap and (not(iClosestMexRef) or not(M28Conditions.IsLocationInPlayableArea(tBombardmentMainTarget)))) then
                --First consider targeting something other than the nearest enemy base in campaign - e.g. cycle through all water zones and see if there are enemy structures that we can target
                --if not(iClosestMexRef) then
                function ConsiderAdjacentLandZonesForBombardment(tCurWZData)
                    if bDebugMessages == true then LOG(sFunctionRef..': Is cur wz in playable area='..tostring(tCurWZData[M28Map.subrefMidpoint])) end
                    if M28Conditions.IsLocationInPlayableArea(tCurWZData[M28Map.subrefMidpoint]) then
                        local iAdjLZ, iAdjPlateau, iCurDist
                        local iClosestDist = 100000
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of adjacent land zones empty='..tostring(M28Utilities.IsTableEmpty(tCurWZData[M28Map.subrefAdjacentLandZones]))) end
                        if M28Utilities.IsTableEmpty(tCurWZData[M28Map.subrefAdjacentLandZones]) == false then
                            for iEntry, tLZSubtable in tCurWZData[M28Map.subrefAdjacentLandZones] do
                                iAdjPlateau = tLZSubtable[M28Map.subrefWPlatAndLZNumber][1]
                                iAdjLZ = tLZSubtable[M28Map.subrefWPlatAndLZNumber][2]
                                if not(tbOptionalPlateauAndLandZonesToConsider) or tbOptionalPlateauAndLandZonesToConsider[iAdjPlateau][iAdjLZ] then
                                    local tAdjLZData = M28Map.tAllPlateaus[iAdjPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjPlateau='..iAdjPlateau..'; iAdjLZ='..iAdjLZ..'; Is midpoint of this LZ in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]))) end
                                    if M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]) then
                                        local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                                        if bDebugMessages == true then LOG(sFunctionRef..': Dangerous enemies in this LZ='..tostring(tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])..'; Enemy structure total mass='..tAdjLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]))) end
                                        if tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] or tAdjLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] >= 30 then
                                            --Get the closest enemy to here
                                            for iUnit, oUnit in tAdjLZTeamData[M28Map.subrefTEnemyUnits] do
                                                if M28UnitInfo.IsUnitValid(oUnit) then
                                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tCurWZData[M28Map.subrefMidpoint], oUnit:GetPosition())
                                                    if iCurDist < iClosestDist and M28Conditions.IsLocationInPlayableArea(oUnit:GetPosition()) then
                                                        iClosestDist = iCurDist
                                                        oClosestEnemyUnit = oUnit

                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                --First check adjacent land zones
                ConsiderAdjacentLandZonesForBombardment(tWZData)
                if not(oClosestEnemyUnit) then
                    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                        local iAdjWZ
                        for iWZEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                            iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                            local tAdjWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
                            if bDebugMessages == true then LOG(sFunctionRef..': About to consider if enmy land zones adjacent to iAdjWZ='..iAdjWZ..' have enemy units in them') end
                            ConsiderAdjacentLandZonesForBombardment(tAdjWZData)
                            if oClosestEnemyUnit then break end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished checking adjacent land zones for untis for bombardment. is oClosestEnemyUnit valid='..tostring(M28UnitInfo.IsUnitValid(oClosestEnemyUnit))..'; iOptionalRaidBaseWZ='..(iOptionalRaidBaseWZ or 'nil')) end
                if tbOptionalPlateauAndLandZonesToConsider and iOptionalRaidBaseWZ then
                    local tRaidWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iOptionalRaidBaseWZ]][M28Map.subrefPondWaterZones][iOptionalRaidBaseWZ]
                    local tRaidWZTeamData = tRaidWZData[M28Map.subrefWZTeamData][iTeam]
                    if M28UnitInfo.IsUnitValid(tRaidWZTeamData[M28Map.refoLastRaidTarget]) then
                        if not(oClosestEnemyUnit) then
                            oClosestEnemyUnit = tRaidWZTeamData[M28Map.refoLastRaidTarget]
                            if bDebugMessages == true then LOG(sFunctionRef..': Setting closest enemy unit as the raid target') end
                        elseif tRaidWZTeamData[M28Map.refiMinRangeRaidingZone] and not(oClosestEnemyUnit == tRaidWZTeamData[M28Map.refoLastRaidTarget]) then
                            --Is the range to hit the raid target better than the closest enemy unit?
                            local iCurRangeRequired, iWZForShot = GetMinDFDistanceForShotFromWaterToHitUnit(aiBrain, tWZData[M28Map.subrefMidpoint], M28Map.tiPondByWaterZone[iOptionalRaidBaseWZ], oClosestEnemyUnit, tRaidWZTeamData[M28Map.refiMinRangeRaidingZone])
                            if bDebugMessages == true then LOG(sFunctionRef..': Are raiding, but closest enemy unit is different to the last raid target, oClosestEnemyUnit='..oClosestEnemyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyUnit)..'; tRaidWZTeamData[M28Map.refoLastRaidTarget]='..tRaidWZTeamData[M28Map.refoLastRaidTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(tRaidWZTeamData[M28Map.refoLastRaidTarget])..'; iCurRangeRequired for lcosest enemy='..iCurRangeRequired..'; tRaidWZTeamData[M28Map.refiMinRangeRaidingZone]='..tRaidWZTeamData[M28Map.refiMinRangeRaidingZone]) end
                            if iCurRangeRequired > tRaidWZTeamData[M28Map.refiMinRangeRaidingZone] then
                                oClosestEnemyUnit = tRaidWZTeamData[M28Map.refoLastRaidTarget]
                                if bDebugMessages == true then LOG(sFunctionRef..': Changing closest enemy unit to be the raid target') end
                            end
                        end
                    end
                end
                if oClosestEnemyUnit then
                    tBombardmentMainTarget = oClosestEnemyUnit:GetPosition()
                    bConsiderGroundAttack = true
                    --Adjust main target if units have had shots blocked against it before for which we have a blocked move location
                    if bDebugMessages == true then LOG(sFunctionRef..': Will target closest enemy unit '..oClosestEnemyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyUnit)..'; Position of this='..repru(oClosestEnemyUnit:GetPosition())..'; oClosestEnemyUnit[reftBlockedShotLocationByPond]='..repru(oClosestEnemyUnit[reftBlockedShotLocationByPond])..'; iPond='..iPond) end
                    if M28Utilities.IsTableEmpty(oClosestEnemyUnit[reftBlockedShotLocationByPond][iPond]) == false then
                        tBlockedShotBaseMoveLocation = {oClosestEnemyUnit[reftBlockedShotLocationByPond][iPond][1], oClosestEnemyUnit[reftBlockedShotLocationByPond][iPond][2], oClosestEnemyUnit[reftBlockedShotLocationByPond][iPond][3]}
                    end
                elseif tbOptionalPlateauAndLandZonesToConsider then
                    --Raiders - no targets so clear flag
                    if not(iOptionalRaidBaseWZ) then M28Utilities.ErrorHandler('Failed to specify base WZ for raid logic')
                    else
                        RefreshRaidingNavalLocations(iOptionalRaidBaseWZ, iTeam)
                    end
                else

                    --Dont have a valid closest enemy unit and are outside playable area
                    --Adjust to the nearest location on map to the bombardment target

                    --end
                    local iInterval = 30
                    local iDistFromBase = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], tBombardmentMainTarget)
                    local iMaxDist = math.floor(iDistFromBase / iInterval) * iInterval
                    local iAngleFromTargetToMidpoint = M28Utilities.GetAngleFromAToB(tWZData[M28Map.subrefMidpoint], tBombardmentMainTarget)
                    if bDebugMessages == true then LOG(sFunctionRef..': Bombardment target is outside playable area so will try and adjust, playable area='..repru(M28Map.rMapPlayableArea)..'; Sync.NewPlayableArea='..repru(Sync.NewPlayableArea)) end
                    for iCurDist = iInterval, iMaxDist, iInterval do
                        local tRevisedTarget = M28Utilities.MoveInDirection(tBombardmentMainTarget, iAngleFromTargetToMidpoint, iCurDist, true, false, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': iCurDist='..iCurDist..'; tRevisedTarget='..repru(tRevisedTarget)..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tRevisedTarget))) end
                        if tRevisedTarget and M28Conditions.IsLocationInPlayableArea(tRevisedTarget) then
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Adjusting bombardment target, iCurDist='..iCurDist..'; tRevisedTarget='..repru(tRevisedTarget)..'; tBombardmentMainTarget before adjust='..repru(tBombardmentMainTarget)..'; Map playable area='..repru(M28Map.rMapPlayableArea))
                                M28Utilities.DrawLocation(tRevisedTarget)
                            end
                            tBombardmentMainTarget = {tRevisedTarget[1], tRevisedTarget[2], tRevisedTarget[3]}
                            break
                        end
                    end
                end
            end



            --Get nearby enemy defences
            local iSearchRange = math.max(iIndirectMinRange + 50, iDFMinRange + 50, 150)
            local tEnemyCombatNearFrontUnit = aiBrain:GetUnitsAroundPoint(iBombardmentBuildingCategory + M28UnitInfo.refCategoryLandCombat, oClosestFriendlyUnitToEnemyBase:GetPosition(), iSearchRange, 'Enemy')
            local tEnemyDefences = {}
            if M28Utilities.IsTableEmpty(tEnemyCombatNearFrontUnit) == false then
                tEnemyDefences = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD + M28UnitInfo.refCategoryFixedT2Arti, tEnemyCombatNearFrontUnit)
            end
            local tEnemyShieldsAndTMD
            if iSearchRange >= iOurBestIndirectRange + 10 then
                if M28Utilities.IsTableEmpty(tEnemyCombatNearFrontUnit) == false then
                    tEnemyShieldsAndTMD = EntityCategoryFilterDown(M28UnitInfo.refCategoryTMD + M28UnitInfo.refCategoryFixedShield, tEnemyCombatNearFrontUnit)
                end
            else
                tEnemyShieldsAndTMD = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryTMD + M28UnitInfo.refCategoryFixedShield, oClosestFriendlyUnitToEnemyBase:GetPosition(), iOurBestIndirectRange + 10, 'Enemy')
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Is tEnemyShieldsAndTMD empty='..tostring(M28Utilities.IsTableEmpty(tEnemyShieldsAndTMD)))
                    if M28Utilities.IsTableEmpty(tEnemyShieldsAndTMD) == false then
                        for iUnit, oUnit in tEnemyShieldsAndTMD do
                            LOG(sFunctionRef..': Cycling through tEnemyShieldsAndTMD, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Dist to front unit='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFriendlyUnitToEnemyBase:GetPosition()))
                        end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
                --Probably easier to just cycle through enemy experimentals rather than adjacent land zones
                for iExperimental, oExperimental in M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
                    if bDebugMessages == true then if M28UnitInfo.IsUnitValid(oExperimental) then LOG(sFunctionRef..': Dist from oExperimental to oClosestFriendlyUnitToEnemyBase='..M28Utilities.GetDistanceBetweenPositions(oExperimental:GetPosition(), oClosestFriendlyUnitToEnemyBase:GetPosition())..'; iSearchRange='..iSearchRange..'; Fraction complete='..oExperimental:GetFractionComplete()) end end
                    if M28UnitInfo.IsUnitValid(oExperimental) and oExperimental:GetFractionComplete() >= 0.95 and M28Utilities.GetDistanceBetweenPositions(oExperimental:GetPosition(), oClosestFriendlyUnitToEnemyBase:GetPosition()) <= iSearchRange + 5 then
                        table.insert(tEnemyDefences, oExperimental)
                    end
                end
            end

            local bCheckForBuildingsToAttack = true
            local bCheckForDangerousDefences = false
            local bRetreatUnit
            if M28Utilities.IsTableEmpty(tEnemyCombatNearFrontUnit) then
                if bDebugMessages == true then LOG(sFunctionRef .. ': No enemy structures within a range of iSearchRange='..iSearchRange..'; Min IF range='..iIndirectMinRange..'; iDFMinRange='..iDFMinRange..'; iOurBestIndirectRange='..(iOurBestIndirectRange or 'nil') .. ' of the unit closest to the enemy base') end
                bCheckForBuildingsToAttack = false
            elseif bDebugMessages == true then
                for iUnit, oUnit in tEnemyCombatNearFrontUnit do
                    LOG(sFunctionRef..': Going through tEnemyCombatNearFrontUnit, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Dist to oClosestFriendlyUnitToEnemyBase='..M28Utilities.GetDistanceBetweenPositions(oClosestFriendlyUnitToEnemyBase:GetPosition(), oUnit:GetPosition()))
                end
            end
            --Add under construction experimentals to the buildings to attack
            local tEnemyExperimentals = aiBrain:GetUnitsAroundPoint(categories.EXPERIMENTAL - categories.STRUCTURE - M28UnitInfo.refCategorySatellite, oClosestFriendlyUnitToEnemyBase:GetPosition(), math.max(iIndirectMinRange + 50, iDFMinRange + 50, 150), 'Enemy')
            if M28Utilities.IsTableEmpty(tEnemyExperimentals) == false then
                for iEnemy, oEnemy in tEnemyExperimentals do
                    if oEnemy:GetFractionComplete() < 0.98 then
                        table.insert(tEnemyCombatNearFrontUnit, oEnemy)
                    end
                end
            end

            bCheckForDangerousDefences = not (M28Utilities.IsTableEmpty(tEnemyDefences))
            local bCheckForSurfaceUnits = false
            local iSurfaceUnitRangeCap = 100 --Will only look this far and reduce ground unit range to this to stop us staying too far away
            local tPotentialNearbyOtherSurfaceThreats = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryIndirectT2Plus - categories.TECH1, oClosestFriendlyUnitToEnemyBase:GetPosition(), math.min(iSurfaceUnitRangeCap, math.max(math.min(50, iIndirectMinRange), iDFMinRange) + 15), 'Enemy')
            local tNearbyOtherSurfaceThreats = {}
            if bDebugMessages == true then LOG(sFunctionRef..': Is tPotentialNearbyOtherSurfaceThreats empty='..tostring(M28Utilities.IsTableEmpty(tPotentialNearbyOtherSurfaceThreats))) end
            if M28Utilities.IsTableEmpty(tPotentialNearbyOtherSurfaceThreats) == false then
                for iUnit, oUnit in tPotentialNearbyOtherSurfaceThreats do
                    if not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                        table.insert(tNearbyOtherSurfaceThreats, oUnit)
                    end
                end
                if M28Utilities.IsTableEmpty(tNearbyOtherSurfaceThreats) == false then
                    bCheckForSurfaceUnits = true
                end
            end

            local oBuildingToAttack
            local iDefencesHeadroom
            local bBlockedSoMove = false --If unit shot is blocked and it should be able to hit the mex then have it move to where we thought the shot would be able to hit from
            local iBlockedAngleFromMexOrTarget
            local iBlockedDistanceFromMexOrTarget
            if tBlockedShotBaseMoveLocation then
                if bDebugMessages == true then LOG(sFunctionRef..': tBombardmentMainTarget='..repru(tBombardmentMainTarget)..'; tBlockedShotBaseMoveLocation='..repru(tBlockedShotBaseMoveLocation)..'; tClosestEnemyBase='..repru(tClosestEnemyBase)..'; tOurBase='..repru(tOurBase)) end
                iBlockedAngleFromMexOrTarget = M28Utilities.GetAngleFromAToB(tBombardmentMainTarget, tBlockedShotBaseMoveLocation)
                if bDebugMessages == true then LOG(sFunctionRef..': iBlockedAngleFromMexOrTarget='..iBlockedAngleFromMexOrTarget..'; tBombardmentMainTarget='..repru(tBombardmentMainTarget)..'; tBlockedShotBaseMoveLocation='..repru(tBlockedShotBaseMoveLocation)) end
                iBlockedDistanceFromMexOrTarget = M28Utilities.GetDistanceBetweenPositions(tBombardmentMainTarget, tBlockedShotBaseMoveLocation)
            end
            local bEnemyUnitsNearlyInRange
            local tPotentialEnemyUnits
            local bDontCheckIfTargetUnderwater
            local bHaveUnblockedBombardingBattleship

            if bDebugMessages == true then LOG(sFunctionRef .. ': About to search for bombardment targets, bCheckForBuildingsToAttack=' .. tostring(bCheckForBuildingsToAttack) .. '; tBombardmentMainTarget=' .. repru(tBombardmentMainTarget) .. '; tNonBombardmentRallyPoint=' .. repru(tNonBombardmentRallyPoint) .. '; iDFMinRange=' .. iDFMinRange .. '; iIndirectMinRange=' .. iIndirectMinRange..'; iBlockedAngleFromMexOrTarget='..(iBlockedAngleFromMexOrTarget or 'nil')..'; iBlockedDistanceFromMexOrTarget='..(iBlockedDistanceFromMexOrTarget or 'nil')..'; tBlockedShotBaseMoveLocation='..repru(tBlockedShotBaseMoveLocation)..'; bCheckForDangerousDefences='..tostring(bCheckForDangerousDefences)) end
            local tDefencesExclT2Arti
            if bCheckForDangerousDefences then
                tDefencesExclT2Arti = EntityCategoryFilterDown(categories.ALLUNITS - M28UnitInfo.refCategoryFixedT2Arti, tEnemyDefences)
            end
            local iCurEnemyRange
            local iCurEnemyDist
            local iCurShield,iMaxShield
            function ConsiderRetreatingFromDefendingUnit(oUnit, oDefence)
                iCurEnemyRange = math.max((oDefence[M28UnitInfo.refiDFRange] or 0), (oDefence[M28UnitInfo.refiIndirectRange] or 0), (oDefence[M28UnitInfo.refiAntiNavyRange] or 0))
                iCurEnemyDist = M28Utilities.GetDistanceBetweenPositions(oDefence:GetPosition(), oUnit:GetPosition())
                if bDebugMessages == true then LOG(sFunctionRef .. ': Considering if oUnit=' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. ' is in range of oDefence=' .. oDefence.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oDefence) .. '; iCurEnemyRange=' .. (iCurEnemyRange or 'nil') .. '; iCurEnemyDist=' .. iCurEnemyDist .. '; Our DF/Indirect range=' .. math.max((oUnit[M28UnitInfo.refiIndirectRange] or 0), (oUnit[M28UnitInfo.refiDFRange] or 0))) end

                iDefencesHeadroom = math.min((iDefencesHeadroom or iCurEnemyDist), iCurEnemyDist - iCurEnemyRange)
                --Are we in range of enemy, or are we almost in range of enemy and outrange them?
                if iCurEnemyDist <= iCurEnemyRange or (iCurEnemyDist - 12 <= iCurEnemyRange and math.max((oUnit[M28UnitInfo.refiIndirectRange] or 0), (oUnit[M28UnitInfo.refiDFRange] or 0)) > (iCurEnemyRange or 0) and iCurEnemyDist < math.max((oUnit[M28UnitInfo.refiIndirectRange] or 0), (oUnit[M28UnitInfo.refiDFRange] or 0))) then
                    --Move away unless are a battleship and the enemy is more than 100 away (unless is a T2 arti, since we likely outrange T2 arti)
                    if not (iCurEnemyDist > 100 and EntityCategoryContains(M28UnitInfo.refCategoryMobileNavalSurface * categories.TECH3 * categories.BATTLESHIP, oUnit.UnitId) and ((math.max((oUnit[M28UnitInfo.refiIndirectRange] or 0), (oUnit[M28UnitInfo.refiDFRange] or 0)) <= iCurEnemyRange) or iCurEnemyDist > 120)) then
                        if bDebugMessages == true then LOG(sFunctionRef .. ': Want to retreat') end
                        bRetreatUnit = true
                    end
                end
            end

            --Set the min range for units such as destroyers on high health to be treated as main bombardment units - i.e. be more aggressive with them if have enemy buildings to attack, or are on our side of the map with no nearby enemies in water zones
            local iDFLowerMinRange =  iOurBestDFRange
            if iOurBestDFRange > 60 and (bCheckForBuildingsToAttack or bCheckForDangerousDefences or (not(tWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) and tWZTeamData[M28Map.refiModDistancePercent] < 0.5) or (oClosestEnemyUnit and NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, M28Utilities.MoveInDirection(oClosestEnemyUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestEnemyUnit:GetPosition(), tWZData[M28Map.subrefMidpoint]), 60, true)) == iPond)) then
                iDFLowerMinRange = 60
            end

            for iUnit, oUnit in tPotentialBombardmentUnits do
                bDontCheckIfTargetUnderwater = (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > 0
                if bDebugMessages == true then LOG(sFunctionRef .. ': Considering unit ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. '; is underwater=' .. tostring(M28UnitInfo.IsUnitUnderwater(oUnit)) .. '; oUnit[M28UnitInfo.refiDFRange]=' .. (oUnit[M28UnitInfo.refiDFRange] or 'nil') .. '; oUnit[M28UnitInfo.refiIndirectRange]=' .. (oUnit[M28UnitInfo.refiIndirectRange] or 'nil')..'; Unit position='..repru(oUnit:GetPosition())) end

                if not (M28UnitInfo.IsUnitUnderwater(oUnit)) then
                    bRetreatUnit = false
                    --Are we in range of enemy PD/T2 arti; or experimental that we outrange? If so then retreat
                    if bCheckForDangerousDefences then

                        iDefencesHeadroom = 1000
                        if oUnit:GetHealth() >= 2100 and M28UnitInfo.GetUnitHealthPercent(oUnit) >= 0.35 then
                            if M28Utilities.IsTableEmpty(tDefencesExclT2Arti) == false then
                                for iDefence, oDefence in tDefencesExclT2Arti do
                                    ConsiderRetreatingFromDefendingUnit(oUnit, oDefence)
                                    if bRetreatUnit then break end
                                end
                            end
                        else
                            for iDefence, oDefence in tEnemyDefences do
                                ConsiderRetreatingFromDefendingUnit(oUnit, oDefence)
                                if bRetreatUnit then break end
                            end
                        end
                    end
                    if not(bRetreatUnit) and bCheckForSurfaceUnits then
                        local iCurEnemyRange
                        local iCurEnemyDist
                        iDefencesHeadroom = 1000
                        for iDefence, oDefence in tNearbyOtherSurfaceThreats do
                            iCurEnemyRange = math.min(iSurfaceUnitRangeCap, math.max((oDefence[M28UnitInfo.refiDFRange] or 0), (oDefence[M28UnitInfo.refiIndirectRange] or 0), (oDefence[M28UnitInfo.refiAntiNavyRange] or 0)))
                            iCurEnemyDist = M28Utilities.GetDistanceBetweenPositions(oDefence:GetPosition(), oUnit:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef .. ': Considering if oUnit=' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. ' is in range of oDefence=' .. oDefence.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oDefence) .. '; iCurEnemyRange=' .. iCurEnemyRange .. '; iCurEnemyDist=' .. iCurEnemyDist .. '; Our DF/Indirect range=' .. math.max((oUnit[M28UnitInfo.refiIndirectRange] or 0), (oUnit[M28UnitInfo.refiDFRange] or 0))) end

                            iDefencesHeadroom = math.min(iDefencesHeadroom, iCurEnemyDist - iCurEnemyRange)
                            if iCurEnemyDist <= iCurEnemyRange + 10 and math.max((oUnit[M28UnitInfo.refiIndirectRange] or 0), (oUnit[M28UnitInfo.refiDFRange] or 0)) < (iCurEnemyRange or 0) then
                                --Move away unless are a battleship and the enemy is more than 100 away
                                bRetreatUnit = true
                                break
                            end
                        end
                    end

                    local bChangedBlockedLocation = false
                    local tBlockedShotActualMoveLocation

                    if bRetreatUnit then
                        if bDebugMessages == true then LOG(sFunctionRef .. ': WIll retreat ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. ' towards our base as we are too close to enemy PD') end

                        M28Orders.IssueTrackedMove(oUnit, tOurBase, 20, false, 'NBRetr')
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': bCheckForSurfaceUnits='..tostring(bCheckForSurfaceUnits)..'; iDFMinRange='..iDFMinRange..'; iIndirectMinRange='..iIndirectMinRange..'; iDFLowerMinRange='..iDFLowerMinRange..'; Unit health%='..M28UnitInfo.GetUnitHealthPercent(oUnit)..'; oUnit[M28UnitInfo.refiDFRange]='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')) end
                        if (oUnit[M28UnitInfo.refiDFRange] or 0) >= iDFMinRange or (oUnit[M28UnitInfo.refiIndirectRange] or 0) >= iIndirectMinRange or ((oUnit[M28UnitInfo.refiDFRange] or 0) >= iDFLowerMinRange and M28UnitInfo.GetUnitHealthPercent(oUnit) >= 0.5) then
                            --Attack-move to target, unless we already have a structure in range or our shot is blocked
                            if bDebugMessages == true then LOG(sFunctionRef .. ': Checking if shot blocked for unit ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. '. tBlockedShotBaseMoveLocation=' .. repru(tBlockedShotBaseMoveLocation) .. '; oUnit[M28UnitInfo.refiDFRange]=' .. (oUnit[M28UnitInfo.refiDFRange] or 'nil') .. '; oUnit[M28UnitInfo.refiIndirectRange]=' .. (oUnit[M28UnitInfo.refiIndirectRange] or 'nil') .. '; oUnit[M28UnitInfo.refbLastShotBlocked]=' .. tostring(oUnit[M28UnitInfo.refbLastShotBlocked] or false)..'; Time of last unblocked shot='..(GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100))..'; Time since last refiLastWeaponEvent='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or -100)) end

                            if (oUnit[M28UnitInfo.refiDFRange] or 0) > (oUnit[M28UnitInfo.refiIndirectRange] or 0) and (oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or -100) < 6) and (tBlockedShotBaseMoveLocation or (tBombardmentMainTarget and (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and oClosestEnemyUnit and not(oClosestEnemyUnit[reftBlockedShotLocationByPond]) and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oClosestEnemyUnit.UnitId) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBombardmentMainTarget) - 5 <= (oUnit[M28UnitInfo.refiDFRange] or 0) and M28Utilities.GetRoughDistanceBetweenPositions(tBombardmentMainTarget, oClosestEnemyUnit:GetPosition()) <= 5))  then
                                bBlockedSoMove = true
                                --Get location this unit should move to
                                if M28Utilities.IsTableEmpty(tBlockedShotBaseMoveLocation) and oClosestEnemyUnit then
                                    tBlockedShotBaseMoveLocation = GetDFShotBlockedLocationForBuildingAndPond(oClosestEnemyUnit, iPond)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished getting shot blocked position, tBlockedShotBaseMoveLocation='..repru(tBlockedShotBaseMoveLocation)) end
                                end
                                if M28Utilities.IsTableEmpty(tBlockedShotBaseMoveLocation) == false then
                                    tBlockedShotActualMoveLocation = {tBlockedShotBaseMoveLocation[1], tBlockedShotBaseMoveLocation[2], tBlockedShotBaseMoveLocation[3]}
                                    --Record that we have been blocked at this range if we are close to the angle wanted and have fired recenlty
                                    local tBaseTargetPosition
                                    if tClosestMex then tBaseTargetPosition = {tClosestMex[1], tClosestMex[2], tClosestMex[3]}
                                    else
                                        tBaseTargetPosition = {tBombardmentMainTarget[1], tBombardmentMainTarget[2], tBombardmentMainTarget[3]}
                                        if not(iBlockedAngleFromMexOrTarget) then iBlockedAngleFromMexOrTarget = M28Utilities.GetAngleFromAToB(tBombardmentMainTarget, tBlockedShotBaseMoveLocation) end
                                        if not(iBlockedDistanceFromMexOrTarget) then iBlockedDistanceFromMexOrTarget = M28Utilities.GetDistanceBetweenPositions(tBombardmentMainTarget, tBlockedShotBaseMoveLocation) end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Shot is blocked for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; checking if we expected to be able to hit from here, and if so will increase the blocked distance. tClosestMex='..repru(tClosestMex)..'; tBaseTargetPosition='..repru(tBaseTargetPosition)..'; Time='..GetGameTimeSeconds()..'; oUnit[M28UnitInfo.refiTimeOfLastCheck]='..(oUnit[M28UnitInfo.refiTimeOfLastCheck] or 'nil'))
                                        if M28Utilities.IsTableEmpty(tBaseTargetPosition) == false then LOG(sFunctionRef..': Angle dif='..M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(tBaseTargetPosition, oUnit:GetPosition()), iBlockedAngleFromMexOrTarget)..'; iBlockedAngleFromMexOrTarget='..iBlockedAngleFromMexOrTarget..'; Angle from unit to tBaseTargetPosition (e.g. mex)='..M28Utilities.GetAngleFromAToB(tBaseTargetPosition, oUnit:GetPosition())) end
                                    end
                                    if M28Utilities.IsTableEmpty(tClosestMex) == false and tBaseTargetPosition and (oUnit[M28UnitInfo.refiIndirectRange] or 0) == 0 and oUnit[M28UnitInfo.refiDFRange] >= iDFMinRange and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or 0) <= 2 and M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(tBaseTargetPosition, oUnit:GetPosition()), iBlockedAngleFromMexOrTarget) <= 8 then
                                        local iDistToBlocked = M28Utilities.GetDistanceBetweenPositions(tBlockedShotActualMoveLocation, oUnit:GetPosition())
                                        if bDebugMessages == true then LOG(sFunctionRef..': iDistToBlocked='..(iDistToBlocked or 'nil')..'; tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexDFDistance]='..(M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFDistance] or 'nil')..'; iBlockedDistanceFromMexOrTarget (ie distance from the location to move to if shot is blocked, and the mex)='..(iBlockedDistanceFromMexOrTarget or 'nil')) end
                                        if iDistToBlocked <= 5 then
                                            local iCurBlockedDistance = math.max(iBlockedDistanceFromMexOrTarget + 2, (M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFDistance] or 0))
                                            local tPotentialUnblockedLocation = M28Utilities.MoveInDirection(tBaseTargetPosition, iBlockedAngleFromMexOrTarget, iCurBlockedDistance, true, false, true)
                                            local bUpdateMex = not(M28Utilities.IsTableEmpty(tClosestMex))
                                            while not(NavUtils.GetLabel(M28Map.refPathingTypeNavy, tPotentialUnblockedLocation) == iPond) do
                                                if bUpdateMex then
                                                    M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFDistance] = iCurBlockedDistance
                                                end
                                                iCurBlockedDistance = iCurBlockedDistance + 2
                                                tPotentialUnblockedLocation = M28Utilities.MoveInDirection(tBaseTargetPosition, iBlockedAngleFromMexOrTarget, iCurBlockedDistance, true, false, true)

                                                if iCurBlockedDistance >= 200 then break end
                                            end

                                            if bUpdateMex then
                                                M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFUnblockedLocation] = {tPotentialUnblockedLocation[1], tPotentialUnblockedLocation[2], tPotentialUnblockedLocation[3]}
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have changed the unblocked location by increasing the distance. New DF distance='..M28Map.tPondDetails[iPond][M28Map.subrefPondMexInfo][iClosestMexRef][M28Map.subrefMexDFDistance]) end
                                            end
                                            bChangedBlockedLocation = true
                                        end
                                    elseif M28Utilities.IsTableEmpty(tClosestMex) then
                                        --Consider moving slightly further back from the shot blocked location if our range allows
                                        local iDistFromBlockedToTarget = M28Utilities.GetDistanceBetweenPositions(tBlockedShotActualMoveLocation, tBaseTargetPosition)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Distance between blocked move location and target='..iDistFromBlockedToTarget..'; Unit DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0)) end
                                        if iDistFromBlockedToTarget + 2 < (oUnit[M28UnitInfo.refiDFRange] or 0) then
                                            local iDistAway = math.min(iDistFromBlockedToTarget + 30, oUnit[M28UnitInfo.refiDFRange] -1)
                                            local tAltBlockedMoveLocation = M28Utilities.MoveInDirection(tBaseTargetPosition, M28Utilities.GetAngleFromAToB(tBaseTargetPosition, tBlockedShotActualMoveLocation), iDistAway, true, false, M28Map.bIsCampaignMap)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we can move further away than the blocked location, iDistAway='..iDistAway..'; iDistFromBlockedToTarget='..iDistFromBlockedToTarget..'; Pond label if move away='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tAltBlockedMoveLocation) or 'nil')..'; iPond='..iPond..'; tBlockedShotActualMoveLocation='..repru(tBlockedShotActualMoveLocation)..'; tAltBlockedMoveLocation='..repru(tAltBlockedMoveLocation)) end
                                            if tAltBlockedMoveLocation and NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tAltBlockedMoveLocation) == iPond then
                                                tBlockedShotActualMoveLocation = tAltBlockedMoveLocation
                                            end
                                        end
                                    end

                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': Will move to tBlockedShotActualMoveLocation=' .. repru(tBlockedShotActualMoveLocation)..'; Dist from tBlockedShotActualMoveLocation='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBlockedShotActualMoveLocation)..'; will draw in blue')
                                        M28Utilities.DrawLocation(tBlockedShotActualMoveLocation)
                                    end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': Cant find blocked move location') end
                                end
                            else
                                --If have a battleship on bombardment duty and its shot isnt blocked and it has fired recently then record this so we know
                                if not(bHaveUnblockedBombardingBattleship) and bCheckForBuildingsToAttack and EntityCategoryContains(M28UnitInfo.refCategoryBattleship, oUnit.UnitId) and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or -100) <= 20 and not(oUnit[M28UnitInfo.refbLastShotBlocked]) then
                                    bHaveUnblockedBombardingBattleship = true
                                    if not(M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBattleshipBombardmentByPond]) then
                                        M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBattleshipBombardmentByPond] = {}
                                    end
                                    M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBattleshipBombardmentByPond][iPond] = GetGameTimeSeconds()
                                end

                                oBuildingToAttack = nil
                                if bDebugMessages == true then LOG(sFunctionRef..': bCheckForBuildingsToAttack='..tostring(bCheckForBuildingsToAttack)..'; Is tEnemyCombatNearFrontUnit empty='..tostring(M28Utilities.IsTableEmpty(tEnemyCombatNearFrontUnit))) end
                                if bCheckForBuildingsToAttack then
                                    local toBlockedBuildingsAndDistWithinRange = {}
                                    local iRangeThreshold = 10
                                    local iDistToPriority, iModDistToPriority
                                    local iClosestDist = 100000
                                    if M28Utilities.IsTableEmpty(tEnemyCombatNearFrontUnit) == false then
                                        for iPriority, oPriority in tEnemyCombatNearFrontUnit do
                                            if ((oPriority[M28UnitInfo.refiMissileShotBlockedCount] or 0) <= 10 or not(oUnit[M28UnitInfo.reftoTargetBlockedMissileCountByEntityId]) or (oUnit[M28UnitInfo.reftoTargetBlockedMissileCountByEntityId][oPriority.EntityId] or 0) == 0) and (oPriority[M28UnitInfo.refiTargetShotBlockedCount] or 0) < 15 then
                                                iDistToPriority = M28Utilities.GetDistanceBetweenPositions(oPriority:GetPosition(), oUnit:GetPosition())
                                                if iDistToPriority < iClosestDist then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oPriority='..oPriority.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPriority)..'; iDistToPriority='..iDistToPriority..'; Is unit underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oPriority))..'; refiMissileShotBlockedCount='..(oPriority[M28UnitInfo.refiMissileShotBlockedCount] or 'nil')..'; refiTargetShotBlockedCount='..(oPriority[M28UnitInfo.refiTargetShotBlockedCount] or 'nil')) end
                                                    if bDontCheckIfTargetUnderwater or not(M28UnitInfo.IsUnitUnderwater(oPriority)) then
                                                        --Is our shot blocked if we try and shoot from either our current position (if in range and shot is blocked), or a similar angle if we arent in range?
                                                        if (oUnit[M28UnitInfo.refiDFRange] or 0) > (oUnit[M28UnitInfo.refiIndirectRange] or 0) and ((oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 and iDistToPriority <= oUnit[M28UnitInfo.refiDFRange] and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or 0) <= 4) or M28Logic.IsShotBlocked(oUnit, oPriority)) then
                                                            --Blocked so dont want to try and attack this building
                                                            if bDebugMessages == true then LOG(sFunctionRef..': DF unit who we think will be blocked from firing at oPriority or which isnt as close as a unit already recorded, oPriority='..oPriority.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPriority)..' so will ignore oPriority, oUnit[M28UnitInfo.refbLastShotBlocked]='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked] or false)..'; Time since last unblocked shot='..(GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100))..'; Time of last check='..(GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100))..'; iDistToPriority='..iDistToPriority..'; oUnit[M28UnitInfo.refiDFRange]='..oUnit[M28UnitInfo.refiDFRange]..'; M28Logic.IsShotBlocked(oUnit, oPriority)='..tostring(M28Logic.IsShotBlocked(oUnit, oPriority))) end
                                                            if iDistToPriority < (oUnit[M28UnitInfo.refiDFRange] or 0) - iRangeThreshold then
                                                                table.insert(toBlockedBuildingsAndDistWithinRange, {oPriority, (oUnit[M28UnitInfo.refiDFRange] or 0) - iDistToPriority})
                                                            end
                                                        else
                                                            iClosestDist = iDistToPriority
                                                            oBuildingToAttack = oPriority
                                                            if bDebugMessages == true then LOG(sFunctionRef..': oPriority Unit is close enough that we want to make it the focus as oBuildingToAttack') end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end

                                    if bDebugMessages == true then
                                        if oBuildingToAttack then
                                            LOG(sFunctionRef .. ': Considering whether to attack oBuildingToAttack=' .. oBuildingToAttack.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oBuildingToAttack) .. '; Distance to it=' .. M28Utilities.GetDistanceBetweenPositions(oBuildingToAttack:GetPosition(), oUnit:GetPosition()) .. '; Our DF range=' .. (oUnit[M28UnitInfo.refiDFRange] or 'nil') .. '; Our Indirect range=' .. (oUnit[M28UnitInfo.refiIndirectRange] or 'nil'))
                                        else
                                            LOG(sFunctionRef..': Dont have a building to attack')
                                        end
                                    end
                                    if oBuildingToAttack and M28Utilities.GetDistanceBetweenPositions(oBuildingToAttack:GetPosition(), oUnit:GetPosition()) > math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0)) then
                                        --Not in range so dont give specific attack order
                                        oBuildingToAttack = nil
                                        if bDebugMessages == true then LOG(sFunctionRef..': Not in range of enemy building so wont attack it') end
                                    else
                                        --Consider overwriting with a priority target (e.g. TMD and shields)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to ignore closest building if enoguh defence headroom, iDefencesHeadroom='..(iDefencesHeadroom or 'nil')..'; bCheckForDangerousDefences='..tostring(bCheckForDangerousDefences)..'; Is tEnemyShieldsAndTMD empty='..tostring(M28Utilities.IsTableEmpty(tEnemyShieldsAndTMD))) end
                                        if (iDefencesHeadroom >= 10 or not(bCheckForDangerousDefences)) and M28Utilities.IsTableEmpty(tEnemyShieldsAndTMD) == false then
                                            local iPriorityCategory = M28UnitInfo.refCategoryFixedShield
                                            if EntityCategoryContains(M28UnitInfo.refCategoryMissileShip, oUnit.UnitId) then
                                                iPriorityCategory = iPriorityCategory + M28UnitInfo.refCategoryTMD
                                            end
                                            local tPriorityTargets = EntityCategoryFilterDown(iPriorityCategory, tEnemyShieldsAndTMD)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering targeting TMD and shields, is tPriorityTargets empty='..tostring(M28Utilities.IsTableEmpty(tPriorityTargets))) end
                                            if M28Utilities.IsTableEmpty(tPriorityTargets) == false then

                                                for iPriority, oPriority in tPriorityTargets do
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering shield (or  TMD for missile ships), oPriority='..oPriority.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oPriority[M28UnitInfo.refiMissileShotBlockedCount]='..(oPriority[M28UnitInfo.refiMissileShotBlockedCount] or 'nil')..'; Is oUnit[M28UnitInfo.reftoTargetBlockedMissileCountByEntityId] nil='..tostring(oUnit[M28UnitInfo.reftoTargetBlockedMissileCountByEntityId] == nil)..'; oPriority[M28UnitInfo.refiTargetShotBlockedCount]='..(oPriority[M28UnitInfo.refiTargetShotBlockedCount] or 'nil')) end
                                                    if ((oPriority[M28UnitInfo.refiMissileShotBlockedCount] or 0) <= 10 or not(oUnit[M28UnitInfo.reftoTargetBlockedMissileCountByEntityId]) or (oUnit[M28UnitInfo.reftoTargetBlockedMissileCountByEntityId][oPriority.EntityId] or 0) == 0) and (oUnit[M28UnitInfo.reftoTargetBlockedMissileCountByEntityId] or (oPriority[M28UnitInfo.refiTargetShotBlockedCount] or 0) < 15) then
                                                        iModDistToPriority = M28Utilities.GetDistanceBetweenPositions(oPriority:GetPosition(), oUnit:GetPosition())
                                                        iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oPriority, false)
                                                        if iMaxShield > 0 and iCurShield < math.min(iMaxShield * 0.1, 1000) then
                                                            iModDistToPriority = iModDistToPriority - math.min(20, iModDistToPriority * 0.2)
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering a low health shield so will reduce dist to make it more likely we attack it') end
                                                        end
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Dist between unit and oPriority='..M28Utilities.GetDistanceBetweenPositions(oPriority:GetPosition(), oUnit:GetPosition())..'; iModDistToPriority='..iModDistToPriority..'; iCurShield='..iCurShield..'; iMaxShield='..iMaxShield) end
                                                        if iModDistToPriority < iClosestDist then
                                                            if bDontCheckIfTargetUnderwater or not(M28UnitInfo.IsUnitUnderwater(oPriority)) then
                                                                iClosestDist = iModDistToPriority
                                                                if iModDistToPriority - math.min((iDefencesHeadroom or 30), 30) <= math.max((oUnit[M28UnitInfo.refiIndirectRange] or 0), (oUnit[M28UnitInfo.refiDFRange] or 0)) then
                                                                    oBuildingToAttack = oPriority
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Is oBuildingToAttack valid='..tostring(M28UnitInfo.IsUnitValid(oBuildingToAttack))..'; Is table of blocked buildings empty='..tostring(M28Utilities.IsTableEmpty(toBlockedBuildingsAndDistWithinRange))) end
                                    if not(oBuildingToAttack) and M28Utilities.IsTableEmpty(toBlockedBuildingsAndDistWithinRange) == false then
                                        --We have buildings that are within our DF range threshold - if we move back by the distance with which we are in range, is our shot still blocked?
                                        local iAngleFromBuilding
                                        local iFurthestInRange = 0
                                        for iEntry, tUnitAndDist in toBlockedBuildingsAndDistWithinRange do
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..tUnitAndDist[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tUnitAndDist[1])..'; tUnitAndDist[2]='..tUnitAndDist[2]..'; iFurthestInRange='..iFurthestInRange) end
                                            if tUnitAndDist[2] > iFurthestInRange then
                                                iAngleFromBuilding = M28Utilities.GetAngleFromAToB(tUnitAndDist[1]:GetPosition(), oUnit:GetPosition())
                                                local tMoveViaPoint = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleFromBuilding, tUnitAndDist[2]-1, true, false, not(bDontCheckIfTargetUnderwater))
                                                if bDebugMessages == true then LOG(sFunctionRef..': tMoveViaPoint='..repru(tMoveViaPoint)..'; Cur poisition='..repru(oUnit:GetPosition())..'; Is shot blocked='..tostring(M28Logic.IsShotBlocked(oUnit, tUnitAndDist[1], false, tMoveViaPoint))..'; iPond='..iPond..'; Naval path label for move point='..NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tMoveViaPoint)) end
                                                if M28Utilities.IsTableEmpty( tMoveViaPoint) == false and iPond == NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tMoveViaPoint) and not(M28Logic.IsShotBlocked(oUnit, tUnitAndDist[1], false, tMoveViaPoint)) then
                                                    iFurthestInRange = tUnitAndDist[2]
                                                    oBuildingToAttack = tUnitAndDist[1]
                                                    bBlockedSoMove = true
                                                    tBlockedShotActualMoveLocation = {tMoveViaPoint[1], tMoveViaPoint[2], tMoveViaPoint[3]}
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Adding as a new building to attack') end
                                                end
                                            end
                                        end
                                    end-- iRangeThreshold
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': is oBuildingToAttack valid='..tostring(M28UnitInfo.IsUnitValid(oBuildingToAttack))..'; bBlockedSoMove='..tostring(bBlockedSoMove)..'; tBlockedShotActualMoveLocation='..repru(tBlockedShotActualMoveLocation)..'; bConsiderGroundAttack='..tostring(bConsiderGroundAttack)..'; Time since refiTimeOfLastUnblockedShot='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or 0)..'; Time since last weapon event='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0)) end
                            if not (oBuildingToAttack) or (bBlockedSoMove and tBlockedShotActualMoveLocation) then
                                --ToDo - figure out solution to both cliff temporarily blocking (where if we dont attack-move we are ok)
                                --ToDo - and the converse where we are ok but if we move towards the target a cliff ends up blocking us until we move further away
                                local oOptionalBombardLinkedTarget
                                if bBlockedSoMove and tBlockedShotActualMoveLocation then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Dist to move location='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBlockedShotActualMoveLocation)) end
                                    if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBlockedShotActualMoveLocation) <= 1.5 then --tried with <=1 but had issues with frigate on betrayal ocean not firing
                                        --Otherwise will just keep repeating order to move and end up not firing, when there's a chance firing shots might hit something (i.e. might be marginal whether hit cliff or not)
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, tBlockedShotActualMoveLocation, 1.5, false, 'NBlckAM', false)
                                    else
                                        M28Orders.IssueTrackedMove(oUnit, tBlockedShotActualMoveLocation, 1.5, false, 'NBlckM', false)
                                    end
                                else
                                    if bConsiderGroundAttack then
                                        --Change back to false if no units at the target
                                        bConsiderGroundAttack = false
                                        local tRect = M28Utilities.GetRectAroundLocation(tBombardmentMainTarget, 1)
                                        local tUnitsInRect = GetUnitsInRect(tRect)
                                        if bDebugMessages == true and oClosestEnemyUnit then LOG(sFunctionRef..': oClosestEnemyUnit position='..repru(oClosestEnemyUnit:GetPosition())..'; Is tUnitsInRect empty='..tostring(M28Utilities.IsTableEmpty(tUnitsInRect))..'; tBombardmentMainTarget='..repru(tBombardmentMainTarget)) end
                                        if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                                            for iUnit, oUnit in tUnitsInRect do
                                                if not(oUnit:GetAIBrain().M28Team == iTeam) and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) and not(M28UnitInfo.CanSeeUnit(aiBrain, oUnit)) then
                                                    oOptionalBombardLinkedTarget = oUnit
                                                    bConsiderGroundAttack = true
                                                    break
                                                end
                                            end
                                        end
                                    end
                                    bEnemyUnitsNearlyInRange = false
                                    if ((oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6) or (bIgnoreLowThreats and EntityCategoryContains(categories.TECH3 + M28UnitInfo.refCategoryMissileShip, oUnit.UnitId))) and M28Utilities.GetDistanceBetweenPositions(tBombardmentMainTarget, oUnit:GetPosition()) > math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0)) then
                                        --Check if enemy has non-air units near us that could hit us or if we can do an issuemove instead of attackmove to get within range of the desired location
                                        tPotentialEnemyUnits = aiBrain:GetUnitsAroundPoint(categories.DIRECTFIRE + categories.INDIRECTFIRE + M28UnitInfo.refCategoryAntiNavy - categories.AIR - M28UnitInfo.refCategoryFixedT3Arti - categories.SILO  - categories.UNSELECTABLE - categories.UNTARGETABLE, oUnit:GetPosition(), 100, 'Enemy')
                                        if M28Utilities.IsTableEmpty(tPotentialEnemyUnits) == false then
                                            for iEnemy, oEnemy in tPotentialEnemyUnits do
                                                if math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0)) + 5 <= M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition()) then
                                                    bEnemyUnitsNearlyInRange = true
                                                    if bDebugMessages == true then LOG(sFunctionRef..': oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..' is only '..M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())..' from us and ourDF  range is '..(oUnit[M28UnitInfo.refiDFRange] or 0)..' and indirect is '..(oUnit[M28UnitInfo.refiIndirectRange] or 0)..' so will use attack move instead of move') end
                                                    break
                                                end
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef..': Will bombard the target wit hthis unit.  Considering whether to move or attack for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bIgnoreLowThreats='..tostring(bIgnoreLowThreats)..'; oUnit[M28UnitInfo.refbLastShotBlocked]='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked])..'; bEnemyUnitsNearlyInRange='..tostring(bEnemyUnitsNearlyInRange)..'; M28UnitInfo.GetUnitHealthPercent(oUnit)='..M28UnitInfo.GetUnitHealthPercent(oUnit)..'; tBombardmentMainTarget='..repru(tBombardmentMainTarget)..'; tBlockedShotBaseMoveLocation='..repru(tBlockedShotBaseMoveLocation))
                                        if oClosestEnemyUnit then LOG(sFunctionRef..': oClosestEnemyUnit position='..repru(oClosestEnemyUnit:GetPosition())..'; oClosestEnemyUnit='..oClosestEnemyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyUnit)) end
                                    end
                                    if (bIgnoreLowThreats or (oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6)) and (not(bEnemyUnitsNearlyInRange) or M28UnitInfo.GetUnitHealthPercent(oUnit) >= 0.75) then
                                        if oUnit[M28UnitInfo.refbLastShotBlocked] and M28Utilities.IsTableEmpty(tBlockedShotActualMoveLocation) == false then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Checking Dist to move location='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBlockedShotActualMoveLocation)) end
                                            if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBlockedShotActualMoveLocation) <= 1.5 then --tried with <=1 but had issues with frigate on betrayal ocean not firing
                                                --Otherwise will just keep repeating order to move and end up not firing, when there's a chance firing shots might hit something (i.e. might be marginal whether hit cliff or not)
                                                M28Orders.IssueTrackedAggressiveMove(oUnit, tBlockedShotActualMoveLocation, 1.5, false, 'MABlbard', false)
                                            else
                                                M28Orders.IssueTrackedMove(oUnit, tBlockedShotActualMoveLocation, 1.5, false, 'MBlbard', false)
                                            end
                                        else
                                            M28Orders.IssueTrackedMove(oUnit, tBombardmentMainTarget, 10, false, 'MBombard', false)
                                        end
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': Dist between unit and main target='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBombardmentMainTarget)..'; bConsiderGroundAttack='..tostring(bConsiderGroundAttack or false)..'; Min IF range='..(oUnit[M28UnitInfo.refiIFMinRange] or 'nil')..'; Min DF range='..(oUnit[M28UnitInfo.refiDFMinRange] or 0)..'; Time since last weapon event='..(GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0))) end
                                        if bConsiderGroundAttack and ((oUnit[M28UnitInfo.refiDFAOE] or 0) > 0 or (oUnit[M28UnitInfo.refiIndirectAOE] or 0) > 0) then
                                            M28Orders.IssueTrackedGroundAttack(oUnit, tBombardmentMainTarget, 1.5, false, 'AGBombrd', false, oOptionalBombardLinkedTarget)
                                            --If inside minimum range then do a manual attack
                                        elseif (oUnit[M28UnitInfo.refiIFMinRange] or 0) > 0 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBombardmentMainTarget) <= oUnit[M28UnitInfo.refiIFMinRange] + 10 and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0) >= (oUnit[M28UnitInfo.refiTimeBetweenIFShots] or 0) + 1 or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBombardmentMainTarget) <= oUnit[M28UnitInfo.refiIFMinRange] + 4) then
                                            --Missile ships - issue where they dont actually fire under attackmove in some cases
                                            --If we have a unit order target then 20% chance we will get a random new target, 80% chance we attackmove away
                                            if oUnit[M28UnitInfo.reftoTargetBlockedMissileCountByEntityId] or EntityCategoryContains(M28UnitInfo.refCategoryMissileShip, oUnit.UnitId) then
                                                if not(M28UnitInfo.IsUnitValid(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subrefoOrderUnitTarget])) or math.random(1,5) == 1 then
                                                    local tNearbyEnemyBuildings = oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure, oUnit:GetPosition(),  oUnit[M28UnitInfo.refiIndirectRange], 'Enemy')
                                                    if M28Utilities.IsTableEmpty(tNearbyEnemyBuildings) == false then
                                                        local iEnemyCount = table.getn(tNearbyEnemyBuildings)
                                                        local oTarget = tNearbyEnemyBuildings[math.random(1, iEnemyCount)]
                                                        M28Orders.IssueTrackedAttack(oUnit, oTarget, false, 'BmbdMinIFRnMA', false)
                                                    end
                                                else
                                                    --Do nothing
                                                end
                                            else
                                                local tRetreatForRangeTarget = M28Utilities.MoveInDirection(tBombardmentMainTarget, M28Utilities.GetAngleFromAToB(tBombardmentMainTarget, oUnit:GetPosition()), oUnit[M28UnitInfo.refiIFMinRange] + 15, true, false, M28Map.bIsCampaignMap)
                                                M28Orders.IssueTrackedAggressiveMove(oUnit, tRetreatForRangeTarget, 3, false, 'AAMinRngBmbd', false)
                                            end
                                        elseif (oUnit[M28UnitInfo.refiDFMinRange] or 0) > 0 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBombardmentMainTarget) <= oUnit[M28UnitInfo.refiDFMinRange] + 10 and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0) >= (oUnit[M28UnitInfo.refiTimeBetweenDFShots] or 0) + 1 or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBombardmentMainTarget) <= oUnit[M28UnitInfo.refiDFMinRange] + 4) then
                                            local tRetreatForRangeTarget = M28Utilities.MoveInDirection(tBombardmentMainTarget, M28Utilities.GetAngleFromAToB(tBombardmentMainTarget, oUnit:GetPosition()), oUnit[M28UnitInfo.refiDFMinRange] + 15, true, false, M28Map.bIsCampaignMap)
                                            M28Orders.IssueTrackedAggressiveMove(oUnit, tRetreatForRangeTarget, 3, false, 'AAMinDRngBmbd', false)
                                        else
                                            M28Orders.IssueTrackedAggressiveMove(oUnit, tBombardmentMainTarget, 10, false, 'ABombard', false)
                                        end
                                    end
                                end
                            else
                                if bBlockedSoMove then --Redundancy (for if we somehow set this to true without a blocked location)
                                    M28Orders.IssueTrackedMove(oUnit, tBombardmentMainTarget, 10, false, 'MBBombard', false)
                                else
                                    --Do we want to run from the building to attack?
                                    ConsiderRetreatingFromDefendingUnit(oUnit, oBuildingToAttack)
                                    if bRetreatUnit then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to kite enemy') end
                                        M28Orders.IssueTrackedMove(oUnit, tOurBase, 20, false, 'NBaRetr')
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef .. ': Launching specific attack order on ' .. oBuildingToAttack.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oBuildingToAttack)..'; oUnit[M28UnitInfo.refbLastShotBlocked]='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked])) end
                                        M28Orders.IssueTrackedAttack(oUnit, oBuildingToAttack, false, 'BAttack', false)
                                    end
                                end
                            end
                        else
                            M28Orders.IssueTrackedMove(oUnit, tNonBombardmentRallyPoint, 10, false, 'SRSupport', false)
                        end
                    end
                else
                    M28Orders.IssueTrackedMove(oUnit, tNonBombardmentRallyPoint, 10, false, 'SRMSupport', false)
                end
            end
        else
            M28Utilities.ErrorHandler('No active M28 brain')
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function IncludeThreatOfAdjacentZone(iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, tBaseWZToUse, tAdjWZTeamData, iAdjWZ, bIncludeAdjacentAlliedSubmersibleThreat, bIncludeAdjacentEnemyAntiNavyThreat, bIncludeAdjacentAlliedCombatThreat, bIncludeAdjacentEnemyCombatThreat, iEnemyFactorOverride)
    --Updates the threat variables for enemies in adjacent zone, based on how close they are to being in range of tBaseWZToUse
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IncludeThreatOfAdjacentZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(tAdjWZTeamData[M28Map.subrefTEnemyUnits]) == false or M28Utilities.IsTableEmpty(tAdjWZTeamData[M28Map.subrefWZTAlliedCombatUnits]) == false then
        local iEnemyFactor = iEnemyFactorOverride or 0.2
        local iAlliedFactor = 0.8
        if bIncludeAdjacentAlliedSubmersibleThreat then iAdjacentAlliedSubmersibleThreat = iAdjacentAlliedSubmersibleThreat + (tAdjWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] or 0) * iAlliedFactor end
        if bIncludeAdjacentEnemyAntiNavyThreat then iAdjacentEnemyAntiNavyThreat = iAdjacentEnemyAntiNavyThreat + (tAdjWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] or 0) * iEnemyFactor end
        if bIncludeAdjacentAlliedCombatThreat then iAdjacentAlliedCombatThreat = iAdjacentAlliedCombatThreat + (tAdjWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0) * iAlliedFactor end
        if bIncludeAdjacentEnemyCombatThreat then iAdjacentEnemyCombatThreat = iAdjacentEnemyCombatThreat + (tAdjWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * iEnemyFactor end
        if tAdjWZTeamData[M28Map.subrefWZTThreatAllyLauncherDefenceTotal] > 0 then
            if bIncludeAdjacentAlliedSubmersibleThreat then iAdjacentAlliedSubmersibleThreat = iAdjacentAlliedSubmersibleThreat - math.min(tAdjWZTeamData[M28Map.subrefWZTThreatAllyLauncherDefenceTotal], (tAdjWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] or 0)) * iAlliedFactor end
            if bIncludeAdjacentAlliedCombatThreat then iAdjacentAlliedCombatThreat = iAdjacentAlliedCombatThreat - math.min(tAdjWZTeamData[M28Map.subrefWZTThreatAllyLauncherDefenceTotal], (tAdjWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0)) * iAlliedFactor end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Adjusting threat for adjacent zones, considering iAdjWZ='..iAdjWZ..', is table of LR units empty='..tostring(M28Utilities.IsTableEmpty(tAdjWZTeamData[M28Map.subreftEnemyLongRangeUnits]))..'; bIncludeAdjacentAlliedSubmersibleThreat='..tostring(bIncludeAdjacentAlliedSubmersibleThreat)..'; bIncludeAdjacentAlliedCombatThreat='..tostring(bIncludeAdjacentAlliedCombatThreat)..'; iAdjacentEnemyAntiNavyThreat before LR adjust='..iAdjacentEnemyAntiNavyThreat..'; iAdjacentEnemyCombatThreat='..iAdjacentEnemyCombatThreat..'; tAdjWZTeamData[M28Map.subrefWZTThreatAllyLauncherDefenceTotal]='..(tAdjWZTeamData[M28Map.subrefWZTThreatAllyLauncherDefenceTotal] or 'nil')) end
        if M28Utilities.IsTableEmpty(tAdjWZTeamData[M28Map.subreftEnemyLongRangeUnits]) == false then
            local tLongRangeEnemiesAlmostInRange = {}
            local iLRFactor = 1 - iEnemyFactor
            local iZoneMinX = tBaseWZToUse[M28Map.subrefPondMinX]
            local iZoneMinZ = tBaseWZToUse[M28Map.subrefPondMinZ]
            local iZoneMaxX = tBaseWZToUse[M28Map.subrefPondMaxX]
            local iZoneMaxZ = tBaseWZToUse[M28Map.subrefPondMaxZ]
            local iUnitDistAdjust
            for iUnit, oUnit in tAdjWZTeamData[M28Map.subreftEnemyLongRangeUnits] do
                if M28UnitInfo.IsUnitValid(oUnit) then
                    local tUnitPosition = oUnit:GetPosition()

                    if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) then
                        iUnitDistAdjust = oUnit[M28UnitInfo.refiCombatRange] - 8
                    else
                        iUnitDistAdjust = oUnit[M28UnitInfo.refiCombatRange] + 3
                    end
                    if tUnitPosition[1] + iUnitDistAdjust >= iZoneMinX and tUnitPosition[1] - iUnitDistAdjust <= iZoneMaxX
                            and tUnitPosition[3] + iUnitDistAdjust >= iZoneMinZ and tUnitPosition[3] - iUnitDistAdjust <= iZoneMaxZ then
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding unit to long range enemies, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Position='..repru(oUnit:GetPosition())..'; iUnitDistAdjust='..iUnitDistAdjust..'; iZoneMinX='..iZoneMinX..';Z='..iZoneMinZ..'; MaxX='..iZoneMaxX..';Z='..iZoneMaxZ) end
                        table.insert(tLongRangeEnemiesAlmostInRange, oUnit)
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tLongRangeEnemiesAlmostInRange) == false then
                --GetCombatThreatRating(tUnits, bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, bBlueprintThreat)
                if bIncludeAdjacentEnemyAntiNavyThreat then iAdjacentEnemyAntiNavyThreat = iAdjacentEnemyAntiNavyThreat + M28UnitInfo.GetCombatThreatRating(tLongRangeEnemiesAlmostInRange, true, false, false, true) * iLRFactor end
                if bIncludeAdjacentEnemyCombatThreat then iAdjacentEnemyCombatThreat = iAdjacentEnemyCombatThreat + M28UnitInfo.GetCombatThreatRating(tLongRangeEnemiesAlmostInRange, true, false, false, false, true) * iLRFactor end
            end
        end

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat
end

function ManageCombatUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableCombatUnits, tAvailableSubmarines, tUnavailableUnitsInThisWZ, tMissileShips)
    --Handles logic for main combat units (direct and indirect fire mobile units) that are noted as available to the land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageCombatUnitsInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tUnassignedLandUnits
    if bDebugMessages == true then LOG(sFunctionRef..': start of code for time '..GetGameTimeSeconds()..', iTeam='..iTeam..'; iPond='..iPond..'; iWaterZone='..iWaterZone..'; Is table of available combat units empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))..'; Is table of available subs empty='..tostring(M28Utilities.IsTableEmpty(tAvailableSubmarines))..'; Are there enemy units in this or adjacent WZ='..tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])..'; Is table of missile ships empty='..tostring(M28Utilities.IsTableEmpty(tMissileShips))..'; subrefWZbSuicideIntoEnemy='..tostring(tWZTeamData[M28Map.subrefWZbSuicideIntoEnemy] or false)) end

    local bWantReinforcements = false

    --Record which untis in adjacent zones are nearest to us:
    local iEnemyBestAntiNavyRange, iEnemyBestCombatRange, iEnemyBestUnderwaterRange = RecordClosestAdjacentRangesAndEnemies(tWZData, tWZTeamData, iPond, iWaterZone, iTeam)
    local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)

    --If enemy has units in this or adjacent WZ, then decide what to do
    local oNearestEnemyToFriendlyBase
    local oNearestEnemySurfaceToFriendlyBase
    local oNearestEnemyNonHoverToFriendlyBase
    local iTargetZoneForNonHover = iWaterZone --Will update with the zone that the nearest non hover enemy is in, for calculating threats
    local iTargetZoneForSurface = iWaterZone --will update with the zone that the nearest surface enemy is in, for calculating threats

    local bUpdateNearestUnit = tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]
    local bCheckIfNearestUnitVisible = false
    local bMoveBlockedNotAttackMove = false

    local iReissueOrderDistanceStandard = 6
    local iResisueOrderDistanceHover = 15
    local iOrderReissueDistToUse = iReissueOrderDistanceStandard
    local tEnemySurfaceUnits = {}
    local tEnemyNonHoverUnits = {}

    --Run to nearest zone with ZZ (or if none, our naval fac) if enemy has air to ground threat here or in adjacent zone and we have no AA in this zone or adjacent to this zone
    local iEnemyAdjacentAirToGroundThreat = tWZTeamData[M28Map.refiEnemyAirToGroundThreat]
    local iFriendlyAdjacentAAThreat = tWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA]
    local iFriendlyAdjacentUnweightedAAThreat = tWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA]
    iCurTime = math.floor(GetGameTimeSeconds())

    function IgnoreOrderDueToStuckUnit(oUnit)
        if oUnit[M28UnitInfo.refbUnitStuckAlternating] then
            if (not(oUnit[M28UnitInfo.refbEasyBrain]) or EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnit.UnitId)) and oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition] and M28Utilities.GetDistanceBetweenPositions(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition], oUnit:GetPosition()) >= 15 then
                --Do nothing - want unit to reach its destination before it gets new orders
                return true
            end
        end
    end

    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
        for _, iAltWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
            local tAltWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAltWZ][M28Map.subrefWZTeamData][iTeam]
            iEnemyAdjacentAirToGroundThreat = iEnemyAdjacentAirToGroundThreat + tAltWZTeamData[M28Map.refiEnemyAirToGroundThreat]
            if bDebugMessages == true then LOG(sFunctionRef..': Enemy air to ground threat in iAltWZ='..iAltWZ..'='..(tAltWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 'nil')) end
            if (tAltWZTeamData[M28Map.subrefWZThreatAlliedMAA] or 0) > 0 then
                iFriendlyAdjacentAAThreat = iFriendlyAdjacentAAThreat + tAltWZTeamData[M28Map.subrefWZThreatAlliedMAA] * 0.5 --Only factor in part of threat of nearby allied navy
                iFriendlyAdjacentUnweightedAAThreat = iFriendlyAdjacentUnweightedAAThreat + tAltWZTeamData[M28Map.subrefWZThreatAlliedMAA]
            end
        end
    end

    --Surface subs if enemy has airtoground in this zone (or nearby if it's a large threat)
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if should surface AA subs, iEnemyAdjacentAirToGroundThreat just from this zone='..iEnemyAdjacentAirToGroundThreat..'; Is table of available subs empty='..tostring(M28Utilities.IsTableEmpty(tAvailableSubmarines))..'; tWZTeamData[M28Map.refiEnemyAirToGroundThreat]='..(tWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 'nil')) end
    if (iEnemyAdjacentAirToGroundThreat > 2000 or tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0) and M28Utilities.IsTableEmpty(tAvailableSubmarines) == false then
        local tAASubs = EntityCategoryFilterDown(M28UnitInfo.refCategoryAntiAir, tAvailableSubmarines)
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of AA subs empty='..tostring(M28Utilities.IsTableEmpty(tAASubs))) end
        if M28Utilities.IsTableEmpty(tAASubs) == false then
            for iUnit, oUnit in tAASubs do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to surface unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is unit underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))) end
                if M28UnitInfo.IsUnitUnderwater(oUnit) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and surface the unit, is special micro active='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive])..'; Cur time='..GetGameTimeSeconds()..'; Time for micro to reset='..(oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] or 'nil')) end
                    M28UnitInfo.ToggleUnitDiveOrSurfaceStatus(oUnit) --wont do anything if special micro is active, and will set special micro to active if it does give the order
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Relatively near start for iWaterZone='..iWaterZone..' at time='..GetGameTimeSeconds()..'; Checking if want to run from enemy AA iEnemyAdjacentAirToGroundThreat='..iEnemyAdjacentAirToGroundThreat..'; iFriendlyAdjacentAAThreat='..iFriendlyAdjacentAAThreat..'; tRallyPoint='..repru(tRallyPoint)) end

    function RetreatAllUnits(tUnitsToRetreat) --intended for availablecoombatunits and/or availablesubmarines
        local tAmphibiousRallyPoint = {tWZTeamData[M28Map.reftClosestFriendlyBase][1], tWZTeamData[M28Map.reftClosestFriendlyBase][2], tWZTeamData[M28Map.reftClosestFriendlyBase][3]}
        for iUnit, oUnit in tUnitsToRetreat do
            --Only retreat units from this WZ
            if oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iWaterZone then
                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                if EntityCategoryContains(M28UnitInfo.refCategoryAmphibious + categories.HOVER, oUnit.UnitId) then --redundancy - wouldnt expect any subs to be amphibious or hover
                    M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'WSRetrFrA'..iWaterZone)
                else
                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'WSRetrFrA'..iWaterZone)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': retreating unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to rally point or amphibious rally point') end
            else
                oUnit[refiCurrentWZAssignmentValue] = 0
            end
        end
        tUnitsToRetreat = nil --doesnt seem to work so need to manually set the table to nil
    end
    local iBestAvailableSubmarineRange = 0
    local bHaveRunFromAir = false
    if iEnemyAdjacentAirToGroundThreat > math.max(50, iFriendlyAdjacentAAThreat * 1.5) and iFriendlyAdjacentAAThreat < 1500 and not(M28Team.tTeamData[iTeam][M28Team.refbDontHaveBuildingsOrACUInPlayableArea]) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 2.2 * iFriendlyAdjacentAAThreat then
        --Retreat to rally point
        if bDebugMessages == true then LOG(sFunctionRef..': Will retreat available combat units and subs to the rally point, si available combat units empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))..'; Is available subs empty='..tostring(M28Utilities.IsTableEmpty(tAvailableSubmarines))) end
        if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
            if iEnemyAdjacentAirToGroundThreat - iFriendlyAdjacentAAThreat > 0 and iEnemyAdjacentAirToGroundThreat - iFriendlyAdjacentAAThreat > M28UnitInfo.GetMassCostOfUnits(tAvailableCombatUnits) * 0.05 then
                bHaveRunFromAir = true
                tWZTeamData[M28Map.refiTimeLastRunFromEnemyAir] = iCurTime
                RetreatAllUnits(tAvailableCombatUnits)
                tAvailableCombatUnits = nil
                --[[local tAmphibiousRallyPoint = {tWZTeamData[M28Map.reftClosestFriendlyBase][1], tWZTeamData[M28Map.reftClosestFriendlyBase][2], tWZTeamData[M28Map.reftClosestFriendlyBase][3]}
                for iUnit, oUnit in tAvailableCombatUnits do
                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                    if EntityCategoryContains(M28UnitInfo.refCategoryAmphibious + categories.HOVER, oUnit.UnitId) then
                        M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'WNRetrApA'..iWaterZone)
                    else
                        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'WNRetrFrA'..iWaterZone)
                    end
                end--]]
            end
        else
            tAvailableCombatUnits = nil
        end

        if M28Utilities.IsTableEmpty(tAvailableSubmarines) == false then
            --Decide if we want to run from enemy air - only run if they have torp bombers
            if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want our subs to run from enemy, will depend on if they ahve torps, enemy torp total threat='..(M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] or 0)..'; iFriendlyAdjacentAAThreat='..iFriendlyAdjacentAAThreat..'; Available sub mass value='..M28UnitInfo.GetCombatThreatRating(tAvailableSubmarines, false, true)) end
            if (M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] or 0) > iFriendlyAdjacentAAThreat * 1.5 and M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] - iFriendlyAdjacentAAThreat >= 0.1 * M28UnitInfo.GetMassCostOfUnits(tAvailableSubmarines) then
                bHaveRunFromAir = true
                tWZTeamData[M28Map.refiTimeLastRunFromEnemyAir] = iCurTime
                if bDebugMessages == true then LOG(sFunctionRef..': Will retreat to closest friendly base for amphibious unit, or rally point for subs') end
                RetreatAllUnits(tAvailableSubmarines)
                tAvailableSubmarines = nil
                --[[local tAmphibiousRallyPoint = {tWZTeamData[M28Map.reftClosestFriendlyBase][1], tWZTeamData[M28Map.reftClosestFriendlyBase][2], tWZTeamData[M28Map.reftClosestFriendlyBase][3]}
                for iUnit, oUnit in tAvailableSubmarines do
                    --Only retreat units from this WZ
                    if oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iWaterZone then
                        oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                        if EntityCategoryContains(M28UnitInfo.refCategoryAmphibious + categories.HOVER, oUnit.UnitId) then --redundancy - wouldnt expect any subs to be amphibious or hover
                            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'WSRetrFrA'..iWaterZone)
                        else
                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'WSRetrFrA'..iWaterZone)
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': retreating sub '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to rally point or amphibious rally point') end
                    else
                        oUnit[refiCurrentWZAssignmentValue] = 0
                    end
                end
                tAvailableSubmarines = nil--]]
            elseif bDebugMessages == true then LOG(sFunctionRef..': Wont retreat subs as not enough for a torp bomber threat')
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Have told all units to run to tRallyPoint='..repru(tRallyPoint)) end
    end
    if bHaveRunFromAir then --We have run due to enemy air to ground threat, so want nearby zones to run
        --Record adjacent WZs that lack any AA as well that they should run from air, but make it expire sooner
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
            local iTimeForRetreat = iCurTime - iRetreatFromAirDuration * 0.35
            for _, iAdjWZ in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZAdjacentWaterZones] do
                local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                if tAdjWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] <= 100 then
                    if not(tAdjWZTeamData[M28Map.refiTimeLastRunFromEnemyAir]) then
                        tAdjWZTeamData[M28Map.refiTimeLastRunFromEnemyAir] = iTimeForRetreat
                    else
                        tAdjWZTeamData[M28Map.refiTimeLastRunFromEnemyAir] = math.max(iTimeForRetreat, tAdjWZTeamData[M28Map.refiTimeLastRunFromEnemyAir])
                    end
                end
            end
        end
    end

    --Retreat if enemy air threat too great to risk our navy
    if bDebugMessages == true then LOG(sFunctionRef..': Even if enemy has no nearby air to ground threat still consider retreating from air if we lack sufficient AA force, bHaveRunFromAir='..tostring(bHaveRunFromAir)..'; Mod dist%='..tWZTeamData[M28Map.refiModDistancePercent]..'; Core base='..tostring(tWZTeamData[M28Map.subrefWZbCoreBase])..'; Enemy total torp bomber threat='.. M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat]..'; iFriendlyAdjacentUnweightedAAThreat='..iFriendlyAdjacentUnweightedAAThreat) end
    if not(bHaveRunFromAir) and tWZTeamData[M28Map.refiModDistancePercent] >= 0.25 and not(tWZTeamData[M28Map.subrefWZbCoreBase]) and M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] > iFriendlyAdjacentUnweightedAAThreat then
        local aiBrain = ArmyBrains[tWZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]]
        local iAirSubteam = aiBrain.M28AirSubteam
        local iAAFactorWanted = 0.45
        if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] then iAAFactorWanted = 0.25
        elseif M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir] then iAAFactorWanted = 0.55
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Deciding if want to run due to enemy total torp bomber threat, M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat]='..M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat]..'; iAAFactorWanted='..iAAFactorWanted..'; iFriendlyAdjacentUnweightedAAThreat='..iFriendlyAdjacentUnweightedAAThreat) end
        if M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] * iAAFactorWanted > iFriendlyAdjacentUnweightedAAThreat then
            --Ignore if torp bomber threat not large relative to our naval force
            local iAvailableCombatMass = M28UnitInfo.GetMassCostOfUnits(tAvailableCombatUnits)
            if bDebugMessages == true then LOG(sFunctionRef..': Will run back to base unless enemy torpedo bomber force is a small fraction of our naval force, iAvailableCombatMass='..iAvailableCombatMass) end
            if M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] > iAvailableCombatMass * 0.04 then
                local iTimeForRetreat = iCurTime - iRetreatFromAirDuration * 0.8 --i.e. as soon as we get enough AA force we should be open to advancing
                tWZTeamData[M28Map.refiTimeLastRunFromEnemyAir] = math.max(iTimeForRetreat, (tWZTeamData[M28Map.refiTimeLastRunFromEnemyAir] or 0))
                bHaveRunFromAir = true
                if M28Utilities.IsTableEmpty(tAvailableSubmarines) == false and (M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] or 0) > 0 then RetreatAllUnits(tAvailableSubmarines) tAvailableSubmarines = nil end
                if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then RetreatAllUnits(tAvailableCombatUnits) tAvailableCombatUnits = nil end
                if M28Utilities.IsTableEmpty(tMissileShips) == false then RetreatAllUnits(tMissileShips) tMissileShips = nil end
            end
        end
    end

    if (not(bHaveRunFromAir) and tWZTeamData[M28Map.refiTimeLastRunFromEnemyAir] and GetGameTimeSeconds() - tWZTeamData[M28Map.refiTimeLastRunFromEnemyAir] <= iRetreatFromAirDuration and tWZTeamData[M28Map.subrefWZThreatAlliedMAA] < 500)
            --Below is to be consistent so if we are retreating subs or surface from air we will do the same for the other
            or (bHaveRunFromAir and (M28Utilities.IsTableEmpty(tAvailableSubmarines) == false or M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false or M28Utilities.IsTableEmpty(tMissileShips) == false)) then
        bHaveRunFromAir = true
        if bDebugMessages == true then LOG(sFunctionRef..': We have retreated from air before so want to retreat all naval units, time since last ran='..GetGameTimeSeconds() - tWZTeamData[M28Map.refiTimeLastRunFromEnemyAir]..'; iRetreatFromAirDuration='..iRetreatFromAirDuration) end
        if M28Utilities.IsTableEmpty(tAvailableSubmarines) == false and (M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] or 0) > 0 then RetreatAllUnits(tAvailableSubmarines) tAvailableSubmarines = nil end
        if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then RetreatAllUnits(tAvailableCombatUnits) tAvailableCombatUnits = nil end
        if M28Utilities.IsTableEmpty(tMissileShips) == false then RetreatAllUnits(tMissileShips) tMissileShips = nil end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering whether units should run from air, bHaveRunFromAir='..tostring(bHaveRunFromAir or false)..'; Time since last ran='..  GetGameTimeSeconds() - (tWZTeamData[M28Map.refiTimeLastRunFromEnemyAir] or 0)..'; tWZTeamData[M28Map.subrefWZThreatAlliedMAA]='..tWZTeamData[M28Map.subrefWZThreatAlliedMAA]..'; iEnemyAdjacentAirToGroundThreat='..iEnemyAdjacentAirToGroundThreat..'; iFriendlyAdjacentAAThreat='..iFriendlyAdjacentAAThreat..'; Is table of available subs empty='..tostring(M28Utilities.IsTableEmpty(tAvailableSubmarines))..'; Is table of combat units empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))) end

    if not(bHaveRunFromAir) or M28Utilities.IsTableEmpty(tAvailableSubmarines) == false or M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false or M28Utilities.IsTableEmpty(tMissileShips) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': About to get nearest enemy units to midpoint, tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]='..tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])) end
        --Have submarines consolidate to the one closest to the enemy if they are far away (factoring in range)
        local oFrontSub
        local iNearbyFriendlySubThreat = 0
        if M28Utilities.IsTableEmpty(tAvailableSubmarines) == false then
            local iClosestSubToEnemyBaseDist = 100000
            local iCurSubDist
            for iUnit, oUnit in tAvailableSubmarines do
                iCurSubDist = M28Utilities.GetDistanceBetweenPositions(tWZTeamData[M28Map.reftClosestEnemyBase], oUnit:GetPosition())
                if iCurSubDist < iClosestSubToEnemyBaseDist then
                    iClosestSubToEnemyBaseDist = iCurSubDist
                    oFrontSub = oUnit
                end
            end
            --Treat any subs far from the front sub as unavailable and just have them move to the front sub, factoring in their range differential
            local tbWZToConsolidate = {}
            local tFrontSubWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][oFrontSub[refiCurrentAssignmentWaterZone]][M28Map.subrefWZTeamData][iTeam]
            if tFrontSubWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] > 0 then
                tbWZToConsolidate[oFrontSub[refiCurrentAssignmentWaterZone]] = false
            else
                tbWZToConsolidate[oFrontSub[refiCurrentAssignmentWaterZone]] = true
            end
            for iCurUnit = table.getn(tAvailableSubmarines), 1, -1 do
                local oUnit = tAvailableSubmarines[iCurUnit]
                iCurSubDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oFrontSub:GetPosition())
                if iCurSubDist > 20 and (oUnit[M28UnitInfo.refiAntiNavyRange] <= oFrontSub[M28UnitInfo.refiAntiNavyRange] or iCurSubDist - oUnit[M28UnitInfo.refiAntiNavyRange] + oFrontSub[M28UnitInfo.refiAntiNavyRange] > 20) then
                    if tbWZToConsolidate[oUnit[refiCurrentAssignmentWaterZone]] == nil then
                        local tCurSubWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][oUnit[refiCurrentAssignmentWaterZone]][M28Map.subrefWZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': enemy antinavy threat in WZ '..oUnit[refiCurrentAssignmentWaterZone]..'='..tCurSubWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy]) end
                        if tCurSubWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] > 0 then
                            tbWZToConsolidate[oUnit[refiCurrentAssignmentWaterZone]] = false
                        else
                            tbWZToConsolidate[oUnit[refiCurrentAssignmentWaterZone]] = true
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Will consolidate subs if in a consolidation zone, moving oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by brain '..oUnit:GetAIBrain().Nickname..' to be closer to oFrontSub, iCurSubDist='..iCurSubDist..'; Cur unit WZ assignment='..oUnit[refiCurrentAssignmentWaterZone]..'; Front sub assignment='..oFrontSub[refiCurrentAssignmentWaterZone]..'; tbWZToConsolidate[oUnit[refiCurrentAssignmentWaterZone]]='..tostring(tbWZToConsolidate[oUnit[refiCurrentAssignmentWaterZone]])) end
                    if tbWZToConsolidate[oUnit[refiCurrentAssignmentWaterZone]] then
                        M28Orders.IssueTrackedMove(oUnit, oFrontSub:GetPosition(), 5, false, 'SubCons', false)
                        table.remove(tAvailableSubmarines, iCurUnit)
                    else
                        --Give orders to unit as normal
                        if (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > iBestAvailableSubmarineRange then
                            iBestAvailableSubmarineRange = oUnit[M28UnitInfo.refiAntiNavyRange]
                        end
                    end
                    if iCurSubDist <= 50 then
                        iNearbyFriendlySubThreat = iNearbyFriendlySubThreat + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
                    end
                else
                    if (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > iBestAvailableSubmarineRange then
                        iBestAvailableSubmarineRange = oUnit[M28UnitInfo.refiAntiNavyRange]
                    end
                    iNearbyFriendlySubThreat = iNearbyFriendlySubThreat + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit))
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': oFrontSub='..oFrontSub.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFrontSub)..'; owned by brain '..oFrontSub:GetAIBrain().Nickname..'; iNearbyFriendlySubThreat='..iNearbyFriendlySubThreat) end
        end
        if tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then

            local iClosestDist, iClosestSurfaceDist, iClosestNonHoverDist
            if bDebugMessages == true then LOG(sFunctionRef..': Will record details of nearest enemy units') end
            iClosestDist, iClosestSurfaceDist, iClosestNonHoverDist, oNearestEnemyToFriendlyBase, oNearestEnemySurfaceToFriendlyBase, oNearestEnemyNonHoverToFriendlyBase = GetNearestEnemyUnitsAndUpdateUnitTables(iPond, iWaterZone, tWZData, tWZTeamData, iTeam, tEnemySurfaceUnits, tEnemyNonHoverUnits)

            if not(oNearestEnemyToFriendlyBase) then
                if bDebugMessages == true then LOG(sFunctionRef..': WZ has flagged it has enemies here or in adjacent WZ but couldnt find any; iPond='..iPond..'; WZ='..iWaterZone) end
                tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = false
                tWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] = false
            end

            --First consider submarines
            --Do we have shot blocked on non-skirmisher units, no indirect fire units, and have signficantly more threat than the enemy or are on an island beachhead? If so then move instead of attakc-moving when attacking
            if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to move blocked units instead of attack moving them, ally combat='..tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]..'; Enemy combat='..tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]) end
            if tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] > tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 3 then
                bMoveBlockedNotAttackMove = true
            end

            if tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 1.5 > M28UnitInfo.GetMassCostOfUnits(tAvailableCombatUnits) + M28UnitInfo.GetMassCostOfUnits(tAvailableSubmarines) then
                bWantReinforcements = true
                if bDebugMessages == true then LOG(sFunctionRef..': Want reinforcements as enemy combat exceeds our combat rating, tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Our combat units rating='..M28UnitInfo.GetCombatThreatRating(tAvailableCombatUnits, false, true)) end
            end
        elseif (iBestAvailableSubmarineRange >= 80 or tWZTeamData[M28Map.subrefWZBestAlliedDFRange] >= 80) and tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= 2000 then
            --Consider enemies adjacent to an adjacent water zone
            local iClosestDist, iClosestSurfaceDist, iClosestNonHoverDist
            iClosestDist, iClosestSurfaceDist, iClosestNonHoverDist, oNearestEnemyToFriendlyBase, oNearestEnemySurfaceToFriendlyBase, oNearestEnemyNonHoverToFriendlyBase = GetNearestEnemyUnitsAndUpdateUnitTables(iPond, iWaterZone, tWZData, tWZTeamData, iTeam, tEnemySurfaceUnits, tEnemyNonHoverUnits, true)
            if oNearestEnemyToFriendlyBase then bMoveBlockedNotAttackMove = true end
        end

        local tSubmarinesWithNoTarget
        local tCombatUnitsWithNoTarget
        if not(oNearestEnemyNonHoverToFriendlyBase) then tSubmarinesWithNoTarget = tAvailableSubmarines end
        if not(oNearestEnemyToFriendlyBase) then tCombatUnitsWithNoTarget = tAvailableCombatUnits end



        if bUpdateNearestUnit and oNearestEnemyToFriendlyBase then
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            if aiBrain then
                M28Team.UpdateUnitLastKnownPosition(aiBrain, oNearestEnemyToFriendlyBase, true)
                if oNearestEnemyNonHoverToFriendlyBase and not(oNearestEnemyNonHoverToFriendlyBase == oNearestEnemyToFriendlyBase) then M28Team.UpdateUnitLastKnownPosition(aiBrain, oNearestEnemyNonHoverToFriendlyBase, true) end
                if oNearestEnemySurfaceToFriendlyBase and not(oNearestEnemySurfaceToFriendlyBase == oNearestEnemyToFriendlyBase) then M28Team.UpdateUnitLastKnownPosition(aiBrain, oNearestEnemySurfaceToFriendlyBase) end
            end
        end

        local bMoveAntiNavyForwardsAsCantSee = false
        if oNearestEnemyNonHoverToFriendlyBase and tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] and tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] < tWZTeamData[M28Map.subrefWZThreatAlliedAntiNavy] then
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            if aiBrain then
                if not(M28UnitInfo.CanSeeUnit(aiBrain, oNearestEnemyNonHoverToFriendlyBase)) then
                    bMoveAntiNavyForwardsAsCantSee = true
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to advance due to not seeing enemy, oNearestEnemyNonHoverToFriendlyBase='..(oNearestEnemyNonHoverToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyNonHoverToFriendlyBase) or 'nil')..'; Can see htis unit='..tostring(M28UnitInfo.CanSeeUnit(aiBrain, oNearestEnemyNonHoverToFriendlyBase))..'; bMoveAntiNavyForwardsAsCantSee='..tostring(bMoveAntiNavyForwardsAsCantSee)..'; aiBrain='..aiBrain.Nickname) end
            end
        end


        --Calculate firendly and enemy threat values
        local iAdjacentAlliedSubmersibleThreat = 0 -- = tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible]
        local iAdjacentEnemyAntiNavyThreat = 0 -- = tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy]
        local iAdjacentAlliedCombatThreat = 0 --= tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]
        local iAdjacentEnemyCombatThreat = 0 --= tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]
        local iModForEnemyScenario2Threat = 0 --Will increase this if we are deciding whether to attack another zone and that other zone doesnt have friendly combat units in it
        --If no enemies in this zone, then focus on the zone with the nearest enemy unit
        if oNearestEnemySurfaceToFriendlyBase then
            local iNearestUnitPlateauOrZero, iNearestUnitLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oNearestEnemySurfaceToFriendlyBase:GetPosition())
            if iNearestUnitPlateauOrZero == 0 and (iNearestUnitLandOrWaterZone or 0) > 0 then
                iTargetZoneForSurface = iNearestUnitLandOrWaterZone
            end
        end
        if oNearestEnemyNonHoverToFriendlyBase then
            local iNearestUnitPlateauOrZero, iNearestUnitLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oNearestEnemyNonHoverToFriendlyBase:GetPosition())
            if iNearestUnitPlateauOrZero == 0 and (iNearestUnitLandOrWaterZone or 0) > 0 then
                iTargetZoneForNonHover = iNearestUnitLandOrWaterZone
            end
        end


        --Calc threat differently for enemy antinavy threat if no targets for subs in this zone such that will want to try attacking an adjacent zone - i.e. want to predict whether we will still want to attack when our units are in the adjacent zone
        local bCalcAntiNavyThreatNormally = true
        if oNearestEnemyNonHoverToFriendlyBase and not(iTargetZoneForNonHover == iWaterZone) then
            bCalcAntiNavyThreatNormally = false
        end
        if not(bCalcAntiNavyThreatNormally) then
            local tTargetZoneWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iTargetZoneForNonHover]
            local tTargetZoneWZTeamData = tTargetZoneWZData[M28Map.subrefWZTeamData][iTeam]
            iAdjacentAlliedSubmersibleThreat = (tTargetZoneWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] or 0)
            iAdjacentEnemyAntiNavyThreat = (tTargetZoneWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] or 0)
            if bDebugMessages == true then LOG(sFunctionRef..': Nearest non hover threat is in zone '..iTargetZoneForNonHover..'; will use this as the base for deciding whether to attack with subs, repru(tTargetZoneWZData[M28Map.subrefWZAdjacentWaterZones])='..repru(tTargetZoneWZData[M28Map.subrefWZAdjacentWaterZones])) end
            if M28Utilities.IsTableEmpty(tTargetZoneWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                for _, iAdjWZ in tTargetZoneWZData[M28Map.subrefWZAdjacentWaterZones] do
                    local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                    iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat = IncludeThreatOfAdjacentZone(iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, tTargetZoneWZData, tAdjWZTeamData, iAdjWZ, true, true, false, false)
                    --iAdjacentAlliedSubmersibleThreat = iAdjacentAlliedSubmersibleThreat + (tAdjWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] or 0)
                    --iAdjacentEnemyAntiNavyThreat = iAdjacentEnemyAntiNavyThreat + (tAdjWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] or 0)
                end
            end
            if M28Utilities.IsTableEmpty(tTargetZoneWZTeamData[M28Map.subrefWZTAlliedCombatUnits]) == false then
                iModForEnemyScenario2Threat = iModForEnemyScenario2Threat + 0.075
            end
        else
            iAdjacentAlliedSubmersibleThreat = (tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] or 0)
            iAdjacentEnemyAntiNavyThreat = (tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] or 0)
        end

        local bCalcCombatThreatNormally = true
        if oNearestEnemySurfaceToFriendlyBase and not(iTargetZoneForSurface == iWaterZone) then
            bCalcCombatThreatNormally = false
        end
        if not(bCalcCombatThreatNormally) then
            local tTargetZoneWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iTargetZoneForNonHover]
            local tTargetZoneWZTeamData = tTargetZoneWZData[M28Map.subrefWZTeamData][iTeam]
            iAdjacentAlliedCombatThreat = (tTargetZoneWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0)
            iAdjacentEnemyCombatThreat = (tTargetZoneWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)

            if M28Utilities.IsTableEmpty(tTargetZoneWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                for _, iAdjWZ in tTargetZoneWZData[M28Map.subrefWZAdjacentWaterZones] do
                    local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                    iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat = IncludeThreatOfAdjacentZone(iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, tTargetZoneWZData, tAdjWZTeamData, iAdjWZ, false, false, true, true)
                    --iAdjacentAlliedCombatThreat = iAdjacentAlliedCombatThreat + (tAdjWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0)
                    --iAdjacentEnemyCombatThreat = iAdjacentEnemyCombatThreat + (tAdjWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                end
            end
            if M28Utilities.IsTableEmpty(tTargetZoneWZTeamData[M28Map.subrefWZTAlliedCombatUnits]) == false then
                iModForEnemyScenario2Threat = iModForEnemyScenario2Threat + 0.075
            end
        else
            iAdjacentAlliedCombatThreat = (tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0)
            iAdjacentEnemyCombatThreat = (tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
        end


        if bCalcAntiNavyThreatNormally or bCalcCombatThreatNormally then
            for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat = IncludeThreatOfAdjacentZone(iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, tWZData, tAdjWZTeamData, iAdjWZ, bCalcAntiNavyThreatNormally, bCalcAntiNavyThreatNormally, bCalcCombatThreatNormally, bCalcCombatThreatNormally)
            end
        end


        if bDebugMessages == true then LOG(sFunctionRef..': oNearestEnemyNonHoverToFriendlyBase='..(oNearestEnemyNonHoverToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyNonHoverToFriendlyBase) or 'nil')..'; Is table of avaialble subs empty='..tostring(M28Utilities.IsTableEmpty(tAvailableSubmarines))..'; tWZTeamData[M28Map.subrefWZBestAlliedSubmersibleRange]='..tWZTeamData[M28Map.subrefWZBestAlliedSubmersibleRange]..'; iEnemyBestAntiNavyRange='..iEnemyBestAntiNavyRange..', will set iScenario1AntiNavyRangeThreshold equal to enemy best antinavy range') end
        if oNearestEnemyNonHoverToFriendlyBase and M28Utilities.IsTableEmpty(tAvailableSubmarines) == false then
            local bAttackAndKite = false
            local iScenario1AntiNavyRangeThreshold = iEnemyBestAntiNavyRange
            if tWZTeamData[M28Map.subrefWZBestAlliedSubmersibleRange] > iEnemyBestAntiNavyRange then
                bAttackAndKite = true
                if bDebugMessages == true then LOG(sFunctionRef..': We outrange enemy antinavy') end
            else
                --If closeest enemy is a non-hover unit and has significantly worse antinavy range than us, and nearest enemy with equal or better antinavy is too far away, then attack and kite
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we can still be aggressive if we outrange the nearest enemy to us, nearest enemy antinavy='..(oNearestEnemyToFriendlyBase[M28UnitInfo.refiAntiNavyRange] or 0)..'; iBestAvailableSubmarineRange='..iBestAvailableSubmarineRange..'; Is nearest enemy unit the nearest hover='..tostring(oNearestEnemyToFriendlyBase == oNearestEnemyNonHoverToFriendlyBase)) end
                if oNearestEnemyToFriendlyBase == oNearestEnemyNonHoverToFriendlyBase and (oNearestEnemyToFriendlyBase[M28UnitInfo.refiAntiNavyRange] or 0) < iBestAvailableSubmarineRange - 8 then
                    --Check for if the enemy has antinavy units that are close enough to this unit that they could support it
                    local bClosestUnitHasAntiNavyCover = false
                    local iAntiNavyMinEnemyRange = iBestAvailableSubmarineRange - 8 --i.e. enemy units with an anti-navy range that are close to outranigng our antinavy attack (or that outrange entirely) shall be considered for assessment
                    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]) == false then
                        local iDistUntilEnemyAntiNavyInRangeOfClosestEnemy
                        local iStructureThreshold = math.max(-10, -(iBestAvailableSubmarineRange - 10)) --i.e. if our unit can in range of closest enemy by at least 10 before getting in range of enemy torpedo launcher, then proceed with attack
                        for iUnit, oUnit in tWZTeamData[M28Map.reftoNearestCombatEnemies] do
                            if (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) >= iAntiNavyMinEnemyRange then
                                iDistUntilEnemyAntiNavyInRangeOfClosestEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition()) - (oUnit[M28UnitInfo.refiAntiNavyRange] or 0)
                                if bDebugMessages == true then LOG(sFunctionRef..': iDistUntilEnemyAntiNavyInRangeOfClosestEnemy='..iDistUntilEnemyAntiNavyInRangeOfClosestEnemy..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Actual dist to closest enemy='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase:GetPosition())..'; Anti navy range='..oUnit[M28UnitInfo.refiAntiNavyRange]..'; Unit assigned WZ for our team='..(oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] or 'nil')) end
                                if iDistUntilEnemyAntiNavyInRangeOfClosestEnemy <= 16 and (iDistUntilEnemyAntiNavyInRangeOfClosestEnemy <= iStructureThreshold or EntityCategoryContains(categories.MOBILE, oUnit.UnitId)) then --within 16 of being in range of the unit closest to our base
                                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy antinavy close enough to support their nearest enemy unit that we cant try attacking nearest enemy and then retreating when its antinavy support arrives') end
                                    bClosestUnitHasAntiNavyCover = true
                                    break
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy unit doesnt have good enough antinaavy range; bClosestUnitHasAntiNavyCover='..tostring(bClosestUnitHasAntiNavyCover)..'; is tEnemyNonHoverUnits empty='..tostring(M28Utilities.IsTableEmpty(tEnemyNonHoverUnits))..'; Is tWZTeamData[M28Map.reftoNearestCombatEnemies] empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]))) end
                    if not(bClosestUnitHasAntiNavyCover) then
                        bAttackAndKite = true
                    end
                end
                if bAttackAndKite then iScenario1AntiNavyRangeThreshold = 5 end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Checking if in scenario 1 or 2 for subs, tWZTeamData[M28Map.subrefWZbCoreBase]='..tostring(tWZTeamData[M28Map.subrefWZbCoreBase] or false)..'; tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible]='..tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible]..'; tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy]='..tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy]..'; tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]='..tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]..'; tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; iAdjacentAlliedSubmersibleThreat='..iAdjacentAlliedSubmersibleThreat..'; iNearbyFriendlySubThreat='..iNearbyFriendlySubThreat..'; iAdjacentEnemyAntiNavyThreat='..iAdjacentEnemyAntiNavyThreat..'; iAdjacentAlliedCombatThreat='.. iAdjacentAlliedCombatThreat..'; iAdjacentEnemyCombatThreat='..iAdjacentEnemyCombatThreat..'; bAttackAndKite='..tostring(bAttackAndKite)) end
            if bAttackAndKite then
                --Scenario 1 - our subs outrange enemy antinavy
                local tOutrangedCombatUnits = {}
                local tUnitsToSupport = {}
                local bAttackWithOutrangedSubUnits = false
                if tWZTeamData[M28Map.subrefWZbCoreBase] then bAttackWithOutrangedSubUnits = true
                elseif tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] > tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] then bAttackWithOutrangedSubUnits = true
                end

                if M28Utilities.GetDistanceBetweenPositions(oNearestEnemyNonHoverToFriendlyBase:GetPosition(), oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) >= 10 then bCheckIfNearestUnitVisible = true end

                for iUnit, oUnit in tAvailableSubmarines do
                    if bDebugMessages == true then LOG(sFunctionRef..': Scenario 1 main unit loop, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Antinavy range='..(oUnit[M28UnitInfo.refiAntiNavyRange] or 'nil')..'; iScenario1AntiNavyRangeThreshold='..(iScenario1AntiNavyRangeThreshold or 'nil')) end
                    if oUnit[M28UnitInfo.refiAntiNavyRange] > iScenario1AntiNavyRangeThreshold then
                        table.insert(tUnitsToSupport, oUnit)
                        --Seraphim sub and atlantis - make sure are submerged if no enemy AA threat (unless are in bombardment mode for atlantis)
                        if EntityCategoryContains(M28UnitInfo.refCategoryAntiAir, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbSpecialMicroActive]) and
                                --No enemy air units so want to submerge (unless are in bombardment mode and either have an atlantis, or any enemy air unit)
                                ((tWZTeamData[M28Map.refiEnemyAirToGroundThreat] == 0 and not(M28UnitInfo.IsUnitUnderwater(oUnit)) and ((GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBombardmentModeByPond][iPond] or 0)) >= 30 or (M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]) and not(EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId)))))
                                        or (tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 and M28UnitInfo.IsUnitUnderwater(oUnit))) then
                            M28UnitInfo.ToggleUnitDiveOrSurfaceStatus(oUnit)
                            --Consider kiting logic unless want to use shot blocked override logic
                        elseif bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                            --If subs are really close to the target they wont fire, so add in a distance check
                            if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyNonHoverToFriendlyBase:GetPosition()) >= 3 then
                                M28Orders.IssueTrackedMove(oUnit, oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'NSBlckM'..iWaterZone)
                            else
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyNonHoverToFriendlyBase:GetPosition(), 3, false, 'NSBlckAM'..iWaterZone)
                            end
                            --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                            if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                        else
                            --Are we not in range of any enemy, or are easy M28? Then attack move
                            --CloseToEnemyUnit(tStartPosition, tUnitsToCheck,                                               iDistThreshold,                    iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                            if oUnit[M28UnitInfo.refbEasyBrain] or bMoveAntiNavyForwardsAsCantSee or M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]) or iScenario1AntiNavyRangeThreshold <= 5 or (iScenario1AntiNavyRangeThreshold + 10 < oUnit[M28UnitInfo.refiAntiNavyRange] and (oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.refiAntiNavyRange] or 0) == 0) or (not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tWZTeamData[M28Map.reftoNearestCombatEnemies], oUnit[M28UnitInfo.refiAntiNavyRange] * 0.94, iTeam, false,                nil,                    nil,                                    oUnit)) and (not(M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) or (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiAntiNavyRange] or 0) == 0 or M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition()) >= oUnit[M28UnitInfo.refiAntiNavyRange] or not(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], false)))) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Not in range of enemy yet (or enemy ahs no antinavy), and we outrange enemy; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Antinavy range='..oUnit[M28UnitInfo.refiAntiNavyRange]..'; oNearestEnemyNonHoverToFriendlyBase='..oNearestEnemyNonHoverToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyNonHoverToFriendlyBase)..'; oNearestEnemyNonHoverToFriendlyBase antinavy range='..(oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.refiAntiNavyRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oNearestEnemyNonHoverToFriendlyBase:GetPosition())..'; Enemy last recorded position='..repru(oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; WZ midpoint position='..repru(tWZData[M28Map.subrefMidpoint])) end
                                --Not in range yet, so attack move to the nearest enemy
                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit[M28UnitInfo.refiAntiNavyRange] * 0.5, false, 'NSKAMve'..iWaterZone)
                                end
                            else
                                --Enemy has DF units and they are already in our range so retreat
                                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                ForkThread(M28Land.BackupUnitTowardsRallyIfAvailable, oUnit, tRallyPoint, iPond, 'NSKRetr', false, nil, nil, true)
                                --M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'NSKRetr'..iWaterZone)
                                --If enemy is able to shoot us then get DF support
                                if not(bAttackWithOutrangedSubUnits) and (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiAntiNavyRange] or 0) > 0 and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()) < oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiAntiNavyRange] then
                                    --Enemy antinavy unit is in range of our longer ranged sub unit
                                    bAttackWithOutrangedSubUnits = true
                                end
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                            end
                        end
                    else
                        if oUnit[M28UnitInfo.refiAntiNavyRange] > 0 then
                            --We dont outrange the enemy, but we do have other units that do
                            if EntityCategoryContains(M28UnitInfo.refCategoryAntiAir, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbSpecialMicroActive]) and ((tWZTeamData[M28Map.refiEnemyAirToGroundThreat] == 0 and not(M28UnitInfo.IsUnitUnderwater(oUnit))) or (tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 and M28UnitInfo.IsUnitUnderwater(oUnit))) then
                                M28UnitInfo.ToggleUnitDiveOrSurfaceStatus(oUnit)
                            else
                                table.insert(tOutrangedCombatUnits, oUnit)
                            end
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tOutrangedCombatUnits) == false then
                    if bAttackWithOutrangedSubUnits then
                        for iUnit, oUnit in tOutrangedCombatUnits do
                            if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                                M28Orders.IssueTrackedMove(oUnit, oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'WSOBlckM'..iWaterZone)
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                            else
                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit[M28UnitInfo.refiAntiNavyRange] * 0.5, false, 'WSSRDFA'..iWaterZone)
                                end
                            end
                        end
                    else
                        if M28Utilities.IsTableEmpty(tUnitsToSupport) == false then
                            --Short range units can stay back and provide support - stay inbetween our long range units and the rally point
                            local iCurDist
                            local iClosestDist
                            local oClosestUnit
                            for iSRUnit, oSRUnit in tOutrangedCombatUnits do
                                iClosestDist = 100000
                                for iLRUnit, oLRUnit in tUnitsToSupport do
                                    iCurDist = M28Utilities.GetRoughDistanceBetweenPositions(oSRUnit:GetPosition(), oLRUnit:GetPosition())
                                    if iCurDist < iClosestDist then
                                        iClosestDist = iCurDist
                                        oClosestUnit = oLRUnit
                                    end
                                end
                                M28Orders.IssueTrackedMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), tRallyPoint), 5, true, false, true), 5, false, 'WSSRSup'..iWaterZone)
                            end
                        else
                            M28Utilities.ErrorHandler('We somehow think we outrange the enemy with subs, but have no subs units with a long range, iWZ='..iWaterZone)
                        end
                    end
                end
            else
                --WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iNearbyFriendlySubThreat, iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, bConsideringSubmarinesNotSurface, iOptionalThreatAbsolutePercentIncrease)
                if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to attack enemy even if outranged, iAdjacentAlliedSubmersibleThreat='..iAdjacentAlliedSubmersibleThreat..'; iAdjacentEnemyAntiNavyThreat='..iAdjacentEnemyAntiNavyThreat..'; iAdjacentAlliedCombatThreat='..iAdjacentAlliedCombatThreat..'; iAdjacentEnemyCombatThreat='..iAdjacentEnemyCombatThreat..'; iModForEnemyScenario2Threat='..iModForEnemyScenario2Threat..'; Want to attack='..tostring(M28Conditions.WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iNearbyFriendlySubThreat, iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, true                             ,iModForEnemyScenario2Threat ))..'; tWZTeamData[M28Map.subrefWZbSuicideIntoEnemy]='..tostring(tWZTeamData[M28Map.subrefWZbSuicideIntoEnemy] or false)) end
                local bSubInScenario2
                if tWZTeamData[M28Map.subrefWZbSuicideIntoEnemy] then

                    bSubInScenario2 = true
                else
                    bSubInScenario2 = M28Conditions.WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iNearbyFriendlySubThreat, iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, true                             ,iModForEnemyScenario2Threat )
                    if bSubInScenario2 and tWZTeamData[M28Map.subrefWZbCoreBase] then
                        tWZTeamData[M28Map.subrefWZbSuicideIntoEnemy] = true
                        M28Utilities.ForkedDelayedChangedVariable(tWZTeamData, M28Map.subrefWZbSuicideIntoEnemy, false, 30)
                        if bDebugMessages == true then LOG(sFunctionRef..': Subs Setting suicide flag to true, is table of adj WZs empty='..tostring( M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]))) end
                        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                            for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                                local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to set Suicide flag to true for iAdjWZ='..iAdjWZ..' (based on base iWZ='..iWaterZone..'); tAdjWZTeamData[M28Map.subrefWZbSuicideIntoEnemy]='..tostring(tAdjWZTeamData[M28Map.subrefWZbSuicideIntoEnemy] or false)) end
                                if not(tAdjWZTeamData[M28Map.subrefWZbSuicideIntoEnemy]) then
                                    tAdjWZTeamData[M28Map.subrefWZbSuicideIntoEnemy] = true
                                    M28Utilities.ForkedDelayedChangedVariable(tAdjWZTeamData, M28Map.subrefWZbSuicideIntoEnemy, false, 30)
                                    if tAdjWZTeamData[M28Map.subrefWZbCoreBase] and M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]) == false then
                                        for _, iSecondAdjWZ in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZAdjacentWaterZones] do
                                            local tSecondAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iSecondAdjWZ][M28Map.subrefWZTeamData][iTeam]
                                            if not(tSecondAdjWZTeamData[M28Map.subrefWZbSuicideIntoEnemy]) then
                                                if tSecondAdjWZTeamData then
                                                    tSecondAdjWZTeamData[M28Map.subrefWZbSuicideIntoEnemy] = true
                                                    M28Utilities.ForkedDelayedChangedVariable(tSecondAdjWZTeamData, M28Map.subrefWZbSuicideIntoEnemy, false, 30)
                                                else
                                                    M28Utilities.ErrorHandler('Dont have a valid second WZ ref')
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                if bSubInScenario2 then
                    --SCENARIO 2 - We are either near our core naval factory or we have a greater threat than the enemy - attack
                    if bDebugMessages == true then LOG(sFunctionRef..': Are in scenario 2 for subs, bMoveBlockedNotAttackMove='..tostring(bMoveBlockedNotAttackMove or false)) end
                    for iUnit, oUnit in tAvailableSubmarines do
                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to move or attack move for sub '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[M28UnitInfo.refbLastShotBlocked]='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked])) end
                        if oUnit.Dead then --wierd bug where sometimes unit is dead
                            --Do nothing
                        elseif not(M28UnitInfo.IsUnitValid(oNearestEnemyNonHoverToFriendlyBase)) then
                            --Redundancy (hopefully should only trigger temporarily if a unit dies)
                            if bDebugMessages == true then LOG(sFunctionRef..': No valid nearby enemy non hover so will just attackmove towards enemy base') end
                            M28Orders.IssueTrackedAggressiveMove(oUnit, (oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or tWZTeamData[M28Map.reftClosestEnemyBase]), iOrderReissueDistToUse, false, 'WARedA'..iWaterZone)
                            --Subs with stealth - once in range of enemy then dont keep advancing (since they dont use the stealth category, have to use the unit Id)
                        elseif oNearestEnemyNonHoverToFriendlyBase and oUnit.UnitId == 'xrs0204' and not(oUnit[M28UnitInfo.refbLastShotBlocked]) and (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > 0 then
                            --Attack-move if almost in range; move away if already in range
                            if bDebugMessages == true then LOG(sFunctionRef..': Stealth sub dist to enemy='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyNonHoverToFriendlyBase:GetPosition())..'; Can see neemy='..tostring(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oNearestEnemyNonHoverToFriendlyBase, false))) end
                            if not(M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oNearestEnemyNonHoverToFriendlyBase, false)) then
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyNonHoverToFriendlyBase:GetPosition(), 3, false, 'SWBAMSt'..iWaterZone)
                            else
                                local iDistToEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyNonHoverToFriendlyBase:GetPosition())
                                if iDistToEnemy <= oUnit[M28UnitInfo.refiAntiNavyRange] - 2 then
                                    --Move away towards rally point
                                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'SWSbStKit'..iWaterZone)
                                else
                                    --Attackmove towards enemy
                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyNonHoverToFriendlyBase:GetPosition(), 3, false, 'SWBASt'..iWaterZone)
                                end
                            end
                        elseif oNearestEnemyNonHoverToFriendlyBase and oUnit[M28UnitInfo.refiAntiNavyRange] - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyNonHoverToFriendlyBase:GetPosition()) <= 10 and EntityCategoryContains(categories.MOBILE, oNearestEnemyNonHoverToFriendlyBase.UnitId) then
                            M28Orders.IssueTrackedMove(oUnit, oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'SWSbMv'..iWaterZone)
                        elseif bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                            --If subs are really close to the target they wont fire, so add in a distance check
                            if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyNonHoverToFriendlyBase:GetPosition()) >= 3 then
                                M28Orders.IssueTrackedMove(oUnit, oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'SWBAWE'..iWaterZone)
                            else
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyNonHoverToFriendlyBase:GetPosition(), 3, false, 'SWBAMW'..iWaterZone)
                            end

                            --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                            if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                        else
                            if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'SWAWE'..iWaterZone)
                            end
                        end
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': In scenario 3 so will retreat') end
                    --Scenario 3 - want to retreat, or (if we have enough threat available to us) to rally in this zone
                    bWantReinforcements = true
                    local iAvailableSubmersibleThreat = M28UnitInfo.GetCombatThreatRating(tAvailableSubmarines, false, false, false, false, true, false, false)
                    local tSubRallyPoint
                    local sMessage
                    local bConsiderAmphibiousRally = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have enough threat to attack, will see if we want to consolidate in this zone, iAvailableSubmersibleThreat='..iAvailableSubmersibleThreat..'; iAdjacentAlliedSubmersibleThreat='..iAdjacentAlliedSubmersibleThreat..'; Want to attack with navy='..tostring(M28Conditions.WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iNearbyFriendlySubThreat, iAvailableSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, true, iModForEnemyScenario2Threat ))) end
                    if iAvailableSubmersibleThreat > iAdjacentAlliedSubmersibleThreat * 1.1 and iAvailableSubmersibleThreat > (tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] or 0) * 2 and M28Conditions.WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iNearbyFriendlySubThreat, iAvailableSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, true, iModForEnemyScenario2Threat ) then
                        sMessage = 'WSConsR'
                        tSubRallyPoint = {tWZData[M28Map.subrefMidpoint][1], tWZData[M28Map.subrefMidpoint][2], tWZData[M28Map.subrefMidpoint][3]}
                        bConsiderAmphibiousRally = false
                    else
                        sMessage = 'WSRetr'
                        tSubRallyPoint = tRallyPoint
                    end
                    local tAmphibiousRallyPoint = {tWZTeamData[M28Map.reftClosestFriendlyBase][1], tWZTeamData[M28Map.reftClosestFriendlyBase][2], tWZTeamData[M28Map.reftClosestFriendlyBase][3]}
                    local iAmphibiousRallyPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tAmphibiousRallyPoint)
                    for iUnit, oUnit in tAvailableSubmarines do
                        --Only retreat units from this WZ
                        if oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iWaterZone then
                            oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                            if bConsiderAmphibiousRally and EntityCategoryContains(M28UnitInfo.refCategoryAmphibious + categories.HOVER, oUnit.UnitId) then --redundancy - wouldnt expect a sub to be amphibious
                                if iAmphibiousRallyPlateau then
                                    ForkThread(M28Land.BackupUnitTowardsRallyIfAvailable, oUnit, tRallyPoint, iAmphibiousRallyPlateau, sMessage..'_AmphR'..iWaterZone, false, nil, nil, false)
                                else
                                    M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, sMessage..'_AmphR'..iWaterZone)
                                end
                            else
                                ForkThread(M28Land.BackupUnitTowardsRallyIfAvailable, oUnit, tSubRallyPoint, iPond, sMessage..iWaterZone, false, nil, nil, true)
                                --M28Orders.IssueTrackedMove(oUnit, tSubRallyPoint, 6, false, sMessage..iWaterZone)
                            end
                        else
                            oUnit[refiCurrentWZAssignmentValue] = 0
                        end
                    end
                end
            end
        end


        --Now consider non-submarine combat units
        if bDebugMessages == true then LOG(sFunctionRef..': oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase) or 'nil')..'; Is table of available combat units empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))..'; oNearestEnemySurfaceToFriendlyBase='..(oNearestEnemySurfaceToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemySurfaceToFriendlyBase) or 'nil')) end
        if oNearestEnemyToFriendlyBase and M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
            local oEnemyToFocusOn

            local tCombatUnitsOfUse
            local tCombatUnitsNeedingAOEForSubs
            local bConsiderUsingAOE = false

            if not(M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) and oNearestEnemyNonHoverToFriendlyBase and (EntityCategoryContains(categories.SUBMERSIBLE, oNearestEnemyNonHoverToFriendlyBase.UnitId) or oNearestEnemyNonHoverToFriendlyBase.UnitId == 'xrb2308' or (M28Map.IsUnderwater({oNearestEnemyNonHoverToFriendlyBase:GetPosition()[1], oNearestEnemyNonHoverToFriendlyBase:GetPosition()[2] + (oNearestEnemyNonHoverToFriendlyBase:GetBlueprint().SizeY or 0) + 1.3, oNearestEnemyNonHoverToFriendlyBase:GetPosition()[3]}, false)) and not(M28Map.IsUnderwater({oNearestEnemyNonHoverToFriendlyBase:GetPosition()[1], oNearestEnemyNonHoverToFriendlyBase:GetPosition()[2] + 1.2 + (oNearestEnemyNonHoverToFriendlyBase:GetBlueprint().SizeY or 0) + 1.3, oNearestEnemyNonHoverToFriendlyBase:GetPosition()[3]}, false))) then
                --Check we have a non-M28Easy on the team
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    if not(oBrain.M28Easy) then
                        bConsiderUsingAOE = true
                        break
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished considering if we want to use aoe to ground fire subs, bConsiderUsingAOE='..tostring(bConsiderUsingAOE)..'; oNearestEnemyNonHoverToFriendlyBase='..(oNearestEnemyNonHoverToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyNonHoverToFriendlyBase) or 'nil')..'; oNearestEnemySurfaceToFriendlyBase='..(oNearestEnemySurfaceToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemySurfaceToFriendlyBase) or 'nil'))
                if oNearestEnemyNonHoverToFriendlyBase then
                    LOG(sFunctionRef..': Is nearest enemy submersible='..tostring(EntityCategoryContains(categories.SUBMERSIBLE, oNearestEnemyNonHoverToFriendlyBase.UnitId))..'; Is nearest unit underwater='..tostring(not(M28Map.IsUnderwater({oNearestEnemyNonHoverToFriendlyBase:GetPosition()[1], oNearestEnemyNonHoverToFriendlyBase:GetPosition()[2] + 1.2 + (oNearestEnemyNonHoverToFriendlyBase:GetBlueprint().SizeY or 0) + 1.3, oNearestEnemyNonHoverToFriendlyBase:GetPosition()[3]}, false)))..'; Nearest enemy position='..repru(oNearestEnemyNonHoverToFriendlyBase:GetPosition())..'; Unit sizeY='..(oNearestEnemyNonHoverToFriendlyBase:GetBlueprint().SizeY or 'nil')..'; Water height='..M28Map.iMapWaterHeight)
                end
            end




            if bConsiderUsingAOE and (EntityCategoryContains(M28UnitInfo.refCategorySubmarine, oNearestEnemyNonHoverToFriendlyBase.UnitId) or not(oNearestEnemySurfaceToFriendlyBase)) then
                tCombatUnitsOfUse = {}
                tCombatUnitsWithNoTarget = {}
                tCombatUnitsNeedingAOEForSubs = {}
                for iUnit, oUnit in tAvailableCombatUnits do
                    if bConsiderUsingAOE and (oUnit[M28UnitInfo.refiDFAOE] or 0) >= 1.4 and oNearestEnemyNonHoverToFriendlyBase and ((oUnit[M28UnitInfo.refiAntiNavyRange] or 0) == 0 or EntityCategoryContains(M28UnitInfo.refCategoryBattleship, oUnit.UnitId)) then --Doing testing in sandbox, Aeon T2 destroyer aoe of 1.4 can kill subs, as can battleships, but other destroyers with aoe of 1 cant hit subs via ground fire
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with no antinavy range but aoe of '..(oUnit[M28UnitInfo.refiDFAOE] or 0)..' to tCombatUnitsNeedingAOEForSubs') end
                        table.insert(tCombatUnitsNeedingAOEForSubs, oUnit)
                    elseif (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with antinavy range '..oUnit[M28UnitInfo.refiAntiNavyRange]..' to combat units of use') end
                        table.insert(tCombatUnitsOfUse, oUnit)
                    elseif oNearestEnemySurfaceToFriendlyBase and (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': since enemy has surface unit and we ahve DF attack we are still of use in combat, adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to combat units of use') end
                        table.insert(tCombatUnitsOfUse, oUnit)
                    else
                        table.insert(tCombatUnitsWithNoTarget, oUnit)
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with no antinavy range and aoe of '..(oUnit[M28UnitInfo.refiDFAOE] or 0)..' to tCombatUnitsWithNoTarget') end
                    end
                end
            else
                if oNearestEnemySurfaceToFriendlyBase then tCombatUnitsOfUse = tAvailableCombatUnits
                else
                    tCombatUnitsOfUse = {}
                    tCombatUnitsWithNoTarget = {}
                    for iUnit, oUnit in tAvailableCombatUnits do
                        if (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > 0 then
                            table.insert(tCombatUnitsOfUse, oUnit)
                        else
                            table.insert(tCombatUnitsWithNoTarget, oUnit)
                        end
                    end
                end
            end


            local iEnemyBestRange = math.max(tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange], tWZTeamData[M28Map.subrefWZBestEnemyDFRange], iEnemyBestAntiNavyRange, iEnemyBestCombatRange)
            if bDebugMessages == true then LOG(sFunctionRef..': Set iEnemyBestRange='..iEnemyBestRange..'; tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange]='..tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange]..'; tWZTeamData[M28Map.subrefWZBestEnemyDFRange]='..tWZTeamData[M28Map.subrefWZBestEnemyDFRange]..'; iEnemyBestAntiNavyRange='..iEnemyBestAntiNavyRange..'; iEnemyBestCombatRange='..iEnemyBestCombatRange) end
            local iAlliedBestAntiNavyRange = 0
            local iEnemyBestSumbersibleRange = (tWZTeamData[M28Map.subrefWZBestEnemySubmersibleRange] or 0)
            local iEnemyNearbySubmersibleThreat = tWZTeamData[M28Map.subrefWZThreatEnemySubmersible]
            for iUnit, oUnit in tAvailableCombatUnits do
                iAlliedBestAntiNavyRange = math.max(iAlliedBestAntiNavyRange, (oUnit[M28UnitInfo.refiAntiNavyRange] or 0))
                --If we have a battleship then treat our antinavy range as being equal to that of the battleship
                if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' DF AOE='..(oUnit[M28UnitInfo.refiDFAOE] or 0)..'; is battleship='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryBattleship, oUnit.UnitId))..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0)) end
                if (oUnit[M28UnitInfo.refiDFAOE] or 0) >= 2 and EntityCategoryContains(M28UnitInfo.refCategoryBattleship, oUnit.UnitId) then iAlliedBestAntiNavyRange = math.max(iAlliedBestAntiNavyRange, (oUnit[M28UnitInfo.refiDFRange] or 0)) end
            end
            local iOurAntiNavyThreat = M28UnitInfo.GetCombatThreatRating(tAvailableCombatUnits, false, false, false, true)
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                    local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                    iEnemyBestSumbersibleRange = math.max(iEnemyBestSumbersibleRange, (tAdjWZTeamData[M28Map.subrefWZBestEnemySubmersibleRange] or 0))
                    iEnemyNearbySubmersibleThreat = iEnemyNearbySubmersibleThreat + (tAdjWZTeamData[M28Map.subrefWZThreatEnemySubmersible] or 0)
                end
            end

            function KitingRetreatOfUnit(oUnit)
                --Enemy has DF units and they are already in our range so retreat
                if bDebugMessages == true then LOG(sFunctionRef..': KitingRetreatOfUnit: Are close to enemies, Unit combat range='..oUnit[M28UnitInfo.refiCombatRange]..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                --If we havent fired for a while and are in a core WZ then try an attack order instead
                oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                if tWZTeamData[M28Map.subrefWZbCoreBase] and GetGameTimeSeconds() - 2 - (oUnit[M28UnitInfo.refiLastWeaponEvent] or -100) > oUnit[M28UnitInfo.refiTimeBetweenDFShots] and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint) <= 16 then
                    M28Orders.IssueTrackedAttack(oUnit, oEnemyToFocusOn, false, 'NotFirS', false)
                else
                    --Check rally point means we will actually be moving away from the closest enemy
                    local bRunFromNearestEnemy
                    local tRetreatLocation
                    if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                        local iAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())
                        local iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)

                        if bDebugMessages == true then LOG(sFunctionRef..': iAngleToNearestEnemy='..iAngleToNearestEnemy..'; iAngleToRally='..iAngleToRally..'; Angle dif='..M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToRally)..'; Nearest enemy='..oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) end
                        if M28Utilities.GetAngleDifference(iAngleToNearestEnemy, iAngleToRally) <= 80 or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint) <= 9 then
                            tRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToNearestEnemy + 180, 10, true, false, M28Map.bIsCampaignMap)
                            if tRetreatLocation then
                                local iKitingSegmentX, iKitingSegmentZ = M28Map.GetPathingSegmentFromPosition(tRetreatLocation)
                                if M28Map.tPondBySegment[iKitingSegmentX][iKitingSegmentZ] == iPond then
                                    bRunFromNearestEnemy = true
                                    --M28Orders.IssueTrackedMove(oUnit, tKitingRetreatLocation, iOrderReissueDistToUse, false, 'NKRetNrE'..iWaterZone)
                                else
                                    tRetreatLocation = nil
                                end
                            end
                        end
                    end
                    if not(bRunFromNearestEnemy) then
                        tRetreatLocation = nil --redundancy
                    end

                    --Decide if we want to attack move instead of doing kiting retreat - consider for higher cost units (destroyers and better) that haven't fired recently
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to do kiting retreat or attackmove retreat, oUnit[M28UnitInfo.refiUnitMassCost]='..oUnit[M28UnitInfo.refiUnitMassCost]..'; oUnit[M28UnitInfo.refiDFRange]='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; oUnit[M28UnitInfo.refiTimeBetweenDFShots]='..(oUnit[M28UnitInfo.refiTimeBetweenDFShots] or 'nil')..'; oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) or 'nil')..'; Time since last weapon event='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0))
                        if oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] then
                            LOG(sFunctionRef..': Dist to closest enemy unit='..M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition())..'; Enemy unit combat range='..(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiCombatRange] or 'nil'))
                        end
                    end

                    if not(oUnit[M28UnitInfo.refbAttackMoveInsteadOfKiting]) and oUnit[M28UnitInfo.refiUnitMassCost] > 1500 and (oUnit[M28UnitInfo.refiDFRange] or 0) > 20 and oUnit[M28UnitInfo.refiTimeBetweenDFShots] and oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0) > 4 + oUnit[M28UnitInfo.refiTimeBetweenDFShots] and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()) <= math.max(oUnit[M28UnitInfo.refiDFRange]*0.5, math.min(oUnit[M28UnitInfo.refiDFRange] * 0.8, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiCombatRange])) and M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck], false) then
                        oUnit[M28UnitInfo.refbAttackMoveInsteadOfKiting] = true
                        M28Utilities.DelayChangeVariable(oUnit, M28UnitInfo.refbAttackMoveInsteadOfKiting, false, 40)
                    end
                    if oUnit[M28UnitInfo.refbAttackMoveInsteadOfKiting] then
                        --Attack move to retreat location
                        --IssueTrackedAttackMove(oUnit, tOrderPosition, iDistanceToReissueOrder, bAddToExistingQueue, sOptionalOrderDesc, bOverrideMicroOrder)
                        M28Orders.IssueTrackedAttackMove(oUnit, (tRetreatLocation or tRallyPoint), 5, false, 'NKRetAM'..iWaterZone, false)
                        if bDebugMessages == true then LOG(sFunctionRef..': Giving attack move as unit hasnt fired recently') end
                    else
                        ForkThread(M28Land.BackupUnitTowardsRallyIfAvailable, oUnit, (tRetreatLocation or tRallyPoint), iPond, 'NKRetr'..iWaterZone, false, nil, nil, true)
                    end
                end
            end
            --if iEnemyBestAntiNavyRange > tWZTeamData[M28Map.

            if bDebugMessages == true then
                LOG(sFunctionRef..': Deciding if we are in scenario 1, tWZTeamData[M28Map.subrefWZBestAlliedDFRange]='..tWZTeamData[M28Map.subrefWZBestAlliedDFRange]..'; iEnemyBestRange='..iEnemyBestRange..'; iEnemyNearbySubmersibleThreat='..iEnemyNearbySubmersibleThreat..'; iEnemyBestSumbersibleRange='..iEnemyBestSumbersibleRange..'; iAlliedBestAntiNavyRange='..iAlliedBestAntiNavyRange..'; iEnemyNearbySubmersibleThreat='..iEnemyNearbySubmersibleThreat..'; iOurAntiNavyThreat='..iOurAntiNavyThreat..'; Is table of combat units of use empty='..tostring(M28Utilities.IsTableEmpty(tCombatUnitsOfUse))..'; Our combat='..(tWZTeamData[M28Map.subrefWZThreatAlliedSurface] or 'nil'))
                LOG(sFunctionRef..': oNearestEnemyToFriendlyBase='..(oNearestEnemyToFriendlyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase) or 'nil')..'; Is this underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oNearestEnemyToFriendlyBase))..'; Range-15 condition combined='..tostring((tWZTeamData[M28Map.subrefWZBestAlliedDFRange] - 15 > iEnemyBestRange and oNearestEnemyToFriendlyBase and not(M28UnitInfo.IsUnitUnderwater(oNearestEnemyToFriendlyBase)) and tWZTeamData[M28Map.subrefWZThreatAlliedSurface] > iEnemyNearbySubmersibleThreat)))
                if bDebugMessages == true then LOG(sFunctionRef..': Is nearest surface enemy unit same as nearest enemy='..tostring(oNearestEnemyToFriendlyBase == oNearestEnemySurfaceToFriendlyBase)..'; Nearest enemy surface DF range='..(oNearestEnemySurfaceToFriendlyBase[M28UnitInfo.refiDFRange] or 0)..'; Antinavy='..oNearestEnemySurfaceToFriendlyBase[M28UnitInfo.refiAntiNavyRange]) end
            end
            local iFriendlyDFScenario1RangeThresholdOverride
            local bAreInScenario1 = false
            if M28Utilities.IsTableEmpty(tCombatUnitsOfUse) == false and tWZTeamData[M28Map.subrefWZBestAlliedDFRange] > iEnemyBestRange and (iEnemyNearbySubmersibleThreat < 500 or iEnemyBestSumbersibleRange < iAlliedBestAntiNavyRange or iOurAntiNavyThreat > iEnemyNearbySubmersibleThreat or tWZTeamData[M28Map.subrefWZThreatAlliedSurface] > 5 * iEnemyNearbySubmersibleThreat or ((tWZTeamData[M28Map.subrefWZBestAlliedDFRange] > 100 and tWZTeamData[M28Map.subrefWZThreatAlliedSurface] > math.max(18000, iEnemyNearbySubmersibleThreat * 2))) or (tWZTeamData[M28Map.subrefWZBestAlliedDFRange] - 15 > iEnemyBestRange and oNearestEnemyToFriendlyBase and not(M28UnitInfo.IsUnitUnderwater(oNearestEnemyToFriendlyBase)) and tWZTeamData[M28Map.subrefWZThreatAlliedSurface] > iEnemyNearbySubmersibleThreat))
                    and (M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftEnemyFirebasesInRange]) or tWZTeamData[M28Map.subrefWZBestAlliedDFRange] > 100 or tWZTeamData[M28Map.subrefWZThreatAlliedSurface] > 10000) then
                bAreInScenario1 = true
            end
            if oNearestEnemyToFriendlyBase == oNearestEnemySurfaceToFriendlyBase and (tWZTeamData[M28Map.subrefiNearbyEnemyLongRangeDFThreat] or 0) == 0 and tWZTeamData[M28Map.subrefWZBestAlliedDFRange] > math.max((oNearestEnemySurfaceToFriendlyBase[M28UnitInfo.refiDFRange] or 0), oNearestEnemySurfaceToFriendlyBase[M28UnitInfo.refiAntiNavyRange] or 0) + 6 then
                --Surface units that outrange nearest enemy unit, and enemy doesnt have otheru nits close to being in range of us if we attack it - so we can kite the nearest enemy
                --Get the zone the nearest enemy is in (so we can reference DF units in that zone)
                local tNearestEnemyWZTeamData
                if oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iWaterZone then
                    tNearestEnemyWZTeamData = tWZTeamData
                else
                    tNearestEnemyWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][oNearestEnemyToFriendlyBase[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam]][M28Map.subrefWZTeamData][iTeam]
                end
                --How close is an enemy unit to being in range of the nearest enemy (i.e. negative value means it can attack our units once they get this distance away)
                local iClosestDistLessRange = 10000
                if M28Utilities.IsTableEmpty(tNearestEnemyWZTeamData[M28Map.reftoNearestCombatEnemies]) == false then
                    local iEnemyRangeThreshold = math.max((oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0), (oNearestEnemyToFriendlyBase[M28UnitInfo.refiAntiNavyRange] or 0)) + 2
                    for iEnemy, oEnemy in tNearestEnemyWZTeamData[M28Map.reftoNearestCombatEnemies] do
                        --Only consider enemies that outrange the nearest enemy (since if they're the same or less range then we can kite them with the same units that can kite the nearest enemy)
                        if bDebugMessages == true then LOG(sFunctionRef..': considering how close nearby DF and antinavy units are to closest enemy, factoring in their range, oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; DF range='..(oEnemy[M28UnitInfo.refiDFRange] or 'nil')..'; AntiNavy='..(oEnemy[M28UnitInfo.refiAntiNavyRange] or 'nil')..'; iEnemyRangeThreshold='..iEnemyRangeThreshold..'; Dist between positions='..M28Utilities.GetDistanceBetweenPositions(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oNearestEnemyToFriendlyBase:GetPosition())..'; iClosestDistLessRange before update='..iClosestDistLessRange) end
                        if (oEnemy[M28UnitInfo.refiDFRange] or 0) > iEnemyRangeThreshold and (oEnemy[M28UnitInfo.refiAntiNavyRange] or 0) > iEnemyRangeThreshold then
                            iClosestDistLessRange = math.min(iClosestDistLessRange, M28Utilities.GetDistanceBetweenPositions(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oNearestEnemyToFriendlyBase:GetPosition()) - math.max((oEnemy[M28UnitInfo.refiDFRange] or 0), (oEnemy[M28UnitInfo.refiAntiNavyRange] or 0)))
                        end
                    end
                end
                local iFriendlyDFRangeThresholdBasedOnAbove
                if iClosestDistLessRange * -1 + 10 > (oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0) then
                    iFriendlyDFRangeThresholdBasedOnAbove = iClosestDistLessRange * -1 + 10
                    if bDebugMessages == true then LOG(sFunctionRef..': Updating range threshold for +8, iFriendlyDFRangeThresholdBasedOnAbove='..iFriendlyDFRangeThresholdBasedOnAbove..'; iClosestDistLessRange='..iClosestDistLessRange) end
                else
                    iFriendlyDFRangeThresholdBasedOnAbove = math.max((oNearestEnemyToFriendlyBase[M28UnitInfo.refiDFRange] or 0), (oNearestEnemyToFriendlyBase[M28UnitInfo.refiAntiNavyRange] or 0)) + 6
                    if bDebugMessages == true then LOG(sFunctionRef..': Updating range threshold for +3, iFriendlyDFRangeThresholdBasedOnAbove='..iFriendlyDFRangeThresholdBasedOnAbove..'; iClosestDistLessRange='..iClosestDistLessRange) end
                end

                if bAreInScenario1 and iFriendlyDFRangeThresholdBasedOnAbove + 6 < tWZTeamData[M28Map.subrefWZBestAlliedDFRange] and iFriendlyDFRangeThresholdBasedOnAbove + 6 < iEnemyBestRange then
                    iFriendlyDFScenario1RangeThresholdOverride = iFriendlyDFRangeThresholdBasedOnAbove
                    if bDebugMessages == true then LOG(sFunctionRef..': Are in scenario 1 so making lower of enemy range and the other values, iFriendlyDFScenario1RangeThresholdOverride='..iFriendlyDFScenario1RangeThresholdOverride) end
                elseif not(bAreInScenario1) then
                    iFriendlyDFScenario1RangeThresholdOverride = iFriendlyDFRangeThresholdBasedOnAbove
                    bAreInScenario1 = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Will act as if in scenario 1 so we can attack nearest enemy that we outrange, iFriendlyDFScenario1RangeThresholdOverride='..iFriendlyDFScenario1RangeThresholdOverride) end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Not that much difference in ranges to normal scenario 1 best enemy range so wont give an override') end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if we think closest enemy unit is vulnerable to a kiting attack, bAreInScenario1='..tostring(bAreInScenario1 or false)..'; iFriendlyDFScenario1RangeThresholdOverride='..(iFriendlyDFScenario1RangeThresholdOverride or 'nil')..'; nearest enemy unit state='..M28UnitInfo.GetUnitState(oNearestEnemyToFriendlyBase)) end
            end
            if bAreInScenario1 then
                --Scenario 1 - our ships outrange enemy
                local tOutrangedCombatUnits = {}
                local tUnitsToSupport = {}
                local bAttackWithOutrangedUnits = false
                if tWZTeamData[M28Map.subrefWZbCoreBase] then bAttackWithOutrangedUnits = true
                elseif not(iFriendlyDFScenario1RangeThresholdOverride) and tWZTeamData[M28Map.subrefWZThreatAlliedSurface] > tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] then
                    local iAdjEnemyCombatThreat = tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]
                    for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                        local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                        iAdjEnemyCombatThreat = iAdjEnemyCombatThreat + (tAdjWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Cnsidering whether to attack with outranged surface units in scenario 1, iAdjEnemyCombatThreat='..iAdjEnemyCombatThreat..'; tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]) end
                    --Only consider attack with outranged units if we have a clear advantage in naval force
                    if iAdjEnemyCombatThreat * 1.5 < tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] then
                        bAttackWithOutrangedUnits = true
                    end
                end
                local bNearestEnemyToMidpointIsUnderwater = M28UnitInfo.IsUnitUnderwater(oNearestEnemyToFriendlyBase)
                local iRangeToUseForChecks
                local iEnemyAntiNavyOverride
                if bNearestEnemyToMidpointIsUnderwater and (oNearestEnemyToFriendlyBase[M28UnitInfo.refiAntiNavyRange] or 0) < iEnemyBestUnderwaterRange then
                    iEnemyAntiNavyOverride = (oNearestEnemyToFriendlyBase[M28UnitInfo.refiAntiNavyRange] or 0)
                end

                if M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) >= 10 then bCheckIfNearestUnitVisible = true end
                for iUnit, oUnit in tCombatUnitsOfUse do
                    if not(oUnit.Dead) then --rare redundancy
                        local tEnemiesToConsider
                        if (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > 0 then
                            oEnemyToFocusOn = oNearestEnemyToFriendlyBase
                            tEnemiesToConsider =  tWZTeamData[M28Map.reftoNearestCombatEnemies]
                            if bNearestEnemyToMidpointIsUnderwater and (oEnemyToFocusOn[M28UnitInfo.refiAntiNavyRange] or 0) > 0 then iRangeToUseForChecks = oUnit[M28UnitInfo.refiAntiNavyRange]
                            else iRangeToUseForChecks = math.max(oUnit[M28UnitInfo.refiAntiNavyRange], (oUnit[M28UnitInfo.refiDFRange] or 0))
                            end
                        else
                            oEnemyToFocusOn = oNearestEnemySurfaceToFriendlyBase
                            tEnemiesToConsider = tEnemySurfaceUnits
                            iRangeToUseForChecks = (oUnit[M28UnitInfo.refiDFRange] or 0)
                        end
                        if EntityCategoryContains(categories.HOVER, oUnit.UnitId) then
                            iOrderReissueDistToUse = iResisueOrderDistanceHover
                        else iOrderReissueDistToUse = iReissueOrderDistanceStandard
                        end

                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if our unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' outrangs enemy, iRangeToUseForChecks='..iRangeToUseForChecks..'; iEnemyBestAntiNavyRange='..iEnemyBestAntiNavyRange..'; iEnemyBestUnderwaterRange='..iEnemyBestUnderwaterRange) end

                        if iRangeToUseForChecks > (iEnemyAntiNavyOverride or iEnemyBestUnderwaterRange) and (not(iFriendlyDFScenario1RangeThresholdOverride) or iRangeToUseForChecks >= iEnemyBestRange) then
                            table.insert(tUnitsToSupport, oUnit)
                            --Consider kiting logic unless want to use shot blocked override logic
                            if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                                if bDebugMessages == true then LOG(sFunctionRef..': oEnemyToFocusOn='..oEnemyToFocusOn.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToFocusOn)..'; Blocked count='..(oEnemyToFocusOn[M28UnitInfo.refiTargetShotBlockedCount] or 0)) end
                                M28Orders.IssueTrackedMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iOrderReissueDistToUse, false, 'NSCBlckM'..iWaterZone)
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                            else
                                if oUnit[M28UnitInfo.refbEasyBrain] and oEnemyToFocusOn then
                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                        if M28Conditions.GroundAttackTargetUnitInsteadOfAttackMove(oUnit, oEnemyToFocusOn) then
                                            M28Orders.IssueTrackedGroundAttack(oUnit, oEnemyToFocusOn:GetPosition(), 1, false, 'NKAesagMve'..iWaterZone, false, oEnemyToFocusOn)
                                        else
                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(iOrderReissueDistToUse, (oUnit[M28UnitInfo.refiDFRange] or 0) * 0.5), false, 'NKAesMve'..iWaterZone)
                                        end
                                    end
                                    --Are we in range of any enemy?
                                    --CloseToEnemyUnit(tStartPosition, tUnitsToCheck,               iDistThreshold,             iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                                elseif M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]) or (bMoveAntiNavyForwardsAsCantSee and (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > 0) or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tEnemiesToConsider, iRangeToUseForChecks * 0.90, iTeam,    false,                  nil,                    nil,                                oUnit)) then
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef..': Not in range of enemy yet (or not far enough in range), and we outrange enemy; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Antinavy range='..(oUnit[M28UnitInfo.refiAntiNavyRange] or 'nil')..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; oEnemyToFocusOn='..(oEnemyToFocusOn.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEnemyToFocusOn) or 'nil')..'; oEnemyToFocusOn antinavy range='..(oEnemyToFocusOn[M28UnitInfo.refiAntiNavyRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oEnemyToFocusOn:GetPosition())..'; Enemy last recorded position='..repru(oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; WZ midpoint position='..repru(tWZData[M28Map.subrefMidpoint])..'; bMoveAntiNavyForwardsAsCantSee='..tostring(bMoveAntiNavyForwardsAsCantSee or false)..'; M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies])='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies])))
                                        if oEnemyToFocusOn then LOG(sFunctionRef..': Dist to oEnemyToFocusOn='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn:GetPosition())..'; Dist to last known position='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])) end
                                    end
                                    --Not in range yet, so attack move to the nearest enemy

                                    --If we have a long range unit, then check if we already have any high value targets in our range (as sometimes attack-move e.g. on a summit doesnt cause it to stop and fire when enemy is in range)

                                    if oUnit[M28UnitInfo.refiCombatRange] >= 100 then
                                        if M28UnitInfo.CanSeeUnit(oUnit:GetAIBrain(), oEnemyToFocusOn) and M28Utilities.GetDistanceBetweenPositions(oEnemyToFocusOn:GetPosition(), oUnit:GetPosition()) <= oUnit[M28UnitInfo.refiCombatRange] - 6 then --dont want to chase after enemy necessarily
                                            M28Orders.IssueTrackedAttack(oUnit, oEnemyToFocusOn, false, 'LRNAtE', false)
                                        else
                                            local tNearbyUnitsOfInterest = oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategorySkirmisher * categories.TECH3 + M28UnitInfo.refCategoryStructure - categories.TECH1 + M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryBattleship, oUnit:GetPosition(), oUnit[M28UnitInfo.refiCombatRange], 'Enemy')
                                            if bDebugMessages == true then LOG(sFunctionRef..': Have a long range enemy unit, is table of nearby units of interest empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnitsOfInterest))) end
                                            if M28Utilities.IsTableEmpty(tNearbyUnitsOfInterest) == false then
                                                --if are fixed shields then target the closest one; otherwise if are T2 arti target them; otehrwise target highets value unit
                                                local oEnemyToTarget
                                                local tNearbyShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, tNearbyUnitsOfInterest)
                                                if M28Utilities.IsTableEmpty(tNearbyShields) == false then
                                                    oEnemyToTarget = M28Utilities.GetNearestUnit(tNearbyShields, oUnit:GetPosition())
                                                else
                                                    local tNearbyT2ArtiAndExperimentalStructure = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryExperimentalLevel * categories.STRUCTURE, tNearbyUnitsOfInterest)
                                                    if M28Utilities.IsTableEmpty(tNearbyT2ArtiAndExperimentalStructure) == false then oEnemyToTarget = M28Utilities.GetNearestUnit(tNearbyT2ArtiAndExperimentalStructure, oUnit:GetPosition())
                                                    else
                                                        --Target the highest value enemy (or shield if there is one)
                                                        local iHighestValueTarget = 0
                                                        local iCurValueTarget
                                                        for iEnemyTarget, oEnemyTarget in tNearbyUnitsOfInterest do
                                                            if not(M28UnitInfo.IsUnitUnderwater(oEnemyTarget)) then
                                                                iCurValueTarget = oEnemyTarget[M28UnitInfo.refiUnitMassCost]
                                                                if iCurValueTarget > iHighestValueTarget then
                                                                    iHighestValueTarget = iCurValueTarget
                                                                    oEnemyToTarget = oEnemyTarget
                                                                end
                                                            end
                                                            if oEnemyToTarget then
                                                                M28Orders.IssueTrackedAttack(oUnit, oEnemyToTarget, false, 'LRHVEn', false)
                                                            else
                                                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(iOrderReissueDistToUse, (oUnit[M28UnitInfo.refiDFRange] or 0) * 0.5), false, 'BSKAltM'..iWaterZone)
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            else
                                                if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(iOrderReissueDistToUse, (oUnit[M28UnitInfo.refiDFRange] or 0) * 0.5), false, 'BSKAMve'..iWaterZone)
                                                end
                                            end
                                        end
                                    else
                                        if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(iOrderReissueDistToUse, (oUnit[M28UnitInfo.refiDFRange] or 0) * 0.5), false, 'NKAMve'..iWaterZone)
                                        end
                                    end

                                else
                                    KitingRetreatOfUnit(oUnit)

                                    --If enemy is able to shoot us then get DF support
                                    --CloseToEnemyUnit(tStartPosition, tUnitsToCheck,       iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                                    if not(bAttackWithOutrangedUnits) and
                                            M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tEnemiesToConsider, 4,                  iTeam,  true                ,nil,                   nil,                                nil,                                        nil,                                true) then
                                        bAttackWithOutrangedUnits = true
                                    end
                                    --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                    if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), (oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or oEnemyToFocusOn:GetPosition())) <= 18 then bUpdateNearestUnit = true end
                                end
                            end
                        else
                            if oUnit[M28UnitInfo.refiAntiNavyRange] > 0 or oUnit[M28UnitInfo.refiDFRange] > 0 then
                                --We dont outrange the enemy, but we do have other units that do
                                table.insert(tOutrangedCombatUnits, oUnit)
                                if bDebugMessages == true then LOG(sFunctionRef..': Adding to table of outranged units') end
                            end
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tOutrangedCombatUnits) == false then
                    if bAttackWithOutrangedUnits then
                        if not(M28UnitInfo.IsUnitValid(oEnemyToFocusOn)) then
                            --For rare redundancy where nearest enemy is dead
                            if M28UnitInfo.IsUnitValid(oNearestEnemyToFriendlyBase) then oEnemyToFocusOn = oNearestEnemyToFriendlyBase
                            else
                                local iClosestDist = 10000
                                local iCurDist
                                for iUnit, oUnit in tWZTeamData[M28Map.subrefTEnemyUnits] do
                                    if M28UnitInfo.IsUnitValid(oUnit) then
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tWZTeamData[M28Map.reftClosestFriendlyBase])
                                        if iCurDist < iClosestDist then
                                            oEnemyToFocusOn = oUnit
                                            iClosestDist = iCurDist
                                        end
                                    end
                                end
                            end
                            if not(M28UnitInfo.IsUnitValid(oEnemyToFocusOn)) and M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                                for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                                    local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                                    if M28Utilities.IsTableEmpty(tAdjWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                                        for iUnit, oUnit in tAdjWZTeamData[M28Map.subrefTEnemyUnits] do
                                            if M28UnitInfo.IsUnitValid(oUnit) then oEnemyToFocusOn = oUnit break end
                                        end
                                    end
                                end
                            end
                        end --end of redundancy

                        local iOurRelevantRange
                        local iEnemyRelevantRange
                        local bEnemyToFocusOnIsUnderwater = M28UnitInfo.IsUnitUnderwater(oEnemyToFocusOn)
                        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                        local bCanSeeEnemy = M28UnitInfo.CanSeeUnit(aiBrain, oEnemyToFocusOn)
                        local bRetreatFromEnemy
                        local tTempRetreatLocation
                        local bCampaignMap = M28Map.bIsCampaignMap

                        if bEnemyToFocusOnIsUnderwater then
                            iEnemyRelevantRange = (oEnemyToFocusOn[M28UnitInfo.refiAntiNavyRange] or 0)
                        else
                            iEnemyRelevantRange = oEnemyToFocusOn[M28UnitInfo.refiCombatRange]
                        end
                        local iDistUntilEnemyOutOfRange = 0
                        for iUnit, oUnit in tOutrangedCombatUnits do
                            if EntityCategoryContains(categories.HOVER, oUnit.UnitId) then iOrderReissueDistToUse = iResisueOrderDistanceHover
                            else iOrderReissueDistToUse = iReissueOrderDistanceStandard
                            end

                            if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                                M28Orders.IssueTrackedMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iOrderReissueDistToUse, false, 'WOBlckM'..iWaterZone)
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                            else
                                bRetreatFromEnemy = false
                                if not(oUnit[M28UnitInfo.refbEasyBrain]) then
                                    if bCanSeeEnemy then
                                        --Are we already in range of the enemy to focus on and do we outrange it? if so then retreat slightly even if overall the enemy outranges us
                                        if bEnemyToFocusOnIsUnderwater then
                                            iOurRelevantRange = (oUnit[M28UnitInfo.refiAntiNavyRange] or 0)
                                        else
                                            iOurRelevantRange = oUnit[M28UnitInfo.refiCombatRange]
                                        end
                                        if bCanSeeEnemy and iOurRelevantRange >= iEnemyRelevantRange then
                                            iDistUntilEnemyOutOfRange = iOurRelevantRange - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn:GetPosition())
                                            if iDistUntilEnemyOutOfRange >= 3 then
                                                tTempRetreatLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oEnemyToFocusOn:GetPosition(), oUnit:GetPosition()), math.min(6, iDistUntilEnemyOutOfRange - 1.5), true, false, bCampaignMap)
                                                if NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tTempRetreatLocation) == iPond then
                                                    bRetreatFromEnemy = true
                                                end
                                            end
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': bCanSeeEnemy='..tostring(bCanSeeEnemy)..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iOurRelevantRange='..(iOurRelevantRange or 'nil')..'; iEnemyRelevantRange='..(iEnemyRelevantRange or 'nil')..'; Dist until out of range='..(iDistUntilEnemyOutOfRange or 'nil')..'; bRetreatFromEnemy='..tostring(bRetreatFromEnemy)) end
                                if bRetreatFromEnemy then
                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                    ForkThread(M28Land.BackupUnitTowardsRallyIfAvailable, oUnit, tTempRetreatLocation, iPond, 'WSRKitR'..iWaterZone, false, nil, nil, true)
                                    --M28Orders.IssueTrackedMove(oUnit, tTempRetreatLocation, 1.5, false, 'WSRKitR'..iWaterZone, false)
                                else
                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                        M28Orders.IssueTrackedAggressiveMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(iOrderReissueDistToUse, (oUnit[M28UnitInfo.refiAntiNavyRange] or 0), (oUnit[M28UnitInfo.refiDFRange] or 0))* 0.5, false, 'WSRDFA'..iWaterZone)
                                    end
                                end
                            end
                        end
                    else
                        if M28Utilities.IsTableEmpty(tUnitsToSupport) == false then
                            --Short range units can stay back and provide support - stay inbetween our long range units and the rally point
                            local iCurDist
                            local iClosestDist
                            local oClosestUnit
                            for iSRUnit, oSRUnit in tOutrangedCombatUnits do
                                if EntityCategoryContains(categories.HOVER, oSRUnit.UnitId) then iOrderReissueDistToUse = iResisueOrderDistanceHover
                                else iOrderReissueDistToUse = iReissueOrderDistanceStandard
                                end
                                iClosestDist = 100000
                                for iLRUnit, oLRUnit in tUnitsToSupport do
                                    iCurDist = M28Utilities.GetRoughDistanceBetweenPositions(oSRUnit:GetPosition(), oLRUnit:GetPosition())
                                    if iCurDist < iClosestDist then
                                        iClosestDist = iCurDist
                                        oClosestUnit = oLRUnit
                                    end
                                end
                                M28Orders.IssueTrackedMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), tRallyPoint), 5, true, false, true), iOrderReissueDistToUse, false, 'WSRSup'..iWaterZone)
                            end
                        else
                            --Presumably we outrange if we include surface and antinavy but enemy only has submersed?
                            bAreInScenario1 = false

                            if bDebugMessages == true then
                                --List out every unit
                                LOG(sFunctionRef..': Will list out every unit in combat units of use, tWZTeamData[M28Map.subrefWZBestAlliedDFRange]='..(tWZTeamData[M28Map.subrefWZBestAlliedDFRange] or 'nil')..'; iEnemyBestAntiNavyRange='..(iEnemyBestAntiNavyRange or 'nil')..'; tWZTeamData[M28Map.subrefWZBestEnemyDFRange]='..(tWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 'nil')..'; iEnemyBestRange='..iEnemyBestRange)
                                for iUnit, oUnit in tCombatUnitsOfUse do
                                    LOG(sFunctionRef..': iUnit='..iUnit..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; AntiNavy range='..(oUnit[M28UnitInfo.refiAntiNavyRange] or 0)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0))
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bAreInScenario1 (and have already applied logic)='..tostring(bAreInScenario1)..'; Is tCombatUnitsOfUse empty='..tostring(M28Utilities.IsTableEmpty(tCombatUnitsOfUse))) end
            if not(bAreInScenario1) then
                if M28Utilities.IsTableEmpty(tCombatUnitsOfUse) == false then
                    --Add in adjacnet land zone DF threats to decision on whether to engage - determine based on tWZTeamData[M28Map.reftoNearestCombatEnemies]
                    --WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iNearbyFriendlySubThreat, iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, bConsideringSubmarinesNotSurface, iOptionalThreatAbsolutePercentIncrease)
                    local bAreInScenario2
                    if tWZTeamData[M28Map.subrefWZbSuicideIntoEnemy] then
                        bAreInScenario2 = true
                    else
                        bAreInScenario2 = M28Conditions.WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iNearbyFriendlySubThreat, iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, false                               ,iModForEnemyScenario2Threat, iEnemyNearbySubmersibleThreat, iOurAntiNavyThreat)
                        if bAreInScenario2 and iEnemyBestCombatRange >= 45 and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]) == false then
                            --Extra check in case we have included enemies from an adjacent land zone in the nearest enemies
                            local toEnemiesFromAdjacentLandZone = {}
                            for iUnit, oUnit in tWZTeamData[M28Map.reftoNearestCombatEnemies] do
                                if oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1] and not(oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam]) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Adding nearby DF unit assigned to a land zone to toEnemiesFromAdjacentLandZone, nearby enemy unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                    table.insert(toEnemiesFromAdjacentLandZone, oUnit)
                                end
                            end
                            if M28Utilities.IsTableEmpty(toEnemiesFromAdjacentLandZone) == false then
                                local iAdjacentLandThreat = M28UnitInfo.GetCombatThreatRating(toEnemiesFromAdjacentLandZone, true, false)
                                if bDebugMessages == true then LOG(sFunctionRef..': iAdjacentLandThreat='..iAdjacentLandThreat..'; will increase adjacent enemy threat for this if it is significant') end
                                if iAdjacentLandThreat > 100 and iAdjacentLandThreat > iAdjacentEnemyCombatThreat * 0.1 then
                                    iAdjacentEnemyCombatThreat = iAdjacentEnemyCombatThreat + iAdjacentLandThreat
                                    bAreInScenario2 = M28Conditions.WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iNearbyFriendlySubThreat, iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAdjacentAlliedCombatThreat, iAdjacentEnemyCombatThreat, false                               ,iModForEnemyScenario2Threat, iEnemyNearbySubmersibleThreat, iOurAntiNavyThreat)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished rechecking if are in scenario2, bAreInScenario2='..tostring(bAreInScenario2)) end
                                end
                            end
                        end
                        if bAreInScenario2 and tWZTeamData[M28Map.subrefWZbCoreBase] then
                            tWZTeamData[M28Map.subrefWZbSuicideIntoEnemy] = true
                            M28Utilities.ForkedDelayedChangedVariable(tWZTeamData, M28Map.subrefWZbSuicideIntoEnemy, false, 30)
                            if bDebugMessages == true then LOG(sFunctionRef..': Surface setting suicide flag to true, is table of adj WZs empty='..tostring( M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]))) end
                            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                                for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                                    local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                                    if bDebugMessages == true then LOG(sFunctionRef..': Nonsub suicide flag, considering iAdjWZ='..iAdjWZ..'; tAdjWZTeamData[M28Map.subrefWZbSuicideIntoEnemy]='..tostring(tAdjWZTeamData[M28Map.subrefWZbSuicideIntoEnemy] or false)) end
                                    if not(tAdjWZTeamData[M28Map.subrefWZbSuicideIntoEnemy]) then
                                        tAdjWZTeamData[M28Map.subrefWZbSuicideIntoEnemy] = true
                                        M28Utilities.ForkedDelayedChangedVariable(tAdjWZTeamData, M28Map.subrefWZbSuicideIntoEnemy, false, 30)
                                        if tAdjWZTeamData[M28Map.subrefWZbCoreBase] and M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZAdjacentWaterZones]) == false then
                                            for _, iSecondAdjWZ in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZAdjacentWaterZones] do
                                                local tSecondAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iSecondAdjWZ][M28Map.subrefWZTeamData][iTeam]
                                                if not(tSecondAdjWZTeamData[M28Map.subrefWZbSuicideIntoEnemy]) then
                                                    if tSecondAdjWZTeamData then
                                                        tSecondAdjWZTeamData[M28Map.subrefWZbSuicideIntoEnemy] = true
                                                        M28Utilities.ForkedDelayedChangedVariable(tSecondAdjWZTeamData, M28Map.subrefWZbSuicideIntoEnemy, false, 30)
                                                    else
                                                        M28Utilities.ErrorHandler('Dont have a valid second WZ ref')
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end

                    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if are in scenario2, bAreInScenario2='..tostring(bAreInScenario2)..'; tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]='..tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]..'; tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Core WZ base='..tostring(tWZTeamData[M28Map.subrefWZbCoreBase])..'; iAdjacentAlliedCombatThreat='..iAdjacentAlliedCombatThreat..'; iAdjacentEnemyCombatThreat='..iAdjacentEnemyCombatThreat) end
                    if bAreInScenario2 then
                        --SCENARIO 2 - We either have enemies near our core naval factory or we have a greater threat than the enemy - attack
                        if bDebugMessages == true then
                            if M28UnitInfo.IsUnitValid(oNearestEnemyToFriendlyBase) then
                                LOG(sFunctionRef..': oNearestEnemyToFriendlyBase='..oNearestEnemyToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToFriendlyBase)..'; position='..repru(oNearestEnemyToFriendlyBase:GetPosition())..'; Last known position='..repru(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Playable area='..repru(M28Map.rMapPlayableArea))
                                if M28UnitInfo.IsUnitValid(oNearestEnemySurfaceToFriendlyBase) then
                                    LOG(sFunctionRef..' oNearestEnemySurfaceToFriendlyBase='..oNearestEnemySurfaceToFriendlyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemySurfaceToFriendlyBase)..'; Position='..repru(oNearestEnemySurfaceToFriendlyBase:GetPosition())..'; Last known position='..repru(oNearestEnemySurfaceToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]))
                                end
                            else
                                LOG(sFunctionRef..': Dont have a valid oNearestEnemyToFriendlyBase')
                            end
                        end
                        local bOutrangeClosestEnemy
                        local iDistUntilEnemyOutOfOurRange
                        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                        local bNearestEnemyToMidpointIsVisible
                        if M28UnitInfo.IsUnitValid(oNearestEnemyToFriendlyBase) then bNearestEnemyToMidpointIsVisible = M28UnitInfo.CanSeeUnit(aiBrain, oNearestEnemyToFriendlyBase) end
                        local bNearestEnemySurfaceIsVisible
                        if M28UnitInfo.IsUnitValid(oNearestEnemySurfaceToFriendlyBase) then bNearestEnemySurfaceIsVisible = M28UnitInfo.CanSeeUnit(aiBrain, oNearestEnemySurfaceToFriendlyBase) end
                        local bNearestEnemyIsUnderwater = M28UnitInfo.IsUnitUnderwater(oNearestEnemyToFriendlyBase)
                        local bNearestEnemyIsHover = EntityCategoryContains(categories.HOVER, oNearestEnemyToFriendlyBase.UnitId)
                        local iAmountWeOutrangeNearestEnemy
                        local bCheckPlayableArea = M28Map.bIsCampaignMap

                        for iUnit, oUnit in tCombatUnitsOfUse do
                            if not(oUnit.Dead) then --strange error where this rarely triggers for a dead unit, so adding extra redundancy here
                                bOutrangeClosestEnemy = false
                                iDistUntilEnemyOutOfOurRange = 0
                                iAmountWeOutrangeNearestEnemy = 0
                                if (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > 0 then
                                    oEnemyToFocusOn = oNearestEnemyToFriendlyBase

                                    if bNearestEnemyToMidpointIsVisible then
                                        if bNearestEnemyIsUnderwater then
                                            iAmountWeOutrangeNearestEnemy = oUnit[M28UnitInfo.refiAntiNavyRange] - (oEnemyToFocusOn[M28UnitInfo.refiAntiNavyRange] or 0)
                                            if iAmountWeOutrangeNearestEnemy >= 2 then
                                                bOutrangeClosestEnemy = true
                                                iDistUntilEnemyOutOfOurRange = oUnit[M28UnitInfo.refiAntiNavyRange] - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn:GetPosition())
                                            end
                                        elseif bNearestEnemyIsHover then
                                            iAmountWeOutrangeNearestEnemy = (oUnit[M28UnitInfo.refiDFRange] or 0) - math.max((oEnemyToFocusOn[M28UnitInfo.refiDFRange] or 0), (oEnemyToFocusOn[M28UnitInfo.refiAntiNavyRange] or 0))
                                            if iAmountWeOutrangeNearestEnemy >= 2 then
                                                bOutrangeClosestEnemy = true
                                                iDistUntilEnemyOutOfOurRange = oUnit[M28UnitInfo.refiDFRange] - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn:GetPosition())
                                            end
                                        else
                                            iAmountWeOutrangeNearestEnemy = oUnit[M28UnitInfo.refiCombatRange] - math.max((oEnemyToFocusOn[M28UnitInfo.refiDFRange] or 0), (oEnemyToFocusOn[M28UnitInfo.refiAntiNavyRange] or 0))
                                            if iAmountWeOutrangeNearestEnemy >= 2 then
                                                bOutrangeClosestEnemy = true
                                                iDistUntilEnemyOutOfOurRange = oUnit[M28UnitInfo.refiCombatRange] - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn:GetPosition())
                                            end
                                        end
                                    end
                                else
                                    oEnemyToFocusOn = oNearestEnemySurfaceToFriendlyBase
                                    if bNearestEnemySurfaceIsVisible then
                                        if bNearestEnemyIsHover then
                                            iAmountWeOutrangeNearestEnemy = (oUnit[M28UnitInfo.refiDFRange] or 0) - math.max((oEnemyToFocusOn[M28UnitInfo.refiDFRange] or 0), (oEnemyToFocusOn[M28UnitInfo.refiAntiNavyRange] or 0))
                                            if iAmountWeOutrangeNearestEnemy >= 2 then
                                                bOutrangeClosestEnemy = true
                                                iDistUntilEnemyOutOfOurRange = oUnit[M28UnitInfo.refiDFRange] - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn:GetPosition())
                                            end
                                        else
                                            iAmountWeOutrangeNearestEnemy = oUnit[M28UnitInfo.refiCombatRange] - math.max((oEnemyToFocusOn[M28UnitInfo.refiDFRange] or 0), (oEnemyToFocusOn[M28UnitInfo.refiAntiNavyRange] or 0))
                                            if iAmountWeOutrangeNearestEnemy >= 2 then
                                                bOutrangeClosestEnemy = true
                                                iDistUntilEnemyOutOfOurRange = oUnit[M28UnitInfo.refiCombatRange] - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn:GetPosition())
                                            end
                                        end
                                    end
                                end

                                if EntityCategoryContains(categories.HOVER, oUnit.UnitId) then iOrderReissueDistToUse = iResisueOrderDistanceHover
                                else iOrderReissueDistToUse = iReissueOrderDistanceStandard
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': bOutrangeClosestEnemy (factoring in if we can see the unit)='..tostring(bOutrangeClosestEnemy)..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iDistUntilEnemyOutOfOurRange'..iDistUntilEnemyOutOfOurRange..'; bMoveBlockedNotAttackMove='..tostring(bMoveBlockedNotAttackMove)..'; oUnit[M28UnitInfo.refbLastShotBlocked]='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked] or false)..'; Time since last blocked shot='..(GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100))..'; Time of last check='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100)..'; oEnemyToFocusOn='..(oEnemyToFocusOn.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEnemyToFocusOn) or 'nil')..'; bNearestEnemyIsUnderwater='..tostring(bNearestEnemyIsUnderwater or false)..'; bNearestEnemyIsHover='..tostring(bNearestEnemyIsHover or false)..'; Dist to nearest enemy='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyToFocusOn:GetPosition())..'; Our unit DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Our unit antinavy range='..(oUnit[M28UnitInfo.refiAntiNavyRange] or 'nil')) end
                                if not(M28UnitInfo.IsUnitValid(oEnemyToFocusOn)) then
                                    oEnemyToFocusOn = oNearestEnemyToFriendlyBase
                                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy to focus on isnt valid so switching to nearest enemy to base') end
                                end
                                if not(oEnemyToFocusOn) or oEnemyToFocusOn.Dead then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have a valid enemy to focus on even after updating to nearest enemy to frinedly base, so will attackmove to enemy base') end
                                    M28Orders.IssueTrackedAggressiveMove(oUnit, (oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or tWZTeamData[M28Map.reftClosestEnemyBase]), iOrderReissueDistToUse, false, 'WARedA'..iWaterZone)
                                elseif bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                                    M28Orders.IssueTrackedMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iOrderReissueDistToUse, false, 'WBAWE'..iWaterZone)
                                    --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                    if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                                elseif iDistUntilEnemyOutOfOurRange >= 3 and not(oUnit[M28UnitInfo.refbEasyBrain]) then
                                    --if we outrange the enemy we are focused on and are already in range then move back slightly even though we dont outrange the enemy as a whole
                                    local tLocalisedKitingPosition = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oEnemyToFocusOn:GetPosition(), oUnit:GetPosition()), math.min(5, iDistUntilEnemyOutOfOurRange - 0.25), true, false, bCheckPlayableArea)
                                    if NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tLocalisedKitingPosition) == iPond then
                                        oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                        ForkThread(M28Land.BackupUnitTowardsRallyIfAvailable, oUnit, tLocalisedKitingPosition, iPond, 'WATKR'..iWaterZone, false, nil, nil, true)
                                        --M28Orders.IssueTrackedMove(oUnit, tLocalisedKitingPosition, 1, false, 'WATKR'..iWaterZone)
                                    else
                                        if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                            if M28Conditions.GroundAttackTargetUnitInsteadOfAttackMove(oUnit, oEnemyToFocusOn) then
                                                M28Orders.IssueTrackedGroundAttack(oUnit, oEnemyToFocusOn:GetPosition(), 1, false, 'WATagWE'..iWaterZone, false, oEnemyToFocusOn)
                                            else
                                                M28Orders.IssueTrackedAggressiveMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iOrderReissueDistToUse, false, 'WATWE'..iWaterZone)
                                            end
                                        end
                                    end
                                else
                                    if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                        if M28Conditions.GroundAttackTargetUnitInsteadOfAttackMove(oUnit, oEnemyToFocusOn) then
                                            M28Orders.IssueTrackedGroundAttack(oUnit, oEnemyToFocusOn:GetPosition(), 1, false, 'WAWagE'..iWaterZone, false, oEnemyToFocusOn)
                                        else
                                            --Had strange issue where oUnit was invalid; despite adding extra check in the managespecificwaterzone to check unit is valid in same zone, and checking we had this check for adjWZ, still occurred; so will just accept as rare error
                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iOrderReissueDistToUse, false, 'WAWE'..iWaterZone)
                                        end
                                    end
                                end
                            end
                        end
                    else
                        --Are we in the (rare) case where we have units with same DF range as enemy DF units, and enemy DF is due to torp launchers, while we have aoe attack, such that we could ground fire the torp launchers to outrange them?
                        --GetCombatThreatRating(tUnits,         bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, bBlueprintThreat)
                        local iAvailableCombatThreat = M28UnitInfo.GetCombatThreatRating(tCombatUnitsOfUse, false,          false,          false,                  false,          true,           false,          false)

                        local bAntiTorpLauncherMode = false
                        --Consider attacking if we outrange enemy DF units but not antinavy units, but we have better threat than their subersible threat (e.g. enemy threat is torp launchers, or units with weak antinavy attack)
                        if oNearestEnemySurfaceToFriendlyBase and iAvailableCombatThreat >= 1000 and tWZTeamData[M28Map.subrefWZBestAlliedDFRange] == iEnemyBestRange and tWZTeamData[M28Map.subrefWZBestAlliedDFRange] > tWZTeamData[M28Map.subrefWZBestEnemyDFRange] and (iEnemyBestSumbersibleRange < iAlliedBestAntiNavyRange or iOurAntiNavyThreat > iEnemyNearbySubmersibleThreat) and tWZTeamData[M28Map.subrefWZBestAlliedDFRange] >= 50 then
                            if bDebugMessages == true then LOG(sFunctionRef..': we might still consider attacking due to enemy range being torp launchers') end
                            local tLRUnits = {}
                            local tSRUnits = {}
                            local bUseAOEAttacks = false
                            local iNearestEnemyRangeThreshold = (oNearestEnemySurfaceToFriendlyBase[M28UnitInfo.refiCombatRange] or 0)
                            if tWZTeamData[M28Map.subrefWZBestAlliedDFRange] > iNearestEnemyRangeThreshold then
                                local bEnemyIsHover = EntityCategoryContains(categories.HOVER, oNearestEnemySurfaceToFriendlyBase.UnitId)
                                if bDebugMessages == true then LOG(sFunctionRef..': We outrange the enemy surface unit nearest midpoint so will assume it is the closest unit to us and attack') end
                                for iUnit, oUnit in tCombatUnitsOfUse do
                                    if oUnit[M28UnitInfo.refiCombatRange] > iNearestEnemyRangeThreshold and (not(bEnemyIsHover) or (oUnit[M28UnitInfo.refiDFRange] or 0) > iNearestEnemyRangeThreshold or (oUnit[M28UnitInfo.refiIndirectRange] or 0) > iNearestEnemyRangeThreshold) and not(oUnit:GetAIBrain().M28Easy) then
                                        table.insert(tLRUnits, oUnit)
                                    else
                                        table.insert(tSRUnits, oUnit)
                                    end
                                end
                            elseif not(M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oNearestEnemySurfaceToFriendlyBase.UnitId) then
                                bUseAOEAttacks = true
                                if bDebugMessages == true then LOG(sFunctionRef..': The nearest enemy unit has equal range to our best range unit but is a structure, so we will attack it and try to ground fire if possible') end
                                for iUnit, oUnit in tCombatUnitsOfUse do
                                    if oUnit[M28UnitInfo.refiCombatRange] >= iNearestEnemyRangeThreshold and (oUnit[M28UnitInfo.refiDFAOE] or 0) > 0.1 then
                                        table.insert(tLRUnits, oUnit)
                                    else
                                        table.insert(tSRUnits, oUnit)
                                    end
                                end
                            end
                            local iClosestLRUnitDist = 10000
                            local oClosestLRUnit
                            if M28Utilities.IsTableEmpty(tLRUnits) == false then
                                --Special scenario
                                local oEnemyToFocusOn = oNearestEnemySurfaceToFriendlyBase
                                local iCurDist

                                bAntiTorpLauncherMode = true
                                if bDebugMessages == true then LOG(sFunctionRef..': About to enter special scenario mode for zone '..iWaterZone..', oEnemyToFocusOn='..oEnemyToFocusOn.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToFocusOn)) end
                                if M28UnitInfo.IsUnitValid(oEnemyToFocusOn) then
                                    for iUnit, oUnit in tLRUnits do
                                        if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                                            M28Orders.IssueTrackedMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iOrderReissueDistToUse, false, 'NTorLBl'..iWaterZone)
                                            if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), (oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or oEnemyToFocusOn:GetPosition())) <= 18 then bUpdateNearestUnit = true end
                                            if not(oEnemyToFocusOn) then
                                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(),  (oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or oEnemyToFocusOn:GetPosition()))
                                            end
                                        elseif not(IgnoreOrderDueToStuckUnit(oUnit)) then
                                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(),  (oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] or oEnemyToFocusOn:GetPosition()))
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..iCurDist..'; Unit combat range='..oUnit[M28UnitInfo.refiCombatRange]..'; bUseAOEAttacks='..tostring(bUseAOEAttacks)) end
                                            if iCurDist < oUnit[M28UnitInfo.refiCombatRange] - 5 then
                                                --Kiting retreat
                                                KitingRetreatOfUnit(oUnit)
                                            else
                                                --Attack-move to the nearest enemy, unless we have AOE and enemy has same range as us, in which case check for nearest enemy unit and attack ground if it is a surface unit
                                                if bUseAOEAttacks then
                                                    if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) and not(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck] == oEnemyToFocusOn) and not(M28UnitInfo.IsUnitUnderwater(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) then
                                                        --Attack the nearest enemy to us instead of the original target
                                                        if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId) and (oUnit[M28UnitInfo.refiCombatRange] or 0) <= (oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.refiCombatRange] or 0) then
                                                            --Do aoe attack
                                                            local tGroundAttackTarget = M28Utilities.MoveInDirection(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition(), oUnit:GetPosition()), oUnit[M28UnitInfo.refiDFAOE] * 0.75, true)
                                                            M28Orders.IssueTrackedGroundAttack(oUnit, tGroundAttackTarget, oUnit[M28UnitInfo.refiDFAOE], false, 'NTorAOEGA', false, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Doing ground attack as oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]'..oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) end
                                                        else
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy isnt a structure so we will do attack move towards it, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]='..oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck])) end
                                                            --do attack move
                                                            M28Orders.IssueTrackedAggressiveMove(oUnit, oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iOrderReissueDistToUse, false, 'NTorAOEAM'..iWaterZone)
                                                        end
                                                    else
                                                        --do aoe attack
                                                        local tGroundAttackTarget = M28Utilities.MoveInDirection(oEnemyToFocusOn:GetPosition(), M28Utilities.GetAngleFromAToB(oEnemyToFocusOn:GetPosition(), oUnit:GetPosition()), oUnit[M28UnitInfo.refiDFAOE] * 0.75, true)
                                                        M28Orders.IssueTrackedGroundAttack(oUnit, tGroundAttackTarget, oUnit[M28UnitInfo.refiDFAOE], false, 'NTorAOEGA', false, oEnemyToFocusOn)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Doing ground attack to attack the enemy') end
                                                    end
                                                else
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Arent relying on aoe to attack') end
                                                    M28Orders.IssueTrackedAggressiveMove(oUnit, oEnemyToFocusOn[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iOrderReissueDistToUse, false, 'NTorLAM'..iWaterZone)
                                                end
                                            end
                                        end
                                        if iCurDist and iCurDist < iClosestLRUnitDist then
                                            iClosestLRUnitDist = iCurDist
                                            oClosestLRUnit = oUnit
                                        end
                                    end
                                end

                                if oClosestLRUnit and M28Utilities.IsTableEmpty(tSRUnits) == false then
                                    local tSupportPosition = M28Utilities.MoveInDirection(oClosestLRUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestLRUnit:GetPosition(), tRallyPoint), 10, true)
                                    for iUnit, oUnit in tSRUnits do
                                        M28Orders.IssueTrackedMove(oUnit, tSupportPosition, 5, false, 'NTorSRSup'..iWaterZone, false)
                                    end
                                end

                                if bUpdateNearestUnit then
                                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                                        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                                        if aiBrain then
                                            M28Team.UpdateUnitLastKnownPosition(aiBrain, oNearestEnemyToFriendlyBase, true)
                                        end
                                    else
                                        M28Utilities.ErrorHandler('No active M28 brain')
                                    end
                                end
                                --if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                                --if not(IgnoreOrderDueToStuckUnit(oUnit)) then
                            end
                        end

                        --Scenario 3 - want to retreat (but only retreat units from this WZ)
                        bWantReinforcements = true
                        if not(bAntiTorpLauncherMode) and M28Utilities.IsTableEmpty(tCombatUnitsOfUse) == false then
                            local tSubRallyPoint
                            local sMessage
                            local bConsiderAmphibiousRally = true
                            local bAttackMoveIfRallyPointIsClose = false
                            if bDebugMessages == true then LOG(sFunctionRef..': Dont have enough threat to attack with surface naval units, will see if we want to consolidate in this zone, iAvailableCombatThreat='..iAvailableCombatThreat..'; iAdjacentAlliedCombatThreat='..iAdjacentAlliedCombatThreat..'; Want to attack with navy='..tostring(M28Conditions.WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iNearbyFriendlySubThreat, iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAvailableCombatThreat, iAdjacentEnemyCombatThreat, true, iModForEnemyScenario2Threat, iEnemyNearbySubmersibleThreat,  iOurAntiNavyThreat ))) end
                            if iAvailableCombatThreat > iAdjacentAlliedCombatThreat and M28Conditions.WantToAttackWithNavyEvenIfOutranged(tWZData, tWZTeamData, iTeam, iNearbyFriendlySubThreat, iAdjacentAlliedSubmersibleThreat, iAdjacentEnemyAntiNavyThreat, iAvailableCombatThreat, iAdjacentEnemyCombatThreat, true, iModForEnemyScenario2Threat, iEnemyNearbySubmersibleThreat,  iOurAntiNavyThreat) then
                                sMessage = 'WSfConsR'
                                tSubRallyPoint = {tWZData[M28Map.subrefMidpoint][1], tWZData[M28Map.subrefMidpoint][2], tWZData[M28Map.subrefMidpoint][3]}
                                bConsiderAmphibiousRally = false
                                bAttackMoveIfRallyPointIsClose = true
                            else
                                sMessage = 'WSfRetr'
                                tSubRallyPoint = tRallyPoint
                                if M28Map.GetWaterZoneFromPosition(tSubRallyPoint) == iWaterZone then bAttackMoveIfRallyPointIsClose = true end
                            end
                            local tAmphibiousRallyPoint = {tWZTeamData[M28Map.reftClosestFriendlyBase][1], tWZTeamData[M28Map.reftClosestFriendlyBase][2], tWZTeamData[M28Map.reftClosestFriendlyBase][3]}
                            local iAmphibiousRallyPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tAmphibiousRallyPoint)


                            for iUnit, oUnit in tCombatUnitsOfUse do
                                if oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iWaterZone then
                                    if EntityCategoryContains(categories.HOVER, oUnit.UnitId) then iOrderReissueDistToUse = iResisueOrderDistanceHover
                                    else iOrderReissueDistToUse = iReissueOrderDistanceStandard
                                    end
                                    oUnit[M28UnitInfo.refiTimeLastTriedRetreating] = iCurTime
                                    if bConsiderAmphibiousRally and EntityCategoryContains(M28UnitInfo.refCategoryAmphibious + categories.HOVER, oUnit.UnitId) then --redundancy - wouldnt expect a sub to be amphibious
                                        if iAmphibiousRallyPlateau then
                                            ForkThread(M28Land.BackupUnitTowardsRallyIfAvailable, oUnit, tRallyPoint, iAmphibiousRallyPlateau, sMessage..'_AmpR'..iWaterZone, false, nil, nil, false)
                                        else
                                            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, iOrderReissueDistToUse, false, sMessage..'_AmpR'..iWaterZone)
                                        end
                                    else
                                        --If close to rally point then attackmove
                                        if bAttackMoveIfRallyPointIsClose and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tSubRallyPoint) <= 10 then
                                            M28Orders.IssueTrackedAttackMove(oUnit, tAmphibiousRallyPoint, iOrderReissueDistToUse, false, sMessage..'AM'..iWaterZone)
                                        else
                                            ForkThread(M28Land.BackupUnitTowardsRallyIfAvailable, oUnit, tSubRallyPoint, iPond, sMessage..iWaterZone, false, nil, nil, true)
                                        end
                                        --M28Orders.IssueTrackedMove(oUnit, tSubRallyPoint, iOrderReissueDistToUse, false, sMessage..iWaterZone)
                                    end
                                else
                                    oUnit[refiCurrentWZAssignmentValue] = 0
                                end
                            end
                        end
                    end
                end
            end

            --Ground fire subs
            if bDebugMessages == true then LOG(sFunctionRef..': Considering ground firing subs, is tCombatUnitsNeedingAOEForSubs empty='..tostring(M28Utilities.IsTableEmpty(tCombatUnitsNeedingAOEForSubs))..'; Is oNearestEnemyNonHoverToFriendlyBase nil='..tostring(oNearestEnemyNonHoverToFriendlyBase == nil)) end
            if M28Utilities.IsTableEmpty(tCombatUnitsNeedingAOEForSubs) == false and oNearestEnemyNonHoverToFriendlyBase then
                local tTargetPoint = oNearestEnemyNonHoverToFriendlyBase:GetPosition()
                tTargetPoint[2] = GetSurfaceHeight(tTargetPoint[1], tTargetPoint[3])
                for iUnit, oUnit in tCombatUnitsNeedingAOEForSubs do
                    --Ground fire the closest enemy unit
                    M28Orders.IssueTrackedGroundAttack(oUnit, tTargetPoint, 1, false, 'GrndFr', false)
                end
            end
        end

        --Missile ships - consider retreating from nearby enemy units
        local tMissileShipsToBombard = {}
        if M28Utilities.IsTableEmpty(tMissileShips) == false then
            if oNearestEnemyToFriendlyBase then
                for iUnit, oUnit in tMissileShips do
                    if oNearestEnemyToFriendlyBase and M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase:GetPosition(), oUnit:GetPosition()) <= math.max((oUnit[M28UnitInfo.refiCombatRange] or 60) * 0.6, math.min((oUnit[M28UnitInfo.refiCombatRange] or 60) - 10, (oNearestEnemyToFriendlyBase[M28UnitInfo.refiCombatRange] or 20) + 10, (tWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0) + 10)) then
                        --M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 5, false, 'MisRetr', false)
                        ForkThread(M28Land.BackupUnitTowardsRallyIfAvailable, oUnit, tRallyPoint, iPond, 'MisRetr', false, nil, nil, true)
                    else
                        table.insert(tMissileShipsToBombard, oUnit)
                    end
                end
            else
                tMissileShipsToBombard = tMissileShips
            end
        end

        --Update if had visula of WZ recently
        if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
            tWZTeamData[M28Map.refiTimeLastHadVisual] = GetGameTimeSeconds()
        end


        if bDebugMessages == true then LOG(sFunctionRef..': Is table of subs with no target empty='..tostring(M28Utilities.IsTableEmpty(tSubmarinesWithNoTarget))..'; Is table of combat units with no target empty='..tostring(M28Utilities.IsTableEmpty(tCombatUnitsWithNoTarget))) end
        if M28Utilities.IsTableEmpty(tSubmarinesWithNoTarget) == false or M28Utilities.IsTableEmpty(tCombatUnitsWithNoTarget) == false or M28Utilities.IsTableEmpty(tMissileShipsToBombard) == false then
            --No enemies in the water zone or adjacent that can target so will look to reinforce another water zone
            --ConsiderOrdersForUnitsWithNoTarget(tWZData, iPond, iWaterZone, iTeam, tSubmarinesWithNoTarget, tCombatUnitsWithNoTarget, tMissileShips)
            tUnassignedLandUnits = ConsiderOrdersForUnitsWithNoTarget(tWZData, iPond, iWaterZone, iTeam, tSubmarinesWithNoTarget, tCombatUnitsWithNoTarget, tMissileShipsToBombard)
            if M28Utilities.IsTableEmpty(tSubmarinesWithNoTarget) == false then
                if not(M28Team.tTeamData[iTeam][M28Team.refiTimeLastNoSubCombatTargetByPond]) then M28Team.tTeamData[iTeam][M28Team.refiTimeLastNoSubCombatTargetByPond] = {} end
                M28Team.tTeamData[iTeam][M28Team.refiTimeLastNoSubCombatTargetByPond][iPond] = GetGameTimeSeconds()
            end
            if M28Utilities.IsTableEmpty(tCombatUnitsWithNoTarget) == false and not(oNearestEnemyNonHoverToFriendlyBase) then
                if not(M28Team.tTeamData[iTeam][M28Team.refiTimeLastNoSurfaceCombatTargetByPond]) then M28Team.tTeamData[iTeam][M28Team.refiTimeLastNoSurfaceCombatTargetByPond] = {} end
                M28Team.tTeamData[iTeam][M28Team.refiTimeLastNoSurfaceCombatTargetByPond][iPond] = GetGameTimeSeconds()
            end
        end
    end

    --Override support if we couldnt find any enemies
    if bWantReinforcements and (not(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) or tWZData[M28Map.subrefbPacifistArea]) then bWantReinforcements = false end
    UpdateIfWaterZoneWantsSupport(tWZTeamData, bWantReinforcements)
    if bDebugMessages == true then LOG(sFunctionRef..': Just recorded if this WZ wants support, bWantReinforcements='..tostring(bWantReinforcements)..'; is tUnassignedLandUnits empty='..tostring(M28Utilities.IsTableEmpty(tUnassignedLandUnits))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tUnassignedLandUnits
end

function ManageMAAInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableMAA)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMAAInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
    local tAmphibiousRallyPoint = {tWZTeamData[M28Map.reftClosestFriendlyBase][1], tWZTeamData[M28Map.reftClosestFriendlyBase][2], tWZTeamData[M28Map.reftClosestFriendlyBase][3]}
    local iResisueOrderDistanceHover = 15

    --First split the MAA into those that need to run (due to being in range of DF units) and those that can advance
    local tAvailableSubjectToAA = {}
    local tMAAToAdvance = {}
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Time='..GetGameTimeSeconds()..' for iPond='..iPond..' iWaterZone '..iWaterZone..' iTeam '..iTeam..'; Is table of nearest combat enemies empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]))..'; Is subreftoAllNearbyEnemyT2ArtiUnits empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]))) end

    local tEnemyT2Arti = {}

    if M28Conditions.IsTableOfUnitsStillValid(tWZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) then
        for iUnit, oUnit in tWZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits] do
            if oUnit:GetFractionComplete() == 1 then
                table.insert(tEnemyT2Arti, oUnit)
            end
        end
    end
    local bCheckForT2Arti = not(M28Utilities.IsTableEmpty(tEnemyT2Arti))
    --If have adjacent water zone with naval combat under air attack then dont check for T2 arti
    if bCheckForT2Arti then
        if tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 and tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] > 200 and tWZTeamData[M28Map.subrefWZMAAThreatWanted] >= 50 then
            bCheckForT2Arti = false
        elseif M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
            local iAdjPond
            for iEntry, iAdjWaterZone in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                iAdjPond = M28Map.tiPondByWaterZone[iAdjWaterZone]
                local tAdjWZTeamData = M28Map.tPondDetails[iAdjPond][M28Map.subrefPondWaterZones][iAdjWaterZone][M28Map.subrefWZTeamData][iTeam]
                if tAdjWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 and tAdjWZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] > 200 and tAdjWZTeamData[M28Map.subrefWZMAAThreatWanted] >= 50 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont want to check for T2 arti as we have navlau nits under attack') end
                    bCheckForT2Arti = false
                    break
                end
            end
        end
    end

    local bIgnoreT2ArtiIfOutrangedByIt = false
    if bCheckForT2Arti then
        --If our indirect threat of our MAA units is significant, and exceeds the enemy T2 arti, then want to consider attacking
        if tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] > 200 then
            local iOurIndirectThreat = M28UnitInfo.GetCombatThreatRating(tAvailableMAA, false, false, true, false, false, false, false)
            local iEnemyT2ArtiCost = M28UnitInfo.GetMassCostOfUnits(tEnemyT2Arti, true)
            if iOurIndirectThreat > 1.5 * iEnemyT2ArtiCost then
                --Check the mass value of our units that have below 130 range (but more than 50) is at least as much as the t2 arti value - i.e. risk is we have lots of cruiers and 1 shorter range unit and we suicide shorter range unit
                local iOurMediumRangeIndirectMassValue = 0
                for iUnit, oUnit in tAvailableMAA do
                    if oUnit[M28UnitInfo.refiCombatRange] > 50 and oUnit[M28UnitInfo.refiCombatRange] < 135 then
                        iOurMediumRangeIndirectMassValue = iOurMediumRangeIndirectMassValue + (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetMassCostOfUnits(oUnit))
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iOurMediumRangeIndirectMassValue='..iOurMediumRangeIndirectMassValue..'; iEnemyT2ArtiCost='..iEnemyT2ArtiCost) end
                if iOurMediumRangeIndirectMassValue > iEnemyT2ArtiCost then
                    bIgnoreT2ArtiIfOutrangedByIt = true
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iOurIndirectThreat='..iOurIndirectThreat..'; iEnemyT2ArtiCost='..iEnemyT2ArtiCost..'; bIgnoreT2ArtiIfOutrangedByIt='..tostring(bIgnoreT2ArtiIfOutrangedByIt or false)) end
        end
    end

    function RetreatUnitTowardsNavalOrAmphibiousRally(oUnit, sOrderDesc)
        if EntityCategoryContains(M28UnitInfo.refCategoryAmphibious + categories.HOVER, oUnit.UnitId) then
            M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, iResisueOrderDistanceHover, false, (sOrderDesc or 'Run')..'A'..iWaterZone)
        else
            --Naval AA - Are we close to an enemy unit, and the rally point we would be using isn't in the opposite direction?
            local bMovedInOppositeDirectionInstead = false
            if M28UnitInfo.IsUnitValid(oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]) then
                local iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tRallyPoint)
                local iAngleToEnemy = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M28UnitInfo.refoClosestEnemyFromLastCloseToEnemyUnitCheck]:GetPosition())
                if M28Utilities.GetAngleDifference(iAngleToRally, iAngleToEnemy) <= 65 then
                    local tRunFromEnemyPosition = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToEnemy + 180, 15, true, false, M28Map.bIsCampaignMap)
                    if M28Utilities.IsTableEmpty(tRunFromEnemyPosition) == false then
                        local iRunSegmentX, iRunSegmentZ = M28Map.GetPathingSegmentFromPosition(tRunFromEnemyPosition)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering running away from nearest enemy, Pond of run position='..( M28Map.tPondBySegment[iRunSegmentX][iRunSegmentZ] or 'nil')..'; iPond='..(iPond)) end
                        if M28Map.tPondBySegment[iRunSegmentX][iRunSegmentZ] == iPond then
                            bMovedInOppositeDirectionInstead = true
                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, iResisueOrderDistanceHover, false, (sOrderDesc or 'Run')..'Aw'..iWaterZone)
                        end
                    end
                end
            end
            if not(bMovedInOppositeDirectionInstead) then
                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, iResisueOrderDistanceHover, false, (sOrderDesc or 'Run')..'N'..iWaterZone)
            end
        end
    end


    function DoesUnitWantToRunFromT2Arti(oUnit, iRunThreshold)
        if bCheckForT2Arti then --redundancy
            for iArti, oArti in tEnemyT2Arti do
                if bIgnoreT2ArtiIfOutrangedByIt and (oArti[M28UnitInfo.refiCombatRange] or 0) + iRunThreshold >= (oUnit[M28UnitInfo.refiCombatRange] or 0) then
                    if bDebugMessages == true then LOG(sFunctionRef..': oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has combat range='..(oUnit[M28UnitInfo.refiCombatRange] or 0)..'; oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)..' has a combat range '..(oArti[M28UnitInfo.refiCombatRange] or 0)..' will ignore since we think we have enough indirect threat to take on the arti') end
                    return false
                elseif M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oArti:GetPosition()) <= iRunThreshold + (oArti[M28UnitInfo.refiCombatRange] or 0) then
                    if bDebugMessages == true then LOG(sFunctionRef..': oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has combat range='..(oUnit[M28UnitInfo.refiCombatRange] or 0)..'; oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)..' has a combat range '..(oArti[M28UnitInfo.refiCombatRange] or 0)..'; bIgnoreT2ArtiIfOutrangedByIt='..tostring(bIgnoreT2ArtiIfOutrangedByIt)..'; Dist to the arti='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oArti:GetPosition())..'; will run from the arti') end
                    return true
                end
            end
        end
        return false
    end
    local tNearbyEnemyLandToAvoid = {}
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
        local iClosestDistLessRange
        local iCurDistLessRange
        for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
            local tAdjLZTeamData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefWPlatAndLZNumber][1]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefWPlatAndLZNumber][2]][M28Map.subrefLZTeamData][iTeam]
            local oClosestEnemyDFUnit
            iClosestDistLessRange = 150 --No point including units further away than this
            if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                --Record all units who are within 50 of being able to shoot at this WZ's midpoint, or (if no such units) the closest enemy unit
                for iUnit, oUnit in tAdjLZTeamData[M28Map.reftoNearestDFEnemies] do
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        iCurDistLessRange = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tWZData[M28Map.subrefMidpoint])
                        if iCurDistLessRange <= 50 then
                            table.insert(tNearbyEnemyLandToAvoid, oUnit)
                            if iCurDistLessRange < iClosestDistLessRange then
                                if oClosestEnemyDFUnit and iClosestDistLessRange > 50 then oClosestEnemyDFUnit = nil end
                                iClosestDistLessRange = iCurDistLessRange
                            end
                        elseif iCurDistLessRange < iClosestDistLessRange then
                            iClosestDistLessRange = iCurDistLessRange
                            oClosestEnemyDFUnit = oUnit
                        end
                    end
                end
            end
            if oClosestEnemyDFUnit then table.insert(tNearbyEnemyLandToAvoid, oClosestEnemyDFUnit) end
        end
    end
    local bHaveNearbyLandUnits = not(M28Utilities.IsTableEmpty(tNearbyEnemyLandToAvoid))

    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]) and not(bHaveNearbyLandUnits) then
        --No DF enemies so treat all MAA as being available
        if bDebugMessages == true then LOG(sFunctionRef..': No nearby combat enemies so treating all MAA as being available unless in range of T2 arti, bCheckForT2Arti='..tostring(bCheckForT2Arti)) end
        if bCheckForT2Arti then
            for iUnit, oUnit in tAvailableMAA do
                if not(DoesUnitWantToRunFromT2Arti(oUnit, 10)) then
                    table.insert(tAvailableSubjectToAA, oUnit)
                else
                    RetreatUnitTowardsNavalOrAmphibiousRally(oUnit, 'RunT2Art')
                end
            end
        else
            tAvailableSubjectToAA = tAvailableMAA
        end

    else
        local iRunThreshold = 30
        if tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
            iRunThreshold = 15
        end
        local bHaveNearbyWaterEnemies = not(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]))
        for iUnit, oUnit in tAvailableMAA do
            if not(oUnit.Dead) then --to stop rare error
                --Run if within 30 of being in range of enemy combat
                if bDebugMessages == true then
                    LOG(sFunctionRef..': MAA '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' - checking if is too close to enemy, is close='..tostring(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tWZTeamData[M28Map.reftoNearestCombatEnemies], iRunThreshold, iTeam, true                    ,nil                        ,nil                            ,nil                                        ,nil                                    ,true))..'; iRunThreshold='..iRunThreshold..'; will run back if are too close; will list out enemy units and distance to us in a moment; Is unit too close to T2 arti='..tostring(DoesUnitWantToRunFromT2Arti(oUnit, 10)))
                    if bHaveNearbyWaterEnemies then
                        for iEnemy, oEnemy in tWZTeamData[M28Map.reftoNearestCombatEnemies] do
                            LOG('oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; DF r ange='..(oEnemy[M28UnitInfo.refiDFRange] or 'nil')..'; Dist to this MAA unit='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Actual distance using actual position='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemy:GetPosition()))
                        end
                    end
                    if bHaveNearbyLandUnits then
                        for iEnemy, oEnemy in tNearbyEnemyLandToAvoid do
                            LOG('oEnemy on land='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; Dist to MAA='..M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())..'; Unit DF range='..(oEnemy[M28UnitInfo.refiDFRange] or 'nil'))
                            if M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition()) - (oEnemy[M28UnitInfo.refiDFRange] or 0) <= iRunThreshold then
                                LOG('This enemy unit is close enough that it should cause the MAA to run')
                            end
                        end
                    end
                end
                --                      CloseToEnemyUnit(tStartPosition, tUnitsToCheck,                             iDistThreshold, iTeam, bIncludeEnemyDFRange, iAltThresholdToDFRange, oUnitIfConsideringAngleAndLastShot, oOptionalFriendlyUnitToRecordClosestEnemy, iOptionalDistThresholdForStructure, bIncludeEnemyAntiNavyRange)
                if (bHaveNearbyWaterEnemies and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tWZTeamData[M28Map.reftoNearestCombatEnemies], iRunThreshold, iTeam, true                    ,nil                        ,oUnit                            ,nil                                        ,nil                                    ,true))
                        or (bHaveNearbyLandUnits and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tNearbyEnemyLandToAvoid, iRunThreshold, iTeam, true                    ,nil                        ,oUnit                            ,nil                                        ,nil                                    ,true)) then
                    RetreatUnitTowardsNavalOrAmphibiousRally(oUnit, 'RunDF')
                else
                    --Check not in range of T2 arti
                    if bCheckForT2Arti and DoesUnitWantToRunFromT2Arti(oUnit, 10) then
                        RetreatUnitTowardsNavalOrAmphibiousRally(oUnit, 'RunT2Art')
                    else
                        table.insert(tAvailableSubjectToAA, oUnit)
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': is table of tAvailableSubjectToAA empty after running from DF threats='..tostring(M28Utilities.IsTableEmpty(tAvailableSubjectToAA))) end
    if M28Utilities.IsTableEmpty(tAvailableSubjectToAA) == false then
        --Retreat individual MAA units if in range of enemy air and enemy has high air to ground threat
        local iEnemyAirToGroundThreat = tWZTeamData[M28Map.refiEnemyAirToGroundThreat]
        local iOurAAThreat = tWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA]
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
            for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do --include half of the 'excess' enemy air to ground threat in adjacent zones
                local tAdjWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                iEnemyAirToGroundThreat = iEnemyAirToGroundThreat + math.max(0, ((tAdjWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) -  (tAdjWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] or 0) * 3))*0.5
            end
        end

        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
            for _, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                local tAdjLZTeamData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefWPlatAndLZNumber][1]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefWPlatAndLZNumber][2]][M28Map.subrefLZTeamData][iTeam]
                iEnemyAirToGroundThreat = iEnemyAirToGroundThreat + (tAdjLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) + (tAdjLZTeamData[M28Map.refiEnemyAirOtherThreat] or 0)
            end
        end
        local tEnemyAirToRunFrom
        if bDebugMessages == true then LOG(sFunctionRef..': iEnemyAirToGroundThreat='..iEnemyAirToGroundThreat..'; iOurAAThreat='..iOurAAThreat) end
        if iEnemyAirToGroundThreat > iOurAAThreat then
            --We may lose if our AA goes up against their air threat, so want to retreat any AA units that are reasonably in-range
            local iCategoriesToAvoid = M28UnitInfo.refCategoryAirToGround - M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL -M28UnitInfo.refCategoryBomber * categories.TECH3 --dont want to avoid t3 or exp bombers since they struggle to turn around
            if tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]) == false then
                tEnemyAirToRunFrom = EntityCategoryFilterDown(iCategoriesToAvoid, tWZTeamData[M28Map.reftWZEnemyAirUnits])
            end
            if not(tEnemyAirToRunFrom) then tEnemyAirToRunFrom = {} end
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do --include half of the 'excess' enemy air to ground threat in adjacent zones
                    local tAdjWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                    if tAdjWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 and   M28Utilities.IsTableEmpty(tAdjWZTeamData[M28Map.reftWZEnemyAirUnits]) == false then
                        local tAdditionalAirToRunFrom = EntityCategoryFilterDown(iCategoriesToAvoid, tAdjWZTeamData[M28Map.reftWZEnemyAirUnits])
                        if M28Utilities.IsTableEmpty(tAdditionalAirToRunFrom) == false then
                            for iUnit, oUnit in tAdditionalAirToRunFrom do
                                if M28UnitInfo.IsUnitValid(oUnit) then table.insert(tEnemyAirToRunFrom, oUnit) end
                            end
                        end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
                for _, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do --include half of the 'excess' enemy air to ground threat in adjacent zones
                    local tAdjLZTeamData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefWPlatAndLZNumber][1]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefWPlatAndLZNumber][2]][M28Map.subrefLZTeamData][iTeam]
                    if tAdjLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 and   M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.reftLZEnemyAirUnits]) == false then
                        local tAdditionalAirToRunFrom = EntityCategoryFilterDown(iCategoriesToAvoid, tAdjLZTeamData[M28Map.reftLZEnemyAirUnits])
                        if M28Utilities.IsTableEmpty(tAdditionalAirToRunFrom) == false then
                            for iUnit, oUnit in tAdditionalAirToRunFrom do
                                if M28UnitInfo.IsUnitValid(oUnit) then table.insert(tEnemyAirToRunFrom, oUnit) end
                            end
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is tEnemyAirToRunFrom empty='..tostring(M28Utilities.IsTableEmpty(tEnemyAirToRunFrom))) end
        if M28Utilities.IsTableEmpty(tEnemyAirToRunFrom) then
            tMAAToAdvance = tAvailableSubjectToAA
        else
            local iAttackMoveDistWithinRangeWanted = 4
            local iMoveDistWithinRange = 8

            local bAAInRange, iCurDistWithinRange
            for iMAA, oMAA in tAvailableSubjectToAA do
                bAAInRange = false
                for iAirUnit, oAirUnit in tEnemyAirToRunFrom do
                    iCurDistWithinRange = (oMAA[M28UnitInfo.refiAARange] or 0) - M28Utilities.GetDistanceBetweenPositions(oMAA:GetPosition(), oAirUnit:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oMAA='..oMAA.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMAA)..'; AA range='..(oMAA[M28UnitInfo.refiAARange] or 0)..'; oAirUnit='..oAirUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oAirUnit)..'; Dist to oAirUnit='..M28Utilities.GetDistanceBetweenPositions(oMAA:GetPosition(), oAirUnit:GetPosition())) end
                    if iCurDistWithinRange >= iAttackMoveDistWithinRangeWanted then
                        bAAInRange = true
                        if iCurDistWithinRange >= iMoveDistWithinRange then
                            --Move away
                            RetreatUnitTowardsNavalOrAmphibiousRally(oMAA, 'AAMPRun')
                        else
                            --Attack move away
                            if EntityCategoryContains(M28UnitInfo.refCategoryAmphibious + categories.HOVER, oMAA.UnitId) then
                                M28Orders.IssueTrackedAttackMove(oMAA, tAmphibiousRallyPoint, iResisueOrderDistanceHover, false, 'AAAPRun'..iWaterZone)
                            else
                                M28Orders.IssueTrackedAttackMove(oMAA, tRallyPoint, iResisueOrderDistanceHover, false, 'AAARun'..iWaterZone)
                            end
                        end
                        break
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': bAAInRange='..tostring(bAAInRange)) end
                if not(bAAInRange) then table.insert(tMAAToAdvance, oMAA) end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of tMAAToAdvance empty='..tostring(M28Utilities.IsTableEmpty(tMAAToAdvance))) end
    local bDontCheckIfUnitInPlayableArea = not(M28Map.bIsCampaignMap)
    --If enemy has air units in this zone then send the MAA to advance units towards it, but avoid enemy land units
    if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
        local bDontCheckIfInCampaignArea = not(M28Map.bIsCampaignMap)
        if bDebugMessages == true then LOG(sFunctionRef..': Number of MAA units to advance='..table.getn(tMAAToAdvance)..'; Is table of enemy air units for this WZ '..iWaterZone..' empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]))) end

        --Do we have missile based MAA in this list, and if so does the enemy have nearby structures of interest? (i.e. T2+ structures)
        local tCombatAAByOrigRef = {}
        local iBestRange = 0
        local iLowestBestRange = 1000 --i.e. of those that are more than the threshold (80 as of first draft), what is the worst range?
        local iClosestZoneWithStructuresDist = 10000
        local tClosestEnemyBuildingsOfInterest
        local oClosestEnemyStructureOfInterest
        local oEnemyStructureToTarget
        local toEnemyStructuresAndModDist = {}
        local oClosestModDistEnemyStructure -- will favour higher priority enemy targets that may not be the closest unit
        local iApproxDistUntilEnemyInRangeOfZone = 10000
        local iSurfaceRange

        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
            for iUnit, oUnit in tMAAToAdvance do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit combat range='..oUnit[M28UnitInfo.refiCombatRange]..'; Last shot blocked='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked] or false)) end
                if oUnit[M28UnitInfo.refiCombatRange] >= 80 then --covers cybran cruisers
                    iSurfaceRange = math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0))
                    if iSurfaceRange >= 80 then
                        if oUnit[M28UnitInfo.refbLastShotBlocked] and (oUnit[M28UnitInfo.refiIndirectRange] or 0) == 0 and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                            --Do nothing - direct fire cruiser whose shot is blocked so want to use like normal AA unit
                        else
                            tCombatAAByOrigRef[iUnit] = oUnit
                            if oUnit[M28UnitInfo.refiCombatRange] >= iBestRange then iBestRange = oUnit[M28UnitInfo.refiCombatRange] end
                        end
                        iLowestBestRange = math.min(iLowestBestRange, iSurfaceRange)
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for combat AA units, iBestRange='..iBestRange) end
            --if iBestRange >= 80 then
            --search for enemy buildings both for potential targets, and t2 arti/pd to retreat from
            local iDistanceThreshold = math.max(iBestRange + 90, 40+128)
            local bDontCheckPlayableArea = M28Map.bIsCampaignMap
            local iBestEnemyRangeForThisZone
            local iApproxMidpointAdjust

            local iClosestBuildingDist = 10000
            local iCurDist
            local iCurModDist
            local iClosestBuildingModDist = 10000
            local iZoneCountFromFirstBuilding = 0
            for iEntry, tSubtable in tWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                if tSubtable[M28Map.subrefiDistance] > iDistanceThreshold then
                    break
                else
                    if not(iApproxMidpointAdjust) then iApproxMidpointAdjust = tSubtable[M28Map.subrefiDistance] end --i.e. dist from the closest land/water zone midpoint to this midpoint will be used as a proxy to adjust the other distances, on the assumption that a unit in the closest zone to this could be firing at units in this zone
                    local tAltLZOrWZData
                    local tAltLZOrWZTeamData
                    iBestEnemyRangeForThisZone = 0
                    if tSubtable[M28Map.subrefbIsWaterZone] then --will check if it's in the same pond later on
                        tAltLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                        tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                        --Water zone - only consider DF+Antinayv range, not indirect fire since should be able to dodge most IF
                        iBestEnemyRangeForThisZone = math.max((tAltLZOrWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0), (tAltLZOrWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] or 0))
                    else
                        --Land zone
                        tAltLZOrWZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                        tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                        iBestEnemyRangeForThisZone = math.max((tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0), (tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0), (tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0))
                        if (tAltLZOrWZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] or 0) >= 200 then
                            iBestEnemyRangeForThisZone = math.max(iBestEnemyRangeForThisZone, 128)
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering entry '..iEntry..'; Is water zone='..tostring(tSubtable[M28Map.subrefbIsWaterZone])..'; PlateauOrPond='..tSubtable[M28Map.subrefiPlateauOrPond]..'; Zone ref='..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..'; In playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAltLZOrWZData[M28Map.subrefMidpoint]))..'; Enemy structure value='..(tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0)) end
                    --Get the closest enemy unit to thie midpoint of this zone if we have combat aa:
                    if (bDontCheckIfInCampaignArea or M28Conditions.IsLocationInPlayableArea(tAltLZOrWZData[M28Map.subrefMidpoint])) and iBestRange >= 80 and (tSubtable[M28Map.subrefiPlateauOrPond] == iPond or not(tSubtable[M28Map.subrefbIsWaterZone])) and iZoneCountFromFirstBuilding <= 8 then
                        if (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAltLZOrWZData[M28Map.subrefMidpoint])) and (tAltLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) >= 200 then
                            if oClosestEnemyStructureOfInterest then iZoneCountFromFirstBuilding = iZoneCountFromFirstBuilding + 1 end
                            tClosestEnemyBuildingsOfInterest = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure - categories.TECH1, tAltLZOrWZTeamData[M28Map.subrefTEnemyUnits])
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy buildsings empty='..tostring(M28Utilities.IsTableEmpty(tClosestEnemyBuildingsOfInterest))) end
                            if M28Utilities.IsTableEmpty(tClosestEnemyBuildingsOfInterest) == false then
                                if not(oClosestEnemyStructureOfInterest) then iClosestZoneWithStructuresDist = tSubtable[M28Map.subrefiDistance] end
                                --Get the closest enemy unit to thie midpoint of this zone if we have combat aa:

                                for iUnit, oUnit in tClosestEnemyBuildingsOfInterest do
                                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() >= 0.7 and not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tWZData[M28Map.subrefMidpoint])
                                        iCurModDist = iCurDist
                                        if EntityCategoryContains(categories.TECH3 + categories.EXPERIMENTAL + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryTMD, oUnit.UnitId) then
                                            iCurModDist = math.min(iCurModDist * 0.8, iCurModDist - 30)
                                        end
                                        if iCurDist < iClosestBuildingDist then
                                            iClosestBuildingDist = iCurDist
                                            oClosestEnemyStructureOfInterest = oUnit
                                        end
                                        if iCurModDist < iClosestBuildingModDist then
                                            iClosestBuildingModDist = iCurModDist
                                            oClosestModDistEnemyStructure = oUnit
                                        end
                                        table.insert(toEnemyStructuresAndModDist, {oUnit, iCurModDist})
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': iClosestZoneWithStructuresDist='..iClosestZoneWithStructuresDist..'; iClosestBuildingDist='..iClosestBuildingDist..'; oClosestEnemyStructureOfInterest='..(oClosestEnemyStructureOfInterest.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyStructureOfInterest) or 'nil')) end
                            end
                        end
                    end
                    --Also record how close an enemy unit is to being in range of the midpoint of this zone
                    iApproxDistUntilEnemyInRangeOfZone = math.min(iApproxDistUntilEnemyInRangeOfZone, tSubtable[M28Map.subrefiDistance] - iApproxMidpointAdjust - iBestEnemyRangeForThisZone)
                end
            end

            if oClosestEnemyStructureOfInterest then
                --Switch closest enemy structure to closest mod dist enemy structure if we are likely to be in range of it
                if not(oClosestModDistEnemyStructure == oClosestEnemyStructureOfInterest) and iClosestBuildingModDist < iClosestBuildingDist then
                    --Are we in the same pond if we move towards this water zone midpoint?
                    local iActualDistToClosestModDist = M28Utilities.GetDistanceBetweenPositions(oClosestModDistEnemyStructure:GetPosition(), tWZData[M28Map.subrefMidpoint])
                    if iActualDistToClosestModDist <= iLowestBestRange then
                        oEnemyStructureToTarget = oClosestModDistEnemyStructure
                    else
                        local tPossibleAttackPoint = M28Utilities.MoveInDirection(oClosestModDistEnemyStructure:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestModDistEnemyStructure:GetPosition(), tWZData[M28Map.subrefMidpoint]), iActualDistToClosestModDist, true, false, false)
                        if NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tPossibleAttackPoint) == iPond then
                            oEnemyStructureToTarget = oClosestModDistEnemyStructure
                        else
                            oEnemyStructureToTarget = oClosestEnemyStructureOfInterest
                        end
                    end
                else
                    oEnemyStructureToTarget = oClosestEnemyStructureOfInterest
                end

                --Filter the combat MAA further to only include those who are either in range of oEnemyStructureToTarget, or would be in the same pond if they moved in range
                local iCurDist
                for iUnit, oUnit in tCombatAAByOrigRef do

                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oEnemyStructureToTarget:GetPosition(), oUnit:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if combat AA unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is in range of oEnemyStructureToTarget, CCombat range='..oUnit[M28UnitInfo.refiCombatRange]..'; iCurDist='..iCurDist) end
                    if iCurDist > oUnit[M28UnitInfo.refiCombatRange] then
                        local bHaveValidTarget = false
                        for iDistInterval = 0, 50, 10 do
                            local tPossibleFiringPoint = M28Utilities.MoveInDirection(oEnemyStructureToTarget:GetPosition(), M28Utilities.GetAngleFromAToB(oEnemyStructureToTarget:GetPosition(), oUnit:GetPosition()), oUnit[M28UnitInfo.refiCombatRange] - iDistInterval, true, false, false)
                            if NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tPossibleFiringPoint) == iPond then
                                bHaveValidTarget = true
                                break
                            end
                        end
                        if not(bHaveValidTarget) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Dont have valid firing point so removing combat unit') end
                            tCombatAAByOrigRef[iUnit] = nil
                        end
                    end
                end
            end
            --end
        else
            M28Air.RecordOtherLandAndWaterZonesByDistance(tWZData)
        end
        function AttackWithCombatAA(bOptionalOnlyAttackIfInRange)
            --Assign any remaining combatAA to attack the nearest structure to them
            --First remove from the orig MAA list
            if bDebugMessages == true then LOG(sFunctionRef..': Will attack with all combat AA units') end
            local iTableSize = table.getn(tMAAToAdvance)
            local iRevisedIndex = 1
            for iOrigIndex=1, iTableSize do
                if tMAAToAdvance[iOrigIndex] then
                    if not(tCombatAAByOrigRef[iOrigIndex]) or(bOptionalOnlyAttackIfInRange and M28Utilities.GetDistanceBetweenPositions(tCombatAAByOrigRef[iOrigIndex]:GetPosition(), oEnemyStructureToTarget:GetPosition()) <= tCombatAAByOrigRef[iOrigIndex][M28UnitInfo.refiCombatRange]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                        --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                        if (iOrigIndex ~= iRevisedIndex) then
                            tMAAToAdvance[iRevisedIndex] = tMAAToAdvance[iOrigIndex];
                            tMAAToAdvance[iOrigIndex] = nil;
                        end
                        if bOptionalOnlyAttackIfInRange then tCombatAAByOrigRef[iOrigIndex] = nil end
                        iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                    else
                        tMAAToAdvance[iOrigIndex] = nil;
                    end
                end
            end
            if iRevisedIndex < iTableSize then
                --table.setn(tMAAToAdvance, iRevisedIndex - 1)
                for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
                    table.remove(tMAAToAdvance, iRemovalEntry)
                end
            end

            --Now assign the combat MAA to attack the enemy structure
            local iAssignedUnitCount = 0
            for iUnit, oUnit in tCombatAAByOrigRef do
                --Get the closest enemy structure to this unit and attack it, unless we may be in range of a unit that can hurt us and are more than 6 in range of this

                if iApproxDistUntilEnemyInRangeOfZone <= 5 and oUnit[M28UnitInfo.refiCombatRange] - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemyStructureToTarget:GetPosition()) >= 6 then
                    --move away if same pond
                    local tTempRetreat = M28Utilities.MoveInDirection(oEnemyStructureToTarget:GetPosition(), M28Utilities.GetAngleFromAToB(oEnemyStructureToTarget:GetPosition(), oUnit:GetPosition()), oUnit[M28UnitInfo.refiCombatRange], true, false, M28Map.bIsCampaignMap)
                    if NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tTempRetreat) == iPond then
                        M28Orders.IssueTrackedMove(oUnit, tTempRetreat, 2, false, 'MAAReta', false)
                    else
                        iAssignedUnitCount = iAssignedUnitCount + 1
                        M28Orders.IssueTrackedAttack(oUnit, oEnemyStructureToTarget, false, 'CrNRAtc', false)
                    end
                else
                    iAssignedUnitCount = iAssignedUnitCount + 1
                    M28Orders.IssueTrackedAttack(oUnit, oEnemyStructureToTarget, false, 'CrSAtc', false)
                end
                if iAssignedUnitCount >= 5 then
                    if (iAssignedUnitCount >= 10 or not(EntityCategoryContains(M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryExperimentalLevel, oEnemyStructureToTarget.UnitId))) and M28Utilities.IsTableEmpty(toEnemyStructuresAndModDist) == false then
                        iAssignedUnitCount = 0
                        local iClosestModDist = 100000
                        local oNewTarget
                        local iNewEntryRef
                        local iOldEntryRef
                        local iOldModDist
                        for iEntry, tUnitAndModDist in toEnemyStructuresAndModDist do
                            if tUnitAndModDist[2] < iClosestModDist then
                                if tUnitAndModDist[1] == oEnemyStructureToTarget then
                                    iOldEntryRef = iEntry
                                    iOldModDist = tUnitAndModDist[2]
                                else
                                    oNewTarget = tUnitAndModDist[1]
                                    iClosestModDist = tUnitAndModDist[2]
                                    iNewEntryRef = iEntry
                                end
                            end
                        end
                        if oNewTarget and (not(iOldModDist) or iClosestModDist <= iOldModDist + 35) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Switching cruiser target to new building, oNewTarget='..(oNewTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNewTarget) or 'nil')..'; size of tCombatAAByOrigRef='..table.getn(tCombatAAByOrigRef)) end
                            table.remove(toEnemyStructuresAndModDist, iOldEntryRef)
                            oEnemyStructureToTarget = oNewTarget
                        end
                    end
                end
            end
        end

        local bConsiderAttackingStructuresInstead = false
        if M28UnitInfo.IsUnitValid(oEnemyStructureToTarget) and iClosestZoneWithStructuresDist < 500 and M28Utilities.IsTableEmpty(tCombatAAByOrigRef) == false and M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Want to consider attacking enemy structures instead') end
            bConsiderAttackingStructuresInstead = true
        else
            tCombatAAByOrigRef = nil
        end

        local bGivenOrderToGoToEnemyAirUnit = false
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]) == false then
            --Move towards the nearest enemy air unit to the WZ midpoint, unless are a combat AA unit in range of enemy unit (in which case keep attacking it)
            if bConsiderAttackingStructuresInstead then
                AttackWithCombatAA(true) --Only attacks structures if are in range of them
            end

            if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                local oNearestEnemyToMidpoint
                local iClosestDist = 100000
                local iCurDist
                --Get closest enemy air unit
                for iUnit, oUnit in tWZTeamData[M28Map.reftWZEnemyAirUnits] do
                    if bDontCheckIfUnitInPlayableArea or M28Conditions.IsLocationInPlayableArea(oUnit:GetPosition()) then
                        if (oUnit[M28UnitInfo.refiTargetShotBlockedCount] or 0) >= 10 then --Have had 10 shots at this unit and they have all been blocked - want to treat it as invisible
                            --Dont include as ap otential nearest enemy
                            if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has a shot blocked count of '..(oUnit[M28UnitInfo.refiTargetShotBlockedCount] or 0)) end
                        else
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oNearestEnemyToMidpoint = oUnit
                            end
                        end
                    end
                end

                --Move towards the air unit
                if oNearestEnemyToMidpoint then
                    bGivenOrderToGoToEnemyAirUnit = true
                    local tOrderPosition = oNearestEnemyToMidpoint:GetPosition()
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..' Will order every MAA to move to oNearestEnemyToMidpoint='..oNearestEnemyToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint)..' at position '..repru(oNearestEnemyToMidpoint:GetPosition()))
                        M28Utilities.DrawLocation(tOrderPosition)
                    end

                    for iUnit, oUnit in tMAAToAdvance do
                        M28Orders.IssueTrackedMove(oUnit, tOrderPosition, iResisueOrderDistanceHover, false, 'NMNA')
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Will do reprs of orders of the first unit in tMAAToAdvance, '..tMAAToAdvance[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tMAAToAdvance[1])..': '..reprs(tMAAToAdvance[1][M28Orders.reftiLastOrders])) end
                end
            end
        end

        if not(bGivenOrderToGoToEnemyAirUnit) and M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
            --Flag we have MAA without orders with a combat range, if relevant, so bombardment mode doesnt take them into account when deciding at what range to bombard targets
            if iBestRange > 20 then
                tWZTeamData[M28Map.refiMAACombatRangeWithoutTarget] = iBestRange
            end

            local tWZToReinforceModDistance = {}
            local iCurModDist
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': About to consider all other adjacent land zones to iWaterZone '..iWaterZone..' to reinforce with AA, reprs of tWZData[M28Map.subrefWZOtherWaterZones]='..reprs(tWZData[M28Map.subrefWZOtherWaterZones])) end

                local iAltWZ
                local bDontCheckInPlayableArea = not(M28Map.bIsCampaignMap)
                local iThresholdForAA = 100
                if M28Team.tTeamData[iTeam][M28Team.subrefbUseFrigatesAsScoutsByPond][iPond] and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] >= 2 then iThresholdForAA = 400 end
                for iEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                    iAltWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                    local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAltWZ]
                    if bDontCheckInPlayableArea or M28Conditions.IsLocationInPlayableArea(tAltWZData[M28Map.subrefMidpoint]) then
                        local tAltTeamWZData = tAltWZData[M28Map.subrefWZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to send MAA to assist alt WZ iAltWZ='..iAltWZ..'; tAltTeamWZData[M28Map.subrefWZMAAThreatWanted]='..(tAltTeamWZData[M28Map.subrefWZMAAThreatWanted] or 'nil')..'; tAltTeamWZData[M28Map.subrefLZOrWZThreatAllyGroundAA]='..(tAltTeamWZData[M28Map.subrefLZOrWZThreatAllyGroundAA] or 'nil')..'; Air to ground threat in this alt WZ='..(tAltTeamWZData[M28Map.refiEnemyAirToGroundThreat] or 'nil')..'; Our allied surface threat in the WZ considering MAA orders='..(tWZTeamData[M28Map.subrefWZThreatAlliedSurface] or 'nil')..'; subrefWZbCoreBase='..tostring(tAltTeamWZData[M28Map.subrefWZbCoreBase] or false)) end
                        if tAltTeamWZData[M28Map.subrefWZMAAThreatWanted] > tAltTeamWZData[M28Map.subrefLZOrWZThreatAllyGroundAA] and (tAltTeamWZData[M28Map.subrefWZMAAThreatWanted] > iThresholdForAA or M28Utilities.IsTableEmpty(tAltTeamWZData[M28Map.reftWZEnemyAirUnits]) == false) then
                            iCurModDist = tWZSubtable[M28Map.subrefWZAWZDistance]
                            if tAltTeamWZData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                                iCurModDist = iCurModDist - 200
                                if tAltTeamWZData[M28Map.subrefWZTThreatAllyCombatTotal] > 0 then iCurModDist = iCurModDist - 35 end
                            elseif (tAltTeamWZData[M28Map.refiEnemyAirOtherThreat] + tAltTeamWZData[M28Map.refiEnemyAirAAThreat]) > 45 then iCurModDist = iCurModDist - 100
                            end
                            if bConsiderAttackingStructuresInstead and iClosestZoneWithStructuresDist > iCurModDist and M28Utilities.IsTableEmpty(tAltTeamWZData[M28Map.reftWZEnemyAirUnits]) then iCurModDist = iCurModDist + 100 end
                            if M28Utilities.IsTableEmpty(tAltTeamWZData[M28Map.subreftoLZOrWZAlliedUnits]) then iCurModDist = iCurModDist + 100 end
                            if tAltTeamWZData[M28Map.subrefTThreatEnemyCombatTotal] > 6 then
                                iCurModDist = iCurModDist + 50
                                if tAltTeamWZData[M28Map.subrefWZTThreatAllyCombatTotal] == 0 then
                                    iCurModDist = iCurModDist + 150
                                elseif tAltTeamWZData[M28Map.subrefTThreatEnemyCombatTotal] > tAltTeamWZData[M28Map.subrefWZTThreatAllyCombatTotal] then
                                    iCurModDist = iCurModDist + 75
                                end
                            end
                            if tAltTeamWZData[M28Map.subrefWZTThreatAllyCombatTotal] < iThresholdForAA and M28Utilities.IsTableEmpty(tAltTeamWZData[M28Map.reftWZEnemyAirUnits]) and tAltTeamWZData[M28Map.subrefWZMAAThreatWanted] < iThresholdForAA * 2 then iCurModDist = iCurModDist + 100 end
                            if bDebugMessages == true then LOG(sFunctionRef..': Recording iAltWZ '..iAltWZ..' with a mod dist of '..iCurModDist) end
                            tWZToReinforceModDistance[iAltWZ] = iCurModDist
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to send MAA to assist alt WZ iAltWZ, but it isnt in playable area, iAltWZ='..iAltWZ..'; In playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAltWZData[M28Map.subrefMidpoint]))) end
                    end
                end
                if M28Utilities.IsTableEmpty(tWZToReinforceModDistance) == false then

                    for iWZ, iModDist in M28Utilities.SortTableByValue(tWZToReinforceModDistance, false) do
                        if bConsiderAttackingStructuresInstead and iModDist > iClosestZoneWithStructuresDist then
                            if M28Utilities.IsTableEmpty(tCombatAAByOrigRef) == false then
                                AttackWithCombatAA()

                                if M28Utilities.IsTableEmpty(tMAAToAdvance) then break end
                            end
                        end
                        --SendMAAToSupportWaterZone(tMAAToAdvance, iPond, iTeam, iWZToSupport, iMAAFactorAdjust, iStartingWZ)
                        SendMAAToSupportWaterZone(tMAAToAdvance, iPond, iTeam, iWZ, nil,        iWaterZone, tWZData, tCombatAAByOrigRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished sending MAA to support iWZ='..iWZ..'; Is table of MAA to advance empty yet='..tostring(M28Utilities.IsTableEmpty(tMAAToAdvance))) end
                        if M28Utilities.IsTableEmpty(tMAAToAdvance) then
                            break
                        end
                    end
                end

                if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                    --Do we have any combat AA units to attack with still?
                    if M28Utilities.IsTableEmpty(tCombatAAByOrigRef) == false then
                        AttackWithCombatAA()
                    end
                    if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                            for iEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                                iAltWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                                local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAltWZ]
                                if (bDontCheckIfInCampaignArea or M28Conditions.IsLocationInPlayableArea(tAltWZData[M28Map.subrefMidpoint])) then
                                    local tAltWZTeamData = tAltWZData[M28Map.subrefWZTeamData][iTeam]
                                    if M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false and tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] and tAltWZTeamData[M28Map.subrefLZOrWZThreatAllyGroundAA] < tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] * 0.4 then
                                        SendMAAToSupportWaterZone(tMAAToAdvance, iPond, iTeam, iAltWZ, nil, iWaterZone, tWZData)
                                    end
                                end
                            end
                        end
                    end
                end



                --Do we have any MAA remaining after sending MAA to any WZ wanting support?
                if bDebugMessages == true then LOG(sFunctionRef..': Finished sending MAA to WZs wanting support, is table empty of MAA still to advance='..tostring(M28Utilities.IsTableEmpty(tMAAToAdvance))) end
                if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                    local iFactorAdjust
                    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                        for iEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                            iAltWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                            local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAltWZ]
                            if (bDontCheckIfInCampaignArea or M28Conditions.IsLocationInPlayableArea(tAltWZData[M28Map.subrefMidpoint])) then
                                local tAltWZTeamData = tAltWZData[M28Map.subrefWZTeamData][iTeam]
                                if tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] > 10 or tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < 10 then
                                    iFactorAdjust = 2
                                    if tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then iFactorAdjust = 4 end
                                    SendMAAToSupportWaterZone(tMAAToAdvance, iPond, iTeam, iAltWZ, iFactorAdjust, iWaterZone, tWZData)
                                    if M28Utilities.IsTableEmpty(tMAAToAdvance) then break end
                                end
                            end
                        end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Still have spare MAA, will go to rally point') end
                for iUnit, oUnit in tMAAToAdvance do
                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, iResisueOrderDistanceHover, false, 'NBRtr'..iWaterZone)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SendMAAToSupportWaterZone(tMAAToAdvance, iPond, iTeam, iWZToSupport, iMAAFactorAdjust, iStartingWZ, tStartingWZData, tOptionalCombatAAByOrigRef)
    --Assigns MAA to the water zone up to the level at which the WZ doesnt want more MAA support, but increases the MAA wanted by the water zone by iMAAFactorAdjust (or 1 if not specified)
    --tOptionalCombatAAByOrigRef - if we have missile cruisers or cybran cruisers then want ot update this table if removing units from tMAAToAdvance
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SendMAAToSupportWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iResisueOrderDistanceHover = 20 --higher than normal

    local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWZToSupport]
    local tAltTeamWZData = tAltWZData[M28Map.subrefWZTeamData][iTeam]
    local tDistToTargetByRef = {}
    local tTargetPosition = tAltWZData[M28Map.subrefMidpoint]
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for iStartingWZ='..(iStartingWZ or 'nil')..' at time '..GetGameTimeSeconds()..'; iWZToSupport='..iWZToSupport..'; tAltTeamWZData[M28Map.subrefWZMAAThreatWanted]='..(tAltTeamWZData[M28Map.subrefWZMAAThreatWanted] or 'nil')) end
    if not(tAltTeamWZData[M28Map.subrefWZMAAThreatWanted]) or not(tAltTeamWZData[M28Map.subrefLZOrWZThreatAllyGroundAA]) then
        M28Utilities.ErrorHandler('Have nil MAA or AllyGroundAA threat for iWZToSupport='..(iWZToSupport or 'nil')..'; see log for more info')
        LOG(sFunctionRef..': MAA iTeam='..(iTeam or 'nil')..'; iPond='..(iPond or 'nil')..'; iWZToSupport='..(iWZToSupport or 'nil')..'; tAltTeamWZData[M28Map.subrefLZOrWZThreatAllyGroundAA]='..(tAltTeamWZData[M28Map.subrefLZOrWZThreatAllyGroundAA] or 'nil')..'; reprs of teamWZData='..reprs(tAltTeamWZData))
    else
        local iMAAThreatWanted = tAltTeamWZData[M28Map.subrefWZMAAThreatWanted] * (iMAAFactorAdjust or 1) - tAltTeamWZData[M28Map.subrefLZOrWZThreatAllyGroundAA]
        local tbRemovedMAAReferencesByRef = {}
        --If target is far away find an intermediary zone to go to, to reduce risk that order just gets cancelled
        local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(tStartingWZData[M28Map.subrefMidpoint], tTargetPosition)
        local tViaPoint
        if iDistToTarget >= 400 then
            local iAngleToTarget = M28Utilities.GetAngleFromAToB(tStartingWZData[M28Map.subrefMidpoint], tTargetPosition)
            local iCurSegX, iCurSegZ
            for iDistAbsMod = 0, 100, 10 do
                for iModFactor = -1, 1, 2 do
                    if iDistAbsMod > 0 or iModFactor == -1 then
                        local tPotentialViaPoint = M28Utilities.MoveInDirection(tStartingWZData[M28Map.subrefMidpoint], iAngleToTarget, 200 + iDistAbsMod * iModFactor, true, false, M28Map.bIsCampaignMap)
                        if M28Utilities.IsTableEmpty(tPotentialViaPoint) == false then
                            iCurSegX, iCurSegZ = M28Map.GetPathingSegmentFromPosition(tPotentialViaPoint)
                            if M28Map.tPondBySegment[iCurSegX][iCurSegZ] == iPond then
                                tViaPoint = {tPotentialViaPoint[1], tPotentialViaPoint[2], tPotentialViaPoint[3]}
                                break
                            end
                        end
                    end
                end
                if tViaPoint then break end
            end
        end
        for iUnit, oUnit in tMAAToAdvance do
            if oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iStartingWZ then
                tDistToTargetByRef[iUnit] = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetPosition)
            else
                --Unit is from a different zone - need to change the value of its assignment so it is considered for orders by the zone that it is part of
                oUnit[refiCurrentWZAssignmentValue] = 0
                tbRemovedMAAReferencesByRef[iUnit] = true
            end
        end

        for iUnitRef, iDistance in M28Utilities.SortTableByValue(tDistToTargetByRef, false) do
            if tViaPoint then
                M28Orders.IssueTrackedMove(tMAAToAdvance[iUnitRef], tViaPoint, iResisueOrderDistanceHover, false, 'NMViaEWZ'..iWZToSupport)
                if tMAAToAdvance[iUnitRef][M28Orders.refiOrderCount] <= 1 then
                    M28Orders.IssueTrackedMove(tMAAToAdvance[iUnitRef], tTargetPosition, iResisueOrderDistanceHover, true, 'NMViaPEWZ'..iWZToSupport)
                end
            else
                M28Orders.IssueTrackedMove(tMAAToAdvance[iUnitRef], tTargetPosition, iResisueOrderDistanceHover, false, 'NMVEWZ'..iWZToSupport)
            end
            iMAAThreatWanted = iMAAThreatWanted - M28UnitInfo.GetAirThreatLevel({ tMAAToAdvance[iUnitRef] }, false, false, true, false, false, false)
            tbRemovedMAAReferencesByRef[iUnitRef] = true
            if iMAAThreatWanted < 0 then break end
        end
        if M28Utilities.IsTableEmpty(tbRemovedMAAReferencesByRef) == false then
            --Remove any MAA that have given orders from tMAAToAdvance:
            local iRevisedIndex = 1
            local iTableSize = table.getn(tMAAToAdvance)

            for iOrigIndex=1, iTableSize do
                if tMAAToAdvance[iOrigIndex] then
                    if not(tbRemovedMAAReferencesByRef[iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                        --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                        if (iOrigIndex ~= iRevisedIndex) then
                            tMAAToAdvance[iRevisedIndex] = tMAAToAdvance[iOrigIndex];
                            tMAAToAdvance[iOrigIndex] = nil;
                            if tOptionalCombatAAByOrigRef[iOrigIndex] then
                                tOptionalCombatAAByOrigRef[iRevisedIndex] = tOptionalCombatAAByOrigRef[iOrigIndex]
                                tOptionalCombatAAByOrigRef[iOrigIndex] = nil
                            end
                        end
                        iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                    else
                        tMAAToAdvance[iOrigIndex] = nil;
                        if tOptionalCombatAAByOrigRef then tOptionalCombatAAByOrigRef[iOrigIndex] = nil end
                    end
                end
            end
            if iRevisedIndex < iTableSize then
                --table.setn(tMAAToAdvance, iRevisedIndex - 1)
                for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
                    table.remove(tMAAToAdvance, iRemovalEntry)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RetreatOtherUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tOtherUnitsToRetreat)
    local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
    for iUnit, oUnit in tOtherUnitsToRetreat do
        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 16, false, 'NOtRet', false)
    end
end

function ManageWaterZoneScouts(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tScouts, bWaterZoneContainsNonScouts)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageWaterZoneScouts'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    tWZTeamData[M28Map.refbWantLandScout] = false
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want a land scout at time='..GetGameTimeSeconds()..' for iPond '..iPond..'; iWaterZone='..iWaterZone..'; nemy combat threat='..tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Is table of land scouts traveling here empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTScoutsTravelingHere]))..'; Is table of scouts currently in this WZ empty='..tostring(M28Utilities.IsTableEmpty(tScouts))) end

    --Refresh list of scouts traveling here
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTScoutsTravelingHere]) == false then
        local iTableSize = table.getn(tWZTeamData[M28Map.subrefTScoutsTravelingHere])
        for iCurEntry = iTableSize, 1, -1 do
            if not(M28UnitInfo.IsUnitValid(tWZTeamData[M28Map.subrefTScoutsTravelingHere][iCurEntry])) then
                table.remove(tWZTeamData[M28Map.subrefTScoutsTravelingHere], iCurEntry)
            end
        end
    end

    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTScoutsTravelingHere]) then
        --Want a land scout for htis land zone, unless we already have one traveling here; if we have available land scouts then will change this flag back to false
        if not(tWZData[M28Map.subrefbPacifistArea]) then
            if not(M28Map.bIsCampaignMap) or M28Conditions.IsLocationInPlayableArea(tWZData[M28Map.subrefMidpoint]) then
                tWZTeamData[M28Map.refbWantLandScout] = true
                if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; We want to get a scout for this WZ '..(iWaterZone or 'nil')..' on pond '..(iPond or 'nil')) end
            end
        end
    elseif bDebugMessages == true then
        LOG(sFunctionRef..': We have scouts traveling to this WZ so wont flag it needs more scouts. Will list out traveling scouts')
        for iUnit, oUnit in tWZTeamData[M28Map.subrefTScoutsTravelingHere] do
            LOG(sFunctionRef..': iUnit='..iUnit..'; oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit)))
        end
    end

    --Do we have any land scouts that are available? if so then assign to an adjacent land zone if the adjacent zone wants scouts
    if M28Utilities.IsTableEmpty(tScouts) == false then
        local tAvailableScouts = {}
        local bCheckForEnemies = false
        local tEnemyUnitTablesToConsider = {}
        --Check for neemies if there are any in this or adjacent land zone
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
            --if tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 0 then
            table.insert(tEnemyUnitTablesToConsider, tWZTeamData[M28Map.subrefTEnemyUnits])
        end
        if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZOtherWaterZones]) == false then
            local iAdjWZ
            for _, tWZSubtable in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZOtherWaterZones] do
                iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                if bDebugMessages == true then LOG(sFunctionRef..': Checking if enemies in iAdjWZ='..iAdjWZ..'; enemy combat total='..M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal]) end
                if M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] > 0 then
                    table.insert(tEnemyUnitTablesToConsider, M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits])
                end
            end
        end
        if M28Utilities.IsTableEmpty(tEnemyUnitTablesToConsider) == false then bCheckForEnemies = true end

        local oEnemyToRunFrom
        local oPrevEnemyToRunFrom
        local iRunThreshold = 20 --If get this close to being in range of an enemy should try to run
        if bDebugMessages == true then LOG(sFunctionRef..': About to consider orders for scouts in this WZ, size of tScouts='..table.getn(tScouts)..'; bCheckForEnemies='..tostring(bCheckForEnemies)..'; Enemy combat total='..tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]) end
        local iCurDist
        for iScout, oScout in tScouts do
            if not(oScout.Dead) then --rare issue that can lead to errors
                if bCheckForEnemies then
                    oEnemyToRunFrom = nil
                    if oPrevEnemyToRunFrom and M28Utilities.GetDistanceBetweenPositions(oPrevEnemyToRunFrom[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) - (oPrevEnemyToRunFrom[M28UnitInfo.refiDFRange] or 0) <= iRunThreshold then
                        --Run from same enemy
                        oEnemyToRunFrom = oPrevEnemyToRunFrom
                    else
                        for iUnitTable, tUnitTable in tEnemyUnitTablesToConsider do
                            for iUnit, oUnit in tUnitTable do
                                if bDebugMessages == true then LOG(sFunctionRef..': Looking for enemy to run from for scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..', considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Unit position='..repru(oUnit:GetPosition())..'; Unit last known position='..repru(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Dist between last known position and scout='..M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition())..'; Unit range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; iRunThreshold='..iRunThreshold..'; Is distance within run threshold='..tostring(M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0) <= iRunThreshold)..'; bConsiderAttacking='..tostring(bConsiderAttacking)..'; Unit df range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Unit build range='..(oUnit:GetBlueprint().Economy.MaxBuildDistance or 'nil')) end
                                if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and not(oUnit == oPrevEnemyToRunFrom) then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0)
                                    if iCurDist <= iRunThreshold then
                                        oEnemyToRunFrom = oUnit
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to run from unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so will stop searching') end
                                        break
                                    elseif bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is too far away for us to run from it, will keep looking')
                                    end
                                    --Check if about to get in range of engineer that can reclaim us - have done +8 as lower values resulted in some cases in the engineer being able to reclaim the scout
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) <= 8 + (oUnit:GetBlueprint().Economy.MaxBuildDistance or 3) then
                                    oEnemyToRunFrom = oUnit
                                    break
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Do we have a valid enemy unit to run from='..tostring(M28UnitInfo.IsUnitValid(oEnemyToRunFrom))..'; ENemy ID if any='..(oEnemyToRunFrom.UnitId or 'nil')) end
                end
                if oEnemyToRunFrom then
                    tWZTeamData[M28Map.refbWantLandScout] = false
                    if bDebugMessages == true then LOG(sFunctionRef..': Want scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..' to run from oEnemyToRunFrom '..oEnemyToRunFrom.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToRunFrom)..' unless iti s a combat scout vs an engineer/mex in a low threat WZ in which case want it to attack the unit; WZ combat total='..tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Scout DF range='..(oScout[M28UnitInfo.refiDFRange] or 'nil')..'; Do we have a combat scout='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryCombatScout, oScout.UnitId))..'; Distance to nearest enemy='..M28Utilities.GetDistanceBetweenPositions(oEnemyToRunFrom:GetPosition(), oScout:GetPosition())) end
                    oPrevEnemyToRunFrom = oEnemyToRunFrom
                    local iPlateau = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oScout:GetPosition())
                    M28Land.RunFromEnemy(oScout, oEnemyToRunFrom, iTeam, iPlateau, 16)
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': No nearby enemy to run from, Considering if scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..' is available; refiWZToMoveTo='..repru(oScout[refiWZToMoveTo])) end
                    if oScout[refiWZToMoveTo] then
                        --Make scout available if its target WZ is this WZ
                        if oScout[refiWZToMoveTo] == iWaterZone then
                            --Clear this unit from list of traveling units, but dont make it available as want a slight delay, so want it to be available on the next cycle
                            if bDebugMessages == true then LOG(sFunctionRef..': Scout is traveling to this land zone and is here so will clear the trackers so next cycle it is shown as available') end
                            RemoveUnitFromListOfUnitsTravelingToWaterZone(oScout, iTeam)
                            tWZTeamData[M28Map.refbWantLandScout] = false
                        else
                            --Scout should be traveling to another land zone - if it has no orders then refresh them
                            local iTravelPond = M28Map.tiPondByWaterZone[oScout[refiWZToMoveTo]]
                            if bDebugMessages == true then LOG(sFunctionRef..': Scout should travel to another water zone so order it to travel there, iTravelPond='..(iTravelPond or 'nil')..'; oScout[refiWZToMoveTo]='..(oScout[refiWZToMoveTo] or 'nil')..'; oScout='..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..'; Midpoint of WZ to move to='..repru(M28Map.tPondDetails[iTravelPond][M28Map.subrefPondWaterZones][oScout[refiWZToMoveTo]][M28Map.subrefMidpoint])) end
                            M28Orders.IssueTrackedMove(oScout, M28Map.tPondDetails[iTravelPond][M28Map.subrefPondWaterZones][oScout[refiWZToMoveTo]][M28Map.subrefMidpoint], 16, false, 'TWZ'..oScout[refiWZToMoveTo])
                        end
                    elseif oScout[M28Land.reftiPlateauAndLZToMoveTo] then
                        --Scout is going to a land zone not a water zone
                        if bDebugMessages == true then LOG(sFunctionRef..': Scout should travel to another land zone so order it to travel there') end
                        M28Orders.IssueTrackedMove(oScout, M28Map.tAllPlateaus[oScout[M28Land.reftiPlateauAndLZToMoveTo][1]][M28Map.subrefPlateauLandZones][oScout[M28Land.reftiPlateauAndLZToMoveTo][2]][M28Map.subrefMidpoint], 16, false, 'NTLZ'..oScout[M28Land.reftiPlateauAndLZToMoveTo][2])
                    else
                        if oScout[M28Land.refoLandScoutTarget] and M28UnitInfo.IsUnitValid(oScout[M28Land.refoLandScoutTarget]) then
                            M28Orders.IssueTrackedMove(oScout, M28Utilities.MoveInDirection(oScout[M28Land.refoLandScoutTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(oScout[M28Land.refoLandScoutTarget]:GetPosition(), oScout:GetPosition()), 8, true, false, true), 1.5, false, 'ScWACU'..oScout[M28Land.refoLandScoutTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout[M28Land.refoLandScoutTarget]))
                        else
                            --Scout has no nearby enemies to run from, and isnt traveling to a water zone, so it should be available for use
                            if bDebugMessages == true then LOG(sFunctionRef..': Dont want to run or attack with scout and it isnt already assigned to another LZ or WZ so will aadd to table of available scouts, oScout='..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)) end
                            table.insert(tAvailableScouts, oScout)
                        end
                    end
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Is available scout table empty='..tostring(M28Utilities.IsTableEmpty(tAvailableScouts))) end

        if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
            --First assign any available scouts to adjacent water zones wanting scouts
            if bDebugMessages == true then LOG(sFunctionRef..': Will first allocate scouts to any adjacent land zones that want a scout. Is table of adj zones empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]))) end
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                local iAdjWZ
                for _, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                    iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                    local tWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Consideri niAdjWZ='..iAdjWZ..'; Does this WZ want land scout='..tostring(tWZTeamData[M28Map.refbWantLandScout] or false)..'; Is table of traveling scouts here empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTScoutsTravelingHere]))) end
                    if tWZTeamData[M28Map.refbWantLandScout] then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will send land scout '..tAvailableScouts[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tAvailableScouts[1])..' to go to adjacent water zone '..iAdjWZ) end

                        for iEntry = 1, 5 do
                            if M28UnitInfo.IsUnitValid(tAvailableScouts[iEntry]) then --redundancy for rare error
                                GetUnitToTravelToWaterZone(tAvailableScouts[iEntry], iPond, iAdjWZ, M28Map.subrefTScoutsTravelingHere)
                                tWZTeamData[M28Map.refbWantLandScout] = false
                                table.remove(tAvailableScouts, iEntry)
                                break
                            end
                        end
                        if M28Utilities.IsTableEmpty(tAvailableScouts) then break end
                    end
                end

            end
            if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
                tWZTeamData[M28Map.refbWantLandScout] = false
                --If we are here then we still have available land scouts; if we have ap atrol path then patrol; if we have a mex then go here, if we have an adjcent zone go here, otherwise move randomly if we have no orders
                for iScout, oScout in tAvailableScouts do
                    if not(oScout.Dead) then
                        if M28Utilities.IsTableEmpty(tWZData[M28Map.subreftPatrolPath]) == false then
                            --Patrol the water zone
                            M28Orders.PatrolPath(oScout, tWZData[M28Map.subreftPatrolPath], false, 'NSP'..iWaterZone)
                        else
                            --Do nothing if scout is moving as maybe it landed on a segment just out of the zone it shoudl have been in
                            if not(oScout:IsUnitState('Moving')) then
                                M28Orders.UpdateRecordedOrders(oScout)
                                if (oScout[M28Orders.refiOrderCount] or 0) == 0 then
                                    --Want ot get somewhere to move to as a backup
                                    --Do we have an adjacent WZ? If so move here
                                    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                                        GetUnitToTravelToWaterZone(tAvailableScouts[1], iPond, tWZData[M28Map.subrefWZOtherWaterZones][1][M28Map.subrefWZAWZRef], M28Map.subrefTScoutsTravelingHere)
                                    else
                                        --No adjacent WZs, and no mexes in this WZ, so just move randomly
                                        M28Orders.IssueTrackedMove(oScout, M28Utilities.MoveInDirection(oScout:GetPosition(), math.random(1, 360), math.random(10, 30), true, false, true), 10, false, 'NBackupRnd')
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetWaterZoneToRunTo(iTeam, iPond, iCurWaterZone, sPathing, tOptionalStartPosition, tOptionalEnemyPositionToRunFrom)
    --Returns cur WZ if no WZ to run to, otherwise returns the land zone we think is best to run to from iCurLandZone
    --tOptionalStartPosition - if nil then will use midpoint of iCurLandZone
    --tOptionalEnemyPositionToRunFrom - if this is specified, then will pick al ocation based on angle from the start position to the location vs the start position angle to the enemy position to run to (so we run in the opposite direction to the enemy position if the opposite direction WZ is safe)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetWaterZoneToRunTo'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': iTeam='..iTeam..'; iPond='..iPond..'; iCurWaterZone='..iCurWaterZone..'; sPathing='..sPathing..'; tOptionalStartPosition='..repru(tOptionalStartPosition)..'; tOptionalEnemyPositionToRunFrom='..repru(tOptionalEnemyPositionToRunFrom)) end

    local tWZShortlist = {}
    local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iCurWaterZone]
    --See if there are any adjacent water zones without enemy units
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
        for iEntry, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
            if M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] == 0 then
                table.insert(tWZShortlist, iAdjWZ)
            end
        end
    end
    if M28Utilities.IsTableEmpty(tWZShortlist) then
        --Nowhere to run to
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return iCurWaterZone
    else
        local tStartPoint = (tOptionalStartPosition or tWZData[M28Map.subrefMidpoint])
        local iPreferredWZRef
        if tOptionalEnemyPositionToRunFrom then
            --Go to the angle furthest in angle away from the nearest enemy
            local iAngleToEnemy = M28Utilities.GetAngleFromAToB(tStartPoint, tOptionalEnemyPositionToRunFrom)
            local iCurAngleDif
            local iHighestAngleDif = 0
            for _, iPossibleWZ in tWZShortlist do
                iCurAngleDif = M28Utilities.GetAngleDifference(iAngleToEnemy, M28Utilities.GetAngleFromAToB(tStartPoint, M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iPossibleWZ][M28Map.subrefMidpoint]))
                if iCurAngleDif > iHighestAngleDif then
                    iHighestAngleDif = iCurAngleDif
                    iPreferredWZRef = iPossibleWZ
                end
            end
        else
            --dont have angle to nearest enemy so just pick the closest land zone

            local iClosestWZDistance = 100000
            local iCurDist
            for _, iPossibleWZ in tWZShortlist do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering distance from tStartPoint to iPossibleWZ '..(iPossibleWZ or 'nil')..'; Midpoint of that WZ='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleWZ][M28Map.subrefMidpoint])..'; iCurDist='..(M28Utilities.GetTravelDistanceBetweenPositions(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleWZ][M28Map.subrefMidpoint], sPathing) or 'nil')) end
                iCurDist = M28Utilities.GetTravelDistanceBetweenPositions(tStartPoint, M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iPossibleWZ][M28Map.subrefMidpoint], sPathing)
                --Backup - if the built in pathfinding doesnt htink we can path there (e.g. we are by a cliff) then use straight line distance
                if not(iCurDist) then iCurDist = M28Utilities.GetDistanceBetweenPositions(tStartPoint, M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iPossibleWZ][M28Map.subrefMidpoint]) + 30 end

                if iCurDist < iClosestWZDistance then
                    iClosestWZDistance = iCurDist
                    iPreferredWZRef = iPossibleWZ
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return (iPreferredWZRef or iCurWaterZone)
    end

end

function UpdateSonarCoverageForDestroyedSonar(oSonar)
    --Only track for water zones
    if M28Utilities.IsTableEmpty(oSonar[reftiSonarWaterZonesCoveredByTeam]) == false then
        for iTeam, tSonarData in oSonar[reftiSonarWaterZonesCoveredByTeam] do
            --local aiBrain = oSonar:GetAIBrain()
            --local iTeam = aiBrain.M28Team
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            if aiBrain then
                local iPond
                for iEntry, iWaterZone in tSonarData do
                    iPond = M28Map.tiPondByWaterZone[iWaterZone]
                    local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
                    local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                    if tWZTeamData[M28Map.refoBestSonar] == oSonar then
                        tWZTeamData[M28Map.refoBestSonar] = nil
                        tWZTeamData[M28Map.refiSonarCoverage] = 0
                        local tNearbySonar = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategorySonar, tWZData[M28Map.subrefMidpoint], 600, 'Ally')
                        local iCurIntelRange
                        local iBestIntelRange = 0
                        local oBestSonar
                        local iCurDist
                        local oBP
                        if M28Utilities.IsTableEmpty(tNearbySonar) == false then
                            for iUnit, oUnit in tNearbySonar do
                                oBP = oUnit:GetBlueprint()
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tWZData[M28Map.subrefMidpoint])
                                iCurIntelRange = (oBP.Intel.SonarRadius or 0) - iCurDist
                                if iCurIntelRange > iBestIntelRange then
                                    iBestIntelRange = iCurIntelRange
                                    oBestSonar = oUnit
                                end
                            end
                        end
                        if oBestSonar then
                            tWZTeamData[M28Map.refoBestSonar] = oBestSonar
                            tWZTeamData[M28Map.refiSonarCoverage] = iBestIntelRange
                            if not(oBestSonar[reftiSonarWaterZonesCoveredByTeam]) then oBestSonar[reftiSonarWaterZonesCoveredByTeam] = {} end
                            if not(oBestSonar[reftiSonarWaterZonesCoveredByTeam][iTeam]) then oBestSonar[reftiSonarWaterZonesCoveredByTeam][iTeam] = {} end
                            table.insert(oBestSonar[reftiSonarWaterZonesCoveredByTeam][iTeam], iWaterZone)
                        end
                    end
                end
            end
        end
    end
end

function UpdateZoneIntelForSonar(oSonar)
    --If just built Sonar then want to update all land zones for the team to indicate the intel coverage
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateZoneIntelForSonar'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iTeam = oSonar:GetAIBrain().M28Team
    if bDebugMessages == true then LOG(sFunctionRef..': Just built Sonar '..oSonar.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSonar)..' owned by '..oSonar:GetAIBrain().Nickname..' with M28Team '..iTeam..'; is the table of active m28 brains for this team empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        if not(oSonar['M28UpdatedIntel']) then
            oSonar['M28UpdatedIntel'] = true
            local oBP = oSonar:GetBlueprint()
            local iIntelRange = (oBP.Intel.SonarRadius or 0)
            local iCurIntelRange
            if bDebugMessages == true then LOG(sFunctionRef..': Sonar intel range='..iIntelRange) end
            if iIntelRange > 0 then
                --Update water zones
                for iPond, tPondSubtable in M28Map.tPondDetails do
                    if M28Utilities.IsTableEmpty(tPondSubtable[M28Map.subrefPondWaterZones]) == false then
                        for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do

                            local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering ater zone '..iWaterZone..' with sonar coverage='..tWZTeamData[M28Map.refiSonarCoverage]..'; iIntelRange='..iIntelRange) end
                            if tWZTeamData[M28Map.refiSonarCoverage] < iIntelRange then
                                iCurIntelRange = iIntelRange - M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oSonar:GetPosition())
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering iPond '..iPond..' Water zone '..iWaterZone..'; iCurIntelRange factoring in distance='..iCurIntelRange..'; Distance='..M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oSonar:GetPosition())..'; WZ current Sonar coverage='..tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiSonarCoverage]) end
                                if iCurIntelRange > tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiSonarCoverage] then
                                    --First remove this WZ from the existing (worse) Sonar if there was one
                                    if M28UnitInfo.IsUnitValid(tWZTeamData[M28Map.refoBestSonar]) then
                                        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.refoBestSonar][reftiSonarWaterZonesCoveredByTeam][iTeam]) == false then
                                            for iEntry, iRecordedWaterZone in tWZTeamData[M28Map.refoBestSonar][reftiSonarWaterZonesCoveredByTeam][iTeam] do
                                                if iRecordedWaterZone == iWaterZone then
                                                    table.remove(tWZTeamData[M28Map.refoBestSonar][reftiSonarWaterZonesCoveredByTeam][iTeam], iEntry)
                                                    break
                                                end
                                            end
                                        end
                                    end
                                    --Now assign this WZ to this Sonar as providing the best coverage
                                    tWZTeamData[M28Map.refiSonarCoverage] = iCurIntelRange
                                    tWZTeamData[M28Map.refoBestSonar] = oSonar
                                    if not(oSonar[reftiSonarWaterZonesCoveredByTeam]) then oSonar[reftiSonarWaterZonesCoveredByTeam] = {} end
                                    if not(oSonar[reftiSonarWaterZonesCoveredByTeam][iTeam]) then oSonar[reftiSonarWaterZonesCoveredByTeam][iTeam] = {} end
                                    table.insert(oSonar[reftiSonarWaterZonesCoveredByTeam][iTeam], iWaterZone)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished udpating for the new intel range, iWaterZone='..iWaterZone..'; tWZTeamData[M28Map.refiSonarCoverage]='..tWZTeamData[M28Map.refiSonarCoverage]) end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function DelayedCheckIfShouldSubmerge(oJustBuilt)
    --Call via fork thread just after unit is built
    WaitSeconds(3)
    if M28UnitInfo.IsUnitValid(oJustBuilt) then
        local bWantToBeUnderwater
        if EntityCategoryContains(M28UnitInfo.refCategorySeraphimDestroyer + categories.uas0401, oJustBuilt.UnitId) then
            bWantToBeUnderwater = false
        else
            bWantToBeUnderwater = true
        end
        if not(M28UnitInfo.IsUnitUnderwater(oJustBuilt) == bWantToBeUnderwater) then
            M28UnitInfo.ToggleUnitDiveOrSurfaceStatus(oJustBuilt)
        end
    end
end

function GetMinDFDistanceForShotFromWaterToHitUnit(aiBrain, tWZMidpoint, iPond, oTarget, iMaxDist)
    local iBestDist = 10000
    local iBaseAngle = M28Utilities.GetAngleFromAToB(oTarget:GetPosition(), tWZMidpoint)
    local tShotEndPosition = oTarget:GetPosition()
    local iTargetWZ
    tShotEndPosition[2] = tShotEndPosition[2] + math.max(0, ((oTarget:GetBlueprint().SizeY or 0.5) - 0.5 * 0.7))

    for iAngleAdjust = 0, 270, 90 do
        for iDFDistAdjust = 12, math.max(12, math.floor((iMaxDist / 6) * 6)), 6 do
            local tPossibleWaterPosition = M28Utilities.MoveInDirection(oTarget:GetPosition(), iBaseAngle + iAngleAdjust, iDFDistAdjust, true, true, false)
            if tPossibleWaterPosition and NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tPossibleWaterPosition) == iPond then
                local tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                iTargetWZ = M28Map.GetWaterZoneFromPosition(tShotStartPosition)
                if M28Map.tiPondByWaterZone[iTargetWZ] == iPond then
                    if not(M28Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, 1)) then
                        iBestDist = iDFDistAdjust
                        break
                    end
                end
            end
        end
        if iBestDist <= iMaxDist then break end
    end
    if iBestDist > iMaxDist then iTargetWZ = nil end

    return iBestDist, iTargetWZ
end

function GetDFShotBlockedLocationForBuildingAndPond(oUnit, iPond)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetDFShotBlockedLocationForBuildingAndPond'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(oUnit[reftBlockedShotLocationByPond][iPond]) then
        if not(oUnit[reftBlockedShotLocationByPond]) then oUnit[reftBlockedShotLocationByPond] = {} end
        local oDummyBrain = oUnit:GetAIBrain() --in case want to try the brain terrain blocking function later
        local tBasePosition = oUnit:GetPosition()
        local iAngleInterval = 360 / 24
        local tShotEndPosition = {tBasePosition[1], tBasePosition[2] + math.max(0, ((oUnit:GetBlueprint().SizeY or 0.5) - 0.5 * 0.7)), tBasePosition[3]}
        if bDebugMessages == true then LOG(sFunctionRef..': Looking for non shot blocked location for oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at position '..repru(oUnit:GetPosition())) end
        local bHaveMatch = false
        for iDFDist = 5, 150, 5 do
            for iCurAngle = iAngleInterval, 360, iAngleInterval do
                local tPossibleWaterPosition = M28Utilities.MoveInDirection(tBasePosition, iCurAngle, iDFDist, true, true, false)
                if bDebugMessages == true then
                    LOG(sFunctionRef..': iDFDist='..iDFDist..'; iCurAngle='..iCurAngle..'; tPossibleWaterPosition='..repru(tPossibleWaterPosition))
                    if tPossibleWaterPosition then LOG(sFunctionRef..': Terrain label for tPossibleWaterPosition='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tPossibleWaterPosition) or 'nil')..'; iPond='..iPond) end
                end
                if tPossibleWaterPosition and NavUtils.GetTerrainLabel(M28Map.refPathingTypeNavy, tPossibleWaterPosition) == iPond then
                    local tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                    if bDebugMessages == true then LOG(sFunctionRef..': Is line blocked='..tostring(M28Logic.IsLineBlocked(oDummyBrain, tShotStartPosition, tShotEndPosition, 1))..'; tShotStartPosition='..repru(tShotStartPosition)) end
                    if not(M28Logic.IsLineBlocked(oDummyBrain, tShotStartPosition, tShotEndPosition, 1)) then
                        oUnit[reftBlockedShotLocationByPond][iPond] = {tPossibleWaterPosition[1], tPossibleWaterPosition[2], tPossibleWaterPosition[3]}
                        bHaveMatch = true
                        break
                    end
                end
            end
            if bHaveMatch then break end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oUnit[reftBlockedShotLocationByPond][iPond]
end

function RefreshRaidingNavalLocations(iFactoryWaterZone, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshRaidingNavalLocations'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Find the land zone nearest to us with mexes that we think we can hit
    local iLandZoneToTarget
    local iPlateauToTarget
    local iStartPond = M28Map.tiPondByWaterZone[iFactoryWaterZone]
    local tStartWZData = M28Map.tPondDetails[iStartPond][M28Map.subrefPondWaterZones][iFactoryWaterZone]
    local tStartWZTeamData = tStartWZData[M28Map.subrefWZTeamData][iTeam]
    local iRangeWanted, iWZForShot, iAltMinRangeRequired, iSecondAltMinRangeRequired, iSecondWZForShot
    tStartWZTeamData[M28Map.refoLastRaidTarget] = nil
    if bDebugMessages == true then LOG(sFunctionRef..': Near start, iStartPond='..iStartPond..'; iFactoryWaterZone='..iFactoryWaterZone..'; iTeam='..iTeam..'; time since last had bombardment mode='..(M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBombardmentModeByPond][iStartPond] or 'nil')..'; Time='..GetGameTimeSeconds()) end
    local iAltWZForBombardment
    if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBombardmentModeByPond][iStartPond] or -100) >= 30 then --dont try raiding if we have been in bombardment mode recently
        local tbPlateauAndLandZonesConsidered = {}
        local tAcceptableRangesByTech = {[0]=26,[1]=26,[2]=60,[3]=110, [4]=110}
        local tiMaxThreatByTech = {[0]=300,[1]=300,[2]=1000,[3]=2000,[4]=2000}
        local tiMinStructureValueWanted = {[0]=300,[1]=300,[2]=500,[3]=1000,[4]=1000} --if no mexes then will still attack if have this much S value
        local iStructureValueWanted = tiMinStructureValueWanted[(tStartWZTeamData[M28Map.refiRaidTechLevel] or 0)]
        local iHighestAcceptableRange = tAcceptableRangesByTech[(tStartWZTeamData[M28Map.refiRaidTechLevel] or 0)]
        local iMaxNavalThreat = tiMaxThreatByTech[(tStartWZTeamData[M28Map.refiRaidTechLevel] or 0)]
        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
        function GetAdjacentZoneToTarget(iWaterZone)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering land zones adjacent to iWaterZone '..iWaterZone..'; Pond for this zone='..M28Map.tiPondByWaterZone[iWaterZone]..'; iStartPond='..iStartPond) end
            if M28Map.tiPondByWaterZone[iWaterZone] == iStartPond then
                local tCurWZData = M28Map.tPondDetails[iStartPond][M28Map.subrefPondWaterZones][iWaterZone]
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of adjacent land zones empty='..tostring(M28Utilities.IsTableEmpty(tCurWZData[M28Map.subrefAdjacentLandZones]))) end
                if M28Utilities.IsTableEmpty(tCurWZData[M28Map.subrefAdjacentLandZones]) == false then
                    local tCurWZTeamData = tCurWZData[M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy combat total in this WZ='..(tCurWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)..'; iMaxNavalThreat='..iMaxNavalThreat) end
                    if (tCurWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) <= iMaxNavalThreat then
                        for iAdjEntry, tAdjSubtable in tCurWZData[M28Map.subrefAdjacentLandZones] do
                            local iCurPlateau = tAdjSubtable[M28Map.subrefWPlatAndLZNumber][1]
                            local iCurLandZone = tAdjSubtable[M28Map.subrefWPlatAndLZNumber][2]
                            if not(tbPlateauAndLandZonesConsidered[iCurPlateau][iCurLandZone]) then
                                if not(tbPlateauAndLandZonesConsidered[iCurPlateau]) then tbPlateauAndLandZonesConsidered[iCurPlateau] = {} end
                                tbPlateauAndLandZonesConsidered[iCurPlateau][iCurLandZone] = true
                                local tCurLZData = M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLandZone]
                                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tCurLZData[M28Map.subrefMidpoint]) then
                                    local tCurLZTeamData = tCurLZData[M28Map.subrefLZTeamData][iTeam]
                                    local iZoneEnemyStructureMassValue = 0
                                    local tZoneStructures
                                    if M28Utilities.IsTableEmpty(tCurLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                                        tZoneStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tCurLZTeamData[M28Map.subrefTEnemyUnits])
                                        if M28Utilities.IsTableEmpty(tZoneStructures) == false then
                                            iZoneEnemyStructureMassValue = M28UnitInfo.GetMassCostOfUnits(tZoneStructures, true)
                                            local tMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tZoneStructures)
                                            if M28Utilities.IsTableEmpty(tMexes) == false then
                                                iZoneEnemyStructureMassValue = iZoneEnemyStructureMassValue + 300 * table.getn(tMexes)
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to target plateau '..iCurPlateau..'; LZ'..iCurLandZone..'; Friendly LZ S value='..(tCurLZTeamData[M28Map.subrefLZSValue] or 0)..'; Is table of mex locations empty='..tostring(M28Utilities.IsTableEmpty(tCurLZData[M28Map.subrefLZMexLocations]))..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tCurLZTeamData[M28Map.subrefTEnemyUnits]))..'; iZoneEnemyStructureMassValue='..iZoneEnemyStructureMassValue..'; iStructureValueWanted='..iStructureValueWanted) end
                                    if iZoneEnemyStructureMassValue >= 10 and iStructureValueWanted then
                                        --Check enemy has mexes or high S value
                                        if iZoneEnemyStructureMassValue >= iStructureValueWanted or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryPD, tCurLZTeamData[M28Map.subrefTEnemyUnits])) == false then
                                            --Check the enemy range isn't too much
                                            local iShortestRangeRequired = math.max((tCurLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0), (tCurLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0), (tCurLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0))
                                            if bDebugMessages == true then LOG(sFunctionRef..': iShortestRangeRequired='..iShortestRangeRequired..'; Best mobile DF range='..tCurLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]..'; Best indirect='..tCurLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange]..'; Best structureDF='..tCurLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange]..'; iHighestAcceptableRange='..iHighestAcceptableRange) end
                                            if iShortestRangeRequired <= iHighestAcceptableRange then
                                                --Determine the water zone path to get here, and the enemy water threat along that path
                                                local tWZPath = GetWaterZonePathToWaterOrAdjacentLandZone(iFactoryWaterZone, iCurPlateau, iCurLandZone)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Is  tWZPath empty='..tostring(M28Utilities.IsTableEmpty(tWZPath))) end
                                                if M28Utilities.IsTableEmpty(tWZPath) == false then
                                                    local iEnemyThreat = (tCurWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                                                    local bPathInPlayableArea = true
                                                    for iEntry, iPathZone in tWZPath do
                                                        local tWZPathData = M28Map.tPondDetails[iStartPond][M28Map.subrefPondWaterZones][iPathZone]
                                                        local tWZPathTeamData = tWZPathData[M28Map.subrefWZTeamData][iTeam]
                                                        iEnemyThreat = iEnemyThreat + (tWZPathTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                                                        if iEnemyThreat > iMaxNavalThreat then break end
                                                        if not(bDontCheckPlayableArea) and not(M28Conditions.IsLocationInPlayableArea(tWZPathData[M28Map.subrefMidpoint])) then
                                                            bPathInPlayableArea = false
                                                            break
                                                        end
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..'; iEnemyThreat='..iEnemyThreat..'; iMaxNavalThreat='..iMaxNavalThreat) end
                                                    if iEnemyThreat <= iMaxNavalThreat and bPathInPlayableArea then
                                                        --No significant water threat, consider the closest enemy building to the last water zone path entry, and the max range required to attack.  To keep things simple, for now will only consider the closest unit and if shot is blocked for it (rather than every unit)
                                                        local tEnemyStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tCurLZTeamData[M28Map.subrefTEnemyUnits])
                                                        if M28Conditions.IsTableOfUnitsStillValid(tEnemyStructures) then
                                                            --Want both the closest and furthest unti since on some islands units might be at the rear of the island so furthest from our water zone, yet close to water, hence still worth considering as a target
                                                            local oClosestEnemyStructure -- = M28Utilities.GetNearestUnit(tEnemyStructures, tCurWZData[M28Map.subrefMidpoint])
                                                            local oFurthestEnemyStructure, iCurDist
                                                            local iClosestDist = 10000
                                                            local iFurthestDist = 0
                                                            for iUnit, oUnit in tEnemyStructures do
                                                                iCurDist = M28Utilities.GetDistanceBetweenPositions(tCurWZData[M28Map.subrefMidpoint], oUnit:GetPosition())
                                                                if iCurDist < iClosestDist then
                                                                    oClosestEnemyStructure = oUnit
                                                                    iClosestDist = iCurDist
                                                                end
                                                                if iCurDist > iFurthestDist then
                                                                    iFurthestDist = iCurDist
                                                                    oFurthestEnemyStructure = oUnit
                                                                end
                                                            end
                                                            if M28UnitInfo.IsUnitValid(oClosestEnemyStructure) and (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(oClosestEnemyStructure:GetPosition())) then
                                                                iWZForShot = nil
                                                                if oClosestEnemyStructure == oFurthestEnemyStructure then
                                                                    iAltMinRangeRequired, iWZForShot = GetMinDFDistanceForShotFromWaterToHitUnit(aiBrain, tCurWZData[M28Map.subrefMidpoint], iStartPond, oClosestEnemyStructure, iHighestAcceptableRange)
                                                                    iShortestRangeRequired = math.max(iShortestRangeRequired, iAltMinRangeRequired)
                                                                else
                                                                    iAltMinRangeRequired, iWZForShot = GetMinDFDistanceForShotFromWaterToHitUnit(aiBrain, tCurWZData[M28Map.subrefMidpoint], iStartPond, oClosestEnemyStructure, iHighestAcceptableRange)
                                                                    iSecondAltMinRangeRequired, iSecondWZForShot = GetMinDFDistanceForShotFromWaterToHitUnit(aiBrain, tCurWZData[M28Map.subrefMidpoint], iStartPond, oFurthestEnemyStructure, iHighestAcceptableRange)
                                                                    if iWZForShot == iSecondWZForShot then
                                                                        --Want the lowest range of the two options
                                                                        iShortestRangeRequired = math.max(iShortestRangeRequired, math.min(iAltMinRangeRequired, iSecondAltMinRangeRequired))
                                                                    elseif (iAltMinRangeRequired <= 150 and iSecondAltMinRangeRequired > 150) then
                                                                        --Want the first choice
                                                                        iShortestRangeRequired = math.max(iShortestRangeRequired, iAltMinRangeRequired)
                                                                    elseif (iSecondAltMinRangeRequired <= 150 and iAltMinRangeRequired > 150) then
                                                                        iWZForShot = iSecondWZForShot
                                                                        iShortestRangeRequired = math.max(iShortestRangeRequired, iSecondAltMinRangeRequired)
                                                                    end
                                                                end
                                                                if bDebugMessages == true then LOG(sFunctionRef..': oClosestEnemyStructure='..oClosestEnemyStructure.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemyStructure)..'; iShortestRangeRequired='..iShortestRangeRequired..'; iHighestAcceptableRange='..iHighestAcceptableRange..'; oFurthestEnemyStructure='..oFurthestEnemyStructure.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFurthestEnemyStructure)) end
                                                                if iShortestRangeRequired <= iHighestAcceptableRange then
                                                                    tStartWZTeamData[M28Map.refoLastRaidTarget] = oClosestEnemyStructure
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Have a valid target for raiding, iWZForShot='..iWZForShot) end
                                                                    return iCurPlateau, iCurLandZone, iShortestRangeRequired, iWZForShot
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        iPlateauToTarget, iLandZoneToTarget, iRangeWanted, iAltWZForBombardment = GetAdjacentZoneToTarget(iFactoryWaterZone)
        if not(iLandZoneToTarget) then
            if M28Utilities.IsTableEmpty(tStartWZData[M28Map.subrefWZOtherWaterZones]) == false then
                for iEntry, tSubtable in tStartWZData[M28Map.subrefWZOtherWaterZones] do
                    iPlateauToTarget, iLandZoneToTarget, iRangeWanted, iAltWZForBombardment = GetAdjacentZoneToTarget(tSubtable[M28Map.subrefWZAWZRef])
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering land zones adjacent to WZ '..tSubtable[M28Map.subrefWZAWZRef]..'; iLandZoneToTarget='..(iLandZoneToTarget or 'nil')..'; iPlateauToTarget='..(iPlateauToTarget or 'nil')) end
                    if iLandZoneToTarget then break end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iPlateauToTarget='..(iPlateauToTarget or 'nil')..'; iLandZoneToTarget='..(iLandZoneToTarget or 'nil')..'; iAltWZForBombardment='..(iAltWZForBombardment or 'nil')..'; ') end
    if iPlateauToTarget then
        tStartWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone] = {iPlateauToTarget, iLandZoneToTarget}
        tStartWZTeamData[M28Map.refiMinRangeRaidingZone] = iRangeWanted
        tStartWZTeamData[M28Map.refiRaidWZForBombardment] = iAltWZForBombardment
    else
        tStartWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone] = nil
        tStartWZTeamData[M28Map.refiMinRangeRaidingZone] = nil
        tStartWZTeamData[M28Map.refiRaidWZForBombardment] = nil
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetWaterZonePathToWaterOrAdjacentLandZone(iStartWaterZone, iTargetPlateauOrZero, iTargetLandOrWaterZone)
    --Returns the water zones to travel across (excluding iStartWaterZone) to get from iStartWaterZone to either hte target water zone, or (if it's a land zone) the closest water zone adjacent to the target land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetWaterZonePathToWaterOrAdjacentLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iStartPond = M28Map.tiPondByWaterZone[iStartWaterZone]
    local tStartWZData = M28Map.tPondDetails[iStartPond][M28Map.subrefPondWaterZones][iStartWaterZone]
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iStartWaterZone='..iStartWaterZone..'; iTargetPlateauOrZero='..iTargetPlateauOrZero..'; iTargetLandOrWaterZone='..iTargetLandOrWaterZone..'; Is pathing table empty='..tostring(M28Utilities.IsTableEmpty(tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone][iTargetPlateauOrZero][iTargetLandOrWaterZone]))) end
    if not(tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone][iTargetPlateauOrZero][iTargetLandOrWaterZone]) then
        if not(tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone][iTargetPlateauOrZero]) then
            if not(tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone]) then tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone] = {} end
            tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone][iTargetPlateauOrZero] = {}
        end
        tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone][iTargetPlateauOrZero][iTargetLandOrWaterZone] = {}
        local bValidLocation = false
        local iTargetWaterZone --if targetin land zone, this is the closest water zone in the same pond
        --Is the target in the same pond, or adjacent to a zone in the same pond?
        if iTargetPlateauOrZero == 0 then
            if M28Map.tiPondByWaterZone[iTargetLandOrWaterZone] == iStartPond then
                bValidLocation = true
                iTargetWaterZone = iTargetLandOrWaterZone
            end
        else
            --Dealing with a land zone, check for adjacent water zones
            local tTargetLZData = M28Map.tAllPlateaus[iTargetPlateauOrZero][M28Map.subrefPlateauLandZones][iTargetLandOrWaterZone]
            if M28Utilities.IsTableEmpty(tTargetLZData[M28Map.subrefAdjacentWaterZones]) == false then
                local iClosestAdjWZDist = 10000
                local iCurDist
                for iEntry, tSubtable in tTargetLZData[M28Map.subrefAdjacentWaterZones] do
                    if M28Map.tiPondByWaterZone[tSubtable[M28Map.subrefAWZRef]] == iStartPond then
                        iCurDist = tSubtable[M28Map.subrefAWZDistance]
                        if iCurDist < iClosestAdjWZDist then
                            iClosestAdjWZDist = iCurDist
                            iTargetWaterZone = tSubtable[M28Map.subrefAWZRef]
                            bValidLocation = true
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bValidLocation='..tostring(bValidLocation or false)..'; iTargetWaterZone='..(iTargetWaterZone or 'nil')) end
        if bValidLocation and iTargetWaterZone then
            local tTargetWZData = M28Map.tPondDetails[iStartPond][M28Map.subrefPondWaterZones][iTargetWaterZone]
            local tFullPath, iPathSize, iDistance = NavUtils.PathTo(M28Map.refPathingTypeNavy, tStartWZData[M28Map.subrefMidpoint], tTargetWZData[M28Map.subrefMidpoint], nil)
            local tbZoneConsidered = {[iStartWaterZone] = true, [iTargetWaterZone] = true}
            local iCurWZ
            if M28Utilities.IsTableEmpty(tFullPath) == false then
                for iEntry, tPosition in tFullPath do
                    iCurWZ = M28Map.GetWaterZoneFromPosition(tPosition)
                    if not(tbZoneConsidered[iCurWZ]) then
                        tbZoneConsidered[iCurWZ] = true
                        table.insert(tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone][iTargetPlateauOrZero][iTargetLandOrWaterZone], iCurWZ)
                    end
                end
            end
            table.insert(tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone][iTargetPlateauOrZero][iTargetLandOrWaterZone], iTargetWaterZone)
            if bDebugMessages == true then LOG(sFunctionRef..': Finished recording path for iTargetLandOrWaterZone='..iTargetLandOrWaterZone..'; Path='..repru(tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone][iTargetPlateauOrZero][iTargetLandOrWaterZone])) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tStartWZData[M28Map.subrefWZManualNavalPathToOtherPlateauOrZeroAndZone][iTargetPlateauOrZero][iTargetLandOrWaterZone]
end

function CheckWaterZoneForRaiders(iWaterZone, tWZTeamData, iFactoryWaterZone, tFactoryWZTeamData, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckWaterZoneForRaiders'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
        local tPotentialRaiders = EntityCategoryFilterDown(M28UnitInfo.refCategoryBombardment, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of potentail raiders empty='..tostring(M28Utilities.IsTableEmpty(tPotentialRaiders))..' for iWaterZone='..iWaterZone) end
        if M28Conditions.IsTableOfUnitsStillValid(tPotentialRaiders) then
            for iRaider, oRaider in tPotentialRaiders do
                if oRaider[refiWZOfFactory] == iFactoryWaterZone and not(oRaider[refbActiveRaider]) and oRaider[M28UnitInfo.refiCombatRange] >= tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone] then
                    AddUnitToRaiders(oRaider, iFactoryWaterZone, iTeam, tFactoryWZTeamData)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageWaterZoneRaiders(iFactoryWaterZone, iTeam, tFactoryWZData, tFactoryWZTeamData)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageWaterZoneRaiders'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(tFactoryWZTeamData[M28Map.refbActiveRaiderLogic]) then
        tFactoryWZTeamData[M28Map.refbActiveRaiderLogic] = true
        local iPrevRangeWanted = 10000 --tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone]
        local iPrevRaidTargetPlateau --= tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][1]
        local iPrevRaidTargetZone --= tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][2]
        local tWZRaidingPath
        local iPond = M28Map.tiPondByWaterZone[iFactoryWaterZone]

        while M28Conditions.IsTableOfUnitsStillValid(tFactoryWZTeamData[M28Map.reftoWZRaiders]) do
            --First check we have a valid location to raid, and all our raiders have sufficient range:
            if bDebugMessages == true then LOG(sFunctionRef..': Start of loop for iFactoryWaterZone '..iFactoryWaterZone..', closest plateau and land zone for raiding='..repru(tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone])..'; Are there enemis in wz adjacent to factory='..tostring(tFactoryWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ])..'; Time='..GetGameTimeSeconds()..'; Is raid target valid='..tostring(M28UnitInfo.IsUnitValid(tFactoryWZTeamData[M28Map.refoLastRaidTarget]))..'; Raid target='..(tFactoryWZTeamData[M28Map.refoLastRaidTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tFactoryWZTeamData[M28Map.refoLastRaidTarget]) or 'nil')..' Range wanted='..(tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone] or 'nil')..'; refiRaidWZForBombardment='..(tFactoryWZTeamData[M28Map.refiRaidWZForBombardment] or 'nil')) end

            if tFactoryWZTeamData[M28Map.refoLastRaidTarget] and not(M28UnitInfo.IsUnitValid(tFactoryWZTeamData[M28Map.refoLastRaidTarget])) then
                tFactoryWZTeamData[M28Map.refoLastRaidTarget] = nil
                RefreshRaidingNavalLocations(iFactoryWaterZone, iTeam)
                if bDebugMessages == true then LOG(sFunctionRef..': Finished refreshing naval locations') end
            elseif not(tFactoryWZTeamData[M28Map.refiRaidWZForBombardment]) then
                RefreshRaidingNavalLocations(iFactoryWaterZone, iTeam)
            end

            if M28Utilities.IsTableEmpty(tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone]) or tFactoryWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] then
                --Clear raiders
                local tRaiderTable = tFactoryWZTeamData[M28Map.reftoWZRaiders]
                for iCurRaider = table.getn(tFactoryWZTeamData[M28Map.reftoWZRaiders]), 1, -1 do
                    if bDebugMessages == true then LOG(sFunctionRef..'; Removing unit '..(tFactoryWZTeamData[M28Map.reftoWZRaiders][iCurRaider].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tFactoryWZTeamData[M28Map.reftoWZRaiders][iCurRaider]) or 'nil')..' from table of active raiders') end
                    RemoveUnitFromRaiders(tFactoryWZTeamData[M28Map.reftoWZRaiders], iCurRaider)
                end
                tFactoryWZTeamData[M28Map.reftoWZRaiders] = { }
                if bDebugMessages == true then LOG(sFunctionRef..': Cleared table of raiders') end
                break
            elseif tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone] > iPrevRangeWanted then
                --Remove any units with too little range
                for iCurRaider = table.getn(tFactoryWZTeamData[M28Map.reftoWZRaiders]), 1, -1 do
                    if tFactoryWZTeamData[M28Map.reftoWZRaiders][iCurRaider][M28UnitInfo.refiCombatRange] < tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone] then
                        RemoveUnitFromRaiders(tFactoryWZTeamData[M28Map.reftoWZRaiders], iCurRaider)
                    end
                end
                if M28Utilities.IsTableEmpty(tFactoryWZTeamData[M28Map.reftoWZRaiders]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Revmoed raiders with insufficient range, tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone]='..tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone]..'; now have no raiders that are suiable') end
                    break
                end
            elseif (tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone] or 10000) < iPrevRangeWanted then
                --Consider adding units from around the factory that used to be raiders if they now have sufficient range
                if bDebugMessages == true then LOG(sFunctionRef..': Will search around original water zone '..(iFactoryWaterZone or 'nil')..' for raiders with a range of at least '..(tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone] or 'nil')) end
                CheckWaterZoneForRaiders(iFactoryWaterZone, tFactoryWZTeamData, iFactoryWaterZone, tFactoryWZTeamData, iTeam)
                if M28Utilities.IsTableEmpty(tFactoryWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                    for iEntry, iAdjWZ in tFactoryWZData[M28Map.subrefWZAdjacentWaterZones] do
                        local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                        CheckWaterZoneForRaiders(iAdjWZ, tAdjWZTeamData, iFactoryWaterZone, tFactoryWZTeamData, iTeam)
                    end
                end
            end

            --Update the raiding path from the orig naval factory to the target
            if not(iPrevRaidTargetZone == tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][2]) or not(iPrevRaidTargetPlateau == tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][1]) then
                tWZRaidingPath = nil
                iPrevRaidTargetPlateau = tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][1]
                iPrevRaidTargetZone = tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][2]
            end
            iPrevRangeWanted = tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone]
            if not(tWZRaidingPath) then
                tWZRaidingPath = GetWaterZonePathToWaterOrAdjacentLandZone(iFactoryWaterZone, tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][1], tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][2])
            end
            if bDebugMessages == true then LOG(sFunctionRef..': tWZRaidingPath='..repru(tWZRaidingPath)..'; Is table of raiders empty='..tostring(M28Utilities.IsTableEmpty(tFactoryWZTeamData[M28Map.reftoWZRaiders]))..'; Are there dangerous enemies in an adjacent WZ='..tostring((tFactoryWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]))..'; Time='..GetGameTimeSeconds()..'; tFactoryWZTeamData[M28Map.refiRaidWZForBombardment]='..(tFactoryWZTeamData[M28Map.refiRaidWZForBombardment] or 'nil')) end
            if tWZRaidingPath then
                --Next check the total enemy naval threat from the base WZ to the raid destination or if we have enemies in the base WZ; if it is too much, then free up these units temporarily to help with normal combat duties
                if bDebugMessages == true then LOG(sFunctionRef..': is table of raiders empty='..tostring(M28Utilities.IsTableEmpty(tFactoryWZTeamData[M28Map.reftoWZRaiders]))) end
                if M28Utilities.IsTableEmpty(tFactoryWZTeamData[M28Map.reftoWZRaiders]) == false then
                    --Record every water zone along the path; then for any unit not in one of these zones, figure out the closest such water zone (with a bonus for those closer to the destination) and travel there
                    local tbWaterZonesInPath = {[iFactoryWaterZone] = true}
                    local toUnitsToAttack = {}

                    for iEntry, iZone in tWZRaidingPath do
                        table.insert(tbWaterZonesInPath, iZone)
                    end
                    local iLastZone = tFactoryWZTeamData[M28Map.refiRaidWZForBombardment] --tWZRaidingPath[table.getn(tWZRaidingPath)]
                    local iCurWZ
                    local iTargetWZPond = M28Map.tiPondByWaterZone[iLastZone]
                    local tTargetWZData = M28Map.tPondDetails[iTargetWZPond][M28Map.subrefPondWaterZones][iLastZone]

                    for iCurRaider = table.getn(tFactoryWZTeamData[M28Map.reftoWZRaiders]), 1, -1 do
                        local oUnit = tFactoryWZTeamData[M28Map.reftoWZRaiders][iCurRaider]
                        iCurWZ = M28Map.GetWaterZoneFromPosition(oUnit:GetPosition())
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering orders for raider oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurWZ='..(iCurWZ or 'nil')..'; iLastZone='..iLastZone..'; Active raider='..tostring(oUnit[refbActiveRaider])) end
                        if not(iCurWZ) then
                            M28Orders.UpdateRecordedOrders(oUnit)
                            if (oUnit[M28Orders.refiOrderCount] or 0) == 0 then
                                RemoveUnitFromRaiders(tFactoryWZTeamData[M28Map.reftoWZRaiders], iCurRaider)
                            end
                        else
                            if iCurWZ == iLastZone then
                                --Are at the target, can try to attack the enemy
                                table.insert(toUnitsToAttack, oUnit)
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Have unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' who is currently in water zone '..iCurWZ..' and wants to get to WZ '..iLastZone..' so will have it move to that midpoint. oRaider[refbActiveRaider]='..tostring(oUnit[refbActiveRaider] or false)) end
                                --Move towards the last zone, attack-move if shot not blocked
                                if oUnit[M28UnitInfo.refbLastShotBlocked] and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) >= 10 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100) < 6 then
                                    M28Orders.IssueTrackedAttackMove(oUnit, tTargetWZData[M28Map.subrefMidpoint], 10, false, 'RaidMT'..iLastZone, false)
                                else
                                    M28Orders.IssueTrackedAggressiveMove(oUnit, tTargetWZData[M28Map.subrefMidpoint], 10, false, 'RaidAMT'..iLastZone, false)
                                end
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(toUnitsToAttack) == false then
                        local tbPlateauAndZones = {}
                        tbPlateauAndZones[tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][1]] = {}
                        tbPlateauAndZones[tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][1]][tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone][2]] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Have '..table.getn(toUnitsToAttack)..' units which will assign bombardment actions for the water zone '..iLastZone..'; tFactoryWZTeamData[M28Map.refiRaidWZForBombardment]='..(tFactoryWZTeamData[M28Map.refiRaidWZForBombardment] or 'nil')) end
                        --AssignBombardmentActions(tWZData,     iPond,      iWaterZone,     iTeam, tPotentialBombardmentUnits, tbOptionalPlateauAndLandZonesToConsider,                  iOptionalRaidBaseWZ)
                        AssignBombardmentActions(tTargetWZData, iPond, iTargetWZPond, iTeam, toUnitsToAttack,           tbPlateauAndZones, tFactoryWZTeamData[M28Map.refiRaidWZForBombardment])
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': have no units that are in the final zone to attack with') end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': end of loop, will wait 1 second') end

            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    end
    tFactoryWZTeamData[M28Map.refbActiveRaiderLogic] = false
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RemoveUnitFromRaiders(tWZRaiderTable, iCurEntry)
    --Cycle through the table in reverse order to avoid issues
    tWZRaiderTable[iCurEntry][refbActiveRaider] = false
    table.remove(tWZRaiderTable, iCurEntry)
end

function AddUnitToRaiders(oRaider, iFactoryWaterZone, iTeam, tFactoryWZTeamData)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddUnitToRaiders'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    oRaider[refbActiveRaider] = true
    oRaider[refiWZOfFactory] = iFactoryWaterZone --redundancy (are already setting when unit is created)
    if not(tFactoryWZTeamData[M28Map.reftoWZRaiders]) then
        tFactoryWZTeamData[M28Map.reftoWZRaiders] = {}
    end
    table.insert(tFactoryWZTeamData[M28Map.reftoWZRaiders], oRaider)
    if bDebugMessages == true then
        LOG(sFunctionRef..': Just added raider '..oRaider.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRaider)..' to table of raiders for iFactoryWaterZone='..iFactoryWaterZone..'; Time='..GetGameTimeSeconds())
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderAssigningRaidingNavalUnit(oRaider, oFactory)
    --First refresh potential raiding (mini bombardment) locations
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderAssigningRaidingNavalUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iFactoryWaterZone = M28Map.GetWaterZoneFromPosition(oFactory:GetPosition())
    if iFactoryWaterZone then
        local tFactoryWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iFactoryWaterZone]][M28Map.subrefPondWaterZones][iFactoryWaterZone]
        local iTeam = oFactory:GetAIBrain().M28Team
        local tFactoryWZTeamData = tFactoryWZData[M28Map.subrefWZTeamData][iTeam]
        RefreshRaidingNavalLocations(iFactoryWaterZone, iTeam)
        local iLifetimeCount = M28UnitInfo.GetUnitLifetimeCount(oRaider)
        --Assign every 4th unit to bombardment if we have somewhere to bombard
        if math.floor(iLifetimeCount / 4) == iLifetimeCount / 4 then
            tFactoryWZTeamData[M28Map.refiRaidTechLevel] = math.max((tFactoryWZTeamData[M28Map.refiRaidTechLevel] or 0), M28UnitInfo.GetUnitTechLevel(oRaider))
            oRaider[refiWZOfFactory] = iFactoryWaterZone --so this unit will be considered for raiding later if its range becomes sufficient
            --Does this unit have sufficient range to be a bombardment unit?
            --[[refiClosestRaidingPlateauAndLandZone = 'WZClRLZ' --returns {Plateau, LandZone} if htere is a land zone we want to consider as a raiding target
            --            refiMinRangeRaidingZone = 'WZClRng' --returns the min range we want raiding naval units to have to join the raid on the land zone--]]
            if M28Utilities.IsTableEmpty(tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone]) == false and oRaider[M28UnitInfo.refiCombatRange] >= tFactoryWZTeamData[M28Map.refiMinRangeRaidingZone] then
                AddUnitToRaiders(oRaider, iFactoryWaterZone, iTeam, tFactoryWZTeamData)
            end
        end
        if not(tFactoryWZTeamData[M28Map.refbActiveRaiderLogic]) and M28Utilities.IsTableEmpty(tFactoryWZTeamData[M28Map.refiClosestRaidingPlateauAndLandZone]) == false then --check units in this zone in case we have overlooked any (e.g. due to logic previously resetting)
            CheckWaterZoneForRaiders(iFactoryWaterZone, tFactoryWZTeamData, iFactoryWaterZone, tFactoryWZTeamData, iTeam)
        end

        ForkThread(ManageWaterZoneRaiders, iFactoryWaterZone, iTeam, tFactoryWZData, tFactoryWZTeamData) --So we can pick up any former raiders that are now available for raiding
        --Forked above to avoid affecting profiling

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetNearestEnemyUnitsAndUpdateUnitTables(iPond, iWaterZone, tWZData, tWZTeamData, iTeam, tEnemySurfaceUnits, tEnemyNonHoverUnits, bOnlyConsiderDoublyAdjacentZones)
    --Done due to local variable limit due ot error ablut too many upvalues - moving into a separate function doesnt actually help with that, but have left separated as makes the main navla combat code a bit tidier and probably makes it a bit easier to read parts of this, especially as have added commented out code below on doing table variables
    --bOnlyConsiderDoublyAdjacentZones - if this is true then will ignore units in this and adjacent zones
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNearestEnemyUnitsAndUpdateUnitTables'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    refiMaxDist = 100000
    if bOnlyConsiderDoublyAdjacentZones then refiMaxDist = 200 end
    refiClosestDist = refiMaxDist
    refiClosestSurfaceDist = refiMaxDist
    refiClosestNonHoverDist = refiMaxDist

    local oNearestEnemyToFriendlyBase, oNearestEnemySurfaceToFriendlyBase, oNearestEnemyNonHoverToFriendlyBase

    refiOverallClosestNonHoverRangeDist = refiMaxDist
    local oOverallClosestNonHoverRangeUnit



    --local iClosestToMidpointDist = 100000
    refiClosestSurfaceToMidpointDist = refiMaxDist
    refiClosestNonHoverToMidpointDist = refiMaxDist
    refiClosestSurfaceToMidpointByRange = refiMaxDist
    local oClosestSurfaceToMidpointByRange
    refiClosestNonHoverToMidpointByRange = refiMaxDist
    local oClosestNonHoverToMidpointByRange
    local oClosestSurfaceToMidpointByDist
    local oClosestNonHoverToMidpointByDist
    refiOverallClosestSurfaceRangeDist = refiMaxDist
    local oOverallClosestSurfaceRangeUnit


    function ConsiderIfUnitIsClosest(oUnit, bDealingWithAdjZone)
        --bDontIncludeAdjZoneUnitHere - for if we wil lbe including only the closest unit using the variables

        --This records the closest unit for surface; and separately hover; units.  It gets reset for each new (adjacent) zone being considered so we end up including the closest in every adj zone.  The main zone includes slighlty more than this
        if bDebugMessages == true then LOG(sFunctionRef..': Considering oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bDealingWithAdjZone='..tostring(bDealingWithAdjZone or false)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; bOnlyConsiderDoublyAdjacentZones='..tostring(bOnlyConsiderDoublyAdjacentZones or false)..'; Unit mass cost='..(oUnit[M28UnitInfo.refiUnitMassCost] or 'nil')) end
        if (not(bDealingWithAdjZone) or M28UnitInfo.IsUnitValid(oUnit)) and (not(bOnlyConsiderDoublyAdjacentZones) or (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) >= 250) then
            if bDebugMessages == true then LOG(sFunctionRef..': Is this a campaign map='..tostring(M28Map.bIsCampaignMap)..'; Is unit in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(oUnit:GetPosition()))) end
            if not(M28Map.bIsCampaignMap) or M28Conditions.IsLocationInPlayableArea(oUnit:GetPosition()) then
                --Changed in v229 to use actual position, since the 'updatnearestunit' logic goes off this; meaning if we refer to the last known position here we can end up in the scenario where say a destroyer infront of a cruiser is spotted; we retreat; they both advance; and we think only the cruiser has advanced (due to firing), when a player would recognise they would likely advance together
                refiCurDist = M28Utilities.GetDistanceBetweenPositions(tWZTeamData[M28Map.reftClosestFriendlyBase], oUnit:GetPosition())
                refiCurRangeAdjustedDist = refiCurDist - (oUnit[M28UnitInfo.refiCombatRange] or 0)
                refiCurAntiNavyRangeAdjustedDist = refiCurDist - (oUnit[M28UnitInfo.refiAntiNavyRange] or 0)
                refiCurMidpointDist = -1
                if bDebugMessages == true then LOG(sFunctionRef..': ConsiderIfUnitIsClosest: oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; refiCurDist='..refiCurDist..'; Actual dist based on actual position='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tWZTeamData[M28Map.reftClosestFriendlyBase])..'; oUnit[M28UnitInfo.refiCombatRange]='..(oUnit[M28UnitInfo.refiCombatRange] or 'nil')..'; refiClosestDist ='..refiClosestDist..'; refiCurRangeAdjustedDist='..refiCurRangeAdjustedDist..'; refiClosestNonHoverToMidpointByRange='..refiClosestNonHoverToMidpointByRange..'; bDealingWithAdjZone='..tostring(bDealingWithAdjZone or false)) end
                if refiCurDist < refiClosestDist then
                    --[[if bDealingWithAdjZone then
                        iCurMidpointDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                        if iCurMidpointDist <= iClosestToMidpointDist then
                            iClosestDist = iCurDist
                            oNearestEnemyToFriendlyBase = oUnit
                            iClosestToMidpointDist = iCurMidpointDist
                        end
                    else--]]
                    refiClosestDist = refiCurDist
                    oNearestEnemyToFriendlyBase = oUnit
                    --end
                end

                if not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                    if refiCurRangeAdjustedDist < refiClosestSurfaceToMidpointByRange then
                        refiClosestSurfaceToMidpointByRange = refiCurRangeAdjustedDist
                        oClosestSurfaceToMidpointByRange = oUnit
                        if refiCurRangeAdjustedDist < refiOverallClosestSurfaceRangeDist then
                            refiOverallClosestSurfaceRangeDist = refiCurRangeAdjustedDist
                            oOverallClosestSurfaceRangeUnit = oUnit
                        end
                    end

                    if refiCurDist < refiClosestSurfaceDist then
                        if bDealingWithAdjZone then
                            if refiCurMidpointDist < 0 then refiCurMidpointDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) end
                            if refiCurMidpointDist <= refiClosestSurfaceToMidpointDist then
                                refiClosestSurfaceDist = refiCurDist
                                oNearestEnemySurfaceToFriendlyBase = oUnit
                                refiClosestSurfaceToMidpointDist = refiCurMidpointDist
                                oClosestSurfaceToMidpointByDist = oUnit --means it gets added to tEnemySurfaceUnits later on)
                            end
                        else
                            refiClosestSurfaceDist = refiCurDist
                            oNearestEnemySurfaceToFriendlyBase = oUnit
                            --Dont bother with updating oClosestSurfaceToMidpointByDist
                            table.insert(tEnemySurfaceUnits, oUnit)
                        end
                    elseif not(bDealingWithAdjZone) then
                        if oClosestSurfaceToMidpointByRange == oUnit then
                            table.insert(tEnemySurfaceUnits, oUnit)
                        end
                    end
                end
                if not(EntityCategoryContains(categories.HOVER, oUnit.UnitId)) then
                    --If looking at non-hover then most likely it is for subs/antinavy attacks
                    if refiCurAntiNavyRangeAdjustedDist < refiClosestNonHoverToMidpointByRange then
                        refiClosestNonHoverToMidpointByRange = refiCurAntiNavyRangeAdjustedDist
                        oClosestNonHoverToMidpointByRange = oUnit
                        if refiCurAntiNavyRangeAdjustedDist < refiOverallClosestNonHoverRangeDist then
                            refiOverallClosestNonHoverRangeDist = refiCurAntiNavyRangeAdjustedDist
                            oOverallClosestNonHoverRangeUnit = oUnit
                        end
                    end

                    if refiCurDist < refiClosestNonHoverDist then
                        if bDealingWithAdjZone then
                            if refiCurMidpointDist < 0 then refiCurMidpointDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) end
                            if refiCurMidpointDist <= refiClosestNonHoverToMidpointDist then
                                refiClosestNonHoverDist = refiCurDist
                                oNearestEnemyNonHoverToFriendlyBase = oUnit
                                refiClosestNonHoverToMidpointDist = refiCurMidpointDist
                                oClosestNonHoverToMidpointByDist = oUnit --means it gets added to tEnemyNonHover units later on
                                if bDebugMessages == true then LOG(sFunctionRef..': Updating oClosestNonHoverToMidpointByDist to be oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                            elseif bDebugMessages == true then LOG(sFunctionRef..': Dealing with adj zone, we arent closer than refiClosestNonHoverToMidpointDist, refiCurMidpointDist='..refiCurMidpointDist..'; refiClosestNonHoverToMidpointDist='..refiClosestNonHoverToMidpointDist)
                            end
                        else
                            refiClosestNonHoverDist = refiCurDist
                            oNearestEnemyNonHoverToFriendlyBase = oUnit
                            table.insert(tEnemyNonHoverUnits, oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Recording unit against enemy nonhoverunits and as the nearest enemy to friendly base, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                        end
                    elseif not(bDealingWithAdjZone) then
                        if oClosestNonHoverToMidpointByRange == oUnit then
                            table.insert(tEnemyNonHoverUnits, oUnit)
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..(refiCurDist or 'nil')..'; iClosestDist='..refiClosestDist..'; iClosestSurfaceDist='..refiClosestSurfaceDist..'; iClosestNonHoverDist='..refiClosestNonHoverDist..'; In playable area='..tostring(M28Conditions.IsLocationInPlayableArea(oUnit:GetPosition()))..'; iCurRangeAdjustedDist='..refiCurRangeAdjustedDist..'; iClosestSurfaceToMidpointByRange='..refiClosestSurfaceToMidpointByRange..'; iClosestNonHoverToMidpointByRange='..refiClosestNonHoverToMidpointByRange) end
    end

    function ConsiderUnitsInZone(tCurWZTeamData, bDealingWithAdjZone)
        if bDebugMessages == true then LOG(sFunctionRef..': ConsiderUnitsInZone: Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tCurWZTeamData[M28Map.subrefTEnemyUnits]))) end
        if M28Utilities.IsTableEmpty(tCurWZTeamData[M28Map.subrefTEnemyUnits]) == false then
            refiClosestSurfaceDist = refiMaxDist
            refiClosestSurfaceToMidpointDist = refiMaxDist
            refiClosestNonHoverToMidpointDist = refiMaxDist
            refiClosestSurfaceToMidpointByRange = refiMaxDist
            refiClosestNonHoverToMidpointByRange = refiMaxDist
            oClosestSurfaceToMidpointByRange = nil
            oClosestNonHoverToMidpointByRange = nil
            oClosestSurfaceToMidpointByDist = nil
            oClosestNonHoverToMidpointByDist = nil

            for iUnit, oUnit in tCurWZTeamData[M28Map.subrefTEnemyUnits] do
                if not(oUnit.Dead) then
                    ConsiderIfUnitIsClosest(oUnit, bDealingWithAdjZone)
                end
            end
            --Add closest unit from adj zone (by dist, and if different by range) to tables of enemy surface/non hover units:
            if bDebugMessages == true then LOG(sFunctionRef..': Finished considering units in zone; bDealingWithAdjZone='..tostring(bDealingWithAdjZone or false)..'; oClosestSurfaceToMidpointByDist='..(oClosestSurfaceToMidpointByDist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestSurfaceToMidpointByDist) or 'nil')..'; oClosestSurfaceToMidpointByRange='..(oClosestSurfaceToMidpointByRange.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestSurfaceToMidpointByRange) or 'nil')..'; oClosestNonHoverToMidpointByDist='..(oClosestNonHoverToMidpointByDist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestNonHoverToMidpointByDist) or 'nil')..'; oClosestNonHoverToMidpointByRange='..(oClosestNonHoverToMidpointByRange.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestNonHoverToMidpointByRange) or 'nil')) end
            if oClosestSurfaceToMidpointByDist then table.insert(tEnemySurfaceUnits, oClosestSurfaceToMidpointByDist) end
            if oClosestSurfaceToMidpointByRange and not(oClosestSurfaceToMidpointByRange == oClosestSurfaceToMidpointByDist) then table.insert(tEnemySurfaceUnits, oClosestSurfaceToMidpointByRange) end
            if oClosestNonHoverToMidpointByDist then table.insert(tEnemyNonHoverUnits, oClosestNonHoverToMidpointByDist) end
            if oClosestNonHoverToMidpointByRange and not(oClosestNonHoverToMidpointByRange == oClosestNonHoverToMidpointByDist) then table.insert(tEnemyNonHoverUnits, oClosestNonHoverToMidpointByRange) end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy units in this zone, bOnlyConsiderDoublyAdjacentZones='..tostring(bOnlyConsiderDoublyAdjacentZones or false)..'; Is tWZTeamData[M28Map.subrefTEnemyUnits] empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]))) end
    if not(bOnlyConsiderDoublyAdjacentZones) then
        if bDebugMessages == true then LOG(sFunctionRef..': About to call considerunitsinzone') end
        ConsiderUnitsInZone(tWZTeamData, false)
    end

    --(wasn't sure why the below lines were here, commented out given new approach for adj zones to include even if not the closest)
    --[[
    if oNearestEnemyToFriendlyBase then iClosestToMidpointDist = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tWZData[M28Map.subrefMidpoint]) end
    if oNearestEnemySurfaceToFriendlyBase then iClosestSurfaceToMidpointDist = M28Utilities.GetDistanceBetweenPositions(oNearestEnemySurfaceToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tWZData[M28Map.subrefMidpoint]) end
    if oNearestEnemyNonHoverToFriendlyBase then iClosestNonHoverToMidpointDist = M28Utilities.GetDistanceBetweenPositions(oNearestEnemyNonHoverToFriendlyBase[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tWZData[M28Map.subrefMidpoint]) end
    --]]

    --if not(oNearestEnemyToFriendlyBase) then --v128 - removed condition as want to include closest unit in each adjacent water zone or else we can end up going in range of it
    local tbDoublyAdjacentZonesConsidered = {}
    tbDoublyAdjacentZonesConsidered[iWaterZone] = true
    for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
        --iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]
        if not(bOnlyConsiderDoublyAdjacentZones) then
            if bDebugMessages == true then LOG(sFunctionRef..': About to consider iAdjWZ='..iAdjWZ) end
            ConsiderUnitsInZone(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam], true)
        else
            tbDoublyAdjacentZonesConsidered[iAdjWZ] = true --dont want to consider adj zone
            local tAdjWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
            local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
            if tAdjWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then
                for _, iSecondAdjWZ in  tAdjWZData[M28Map.subrefWZAdjacentWaterZones] do
                    if not(tbDoublyAdjacentZonesConsidered[iSecondAdjWZ]) then
                        tbDoublyAdjacentZonesConsidered[iSecondAdjWZ] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': About to consider iSecondAdjWZ='..iSecondAdjWZ) end
                        ConsiderUnitsInZone(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iSecondAdjWZ][M28Map.subrefWZTeamData][iTeam], true)
                    end
                end
            end
        end
    end

    --Update closest unit variables
    oNearestEnemySurfaceToFriendlyBase = oOverallClosestSurfaceRangeUnit
    oNearestEnemyNonHoverToFriendlyBase = oOverallClosestNonHoverRangeUnit
    if refiOverallClosestNonHoverRangeDist < refiOverallClosestSurfaceRangeDist then
        oNearestEnemyToFriendlyBase = oNearestEnemyNonHoverToFriendlyBase
    else
        oNearestEnemyToFriendlyBase = oNearestEnemySurfaceToFriendlyBase
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return refiClosestDist, refiClosestSurfaceDist, refiClosestNonHoverDist, oNearestEnemyToFriendlyBase, oNearestEnemySurfaceToFriendlyBase, oNearestEnemyNonHoverToFriendlyBase

    --[[Example of drafted (untested) alt approach which might need to consider if need to free up more variables with above:
    function GetTableValueRef(bDistToEnemyBase, bDistToMidpoint, bDistLessRangeToMidpoint, bSurface, bDistNotUnit, bOverall)
    if bOverall then
        if bDistToEnemyBase then
            if bSurface then
                if bDistNotUnit then
                    return '411'
                else
                    return '412'
                end
            else
                if bDistNotUnit then
                    return '421'
                else
                    return '422'
                end
            end
        elseif bDistToMidpoint then
            if bSurface then
                if bDistNotUnit then
                    return '511'
                else
                    return '512'
                end
            else
                if bDistNotUnit then
                    return '521'
                else
                    return '522'
                end
            end
        elseif bDistLessRangeToMidpoint then
            if bSurface then
                if bDistNotUnit then
                    return '611'
                else
                    return '612'
                end
            else
                if bDistNotUnit then
                    return '621'
                else
                    return '622'
                end
            end
        else
            M28Utilities.ErrorHandler('Invalid reference request')
            return '000'
        end
    else
        if bDistToEnemyBase then
            if bSurface then
                if bDistNotUnit then
                    return '111'
                else
                    return '112'
                end
            else
                if bDistNotUnit then
                    return '121'
                else
                    return '122'
                end
            end
        elseif bDistToMidpoint then
            if bSurface then
                if bDistNotUnit then
                    return '211'
                else
                    return '212'
                end
            else
                if bDistNotUnit then
                    return '221'
                else
                    return '222'
                end
            end
        elseif bDistLessRangeToMidpoint then
            if bSurface then
                if bDistNotUnit then
                    return '311'
                else
                    return '312'
                end
            else
                if bDistNotUnit then
                    return '321'
                else
                    return '322'
                end
            end
        else
            M28Utilities.ErrorHandler('Invalid reference request')
            return '000'
        end
    end
end
local tClosestUnitVariables = {['111']=100000,['112']=nil,['121']=100000,['122']=nil,['211']=100000,['212']=nil,['221']=100000,['222']=nil,['311']=100000,['312']=nil,['321']=100000,['322']=nil, ['411']=100000,['412']=nil,['421']=100000,['422']=nil,['511']=100000,['512']=nil,['521']=100000,['522']=nil,['611']=100000,['612']=nil,['621']=100000,['622']=nil}
--]]

end

function MonitorNavalUnitToSeeIfStuck(oUnit, iStartWaterZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MonitorNavalUnitToSeeIfStuck'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if not(oUnit.Dead) then
        oUnit[refbSpecialStuckTrackingActive] = true
        --Monitor the unit position for the next 50s (before wiping the information on the recent positions to reduce risk of memory issues)
        local iCycleDelayInSeconds = 5
        local iCurCycle = 0
        local iMaxCycles = 10
        local iTeam = oUnit:GetAIBrain().M28Team
        ForkThread(M28Building.MonitorUnitRecentPositions, oUnit, iCycleDelayInSeconds, iMaxCycles)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(iCycleDelayInSeconds * 3 + 0.1) --0.1 more than 3*5s to ensure we will have recorded recent positions
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        local bAppearToBeMoving
        if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop for unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Time since last weapon event='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0)..'; Time since last tried retreating='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeLastTriedRetreating] or 0)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; iStartWaterZone='..iStartWaterZone..'; Cur time='..GetGameTimeSeconds()) end
        while M28UnitInfo.IsUnitValid(oUnit) and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastWeaponEvent] or 0) >= 30 and GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeLastTriedRetreating] or 0) >= 30 do
            --Check we are trying to move to another zone
            local tTargetOrderPosition = oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]
            if bDebugMessages == true then LOG(sFunctionRef..': Is tTargetOrderPosition empty='..tostring(M28Utilities.IsTableEmpty(tTargetOrderPosition))..'; WZ of targetorderposition='..(M28Map.GetWaterZoneFromPosition(tTargetOrderPosition) or 'nil')..'; iStartWaterZone='..iStartWaterZone) end
            if M28Utilities.IsTableEmpty(tTargetOrderPosition) == false and not(M28Map.GetWaterZoneFromPosition(tTargetOrderPosition) == iStartWaterZone) then
                bAppearToBeMoving = false
                --If we havent moved at all then start special micro logic to try and move
                if M28Utilities.IsTableEmpty( oUnit[M28UnitInfo.reftRecentUnitPositions]) == false then
                    for iRecentPosition, tRecentPosition in oUnit[M28UnitInfo.reftRecentUnitPositions] do
                        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRecentPosition) >= 1 then
                            bAppearToBeMoving = true
                            break
                        end
                    end
                end
                --If we have moved recently, and are now in a different zone, then stop tracking
                iCurCycle = iCurCycle + 1
                if bDebugMessages == true then LOG(sFunctionRef..': Towards end of loop, iCurCycle='..iCurCycle..'; bAppearToBeMoving='..tostring(bAppearToBeMoving)..'; oUnit[M28UnitInfo.refbSpecialMicroActive]='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive] or false)..'; WZ unit is in='..(oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] or 'nil')..'; iStartWaterZone='..iStartWaterZone) end
                if iCurCycle >= iMaxCycles then break end
                if not(bAppearToBeMoving) and not(oUnit[M28UnitInfo.refbSpecialMicroActive]) then
                    ForkThread(MoveStuckNavalUnitToNearbyZone, oUnit, iStartWaterZone)
                elseif bAppearToBeMoving and not(iStartWaterZone == oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam]) then
                    break
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(iCycleDelayInSeconds)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        oUnit[refbSpecialStuckTrackingActive] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MoveStuckNavalUnitToNearbyZone(oUnit, iStartWaterZone)
    --Gets unit to move along a path to an adjacent water zone
    --Should only be calling if we have a unit htat isnt in combat, is trying to move to another zone, but hasnt moved position for a while
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MoveStuckNavalUnitToNearbyZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(oUnit.Dead) then
        M28Micro.TrackTemporaryUnitMicro(oUnit, 0, nil, true)
        local iTeam = oUnit:GetAIBrain().M28Team
        local iPond = M28Map.tiPondByWaterZone[iStartWaterZone]
        local tStartWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iStartWaterZone]
        local tStartWZTeamData = tStartWZData[M28Map.subrefWZTeamData][iTeam]
        --Go through adjacent WZs and work out the one closest to the nearest enemy base (we have already confirmed we have adj water zones when calling this function)
        local iClosestWZDist = 100000
        local iClosestWZ, iCurDist
        for _, iAdjWZ in tStartWZData[M28Map.subrefWZAdjacentWaterZones] do
            local tAdjWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
            iCurDist = M28Utilities.GetRoughDistanceBetweenPositions(tAdjWZData[M28Map.subrefMidpoint], tStartWZTeamData[M28Map.reftClosestEnemyBase])
            if iCurDist < iClosestWZDist then
                iClosestWZDist = iCurDist
                iClosestWZ = iAdjWZ
            end
        end
        if iClosestWZ then
            --Get travel path to this WZ
            local tTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iClosestWZ]
            local tFullPath, iPathSize, iDistance = NavUtils.PathTo(M28Map.refPathingTypeNavy, oUnit:GetPosition(), tTargetWZData[M28Map.subrefMidpoint], nil)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering starting loop to move unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from iStartWaterZone='..iStartWaterZone..' to iClosestWZ (to enemy base)='..iClosestWZ..'; Is tFullPath empty='..tostring(M28Utilities.IsTableEmpty(tFullPath))..'; iDistance='..(iDistance or 'nil')) end
            if M28Utilities.IsTableEmpty(tFullPath) == false then
                local iCurPathProgress = 1
                local iLastPathEntry = table.getn(tFullPath)
                --Add the midpoint if the last entry doesnt have this
                if M28Utilities.GetDistanceBetweenPositions(tFullPath[iLastPathEntry], tTargetWZData[M28Map.subrefMidpoint]) >= 3 then
                    table.insert(tFullPath, {tTargetWZData[M28Map.subrefMidpoint][1], tTargetWZData[M28Map.subrefMidpoint][2], tTargetWZData[M28Map.subrefMidpoint][3]})
                    iLastPathEntry = iLastPathEntry + 1
                end
                local iViaPathCountBeforeCtrlKCheck = 0
                local iDistToCurPath, iAngleToPath
                local tViaPathPosition = {}
                while M28UnitInfo.IsUnitValid(oUnit) and iCurPathProgress <= iLastPathEntry do
                    --Get dist to current path point
                    iDistToCurPath = M28Utilities.GetDistanceBetweenPositions(tFullPath[iCurPathProgress], oUnit:GetPosition())
                    if iDistToCurPath <= 5 or (iDistToCurPath <= 15 and iCurPathProgress == iLastPathEntry) then
                        iCurPathProgress = iCurPathProgress + 1
                        if iCurPathProgress > iLastPathEntry then break
                        --Decided to remove below commented lines as had scenario where both the core WZ and adj WZ had blockage issues
                        --[[elseif iCurPathProgress == iLastPathEntry and oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iClosestWZ then
                            if bDebugMessages == true then LOG(sFunctionRef..': Are in the target WZ so aborting loop') end
                            break--]]
                        end
                        M28Orders.IssueTrackedMove(oUnit, tFullPath[iCurPathProgress], 0, false, 'StuckPth'..iCurPathProgress, true)
                        iViaPathCountBeforeCtrlKCheck = 0
                    elseif iDistToCurPath <= 10 then
                        M28Orders.IssueTrackedMove(oUnit, tFullPath[iCurPathProgress], 0, false, 'StuckPth'..iCurPathProgress, true)
                        iViaPathCountBeforeCtrlKCheck = 0
                    else
                        --Move towards cur path
                        iAngleToPath = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tFullPath[iCurPathProgress])
                        local tViaPointToPath = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToPath, 10, false, false, false)
                        if M28Utilities.IsTableEmpty(tViaPointToPath) == false then
                            tViaPointToPath[2] = GetSurfaceHeight(tViaPointToPath[1], tViaPointToPath[3])
                            --Consider ctrlking blocking factories/units
                            iViaPathCountBeforeCtrlKCheck = iViaPathCountBeforeCtrlKCheck + 1
                            M28Orders.IssueTrackedMove(oUnit, tViaPointToPath, 3, false, 'StuckPthVia'..iCurPathProgress, true)
                            tViaPathPosition[iViaPathCountBeforeCtrlKCheck] = oUnit:GetPosition()
                            if bDebugMessages == true then LOG(sFunctionRef..': iViaPathCountBeforeCtrlKCheck='..iViaPathCountBeforeCtrlKCheck) end
                            if iViaPathCountBeforeCtrlKCheck >= 6 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tViaPathPosition[iViaPathCountBeforeCtrlKCheck - 1]) <= 0.5 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tViaPathPosition[iViaPathCountBeforeCtrlKCheck - 4]) <= 0.5 then
                                local tMidpointForViaPoint = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngleToPath, 5, false, false, false)
                                if M28Utilities.IsTableEmpty(tMidpointForViaPoint) == false then
                                    if not(tStartWZTeamData[M28Map.subrefWZTimeLastDestroyedForStuckNavy]) and iViaPathCountBeforeCtrlKCheck >= 30 then tStartWZTeamData[M28Map.subrefWZTimeLastDestroyedForStuckNavy] = GetGameTimeSeconds() end --if stuck a while then set the flag even if not ctrlkd anything
                                    --Tried below with range of 5 but wasnt triggering consistently enough
                                    local tBlockingUnits = oUnit:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryNavalHQ * (categories.TECH2 + categories.TECH3), tMidpointForViaPoint, 8, 'Ally')

                                    if bDebugMessages == true then LOG(sFunctionRef..': Is tBlockingUnits empty='..tostring(M28Utilities.IsTableEmpty(tBlockingUnits))) end
                                    if M28Utilities.IsTableEmpty(tBlockingUnits) == false then
                                        tStartWZTeamData[M28Map.subrefWZTimeLastDestroyedForStuckNavy] = GetGameTimeSeconds()
                                        for iBlocker, oBlocker in tBlockingUnits do
                                            if oBlocker:GetAIBrain().M28AI and (M28Orders.bDontConsiderCombinedArmy or oUnit.M28Active) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considerinb oBlocker='..oBlocker.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBlocker)..'; work progress='..oBlocker:GetWorkProgress()) end
                                                if not(oBlocker.GetWorkProgress) or oBlocker:GetWorkProgress() <= 0.1 then
                                                    iViaPathCountBeforeCtrlKCheck = 0 --i.e. dont reset if progress is higher, so we can ctrl-k sooner
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Potentially blocking building, oBlocker='..oBlocker.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBlocker)..'; will try and kill') end
                                                    M28Orders.IssueTrackedKillUnit(oBlocker)
                                                end
                                            end
                                        end
                                    else
                                        iViaPathCountBeforeCtrlKCheck = 0
                                    end
                                end
                            end
                        else
                            M28Orders.IssueTrackedMove(oUnit, tFullPath[iCurPathProgress], 0, false, 'StuckPth'..iCurPathProgress, true)
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering path progress for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurPathProgress='..iCurPathProgress..'; Dist to path position='..M28Utilities.GetDistanceBetweenPositions(tFullPath[iCurPathProgress], oUnit:GetPosition())..'; iLastPathEntry='..iLastPathEntry..'; time='..GetGameTimeSeconds()) end
                    WaitSeconds(1)
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Ending special stuck logic for unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' at time='..GetGameTimeSeconds()) end
        oUnit[M28UnitInfo.refbSpecialMicroActive] = false
    end
end

function ManageSACUsInWaterZone(tSACUs, tWZData, tWZTeamData, iPond, iWaterZone, iTeam)
    --SACU has reached the WZ we wanted; check if a naval fac or not, if not, then assume we lost it and should retreat from water if there are any nearby enemies (or build a naval fac otherwise)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageSACUsInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iWaterZone='..iWaterZone..'; iTeam='..iTeam..'; Time='..GetGameTimeSeconds()) end
    local iHighestUpgradingSACU = -1
    local oHighestUpgradingSACU
    for iSACU, oSACU in tSACUs do
        if oSACU:IsUnitState('Upgrading') then
            if oSACU:GetWorkProgress() > iHighestUpgradingSACU then
                iHighestUpgradingSACU = oSACU:GetWorkProgress()
                oHighestUpgradingSACU = oSACU
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for upgrading SACU, oHighestUpgradingSACU='..(oHighestUpgradingSACU.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oHighestUpgradingSACU) or 'nil')..'; Is table of active upgrades empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoActiveUpgrades]))) end
    if oHighestUpgradingSACU then
        --Assist upgrading SACU
        for iSACU, oSACU in tSACUs do
            if not(oSACU:IsUnitState('Upgrading')) then
                M28Orders.IssueTrackedGuard(oSACU, oHighestUpgradingSACU, false, 'WZAssSUgr', false)
            end
        end

        --Do we have any upgrading units in thie zone? if so then assist
    elseif M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoActiveUpgrades]) == false then
        --Get the upgrade closest to completion and assist it
        local iClosestUpgrade = -1
        local oClosestUpgrade
        for iUnit, oUnit in tWZTeamData[M28Map.subreftoActiveUpgrades] do
            if oUnit:GetWorkProgress() > iClosestUpgrade then
                iClosestUpgrade = oUnit:GetWorkProgress()
                oClosestUpgrade = oUnit
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Have an active upgrade in WZ, oClosestUpgrade='..oClosestUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestUpgrade)) end
        for iSACU, oSACU in tSACUs do
            M28Orders.IssueTrackedGuard(oSACU, oClosestUpgrade, false, 'WZAssUgr', false)
        end
    else
        local bGivenBuildOrder = false
        function BuildCategoryWithSACUs(iCategoryWanted, iOptionalFactionWanted, toSACUByFaction, iOptionalEngineerActionForTracking, iOptionalAlternativeCategory)
            --toSACUByFaction - only needed if iOptionalFactionWanted is specified
            --iOptionalEngineerActionForTracking - if specified, then will call trackengineer function
            --iOptionalAlternativeCategory - if cant find anything to build for category wanted, then will try this as an alternative
            local oPrimaryEngineer
            if iOptionalFactionWanted then
                oPrimaryEngineer = toSACUByFaction[iOptionalFactionWanted][1]
            else
                oPrimaryEngineer = tSACUs[1]
            end

            if oPrimaryEngineer then
                local aiBrain = oPrimaryEngineer:GetAIBrain()
                --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerAction,                                                           iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bNotYetUsedLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData, bCalledFromGetBestLocation, sBlueprintOverride)
                local sBlueprint, tBuildLocation = M28Engineer.GetBlueprintAndLocationToBuild(aiBrain, oPrimaryEngineer, iOptionalEngineerActionForTracking or M28Engineer.refActionBuildExperimental, iCategoryWanted, 100,                nil,                nil,                                false,                          nil,                nil,                                false,              tWZData, tWZTeamData)
                if not(sBlueprint) and iOptionalAlternativeCategory then sBlueprint, tBuildLocation = M28Engineer.GetBlueprintAndLocationToBuild(aiBrain, oPrimaryEngineer, iOptionalEngineerActionForTracking or M28Engineer.refActionBuildExperimental, iOptionalAlternativeCategory, 100, nil, nil,                                false,                          nil,                nil,                                false, tWZData, tWZTeamData) end

                --Update SACU table to remove any of the desired faction who can be given other orders
                if bDebugMessages == true then LOG(sFunctionRef..': sBlueprint='..(sBlueprint or 'nil')..'; tBuildLocation='..repru(tBuildLocation or {})..'; oPrimaryEngineer='..(oPrimaryEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oPrimaryEngineer) or 'nil')) end
                if sBlueprint and tBuildLocation then
                    local toBuilders
                    if iOptionalFactionWanted then
                        for iCurEntry = table.getn(tSACUs), 1, -1 do
                            if M28UnitInfo.GetUnitFaction(tSACUs[iCurEntry]) == iOptionalFactionWanted then
                                table.remove(tSACUs, iCurEntry)
                            end
                        end
                        toBuilders = toSACUByFaction[iOptionalFactionWanted]
                    else
                        toBuilders = tSACUs
                    end

                    --Build with all the SACUs wanted
                    if M28Utilities.IsTableEmpty(toBuilders) == false then
                        for iSACU, oSACU in toBuilders do
                            bGivenBuildOrder = true
                            local tMoveLocation = M28Engineer.GetLocationToMoveForConstruction(oSACU, tBuildLocation, sBlueprint, 0, false)
                            if tMoveLocation then
                                if bDebugMessages == true then LOG(sFunctionRef..': Telling oSACU '..oSACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSACU)..' to move to '..repru(tMoveLocation)..' and then build '..sBlueprint..' at location '..repru(tBuildLocation)) end
                                M28Orders.IssueTrackedMoveAndBuild(oSACU, tBuildLocation, sBlueprint, tMoveLocation, 1, false, 'SACUExpMBld')
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Telling engineer '..oSACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSACU)..' to build '..sBlueprint..' at build location '..repru(tBuildLocation)) end
                                M28Orders.IssueTrackedBuild(oSACU, tBuildLocation, sBlueprint, false, 'SACUExpBld')
                            end
                            if iOptionalEngineerActionForTracking and not(oSACU[M28Engineer.refiAssignedAction] == iOptionalEngineerActionForTracking) then M28Engineer.TrackEngineerAction(oSACU, iOptionalEngineerActionForTracking, iSACU == 1, 1, nil, nil, false) end
                            --M28Engineer.TrackEngineerAction(oSACU, M28Engineer.refActionBuildExperimental, true, 1, nil, nil, false)
                        end
                    end
                end
            end
        end

        --Do we have a naval fac in the zone? base behaviour on this
        local iPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tWZData[M28Map.subrefMidpoint])
        local tFriendlyNavalFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of friendly naval factories empty='..tostring(M28Utilities.IsTableEmpty(tFriendlyNavalFactories))) end
        if M28Utilities.IsTableEmpty(tFriendlyNavalFactories) then
            --No naval fac - either build another (if no nearby enemies) or return to land
            local tRetreatPoint
            if tWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] and not(tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) then
                if NavUtils.GetLabel(M28Map.refPathingTypeHover, tWZTeamData[M28Map.reftClosestFriendlyBase]) == iPlateau then
                    tRetreatPoint = tWZTeamData[M28Map.reftClosestFriendlyBase]
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': want to retreat, tRetreatPoint='..repru(tRetreatPoint)) end
            if tRetreatPoint then
                for iSACU, oSACU in tSACUs do
                    oSACU[M28UnitInfo.refiSACUWaterZoneTarget] = nil
                    M28Orders.IssueTrackedMove(oSACU, tRetreatPoint, 5, false, 'WZSACURun', false)
                end
            else
                --Just build a naval fac (more as a redundancy)
                if bDebugMessages == true then LOG(sFunctionRef..': Redundancy, will build factory') end
                for iSACU, oSACU in tSACUs do
                    M28ACU.ACUActionBuildFactory(oSACU:GetAIBrain(), oSACU, iPlateau, iWaterZone, tWZData, tWZTeamData, M28UnitInfo.refCategoryNavalFactory, M28Engineer.refCategoryNavalFactory)
                end
            end
        else
            --High value reclaim?
            local tSACUsWithoutOrder
            local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
            if (tWZData[M28Map.subrefTotalSignificantMassReclaim] or 0) >= 200 and (bHaveLowMass or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.7) then
                local bGivenReclaimOrder
                local bOnlyGetReclaimInRange = false
                if not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.35 then bOnlyGetReclaimInRange = true end
                for iSACU, oSACU in tSACUs do
                    if oSACU:IsUnitState('Reclaiming') then
                        --Dont give any order as already reclaiming
                    else
                        --GetEngineerToReclaimNearbyArea(oEngineer, iPriorityOverride, tLZOrWZTeamData, iPlateauOrPond, iLandOrWaterZone, bWantEnergyNotMass, bOnlyConsiderReclaimInRangeOfEngineer, iMinIndividualValueOverride, bIsWaterZone, bOptionalReturnTrueIfGivenOrder)
                        bGivenReclaimOrder = M28Engineer.GetEngineerToReclaimNearbyArea(oSACU, 1,                    tWZTeamData, iPlateau,          iWaterZone,      false,         bOnlyGetReclaimInRange, 20, true, true)
                        if not(bGivenReclaimOrder) then
                            if not(tSACUsWithoutOrder) then tSACUsWithoutOrder = {} end
                            table.insert(tSACUsWithoutOrder, oSACU)
                        end
                    end
                end
                if tSACUsWithoutOrder then tSACUs = tSACUsWithoutOrder
                else tSACUs = nil
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bHaveLowMass='..tostring(bHaveLowMass)..'; Significant mass reclaim='..(tWZData[M28Map.subrefTotalSignificantMassReclaim] or 'nil')..'; Av mass%='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; is tSACUs empty after considering reclaim='..tostring(M28Utilities.IsTableEmpty(tSACUs))) end
            if tSACUs then
                --Assist navy if no t3 naval fac here; get the first primary naval fac, or if there is none then assist the highest tech naval fac
                local oFactoryToAssist
                local iHighestTechFactory = 0
                local oFirstHighestTechFactory, iCurTechLevel
                for iFactory, oFactory in tFriendlyNavalFactories do
                    iCurTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
                    if iCurTechLevel > iHighestTechFactory then
                        iHighestTechFactory = iCurTechLevel
                        oFirstHighestTechFactory = oFactory
                    end
                    if oFactory[M28Factory.refbPrimaryFactoryForIslandOrPond] then
                        oFactoryToAssist = oFactory
                        break
                    end
                end
                if not(oFactoryToAssist) then oFactoryToAssist = oFirstHighestTechFactory end
                if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechFactory='..iHighestTechFactory..'; oFactoryToAssist='..(oFactoryToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oFactoryToAssist) or 'nil')) end
                if oFactoryToAssist and iHighestTechFactory < 3 then --we dont even have t3 navy yet so dont want to try building a new experimental
                    for iSACU, oSACU in tSACUs do
                        M28Orders.IssueTrackedGuard(oSACU, oFactoryToAssist, false, 'SACUFacT12Ast', false)
                    end
                else
                    --Build a naval experimental unless low mass and already have some
                    local oExperimentalToAssist
                    --If we have one under construction already then assist
                    local tExperimentals = EntityCategoryFilterDown(M28UnitInfo.refCategoryExperimentalLevel, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tExperimentals) == false then
                        for iExp, oExp in tExperimentals do
                            if oExp:GetFractionComplete() < 1 then
                                oExperimentalToAssist = oExp
                                break
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for under construction exp, oExperimentalToAssist='..(oExperimentalToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oExperimentalToAssist) or 'nil')) end
                    if oExperimentalToAssist then
                        for iSACU, oSACU in tSACUs do
                            M28Orders.IssueTrackedGuard(oSACU, oExperimentalToAssist, false, 'SACUExpAst', false)
                        end
                    else
                        local bWantExperimental = false
                        local aiBrain = ArmyBrains[tWZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]]
                        if not(bHaveLowMass) then bWantExperimental = true
                        elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 10000 then
                            bWantExperimental = true
                        elseif not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) then
                            --Arent stalling resources, so consider getting exp if either navy pers, or we dont own that may experimentals
                            if aiBrain[M28Overseer.refbPrioritiseNavy] then
                                bWantExperimental = true
                            elseif not(M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBombardmentModeByPond][iPond]) or GetGameTimeSeconds() - M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBombardmentModeByPond][iPond] >= 15 then
                                bWantExperimental = true
                            elseif aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryExperimentalLevel * categories.NAVAL * categories.MOBILE) <= 1 then
                                bWantExperimental = true
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': bWantExperimental='..tostring(bWantExperimental)..'; aiBrain='..aiBrain.Nickname..'; StallingE='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; Stalling mass='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass])..'; Time since last bombardment='..GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBombardmentModeByPond][iPond] or 0)..'; Cur mobile exp naval units='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryExperimentalLevel * categories.NAVAL * categories.MOBILE)) end
                        if bWantExperimental then
                            local toSACUByFaction = {}
                            local tbEngineersOfFactionOrNilIfAlreadyAssigned = {}
                            local iCurFaction
                            for iSACU, oSACU in tSACUs do
                                iCurFaction = M28UnitInfo.GetUnitFaction(oSACU)
                                tbEngineersOfFactionOrNilIfAlreadyAssigned[iCurFaction] = true
                                if not(aiBrain) then aiBrain = oSACU:GetAIBrain() end
                                if not(toSACUByFaction[iCurFaction]) then toSACUByFaction[iCurFaction] = {} end
                                table.insert(toSACUByFaction[iCurFaction], oSACU)
                            end
                            BuildCategoryWithSACUs(M28UnitInfo.refCategoryExperimentalLevel * categories.NAVAL * categories.MOBILE,nil, toSACUByFaction, M28Engineer.refActionBuildExperimental, categories.EXPERIMENTAL * categories.MOBILE * categories.ANTINAVY)
                        end
                        if not(bGivenBuildOrder) then
                            --Assist naval fac
                            if bDebugMessages == true then LOG(sFunctionRef..'; Will assist naval fac') end
                            if oFactoryToAssist then
                                for iSACU, oSACU in tSACUs do
                                    M28Orders.IssueTrackedGuard(oSACU, oFactoryToAssist, false, 'SACUFacT3Ast', false)
                                end
                            end
                            --Idle (do nothing)
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end