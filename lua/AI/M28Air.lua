---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 08/12/2022 07:09
---

local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Chat = import('/mods/M28AI/lua/AI/M28Chat.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')

--Global
tAirZonePathingFromZoneToZone = {} --[x]: 1 if land zone start, 0 if water; [y]: Plateau (if land) or 0 if water; [z]: Land/Water zone; [a]: 1 if land zone end, 0 if water; [b]: Plateau (if land) end, 0 if water; [c]: Land/water zone; returns table that contains subreftPlateauAndLandZonesInPath and subreftWaterZonesInPath, each of which will list out in no order the land and water zones that will come across or near
    subreftPlateauAndLandZonesInPath = 'M28APathPlatLZ' --if are any
    subreftWaterZonesInPath = 'M28APathWZ'
tDistanceAdjustXZ = {} --Used for gunships to space out
iMinimumASFCountPostGifting = 18 --if we give asfs to a teammate we want to maintain this number for basic defence
iExtraTicksToWaitBetweenAirCycles = 0 --Set by ConsiderSlowdownForHighUnitCount; E.g. if want to run air logic once every 2s then set this to 10 (since normal air logic is run within 1s)

tbFullAirTeamCycleRun = {} --[x] = iteam, returns true if have run one full cycle
tbFullAirSubteamCycleRun = {} --[x] = --iSubteam, returns true if have run one full cycle
tiRecentExpBomberTargets = {} --when an experimental bomber fires, then will trakc here
iBaseLowHealthThreshold = 0.55
iProjectileLowHealthThreshold = 0.52 --should always be equal or lower than iBaseLowHealthThreshold
iReclaimWantedForTransportDrop = 250 --i.e. amount of reclaim in amss to consider dropping for even if no mex

--Against units:
    reftAssignedRefuelingUnits = 'M28AirRefueling'
    refiGunshipPlacement = 'M28GSPlac' --The placement in the gunship group
    refiStrikeDamageAssigned = 'M28SDAss' --assigned strike damage against the unit
    refoStrikeDamageAssigned = 'M28SDA' --against the bomber, records the unit against which its strike damage has been assigned
    reftScoutAssignedPlateauAndZoneRef = 'M28SPlLZRef' --against scout, returns {iPlateauOrZero, iLZOrWZRef} that the scout is assigned to,  iPlateauOrZero is 0 for water zone
    refiEngisWanted = 'M28TrnEWnt' --Number of engineers a transport wants
    refiTransportTimeSpentWaiting = 'M28TrnTimW' --Time that transport has been waiting for engineers - so will go with fewer engineers for higher values
    refoTransportUnitTryingToLoad = 'M28TrUnLd' --When a unit is given an order to load into a transport directly,  it gets recorded against this for the transport
    refiTargetIslandForDrop = 'M28TrnTgIsl' --Target island for a transport to drop
    refiTargetZoneForDrop = 'M28TrnTgLZ' --target zone for a transport to drop (e.g. it may be dropping the same island its currently on but further away)
    refiLastIslandDrop = 'M28ALstIsD' --When a unit is dropped by a transport, it should be assigned the island ref the transport was trying to drop to
    refiTimeLastDropped = 'M28ATimLstD' --Time that a unit was last dropped by a living transport
    refoPriorityTargetOverride = 'M28NvxTOvrd' --e.g. used against novax satellite, for if want to add logic similar to M27 where attacks on high value targets are coordinated
    refiTimeOfLastOverride = 'M28TimLastOvrd' --e.g. could be used against novax satellite in combination with above - see M27 logic
    refoNovaxLastTarget = 'M28NovLastTarget' --needed in addition to order tracking since we only track if doing an issueattack
    refoAirAACurTarget = 'M28AirAATrg' --Target the AirAA unit was last assigned
    refbActiveNovaxUnloadCheck = 'M28NovActUnl' --true if we are periodically checking if we should unload the novax
    refiTimeLastWantedPriorityAirScout = 'M28PrArSc' --Gametimeseconds the unit was last checked to be added to the table for priority air scouts
    refiAssignedSuicideASF = 'M28AsfSu' --againt a strategic bomber, records Number of asfs assigned to suciide into the bomber in its lifetime


function RecordNewAirUnitForTeam(iTeam, oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordNewAirUnitForTeam'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': iTeam='..iTeam..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit team='..oUnit:GetAIBrain().M28Team..'; table of active M28 brains for this team is empty?='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end
    local sTeamTableRef
    --Is this an enemy unit?
    if not(oUnit:GetAIBrain().M28Team == iTeam) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        if EntityCategoryContains(M28UnitInfo.refCategoryAirToGround, oUnit.UnitId) then
            sTeamTableRef = M28Team.reftoEnemyAirToGround
        elseif EntityCategoryContains(M28UnitInfo.refCategoryAirAA, oUnit.UnitId) then
            sTeamTableRef = M28Team.reftoEnemyAirAA
        elseif EntityCategoryContains(M28UnitInfo.refCategoryTorpBomber, oUnit.UnitId) then
            sTeamTableRef = M28Team.reftoEnemyTorpBombers
        else
            sTeamTableRef = M28Team.reftoEnemyAirOther
        end
        if bDebugMessages == true then LOG(sFunctionRef..': About to insert unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; into table sTeamTableRef='..sTeamTableRef) end
        table.insert(M28Team.tTeamData[iTeam][sTeamTableRef], oUnit)
        table.insert(M28Team.tTeamData[iTeam][M28Team.reftoAllEnemyAir], oUnit)

        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        if aiBrain then

            if iPlateauOrZero == 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Will add unit to water zone, iLandOrWaterZone='..(iLandOrWaterZone or 'nil')) end
                M28Team.AddUnitToWaterZoneForBrain(aiBrain, oUnit, iLandOrWaterZone, true)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Will add unit to land zone, iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')) end
                M28Team.AddUnitToLandZoneForBrain(aiBrain, oUnit, iPlateauOrZero, iLandOrWaterZone, true)
            end
        end
        --[[local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), false, nil)
        if (iLandZone or 0) == 0 then
            --Does it have a water zone?
            local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnit:GetPosition())
            local iWaterZone = M28Map.tWaterZoneBySegment[iSegmentX][iSegmentZ]
            if iWaterZone > 0 then
                local aiBrain
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    aiBrain = oBrain
                    break
                end
                M28Team.AddUnitToWaterZoneForBrain(aiBrain, oUnit, iWaterZone, true)
            else
                RecordEnemyAirUnitWithNoZone(iTeam, oUnit)
            end
        else
            local aiBrain
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                aiBrain = oBrain
                break
            end
            M28Team.AddUnitToLandZoneForBrain(aiBrain, oUnit, iPlateau, iLandZone, true)
        end--]]
    else
        --Friendly unit
        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if this is an under construction air experimental, fraction complete='..oUnit:GetFractionComplete()..'; Is enemy='..tostring(IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()))) end
        if EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) and oUnit:GetFractionComplete() < 1 then
            --Record against list of units in the zone while under construction
            local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
            if (iLandOrWaterZone or 0) > 0 then
                if iPlateauOrZero == 0 then
                    M28Team.AddUnitToWaterZoneForBrain(aiBrain, oUnit, iLandOrWaterZone, false)
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Added unit to land zone '..iLandOrWaterZone) end
                    M28Team.AddUnitToLandZoneForBrain(aiBrain, oUnit, iPlateauOrZero, iLandOrWaterZone, false)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordEnemyAirUnitWithNoZone(iTeam, oUnit)
    local sFunctionRef = 'RecordEnemyAirUnitWithNoZone'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    M28Utilities.ErrorHandler('Obsolete code which wasnt expected to be used')
    table.insert(M28Team.tTeamData[iTeam][M28Team.reftoEnemyUnitsWithNoLZ], oUnit)
    if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam]) then
        if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) then oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] = {} end
        oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam] = {}
    end
    if not(oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam]) then
        if not(oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam]) then oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam] = {} end
        oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] = {}
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshZonelessAir(iTeam)
    local sFunctionRef = 'RefreshZonelessAir'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoEnemyUnitsWithNoLZ]) == false and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)

        if aiBrain then
            --UpdateUnitPositionsAndLandZone(aiBrain, tUnits,                                                       iTeam, iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
            M28Land.UpdateUnitPositionsAndLandZone(aiBrain, M28Team.tTeamData[iTeam][M28Team.reftoEnemyUnitsWithNoLZ], iTeam, nil,              nil,            true,                   true,           nil,        false,                              true)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateEnemyAirThreats(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateEnemyAirThreats'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Calculate threat ratings
    if bDebugMessages == true then
        LOG(sFunctionRef..': Start of code, gametime='..GetGameTimeSeconds()..'; Is table of enemy air to ground threat empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround])))
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround]) == false then
            for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround] do
                LOG(sFunctionRef..': unit '..iUnit..' in enemy air to ground, ref='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has an air to ground threat of '..M28UnitInfo.GetAirThreatLevel({ oUnit }, true, false, false, true, false, false))
            end
        end
    end
                                                                        --GetAirThreatLevel(tUnits,                                             bEnemyUnits,    bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
    M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] = M28UnitInfo.GetAirThreatLevel(M28Team.tTeamData[iTeam][M28Team.reftoAllEnemyAir], true,            true,               false,              false,                  false,              false)
    M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] = M28UnitInfo.GetAirThreatLevel(M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround], true, false,              false,              true,                   false, false)
    M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] = M28UnitInfo.GetAirThreatLevel(M28Team.tTeamData[iTeam][M28Team.reftoEnemyTorpBombers], true, false,              false,              false,                  false, true)
    M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat] = M28UnitInfo.GetAirThreatLevel(M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirOther], true,       true,               false,              true,                   true,                   true)
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, time='..GetGameTimeSeconds()..'; Enemy AirAA threat='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat]..'; Air to ground threat='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; Torp bomber threat='..M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat]..'; Other threat='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat]) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateTeamAirThreats(iTeam)
    M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] = 0
    M28Team.tTeamData[iTeam][M28Team.subrefiOurBomberThreat] = 0
    M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat] = 0
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefAirSubteamsInTeam]) == false then
        for iEntry, iAirSubteam in M28Team.tTeamData[iTeam][M28Team.subrefAirSubteamsInTeam] do
            M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] + (M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] or 0)
            M28Team.tTeamData[iTeam][M28Team.subrefiOurBomberThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiOurBomberThreat] + (M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurBomberThreat] or 0)
            M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat] + (M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] or 0)
        end
    end
end

function AirTeamOverseer(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AirTeamOverseer'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    while not(M28Map.bMapLandSetupComplete) or not(M28Map.bWaterZoneInitialCreation) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitSeconds(5) --extra delay to be safe
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    AssignScoutingIntervalPriorities(iTeam)
    if M28Team.GetFirstActiveM28Brain(iTeam).HostileCampaignAI and tonumber(ScenarioInfo.Options.CmpAIDelay) > GetGameTimeSeconds() + 0.2 then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(tonumber(ScenarioInfo.Options.CmpAIDelay) - GetGameTimeSeconds() - 0.2)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    while M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 0 do
        if ScenarioInfo.OpEnded and M28Map.bIsCampaignMap and GetGameTimeSeconds() <= 120 then
            while ScenarioInfo.OpEnded do
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitSeconds(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) then break end
        end

        ForkThread(RefreshZonelessAir, iTeam)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        ForkThread(UpdateEnemyAirThreats, iTeam)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        ForkThread(UpdateTeamAirThreats, iTeam)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(7)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        --NOTE: Other logic is done on air subteam basis
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        if iExtraTicksToWaitBetweenAirCycles > 0 then WaitTicks(iExtraTicksToWaitBetweenAirCycles) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        tbFullAirTeamCycleRun[iTeam] = true
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AddUnitWantingPriorityScout(oUnit, bDontCheckIfInTable)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddUnitWantingPriorityScout'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bAddUnit = true
    local iAirSubteam = oUnit:GetAIBrain().M28AirSubteam
    if not(bDontCheckIfInTable) and M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout]) == false then
        for iExistingUnit, oExistingUnit in M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout] do
            if oExistingUnit == oUnit then bAddUnit = false break end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Will add unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to priority table of units wanting scout unless it is already there, bAddUnit='..tostring(bAddUnit)..'; iAirSubteam='..iAirSubteam..'; Time='..GetGameTimeSeconds()) end
    if bAddUnit then
        if not(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout]) then M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout] = {} end
        table.insert(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout], oUnit)
        oUnit[refiTimeLastWantedPriorityAirScout] = GetGameTimeSeconds()
    end
end

function AssignScoutingIntervalPriorities(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignScoutingIntervalPriorities'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Make all enemy start positions a high priority
    local iPlateauOrZero, iLandOrWaterZone
    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
        if bDebugMessages == true then LOG(sFunctionRef..': About to get closest plateau and zone for the enemy start position, oBrain='..oBrain.Nickname..'; start point='..repru(M28Map.GetPlayerStartPosition(oBrain))..'; Map plyaable area='..repru(M28Map.rMapPlayableArea)..'; Map size='..repru(ScenarioInfo.size)..'; rMapPotentialPlayableArea='..repru(M28Map.rMapPotentialPlayableArea)) end
        --Check if are within the playable area
        local tStartPoint = M28Map.GetPlayerStartPosition(oBrain)
        if not(M28Map.bIsCampaignMap) or M28Map.InPlayableArea(tStartPoint) then
            iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tStartPoint)

            if iPlateauOrZero == 0 then
                M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam][M28Map.refiScoutingPriority] = M28Map.subrefiScoutingHighPriority
            else
                M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam][M28Map.refiScoutingPriority] = M28Map.subrefiScoutingHighPriority
            end
        end
    end

    --Make any land zone with a mex a medium priority
    for iPlateau, tPlateauSubtable in M28Map.tAllPlateaus do
        for iLandZone, tLZData in tPlateauSubtable[M28Map.subrefPlateauLandZones] do
            local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
            if not(tLZTeamData[M28Map.refiScoutingPriority]) then
                if tLZData[M28Map.subrefLZMexCount] > 0 then
                    tLZTeamData[M28Map.refiScoutingPriority] = M28Map.subrefiScoutingMediumPriority
                else
                    tLZTeamData[M28Map.refiScoutingPriority] = M28Map.subrefiScoutingLowPriority
                end
            end
        end
    end

    --Same for water zones with mexes
    for iPond, tPondSubtable in M28Map.tPondDetails do
        for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
            local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
            if not(tWZTeamData[M28Map.refiScoutingPriority]) then
                if tWZData[M28Map.subrefWZMexCount] > 0 then
                    tWZTeamData[M28Map.refiScoutingPriority] = M28Map.subrefiScoutingMediumPriority
                else
                    tWZTeamData[M28Map.refiScoutingPriority] = M28Map.subrefiScoutingLowPriority
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AirTeamInitialisation(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AirTeamInitialisation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    M28Team.tTeamData[iTeam][M28Team.reftoAllEnemyAir] = {}
    M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirAA] = {}
    M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround] = {}
    M28Team.tTeamData[iTeam][M28Team.reftoEnemyTorpBombers] = {}
    M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirOther] = {}
    M28Team.tTeamData[iTeam][M28Team.reftoEnemyUnitsWithNoLZ] = {}
    M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] = 0
    M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] = 0
    M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] = 0
    M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat] = 0

    ForkThread(AirTeamOverseer, iTeam)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AirSubteamInitialisation(iTeam, iAirSubteam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AirSubteamInitialisation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir] = true
    M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] = false
    ForkThread(AirSubteamOverseer, iTeam, iAirSubteam)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordTorpedoBomberPriorityLocations(iTeam, iAirSubteam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordTorpedoBomberPriorityLocations'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iMaxAdjacencySearchLevel
    if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] then iMaxAdjacencySearchLevel = 3
    elseif M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir] then iMaxAdjacencySearchLevel = 2
    else iMaxAdjacencySearchLevel = 1
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Time='..GetGameTimeSeconds()..'; iMaxAdjacencySearchLevel='..iMaxAdjacencySearchLevel..'; M28Team.tAirSubteamData[iAirSubteam][M28Team.refiLastTorpBomberAdjacencyLevel]='..(M28Team.tAirSubteamData[iAirSubteam][M28Team.refiLastTorpBomberAdjacencyLevel] or 'nil')) end
    if not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refiLastTorpBomberAdjacencyLevel] == iMaxAdjacencySearchLevel) then
        M28Team.tAirSubteamData[iAirSubteam][M28Team.refiLastTorpBomberAdjacencyLevel] = iMaxAdjacencySearchLevel
        M28Team.tAirSubteamData[iAirSubteam][M28Team.reftiTorpedoDefenceWaterZones] = {}

        local tbAddedZones = {}
        local tiMinZoneLevelRecorded = {}
        local iCurAdjacencyLevel
        function AddWaterZoneToTorpedoDefenceZones(iWZToAdd, iLevelRecordedAt)
            if not(tbAddedZones[iWZToAdd]) then
                table.insert(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftiTorpedoDefenceWaterZones], iWZToAdd)
                tbAddedZones[iWZToAdd] = true
            end
            tiMinZoneLevelRecorded[iWZToAdd] = math.min((tiMinZoneLevelRecorded[iWZToAdd] or iLevelRecordedAt), iLevelRecordedAt)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code for iAirSubteam '..iAirSubteam..' in iTeam '..iTeam..' at the game time='..GetGameTimeSeconds()) end
        for iPond, tPondSubtable in M28Map.tPondDetails do
            M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond] = {}
            for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
                local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                if tWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation] or (M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false) then
                    iCurAdjacencyLevel = 0
                    if not(tbAddedZones[iWaterZone]) or tiMinZoneLevelRecorded[iWaterZone] > iCurAdjacencyLevel then
                        AddWaterZoneToTorpedoDefenceZones(iWaterZone, iCurAdjacencyLevel)

                        if bDebugMessages == true then LOG(sFunctionRef..': Added WZ '..iWaterZone..'; is table of adj WZ empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]))) end
                        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false and (tWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation] or iMaxAdjacencySearchLevel > 1) then
                            for iEntry, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                                iCurAdjacencyLevel = 1
                                if not(tbAddedZones[iAdjWZ]) or tiMinZoneLevelRecorded[iAdjWZ] > iCurAdjacencyLevel then
                                    AddWaterZoneToTorpedoDefenceZones(iAdjWZ, iCurAdjacencyLevel)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Added iAdjWZ='..iAdjWZ..'; are we far behind on air='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir])) end
                                    --Include zones adjacent to this if not far behind on air
                                    if iMaxAdjacencySearchLevel > iCurAdjacencyLevel then
                                        for iEntry, iSecondAdjWZ in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZAdjacentWaterZones] do
                                            iCurAdjacencyLevel = 2
                                            if (not(tbAddedZones[iSecondAdjWZ]) or tiMinZoneLevelRecorded[iSecondAdjWZ] > iCurAdjacencyLevel or (not(tWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation]) and (iCurAdjacencyLevel == 2 or iCurAdjacencyLevel >= 2))) then
                                                AddWaterZoneToTorpedoDefenceZones(iSecondAdjWZ, iCurAdjacencyLevel)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Added iSecondAdjWZ='..iSecondAdjWZ..'; Do we have air control='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl])) end
                                                --If have significant torpedo threat then consider adding the next line
                                                if iMaxAdjacencySearchLevel > iCurAdjacencyLevel then
                                                    for iEntry, iThirdAdjWZ in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iSecondAdjWZ][M28Map.subrefWZAdjacentWaterZones] do
                                                        iCurAdjacencyLevel = 3
                                                        if not(tbAddedZones[iThirdAdjWZ]) or tiMinZoneLevelRecorded[iThirdAdjWZ] > iCurAdjacencyLevel then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Added iThirdAdjWZ='..iThirdAdjWZ) end
                                                            AddWaterZoneToTorpedoDefenceZones(iThirdAdjWZ, iCurAdjacencyLevel)
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, M28Team.tAirSubteamData[iAirSubteam][M28Team.reftiTorpedoDefenceWaterZones]='..repru(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftiTorpedoDefenceWaterZones])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ReassessTorpBomberPriorityLocations(iTeam, iAirSubteam)
    local iCurCount = 0
    while iCurCount <= 10 do
        iCurCount = iCurCount + 1
        WaitSeconds(1)
        if iCurCount >= 10 then
            iCurCount = 0
            ForkThread(RecordTorpedoBomberPriorityLocations, iTeam, iAirSubteam)
        end
    end

end

function AirSubteamOverseer(iTeam, iAirSubteam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AirSubteamOverseer'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    while not(M28Map.bMapLandSetupComplete) or not(M28Map.bWaterZoneInitialCreation) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitSeconds(5) --extra delay to be safe
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Team.GetFirstActiveM28Brain(iTeam).HostileCampaignAI and tonumber(ScenarioInfo.Options.CmpAIDelay) > GetGameTimeSeconds() + 0.1 then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(tonumber(ScenarioInfo.Options.CmpAIDelay) - GetGameTimeSeconds() -0.1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    if ScenarioInfo.OpEnded and M28Map.bIsCampaignMap and GetGameTimeSeconds() <= 120 then
        while ScenarioInfo.OpEnded do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    --Record torpedo bomber locations to defend
    RecordTorpedoBomberPriorityLocations(iTeam, iAirSubteam)
    ForkThread(ReassessTorpBomberPriorityLocations, iTeam, iAirSubteam)


    while M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains]) == false do
        if ScenarioInfo.OpEnded and M28Map.bIsCampaignMap and GetGameTimeSeconds() <= 120 then
            while ScenarioInfo.OpEnded do
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitSeconds(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) then break end
        end

        ForkThread(UpdateAirRallyAndSupportPoints, iTeam, iAirSubteam)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        ForkThread(ManageAirAAUnits, iTeam, iAirSubteam)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        ForkThread(ManageBombers, iTeam, iAirSubteam)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        ForkThread(ManageGunships, iTeam, iAirSubteam)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        ForkThread(ManageTorpedoBombers, iTeam, iAirSubteam)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        ForkThread(ManageAirScouts, iTeam, iAirSubteam)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        ForkThread(ManageTransports, iTeam, iAirSubteam)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        ForkThread(ManageNovax, iTeam, iAirSubteam)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        ForkThread(ManageExperimentalBomber, iTeam, iAirSubteam)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        ForkThread(ManageOtherAir, iTeam, iAirSubteam) --e.g. mercies
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        if iExtraTicksToWaitBetweenAirCycles > 0 then WaitTicks(iExtraTicksToWaitBetweenAirCycles) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        tbFullAirSubteamCycleRun[iAirSubteam] = true
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AddPriorityAirDefenceTarget(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddPriorityAirDefenceTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Dont try and defend novax satellite
    if not(EntityCategoryContains(categories.UNTARGETABLE, oUnit.UnitId)) then

        local iAirSubteam = oUnit:GetAIBrain().M28AirSubteam
        if not(iAirSubteam) or (not(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftACUExpAndPriorityDefenceOnSubteam]) and not(oUnit:GetAIBrain().M28AI)) then
            --Search for M28 brain that is an ally
            local aiBrain = oUnit:GetAIBrain()
            for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                if IsAlly(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()) then
                    iAirSubteam = oBrain.M28AirSubteam
                    if not(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftACUExpAndPriorityDefenceOnSubteam]) then M28Team.tAirSubteamData[iAirSubteam][M28Team.reftACUExpAndPriorityDefenceOnSubteam] = {} end
                end
            end
        end
        --Check not already in table
        local bInTableAlready = false
        if M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftACUExpAndPriorityDefenceOnSubteam]) == false then
            for iExistingUnit, oExistingUnit in M28Team.tAirSubteamData[iAirSubteam][M28Team.reftACUExpAndPriorityDefenceOnSubteam] do
                if oExistingUnit == oUnit then
                    bInTableAlready = true
                    break
                end
            end
        end
        if not(bInTableAlready) then
            if not(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftACUExpAndPriorityDefenceOnSubteam]) then M28Team.tAirSubteamData[iAirSubteam][M28Team.reftACUExpAndPriorityDefenceOnSubteam] = {} end --redundancy - above should already cover
            table.insert(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftACUExpAndPriorityDefenceOnSubteam], oUnit)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshPriorityAirDefenceTargets(iAirSubteam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshPriorityAirDefenceTargets'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftACUExpAndPriorityDefenceOnSubteam]) then
        --Presumably first time we have run this as should ahve ACUs - add ACUs
        for iBrain, oBrain in M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains] do
            local tACUs = oBrain:GetListOfUnits(categories.COMMAND, false, true)
            if M28Utilities.IsTableEmpty(tACUs) == false then
                for iACU, oACU in tACUs do
                    AddPriorityAirDefenceTarget(oACU)
                end
            else
                if ScenarioInfo.Options.Victory == "demoralization" then
                    M28Utilities.ErrorHandler('oBrain '..(oBrain.Nickname or 'nil')..' has no ACUs')
                end
            end
        end
    else
        --Check if unit still valid
        local iExistingEntries = table.getn(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftACUExpAndPriorityDefenceOnSubteam])

        for iCurUnit = iExistingEntries, 1, -1 do
            if not(M28UnitInfo.IsUnitValid(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftACUExpAndPriorityDefenceOnSubteam][iCurUnit])) then
                table.remove(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftACUExpAndPriorityDefenceOnSubteam], iCurUnit)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function IsAirUnitInCombat(oUnit, iTeam, tTargetOverride)
    --Intended for deciding if a low health unit belonging to M28Team iTeam should return to air staging or not
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsAirUnitInCombat'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tLastOrder = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]]
    if M28Utilities.IsTableEmpty(tLastOrder) then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false
    else
        local iDistToTarget, tOrderTarget
        if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAttack then
            if M28UnitInfo.IsUnitValid(tLastOrder[M28Orders.subrefoOrderUnitTarget]) then
                tOrderTarget = tTargetOverride or tLastOrder[M28Orders.subrefoOrderUnitTarget]:GetPosition()
                iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOrderTarget)
            else
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return false
            end
        elseif tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueMove then
            tOrderTarget = tTargetOverride or tLastOrder[M28Orders.subreftOrderPosition]
            iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOrderTarget)
        else
            --Other target so treat as not in combat/wanting to refuel
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return false
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if air unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is in combat, iDistToTarget='..iDistToTarget..'; tLastOrder[M28Orders.subrefoOrderUnitTarget]='..(tLastOrder[M28Orders.subrefoOrderUnitTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tLastOrder[M28Orders.subrefoOrderUnitTarget]) or 'nil')..'; Time='..GetGameTimeSeconds()) end
        if iDistToTarget < 100 then
            local iDistThreshold = 100
            if EntityCategoryContains(M28UnitInfo.refCategoryAirAA, oUnit.UnitId) then
                iDistThreshold = 30
                if oUnit[refoAirAACurTarget].UnitId then
                    if EntityCategoryContains(M28UnitInfo.refCategoryBomber + M28UnitInfo.refCategoryTransport - categories.EXPERIMENTAL, oUnit[refoAirAACurTarget].UnitId) then
                        iDistThreshold = 55
                    elseif EntityCategoryContains(categories.EXPERIMENTAL, oUnit[refoAirAACurTarget].UnitId) then
                        iDistThreshold = 70
                    end
                end
            elseif EntityCategoryContains(categories.TECH1, oUnit.UnitId) then iDistThreshold = 50
            elseif EntityCategoryContains(categories.TECH2, oUnit.UnitId) then iDistThreshold = 65
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iDistThreshold='..iDistThreshold) end
            if iDistToTarget > iDistThreshold then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return false
            else
                --Our target is relatively close, if we are not an airAA unit then treat as in combat if we have an attack order
                if EntityCategoryContains(M28UnitInfo.refCategoryAirAA, oUnit.UnitId) then
                    if oUnit[refoAirAACurTarget] then
                        if EntityCategoryContains(M28UnitInfo.refCategoryAirScout, oUnit[refoAirAACurTarget].UnitId) then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return false
                        else
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        end
                        --Treat as in combat if nearby enemy air to the target; not sure if below code is actually used?
                    elseif tOrderTarget then
                        local iPlateau, iLandZone, iWaterZone
                        iPlateau, iLandZone =  M28Map.GetPlateauAndLandZoneReferenceFromPosition(tOrderTarget)
                        if iPlateau then
                            if (iLandZone or 0) == 0 then
                                iWaterZone = M28Map.GetWaterZoneFromPosition(tOrderTarget)
                                if (iWaterZone or 0) == 0 then
                                    --unlikely we are going to a rally point or air staging if it isnt on land or water that can be pathed to by ground
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                    return true
                                else
                                    --Check if enemy air in water zone
                                    local tWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][iTeam]
                                    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]) == false then
                                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                        return true
                                    end
                                end
                            else
                                --Check if enemy air in land zone
                                local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) == false then
                                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                    return true
                                end
                            end
                        else
                            --unlikely we are going to a rally point or air staging if it isnt on land or water that can be pathed to by ground
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        end
                    end
                else
                    --Bomber so unavailable if attack order
                    if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAttack then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return true
                    end
                end
            end
        else
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return false
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function AddAssignedAttacker(oTarget, oNewBomber)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddAssignedAttacker'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..'; Start of code, About to add assigned strike damage to oTarget='..(oTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTarget) or 'nil')..'; oOldBomber='..(oNewBomber.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNewBomber) or 'nil')..'; Time='..GetGameTimeSeconds()) end
    if not(oNewBomber[M28UnitInfo.refiStrikeDamage]) then
        --Redundancy for campaign where presumably there's a slight delay in recording a unit that gets cheated in by the map script
        M28UnitInfo.RecordUnitRange(oNewBomber)
    end
    local bRecordNewStrikeDamage = true
    if oNewBomber[refoStrikeDamageAssigned] then
        if not(oNewBomber[refoStrikeDamageAssigned] == oTarget) then --redundancy - M28Orders should already clear when issuing a clear commands
            RemoveAssignedAttacker(oNewBomber[refoStrikeDamageAssigned], oNewBomber)
        else
            bRecordNewStrikeDamage = false
        end
    end
    if bRecordNewStrikeDamage then
        if bDebugMessages == true then LOG(sFunctionRef..': oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Existing strike damage='..(oTarget[refiStrikeDamageAssigned] or 0)..'; oNewBomber='..oNewBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNewBomber)..'; oNewBomber strike damage='..(oNewBomber[M28UnitInfo.refiStrikeDamage] or 'nil')..'; Bomber brain owner='..oNewBomber:GetAIBrain().Nickname) end
        oTarget[refiStrikeDamageAssigned] = (oTarget[refiStrikeDamageAssigned] or 0) + oNewBomber[M28UnitInfo.refiStrikeDamage]
        oNewBomber[refoStrikeDamageAssigned] = oTarget
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code after assigning oNewBomber '..oNewBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNewBomber)..' to target oTarget '..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Strike damage assigned='..oTarget[refiStrikeDamageAssigned]..'; Time='..GetGameTimeSeconds()) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RemoveAssignedAttacker(oTarget, oOldBomber)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RemoveAssignedAttacker'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..'; Start of code, About to remove assigned strike damage from oTarget='..(oTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTarget) or 'nil')..'; oOldBomber='..(oOldBomber.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oOldBomber) or 'nil')..'; Time='..GetGameTimeSeconds()) end
    if not(oOldBomber[M28UnitInfo.refiStrikeDamage]) then
        M28Utilities.ErrorHandler('Bomber '..(oOldBomber.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oOldBomber) or 'nil')..' doesnt have any strike damage, will reset unit strike damage assignment')
        oTarget[refiStrikeDamageAssigned] = 0
    else
        oTarget[refiStrikeDamageAssigned] = math.max(0, (oTarget[refiStrikeDamageAssigned] or 0) - oOldBomber[M28UnitInfo.refiStrikeDamage])
    end
    oOldBomber[refoStrikeDamageAssigned] = nil

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function GetAvailableLowFuelAndInUseAirUnits(iTeam, iAirSubteam, iCategory, bRecordInTorpBomberWaterZoneList, bLowHealthThresholdDueToSnipeTarget)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetAvailableLowFuelAndInUseAirUnits'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tAvailableUnits = {}
    local tUnitsForRefueling = {}
    local tInUseUnits = {}
    local tSpecialLogicUnits = {}
    local iLowFuelThreshold = 0.25
    local iLowHealthThreshold = iProjectileLowHealthThreshold
    if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbOrigRallyOutsidePlayableArea] or M28Team.tTeamData[iTeam][M28Team.refbDontHaveBuildingsOrACUInPlayableArea] then

        local oFirstBrain
        local bHaveAirStaging = false
        for iBrain, oBrain in M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains] do
            if oBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirStaging) > 0 then
                bHaveAirStaging = true
                break
            end
        end
        if not(bHaveAirStaging) then
            iLowFuelThreshold = 0
            iLowHealthThreshold = 0
        end
    end
    if bLowHealthThresholdDueToSnipeTarget then
        iLowFuelThreshold = math.min(iLowFuelThreshold, 0.05)
        iLowHealthThreshold = math.min(iLowHealthThreshold, 0.1)
    end
    for iBrain, oBrain in M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains] do
        if oBrain.M28AI then
            local tCurUnits = oBrain:GetListOfUnits(iCategory, false, true)
            local iFuelPercent
            local iHealthPercent
            local bSendUnitForRefueling
            local iSegmentX, iSegmentZ
            local iTeam = oBrain.M28Team
            if M28Utilities.IsTableEmpty(tCurUnits) == false then
                for iUnit, oUnit in tCurUnits do
                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() >= 1 then --Needed as sometimes an invalid unit is included from getlistofunits; also because underproduction units are included with getlistofunits
                        if bRecordInTorpBomberWaterZoneList then
                            iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnit:GetPosition())
                            if M28Map.tWaterZoneBySegment[iSegmentX][iSegmentZ] then
                                M28Team.tAirSubteamData[iAirSubteam][M28Team.reftWaterZonesHasFriendlyTorps][M28Map.tWaterZoneBySegment[iSegmentX][iSegmentZ]] = true
                            end
                        end
                        if oUnit[M28UnitInfo.refbSpecialMicroActive] then
                            table.insert(tInUseUnits, oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Special micro is active') end
                        else
                            local tLastOrder = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]]
                            local oExistingValidAttackTarget
                            if tLastOrder and tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAttack then
                                if M28UnitInfo.IsUnitValid(tLastOrder[M28Orders.subrefoOrderUnitTarget]) then
                                    oExistingValidAttackTarget = tLastOrder[M28Orders.subrefoOrderUnitTarget]
                                end
                            elseif oUnit[refoAirAACurTarget] then
                                if M28UnitInfo.IsUnitValid(oUnit[refoAirAACurTarget]) then oExistingValidAttackTarget = oUnit[refoAirAACurTarget] end

                            end

                            --Gunship projectile logic - update table/flag
                            if oUnit[M28UnitInfo.refbProjectilesMeanShouldRefuel] then
                                local iTotalDamage = 0
                                if M28Utilities.IsTableEmpty(oUnit[M28UnitInfo.reftoEnemyProjectiles]) == false then
                                    for iCurProjectile = table.getn(oUnit[M28UnitInfo.reftoEnemyProjectiles]), 1, -1 do
                                        local oCurProjectile = oUnit[M28UnitInfo.reftoEnemyProjectiles][iCurProjectile]
                                        if oCurProjectile:BeenDestroyed() then
                                            table.remove(oUnit[M28UnitInfo.reftoEnemyProjectiles], iCurProjectile)
                                        else
                                            iTotalDamage = iTotalDamage + (oCurProjectile.DamageData.DamageAmount or 0)
                                        end
                                    end
                                end
                                if iTotalDamage == 0 then oUnit[M28UnitInfo.refbProjectilesMeanShouldRefuel] = false end
                            end

                            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is unit attached='..tostring(oUnit:IsUnitState('Attached'))..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; reprs of tLastOrder='..reprs(tLastOrder)..'; Is oExistingValidAttackTarget valid='..tostring(M28UnitInfo.IsUnitValid(oExistingValidAttackTarget))) end
                            if oUnit:IsUnitState('Attached') then
                                --Clear any orders it might have as it is refueling
                                if tLastOrder and tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderRefuel then
                                    M28Orders.IssueTrackedClearCommands(oUnit)
                                end
                                table.insert(tInUseUnits, oUnit)
                            elseif tLastOrder and tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderRefuel and M28UnitInfo.IsUnitValid(tLastOrder[M28Orders.subrefoOrderUnitTarget]) and (not(EntityCategoryContains(M28UnitInfo.refCategoryAirAA, oUnit.UnitId)) or oUnit:GetFuelRatio() <= iLowFuelThreshold + 0.25 or not(M28UnitInfo.IsUnitValid(tLastOrder[M28Orders.subrefoOrderUnitTarget])) or M28Utilities.GetDistanceBetweenPositions(tLastOrder[M28Orders.subrefoOrderUnitTarget]:GetPosition(), oUnit:GetPosition()) <= 150 or M28UnitInfo.GetUnitHealthPercent(oUnit) <= iLowHealthThreshold + 0.1 or oUnit[M28UnitInfo.refbProjectilesMeanShouldRefuel]) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Unit is already on its way to refuel so will treat as being in use, unit health percent='..M28UnitInfo.GetUnitHealthPercent(oUnit)..'; Unit fuel percent='..oUnit:GetFuelRatio()..'; Dist to refuel target='..M28Utilities.GetDistanceBetweenPositions(tLastOrder[M28Orders.subrefoOrderUnitTarget]:GetPosition(), oUnit:GetPosition())) end
                                --Unit on its way to refuel
                                table.insert(tInUseUnits, oUnit)
                                --Also update unit orders in case something has happened so next cycle it will try again
                                M28Orders.UpdateRecordedOrders(oUnit)
                                --Torp bombers and bombers - treat as unavailable if are targeting a valid unit that is on land (bomber) or water (torp bomber) and are close to it (within 90); for bombers also consider ground attacks simialr to unit targets
                            elseif tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueGroundAttack and (tLastOrder[M28Orders.subrefoOrderUnitTarget] and not(M28UnitInfo.IsUnitValid(tLastOrder[M28Orders.subrefoOrderUnitTarget]))) then
                                if bDebugMessages == true then LOG(sFunctionRef..' Unit with ground attack order was linked to target that is dead so will be made available') end
                                table.insert(tAvailableUnits, oUnit)
                            elseif (tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueGroundAttack and tLastOrder[M28Orders.subreftOrderPosition] and M28Utilities.GetDistanceBetweenPositions(tLastOrder[M28Orders.subreftOrderPosition], oUnit:GetPosition()) <= 90) or (oExistingValidAttackTarget and ( (EntityCategoryContains(M28UnitInfo.refCategoryTorpBomber, oUnit.UnitId) and (M28Map.GetWaterZoneFromPosition(tLastOrder[M28Orders.subrefoOrderUnitTarget]:GetPosition()) or 0) > 0) or (EntityCategoryContains(M28UnitInfo.refCategoryBomber, oUnit.UnitId) and not(M28UnitInfo.IsUnitUnderwater(tLastOrder[M28Orders.subrefoOrderUnitTarget])))) and M28Utilities.GetDistanceBetweenPositions(tLastOrder[M28Orders.subrefoOrderUnitTarget]:GetPosition(), oUnit:GetPosition()) <= 90) then
                                table.insert(tInUseUnits, oUnit)
                                M28Orders.UpdateRecordedOrders(oUnit)
                                if bDebugMessages == true then LOG(sFunctionRef..': Have bomber or torp bomber with valid last attack target that is relatively nearby') end
                                --[[elseif tLastOrder and tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderUnloadTransport then
                                table.insert(tInUseUnits, oUnit)
                                oUnit[refiEngisWanted] = 0
                                M28Orders.UpdateRecordedOrders(oUnit)--]]
                            else
                                --Bombers - remove any assigned strike damage; AirAA - still treat as available
                                if oExistingValidAttackTarget then
                                    if EntityCategoryContains(M28UnitInfo.refCategoryBomber + M28UnitInfo.refCategoryTorpBomber, oUnit.UnitId) then
                                        RemoveAssignedAttacker(oExistingValidAttackTarget, oUnit)
                                    end
                                end

                                --AirAA with a combat target that it is near - add to special logic table (as will need to consider updating its move order)
                                if oExistingValidAttackTarget and EntityCategoryContains(M28UnitInfo.refCategoryAirAA, oUnit.UnitId) and IsAirUnitInCombat(oUnit, iTeam) then
                                    table.insert(tSpecialLogicUnits, oUnit)
                                    if bDebugMessages == true then LOG(sFunctionRef..': AirAA unit is in combat') end
                                else
                                    bSendUnitForRefueling = false
                                    --Consider if want to send unit to refuel
                                    if not(EntityCategoryContains(categories.CANNOTUSEAIRSTAGING + categories.EXPERIMENTAL, oUnit.UnitId)) then
                                        if oUnit[M28UnitInfo.refbProjectilesMeanShouldRefuel] then
                                            bSendUnitForRefueling = true
                                            if bDebugMessages == true then LOG(sFunctionRef..': Unit is expecting to take damage from projectiles so will send for refueling') end
                                        else
                                            if oUnit.GetFuelRatio then
                                                iFuelPercent = oUnit:GetFuelRatio()
                                                if bDebugMessages == true then LOG(sFunctionRef..': Unit fuel ratio='..iFuelPercent) end
                                            else iFuelPercent = 1
                                            end
                                            if iFuelPercent < iLowFuelThreshold and iFuelPercent >= 0 then
                                                --Send unit to refuel unless it is attacking a nearby enemy and isnt a gunship
                                                if EntityCategoryContains(M28UnitInfo.refCategoryGunship, oUnit.UnitId) or not(IsAirUnitInCombat(oUnit, iTeam)) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Unit has low fuel so will send for refueling') end
                                                    bSendUnitForRefueling = true
                                                end
                                            else
                                                iHealthPercent = M28UnitInfo.GetUnitHealthPercent(oUnit)
                                                if iHealthPercent <= iLowHealthThreshold then
                                                    if EntityCategoryContains(M28UnitInfo.refCategoryGunship, oUnit.UnitId) or not(IsAirUnitInCombat(oUnit, iTeam)) then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Unit has low health so will send to refuel') end
                                                        bSendUnitForRefueling = true
                                                    end
                                                elseif iHealthPercent <= 0.75 and oUnit[M28UnitInfo.refiHealthSecondLastCheck] and EntityCategoryContains(M28UnitInfo.refCategoryGunship, oUnit.UnitId) then
                                                    --Gunships - send for refueling if expect to be below 55% health soon, based on how much our health has decreased
                                                    if (oUnit:GetHealth() - (oUnit[M28UnitInfo.refiHealthSecondLastCheck] - oUnit:GetHealth())) / oUnit:GetMaxHealth() <= iLowHealthThreshold then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Gunship health is getting low and expected to drop below the low health threshold soon so will refuel') end
                                                        bSendUnitForRefueling = true
                                                    end
                                                end
                                            end
                                        end
                                    elseif EntityCategoryContains(M28UnitInfo.refCategoryGunship * categories.EXPERIMENTAL + M28UnitInfo.refCategoryCzar, oUnit.UnitId) then
                                        --If have shield but its health is low then send for refueling
                                        local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, false)
                                        if iMaxShield > 0 and iCurShield <= iMaxShield * 0.15 then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Unit has low shield so will send to recharge') end
                                            bSendUnitForRefueling = true
                                        elseif iMaxShield == 0 then
                                            local iHealthRegen = M28UnitInfo.GetUnitHealthRegenRate(oUnit)
                                            local iLowHealthThreshold = 0.2
                                            if iHealthRegen >= 50 then iLowHealthThreshold = 0.3 end
                                            if oUnit[M28UnitInfo.refbWantToHealUp] then
                                                iLowHealthThreshold = math.max(0.5, iLowHealthThreshold)
                                            end
                                            if M28UnitInfo.GetUnitHealthPercent(oUnit) <= iLowHealthThreshold then
                                                bSendUnitForRefueling = true
                                                oUnit[M28UnitInfo.refbWantToHealUp] = true
                                                if bDebugMessages == true then LOG(sFunctionRef..': Unit low health so want it to try and heal up') end
                                            else
                                                oUnit[M28UnitInfo.refbWantToHealUp] = nil
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': iHealthRegen='..iHealthRegen..'; iLowHealthThreshold='..iLowHealthThreshold) end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': iCurShield='..iCurShield..'; iMaxShield='..iMaxShield..'; bSendUnitForRefueling='..tostring(bSendUnitForRefueling)) end
                                    else
                                        if EntityCategoryContains(M28UnitInfo.refCategoryTransport, oUnit.UnitId) and oUnit:GetFuelRatio() < iLowFuelThreshold and (oUnit:GetFuelRatio() < 0.05 or M28Utilities.IsTableEmpty(oUnit:GetCargo())) then
                                            bSendUnitForRefueling = true --will unload and ctrl-K transports that are low on fuel
                                        end
                                    end

                                    if bDebugMessages == true then LOG(sFunctionRef..': bSendUnitForRefueling='..tostring(bSendUnitForRefueling or false)) end
                                    if bSendUnitForRefueling then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Unit will be sent for refueling') end
                                        table.insert(tUnitsForRefueling, oUnit)
                                    else
                                        --Unit is available
                                        if M28UnitInfo.GetUnitLifetimeCount(oUnit) == 1 and EntityCategoryContains(M28UnitInfo.refCategoryBomber * categories.TECH1, oUnit.UnitId) then
                                            table.insert(tSpecialLogicUnits, oUnit)
                                        else
                                            if bDebugMessages == true then LOG(sFunctionRef..' Unit will be made available') end
                                            table.insert(tAvailableUnits, oUnit)
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef..': End of code, is tAvailableUnits empty='..tostring(M28Utilities.IsTableEmpty(tAvailableUnits))..'; Is tUnitsForRefueling empty='..tostring(M28Utilities.IsTableEmpty(tUnitsForRefueling))..'; Is tInUseUnits empty='..tostring(M28Utilities.IsTableEmpty(tInUseUnits)))
        if M28Utilities.IsTableEmpty(tUnitsForRefueling) == false then
            for iUnit, oUnit in tUnitsForRefueling do
                LOG(sFunctionRef..': Units for refueling '..iUnit..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    return tAvailableUnits, tUnitsForRefueling, tInUseUnits, tSpecialLogicUnits
end

function GetRallyPointValueOfLandZone(iTeam, tLZData, tLZTeamData, iPlateau)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetRallyPointValueOfLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCurAAValue
    local iCurFactor = 1
    if tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] or tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then iCurFactor = 0.5 end
    iCurAAValue = (tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0) * iCurFactor - (tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) * 4 - (tLZTeamData[M28Map.refiEnemyAirAAThreat] or 0)
    --Factor in adjacent threat
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
            local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
            iCurAAValue = iCurAAValue - (tAdjLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) * 2
        end
    end
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
        local iAdjPond, iAdjWaterZone
        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
            iAdjWaterZone = tSubtable[M28Map.subrefAWZRef]
            iAdjPond = M28Map.tiPondByWaterZone[iAdjWaterZone]
            local tAdjWZTeamData = M28Map.tPondDetails[iAdjPond][M28Map.subrefPondWaterZones][iAdjWaterZone][M28Map.subrefWZTeamData][iTeam]
            iCurAAValue = iCurAAValue - tAdjWZTeamData[M28Map.subrefWZThreatEnemyAA] * 2
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iCurAAValue
end
function GetRallyPointValueOfWaterZone(iTeam, tWZData, tWZTeamData)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetRallyPointValueOfWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCurAAValue
    local iCurFactor = 1
    if tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then iCurFactor = 0.5 end
    iCurAAValue = (tWZTeamData[M28Map.subrefWZThreatAlliedAA] or 0) * iCurFactor - (tWZTeamData[M28Map.subrefWZThreatEnemyAA] or 0) * 4 - (tWZTeamData[M28Map.refiEnemyAirAAThreat] or 0)
    --Factor in adjacent threat
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
        for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
            local tAdjLZTeamData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefWPlatAndLZNumber][1]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefWPlatAndLZNumber][2]][M28Map.subrefLZTeamData][iTeam]
            iCurAAValue = iCurAAValue - (tAdjLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) * 2
        end
    end
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
        local iAdjPond
        for iEntry, iAdjWaterZone in tWZData[M28Map.subrefWZAdjacentWaterZones] do
            iAdjPond = M28Map.tiPondByWaterZone[iAdjWaterZone]
            local tAdjWZTeamData = M28Map.tPondDetails[iAdjPond][M28Map.subrefPondWaterZones][iAdjWaterZone][M28Map.subrefWZTeamData][iTeam]
            iCurAAValue = iCurAAValue - tAdjWZTeamData[M28Map.subrefWZThreatEnemyAA] * 2
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iCurAAValue
end

function IsThereAAInWaterZone(tWZTeamData, bIgnoreAirAA, iGroundAAThreatThreshold, iAirAAThreatThreshold)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsThereAAInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    -- -1 groundAA threat threshold means infinite
    if ((iGroundAAThreatThreshold or 0) >= 0 and (tWZTeamData[M28Map.subrefWZThreatEnemyAA] or 0) > (iGroundAAThreatThreshold or 0)) or (not(bIgnoreAirAA) and (tWZTeamData[M28Map.refiEnemyAirAAThreat] or 0) >= math.max(40, (iAirAAThreatThreshold or 0) + (tWZTeamData[M28Map.subrefWZThreatAlliedAA] or 0) * 0.5)) then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function IsThereAAInLandZone(tLZTeamData, bIgnoreAirAA, iGroundAAThreatThreshold, iAirAAThreatThreshold)
    -- -1 groundAA threat threshold means infinite
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsThereAAInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if ((iGroundAAThreatThreshold or 0) >= 0 and (tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) > (iGroundAAThreatThreshold or 0)) or (not(bIgnoreAirAA) and (tLZTeamData[M28Map.refiEnemyAirAAThreat] or 0) >= math.max(40, (iAirAAThreatThreshold or 0) + (tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0) * 0.5)) then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function CalculateAirTravelPath(iStartPlateauOrZero, iStartLandOrWaterZone, iEndPlateauOrZero, iEndLandOrWaterZone)
    --Plateau refs should be 0 if dealing with a water zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CalculateAirTravelPath'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; iStartPlateauOrZero='..(iStartPlateauOrZero or 'nil')..'; iStartLandOrWaterZone='..(iStartLandOrWaterZone or 'nil')..'; iEndPlateauOrZero='..(iEndPlateauOrZero or 'nil')..'; iEndLandOrWaterZone='..(iEndLandOrWaterZone or 'nil')..'; Is tAirZonePathingFromZoneToZone[iStartPlateauOrZero][iStartLandOrWaterZone][iEndPlateauOrZero][iEndLandOrWaterZone] nil='..tostring(tAirZonePathingFromZoneToZone[iStartPlateauOrZero][iStartLandOrWaterZone][iEndPlateauOrZero][iEndLandOrWaterZone] == nil)) end

    if not(tAirZonePathingFromZoneToZone[iStartPlateauOrZero][iStartLandOrWaterZone][iEndPlateauOrZero][iEndLandOrWaterZone]) then
        --M28Profiler.FunctionProfiler(sFunctionRef..': TabSetup', M28Profiler.refProfilerStart)
        if not(tAirZonePathingFromZoneToZone[iStartPlateauOrZero]) then tAirZonePathingFromZoneToZone[iStartPlateauOrZero] = {} end
        if not(tAirZonePathingFromZoneToZone[iStartPlateauOrZero][iStartLandOrWaterZone]) then tAirZonePathingFromZoneToZone[iStartPlateauOrZero][iStartLandOrWaterZone] = {} end
        if not(tAirZonePathingFromZoneToZone[iStartPlateauOrZero][iStartLandOrWaterZone]) then tAirZonePathingFromZoneToZone[iStartPlateauOrZero][iStartLandOrWaterZone] = {} end
        if not(tAirZonePathingFromZoneToZone[iStartPlateauOrZero][iStartLandOrWaterZone][iEndPlateauOrZero]) then tAirZonePathingFromZoneToZone[iStartPlateauOrZero][iStartLandOrWaterZone][iEndPlateauOrZero] = {} end
        --M28Profiler.FunctionProfiler(sFunctionRef..': TabSetup', M28Profiler.refProfilerEnd)

        --Do we already have the path in the opposite direction?
        if bDebugMessages == true then LOG(sFunctionRef..': Do we already have pathing in the opposite direction? Is tAirZonePathingFromZoneToZone[iEndPlateauOrZero][iEndLandOrWaterZone][iStartPlateauOrZero][iStartLandOrWaterZone] nil='..tostring(tAirZonePathingFromZoneToZone[iEndPlateauOrZero][iEndLandOrWaterZone][iStartPlateauOrZero][iStartLandOrWaterZone] == nil)) end
        if M28Utilities.IsTableEmpty(tAirZonePathingFromZoneToZone[iEndPlateauOrZero][iEndLandOrWaterZone][iStartPlateauOrZero][iStartLandOrWaterZone]) == false then
            --M28Profiler.FunctionProfiler(sFunctionRef..': TabMirror', M28Profiler.refProfilerStart)
            if bDebugMessages == true then LOG(sFunctionRef..': Will use pathing in opposite direction,='..repru(tAirZonePathingFromZoneToZone[iEndPlateauOrZero][iEndLandOrWaterZone][iStartPlateauOrZero][iStartLandOrWaterZone])) end
            tAirZonePathingFromZoneToZone[iStartPlateauOrZero][iStartLandOrWaterZone][iEndPlateauOrZero][iEndLandOrWaterZone] = tAirZonePathingFromZoneToZone[iEndPlateauOrZero][iEndLandOrWaterZone][iStartPlateauOrZero][iStartLandOrWaterZone]

            --M28Profiler.FunctionProfiler(sFunctionRef..': TabMirror', M28Profiler.refProfilerEnd)
        else
            M28Profiler.FunctionProfiler(sFunctionRef..': Detail', M28Profiler.refProfilerStart)
            tAirZonePathingFromZoneToZone[iStartPlateauOrZero][iStartLandOrWaterZone][iEndPlateauOrZero][iEndLandOrWaterZone] = {} --need here not above or else we end up thinking there is an entry already

            --Determine the path - move in a straight line from the start point towards the end point in periodic intervals, checking for the zones to include
            local tiLandZonesByPlateau = {}
            local tiWaterZones = {}
            local tStart
            local tStartLZOrWZData
            if iStartPlateauOrZero > 0 then
                --Dealing with land zone
                tStartLZOrWZData = M28Map.tAllPlateaus[iStartPlateauOrZero][M28Map.subrefPlateauLandZones][iStartLandOrWaterZone]
                tStart = tStartLZOrWZData[M28Map.subrefMidpoint]
                tiLandZonesByPlateau[iStartPlateauOrZero] = {}
                tiLandZonesByPlateau[iStartPlateauOrZero][iStartLandOrWaterZone] = true
            else
                --Dealing with water zone
                tStartLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iStartLandOrWaterZone]][M28Map.subrefPondWaterZones][iStartLandOrWaterZone]
                tStart = tStartLZOrWZData[M28Map.subrefMidpoint]
                tiWaterZones[iStartLandOrWaterZone] = true
            end
            local tEnd
            if iEndPlateauOrZero > 0 then
                --Dealing with land zone
                tEnd = M28Map.tAllPlateaus[iEndPlateauOrZero][M28Map.subrefPlateauLandZones][iEndLandOrWaterZone][M28Map.subrefMidpoint]
                tiLandZonesByPlateau[iEndPlateauOrZero] = {}
                tiLandZonesByPlateau[iEndPlateauOrZero][iEndLandOrWaterZone] = true
            else
                --Dealing with water zone
                tEnd = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iEndLandOrWaterZone]][M28Map.subrefPondWaterZones][iEndLandOrWaterZone][M28Map.subrefMidpoint]
                tiWaterZones[iEndLandOrWaterZone] = true
            end
            local iAngleStartToEnd = M28Utilities.GetAngleFromAToB(tStart, tEnd)
            local iSearchInterval = 15
            local iSearchDistance = math.floor(M28Utilities.GetDistanceBetweenPositions(tStart, tEnd) / iSearchInterval) * iSearchInterval
            local iMaxCycle = math.max(1, iSearchDistance / iSearchInterval)
            local iCurPlateau, iCurLandZone, iCurWaterZone, iCurSegmentX, iCurSegmentZ
            local iSidewaysDistance = 100 --tried with 65 and were ignoring LZ that had nearby enemy AirAA
            local iBackupSidewaysDistance = 70 --For land zones - in addition to checking adjacent zones will also check this far away
            local iSidewaysSegmentDistance = math.ceil(iSidewaysDistance / M28Map.iLandZoneSegmentSize)
            local iSidewaysPlateauOrZero, iSidewaysZone
            local bIncludeMinorPlateaus = true
            if M28Map.iPlateauCount >= 500 then bIncludeMinorPlateaus = false end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iStartPlateauOrZero='..iStartPlateauOrZero..'; iStartLandOrWaterZone='..iStartLandOrWaterZone..'; iEndPlateauOrZero='..iEndPlateauOrZero..'; iEndLandOrWaterZone='..iEndLandOrWaterZone..'; iSearchDistance='..iSearchDistance..'; iSidewaysSegmentDistance='..iSidewaysSegmentDistance..'; iAngleStartToEnd='..iAngleStartToEnd..'; iMaxCycle='..iMaxCycle) end
            if iSearchDistance > 0 then
                for iCycle = 0, iMaxCycle, 1 do
                    local tPositionAlongPath = M28Utilities.MoveInDirection(tStart, iAngleStartToEnd, iCycle * iSearchInterval, true, false, false)
                    iCurPlateau, iCurLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tPositionAlongPath)
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': tPositionAlongPath='..repru(tPositionAlongPath)..'; iCurPlateau='..(iCurPlateau or 'nil')..'; iCurLandZone='..(iCurLandZone or 'nil')..'; Waterzonebyposition='..(M28Map.GetWaterZoneFromPosition(tPositionAlongPath) or 'nil'))
                        M28Utilities.DrawLocation(tPositionAlongPath)
                    end
                    if (iCurPlateau or 0) > 0 and (bIncludeMinorPlateaus or not(M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefbMinorPlateau])) then
                        if (iCurLandZone or 0) > 0 then
                            if not(tiLandZonesByPlateau[iCurPlateau]) then tiLandZonesByPlateau[iCurPlateau] = {} end
                            tiLandZonesByPlateau[iCurPlateau][iCurLandZone] = true
                            --Add any adjacent land zones or water zones if their min/max would get within iSidewaysDistance of here
                            local tBaseLZData = M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLandZone]
                            --If we consider adjacent land zones are there any near to tPositionAlongPath?
                            iCurSegmentX, iCurSegmentZ = M28Map.GetPathingSegmentFromPosition(tPositionAlongPath)
                            if M28Utilities.IsTableEmpty(tBaseLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                for iEntry, iAdjLZ in tBaseLZData[M28Map.subrefLZAdjacentLandZones] do
                                    local tAdjLZ = M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                                    --If draw a square around the land zone, based in segments, do we come within iSidewaysSegmentDistance of this?
                                    if iCurSegmentX >= tAdjLZ[M28Map.subrefLZMinSegX] - iSidewaysSegmentDistance and iCurSegmentX <= tAdjLZ[M28Map.subrefLZMaxSegX] + iSidewaysSegmentDistance
                                            and iCurSegmentZ >= tAdjLZ[M28Map.subrefLZMinSegZ] - iSidewaysSegmentDistance and iCurSegmentZ <= tAdjLZ[M28Map.subrefLZMaxSegZ] + iSidewaysSegmentDistance then
                                        --Are near enough, so include this LZ
                                        tiLandZonesByPlateau[iCurPlateau][iAdjLZ] = true
                                    end
                                end
                            end

                            --Do similar for water zones
                            if M28Utilities.IsTableEmpty(tBaseLZData[M28Map.subrefAdjacentWaterZones]) == false then
                                for iEntry, tSubtable in tBaseLZData[M28Map.subrefAdjacentWaterZones] do
                                    local iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                                    local tAdjWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ]
                                    if iCurSegmentX >= tAdjWZData[M28Map.subrefWZMinSegX] - iSidewaysSegmentDistance and iCurSegmentX <= tAdjWZData[M28Map.subrefWZMaxSegX] + iSidewaysSegmentDistance
                                            and iCurSegmentZ >= tAdjWZData[M28Map.subrefWZMinSegZ] - iSidewaysSegmentDistance and iCurSegmentZ <= tAdjWZData[M28Map.subrefWZMaxSegZ] + iSidewaysSegmentDistance then
                                        --Are near enough, so include this WZ
                                        tiWaterZones[iAdjWZ] = true
                                    end
                                end
                            end
                        else
                            iCurWaterZone = M28Map.GetWaterZoneFromPosition(tPositionAlongPath)
                            if bDebugMessages == true then LOG(sFunctionRef..': tPositionAlongPath='..repru(tPositionAlongPath)..'; iCurWaterZone='..(iCurWaterZone or 'nil')..'; iCycle='..iCycle..'; tiWaterZones[iCurWaterZone]='..tostring((tiWaterZones[iCurWaterZone] or false))) end
                            if (iCurWaterZone or 0) > 0 then
                                tiWaterZones[iCurWaterZone] = true
                                --If we consider adjacent land zones are there any near to tPositionAlongPath?
                                local tBaseWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurWaterZone]][M28Map.subrefPondWaterZones][iCurWaterZone]
                                iCurSegmentX, iCurSegmentZ = M28Map.GetPathingSegmentFromPosition(tPositionAlongPath)
                                if bDebugMessages == true then LOG(sFunctionRef..': is table of adjacent land zones empty='..tostring(M28Utilities.IsTableEmpty(tBaseWZData[M28Map.subrefAdjacentLandZones]))..'; is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tBaseWZData[M28Map.subrefWZAdjacentWaterZones]))) end
                                if M28Utilities.IsTableEmpty(tBaseWZData[M28Map.subrefAdjacentLandZones]) == false then
                                    for iEntry, tSubtable in tBaseWZData[M28Map.subrefAdjacentLandZones] do
                                        local iAdjPlateau = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                                        local iAdjLZ = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                                        local tAdjLZ = M28Map.tAllPlateaus[iAdjPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                                        --If draw a square around the land zone, based in segments, do we come within iSidewaysSegmentDistance of this?
                                        if bDebugMessages == true then LOG(sFunctionRef..': iAdjLZ='..(iAdjLZ or 'nil')..'; iAdjPlateau='..(iAdjPlateau or 'nil')..'; iCurSegmentX='..iCurSegmentX..'; iCurSegmentZ='..iCurSegmentZ..'; tAdjLZ[M28Map.subrefLZMinSegX]='..tAdjLZ[M28Map.subrefLZMinSegX]..'; tAdjLZ[M28Map.subrefLZMaxSegX]='..tAdjLZ[M28Map.subrefLZMaxSegX]..'; tAdjLZ[M28Map.subrefLZMinSegZ]='..tAdjLZ[M28Map.subrefLZMinSegZ]..'; tAdjLZ[M28Map.subrefLZMaxSegZ]='..tAdjLZ[M28Map.subrefLZMaxSegZ]) end
                                        if iCurSegmentX >= tAdjLZ[M28Map.subrefLZMinSegX] - iSidewaysSegmentDistance and iCurSegmentX <= tAdjLZ[M28Map.subrefLZMaxSegX] + iSidewaysSegmentDistance
                                                and iCurSegmentZ >= tAdjLZ[M28Map.subrefLZMinSegZ] - iSidewaysSegmentDistance and iCurSegmentZ <= tAdjLZ[M28Map.subrefLZMaxSegZ] + iSidewaysSegmentDistance then
                                            --Are near enough, so include this LZ
                                            if not(tiLandZonesByPlateau[iAdjPlateau]) then tiLandZonesByPlateau[iAdjPlateau] = {} end
                                            tiLandZonesByPlateau[iAdjPlateau][iAdjLZ] = true
                                            if bDebugMessages == true then LOG(sFunctionRef..': Including iAdjLZ='..iAdjLZ..' in the table of near enough land zones by plateau') end
                                        elseif bDebugMessages == true then LOG(sFunctionRef..': iAdjLZ '..iAdjLZ..' is too far away so wont include')
                                        end
                                    end
                                end
                                --Do similar for water zones
                                if M28Utilities.IsTableEmpty(tBaseWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                                    for iEntry, iAdjWZ in tBaseWZData[M28Map.subrefWZAdjacentWaterZones] do
                                        local tAdjWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ]
                                        if bDebugMessages == true then LOG(sFunctionRef..': iAdjWZ='..(iAdjWZ or 'nil')..'; iCurSegmentX='..iCurSegmentX..'; iCurSegmentZ='..iCurSegmentZ..'; tAdjWZData[M28Map.subrefWZMinSegX]='..tAdjWZData[M28Map.subrefWZMinSegX]..'; tAdjWZData[M28Map.subrefWZMaxSegX]='..tAdjWZData[M28Map.subrefWZMaxSegX]..'; tAdjWZData[M28Map.subrefWZMinSegZ]='..tAdjWZData[M28Map.subrefWZMinSegZ]..'; tAdjWZData[M28Map.subrefWZMaxSegZ]='..tAdjWZData[M28Map.subrefWZMaxSegZ]) end
                                        if iCurSegmentX >= tAdjWZData[M28Map.subrefWZMinSegX] - iSidewaysSegmentDistance and iCurSegmentX <= tAdjWZData[M28Map.subrefWZMaxSegX] + iSidewaysSegmentDistance
                                                and iCurSegmentZ >= tAdjWZData[M28Map.subrefWZMinSegZ] - iSidewaysSegmentDistance and iCurSegmentZ <= tAdjWZData[M28Map.subrefWZMaxSegZ] + iSidewaysSegmentDistance then
                                            --Are near enough, so include this WZ
                                            tiWaterZones[iAdjWZ] = true
                                        end
                                    end
                                end
                            end
                        end
                    end
                    --Backup - also check for potentially further away land zones as sometimes can have a thin LZ adjacent to us meaning the other one that is nearby doesnt get considered (not such an issue for water zones given their size)
                    for iSidewaysAngleAdjust = -90, 90, 180 do
                        local tNearbySideways = M28Utilities.MoveInDirection(tPositionAlongPath, iAngleStartToEnd + iSidewaysAngleAdjust, iBackupSidewaysDistance, true, false, false)
                        if M28Conditions.IsLocationInPlayableArea(tNearbySideways) then
                            if bDebugMessages == true then LOG(sFunctionRef..': tPositionAlongPath='..repru(tPositionAlongPath)..'; Angle='..iAngleStartToEnd + iSidewaysAngleAdjust..'; iBackupSidewaysDistance='..iBackupSidewaysDistance..'; tNearbySideways='..repru(tNearbySideways)..'; Playable area='..repru(M28Map.rMapPlayableArea)) end
                            iSidewaysPlateauOrZero, iSidewaysZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tNearbySideways)
                            if bDebugMessages == true then LOG(sFunctionRef..': Checking sideways points, iSidewaysAngleAdjust='..iSidewaysAngleAdjust..'; iSidewaysPlateauOrZero='..(iSidewaysPlateauOrZero or 'nil')..'; iSidewaysZone='..(iSidewaysZone or 'nil')) end
                            --Only include land zones (as water zones are much larger)
                            if (iSidewaysPlateauOrZero or 0) > 0 and (iSidewaysZone or 0) > 0 and (bIncludeMinorPlateaus or not(M28Map.tAllPlateaus[iSidewaysPlateauOrZero][M28Map.subrefbMinorPlateau])) then
                                if not(tiLandZonesByPlateau[iSidewaysPlateauOrZero]) then tiLandZonesByPlateau[iSidewaysPlateauOrZero] = {} end
                                tiLandZonesByPlateau[iSidewaysPlateauOrZero][iSidewaysZone] = true
                            end
                        end
                    end
                end
            else
                --E.g. if are trying to get the pathing around this particular zone - just include all adjacent zones in that case
                iCurSegmentX, iCurSegmentZ = M28Map.GetPathingSegmentFromPosition(tStartLZOrWZData[M28Map.subrefMidpoint])
                if iStartPlateauOrZero == 0 then
                    --Dealing with water zone - include all adjacent land and water (ignore distance check) - want to use similar method to above to avoid cases where we include far more zones when re reach the target LZ/WZ than if we are appraoching it (which would lead to gunships aborting the attack and dying while doing nothing)
                    if M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefAdjacentLandZones]) == false then
                        for iEntry, tSubtable in tStartLZOrWZData[M28Map.subrefAdjacentLandZones] do
                            local iAdjPlateau = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                            local iAdjLZ = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                            local tAdjLZ = M28Map.tAllPlateaus[iAdjPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                            --If draw a square around the land zone, based in segments, do we come within iSidewaysSegmentDistance of this?
                            if bDebugMessages == true then LOG(sFunctionRef..': iAdjLZ='..(iAdjLZ or 'nil')..'; iAdjPlateau='..(iAdjPlateau or 'nil')..'; iCurSegmentX='..iCurSegmentX..'; iCurSegmentZ='..iCurSegmentZ..'; tAdjLZ[M28Map.subrefLZMinSegX]='..tAdjLZ[M28Map.subrefLZMinSegX]..'; tAdjLZ[M28Map.subrefLZMaxSegX]='..tAdjLZ[M28Map.subrefLZMaxSegX]..'; tAdjLZ[M28Map.subrefLZMinSegZ]='..tAdjLZ[M28Map.subrefLZMinSegZ]..'; tAdjLZ[M28Map.subrefLZMaxSegZ]='..tAdjLZ[M28Map.subrefLZMaxSegZ]) end
                            if iCurSegmentX >= tAdjLZ[M28Map.subrefLZMinSegX] - iSidewaysSegmentDistance and iCurSegmentX <= tAdjLZ[M28Map.subrefLZMaxSegX] + iSidewaysSegmentDistance
                                    and iCurSegmentZ >= tAdjLZ[M28Map.subrefLZMinSegZ] - iSidewaysSegmentDistance and iCurSegmentZ <= tAdjLZ[M28Map.subrefLZMaxSegZ] + iSidewaysSegmentDistance then
                                --Are near enough, so include this LZ
                                if not(tiLandZonesByPlateau[iAdjPlateau]) then tiLandZonesByPlateau[iAdjPlateau] = {} end
                                tiLandZonesByPlateau[iAdjPlateau][iAdjLZ] = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Including iAdjLZ='..iAdjLZ..' in the table of near enough land zones by plateau') end
                            elseif bDebugMessages == true then LOG(sFunctionRef..': iAdjLZ '..iAdjLZ..' is too far away so wont include')
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                        for iEntry, iAdjWZ in tStartLZOrWZData[M28Map.subrefWZAdjacentWaterZones] do
                            local tAdjWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ]
                            if bDebugMessages == true then LOG(sFunctionRef..': Same start and end: iAdjWZ='..(iAdjWZ or 'nil')..'; iCurSegmentX='..iCurSegmentX..'; iCurSegmentZ='..iCurSegmentZ..'; tAdjWZData[M28Map.subrefWZMinSegX]='..tAdjWZData[M28Map.subrefWZMinSegX]..'; tAdjWZData[M28Map.subrefWZMaxSegX]='..tAdjWZData[M28Map.subrefWZMaxSegX]..'; tAdjWZData[M28Map.subrefWZMinSegZ]='..tAdjWZData[M28Map.subrefWZMinSegZ]..'; tAdjWZData[M28Map.subrefWZMaxSegZ]='..tAdjWZData[M28Map.subrefWZMaxSegZ]) end
                            if iCurSegmentX >= tAdjWZData[M28Map.subrefWZMinSegX] - iSidewaysSegmentDistance and iCurSegmentX <= tAdjWZData[M28Map.subrefWZMaxSegX] + iSidewaysSegmentDistance
                                    and iCurSegmentZ >= tAdjWZData[M28Map.subrefWZMinSegZ] - iSidewaysSegmentDistance and iCurSegmentZ <= tAdjWZData[M28Map.subrefWZMaxSegZ] + iSidewaysSegmentDistance then
                                --Are near enough, so include this WZ
                                tiWaterZones[iAdjWZ] = true
                            end
                        end
                    end
                else
                    --Dealing with start and end zone that are the same (if dist between htem is 0) - so only need to consider 1 point along path
                    iCurPlateau = iStartPlateauOrZero
                    iCurLandZone = iStartLandOrWaterZone
                    if not(tiLandZonesByPlateau[iCurPlateau]) then tiLandZonesByPlateau[iCurPlateau] = {} end
                    tiLandZonesByPlateau[iCurPlateau][iCurLandZone] = true
                    --Add any adjacent land zones or water zones if their min/max would get within iSidewaysDistance of here
                    --If we consider adjacent land zones are there any near to tPositionAlongPath?
                    if M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for iEntry, iAdjLZ in tStartLZOrWZData[M28Map.subrefLZAdjacentLandZones] do
                            local tAdjLZ = M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                            --If draw a square around the land zone, based in segments, do we come within iSidewaysSegmentDistance of this?
                            if iCurSegmentX >= tAdjLZ[M28Map.subrefLZMinSegX] - iSidewaysSegmentDistance and iCurSegmentX <= tAdjLZ[M28Map.subrefLZMaxSegX] + iSidewaysSegmentDistance
                                    and iCurSegmentZ >= tAdjLZ[M28Map.subrefLZMinSegZ] - iSidewaysSegmentDistance and iCurSegmentZ <= tAdjLZ[M28Map.subrefLZMaxSegZ] + iSidewaysSegmentDistance then
                                --Are near enough, so include this LZ
                                tiLandZonesByPlateau[iCurPlateau][iAdjLZ] = true
                            end
                        end
                    end
                    --Do similar for water zones
                    if M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefAdjacentWaterZones]) == false then
                        for iEntry, tSubtable in tStartLZOrWZData[M28Map.subrefAdjacentWaterZones] do
                            local iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                            local tAdjWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ]
                            if iCurSegmentX >= tAdjWZData[M28Map.subrefWZMinSegX] - iSidewaysSegmentDistance and iCurSegmentX <= tAdjWZData[M28Map.subrefWZMaxSegX] + iSidewaysSegmentDistance
                                    and iCurSegmentZ >= tAdjWZData[M28Map.subrefWZMinSegZ] - iSidewaysSegmentDistance and iCurSegmentZ <= tAdjWZData[M28Map.subrefWZMaxSegZ] + iSidewaysSegmentDistance then
                                --Are near enough, so include this WZ
                                tiWaterZones[iAdjWZ] = true
                            end
                        end
                    end
                end
            end

            --Should now have tables of all land and water zones that come near the path from start to end; record all of these in a table
            local tBaseTableRef = tAirZonePathingFromZoneToZone[iStartPlateauOrZero][iStartLandOrWaterZone][iEndPlateauOrZero][iEndLandOrWaterZone]
            if bDebugMessages == true then LOG(sFunctionRef..': Finished calculating alnd and water zones in path, tiWaterZones='..repru(tiWaterZones)..'; tiLandZonesByPlateau='..repru(tiLandZonesByPlateau)) end
            if M28Utilities.IsTableEmpty(tiWaterZones) == false then
                tBaseTableRef[subreftWaterZonesInPath] = {}
                for iWaterZone, bIncluded in tiWaterZones do
                    table.insert(tBaseTableRef[subreftWaterZonesInPath], iWaterZone)
                end
            end
            if M28Utilities.IsTableEmpty(tiLandZonesByPlateau) == false then
                tBaseTableRef[subreftPlateauAndLandZonesInPath] = {}
                for iPlateau, tLandZones in tiLandZonesByPlateau do
                    for iLandZone, bIncluded in tLandZones do
                        table.insert(tBaseTableRef[subreftPlateauAndLandZonesInPath], {iPlateau, iLandZone})
                    end
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef..': Detail', M28Profiler.refProfilerEnd)

            if bDebugMessages == true then LOG(sFunctionRef..': Finished updating tBaseTableRef, WaterZonesInPath='..repru(tBaseTableRef[subreftWaterZonesInPath])..'; Land zones in path='..repru(tBaseTableRef[subreftPlateauAndLandZonesInPath])) end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Finished calculating path, tAirZonePathingFromZoneToZone[iStartPlateauOrZero][iStartLandOrWaterZone][iEndPlateauOrZero][iEndLandOrWaterZone]='..repru(tAirZonePathingFromZoneToZone[iStartPlateauOrZero][iStartLandOrWaterZone][iEndPlateauOrZero][iEndLandOrWaterZone])) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function IsThereAANearLandOrWaterZone(iTeam, iPlateau, iLandOrWaterZone, bIsWaterZone, iOptionalGroundThreatThreshold, iOptionalAirAAThreatThreshold, iOptionalMaxDistToEdgeOfAdjacentZone, tOptionalStartPointForEdgeOfAdacentZone)
    --returns true if enemy has AA threat in current zone or adjacent land or water zone
    --e.g. used to determine air rally points and support locations, doesnt factor in the path
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsThereAANearLandOrWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bIsWaterZone then
        local tWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
        if IsThereAAInWaterZone(tWZTeamData, false, iOptionalGroundThreatThreshold, iOptionalAirAAThreatThreshold) then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        else
            --Cycle through every adjacent water zone
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                local bIncludeCurZone
                for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                    if not(iOptionalMaxDistToEdgeOfAdjacentZone) then bIncludeCurZone = true
                    else
                        bIncludeCurZone = M28Conditions.IsPositionCloseToZoneEdge(0, iAdjWZ, iOptionalMaxDistToEdgeOfAdjacentZone, tOptionalStartPointForEdgeOfAdacentZone)
                    end
                    if bIncludeCurZone then
                        local tAdjWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                        if IsThereAAInWaterZone(tAdjWZTeamData, false, iOptionalGroundThreatThreshold, iOptionalAirAAThreatThreshold) then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        end
                    end
                end
            end
            --Cycle through every adjacent land zone
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
                local bIncludeCurZone
                for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                    local iAdjPlateau = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                    local iAdjLZ = tSubtable[M28Map.subrefWPlatAndLZNumber][2]

                    if not(iOptionalMaxDistToEdgeOfAdjacentZone) then bIncludeCurZone = true
                    else
                        bIncludeCurZone = M28Conditions.IsPositionCloseToZoneEdge(iAdjPlateau, iAdjLZ, iOptionalMaxDistToEdgeOfAdjacentZone, tOptionalStartPointForEdgeOfAdacentZone)
                    end
                    if bIncludeCurZone then
                        local tLZTeamData = M28Map.tAllPlateaus[iAdjPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                        if IsThereAAInLandZone(tLZTeamData, false, iOptionalGroundThreatThreshold, iOptionalAirAAThreatThreshold) then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        end
                    end
                end
            end
        end
    else
        --Dealing with a land zone
        local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
        if bDebugMessages == true then LOG(sFunctionRef..': About to check if there is AA in land zone, iOptionalGroundThreatThreshold='..(iOptionalGroundThreatThreshold or 'nil')..'; iOptionalAirAAThreatThreshold='..(iOptionalAirAAThreatThreshold or 'nil')..'; tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA]='..(tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 'nil')..'; tLZTeamData[M28Map.refiEnemyAirAAThreat]='..(tLZTeamData[M28Map.refiEnemyAirAAThreat] or 'nil')..'; tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]='..(tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 'nil')) end
        if IsThereAAInLandZone(tLZTeamData, false, iOptionalGroundThreatThreshold, iOptionalAirAAThreatThreshold) then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        else
            --Cycle through every adjacent land zone
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                local bIncludeCurZone

                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    if not(iOptionalMaxDistToEdgeOfAdjacentZone) then bIncludeCurZone = true
                    else
                        bIncludeCurZone = M28Conditions.IsPositionCloseToZoneEdge(iPlateau, iAdjLZ, iOptionalMaxDistToEdgeOfAdjacentZone, tOptionalStartPointForEdgeOfAdacentZone)
                    end
                    if bIncludeCurZone then

                        local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': About to check if there is AA in land zone, iOptionalGroundThreatThreshold='..(iOptionalGroundThreatThreshold or 'nil')..'; iOptionalAirAAThreatThreshold='..(iOptionalAirAAThreatThreshold or 'nil')..'; tAdjLZTeamData[M28Map.subrefLZThreatEnemyGroundAA]='..(tAdjLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 'nil')..'; tAdjLZTeamData[M28Map.refiEnemyAirAAThreat]='..(tAdjLZTeamData[M28Map.refiEnemyAirAAThreat] or 'nil')..'; tAdjLZTeamData[M28Map.subrefLZThreatAllyGroundAA]='..(tAdjLZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 'nil')) end
                        if IsThereAAInLandZone(tAdjLZTeamData, false, iOptionalGroundThreatThreshold, iOptionalAirAAThreatThreshold) then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        end
                    end
                end
            end
            --Cycle through every adjacent water zone
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                local bIncludeCurZone

                for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                    local iAdjWZ = tSubtable[M28Map.subrefAWZRef]

                    if not(iOptionalMaxDistToEdgeOfAdjacentZone) then bIncludeCurZone = true
                    else
                        bIncludeCurZone = M28Conditions.IsPositionCloseToZoneEdge(0, iAdjWZ, iOptionalMaxDistToEdgeOfAdjacentZone, tOptionalStartPointForEdgeOfAdacentZone)
                    end
                    if bIncludeCurZone then
                        local tAdjWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                        if IsThereAAInWaterZone(tAdjWZTeamData, false, iOptionalGroundThreatThreshold, iOptionalAirAAThreatThreshold) then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function RecordOtherLandAndWaterZonesByDistance(tStartLZOrWZData, tStartMidpoint)
    --Records all other land and water zones in order of straight line distance to tStartLZOrWZData, if not already recorded
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordOtherLandAndWaterZonesByDistance'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start time='..GetGameTimeSeconds()..'; Is table of other land and water zones empty='..tostring(M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]))) end
    if M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) then
        M28Profiler.FunctionProfiler(sFunctionRef..'Detail', M28Profiler.refProfilerStart)
        tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] = {}
        local tTableToSort = {}
        --Add all land zones in the map
        local bIncludeMinorPlateaus = true
        if M28Map.iPlateauCount >= 2000 then bIncludeMinorPlateaus = false end
        for iPlateau, tPlateauData in M28Map.tAllPlateaus do
            if M28Utilities.IsTableEmpty(tPlateauData[M28Map.subrefPlateauLandZones]) == false and (bIncludeMinorPlateaus or not(tPlateauData[M28Map.subrefbMinorPlateau])) then
                --tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
                for iLandZone, tLZData in tPlateauData[M28Map.subrefPlateauLandZones] do
                    table.insert(tTableToSort, { [M28Map.subrefiPlateauOrPond] = iPlateau, [M28Map.subrefiLandOrWaterZoneRef] = iLandZone, [M28Map.subrefbIsWaterZone] = false, [M28Map.subrefiDistance] = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tStartMidpoint)})
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Size of tTableToSort after adding all land zones='..table.getn(tTableToSort)) end
        --Add all water zones in the map
        for iPond, tPondSubtable in M28Map.tPondDetails do
            for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
                table.insert(tTableToSort, { [M28Map.subrefiPlateauOrPond] = iPond, [M28Map.subrefiLandOrWaterZoneRef] = iWaterZone, [M28Map.subrefbIsWaterZone] = true, [M28Map.subrefiDistance] = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], tStartMidpoint)})
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Size of tTableToSort after adding all water zones='..table.getn(tTableToSort)) end
        --Sort the table from low to high
        for iEntry, tValue in M28Utilities.SortTableBySubtable(tTableToSort, M28Map.subrefiDistance, true) do
            table.insert(tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance], tValue)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': reprs of table after sorting='..reprs(tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance])) end
        M28Profiler.FunctionProfiler(sFunctionRef..'Detail', M28Profiler.refProfilerEnd)
    end
end

function UpdateAirRallyAndSupportPoints(iTeam, iAirSubteam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateAirRallyAndSupportPoints'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    RefreshPriorityAirDefenceTargets(iAirSubteam)
    --Get the land or water zone of the priority unit that is closest to the enemy base that is closest to the air rally point and determine if its safe as a rally point

    --Get the safest start point as a rally point:
    --If we have any air staging structures that are in a land zone with fixed AA, or a core base, with no adjacent enemy AA threat, then pick here
    --Otherwise pick the start position with the smallest number when taking adjacent enemy AA threat less current land zone friendly ground AA.
    --If no land zone start points, then pick the first water zone as a backup

    if M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains]) == false then
        local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
        local tPreferredRallyPoint
        local iPlateau, iLandZone, iWaterZone
        local iPossibleWaterZone
        local iBestRallyValue = -100000
        local iCurRallyValue
        local bDontMoveCloserToEnemyBase = false
        local oPriorityUnitBeingSupported
        local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
        for iBrain, oBrain in M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains] do
            local tStartPoint = M28Map.GetPlayerStartPosition(oBrain)
            iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tStartPoint)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering brain '..oBrain.Nickname..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; Start point='..repru(M28Map.GetPlayerStartPosition(oBrain))..'; iAirSubteam='..iAirSubteam) end
            if (iLandZone or 0) == 0 then
                iWaterZone = M28Map.GetWaterZoneFromPosition(tStartPoint)
                if bDebugMessages == true then LOG(sFunctionRef..': iWaterZone='..(iWaterZone or 'nil')) end
                if (iWaterZone or 0) > 0 then
                    local tWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone]
                    if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tWZData[M28Map.subrefMidpoint]) then
                        local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                        iCurRallyValue = GetRallyPointValueOfWaterZone(iTeam, tWZData, tWZTeamData)
                        if bDebugMessages == true then LOG(sFunctionRef..': iCurRallyValue='..(iCurRallyValue)) end
                        if iCurRallyValue > iBestRallyValue then
                            iBestRallyValue = iCurRallyValue
                            tPreferredRallyPoint = {tWZData[M28Map.subrefMidpoint][1], tWZData[M28Map.subrefMidpoint][2], tWZData[M28Map.subrefMidpoint][3]}
                            if bDebugMessages == true then LOG(sFunctionRef..': Updating preferred rally point to water zone '..iWaterZone..' start point, rally point='..repru(tPreferredRallyPoint)) end
                        end
                    end
                end
            else
                --Have a land zone - check for groundAA
                local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then
                    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][oBrain.M28Team]
                    iCurRallyValue = GetRallyPointValueOfLandZone(oBrain.M28Team, tLZData, tLZTeamData, iPlateau)
                    if iCurRallyValue > iBestRallyValue then
                        iBestRallyValue = iCurRallyValue
                        tPreferredRallyPoint = {tLZData[M28Map.subrefMidpoint][1], tLZData[M28Map.subrefMidpoint][2], tLZData[M28Map.subrefMidpoint][3]}
                        if bDebugMessages == true then LOG(sFunctionRef..': Updating preferred rally point to land zone start point '..repru(tPreferredRallyPoint)) end
                    end
                end
            end
        end
        M28Team.tAirSubteamData[iAirSubteam][M28Team.refbOrigRallyOutsidePlayableArea] = false
        if M28Utilities.IsTableEmpty(tPreferredRallyPoint) == false then
            M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint] = tPreferredRallyPoint
        else
            --Dont have a rally point, find the zone closest to our base that is in the playable area
            local oFirstBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            local tPlayerStartPosition = M28Map.GetPlayerStartPosition(oFirstBrain)
            if M28Conditions.IsLocationInPlayableArea(tPlayerStartPosition) then
                M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint] = {tPlayerStartPosition[1], tPlayerStartPosition[2], tPlayerStartPosition[3]}
            else
                local iStartPlateauOrZero, iStartLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tPlayerStartPosition)
                local tStartLZOrWZData
                if iStartPlateauOrZero == 0 then
                    tStartLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iStartLandOrWaterZone]][M28Map.subrefPondWaterZones][iStartLandOrWaterZone]
                else
                    tStartLZOrWZData = M28Map.tAllPlateaus[iStartPlateauOrZero][M28Map.subrefPlateauLandZones][iStartLandOrWaterZone]
                end
                if not(tStartLZOrWZData) then M28Utilities.ErrorHandler('unable to find a valid zone for player start position, iStartPlateauOrZero='..(iStartPlateauOrZero or 'nil')..'; iStartLandOrWaterZone='..(iStartLandOrWaterZone or 'nil')..'; Player='..(oFirstBrain.Nickname or 'nil')..' at position X'..(tPlayerStartPosition[1] or 'nil')..'Z'..(tPlayerStartPosition[3] or 'nil')) end
                if M28Conditions.IsLocationInPlayableArea(tStartLZOrWZData[M28Map.subrefMidpoint]) then
                    M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint] = {tStartLZOrWZData[M28Map.subrefMidpoint][1], tStartLZOrWZData[M28Map.subrefMidpoint][2], tStartLZOrWZData[M28Map.subrefMidpoint][3]}
                else
                    --Check if we have air staging or factory HQs anywhere on the team, and if so then set this as the air rally point
                    local oUnitAsRallyPoint
                    local iHighestLandTech = 0
                    local iCurLandTech
                    for iBrain, oBrain in M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains] do
                        local tFactoriesAndAirStaging = oBrain:GetListOfUnits(M28UnitInfo.refCategoryAllHQFactories + M28UnitInfo.refCategoryAirStaging, false, true)
                        if M28Utilities.IsTableEmpty(tFactoriesAndAirStaging) == false then

                            for iUnit, oUnit in tFactoriesAndAirStaging do
                                if EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oUnit.UnitId) then iCurLandTech = 0.5 else iCurLandTech = M28UnitInfo.GetUnitTechLevel(oUnit) end
                                if iCurLandTech > iHighestLandTech then
                                    iHighestLandTech = iCurLandTech
                                    oUnitAsRallyPoint = oUnit
                                    if iCurLandTech >= 3 then break end
                                end
                            end
                        end
                        if iCurLandTech >= 3 then break end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Does anyone on our team have an air staging faciltiy to be used as the rally point? oUnitAsRallyPoint='..(oUnitAsRallyPoint.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitAsRallyPoint) or 'nil')) end
                    if oUnitAsRallyPoint then
                        M28Team.tAirSubteamData[iAirSubteam][M28Team.refbOrigRallyOutsidePlayableArea] = oUnitAsRallyPoint:GetPosition()
                    else
                        M28Team.tAirSubteamData[iAirSubteam][M28Team.refbOrigRallyOutsidePlayableArea] = true
                        RecordOtherLandAndWaterZonesByDistance(tStartLZOrWZData, tStartLZOrWZData[M28Map.subrefMidpoint])
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of other Land and water zones by distance empty='..tostring(M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]))) end
                        if M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                            for iEntry, tSubtable in tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                                local tAltLZOrWZData
                                local iCurLZOrWZRef = tSubtable[M28Map.subrefiLandOrWaterZoneRef]
                                if tSubtable[M28Map.subrefbIsWaterZone] then
                                    tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurLZOrWZRef]][M28Map.subrefPondWaterZones][iCurLZOrWZRef]
                                else
                                    tAltLZOrWZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][iCurLZOrWZRef]
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering zone '..(iCurLZOrWZRef or 'nil')..'; Plateua or pond='..(tSubtable[M28Map.subrefiPlateauOrPond] or 'nil')..'; is water zone='..tostring(tSubtable[M28Map.subrefbIsWaterZone] or false)..'; In playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAltLZOrWZData[M28Map.subrefMidpoint]))) end
                                if M28Conditions.IsLocationInPlayableArea(tAltLZOrWZData[M28Map.subrefMidpoint]) then
                                    M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint] = {tAltLZOrWZData[M28Map.subrefMidpoint][1], tAltLZOrWZData[M28Map.subrefMidpoint][2], tAltLZOrWZData[M28Map.subrefMidpoint][3]}
                                    break
                                end
                            end
                        end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint]) then
                if M28Utilities.IsTableEmpty(tPreferredRallyPoint) then
                    tPreferredRallyPoint = {tPlayerStartPosition[1], tPlayerStartPosition[2], tPlayerStartPosition[3]}
                    M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint] = {tPlayerStartPosition[1], tPlayerStartPosition[2], tPlayerStartPosition[3]}
                    if bDebugMessages == true then LOG(sFunctionRef..': Still couldnt find preferred rally point or subrallypoint so setting to first brain start position='..repru(tPlayerStartPosition)) end
                else
                    M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint] = {tPreferredRallyPoint[1],tPreferredRallyPoint[2],tPreferredRallyPoint[3]}
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Tried finding revised rally point, M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint] after update='..repru(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint])) end

            --[[M28Air.RecordOtherLandAndWaterZonesByDistance(tLZOrWZData, tLZOrWZData[M28Map.subrefMidpoint])
            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) then
                M28Utilities.ErrorHandler('No other zones found')
            else
                for iEntry, tSubtable in tLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do--]]
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Set air rally point to rpeferred rally point for now='..repru(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint])) end

        --Support rally point - move closer to units to support (if we have any)
        local tSupportRallyPoint
        local tUnitsToProtect = {}
        if M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftACUExpAndPriorityDefenceOnSubteam]) == false then
            for iUnit, oUnit in M28Team.tAirSubteamData[iAirSubteam][M28Team.reftACUExpAndPriorityDefenceOnSubteam] do
                table.insert(tUnitsToProtect, oUnit)
            end
        end
        if M28UnitInfo.IsUnitValid(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]) then
            table.insert(tUnitsToProtect, M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship])
        end
        --[[if M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftoSpecialUnitsToProtect]) then
        for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftoSpecialUnitsToProtect] do
            table.insert(tUnitsToProtect, oUnit)
        end
    end--]]
        if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; About to get support location, is table of units to protect='..tostring(M28Utilities.IsTableEmpty(tUnitsToProtect))) end
        if M28Utilities.IsTableEmpty(tUnitsToProtect) == false then
            local iCurLZOrWZ, iCurPlateauOrZero
            local iClosestDistToEnemyBase = 100000
            local iCurDistToEnemyBase
            local tClosestMidpoint
            local tClosestBase
            for iUnit, oUnit in tUnitsToProtect do
                iCurDistToEnemyBase = 100000
                iCurPlateauOrZero, iCurLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                if bDebugMessages == true then LOG(sFunctionRef..': COnsidering unit to protect='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurPlateauOrZero='..(iCurPlateauOrZero or 'nil')..'; iCurLZOrWZ='..(iCurLZOrWZ or 'nil')..'; position='..repru(oUnit:GetPosition())) end
                if (iCurPlateauOrZero or 0) == 0 then
                    if (iCurLZOrWZ or 0) > 0 then
                        local tWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurLZOrWZ]][M28Map.subrefPondWaterZones][iCurLZOrWZ]
                        if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tWZData[M28Map.subrefMidpoint]) then
                            local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                            iCurDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], tWZTeamData[M28Map.reftClosestEnemyBase])
                            if bDebugMessages == true then LOG(sFunctionRef..': Unit is in a water zone, iCurDistToEnemyBase='..(iCurDistToEnemyBase or 'nil')..'; tWZTeamData[M28Map.reftClosestEnemyBase]='..repru(tWZTeamData[M28Map.reftClosestEnemyBase])..'; WZ midpoint='..repru(tWZData[M28Map.subrefMidpoint])) end
                            if iCurDistToEnemyBase <   iClosestDistToEnemyBase then
                                oPriorityUnitBeingSupported = oUnit
                                iClosestDistToEnemyBase = iCurDistToEnemyBase
                                tClosestMidpoint = {tWZData[M28Map.subrefMidpoint][1], tWZData[M28Map.subrefMidpoint][2], tWZData[M28Map.subrefMidpoint][3]}
                                tClosestBase = {tWZTeamData[M28Map.reftClosestFriendlyBase][1], tWZTeamData[M28Map.reftClosestFriendlyBase][2], tWZTeamData[M28Map.reftClosestFriendlyBase][3]}
                            end
                        end
                    end
                else
                    --Have a valid land zone
                    local tLZData = M28Map.tAllPlateaus[iCurPlateauOrZero][M28Map.subrefPlateauLandZones][iCurLZOrWZ]
                    if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then
                        local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Have a valid land zone, iCurLZ='..(iCurLZOrWZ or 'nil')..'; iCurPlateau='..(iCurPlateauOrZero or 'nil')..'; LZ midpoint='..repru(tLZData[M28Map.subrefMidpoint])..'; Closest enemy base='..repru(tLZTeamData[M28Map.reftClosestEnemyBase])..'; iTeam='..(iTeam or 'nil')) end
                        iCurDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase])
                        if iCurDistToEnemyBase < iClosestDistToEnemyBase then
                            oPriorityUnitBeingSupported = oUnit
                            iClosestDistToEnemyBase = iCurDistToEnemyBase
                            tClosestMidpoint = {tLZData[M28Map.subrefMidpoint][1], tLZData[M28Map.subrefMidpoint][2], tLZData[M28Map.subrefMidpoint][3]}
                            tClosestBase = {tLZTeamData[M28Map.reftClosestFriendlyBase][1], tLZTeamData[M28Map.reftClosestFriendlyBase][2], tLZTeamData[M28Map.reftClosestFriendlyBase][3]}
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..' Finished considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit position='..repru(oUnit:GetPosition())..'; iCurPlateau='..(iCurPlateauOrZero or 'nil')..'; iCurWZ='..(iCurLZOrWZ or 'nil')..'; iCurDistToEnemyBase='..(iCurDistToEnemyBase or 'nil')..'; iClosestDistToEnemyBase='..(iClosestDistToEnemyBase or 'nil')..'; tClosestMidpoint='..repru(tClosestMidpoint)) end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished going through all units to protect, tClosestMidpoint='..repru(tClosestMidpoint)) end
            local tAlternativeToZoneMidpointOverride --Used if want to be partway between base and air unit, due to zone midpoint itself being too dangerous
            if tClosestMidpoint then
                --Change the closest base if it isn't safe and we have another base that is safe
                local iBasePlateau, iBaseLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tClosestBase)
                local bBaseIsNotSafe = true
                if (iBaseLandOrWaterZone or 0) > 0 then
                    if not(IsThereAANearLandOrWaterZone(iTeam, iBasePlateau, iBaseLandOrWaterZone, iBasePlateau == 0, 0, 0)) then bBaseIsNotSafe = false end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': tClosestBase='..repru(tClosestBase)..'; bBaseIsNotSafe='..tostring(bBaseIsNotSafe)) end
                if bBaseIsNotSafe then
                    local tClosestSafeMidpoint
                    local iCurBaseDist
                    local iClosestBaseDist = 100000
                    for iBrain, oBrain in M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains] do
                        local tStartPoint = M28Map.GetPlayerStartPosition(oBrain)
                        iBasePlateau, iBaseLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tStartPoint)
                        if (iBaseLandOrWaterZone or 0) > 0 then
                            iCurBaseDist = M28Utilities.GetDistanceBetweenPositions(tStartPoint, tClosestMidpoint)
                            if iCurBaseDist < iClosestBaseDist then
                                if not(IsThereAANearLandOrWaterZone(iTeam, iBasePlateau, iBaseLandOrWaterZone, iBasePlateau == 0, 0, 0)) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Closest base is dangerous, but have a safe base at position '..repru(M28Map.GetPlayerStartPosition(oBrain))..' for M28 brain '..oBrain.Nickname) end
                                    iClosestBaseDist = iCurBaseDist
                                    tClosestSafeMidpoint = {tStartPoint[1], tStartPoint[2], tStartPoint[3]}
                                end
                            end
                        end
                    end
                    if tClosestSafeMidpoint then tClosestBase = tClosestSafeMidpoint end
                end


                --Move from the closest base to the support point until no longer find a safe land/water zone, and then abort
                local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(tClosestBase, tClosestMidpoint)
                if bDebugMessages == true then LOG(sFunctionRef..': iDistToTarget='..iDistToTarget..'; tClosestBase='..repru(tClosestBase)) end
                if iDistToTarget <= 50 then
                    --If closest base isn't safe then use rally point
                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tClosestBase)
                    local iWaterZone
                    local bClosestBaseIsSafe = true
                    if iPlateau and (iLandZone or 0) == 0 then
                        iWaterZone = M28Map.GetWaterZoneFromPosition(tClosestBase)
                        if (iWaterZone or 0) > 0 then
                            if IsThereAANearLandOrWaterZone(iTeam, iPlateau, iWaterZone, true) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering water zone for the closest base and it isnt safe') end
                                bClosestBaseIsSafe = false
                            end
                        end
                    else
                        if IsThereAANearLandOrWaterZone(iTeam, iPlateau, iLandZone, false) then
                            bClosestBaseIsSafe = false
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering land zone for the closest base and it isnt safe') end
                        end
                    end
                    if bClosestBaseIsSafe then
                        if bDebugMessages == true then LOG(sFunctionRef..': CLosest base is safe so will use as the starting point for support rally point') end
                        tSupportRallyPoint = tClosestBase
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Closest base isnt safe so will use preferred rally point as the support rally point') end
                        bDontMoveCloserToEnemyBase = true
                        tSupportRallyPoint = tPreferredRallyPoint
                    end
                else
                    local iAngleToTarget = M28Utilities.GetAngleFromAToB(tClosestBase, tClosestMidpoint)
                    local iSearchInterval = 10
                    local iRoundedDist = math.floor(iDistToTarget / iSearchInterval) * iSearchInterval
                    local tCurTarget
                    local iPrevPlateau, iPrevLandZone, iPrevWaterZone
                    local bCurTargetTooDangerous
                    local tbWaterZonesConsidered = {}
                    local tbPlateauAndLandZonesConsidered = {}
                    local iCurPlateau, iCurZone
                    local iGroundAAThreshold
                    local iAirAAThreshold
                    local bDoDetailedCheck = false
                    local iStartPlateauOrZero, iStartLandOrWaterZone
                    if tClosestBase then iStartPlateauOrZero, iStartLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tClosestBase) end
                    if not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir]) then
                        local iAirToGroundThreat = M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] + M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurBomberThreat]
                        if oPriorityUnitBeingSupported then
                            --If we are supporting a gunship or experimental air unit then have much higher thresholds
                            if iStartPlateauOrZero and iStartLandOrWaterZone then bDoDetailedCheck = true end
                            if EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oPriorityUnitBeingSupported.UnitId) and M28Utilities.IsTableEmpty(oPriorityUnitBeingSupported[M28Land.reftoAssignedMAAGuards]) == false then
                                iAirAAThreshold = math.max(3000, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] * 0.2)
                                iGroundAAThreshold = math.min(math.max(iAirToGroundThreat * 0.1,  M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] * 0.1, 1000), 3000)
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryAirToGround, oPriorityUnitBeingSupported.UnitId) then
                                local iCap = 2500
                                if not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl]) then iCap = 1500 end
                                iGroundAAThreshold = math.min(iAirToGroundThreat * 0.15,  M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] * 0.075, iCap)
                                iAirAAThreshold = math.max(iAirToGroundThreat * 0.1, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] * 1.2)
                            else
                                iGroundAAThreshold = math.min(iAirToGroundThreat * 0.05,  M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] * 0.04, 1000)
                                iAirAAThreshold = M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] * 0.05
                            end
                        elseif M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] and iAirToGroundThreat >= 3000 then
                            iGroundAAThreshold = math.min(iAirToGroundThreat * 0.08,  M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] * 0.07, 3000)
                            iAirAAThreshold = M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] * 0.1
                        end
                    end
                    local iZoneGroundAAThreshold = (iGroundAAThreshold or 0) * 0.1
                    local iZoneAirAAThreshold = (iAirAAThreshold or 0) * 0.2
                    for iDist = iSearchInterval, iRoundedDist, iSearchInterval do
                        bCurTargetTooDangerous = false
                        tCurTarget = M28Utilities.MoveInDirection(tClosestBase, iAngleToTarget, iDist, true, false, false)
                        iCurPlateau, iCurZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tCurTarget)
                        if bDebugMessages == true then LOG(sFunctionRef..': iDist='..iDist..'; tCurTarget='..repru(tCurTarget)..'; iCurPlateau='..(iCurPlateau or 'nil')..'; iCurZone='..(iCurZone or 'nil')) end
                        if iCurPlateau and iCurZone then
                            if iCurPlateau == 0 then
                                --iCurWZ = M28Map.GetWaterZoneFromPosition(tCurTarget)
                                if bDebugMessages == true then LOG(sFunctionRef..': iCurZone='..(iCurZone or 'nil')) end
                                if not(tbWaterZonesConsidered[iCurZone]) then
                                    --Have a valid water zone, check if it is dangerous
                                    tbWaterZonesConsidered[iCurZone] = true
                                    --IsThereAANearLandOrWaterZone(iTeam, iPlateau, iLandOrWaterZone, bIsWaterZone, iOptionalGroundThreatThreshold, iOptionalAirAAThreatThreshold, iOptionalMaxDistToEdgeOfAdjacentZone, tOptionalStartPointForEdgeOfAdacentZone)
                                    bCurTargetTooDangerous = IsThereAANearLandOrWaterZone(iTeam, iCurPlateau, iCurZone, true,         iZoneGroundAAThreshold,         iZoneAirAAThreshold,                nil,                                    nil)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iCurPlateau='..iCurPlateau..'; iCurZone='..iCurZone..'; bCurTargetTooDangerous='..tostring(bCurTargetTooDangerous)..'; bDoDetailedCheck (i.e. if this is dangerous then will do more precise check)='..tostring(bDoDetailedCheck)) end
                                    if bCurTargetTooDangerous and bDoDetailedCheck then
                                        --function DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iEndPlateauOrZero, iEndLandOrWaterZone, bIgnoreAirAAThreat, iGroundAAThreatThreshold, iAirAAThreatThreshold, bUsingTorpBombers, iAirSubteam, bDoDetailedCheckForAA, bReturnGroundAAThreatInstead, tOptionalStartMidpointAdjustForDetailedCheck)
                                        bCurTargetTooDangerous = DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iCurPlateau, iCurZone, not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir]), iZoneGroundAAThreshold, iZoneAirAAThreshold, false, iAirSubteam, true)
                                        if bDebugMessages == true then LOG(sFunctionRef..': bCurTargetTooDangerous after detailed WZ check='..tostring(bCurTargetTooDangerous)) end
                                    end
                                    if bCurTargetTooDangerous then
                                        break
                                    else
                                        --Record this as the 'previous' entry so if we run into a dnagerous location later on we will use this
                                        iPrevPlateau = iCurPlateau
                                        iPrevWaterZone = iCurZone
                                        iPrevLandZone = nil
                                    end
                                end
                            else
                                --Have a valid land zone
                                if bDebugMessages == true then LOG(sFunctionRef..': tbPlateauAndLandZonesConsidered[iCurPlateau][iCurZone]='..tostring(tbPlateauAndLandZonesConsidered[iCurPlateau][iCurZone] or false)..'; iCurPlateau='..(iCurPlateau or 'nil')..'; iCurZone='..(iCurZone or 'nil')) end
                                if not(tbPlateauAndLandZonesConsidered[iCurPlateau][iCurZone]) then
                                    if not(tbPlateauAndLandZonesConsidered[iCurPlateau]) then tbPlateauAndLandZonesConsidered[iCurPlateau] = {} end
                                    tbPlateauAndLandZonesConsidered[iCurPlateau][iCurZone] = true
                                    bCurTargetTooDangerous = IsThereAANearLandOrWaterZone(iTeam, iCurPlateau, iCurZone, false,         iZoneGroundAAThreshold, iZoneAirAAThreshold)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iCurPlateau='..iCurPlateau..'; iCurZone='..iCurZone..'; bCurTargetTooDangerous before detailed check='..tostring(bCurTargetTooDangerous)..'; bDoDetailedCheck='..tostring(bDoDetailedCheck)) end
                                    if bCurTargetTooDangerous and bDoDetailedCheck then
                                        --function DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iEndPlateauOrZero, iEndLandOrWaterZone, bIgnoreAirAAThreat, iGroundAAThreatThreshold, iAirAAThreatThreshold, bUsingTorpBombers, iAirSubteam, bDoDetailedCheckForAA, bReturnGroundAAThreatInstead, tOptionalStartMidpointAdjustForDetailedCheck)
                                        bCurTargetTooDangerous = DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iCurPlateau, iCurZone, not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir]), iZoneGroundAAThreshold, iZoneAirAAThreshold, false, iAirSubteam, true)
                                        if bDebugMessages == true then LOG(sFunctionRef..': bCurTargetTooDangerous after detailed check='..tostring(bCurTargetTooDangerous)) end
                                    end
                                    if bCurTargetTooDangerous then
                                        break
                                    else
                                        --Record this as the 'previous' entry so if we run into a dnagerous location later on we will use this
                                        iPrevPlateau = iCurPlateau
                                        iPrevWaterZone = nil
                                        iPrevLandZone = iCurZone
                                    end
                                end
                            end
                        else
                            --No valid plateau so ignore this position
                        end
                    end
                    if bCurTargetTooDangerous and bDoDetailedCheck and oPriorityUnitBeingSupported and tClosestBase and EntityCategoryContains(M28UnitInfo.refCategoryAirToGround, oPriorityUnitBeingSupported.UnitId) then

                        local iDistFromBaseToMidpoint
                        if not(iPrevPlateau) then iDistFromBaseToMidpoint = 0
                        else
                            local tSupportLZOrWZData
                            if iPrevLandZone then
                                tSupportLZOrWZData = M28Map.tAllPlateaus[iPrevPlateau][M28Map.subrefPlateauLandZones][iPrevLandZone]
                            else
                                tSupportLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iPrevWaterZone]][M28Map.subrefPondWaterZones][iPrevWaterZone]
                            end
                            iDistFromBaseToMidpoint = M28Utilities.GetDistanceBetweenPositions(tSupportLZOrWZData[M28Map.subrefMidpoint], tClosestBase)
                        end
                        local iUnitDistToBase = M28Utilities.GetDistanceBetweenPositions(oPriorityUnitBeingSupported:GetPosition(), tClosestBase)
                        local iBaseDistanceThreshold = 60
                        if iUnitDistToBase - iDistFromBaseToMidpoint > iBaseDistanceThreshold then
                            local iMaxSearchRange = math.floor((iUnitDistToBase - iDistFromBaseToMidpoint)/10)*10
                            local bDangerousUsingPreciseCheck
                            if bDebugMessages == true then LOG(sFunctionRef..': Will do more precise support zone check, iDistFromBaseToMidpoint='..iDistFromBaseToMidpoint..'; iUnitDistToBase='..iUnitDistToBase..'; iMaxSearchRange='..iMaxSearchRange) end
                            for iDist = iDistFromBaseToMidpoint + 10, iDistFromBaseToMidpoint + iMaxSearchRange - (iBaseDistanceThreshold - 10), 10 do
                                --Using a precise point instead of a midpoint, can we find a safe location that is closer to our experimental bomber?
                                tCurTarget = M28Utilities.MoveInDirection(tClosestBase, iAngleToTarget, iDist, true, false, false)
                                iCurPlateau, iCurZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tCurTarget)
                                if iCurPlateau and iCurZone then
                                    --DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iEndPlateauOrZero, iEndLandOrWaterZone, bIgnoreAirAAThreat, iGroundAAThreatThreshold, iAirAAThreatThreshold, bUsingTorpBombers, iAirSubteam, bDoDetailedCheckForAA, bReturnGroundAAThreatInstead, tOptionalStartMidpointAdjustForDetailedCheck)
                                    bDangerousUsingPreciseCheck = DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iCurPlateau, iCurZone, not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir]), iGroundAAThreshold, iAirAAThreshold, false, iAirSubteam, true,        false,                          tCurTarget)
                                    if bDebugMessages == true then LOG(sFunctionRef..': More precise support shadowing check, iDist='..iDist..'; bDangerousUsingPreciseCheck='..tostring(bDangerousUsingPreciseCheck or false)) end
                                    if not(bDangerousUsingPreciseCheck) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Using a precise location we have a more appropriate point, iDist='..iDist..'; tAlternativeToZoneMidpointOverride='..repru(tAlternativeToZoneMidpointOverride)) end
                                        tAlternativeToZoneMidpointOverride = {tCurTarget[1], tCurTarget[2], tCurTarget[3]}
                                    else
                                        break
                                    end
                                end
                            end
                        end
                    end

                    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for support location, iPrevWaterZone='..(iPrevWaterZone or 'nil')..'; iPrevLandZone='..(iPrevLandZone or 'nil')..'; tAlternativeToZoneMidpointOverride='..repru(tAlternativeToZoneMidpointOverride)) end
                    if bCurTargetTooDangerous then bDontMoveCloserToEnemyBase = true end
                    --Update the support rally point, and record pathing of other land and air zones to it if havent previously
                    if not(iPrevWaterZone) and not(iPrevLandZone) then
                        --Use closest base
                        tSupportRallyPoint = tClosestBase
                    elseif tAlternativeToZoneMidpointOverride then
                        tSupportRallyPoint = {tAlternativeToZoneMidpointOverride[1], tAlternativeToZoneMidpointOverride[2], tAlternativeToZoneMidpointOverride[3]}
                    else
                        --We have a valid support zone
                        local tSupportLZOrWZData
                        if iPrevLandZone then
                            tSupportLZOrWZData = M28Map.tAllPlateaus[iPrevPlateau][M28Map.subrefPlateauLandZones][iPrevLandZone]
                        else
                            tSupportLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iPrevWaterZone]][M28Map.subrefPondWaterZones][iPrevWaterZone]
                        end
                        tSupportRallyPoint = {tSupportLZOrWZData[M28Map.subrefMidpoint][1], tSupportLZOrWZData[M28Map.subrefMidpoint][2], tSupportLZOrWZData[M28Map.subrefMidpoint][3]}
                        --Redundancy - check for enemy ground AA within range of the destination; if have any then move back towards base by 50
                        local bMoveCloserToRally = false
                        local tNearbyEnemyAA
                        if aiBrain.GetUnitsAroundPoint then
                            --Increased range to 85 for v90 from 78 to allow for air units turning around
                            tNearbyEnemyAA = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryGroundAA, tSupportRallyPoint, 85, 'Enemy')
                            if bDebugMessages == true then LOG(sFunctionRef..': Is tNearbyEnemyAA empty='..tostring(M28Utilities.IsTableEmpty(tNearbyEnemyAA))) if M28Utilities.IsTableEmpty(tNearbyEnemyAA) == false then LOG(sFunctionRef..': Mass cost of nearby AA='..M28UnitInfo.GetMassCostOfUnits(tNearbyEnemyAA)..'; M28UnitInfo.GetAirThreatLevel(tNearbyEnemyAA, true, false, true, false, false, false)='..M28UnitInfo.GetAirThreatLevel(tNearbyEnemyAA, true, false, true, false, false, false)..'; iGroundAAThreshold='..iGroundAAThreshold)  end end
                            if M28Utilities.IsTableEmpty(tNearbyEnemyAA) == false and (not(iGroundAAThreshold) or M28UnitInfo.GetAirThreatLevel(tNearbyEnemyAA, true, false, true, false, false, false) > iGroundAAThreshold) then
                                for iAA, oAA in tNearbyEnemyAA do
                                    if bDebugMessages == true then LOG(sFunctionRef..': oAA Nearby='..oAA.UnitId..M28UnitInfo.GetUnitLifetimeCount(oAA)..'; AA range='..oAA[M28UnitInfo.refiAARange]..'; Dist to support rally='..M28Utilities.GetDistanceBetweenPositions(oAA:GetPosition(), tSupportRallyPoint)) end
                                    if oAA[M28UnitInfo.refiAARange] >= 65 or M28Utilities.GetDistanceBetweenPositions(oAA:GetPosition(), tSupportRallyPoint) - (oAA[M28UnitInfo.refiAARange] or 0) <= 18 then
                                        bMoveCloserToRally = true
                                        break
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': bMoveCloserToRally after check for neraby groundAA that have intel of='..tostring(bMoveCloserToRally or false)) end
                            if bMoveCloserToRally then
                                bDontMoveCloserToEnemyBase = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Have managed to end up with a support point wiht nearby enemy groundAA so will move support point back a bit, tSupportRallyPoint pre update='..repru(tSupportRallyPoint)) end
                                tSupportRallyPoint = M28Utilities.MoveInDirection(tSupportRallyPoint, M28Utilities.GetAngleFromAToB(tSupportRallyPoint, tClosestBase), 50, true, false, M28Map.bIsCampaignMap)
                                if bDebugMessages == true then LOG(sFunctionRef..': Rally point post update='..repru(tSupportRallyPoint)) end
                            end
                        end

                        if bDebugMessages == true then LOG(sFunctionRef..': tSupportRallyPoint after updating for zones closer to a unit to support and having a vlocation closer than the nearest friendly base='..repru(tSupportRallyPoint)) end
                    end

                end
            end
        end

        --Check that we have a location with a valid zone (if we have a support rally point)
        if bDebugMessages == true then LOG(sFunctionRef..': tSupportRallyPoint='..repru(tSupportRallyPoint)..'; tPreferredRallyPoint='..repru(tPreferredRallyPoint)) end
        if not(tSupportRallyPoint) then
            if M28Utilities.IsTableEmpty(tPreferredRallyPoint) == false and (bDontCheckPlayableArea or M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint]) or M28Conditions.IsLocationInPlayableArea(tPreferredRallyPoint)) then
                M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint] = tPreferredRallyPoint
            else
                M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint] = {M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint][1], M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint][2], M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint][3]}
            end
        else
            --Move the support rally point if not on a land or water zone
            local iSupportPlateau, iSupportLZOrWZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tSupportRallyPoint)
            local iRevisedSegmentX, iRevisedSegmentZ
            if not(iSupportPlateau) then
                local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(tSupportRallyPoint)
                for iAdjustBase = 1, 30 do
                    for iCurSegmentX = iSegmentX - iAdjustBase, iSegmentX + iAdjustBase, 1 do
                        for iCurSegmentZ = iSegmentZ - iAdjustBase, iSegmentZ + iAdjustBase, iAdjustBase * 2 do
                            if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                                if M28Map.tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] then iSupportLZOrWZ = M28Map.tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] break
                                elseif M28Map.tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] then
                                    iSupportLZOrWZ = M28Map.tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
                                    iRevisedSegmentX = iCurSegmentX
                                    iRevisedSegmentZ = iCurSegmentZ
                                    break
                                end
                            end
                        end
                        if iSupportLZOrWZ then break end
                    end
                    if iSupportLZOrWZ then break end
                    --Then do the left and right row (excl corners which ahve already done per the above)
                    for iCurSegmentX = iSegmentX - iAdjustBase, iSegmentX + iAdjustBase, iAdjustBase * 2 do
                        for iCurSegmentZ = iSegmentZ - iAdjustBase + 1, iSegmentZ + iAdjustBase - 1, 1 do
                            if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                                if M28Map.tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] then iSupportLZOrWZ = M28Map.tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] break
                                elseif M28Map.tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] then
                                    iSupportLZOrWZ = M28Map.tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
                                    iRevisedSegmentX = iCurSegmentX
                                    iRevisedSegmentZ = iCurSegmentZ
                                    break
                                end
                            end
                        end
                        if iSupportLZOrWZ then break end
                    end
                    if iSupportLZOrWZ then break end
                end
                if not(iSupportLZOrWZ) or not(iRevisedSegmentX) or not(iRevisedSegmentZ) then
                    M28Utilities.ErrorHandler('We have tried searching for nearby valid segment and failed to find one, may result in errors, wont update the support rally point')
                else
                    --Update tSupportRallyPoint
                    if bDebugMessages == true then LOG(sFunctionRef..': Will use segment nearby that has a valid zone, iCurSegment: X'..iRevisedSegmentX..'Z'..iRevisedSegmentZ..' at position '..repru(M28Map.GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ))) end
                    tSupportRallyPoint = M28Map.GetPositionFromPathingSegments(iRevisedSegmentX, iRevisedSegmentZ)
                end
            end
            if iSupportLZOrWZ then
                M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint] = tSupportRallyPoint
            else
                --Do nothing - i.e. retain the previous rally point unless we dont have one
                if M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint]) then
                    M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint] = tPreferredRallyPoint
                end
            end
        end


        --Update the recorded support rally point to reflect the above, and record pathing of other land and air zones to it if havent previously
        local tStartLZOrWZData
        if bDebugMessages == true then LOG(sFunctionRef..': About to get the plateau and zone for air support point='..repru(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint])..'; reftAirSubRallyPoint='..repru(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint])..'; tPreferredRallyPoint='..repru(tPreferredRallyPoint)) end
        if M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint]) then
            if M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint]) then
                M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint] = {tPreferredRallyPoint[1], tPreferredRallyPoint[2], tPreferredRallyPoint[3]}
            else
                M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint] = {M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint][1], M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint][2], M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint][3]}
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Updated air support point to be the rally point, M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint]='..repru(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint])) end
        end
        local tStartMidpoint = {M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint][1], M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint][2], M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint][3]}
        if M28Utilities.IsTableEmpty(tStartMidpoint) == false then
            local iStartPlateau, iStartLZOrWZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tStartMidpoint)
            local tStartLZOrWZTeamData
            if (iStartPlateau or 0) > 0 and (iStartLZOrWZ or 0) == 0 then
                iStartLZOrWZ = M28Map.GetWaterZoneFromPosition(tStartMidpoint)
                tSupportRallyPoint = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iStartLZOrWZ]][M28Map.subrefPondWaterZones][iStartLZOrWZ][M28Map.subrefMidpoint]
                tStartLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iStartLZOrWZ]][M28Map.subrefPondWaterZones][iStartLZOrWZ]
                tStartLZOrWZTeamData = tStartLZOrWZData[M28Map.subrefWZTeamData][iTeam]
            else
                tSupportRallyPoint = M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iStartLZOrWZ][M28Map.subrefMidpoint]
                tStartLZOrWZData = M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iStartLZOrWZ]
                tStartLZOrWZTeamData = tStartLZOrWZData[M28Map.subrefLZTeamData][iTeam]
            end
            if tStartLZOrWZData then
                --Move the support rally point towards the enemy base if we have air control
                if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] and not(bDontMoveCloserToEnemyBase) then
                    if tStartLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.5 then
                        local iDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(tStartMidpoint, tStartLZOrWZTeamData[M28Map.reftClosestEnemyBase])
                        if iDistToEnemyBase >= 100 then
                            local iDistToOurBase = M28Utilities.GetDistanceBetweenPositions(tStartMidpoint, tStartLZOrWZTeamData[M28Map.reftClosestFriendlyBase])
                            local iMaxDistToTravel = math.min(iDistToEnemyBase - 100, (iDistToOurBase + iDistToEnemyBase) * 0.5 -  iDistToOurBase)
                            if iMaxDistToTravel >= 40 then
                                local iIntervalSize = 40
                                local iAngleToSupport = M28Utilities.GetAngleFromAToB(tStartMidpoint, tStartLZOrWZTeamData[M28Map.reftClosestEnemyBase])
                                local iRallyPlateau, iRallyLZOrWZ
                                local tLastSafeRally
                                if bDebugMessages == true then LOG(sFunctionRef..': iAngleToSupport='..iAngleToSupport..'; base rally point='..repru(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint])..'; Playable area='..repru(M28Map.rMapPlayableArea)..'; iMaxDistToTravel='..iMaxDistToTravel) end
                                for iCurDist = iIntervalSize, math.floor(iMaxDistToTravel / iIntervalSize) * iIntervalSize, iIntervalSize do
                                    local tPotentialNewRally = M28Utilities.MoveInDirection(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint], iAngleToSupport, iCurDist, true, false, true)
                                    if tPotentialNewRally then
                                        if bDebugMessages == true then LOG(sFunctionRef..': iCurDist='..iCurDist..'; tPotentialNewRally='..repru(tPotentialNewRally)) end
                                        iRallyPlateau, iRallyLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tPotentialNewRally)
                                        if (iRallyLZOrWZ or 0) > 0 then
                                            --Is this safe?
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering new plateau='..iRallyPlateau..'; new zone='..iRallyLZOrWZ..'; Does enemy have AA threat along path to here='..tostring(DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateau, iStartLZOrWZ, iRallyPlateau, iRallyLZOrWZ, false, 0, 0, false, iAirSubteam))) end
                                            if DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateau, iStartLZOrWZ, iRallyPlateau, iRallyLZOrWZ, false, 0, 0, false, iAirSubteam) then
                                                if bDebugMessages == true then LOG(sFunctionRef..'; Zone is not safe so will stop searching') end
                                                break
                                            else
                                                tLastSafeRally = {tPotentialNewRally[1], tPotentialNewRally[2], tPotentialNewRally[3]}
                                                if bDebugMessages == true then LOG(sFunctionRef..': Zone is safe so updating last safe rally to '..repru(tLastSafeRally)) end
                                            end
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Updating support zone location, last safe location after moving towards enemy base='..repru(tLastSafeRally)) end
                                if tLastSafeRally then
                                    iStartPlateau, iStartLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tSupportRallyPoint)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will update the support location to be the midpoint of plateau '..iStartPlateau..'; iStartLZOrWZ='..(iStartLZOrWZ or 'nil')) end
                                    if (iStartLZOrWZ or 0) > 0 then --redundancy
                                        if (iStartPlateau or 0) == 0 then
                                            --water zone
                                            tSupportRallyPoint = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iStartLZOrWZ]][M28Map.subrefPondWaterZones][iStartLZOrWZ][M28Map.subrefMidpoint]
                                            tStartLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iStartLZOrWZ]][M28Map.subrefPondWaterZones][iStartLZOrWZ]
                                            tStartLZOrWZTeamData = tStartLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                                        else
                                            --land zone
                                            tSupportRallyPoint = M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iStartLZOrWZ][M28Map.subrefMidpoint]
                                            tStartLZOrWZData = M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iStartLZOrWZ]
                                            tStartLZOrWZTeamData = tStartLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                                        end
                                        if M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefMidpoint]) == false then
                                            tStartMidpoint = {tStartLZOrWZData[M28Map.subrefMidpoint][1], tStartLZOrWZData[M28Map.subrefMidpoint][2], tStartLZOrWZData[M28Map.subrefMidpoint][3]}
                                        else
                                            M28Utilities.ErrorHandler('No midpoint for P'..iStartPlateau..'; LZOrWZ '..iStartLZOrWZ)
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': About to record the land and water zones by order of distance to iStartPlateau '..(iStartPlateau or 'nil')..'; iStartLZOrWZ='..(iStartLZOrWZ or 'nil')) end
            if not(tStartLZOrWZData) then
                if tStartMidpoint then
                    iStartPlateau, iStartLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tStartMidpoint)
                    if iStartPlateau == 0 and (iStartLZOrWZ or 0) > 0 then
                        tStartLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iStartLZOrWZ]][M28Map.subrefPondWaterZones][iStartLZOrWZ]
                    elseif (iStartLZOrWZ or 0) > 0 then
                        tStartLZOrWZData = M28Map.tAllPlateaus[iStartPlateau][M28Map.subrefPlateauLandZones][iStartLZOrWZ]
                    else
                        M28Utilities.ErrorHandler('Couldnt find LZ or WZ close to tStartMidpoint')
                        LOG(sFunctionRef..': tStartMidpoint='..repru(tStartMidpoint))
                    end
                else
                    M28Utilities.ErrorHandler('No tStartMidpoint set')
                end
            end
            if tStartLZOrWZData then
                RecordOtherLandAndWaterZonesByDistance(tStartLZOrWZData, tStartMidpoint)
            end


            --If have air control then move the rally point to be closer to the support point

            if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to move rally point closer to support point, M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl]='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] or false)) end

            if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] and not(bDontMoveCloserToEnemyBase) then
                local iDistBetweenSupportAndRally = M28Utilities.GetDistanceBetweenPositions(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint], M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint])
                if iDistBetweenSupportAndRally >= 100 then
                    local iIntervalSize = 50
                    local iAngleToSupport = M28Utilities.GetAngleFromAToB(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint], M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint])
                    local iRallyPlateau, iRallyLZOrWZ
                    local tLastSafeRally
                    local iStartPlateauOrZero, iStartLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint])
                    if bDebugMessages == true then LOG(sFunctionRef..': iAngleToSupport='..iAngleToSupport..'; iDistBetweenSupportAndRally='..iDistBetweenSupportAndRally) end
                    for iCurDist = iIntervalSize, math.floor((iDistBetweenSupportAndRally - iIntervalSize) / iIntervalSize) * iIntervalSize, iIntervalSize do
                        local tPotentialNewRally = M28Utilities.MoveInDirection(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint], iAngleToSupport, iCurDist, true, false, true)
                        if tPotentialNewRally then
                            iRallyPlateau, iRallyLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tPotentialNewRally)
                            if (iRallyLZOrWZ or 0) > 0 then
                                --Is this safe?
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering iRallyPlateau='..iRallyPlateau..'; iRallyLZOrWZ='..iRallyLZOrWZ..'; Does enemy have AA threat along path to here='..tostring(DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iRallyPlateau, iRallyLZOrWZ, false, 0, 0, false, iAirSubteam))) end
                                if DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iRallyPlateau, iRallyLZOrWZ, false, 0, 0, false, iAirSubteam) then
                                    if bDebugMessages == true then LOG(sFunctionRef..'; Zone is not safe so will stop searching') end
                                    break
                                else
                                    tLastSafeRally = {tPotentialNewRally[1], tPotentialNewRally[2], tPotentialNewRally[3]}
                                    if bDebugMessages == true then LOG(sFunctionRef..': Zone is safe so updating last safe rally to '..repru(tLastSafeRally)) end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': tLastSafeRally='..repru(tLastSafeRally)) end
                    if tLastSafeRally then
                        M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint] = {tLastSafeRally[1], tLastSafeRally[2], tLastSafeRally[3]}
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..'; Will draw air sub rally point') M28Utilities.DrawLocation(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint], nil, 10, 10) end
        else
            M28Utilities.ErrorHandler('No air support point for air subteam '..iAirSubteam)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetUnitAirStagingSize(oUnit)
    --Manually confirmed - ambassador takes up 4 spaces, janus, inties and asf take up 1, broadswords and solace take up 2 spaces
    if EntityCategoryContains(categories.TECH3 * M28UnitInfo.refCategoryBomber, oUnit.UnitId) then
        return 4
    elseif EntityCategoryContains(categories.TECH3 - M28UnitInfo.refCategoryAirAA, oUnit.UnitId) then
        return 2
    else return 1
    end
end

function SendUnitsForRefueling(tUnitsForRefueling, iTeam, iAirSubteam, bDontReleaseHealedUnits)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OrderUnitsToRefuel'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Sends low fuel units to air staging
    --if M28Utilities.IsTableEmpty(tUnitsForRefueling) == false then
    --Get available air staging units - Only consider actual air staging buildings for these purposes, or else risk interfering with other logic
    local tAirStagingUnitsAndCapacity = {}
    local subrefoUnit = 1
    local subrefiCapacity = 2
    local iMaxCapacity, iCapacityInUse

    for iBrain, oBrain in M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains] do
        local tCurBrainStaging = oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirStaging, false, true)
        if M28Utilities.IsTableEmpty(tCurBrainStaging) == false then
            local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
            for iUnit, oAirStaging in tCurBrainStaging do
                if M28UnitInfo.IsUnitValid(oAirStaging) and oAirStaging:GetFractionComplete() == 1 and (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(oAirStaging:GetPosition())) then
                    --Does this have capacity?
                    iMaxCapacity = 4
                    if EntityCategoryContains(categories.MOBILE, oAirStaging.UnitId) then
                        if EntityCategoryContains(categories.EXPERIMENTAL, oAirStaging.UnitId) then iMaxCapacity = 40
                        else iMaxCapacity = 1
                        end
                    end

                    iCapacityInUse = 0
                    --First check for air staging cargo and release if they are all at full health
                    local bCargoReadyToRelease = false
                    local tCargo = oAirStaging:GetCargo()
                    if M28Utilities.IsTableEmpty(tCargo) == false then

                        for iCargo, oCargo in tCargo do
                            if oCargo.GetFuelRatio and EntityCategoryContains(categories.MOBILE, oCargo.UnitId) then --some mods add units as part of the cargo
                                bCargoReadyToRelease = true
                                if oCargo:GetFuelRatio() < 1 or M28UnitInfo.GetUnitHealthPercent(oCargo) < 1 then
                                    bCargoReadyToRelease = false
                                    break
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering air staging unit '..oAirStaging.UnitId..M28UnitInfo.GetUnitLifetimeCount(oAirStaging)..'; Is tCargo empty='..tostring(M28Utilities.IsTableEmpty(tCargo))..'; bCargoReadyToRelease='..tostring(bCargoReadyToRelease)..'; Is oAirStaging[reftAssignedRefuelingUnits] empty='..tostring(M28Utilities.IsTableEmpty(oAirStaging[reftAssignedRefuelingUnits]))) end
                    if bCargoReadyToRelease then
                        if not(bDontReleaseHealedUnits) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will try and release all units in air staging '..oAirStaging.UnitId..M28UnitInfo.GetUnitLifetimeCount(oAirStaging)) end
                            M28Orders.ReleaseStoredUnits(oAirStaging, false, 'ASUnl', false)
                            --Dont clear unit status as should happen automatically in next cycle; dont consider sending units to it this cycle
                        end
                    else
                        if M28Utilities.IsTableEmpty(oAirStaging[reftAssignedRefuelingUnits]) == false then
                            --Remove any invalid units or units whose order isn't to refuel
                            local iUnitCount = table.getn(oAirStaging[reftAssignedRefuelingUnits])
                            for iCurUnit = iUnitCount, 1, -1 do
                                local oRefuelingUnit = oAirStaging[reftAssignedRefuelingUnits][iCurUnit]
                                if M28UnitInfo.IsUnitValid(oRefuelingUnit) then
                                    local tLastOrder = oRefuelingUnit[M28Orders.reftiLastOrders][oRefuelingUnit[M28Orders.refiOrderCount]]
                                    if oRefuelingUnit:IsUnitState('Attached') or (tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderRefuel and tLastOrder[M28Orders.subrefoOrderUnitTarget] == oAirStaging) then

                                        --Unit is still assigned here
                                        iCapacityInUse = iCapacityInUse + GetUnitAirStagingSize(oRefuelingUnit)
                                        if bDebugMessages == true then LOG(sFunctionRef..' Staging has been assigned to oRefuelingUnit='..oRefuelingUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRefuelingUnit)..'; Size of this unit='..GetUnitAirStagingSize(oRefuelingUnit)..'; Capacity in use='..iCapacityInUse) end
                                    else
                                        --Unit has other orders so remove from here
                                        table.remove(oAirStaging[reftAssignedRefuelingUnits], iCurUnit)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Removing unit '..oRefuelingUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRefuelingUnit)..' as it has other orders now; Unit state='..M28UnitInfo.GetUnitState(oRefuelingUnit)..'; tLastOrder[M28Orders.subrefoOrderUnitTarget]='..(tLastOrder[M28Orders.subrefoOrderUnitTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tLastOrder[M28Orders.subrefoOrderUnitTarget]) or 'nil')..'; air staging it is recorded against='..oAirStaging.UnitId..M28UnitInfo.GetUnitLifetimeCount(oAirStaging)) end
                                    end
                                else
                                    --Unit is dead so remove from this list
                                    table.remove(oAirStaging[reftAssignedRefuelingUnits], iCurUnit)
                                end
                            end
                        end
                        if iMaxCapacity > iCapacityInUse then
                            table.insert(tAirStagingUnitsAndCapacity, {[subrefoUnit] = oAirStaging, [subrefiCapacity] = iMaxCapacity - iCapacityInUse})
                        end
                    end
                end
            end
        end
    end

    local tUnitsUnableToRefuel = {}
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of tAirStagingUnitsAndCapacity empty='..tostring(M28Utilities.IsTableEmpty(tAirStagingUnitsAndCapacity))) end
    if M28Utilities.IsTableEmpty(tAirStagingUnitsAndCapacity) then
        tUnitsUnableToRefuel = tUnitsForRefueling
    else
        if M28Utilities.IsTableEmpty(tUnitsForRefueling) == false then
            --Have air staging available for units to refuel, cycle through each air unit and find the closest air staging to it that has sufficient capacity to take it
            local iClosestAirStagingDist, iCurDist, iClosestAirStagingRef
            local iCurSize
            for iUnit, oAirUnit in tUnitsForRefueling do
                if M28UnitInfo.IsUnitValid(oAirUnit) then
                    if EntityCategoryContains(categories.CANNOTUSEAIRSTAGING + categories.EXPERIMENTAL, oAirUnit.UnitId) then
                        table.insert(tUnitsUnableToRefuel, oAirUnit)
                    else
                        iClosestAirStagingDist = 100000
                        iClosestAirStagingRef = nil
                        iCurSize = GetUnitAirStagingSize(oAirUnit)
                        if M28Utilities.IsTableEmpty(tAirStagingUnitsAndCapacity) == false then
                            for iAirStagingRef, tSubtable in tAirStagingUnitsAndCapacity do
                                if bDebugMessages == true then LOG(sFunctionRef..': Looking for closest air staging '..(tSubtable[subrefoUnit].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tSubtable[subrefoUnit]) or 'nil')..', iAirStagingRef='..(iAirStagingRef or 'nil')..'; tSubtable[subrefiCapacity]='..(tSubtable[subrefiCapacity] or 'nil')..'; Unit that is trying to refuel size='..(iCurSize or 'nil')) end
                                if tSubtable[subrefiCapacity] >= iCurSize then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tSubtable[subrefoUnit]:GetPosition(), oAirUnit:GetPosition())
                                    if bDebugMessages == true then LOG(sFunctionRef..': iCurDist='..iCurDist..'; iClosestAirStagingDist='..(iClosestAirStagingDist or 'nil')) end
                                    if iCurDist < iClosestAirStagingDist then
                                        iClosestAirStagingRef = iCurDist
                                        iClosestAirStagingRef = iAirStagingRef
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering unit wanting refueling='..oAirUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oAirUnit)..'; iCurSize='..iCurSize..'; iClosestAirStagingRef='..(iClosestAirStagingRef or 'nil')..'; iClosestAirStagingDist='..iClosestAirStagingDist) end
                        if iClosestAirStagingRef then
                            local oClosestAirStaging = tAirStagingUnitsAndCapacity[iClosestAirStagingRef][subrefoUnit]
                            M28Orders.IssueTrackedRefuel(oAirUnit, oClosestAirStaging, false, 'Refuel', false)
                            local bRecordRefuelingUnit = true
                            if not(oClosestAirStaging[reftAssignedRefuelingUnits]) then oClosestAirStaging[reftAssignedRefuelingUnits] = {}
                            else
                                for iRecordedUnit, oRecordedUnit in oClosestAirStaging[reftAssignedRefuelingUnits] do
                                    if oRecordedUnit == oAirUnit then
                                        bRecordRefuelingUnit = false
                                        break
                                    end
                                end
                            end
                            if bRecordRefuelingUnit then
                                table.insert(oClosestAirStaging[reftAssignedRefuelingUnits], oAirUnit)
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Just told unit '..oAirUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oAirUnit)..' to refuel at '..oClosestAirStaging.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestAirStaging)..'; size of oClosestAirStaging[reftAssignedRefuelingUnits]='..table.getn(oClosestAirStaging[reftAssignedRefuelingUnits])..'; Available capacity pre this order='..tAirStagingUnitsAndCapacity[iClosestAirStagingRef][subrefiCapacity]..'; iCurSize='..iCurSize) end
                            if tAirStagingUnitsAndCapacity[iClosestAirStagingRef][subrefiCapacity] <= iCurSize then
                                table.remove(tAirStagingUnitsAndCapacity, iClosestAirStagingRef)
                            else
                                tAirStagingUnitsAndCapacity[iClosestAirStagingRef][subrefiCapacity] = tAirStagingUnitsAndCapacity[iClosestAirStagingRef][subrefiCapacity] - iCurSize
                            end
                        else
                            table.insert(tUnitsUnableToRefuel, oAirUnit)
                        end
                    end
                end
            end
        end
    end
    --Send any units that couldnt be refueld to the closest friendly base air rally point
    if M28Utilities.IsTableEmpty(tUnitsUnableToRefuel) == false then
        local bWantMoreAirStaging = false
        for iUnit, oUnit in tUnitsUnableToRefuel do
            if not(EntityCategoryContains(categories.EXPERIMENTAL - categories.CANNOTUSEAIRSTAGING, oUnit.UnitId)) then
                bWantMoreAirStaging = true
                break
            end
        end

        if bWantMoreAirStaging then M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastAirStagingShortage] = GetGameTimeSeconds() end
        local tRallyPoint = M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint]
        if bDebugMessages == true then LOG(sFunctionRef..': Flagged that we want air staging for units on team '..iTeam..' at time '..GetGameTimeSeconds()..' unless we only have low health exp, bWantMoreAirStaging='..tostring(bWantMoreAirStaging)..'; tRallyPoint='..repru(tRallyPoint)..'; Plateau label='..(NavUtils.GetLabel(M28Map.refPathingTypeHover, tRallyPoint) or 'nil')) end
        local tRallyLZData, tRallyLZTeamData = M28Map.GetLandOrWaterZoneData(tRallyPoint, true, iTeam)
        local tRefuelBase
        if tRallyLZTeamData[M28Map.reftClosestFriendlyBase] and (not(M28Map.bIsCampaignMap) or M28Conditions.IsLocationInPlayableArea(tRallyLZTeamData[M28Map.reftClosestFriendlyBase])) then tRefuelBase = tRallyLZTeamData[M28Map.reftClosestFriendlyBase] else tRefuelBase = tRallyPoint end
        --If close to unit cap consider ctrl-King unit if it is close to the rally point
        if (M28Team.tTeamData[iTeam][M28Team.refiLowestUnitCapAdjustmentLevel] or 0) == 0 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] or -100) <= 10 then
            --Ctrlk units if close to rally point and aibrain owner is close to unit cap
            local iCtrlKCount = 0
            for iUnit, oUnit in tUnitsUnableToRefuel do
                if not(EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId)) and oUnit:GetAIBrain()[M28Overseer.refbCloseToUnitCap] and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint) <= 10 and iCtrlKCount < 3 and (not(oUnit[M28UnitInfo.refbCampaignTriggerAdded]) or not(M28Map.bIsCampaignMap)) then
                    iCtrlKCount = iCtrlKCount + 1
                    ForkThread(M28Micro.MoveAndKillAirUnit,oUnit)
                    --M28Orders.IssueTrackedKillUnit(oUnit)
                else
                    M28Orders.IssueTrackedMove(oUnit, tRefuelBase, 10, false, 'UCWntStgn', false)
                end
            end
        else
            --Send units to rally point, unless lots of low fuel in which case consider ctrlking 1 unit (assuming we are past the first 10m)
            local bConsiderKillingUnits = false
            local iLowFuelUnits = table.getn(tUnitsUnableToRefuel)
            if iLowFuelUnits >= 10 and GetGameTimeSeconds() >= math.max(150, 600 / M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier]) then
                local iTotalCurAirStaging = 0
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    iTotalCurAirStaging = iTotalCurAirStaging + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirStaging)
                end
                if iTotalCurAirStaging == 0 or iLowFuelUnits / iTotalCurAirStaging >= 10 then
                    bConsiderKillingUnits = true
                end
            end
            for iUnit, oUnit in tUnitsUnableToRefuel do
                M28Orders.IssueTrackedMove(oUnit, tRefuelBase, 10, false, 'WntStgn', false)
                if bConsiderKillingUnits and oUnit:GetFuelRatio() <= 0.1 and oUnit:GetFuelRatio() >= 0 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint) <= 10 and (not(oUnit[M28UnitInfo.refbCampaignTriggerAdded]) or not(M28Map.bIsCampaignMap)) and (not(EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) or M28UnitInfo.GetUnitHealthPercent(oUnit) <= 0.2)) then --(experimental condition is a redundancy)
                    ForkThread(M28Micro.MoveAndKillAirUnit,oUnit)
                    --M28Orders.IssueTrackedKillUnit(oUnit)
                    bConsiderKillingUnits = false --max one per second
                end
            end
        end
    end
        if bDebugMessages == true then LOG(sFunctionRef .. ': Finished giving orders for refueling, was tUnitsUnableToRefuel empty='..tostring(M28Utilities.IsTableEmpty(tUnitsUnableToRefuel))) end
    --end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TargetUnitWithAirAA(oAirAA, oEnemyUnit, iOptionalClosestDist)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TargetUnitWithAirAA'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Conditions.IsLocationInPlayableArea(oEnemyUnit:GetPosition()) then
        local iClosestUnitDist = iOptionalClosestDist or M28Utilities.GetDistanceBetweenPositions(oAirAA:GetPosition(), oEnemyUnit:GetPosition())
        --Suicide asf into enemy czar or experimental bomber once relatively close; alternativley issua manual attack order when getting close as wehn doing move ended up losing 60 asfs and not even breaking the shield; also manual attack order on exp bomber
        if iClosestUnitDist <= 70 and EntityCategoryContains(M28UnitInfo.refCategoryCzar + M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL, oEnemyUnit.UnitId) then
            SuicideASFIntoStrat(oEnemyUnit, oAirAA, true)
        elseif (iClosestUnitDist >= 120 or EntityCategoryContains(M28UnitInfo.refCategoryCzar, oEnemyUnit.UnitId) or (iClosestUnitDist <= 40 and (oEnemyUnit:GetCurrentLayer() == 'Land' or oEnemyUnit:GetPosition()[2] - GetTerrainHeight(oEnemyUnit:GetPosition()[1],oEnemyUnit:GetPosition()[3]) <= 5 or EntityCategoryContains(M28UnitInfo.refCategoryBomber * categories.TECH3 + M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL + M28UnitInfo.refCategoryTransport, oEnemyUnit.UnitId))) or (iClosestUnitDist <= 5 and EntityCategoryContains(M28UnitInfo.refCategoryGunship, oEnemyUnit.UnitId)))
            and ((M28UnitInfo.CanSeeUnit(oAirAA:GetAIBrain(), oEnemyUnit)) or oAirAA[M28Orders.reftiLastOrders][1][M28Orders.subrefoOrderUnitTarget] == oEnemyUnit) then
            M28Orders.IssueTrackedAttack(oAirAA, oEnemyUnit, false, 'AAAA', false)
            if bDebugMessages == true then LOG(sFunctionRef..': issued tracked attack') end
        else
            M28Orders.IssueTrackedMove(oAirAA, oEnemyUnit:GetPosition(), 3, false, 'AAAM', false)
            oAirAA[M28Orders.reftiLastOrders][oAirAA[M28Orders.refiOrderCount]][M28Orders.subrefoOrderUnitTarget] = oEnemyUnit
        end
        oAirAA[refoAirAACurTarget] = oEnemyUnit

    else
        --If the air unit has a target that is in the playable area then target that
        --local bInterceptTargetFound = false
        --GetNavigator is too unreliable in campaign, so will just ignore and target enemy air unit (moving towards it if it is off-map) - if want the old code using this, refer to v79 and earlier which had it commented out
        if bDebugMessages == true then LOG(sFunctionRef..': Wanted to target unit at position '..repru(oEnemyUnit:GetPosition())) end
        local iAngleToTarget = M28Utilities.GetAngleFromAToB(oAirAA:GetPosition(), oEnemyUnit:GetPosition())
        local tViaPoint = M28Utilities.MoveInDirection(oAirAA:GetPosition(), iAngleToTarget, 40, true, false, true)
        if M28Conditions.IsLocationInPlayableArea(tViaPoint) then
            M28Orders.IssueTrackedMove(oAirAA, tViaPoint, 10, false, 'AAPAV', false)
            if bDebugMessages == true then LOG(sFunctionRef..': Found a via point that is in the playable area='..repru(tViaPoint)) end
            oAirAA[refoAirAACurTarget] = oEnemyUnit
        end
        --end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateOrdersForExistingAirAATargets(tInCombatUnits, bReturnTableOfAssignedThreat)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateOrdersForExistingAirAATargets'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local sUnitRef
    local tExistingThreatAssignedByUnitRef = {}
    for iAAUnit, oAirAA in tInCombatUnits do
        --Update move orders
        if M28UnitInfo.IsUnitValid(oAirAA[refoAirAACurTarget]) then
            TargetUnitWithAirAA(oAirAA, oAirAA[refoAirAACurTarget])

            if bReturnTableOfAssignedThreat then
                --Update assigned threat values
                sUnitRef = oAirAA[refoAirAACurTarget].EntityId
                if sUnitRef then
                    tExistingThreatAssignedByUnitRef[sUnitRef] = (tExistingThreatAssignedByUnitRef[sUnitRef] or 0) + M28UnitInfo.GetAirThreatLevel({ oAirAA }, false, true, false, true, true, true)
                end
            end
        else
            oAirAA[refoAirAACurTarget] = nil
        end
    end
    if bReturnTableOfAssignedThreat then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return tExistingThreatAssignedByUnitRef
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AssignAirAATargets(tAvailableAirAA, tEnemyTargets, iTeam, iAirSubteam, tExistingThreatAssignedByUnitRef)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignAirAATargets'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tStartPoint = {M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint][1], M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint][2], M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint][3]}

    --Copy of M28Utiliteis function (for speed)
    function GetRoughDistanceBetweenPositions(tPosition1, tPosition2)
        --If want a rough indication of proximity but it isnt as important as speed
        return math.max(math.abs(tPosition1[1] - tPosition2[1]), math.abs(tPosition1[3] - tPosition2[3]))
    end
    --local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap) --Can have issues with air units not receiving orders which might be caused by air units going outside the playable area

    --local iAvailableAirSize = table.getn(tAvailableAirAA)
    local iEnemyTargetSize = table.getn(tEnemyTargets)
    local iClosestUnitDist, oClosestUnit, iCurDist, iCurValueAssigned, iThreatWanted, iClosestAARef
    local iCurLoopCount
    local iMaxLoopCount = 200 --Wont assign more than this number of AA units to a particular target, partly as an infinite loop check, and partly to avoid too much on a single unit (e.g. czar or ahwassa)
    local tEnemyAirAAUnits = {}

    local tPriorityEnemyTargets
    if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 10000 then
        local tCzarsAndExpBombers = EntityCategoryFilterDown(M28UnitInfo.refCategoryCzar + categories.BOMBER * categories.EXPERIMENTAL, tEnemyTargets)
        if M28Utilities.IsTableEmpty(tCzarsAndExpBombers) == false then
            tPriorityEnemyTargets = tCzarsAndExpBombers
        end
    end

    function ConsiderAttackingUnit(oEnemyUnit, iThreatToAssign)
        iCurLoopCount = 0
        iCurValueAssigned = (tExistingThreatAssignedByUnitRef[oEnemyUnit.EntityId] or 0)
        if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oEnemyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyUnit)..'; iThreatToAssign='..iThreatToAssign) end
        local tBasePosition = oEnemyUnit:GetPosition()
        while iCurValueAssigned < iThreatToAssign do
            iCurLoopCount = iCurLoopCount + 1
            if iCurLoopCount > iMaxLoopCount then break end
            iClosestUnitDist = 100000
            for iAAUnit, oAAUnit in tAvailableAirAA do
                iCurDist = GetRoughDistanceBetweenPositions(tBasePosition, oAAUnit:GetPosition())
                if iCurDist < iClosestUnitDist then
                    iClosestUnitDist = iCurDist
                    oClosestUnit = oAAUnit
                    iClosestAARef = iAAUnit
                end
            end
            if bDebugMessages == true then
                local iEnemyPlateauOrZero, iEnemyLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oClosestUnit:GetPosition())
                LOG(sFunctionRef..': iClosestUnitDist='..iClosestUnitDist..'; oClosestUnit='..oClosestUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestUnit)..'; will issue attack order if far away and have visibility; iEnemyPlateauOrZero='..iEnemyPlateauOrZero..'; iEnemyLandOrWaterZone='..iEnemyLandOrWaterZone..' tBasePosition='..repru(tBasePosition)..'; In playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tBasePosition))..'; Can see enemy='..tostring(M28UnitInfo.CanSeeUnit(oClosestUnit:GetAIBrain(), oEnemyUnit))..'; enemy unit pos='..repru(oEnemyUnit:GetPosition())..'; terrain height='..GetTerrainHeight(oEnemyUnit:GetPosition()[1],oEnemyUnit:GetPosition()[3])..'; currentlayer='..oEnemyUnit:GetCurrentLayer())
            end
            if not(oClosestUnit.Dead) then --redundancy
                TargetUnitWithAirAA(oClosestUnit, oEnemyUnit, iClosestUnitDist)
            end
            iCurValueAssigned = iCurValueAssigned + M28UnitInfo.GetAirThreatLevel({ oClosestUnit }, false, true, false, true, true, true)
            table.remove(tAvailableAirAA, iClosestAARef)
            if M28Utilities.IsTableEmpty(tAvailableAirAA) then break end
        end
    end

    if tPriorityEnemyTargets then
        for iEnemyUnit, oEnemyUnit in tPriorityEnemyTargets do
            if M28UnitInfo.IsUnitValid(oEnemyUnit) then --redundancy due to lua message that saw once
                iThreatWanted = M28UnitInfo.GetAirThreatLevel({ oEnemyUnit }, true, true, false, true, true, true)
                ConsiderAttackingUnit(oEnemyUnit, iThreatWanted)
            end
        end
    end

    if M28Utilities.IsTableEmpty(tAvailableAirAA) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through each enemy target, iEnemyTargetSize='..iEnemyTargetSize) end
        local tiDistPerTarget = {}
        for iCurEnemyUnit = 1, iEnemyTargetSize do
            tiDistPerTarget[iCurEnemyUnit] = M28Utilities.GetDistanceBetweenPositions(tEnemyTargets[iCurEnemyUnit]:GetPosition(), tStartPoint)
        end
        for iEntry, iDist in M28Utilities.SortTableByValue(tiDistPerTarget, false) do
            local oEnemyUnit = tEnemyTargets[iEntry]
            iThreatWanted = M28UnitInfo.GetAirThreatLevel({ oEnemyUnit }, true, true, false, true, true, true)
            --Increase threat to assign to AA units
            if EntityCategoryContains(categories.ANTIAIR + categories.EXPERIMENTAL, oEnemyUnit.UnitId) then
                iThreatWanted = iThreatWanted * 3
                table.insert(tEnemyAirAAUnits, oEnemyUnit) --Will want to assign more if have spare AirAA
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Dist based approach, iEntry='..iEntry..'; iDist='..iDist..'; enemy unit='..tEnemyTargets[iEntry].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEnemyTargets[iEntry])..'; iThreatWanted='..iThreatWanted) end

            ConsiderAttackingUnit(oEnemyUnit, iThreatWanted)
            if M28Utilities.IsTableEmpty(tAvailableAirAA) then break end
        end

        if M28Utilities.IsTableEmpty(tAvailableAirAA) == false and M28Utilities.IsTableEmpty(tEnemyAirAAUnits) == false then
            --Assign more threat to enemy AirAA units since where there's 1 more are likely to follow, and want to overwhelm; dont bother sorting for performacne reasons (as this means we have already assigned air units to every enemy air unit)
            for iUnit, oUnit in tEnemyAirAAUnits do
                iThreatWanted = M28UnitInfo.GetAirThreatLevel({ oUnit }, true, true, false, true, true, true) * 7 --Will reset the cur assigned threat to 0 when calling below funciton, ehnce doing *3 here is in addition to what assigned before
                ConsiderAttackingUnit(oUnit, iThreatWanted)
            end
            if M28Utilities.IsTableEmpty(tAvailableAirAA) == false and table.getn(tEnemyAirAAUnits) >= 5 then
                for iUnit, oUnit in tEnemyAirAAUnits do
                    iThreatWanted = M28UnitInfo.GetAirThreatLevel({ oUnit }, true, true, false, true, true, true) * 16 --Will reset the cur assigned threat to 0 when calling below funciton, ehnce doing *3 here is in addition to what assigned before
                    ConsiderAttackingUnit(oUnit, iThreatWanted)
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, is table of available airaa empty='..tostring(M28Utilities.IsTableEmpty(tAvailableAirAA))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iEndPlateauOrZero, iEndLandOrWaterZone, bIgnoreAirAAThreat, iGroundAAThreatThreshold, iAirAAThreatThreshold, bUsingTorpBombers, iAirSubteam, bDoDetailedCheckForAA, bReturnGroundAAThreatInstead, tOptionalStartMidpointAdjustForDetailedCheck, bReturnGroundAAUnitsAlongsideAAThreat)
    --Returns true if enemy has AA threat along the path from start to end (or in an adjacent land/water zone that is close enough to the path)

    --iStartPlateauOrZero: 0 if water zone
    --iEndPlateauOrZero: 0 if water zone
    --bIgnoreAirAAThreat - if true will only consider if groundAA threat, not airAA threat
    --iGroundAAThreatThreshold - if set, then will only avoid if has MAA above this levle (e.g. intended for gunships)
    --bUsingTorpBombers - if true, and we want to avoid somewhere due to too much ground AA threat, then flag that we have a torp bomber shortfall

    --bDoDetailedCheckForAA - if true then will calculate how close to the midpoint AA units are
    --bReturnGroundAAThreatInstead - if true will return the groundAA threat
    --tOptionalStartMidpointAdjustForDetailedCheck - ended up removing the code that was making use of this, but in theory this allows a different position to be used than the midpoint for the detailed check
    --bReturnGroundAAUnitsAlongsideAAThreat - only set to true if bReturnGroundAAThreatInstead is true; will also return a table of those groundAA units; recommended that use with bDoDetailedCheckForAA since minimal extra overhead then (so expect the detailed check isn't as expensive vs the normal check which has to do entitycateogyrfilterdown if this is falgged

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DoesEnemyHaveAAThreatAlongPath'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Calculate air travel path
    CalculateAirTravelPath(iStartPlateauOrZero, iStartLandOrWaterZone, iEndPlateauOrZero, iEndLandOrWaterZone)
    local iGroundAAThreat = 0
    local toGroundAAUnits
    if bReturnGroundAAUnitsAlongsideAAThreat then toGroundAAUnits = {} end

    --Cycle through every relevant land and water zone along this path and calculate the threat
    --First do land zones
    local tBasePathingTable = tAirZonePathingFromZoneToZone[iStartPlateauOrZero][iStartLandOrWaterZone][iEndPlateauOrZero][iEndLandOrWaterZone]
    if bDebugMessages == true then LOG(sFunctionRef..': Near start at time '..GetGameTimeSeconds()..', iStartPlateauOrZero='..iStartPlateauOrZero..'; iStartLandOrWaterZone='..iStartLandOrWaterZone..'; iEndPlateauOrZero='..iEndPlateauOrZero..'; iEndLandOrWaterZone='..iEndLandOrWaterZone..'; bIgnoreAirAAThreat='..tostring(bIgnoreAirAAThreat or false)..'; iGroundAAThreatThreshold='..(iGroundAAThreatThreshold or 'nil')..'; Is table of land azones in path empty='..tostring(M28Utilities.IsTableEmpty(tBasePathingTable[subreftPlateauAndLandZonesInPath]) or false)..'; Is table of water zones in path empty='..tostring(M28Utilities.IsTableEmpty(tBasePathingTable[subreftWaterZonesInPath]) or false)..'; iAirAAThreatThreshold='..(iAirAAThreatThreshold or 'nil')..'; tOptionalStartMidpointAdjustForDetailedCheck='..repru(tOptionalStartMidpointAdjustForDetailedCheck)) end
    local iAngleToDestination, iDistanceToDestination, iAngleToInterim, iDistanceToInterim, iInterimBestRange, tStartZoneMidpoint
    local tDestinationMidpoint
    if iEndPlateauOrZero == 0 then
        tDestinationMidpoint = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iEndLandOrWaterZone]][M28Map.subrefPondWaterZones][iEndLandOrWaterZone][M28Map.subrefMidpoint]
    else
        tDestinationMidpoint = M28Map.tAllPlateaus[iEndPlateauOrZero][M28Map.subrefPlateauLandZones][iEndLandOrWaterZone][M28Map.subrefMidpoint]
    end

    local iDistFromOptionalStartToEnd
    if tOptionalStartMidpointAdjustForDetailedCheck then iDistFromOptionalStartToEnd = M28Utilities.GetDistanceBetweenPositions(tOptionalStartMidpointAdjustForDetailedCheck, tDestinationMidpoint) end
    function DetailedCheckIfTooMuchAAInInterimZone(tInterimLZOrWZData, tInterimLZOrWZTeamData, iInterimPlateauOrZero, iInterimZone, bUseMidpointAdjustPosition)
        local bTooMuchAA = false
        if iInterimZone == iEndLandOrWaterZone and iInterimPlateauOrZero == iEndPlateauOrZero then --Redundancy
            bTooMuchAA = true
            if bDebugMessages == true then LOG(sFunctionRef..'; Interim zone same as end zone so returning true for too much AA as redundancy') end
        else
            --First record base values if we havent alreayd
            if not(iAngleToDestination) then
                --Start zone midpoint
                local tMidpoint
                if bUseMidpointAdjustPosition then tMidpoint = tOptionalStartMidpointAdjustForDetailedCheck
                elseif iStartPlateauOrZero == 0 then
                    tMidpoint = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iStartLandOrWaterZone]][M28Map.subrefPondWaterZones][iStartLandOrWaterZone][M28Map.subrefMidpoint]
                else
                    tMidpoint = M28Map.tAllPlateaus[iStartPlateauOrZero][M28Map.subrefPlateauLandZones][iStartLandOrWaterZone][M28Map.subrefMidpoint]
                end
                tStartZoneMidpoint = {tMidpoint[1], tMidpoint[2], tMidpoint[3]}

                iAngleToDestination = M28Utilities.GetAngleFromAToB(tStartZoneMidpoint, tDestinationMidpoint)
                iDistanceToDestination = M28Utilities.GetDistanceBetweenPositions(tStartZoneMidpoint, tDestinationMidpoint)
                --If this zone midpoint isn't reasonably closer than the start position then dont use it
                if tOptionalStartMidpointAdjustForDetailedCheck and iDistanceToDestination + 10 >= iDistFromOptionalStartToEnd then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will update the start position to be used for the line to the optional start='..repru(tOptionalStartMidpointAdjustForDetailedCheck)..'; as iDistanceToDestination='..iDistanceToDestination..'; while iDistFromOptionalStartToEnd='..iDistFromOptionalStartToEnd) end
                    tStartZoneMidpoint = {tOptionalStartMidpointAdjustForDetailedCheck[1], tOptionalStartMidpointAdjustForDetailedCheck[2], tOptionalStartMidpointAdjustForDetailedCheck[3]}
                    iDistanceToDestination = iDistFromOptionalStartToEnd
                end
            end
            --Work ont values specific to this interim zone
            iAngleToInterim = M28Utilities.GetAngleFromAToB(tStartZoneMidpoint, tInterimLZOrWZData[M28Map.subrefMidpoint])
            iDistanceToInterim = M28Utilities.GetDistanceBetweenPositions(tStartZoneMidpoint, tInterimLZOrWZData[M28Map.subrefMidpoint])
            if iDistanceToInterim + 70 <= iDistanceToDestination and (M28Utilities.GetAngleDifference(iAngleToInterim, iAngleToDestination) <= 15 or iDistanceToInterim *0.5 + 30 <= iDistanceToDestination) then
                iInterimBestRange = 0
                local tEnemyAAUnits
                if M28Utilities.IsTableEmpty(tInterimLZOrWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    tEnemyAAUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryGroundAA, tInterimLZOrWZTeamData[M28Map.subrefTEnemyUnits])
                    if M28Utilities.IsTableEmpty(tEnemyAAUnits) == false then
                        for iUnit, oUnit in tEnemyAAUnits do
                            if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() >= 0.8 then
                                iInterimBestRange = math.max(iInterimBestRange, (oUnit[M28UnitInfo.refiAARange] or 0))
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy AA units empty='..tostring(M28Utilities.IsTableEmpty(tEnemyAAUnits))..'; iInterimBestRange='..iInterimBestRange..'; iDistanceToInterim='..iDistanceToInterim..'; iDistanceToDestination='..iDistanceToDestination) end
                    if iInterimBestRange > 0 and iDistanceToInterim + iInterimBestRange + 5 <= iDistanceToDestination then
                        --More detailed check; dont know what part in the zone we are targeting so want a margin of error
                        local iDistToUnit, iAngleToUnit, iDistFromUnitToTarget
                        for iUnit, oUnit in tEnemyAAUnits do
                            if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() >= 0.8 and (oUnit[M28UnitInfo.refiAARange] or 0) > 0 then
                                --IsLineFromAToBInRangeOfCircleAtC(iDistFromAToB, iDistFromAToC, iDistFromBToC, iAngleFromAToB, iAngleFromAToC, iCircleRadius)
                                --C is oUnit, B is destination zone midpoint, A is start zone midpoint
                                iDistToUnit = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tStartZoneMidpoint)
                                iAngleToUnit = M28Utilities.GetAngleFromAToB(tStartZoneMidpoint, oUnit:GetPosition())
                                iDistFromUnitToTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tDestinationMidpoint)
                                if bDebugMessages == true then LOG(sFunctionRef..'; Considering if will be in range of enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is in range='..tostring(M28Utilities.IsLineFromAToBInRangeOfCircleAtC(iDistanceToDestination, iDistToUnit, iDistFromUnitToTarget, iAngleToDestination, iAngleToUnit, oUnit[M28UnitInfo.refiAARange] + 35))..'; Unit position='..repru(oUnit:GetPosition())..'; tDestinationMidpoint='..repru(tDestinationMidpoint)..'; tStartZoneMidpoint='..repru(tStartZoneMidpoint)..'; iDistToUnit from start zone midpoint='..iDistToUnit..'; iDistFromUnitToTarget, being destination midpoint='..iDistFromUnitToTarget..'; iAngleToUnit='..iAngleToUnit) end
                                if M28Utilities.IsLineFromAToBInRangeOfCircleAtC(iDistanceToDestination, iDistToUnit, iDistFromUnitToTarget, iAngleToDestination, iAngleToUnit, oUnit[M28UnitInfo.refiAARange] + 35) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have too much AA when checking if in range of enemy, iGroundAAThreat before increase='..iGroundAAThreat)
                                        --Draw line
                                        ForkThread(M28Utilities.ForkedDrawLine, tStartZoneMidpoint, tDestinationMidpoint, math.random(1, 8))
                                    end
                                    bTooMuchAA = true
                                    if bReturnGroundAAThreatInstead then
                                        iGroundAAThreat = iGroundAAThreat + M28UnitInfo.GetAirThreatLevel({ oUnit }, true, false, true)
                                        if bReturnGroundAAUnitsAlongsideAAThreat then
                                            table.insert(toGroundAAUnits, oUnit)
                                        end
                                    else  break
                                    end
                                end
                            end
                        end
                    end
                end
            elseif bDebugMessages == true then LOG(sFunctionRef..': Too far awya by distance or by angle so treating it as not having too much AA')
            end
        end

        return bTooMuchAA
    end
    local bZoneHasTooMuchAA
    local iOverridePositionPlateau, iOverridePositionZone, bSameZoneAsPositionOverride
    if tOptionalStartMidpointAdjustForDetailedCheck then
        if bDebugMessages == true then LOG(sFunctionRef..': Getting override plateau and zone for tOptionalStartMidpointAdjustForDetailedCheck='..repru(tOptionalStartMidpointAdjustForDetailedCheck)) end
        iOverridePositionPlateau, iOverridePositionZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tOptionalStartMidpointAdjustForDetailedCheck)
    end
    if M28Utilities.IsTableEmpty(tBasePathingTable[subreftPlateauAndLandZonesInPath]) == false then


        for iEntry, tPlateauAndLandZone in tBasePathingTable[subreftPlateauAndLandZonesInPath] do
            local tLZData = M28Map.tAllPlateaus[tPlateauAndLandZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndLandZone[2]]
            local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
            bSameZoneAsPositionOverride = false
            if iOverridePositionPlateau and iOverridePositionPlateau == tPlateauAndLandZone[1] and iOverridePositionZone == tPlateauAndLandZone[2] then bSameZoneAsPositionOverride = true end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry '..iEntry..'; iPlateau='..tPlateauAndLandZone[1]..'; iLandZone='..tPlateauAndLandZone[2]..'; Is there AA in land zone='..tostring(IsThereAAInLandZone(tLZTeamData, bIgnoreAirAAThreat, iGroundAAThreatThreshold, iAirAAThreatThreshold))..'; LZ groundAA threat='..tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA]..'; tLZTeamData[M28Map.refiEnemyAirAAThreat]='..tLZTeamData[M28Map.refiEnemyAirAAThreat]..'; iAirAAThreatThreshold='..(iAirAAThreatThreshold or 0)) end
            if bReturnGroundAAThreatInstead then
                if bDoDetailedCheckForAA then
                    DetailedCheckIfTooMuchAAInInterimZone(tLZData, tLZTeamData, tPlateauAndLandZone[1], tPlateauAndLandZone[2], bSameZoneAsPositionOverride)
                    if bDebugMessages == true then LOG(sFunctionRef..': Doing detailed check, iGroundAAThreat after checking for this zone='..iGroundAAThreat) end
                else
                    if (tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) > 0 then
                        iGroundAAThreat = iGroundAAThreat + tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA]
                        if bReturnGroundAAUnitsAlongsideAAThreat then --redundancy - not currently planning on using for this, only for detailed check
                            local tGroundAAInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryGroundAA, tLZTeamData[M28Map.subrefTEnemyUnits])
                            if M28Utilities.IsTableEmpty(tGroundAAInZone) == false then
                                for iUnit, oUnit in tGroundAAInZone do
                                    if M28UnitInfo.IsUnitValid(oUnit) then
                                        table.insert(toGroundAAUnits, oUnit)
                                    end
                                end
                            end
                        end
                    end
                end
            else
                bZoneHasTooMuchAA = IsThereAAInLandZone(tLZTeamData, bIgnoreAirAAThreat, iGroundAAThreatThreshold, iAirAAThreatThreshold)
                if bZoneHasTooMuchAA then
                    if bDebugMessages == true then LOG(sFunctionRef..': There is too much AA in this land zone, tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA]='..(tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0)..'; tLZTeamData[M28Map.refiEnemyAirAAThreat]='..(tLZTeamData[M28Map.refiEnemyAirAAThreat] or 0)..'; tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]='..(tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0)..'; bDoDetailedCheckForAA='..tostring(bDoDetailedCheckForAA or false)) end
                    if bDoDetailedCheckForAA and (bIgnoreAirAAThreat or IsThereAAInLandZone(tLZTeamData, false, -1, iAirAAThreatThreshold)) then
                        --There is too much groundAA (rather than AirAA) so want to do more detailed check to see if groundAA is in range
                        if DetailedCheckIfTooMuchAAInInterimZone(tLZData, tLZTeamData, tPlateauAndLandZone[1], tPlateauAndLandZone[2], bSameZoneAsPositionOverride) then
                            if bDebugMessages == true then LOG(sFunctionRef..': After doing detailed check it is still not safe') end
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': After doing detailed check it is safe, i.e. groundAA is too far away') end
                        end
                    else
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return true
                    end
                end
            end
        end
    end
    if M28Utilities.IsTableEmpty(tBasePathingTable[subreftWaterZonesInPath]) == false then
        for iEntry, iWaterZone in tBasePathingTable[subreftWaterZonesInPath] do
            local tWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone]
            local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
            bSameZoneAsPositionOverride = false
            if iOverridePositionPlateau and iOverridePositionPlateau == 0 and iOverridePositionZone == iWaterZone then bSameZoneAsPositionOverride = true end

            if bDebugMessages == true then
                LOG(sFunctionRef..': Checking along water zone path, iEntry='..iEntry..'; iWaterZone='..iWaterZone..'; IsThereAAInWaterZone='..tostring(IsThereAAInWaterZone(tWZTeamData, bIgnoreAirAAThreat, iGroundAAThreatThreshold, iAirAAThreatThreshold))..'; tWZTeamData groundAA='..tWZTeamData[M28Map.subrefWZThreatEnemyAA]..'; AirAA threat in WZ='..tWZTeamData[M28Map.refiEnemyAirAAThreat])
                M28Map.DrawSpecificWaterZone(iWaterZone)
            end
            if bReturnGroundAAThreatInstead then
                if bDoDetailedCheckForAA then
                    DetailedCheckIfTooMuchAAInInterimZone(tWZData, tWZTeamData, 0, iWaterZone, bSameZoneAsPositionOverride)
                else
                    if (tWZTeamData[M28Map.subrefWZThreatEnemyAA] or 0) > 0 then
                        iGroundAAThreat = iGroundAAThreat + tWZTeamData[M28Map.subrefWZThreatEnemyAA]
                        if bReturnGroundAAUnitsAlongsideAAThreat then --redundancy - not currently planning on using for this, only for detailed check
                            local tGroundAAInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryGroundAA, tWZTeamData[M28Map.subrefTEnemyUnits])
                            if M28Utilities.IsTableEmpty(tGroundAAInZone) == false then
                                for iUnit, oUnit in tGroundAAInZone do
                                    if M28UnitInfo.IsUnitValid(oUnit) then
                                        table.insert(toGroundAAUnits, oUnit)
                                    end
                                end
                            end
                        end
                    end
                end
            else
                bZoneHasTooMuchAA = IsThereAAInWaterZone(tWZTeamData, bIgnoreAirAAThreat, iGroundAAThreatThreshold, iAirAAThreatThreshold)
                if bZoneHasTooMuchAA then
                    --If using torp bombers check if reason for failure is due to enemy groundAA threat
                    if bDebugMessages == true then LOG(sFunctionRef..': TOo much AA in water zone') end
                    if bUsingTorpBombers and not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbTooMuchGroundNavalAAForTorpBombers]) and not(tWZTeamData[M28Map.subrefbWZOnlyHoverEnemies]) and not(IsThereAAInWaterZone(tWZTeamData, true, 100000000, iAirAAThreatThreshold)) then
                        --We are only ignoring this target because there is too much groundAA in the water zone
                        M28Team.tAirSubteamData[iAirSubteam][M28Team.refbTooMuchGroundNavalAAForTorpBombers] = true
                    end

                    if bDoDetailedCheckForAA and (bIgnoreAirAAThreat or IsThereAAInWaterZone(tWZTeamData, false, -1, iAirAAThreatThreshold)) then
                        --There is too much groundAA (rather than AirAA) so want to do more detailed check to see if groundAA is in range
                        if DetailedCheckIfTooMuchAAInInterimZone(tWZData, tWZTeamData, 0, iWaterZone, bSameZoneAsPositionOverride) then
                            if bDebugMessages == true then LOG(sFunctionRef..': After doing detailed check it is still not safe') end
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': After doing detailed check it is safe, i.e. groundAA is too far away') end
                        end
                    else

                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return true
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bReturnGroundAAThreatInstead then
        if bReturnGroundAAUnitsAlongsideAAThreat then return iGroundAAThreat, toGroundAAUnits
        else
            return iGroundAAThreat
        end
    else
        return false
    end
end

function AddEnemyAirUnitsAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iEndPlateauOrZero, iEndLandOrWaterZone, tbAlongPathPlateauAndZonesAlreadyAdded, tEnemyAirTargets)
    --Should only call if we have added enemy air units in the target zone; will also add any air units in a direct line (ignoring adjacent zones) to get from the start zone to the target
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddEnemyAirUnitsAlongPath'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --First record that we have added enemies from this zone
    if not(tbAlongPathPlateauAndZonesAlreadyAdded[iEndPlateauOrZero]) then tbAlongPathPlateauAndZonesAlreadyAdded[iEndPlateauOrZero] = {} end
    tbAlongPathPlateauAndZonesAlreadyAdded[iEndPlateauOrZero][iEndLandOrWaterZone] = true

    --Next get the zones that will travel along to get to the target
    CalculateAirTravelPath(iStartPlateauOrZero, iStartLandOrWaterZone, iEndPlateauOrZero, iEndLandOrWaterZone)
    local tBasePathingTable = tAirZonePathingFromZoneToZone[iStartPlateauOrZero][iStartLandOrWaterZone][iEndPlateauOrZero][iEndLandOrWaterZone]

    if bDebugMessages == true then LOG(sFunctionRef..': Near start at time '..GetGameTimeSeconds()..', iStartPlateauOrZero='..iStartPlateauOrZero..'; iStartLandOrWaterZone='..iStartLandOrWaterZone..'; iEndPlateauOrZero='..iEndPlateauOrZero..'; iEndLandOrWaterZone='..iEndLandOrWaterZone..'; bIgnoreAirAAThreat='..tostring(bIgnoreAirAAThreat or false)..'; iGroundAAThreatThreshold='..(iGroundAAThreatThreshold or 'nil')..'; Is table of land azones in path empty='..tostring(M28Utilities.IsTableEmpty(tBasePathingTable[subreftPlateauAndLandZonesInPath]) or false)..'; Is table of water zones in path empty='..tostring(M28Utilities.IsTableEmpty(tBasePathingTable[subreftWaterZonesInPath]) or false)..'; iAirAAThreatThreshold='..(iAirAAThreatThreshold or 'nil')..'; tOptionalStartMidpointAdjustForDetailedCheck='..repru(tOptionalStartMidpointAdjustForDetailedCheck)) end
    local iAngleToDestination, iDistanceToDestination, iAngleToInterim, iDistanceToInterim, iInterimBestRange, tStartZoneMidpoint
    local tDestinationMidpoint
    if iEndPlateauOrZero == 0 then
        tDestinationMidpoint = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iEndLandOrWaterZone]][M28Map.subrefPondWaterZones][iEndLandOrWaterZone][M28Map.subrefMidpoint]
    else
        tDestinationMidpoint = M28Map.tAllPlateaus[iEndPlateauOrZero][M28Map.subrefPlateauLandZones][iEndLandOrWaterZone][M28Map.subrefMidpoint]
    end

    local iCurPlateau, iCurZone
    if M28Utilities.IsTableEmpty(tBasePathingTable[subreftPlateauAndLandZonesInPath]) == false then
        for iEntry, tPlateauAndLandZone in tBasePathingTable[subreftPlateauAndLandZonesInPath] do
            if not(tbAlongPathPlateauAndZonesAlreadyAdded[tPlateauAndLandZone[1]][tPlateauAndLandZone[2]]) then
                iCurPlateau = tPlateauAndLandZone[1]
                iCurZone = tPlateauAndLandZone[2]
                if not(tbAlongPathPlateauAndZonesAlreadyAdded[iCurPlateau]) then tbAlongPathPlateauAndZonesAlreadyAdded[iCurPlateau] = {} end
                tbAlongPathPlateauAndZonesAlreadyAdded[iCurPlateau][iCurZone] = true

                local tLZData = M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurZone]
                local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]

                if bDebugMessages == true then LOG(sFunctionRef..': Considering entry '..iEntry..'; iCurPlateau='..iCurPlateau..'; iCurZone='..iCurZone) end
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) == false then
                    for iUnit, oUnit in tLZTeamData[M28Map.reftLZEnemyAirUnits] do
                        if M28UnitInfo.IsUnitValid(oUnit) and not(oUnit:IsUnitState('Attached')) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' as an enemy air target') end
                            table.insert(tEnemyAirTargets, oUnit)
                        end
                    end
                end
            end
        end
    end
    if M28Utilities.IsTableEmpty(tBasePathingTable[subreftWaterZonesInPath]) == false then
        for iEntry, iWaterZone in tBasePathingTable[subreftWaterZonesInPath] do
            if not(tbAlongPathPlateauAndZonesAlreadyAdded[0][iWaterZone]) then
                if not(tbAlongPathPlateauAndZonesAlreadyAdded[0]) then tbAlongPathPlateauAndZonesAlreadyAdded[0] = {} end
                tbAlongPathPlateauAndZonesAlreadyAdded[0][iWaterZone] = true

                local tWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone]
                local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]

                if bDebugMessages == true then LOG(sFunctionRef..': Considering entry '..iEntry..'; iWaterZone='..iWaterZone) end
                if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftLZEnemyAirUnits]) == false then
                    for iUnit, oUnit in tWZTeamData[M28Map.reftLZEnemyAirUnits] do
                        if M28UnitInfo.IsUnitValid(oUnit) and not(oUnit:IsUnitState('Attached')) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' as an enemy air target') end
                            table.insert(tEnemyAirTargets, oUnit)
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageAirAAUnits(iTeam, iAirSubteam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageAirAAUnits'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Get available airAA units (owned by M28 brains in our subteam):
    local tAvailableAirAA, tAirForRefueling, tUnavailableUnits, tInCombatUnits = GetAvailableLowFuelAndInUseAirUnits(iTeam, iAirSubteam, M28UnitInfo.refCategoryAirAA)
    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, time='..GetGameTimeSeconds()..'; Is tAvailableAirAA empty='..tostring(M28Utilities.IsTableEmpty(tAvailableAirAA))..'; iAirSubteam='..iAirSubteam..'; M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint]='..repru(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint])) end
    --Update threat level
    M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] = M28UnitInfo.GetAirThreatLevel(tAvailableAirAA, false, true) + M28UnitInfo.GetAirThreatLevel(tAirForRefueling, false, true) + M28UnitInfo.GetAirThreatLevel(tUnavailableUnits, false, true) + M28UnitInfo.GetAirThreatLevel(tInCombatUnits, false, true)
    --Include human air player if we have gifted them asfs
    if M28Team.tAirSubteamData[iAirSubteam][M28Team.refoLastHumanGiftedASFs] then
        local oHumanToInclude = M28Team.tAirSubteamData[iAirSubteam][M28Team.refoLastHumanGiftedASFs]
        local iHumanAirAAToInclude = 0
        if not(oHumanToInclude) or oHumanToInclude.M28IsDefeated or oHumanToInclude:IsDefeated() then
            oHumanToInclude = nil
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
                local iCurAirAAThreat = 0
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                    if oBrain.Human or (not(oBrain.M28AI) and not(oBrain.BrainType == 'AI') and not(M28Conditions.IsCivilianBrain(oBrain))) then
                        iCurAirAAThreat = M28UnitInfo.GetMassCostOfUnits(oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirAA * categories.TECH3, false, true))
                        if iCurAirAAThreat > iHumanAirAAToInclude then
                            oHumanToInclude = oBrain
                            iHumanAirAAToInclude = iCurAirAAThreat
                        end
                    end
                end
            end
            M28Team.tAirSubteamData[iAirSubteam][M28Team.refoLastHumanGiftedASFs] = oHumanToInclude
        else
            iHumanAirAAToInclude = M28UnitInfo.GetMassCostOfUnits(oHumanToInclude:GetListOfUnits(M28UnitInfo.refCategoryAirAA * categories.TECH3, false, true))
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Will increase AirAA threat for the air subteam '..iAirSubteam..' based on human player '..(oHumanToInclude.Nickname or 'nil')..'; iHumanAirAAToInclude='..iHumanAirAAToInclude) end
        if iHumanAirAAToInclude > 0 then
            M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] = M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] + iHumanAirAAToInclude
        end
    end

    local iAdjacentGroundAAMax = M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] * 0.15 --Even if we want to consider attacking adjacent zones, thsi is the max groundAA to permit

    --Update if we have air control and/or are far behind on air
    local iFarBehindFactor = 0.75
    local iAirControlFactor = 1.2
    if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] >= 25000 then
        local iEnemyThreatOverThreshold = M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] - 25000
        iFarBehindFactor = math.min(0.9, 0.75 + iEnemyThreatOverThreshold / 1000)
        iAirControlFactor = math.min(1.4, iEnemyThreatOverThreshold / 1000)
    end

    if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] >= 200 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] and M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] < M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * iFarBehindFactor then
        M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir] = true
    else M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir] = false
    end

    if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * iAirControlFactor < M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] then
        M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] = true
    else M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] = false
    end
    if bDebugMessages == true then LOG(sFunctionRef..': M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl]='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl])..'; M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir]='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir])..'; refiEnemyAirAAThreat='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat]..'; subrefiHighestFriendlyFactoryTech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; OurAAThreat='..M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat]) end

    --Update orders for any in combat airaa units, and track the assigned damage to them
    local tExistingThreatAssignedByUnitRef = {}
    if M28Utilities.IsTableEmpty(tInCombatUnits) == false then
        tExistingThreatAssignedByUnitRef = UpdateOrdersForExistingAirAATargets(tInCombatUnits, not(M28Utilities.IsTableEmpty(tAvailableAirAA)))
    end

    if M28Utilities.IsTableEmpty(tAvailableAirAA) == false then
        local tEnemyAirTargets = {}
        local tbPlateauAndLandZonesConsidered = {} --[x] = plateau, [y] = land zone, returns true if considered
        local tbAdjacentPlateauAndLandZonesConsidered = {} --as above, but only set to true if we have considered all adjacent locations
        local tbAlongPathPlateauAndZonesAlreadyAdded = {} --as above, but only set to true if we have considered when getting enemy units along a path
        local tbWaterZonesConsidered = {} --[x] = water zone, returns true if considered
        local tbAdjacentWaterZonesConsidered = {} --as above but only set to true if we have considered all adjacent locations
        local refiAvoidAllAA = 0
        local refiAvoidOnlyGroundAA = 1
        local refiIgnoreAllAA = 2

        local iStartPlateauOrZero, iStartLandOrWaterZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint])
        if (iStartPlateauOrZero or 0) > 0 then
            if (iStartLandOrWaterZone or 0) == 0 then
                iStartLandOrWaterZone = M28Map.GetWaterZoneFromPosition(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint])
                iStartPlateauOrZero = 0
            end
        end
        if not(iStartPlateauOrZero) or not(iStartLandOrWaterZone) then
            M28Utilities.ErrorHandler('Dont have valid start zone for iAirSubteam='..iAirSubteam..', air support point=X'..(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint][1] or 'nil')..'Z'..(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint][3] or 'nil'))
        end

        local bDontCheckPacifistArea = not(M28Overseer.bPacifistModeActive)


        function AddEnemyAirInLandZoneIfNoAA(iPlateau, iLandZone, bAddAdjacentZones, refiAASearchType, iOptionalGroundThreatThresholdOverride, iOptionalAirThreatThresholdOverride, iOptionalMaxDistToEdgeOfAdjacentZone, tOptionalStartPointForEdgeOfAdacentZone, toOptionalUnitOverride, iOptionalAdjacentZoneSearchType)
            --See above for refiAASearchTypes, i.e. refiAvoidAllAA, refiAvoidOnlyGroundAA, refiIgnoreAllAA

            if bDebugMessages == true then LOG(sFunctionRef..': refiAASearchType='..(refiAASearchType or 'nil')..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; tbAdjacentPlateauAndLandZonesConsidered[refiAASearchType][iPlateau][iLandZone]='..tostring(tbAdjacentPlateauAndLandZonesConsidered[refiAASearchType][iPlateau][iLandZone] or false)..'; bAddAdjacentZones='..tostring(bAddAdjacentZones or false)..'; tbPlateauAndLandZonesConsidered[refiAASearchType][iPlateau][iLandZone]='..tostring(tbPlateauAndLandZonesConsidered[refiAASearchType][iPlateau][iLandZone] or false)) end
            if not(tbAdjacentPlateauAndLandZonesConsidered[refiAASearchType][iPlateau][iLandZone]) and (bAddAdjacentZones or not(tbPlateauAndLandZonesConsidered[refiAASearchType][iPlateau][iLandZone])) then
                if not(tbPlateauAndLandZonesConsidered[refiAASearchType][iPlateau]) then
                    if not(tbPlateauAndLandZonesConsidered[refiAASearchType]) then tbPlateauAndLandZonesConsidered[refiAASearchType] = {} end
                    tbPlateauAndLandZonesConsidered[refiAASearchType][iPlateau] = {}
                end
                tbPlateauAndLandZonesConsidered[refiAASearchType][iPlateau][iLandZone] = true
                local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                if bDebugMessages == true then LOG(sFunctionRef..': LZ midpoint='..repru(tLZData[M28Map.subrefMidpoint])..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]))..'; Playable area='..repru(M28Map.rMapPlayableArea)..'; Is zone table of enemy air unit sempty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.reftLZEnemyAirUnits]))) end
                if bDontCheckPacifistArea or not(tLZData[M28Map.subrefbPacifistArea]) then
                    --if not(M28Map.bIsCampaignMap) or M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then --will handle via individual targeting as e.g. for transports we could try intercepting the destination
                    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy air units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]))) end
                    if M28Utilities.IsTableEmpty(toOptionalUnitOverride or tLZTeamData[M28Map.reftLZEnemyAirUnits]) == false then
                        --Add units from here unless there is too much AA
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to add enemy air units in land zone '..iLandZone..'; refiAASearchType='..refiAASearchType..'; DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iPlateau, iLandZone, refiAASearchType == refiAvoidOnlyGroundAA, nil, nil)='..tostring(DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iPlateau, iLandZone, refiAASearchType == refiAvoidOnlyGroundAA, nil, nil))) end
                        local bUseDetailedCheck = false
                        if tLZTeamData[M28Map.subrefLZSValue] > 10 and (tLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) > 0 then bUseDetailedCheck = true end --More precise check if we have friendly structures in the zone
                        if refiAASearchType == refiIgnoreAllAA or not(DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iPlateau, iLandZone, refiAASearchType == refiAvoidOnlyGroundAA, iOptionalGroundThreatThresholdOverride, iOptionalAirThreatThresholdOverride, nil, nil, bUseDetailedCheck)) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will add all enemy air as potential targets') end
                            for iUnit, oUnit in (toOptionalUnitOverride or tLZTeamData[M28Map.reftLZEnemyAirUnits]) do
                                if M28UnitInfo.IsUnitValid(oUnit) and not(oUnit:IsUnitState('Attached')) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Adding enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' as an enemy air target') end
                                    table.insert(tEnemyAirTargets, oUnit)
                                end
                            end
                            AddEnemyAirUnitsAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iPlateau, iLandZone, tbAlongPathPlateauAndZonesAlreadyAdded, tEnemyAirTargets)
                        end
                    end
                    if bAddAdjacentZones then
                        local iAdjacentAASearchType = iOptionalAdjacentZoneSearchType or refiAASearchType

                        if iAdjacentAASearchType == refiIgnoreAllAA then
                            iAdjacentAASearchType = refiAvoidOnlyGroundAA
                        end

                        local bIncludeCurZone
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                if bDebugMessages == true then LOG(sFunctionRef..': About to consider for iAdjLZ='..iAdjLZ..'; Dist between midpoints='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMidpoint])) end
                                if not(iOptionalMaxDistToEdgeOfAdjacentZone) then bIncludeCurZone = true
                                else
                                    bIncludeCurZone = M28Conditions.IsPositionCloseToZoneEdge(iPlateau, iAdjLZ, iOptionalMaxDistToEdgeOfAdjacentZone, tOptionalStartPointForEdgeOfAdacentZone)
                                end
                                if bIncludeCurZone then
                                    AddEnemyAirInLandZoneIfNoAA(iPlateau, iAdjLZ, false, iAdjacentAASearchType, iAdjacentGroundAAMax)
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
                            for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
                                if not(iOptionalMaxDistToEdgeOfAdjacentZone) then bIncludeCurZone = true
                                else
                                    bIncludeCurZone = M28Conditions.IsPositionCloseToZoneEdge(0, tSubtable[M28Map.subrefAWZRef], iOptionalMaxDistToEdgeOfAdjacentZone, tOptionalStartPointForEdgeOfAdacentZone)
                                end
                                if bIncludeCurZone then
                                    AddEnemyAirInWaterZoneIfNoAA(tSubtable[M28Map.subrefAWZRef], false, iAdjacentAASearchType, iAdjacentGroundAAMax)
                                end
                            end
                        end
                        if not(tbAdjacentPlateauAndLandZonesConsidered[iAdjacentAASearchType][iPlateau]) then
                            if not(tbAdjacentPlateauAndLandZonesConsidered[iAdjacentAASearchType]) then tbAdjacentPlateauAndLandZonesConsidered[iAdjacentAASearchType] = {} end
                            tbAdjacentPlateauAndLandZonesConsidered[iAdjacentAASearchType][iPlateau] = {}
                        end
                        tbAdjacentPlateauAndLandZonesConsidered[iAdjacentAASearchType][iPlateau][iLandZone] = true
                    end
                    --end
                end
            end
        end
        function AddEnemyAirInWaterZoneIfNoAA(iWaterZone, bAddAdjacentZones, refiAASearchType, iOptionalGroundThreatThresholdOverride, iOptionalAirThreatThresholdOverride, iOptionalMaxDistToEdgeOfAdjacentZone, tOptionalStartPointForEdgeOfAdacentZone, toOptionalUnitOverride, iOptionalAdjacentZoneSearchType)
            --See above for refiAASearchTypes, i.e. refiAvoidAllAA, refiAvoidOnlyGroundAA, refiIgnoreAllAA
            if bDebugMessages == true then LOG(sFunctionRef..': AddEnemyAirInWaterZoneIfNoAA: iWaterZone='..iWaterZone..'; refiAASearchType='..refiAASearchType..'; Adjacent WZ considered='..tostring(tbAdjacentWaterZonesConsidered[refiAASearchType][iWaterZone] or false)..'; This zone considered='..tostring(tbWaterZonesConsidered[refiAASearchType][iWaterZone] or false)..'; bAddAdjacentZones='..tostring(bAddAdjacentZones or false)..'; iOptionalAirThreatThresholdOverride='..(iOptionalAirThreatThresholdOverride or 'nil')) end
            if not(tbAdjacentWaterZonesConsidered[refiAASearchType][iWaterZone]) and (bAddAdjacentZones or not(tbWaterZonesConsidered[refiAASearchType][iWaterZone])) then
                if not(tbWaterZonesConsidered[refiAASearchType]) then tbWaterZonesConsidered[refiAASearchType] = {} end
                tbWaterZonesConsidered[refiAASearchType][iWaterZone] = true
                local tWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone]
                if bDontCheckPacifistArea or not(tWZData[M28Map.subrefbPacifistArea]) then
                    --if not(M28Map.bIsCampaignMap) or M28Conditions.IsLocationInPlayableArea(tWZData[M28Map.subrefMidpoint]) then --will handle via individual targeting as e.g. for transports we could try intercepting the destination
                    local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy air units empty for this WZ='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]))) end

                    if M28Utilities.IsTableEmpty(toOptionalUnitOverride or tWZTeamData[M28Map.reftWZEnemyAirUnits]) == false then
                        --Add air units unless too much enemy AA
                        local bUseDetailedCheck = false
                        if tWZTeamData[M28Map.subrefWZbCoreBase] or tWZTeamData[M28Map.refiModDistancePercent] <= 0.35 then bUseDetailedCheck = true end --More precise check if we have friendly structures in the zone or mod dist is low
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': About to check for air units in a zone, iTeam='..iTeam..'; iStartPlateauOrZero='..iStartPlateauOrZero..'; iStartLandOrWaterZone='..(iStartLandOrWaterZone or 'nil')..'; iWaterZone='..(iWaterZone or 'nil'))
                            LOG(sFunctionRef..': Considering whether to add enemy air units in water zone '..iWaterZone..'; refiAASearchType='..refiAASearchType..'; DoesEnemyHaveAAThreatAlongPath='..tostring(DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, 0, iWaterZone, refiAASearchType == refiAvoidOnlyGroundAA, nil, nil))..'; iOptionalGroundThreatThresholdOverride='..(iOptionalGroundThreatThresholdOverride or 'nil')..'; iOptionalAirThreatThresholdOverride='..(iOptionalAirThreatThresholdOverride or 'nil')..'; Mod dist='..(tWZTeamData[M28Map.refiModDistancePercent] or 0)..'; bUseDetailedCheck='..tostring(bUseDetailedCheck or false))
                        end
                        if refiAASearchType == refiIgnoreAllAA or not(DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, 0, iWaterZone, refiAASearchType == refiAvoidOnlyGroundAA, iOptionalGroundThreatThresholdOverride, iOptionalAirThreatThresholdOverride, nil, nil, bUseDetailedCheck)) then
                            for iUnit, oUnit in (toOptionalUnitOverride or tWZTeamData[M28Map.reftWZEnemyAirUnits]) do
                                if M28UnitInfo.IsUnitValid(oUnit) and not(oUnit:IsUnitState('Attached')) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Adding enemy air unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to tEnemyAirTargets') end
                                    table.insert(tEnemyAirTargets, oUnit)
                                end
                            end
                            AddEnemyAirUnitsAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, 0, iWaterZone, tbAlongPathPlateauAndZonesAlreadyAdded, tEnemyAirTargets)
                        end
                    end
                    if bAddAdjacentZones then
                        local iAdjacentAASearchType = iOptionalAdjacentZoneSearchType or refiAASearchType

                        if iAdjacentAASearchType == refiIgnoreAllAA then
                            iAdjacentAASearchType = refiAvoidOnlyGroundAA
                        end

                        local bIncludeCurZone
                        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                            for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                                if not(iOptionalMaxDistToEdgeOfAdjacentZone) then bIncludeCurZone = true
                                else
                                    bIncludeCurZone = M28Conditions.IsPositionCloseToZoneEdge(0, iAdjWZ, iOptionalMaxDistToEdgeOfAdjacentZone, tOptionalStartPointForEdgeOfAdacentZone)
                                end
                                if bIncludeCurZone then
                                    AddEnemyAirInWaterZoneIfNoAA(iAdjWZ, false, iAdjacentAASearchType)
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
                            for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                                if not(iOptionalMaxDistToEdgeOfAdjacentZone) then bIncludeCurZone = true
                                else
                                    bIncludeCurZone = M28Conditions.IsPositionCloseToZoneEdge(tSubtable[M28Map.subrefWPlatAndLZNumber][1], tSubtable[M28Map.subrefWPlatAndLZNumber][2], iOptionalMaxDistToEdgeOfAdjacentZone, tOptionalStartPointForEdgeOfAdacentZone)
                                end
                                if bIncludeCurZone then
                                    if bDebugMessages == true then LOG(sFunctionRef..': About to add enemy air in land zone if no AA, iEntry='..iEntry..'; tSubtable='..repru(tSubtable)..'; tSubtable[M28Map.subrefWPlatAndLZNumber][1]='..(tSubtable[M28Map.subrefWPlatAndLZNumber][1] or 'nil')..'; tSubtable[M28Map.subrefWPlatAndLZNumber][2]='..(tSubtable[M28Map.subrefWPlatAndLZNumber][2] or 'nil')) end
                                    AddEnemyAirInLandZoneIfNoAA(tSubtable[M28Map.subrefWPlatAndLZNumber][1], tSubtable[M28Map.subrefWPlatAndLZNumber][2], false, iAdjacentAASearchType)
                                end
                            end
                        end
                        if not(tbAdjacentWaterZonesConsidered[iAdjacentAASearchType]) then tbAdjacentWaterZonesConsidered[iAdjacentAASearchType] = {} end
                        tbAdjacentWaterZonesConsidered[iAdjacentAASearchType][iWaterZone] = true
                    end
                    --end
                end
            end
        end
        --Determine targets and issue orders to attack them

        --Suicide into enemy strats
        if M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.toBomberSuicideTargets]) then
            AssignASFsToEnemyStrats(tAvailableAirAA, iTeam, iAirSubteam)
        end
        if M28Utilities.IsTableEmpty(tAvailableAirAA) == false then


            --First search for air near priority defence targets - look for enemies near priority defensive targets and core bases
            local iAASearchType
            local iGroundAAThresholdForPriorityDefence
            if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir] then
                iAASearchType = refiAvoidOnlyGroundAA
            else
                iAASearchType = refiIgnoreAllAA

            end


            local iPlateauOrZero, iLandOrWaterZone
            local iDistanceToZoneEdgeToConsider = 60 --i.e. when deciding whether to consider adjacent zones, will only consdier an adjacent zone if the unit is within this distance of the edge of that zone
            --Cybran M6 specific - suicide into czar if it is close to control centre
            if M28Map.bIsCampaignMap and M28Utilities.IsTableEmpty(tAvailableAirAA) == false and M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives]) then
                --Is the czar close?
                if M28UnitInfo.IsUnitValid(ScenarioInfo.ControlCenter) and ScenarioInfo.Czar and M28Utilities.IsTableEmpty(ScenarioInfo.Czar) == false then
                    local oClosestCzar, iCurCzarDist
                    local iClosestCzar = 100000
                    local tControlCentre = ScenarioInfo.ControlCenter:GetPosition()
                    for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives] do
                        iCurCzarDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tControlCentre)
                        if iCurCzarDist < iClosestCzar then
                            iClosestCzar = iCurCzarDist
                            oClosestCzar = oUnit
                        end
                    end
                    if iClosestCzar <= 220 then --tried with 120 and control centre dies before asfs even get in range; at 180 we get 1 pass
                        table.insert(tEnemyAirTargets, oClosestCzar)
                    end
                end
                if M28Utilities.IsTableEmpty(tEnemyAirTargets) == false then
                    --SendMessage(aiBrain, sMessageType, sMessage, iOptionalDelayBeforeSending, iOptionalTimeBetweenMessageType, bOnlySendToTeam, bWaitUntilHaveACU)
                    local aiBrain
                    for iBrain, oBrain in M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains] do
                        if oBrain.M28AI then aiBrain = oBrain break end
                    end
                    if aiBrain then
                        --SendMessage(aiBrain, sMessageType,    sMessage,                                   iOptionalDelayBeforeSending, iOptionalTimeBetweenMessageType, bOnlySendToTeam, bWaitUntilHaveACU)
                        M28Chat.SendMessage(aiBrain, 'M6Czar', 'Time to pull out the goalies, every air unit attack!', 0,                           10000000,                                false,          M28Map.bIsCampaignMap)
                    end
                    AssignAirAATargets(tAvailableAirAA, tEnemyAirTargets, iTeam, iAirSubteam, tExistingThreatAssignedByUnitRef)
                end
            end

            --Determine what threats to avoid for priority units
            local bAvoidLargeEnemyAirAA = false
            local iAirAAAvoidThreshold
            if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir] then
                bAvoidLargeEnemyAirAA = true
                iAirAAAvoidThreshold = M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] * 0.8
            else
                iAirAAAvoidThreshold = M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat]
            end
            local bAlwaysProtectACU = false
            if ScenarioInfo.Options.Victory == "demoralization" and ( not(ScenarioInfo.Options.Share == 'FullShare') or M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] == 1) then
                bAlwaysProtectACU = true
            end
            if M28Team.tTeamData[iTeam][M28Team.refbDontHaveBuildingsOrACUInPlayableArea] then
                bAvoidLargeEnemyAirAA = false
                bAlwaysProtectACU = true
            end

            function GetAASearchTypeForPriorityUnit(oUnit, iPlateauOrZero, tUnitLZOrWZData, tUnitLZOrWZTeamData)
                --Only consider avoiding AA if no enemy air to ground threat in this zone or adjacent zone
                local bAvoidGroundAA
                if tUnitLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then bAvoidGroundAA = false
                else bAvoidGroundAA = M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir]
                end

                local bAvoidAAThreat = false
                if bAvoidLargeEnemyAirAA and (not(bAlwaysProtectACU) or not(EntityCategoryContains(categories.COMMAND, oUnit.UnitId))) and not(EntityCategoryContains(M28UnitInfo.refCategoryRestorer + M28UnitInfo.refCategoryCzar, oUnit.UnitId)) then
                    --Is this in a core zone?
                    if not(tUnitLZOrWZTeamData[M28Map.subrefLZbCoreBase] or tUnitLZOrWZTeamData[M28Map.subrefWZbCoreBase]) then
                        --Is this a land zone adjacent to a core land zone?
                        local bAdjacentToCoreZone = false
                        if iPlateauOrZero > 0 and M28Utilities.IsTableEmpty(tUnitLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false then
                            for iEntry, iAdjLZ in tUnitLZOrWZData[M28Map.subrefLZAdjacentLandZones] do
                                if M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] then
                                    bAdjacentToCoreZone = true
                                    break
                                end
                            end
                        end
                        if not(bAdjacentToCoreZone) then
                            --if have equiv of 7 t3 maa (just under 4 sams) then still engage
                            if (tUnitLZOrWZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0) + (tUnitLZOrWZTeamData[M28Map.subrefWZThreatAlliedAA] or 0) <= 5500 then
                                bAvoidAAThreat = true
                            end
                        end

                    end
                end

                local iPriorityAASearchType
                if bAvoidAAThreat then
                    --Avoid ground even if normally wouldnt
                    iPriorityAASearchType = refiAvoidAllAA
                elseif bAvoidGroundAA then
                    iPriorityAASearchType = refiAvoidOnlyGroundAA
                else
                    iPriorityAASearchType = refiIgnoreAllAA
                end
                return iPriorityAASearchType
            end
            local iCurUnitAASearchType

            if M28Utilities.IsTableEmpty(tAvailableAirAA) == false then
                if M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftACUExpAndPriorityDefenceOnSubteam]) == false then
                    local iGroundAAAdjacentThreshold = math.max(500, math.min(3000, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] * 0.01))
                    --if far behind on air then only want to defend ACUs (in assassination) or experimentals that are adjacent to a core zone, or units that have significant groundAA threat near them (but do this by adjusting the AirAA threshold for the groundAA nearby)

                    for iUnit, oUnit in M28Team.tAirSubteamData[iAirSubteam][M28Team.reftACUExpAndPriorityDefenceOnSubteam] do
                        iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                        local tUnitLZOrWZData
                        local tUnitLZOrWZTeamData
                        if bDebugMessages == true then LOG(sFunctionRef..': About to consider adding enemy air in land or water zone near priority unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' to protect, iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')) end
                        if iPlateauOrZero == 0 then
                            if (iLandOrWaterZone or 0) > 0 then
                                tUnitLZOrWZData = M28Map.tPondDetails[iLandOrWaterZone][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                                tUnitLZOrWZTeamData = tUnitLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                                if not(tbWaterZonesConsidered[iLandOrWaterZone]) then

                                    iCurUnitAASearchType = GetAASearchTypeForPriorityUnit(oUnit, iPlateauOrZero, tUnitLZOrWZData, tUnitLZOrWZTeamData)
                                    --AddEnemyAirInWaterZoneIfNoAA(iWaterZone, bAddAdjacentZones, refiAASearchType,         iOptionalGroundThreatThresholdOverride, iOptionalAirThreatThresholdOverride, iOptionalMaxDistToEdgeOfAdjacentZone, tOptionalStartPointForEdgeOfAdacentZone, toOptionalUnitOverride, iOptionalAdjacentZoneSearchType)
                                    AddEnemyAirInWaterZoneIfNoAA(iLandOrWaterZone, false, iCurUnitAASearchType,     iGroundAAAdjacentThreshold,iAirAAAvoidThreshold,       nil,     nil,   nil,    refiAvoidOnlyGroundAA)
                                    --Also include adjacent zones subject to air threat
                                    if iCurUnitAASearchType == refiIgnoreAllAA then
                                        AddEnemyAirInWaterZoneIfNoAA(iLandOrWaterZone, true, refiAvoidOnlyGroundAA,     iGroundAAAdjacentThreshold,iAirAAAvoidThreshold,       nil,     nil,   nil,    refiAvoidOnlyGroundAA)
                                    end
                                end
                            end
                        else
                            if (iLandOrWaterZone or 0) > 0 then
                                tUnitLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                                tUnitLZOrWZTeamData = tUnitLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                                iCurUnitAASearchType = GetAASearchTypeForPriorityUnit(oUnit, iPlateauOrZero, tUnitLZOrWZData, tUnitLZOrWZTeamData)

                                AddEnemyAirInLandZoneIfNoAA(iPlateauOrZero, iLandOrWaterZone, false, iCurUnitAASearchType, iGroundAAAdjacentThreshold, iAirAAAvoidThreshold)
                                if bDebugMessages == true then LOG(sFunctionRef..': About to consider adding enemy air in land zone near priority unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' to protect, iAASearchType='..iAASearchType..'; iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; tUnitLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat]='..(tUnitLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 'nil')..'; iCurUnitAASearchType='..iCurUnitAASearchType) end

                                --Also include adjacent zones subject to air threat
                                --AddEnemyAirInLandZoneIfNoAA(iPlateau, iLandZone, bAddAdjacentZones, refiAASearchType, iOptionalGroundThreatThresholdOverride, iOptionalAirThreatThresholdOverride)
                                if iCurUnitAASearchType == refiIgnoreAllAA then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will consider adjacent zones to zone '..iLandOrWaterZone..' but factoring in any groundAA threat, iGroundAAAdjacentThreshold='..iGroundAAAdjacentThreshold) end
                                    --AddEnemyAirInLandZoneIfNoAA(iPlateau, iLandZone,          bAddAdjacentZones, refiAASearchType, iOptionalGroundThreatThresholdOverride, iOptionalAirThreatThresholdOverride, iOptionalMaxDistToEdgeOfAdjacentZone, tOptionalStartPointForEdgeOfAdacentZone, toOptionalUnitOverride, iOptionalAdjacentZoneSearchType)
                                    AddEnemyAirInLandZoneIfNoAA(iPlateauOrZero, iLandOrWaterZone, true, refiAvoidOnlyGroundAA, iGroundAAAdjacentThreshold, iAirAAAvoidThreshold, iDistanceToZoneEdgeToConsider, oUnit:GetPosition(), nil,    refiAvoidOnlyGroundAA)
                                end

                            end
                        end
                    end
                end
                --Also protect gunships
                if M28UnitInfo.IsUnitValid(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]) then
                    iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': About to get the closest plateau or zone to the front gunship, front gunship='..(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]) or 'nil')..' at position '..repru(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition())..'; iPlateauOrZero for gunship='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Playable area='..repru(M28Map.rMapPlayableArea)..'; iAASearchType='..(iAASearchType or 'nil')..'; M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat]='..(M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] or 'nil')) end
                    local iGunshipGroundAAThreshold = math.min(3200,M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] * 0.15)
                    iGunshipGroundAAThreshold = math.min(3200,M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] * 0.15)
                    if not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl]) then
                        if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir] then iGunshipGroundAAThreshold = iGunshipGroundAAThreshold * 0.3
                        else iGunshipGroundAAThreshold = iGunshipGroundAAThreshold * 0.6
                        end
                    end

                    if bDebugMessages == true then LOG(sFunctionRef..': iGunshipGroundAAThreshold='..(iGunshipGroundAAThreshold or 'nil')) end
                    local tUnitLZOrWZData
                    local tUnitLZOrWZTeamData

                    if iPlateauOrZero == 0 then
                        if (iLandOrWaterZone or 0) > 0 then
                            tUnitLZOrWZData = M28Map.tPondDetails[iLandOrWaterZone][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                            tUnitLZOrWZTeamData = tUnitLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                            iCurUnitAASearchType = GetAASearchTypeForPriorityUnit(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship], iPlateauOrZero, tUnitLZOrWZData, tUnitLZOrWZTeamData)

                            if iCurUnitAASearchType == refiIgnoreAllAA and not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir]) then
                                --function AddEnemyAirInWaterZoneIfNoAA(iWaterZone,         bAddAdjacentZones, refiAASearchType,        iOptionalGroundThreatThresholdOverride, iOptionalAirThreatThresholdOverride,                    iOptionalMaxDistToEdgeOfAdjacentZone, tOptionalStartPointForEdgeOfAdacentZone,                              toOptionalUnitOverride, iOptionalAdjacentZoneSearchType)
                                AddEnemyAirInWaterZoneIfNoAA(iLandOrWaterZone, false, iCurUnitAASearchType,        iGunshipGroundAAThreshold               , iAirAAAvoidThreshold                            , iDistanceToZoneEdgeToConsider, M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition(), nil            , refiAvoidOnlyGroundAA)
                                AddEnemyAirInWaterZoneIfNoAA(iLandOrWaterZone, true, refiAvoidOnlyGroundAA,        iGunshipGroundAAThreshold * 0.25               , iAirAAAvoidThreshold                            , iDistanceToZoneEdgeToConsider, M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition(), nil            , refiAvoidOnlyGroundAA)
                            else
                                AddEnemyAirInWaterZoneIfNoAA(iLandOrWaterZone, false, iCurUnitAASearchType,        iGunshipGroundAAThreshold               , iAirAAAvoidThreshold                            , iDistanceToZoneEdgeToConsider, M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition())
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Gunship defence - FInished checking for enemy air in water zone and adjacent zones, is table of enemy targets empty='..tostring(M28Utilities.IsTableEmpty(tEnemyAirTargets))..'; iCurUnitAASearchType='..iCurUnitAASearchType) end
                        end
                    else
                        if (iLandOrWaterZone or 0) > 0 then
                            tUnitLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                            tUnitLZOrWZTeamData = tUnitLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                            iCurUnitAASearchType = GetAASearchTypeForPriorityUnit(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship], iPlateauOrZero, tUnitLZOrWZData, tUnitLZOrWZTeamData)

                            if bDebugMessages == true then LOG(sFunctionRef..': About to search for enemy air targets in land zone that gunship is in to defend gunship, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'#; will search adjacent zones if not far behind on air, far behind='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir])..'; iCurUnitAASearchType='..iCurUnitAASearchType) end
                            if iCurUnitAASearchType == refiIgnoreAllAA and not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir]) then
                                AddEnemyAirInLandZoneIfNoAA(iPlateauOrZero, iLandOrWaterZone, false, iCurUnitAASearchType, iGunshipGroundAAThreshold, iAirAAAvoidThreshold, iDistanceToZoneEdgeToConsider, M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition(), nil,  refiAvoidOnlyGroundAA)
                                AddEnemyAirInLandZoneIfNoAA(iPlateauOrZero, iLandOrWaterZone, true, refiAvoidOnlyGroundAA, iGunshipGroundAAThreshold * 0.25, iAirAAAvoidThreshold, iDistanceToZoneEdgeToConsider, M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition(), nil,  refiAvoidOnlyGroundAA)
                            else
                                AddEnemyAirInLandZoneIfNoAA(iPlateauOrZero, iLandOrWaterZone, not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir]), iCurUnitAASearchType, iGunshipGroundAAThreshold, iAirAAAvoidThreshold, iDistanceToZoneEdgeToConsider, M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition())
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Gunship defence - FInished checking for enemy air in land zone and adjacent zones, is table of enemy targets empty='..tostring(M28Utilities.IsTableEmpty(tEnemyAirTargets))..'; far behind on air='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir])..'; iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone) end
                        end
                    end
                end
                --Now search around start positions
                local iStartPositionGroundAAThreshold = math.min(3200,M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] * 0.2)

                local bConsiderAdjacentZones = not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir])
                if bConsiderAdjacentZones and M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] < M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.8 then bConsiderAdjacentZones = false end
                for iBrain, oBrain in M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains] do
                    local tStartPoint = M28Map.GetPlayerStartPosition(oBrain)
                    iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tStartPoint)
                    if (iPlateauOrZero or 0) == 0 then
                        if (iLandOrWaterZone or 0) > 0 then
                            AddEnemyAirInWaterZoneIfNoAA(iLandOrWaterZone, bConsiderAdjacentZones, iAASearchType, iStartPositionGroundAAThreshold)
                        end
                    else
                        if (iLandOrWaterZone or 0) > 0 then
                            --Have a land zone - check for groundAA
                            if bDebugMessages == true then LOG(sFunctionRef..': About to consider adding enemy air in land or water zone near start position, iAASearchType='..iAASearchType..'; iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; Brain start position='..oBrain.Nickname..'; Start pos='..repru(M28Map.GetPlayerStartPosition(oBrain))) end
                            AddEnemyAirInLandZoneIfNoAA(iPlateauOrZero, iLandOrWaterZone, bConsiderAdjacentZones, iAASearchType, iStartPositionGroundAAThreshold)
                        end
                    end
                end

                --Early game - protect expansions we have recently dropped from air to ground attack similarly to if it was a core base (stop checking for htis once we have reached T3 or 10m into the game)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to defend recently dropped locations, M28Team.tAirSubteamData[iAirSubteam][M28Team.reftiLastTransportDropByPlateauAndZone]='..repru(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftiLastTransportDropByPlateauAndZone])..'; Highest friendly tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end
                if GetGameTimeSeconds() <= 600 and M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftiLastTransportDropByPlateauAndZone]) == false and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 then
                    for iDropPlateauOrZero, tSubtable in M28Team.tAirSubteamData[iAirSubteam][M28Team.reftiLastTransportDropByPlateauAndZone] do
                        --Only consider land zones
                        if iDropPlateauOrZero > 0 then
                            --Have we dropped here in the last 3 minutes?
                            for iDropLandOrWaterZone, iTimeOfDrop in tSubtable do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering drop plateau='..iDropPlateauOrZero..'; iDropLandOrWaterZone='..iDropLandOrWaterZone..'; Time since last drop='..GetGameTimeSeconds() - iTimeOfDrop) end
                                if GetGameTimeSeconds() - iTimeOfDrop <= 240 then
                                    --Do we have friendly engineers or factories in this zone?
                                    local tDropLZData = M28Map.tAllPlateaus[iDropPlateauOrZero][M28Map.subrefPlateauLandZones][iDropLandOrWaterZone]
                                    local tLZTeamData = tDropLZData[M28Map.subrefLZTeamData][iTeam]
                                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of friendly units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))..'; Enemy air to ground threat='..(tLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 'nil')) end
                                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                        local tFriendlyFactoriesAndEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                        if bDebugMessages == true then LOG(sFunctionRef..': is table of friendly facs and engis empty='..tostring(M28Utilities.IsTableEmpty( tFriendlyFactoriesAndEngineers))) end
                                        if M28Utilities.IsTableEmpty( tFriendlyFactoriesAndEngineers) == false then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will add enemy air units in this zone as a high priority, bConsiderAdjacentZones='..tostring(bConsiderAdjacentZones or false)..'; iStartPositionGroundAAThreshold='..iStartPositionGroundAAThreshold) end
                                            if iAASearchType == refiIgnoreAllAA and bConsiderAdjacentZones then
                                                AddEnemyAirInLandZoneIfNoAA(iDropPlateauOrZero, iDropLandOrWaterZone, false, iAASearchType, iStartPositionGroundAAThreshold)
                                                AddEnemyAirInLandZoneIfNoAA(iDropPlateauOrZero, iDropLandOrWaterZone, true, refiAvoidOnlyGroundAA, iStartPositionGroundAAThreshold)
                                            else
                                                AddEnemyAirInLandZoneIfNoAA(iDropPlateauOrZero, iDropLandOrWaterZone, bConsiderAdjacentZones, iAASearchType, iStartPositionGroundAAThreshold)
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end

                --Assign available air units to targets
                if bDebugMessages == true then LOG(sFunctionRef..': FInished checking for neemies around all start positions, is table of enemy air targets empty='..tostring(M28Utilities.IsTableEmpty(tEnemyAirTargets))) end
                if M28Utilities.IsTableEmpty(tEnemyAirTargets) == false then
                    AssignAirAATargets(tAvailableAirAA, tEnemyAirTargets, iTeam, iAirSubteam, tExistingThreatAssignedByUnitRef)
                end
            end
            --If have air units still available then cycle through every land zone and water zome from the support point, identifying land/water zones that are safe to travel to from the support point that have enemy air units in until we have no more land zones or no more available air units
            if M28Utilities.IsTableEmpty(tAvailableAirAA) == false then
                local tStartLZOrWZData
                if iStartPlateauOrZero == 0 then
                    tStartLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iStartLandOrWaterZone]][M28Map.subrefPondWaterZones][iStartLandOrWaterZone]
                else
                    tStartLZOrWZData = M28Map.tAllPlateaus[iStartPlateauOrZero][M28Map.subrefPlateauLandZones][iStartLandOrWaterZone]
                end
                --Cycle through other land and water zones using the table sorting them by distance
                if bDebugMessages == true then LOG(sFunctionRef..': We still have available airaa left, Is table of other land/water zones empty='..tostring(M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]))..'; iStartPlateauOrZero='..(iStartPlateauOrZero or 'nil')..'; iStartLandOrWaterZone='..(iStartLandOrWaterZone or 'nil')..'; M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint]='..repru(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint])) end
                if M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                    local iAASearchType
                    local iTorpGroundAAThreshold = 2100
                    local iTorpAirAAThreshold = M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] * 0.5
                    if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir] then
                        iAASearchType = refiAvoidAllAA
                    else
                        iAASearchType = refiAvoidOnlyGroundAA
                        iTorpAirAAThreshold = iTorpAirAAThreshold * 2
                        iTorpGroundAAThreshold = math.max(iTorpGroundAAThreshold * 1.5, iTorpAirAAThreshold * 0.1)
                    end
                    if M28Team.tTeamData[iTeam][M28Team.refbDontHaveBuildingsOrACUInPlayableArea] then iAASearchType = refiIgnoreAllAA end


                    for iEntry, tSubtable in tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                        tEnemyAirTargets = {}
                        if tSubtable[M28Map.subrefbIsWaterZone] then
                            if bDebugMessages == true then LOG(sFunctionRef..': Lower priority enemy air targeter for water zone '..(tSubtable[M28Map.subrefiLandOrWaterZoneRef] or 'nil')..'; Zone has friendly torps='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftWaterZonesHasFriendlyTorps][tSubtable[M28Map.subrefiLandOrWaterZoneRef]] or false)) end
                            if M28Team.tAirSubteamData[iAirSubteam][M28Team.reftWaterZonesHasFriendlyTorps][tSubtable[M28Map.subrefiLandOrWaterZoneRef]] then
                                if bDebugMessages == true then LOG(sFunctionRef..': This water zone has friendly torpedo bombers in it so will increase thresholds for AA to ignore. Far behind on air='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir])..'; iTorpGroundAAThreshold='..iTorpGroundAAThreshold..'; iTorpAirAAThreshold='..iTorpAirAAThreshold) end
                                --AddEnemyAirInWaterZoneIfNoAA(iWaterZone,                                      bAddAdjacentZones, refiAASearchType, iOptionalGroundThreatThresholdOverride, iOptionalAirThreatThresholdOverride, iOptionalMaxDistToEdgeOfAdjacentZone, tOptionalStartPointForEdgeOfAdacentZone, toOptionalUnitOverride)
                                AddEnemyAirInWaterZoneIfNoAA(tSubtable[M28Map.subrefiLandOrWaterZoneRef], false, iAASearchType, iTorpGroundAAThreshold, iTorpAirAAThreshold)
                            else
                                AddEnemyAirInWaterZoneIfNoAA(tSubtable[M28Map.subrefiLandOrWaterZoneRef], false, iAASearchType)
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Searching through other potential AirAA targets now, considering land zone '..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..', iAASearchType='..iAASearchType) end
                            AddEnemyAirInLandZoneIfNoAA(tSubtable[M28Map.subrefiPlateauOrPond], tSubtable[M28Map.subrefiLandOrWaterZoneRef], false, iAASearchType)
                        end
                        if M28Utilities.IsTableEmpty(tEnemyAirTargets) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will assign available AirAA against enemy air target') end
                            AssignAirAATargets(tAvailableAirAA, tEnemyAirTargets, iTeam, iAirSubteam, tExistingThreatAssignedByUnitRef)
                            if M28Utilities.IsTableEmpty(tAvailableAirAA) then break end
                        end
                    end

                    --Campaign specific - check for air experimental targets and attack if we have equivalent of at least 20 asfs
                    if bDebugMessages == true then LOG(sFunctionRef..': Campaign specific - checking for experimental air targets; Is table of available aira empty='..tostring(M28Utilities.IsTableEmpty(tAvailableAirAA))..'; Is table of enemy experimentals still valid='..tostring(M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives]))..'; Our AA threat='..M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat]) end
                    if M28Map.bIsCampaignMap and M28Utilities.IsTableEmpty(tAvailableAirAA) == false and table.getn(tAvailableAirAA) >= 15 and M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives]) and M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] >= 8000 then
                        --Consider attacking based on a lower threshold
                        local iGroundThreatOverride = math.max(M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] * 0.33, 3000)
                        local iAirThreatOverride = math.max(3000, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] * 0.95)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy exp air objectives, iGroundThreatOverride='..iGroundThreatOverride..'; iAirThreatOverride='..iAirThreatOverride) end
                        for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives] do

                            local iUnitPlateau, iUnitLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                            if iUnitLandOrWaterZone and iUnitPlateau then

                                if iUnitPlateau == 0 then
                                    --Reset considered flags so we reconsider but with much higher thresholds
                                    local bResetFlag = false
                                    if tbWaterZonesConsidered[refiAvoidOnlyGroundAA][iUnitLandOrWaterZone] then
                                        tbWaterZonesConsidered[refiAvoidOnlyGroundAA][iUnitLandOrWaterZone] = nil
                                        bResetFlag = true
                                    end
                                    if tbAdjacentWaterZonesConsidered[refiAvoidOnlyGroundAA][iUnitLandOrWaterZone] then
                                        tbAdjacentWaterZonesConsidered[refiAvoidOnlyGroundAA][iUnitLandOrWaterZone] = nil
                                        bResetFlag = true
                                    end
                                    --Add just for the experimental (as sometimes it doesnt show up in the zone list of units)
                                    AddEnemyAirInWaterZoneIfNoAA(iUnitLandOrWaterZone, false, refiAvoidOnlyGroundAA, iGroundThreatOverride, iAirThreatOverride, 10, oUnit:GetPosition(), {oUnit})
                                    --Also consider adding other enemy air in the zone
                                    if bResetFlag then
                                        AddEnemyAirInWaterZoneIfNoAA(iUnitLandOrWaterZone, false, refiAvoidOnlyGroundAA, iGroundThreatOverride, iAirThreatOverride, 10, oUnit:GetPosition())
                                    end
                                else
                                    local bResetFlag = false
                                    if tbAdjacentPlateauAndLandZonesConsidered[refiAvoidOnlyGroundAA][iUnitPlateau][iUnitLandOrWaterZone] then
                                        tbAdjacentPlateauAndLandZonesConsidered[refiAvoidOnlyGroundAA][iUnitPlateau][iUnitLandOrWaterZone] = nil
                                        bResetFlag = true
                                    end
                                    if tbPlateauAndLandZonesConsidered[refiAvoidOnlyGroundAA][iUnitPlateau][iUnitLandOrWaterZone] then
                                        tbPlateauAndLandZonesConsidered[refiAvoidOnlyGroundAA][iUnitPlateau][iUnitLandOrWaterZone] = nil
                                        bResetFlag = true
                                    end
                                    --Add just for the experimental
                                    AddEnemyAirInLandZoneIfNoAA(iUnitPlateau, iUnitLandOrWaterZone, false, refiAvoidOnlyGroundAA, iGroundThreatOverride, iAirThreatOverride, 10, oUnit:GetPosition(), {oUnit})
                                    --Also consider adding other enemy air in the zone
                                    if bResetFlag then
                                        AddEnemyAirInLandZoneIfNoAA(iUnitPlateau, iUnitLandOrWaterZone, false, refiAvoidOnlyGroundAA, iGroundThreatOverride, iAirThreatOverride, 10, oUnit:GetPosition())
                                    end
                                end
                                if bDebugMessages == true then
                                    local tUnitLZOrWZData, tUnitLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                    LOG(sFunctionRef..': Do we have enemy targets after checking for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'? table is empty='..tostring(M28Utilities.IsTableEmpty(tEnemyAirTargets))..'; iUnitPlateau='..iUnitPlateau..'; iUnitLandOrWaterZone='..iUnitLandOrWaterZone..'; Enemy LZ groundAA='..(tUnitLZOrWZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 'nil')..'; ENemy WZ AA='..(tUnitLZOrWZTeamData[M28Map.subrefWZThreatEnemyAA] or 'nil')..'; Enemy AirAA='..(tUnitLZOrWZTeamData[M28Map.refiEnemyAirAAThreat] or 'nil'))
                                end
                                if M28Utilities.IsTableEmpty(tEnemyAirTargets) == false then
                                    AssignAirAATargets(tAvailableAirAA, tEnemyAirTargets, iTeam, iAirSubteam, tExistingThreatAssignedByUnitRef)
                                    if M28Utilities.IsTableEmpty(tAvailableAirAA) then break end
                                end
                            end
                        end
                    end


                    --If still have available air send them to the support location (unless they could do with a fuel or health top-up); if theyre already there and have low mass consider ctrl-king inties
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering AirAA targets for all land and water zones, is tAvailableAirAA empty='..tostring(M28Utilities.IsTableEmpty(tAvailableAirAA))..'; Is air rally outside playable area='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbOrigRallyOutsidePlayableArea])) end
                    if M28Utilities.IsTableEmpty(tAvailableAirAA) == false then
                        if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbOrigRallyOutsidePlayableArea] then
                            --First check for enemy units near the revised rally point instead
                            local aiBrain
                            for iBrain, oBrain in M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains] do
                                if oBrain.M28AI then aiBrain = oBrain break end
                            end
                            local tEnemiesNearRally = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryAllAir, M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint], 150, 'Enemy')
                            if bDebugMessages == true then LOG(sFunctionRef..': Is tEnemiesNearRally empty for backup given outside playable area='..tostring( M28Utilities.IsTableEmpty(tEnemiesNearRally))) end
                            if M28Utilities.IsTableEmpty(tEnemiesNearRally) == false then
                                AssignAirAATargets(tAvailableAirAA, tEnemiesNearRally, iTeam, iAirSubteam, tExistingThreatAssignedByUnitRef)
                            end

                        end
                        if M28Utilities.IsTableEmpty(tAvailableAirAA) == false then
                            local tMovePoint = M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint]
                            local bConsiderCtrlK = false
                            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 and M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] >= 1750 and M28Conditions.TeamHasLowMass(iTeam) then
                                local tInties = EntityCategoryFilterDown(categories.TECH1, tAvailableAirAA)
                                if M28Utilities.IsTableEmpty(tInties) == false then
                                    local tASFs = EntityCategoryFilterDown(categories.TECH3, tAvailableAirAA)
                                    if M28Utilities.IsTableEmpty(tASFs) == false and table.getn(tASFs) >= 6 then
                                        bConsiderCtrlK = true
                                    end
                                end
                            end
                            local iIdleAirAACount = 0
                            for iUnit, oUnit in tAvailableAirAA do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering idle airAA order for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' Unit fuel='..oUnit:GetFuelRatio()..'; Unit health%='..M28UnitInfo.GetUnitHealthPercent(oUnit)..'; support point='..repru(tMovePoint)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; bConsiderCtrlK='..tostring(bConsiderCtrlK)..'; oUnit.Dead='..tostring(oUnit.Dead or false)) end
                                if not(oUnit.Dead) then --redundancy
                                    if bConsiderCtrlK and EntityCategoryContains(categories.TECH1, oUnit.UnitId) then
                                        bConsiderCtrlK = false
                                        local bMoveUnitToRally = false
                                        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint]) >= 10 then
                                            local tUnitZoneData, tUnitTeamZoneData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                            if not(tUnitTeamZoneData[M28Map.subrefLZbCoreBase]) then bMoveUnitToRally = true end
                                        end
                                        if bMoveUnitToRally or oUnit[M28UnitInfo.refbCampaignTriggerAdded] then
                                            M28Orders.IssueTrackedMove(oUnit, M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint], 10, false, 'AACtrlKI', false)
                                        else
                                            ForkThread(M28Micro.MoveAndKillAirUnit,oUnit)
                                            --M28Orders.IssueTrackedKillUnit(oUnit)
                                            M28Team.tAirSubteamData[iAirSubteam][M28Team.refbOnlyGetASFs] = true
                                            if bDebugMessages == true then LOG(sFunctionRef..': CtrlKing unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                        end
                                    elseif ((oUnit:GetFuelRatio() < 0.6 and oUnit:GetFuelRatio() >= 0) or M28UnitInfo.GetUnitHealthPercent(oUnit) <= 0.85) and not(EntityCategoryContains(categories.CANNOTUSEAIRSTAGING, oUnit.UnitId)) then
                                        if M28UnitInfo.IsUnitValid(oUnit) then
                                            table.insert(tAirForRefueling, oUnit)
                                        end
                                    else
                                        M28Orders.IssueTrackedMove(oUnit, tMovePoint, 10, false, 'AAIdle', false)
                                        iIdleAirAACount = iIdleAirAACount + 1
                                    end
                                elseif bDebugMessages == true then LOG(sFunctionRef..': Air unit appears to be dead?')
                                end
                            end
                            if iIdleAirAACount >= 30 and M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] >= 12000 then
                                --Consider gifting ASFs to a teammate if we haven't considered recently; only gift if they have more asfs than we do, and we lack air control
                                if bDebugMessages == true then LOG(sFunctionRef..': Time since we last considered gifting asf to a teammate for airsubteam '..iAirSubteam..'='..(GetGameTimeSeconds() - (M28Team.tAirSubteamData[iAirSubteam][M28Team.refiTimeLastConsideredGiftingASFToAlly] or -100))) end
                                if GetGameTimeSeconds() - (M28Team.tAirSubteamData[iAirSubteam][M28Team.refiTimeLastConsideredGiftingASFToAlly] or -100) >= 30 then
                                    M28Team.tAirSubteamData[iAirSubteam][M28Team.refiTimeLastConsideredGiftingASFToAlly] = GetGameTimeSeconds()
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have air control='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl])..'; Table of friendly human and ai brains empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains]))..'; M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat]='..M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat]) end
                                    if not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl]) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
                                        local iHumanHighestAirAAThreat = 0
                                        local oHumanHighestAirAAThreat
                                        local iAllTeamAirAAThreat = 0
                                        local iCurAirAAThreat = 0
                                        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                                            if oBrain.Human or (not(oBrain.M28AI) and not(oBrain.BrainType == 'AI') and not(M28Conditions.IsCivilianBrain(oBrain))) then
                                                iCurAirAAThreat = M28UnitInfo.GetMassCostOfUnits(oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirAA * categories.TECH3, false, true))
                                                iAllTeamAirAAThreat = iAllTeamAirAAThreat + iCurAirAAThreat
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering human '..oBrain.Nickname..'; iCurAirAAThreat='..iCurAirAAThreat..'; iAllTeamAirAAThreat='..iAllTeamAirAAThreat) end
                                                if iCurAirAAThreat > iHumanHighestAirAAThreat then
                                                    iHumanHighestAirAAThreat = iCurAirAAThreat
                                                    oHumanHighestAirAAThreat = oBrain
                                                end
                                            end
                                        end
                                        if iHumanHighestAirAAThreat >= math.max(M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] * 1.3, 15000) then
                                            --Want to gift some of our ASF to teammate
                                            local tOurASFs = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirAA *  categories.TECH3, tAvailableAirAA)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of our available asfs empty='..tostring(M28Utilities.IsTableEmpty(tOurASFs))) end
                                            if M28Utilities.IsTableEmpty(tOurASFs) == false then
                                                local toUnitsToConsiderGifting = {}
                                                local iASFCount = 0
                                                for iASF, oASF in tOurASFs do
                                                    if oASF[M28Orders.reftiLastOrders][1][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueMove and not(oASF[M28UnitInfo.refbSpecialMicroActive]) then
                                                        iASFCount = iASFCount + 1
                                                        table.insert(toUnitsToConsiderGifting, oASF)
                                                    end
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': iASFCount='..iASFCount) end
                                                if iASFCount >= 30 then
                                                    local toASFToGive = {}
                                                    local iASFToGive = iASFCount - iMinimumASFCountPostGifting
                                                    for iASF, oASF in toUnitsToConsiderGifting do
                                                        table.insert(toASFToGive, oASF)
                                                        if iASF >= iASFToGive then break end
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Transferring '..iASFToGive..' to player '..oHumanHighestAirAAThreat.Nickname) end
                                                    M28Chat.SendMessage(toUnitsToConsiderGifting[1]:GetAIBrain(), 'GiveASFs', 'We should combine our air forces to maintain air control, I\'ve just transferred '..iASFToGive..' of my fighters to you '..oHumanHighestAirAAThreat.Nickname..', I trust you\'ll keep the skies clear of hostiles', 0.1, 900, true, true)
                                                    M28Team.TransferUnitsToPlayer(toASFToGive, oHumanHighestAirAAThreat:GetArmyIndex())
                                                    M28Team.tAirSubteamData[iAirSubteam][M28Team.refoLastHumanGiftedASFs] = oHumanHighestAirAAThreat
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                else
                    M28Utilities.ErrorHandler('No other land or water zones identified, likely error')
                end
            end
        end
    end

    --Send units for refueling
    if bDebugMessages == true then
        LOG(sFunctionRef..': Finished giving availableAA orders, is table of air for refueling empty='..tostring(M28Utilities.IsTableEmpty(tAirForRefueling)))
        if M28Utilities.IsTableEmpty(tAirForRefueling) == false then
            for iUnit, oUnit in tAirForRefueling do
                LOG(sFunctionRef..': Entry for refueling='..iUnit..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
            end
        end
    end
    --Run the function even if no units wanting refueling so already attached untis can be sent on their way
    SendUnitsForRefueling(tAirForRefueling, iTeam, iAirSubteam)
    if bDebugMessages == true and M28Utilities.IsTableEmpty(tAirForRefueling) == false then
        LOG(sFunctionRef..': Will send '..table.getn(tAirForRefueling)..' units to refuel')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ApplyEngiHuntingBomberLogic(oUnit, iAirSubteam, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ApplyEngiHuntingBomberLogic'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tBomberTable = {oUnit}
    local tEnemyTargets = {}
    --Engi hunter logic - search outwards from the bomber for the closest engineer that doesnt have groundAA protecting it
    local iStartPlateauOrZero, iStartLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Position='..repru(oUnit:GetPosition())..'; iStartPlateauOrZero='..(iStartPlateauOrZero or 'nil')..'; iStartLandOrWaterZone='..(iStartLandOrWaterZone or 'nil')..'; GameTime='..GetGameTimeSeconds()) end
    if (iStartLandOrWaterZone or 0) > 0 then
        local tStartLZOrWZData, tStartLZOrWZTeamData
        if iStartPlateauOrZero == 0 then
            tStartLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iStartLandOrWaterZone]][M28Map.subrefPondWaterZones][iStartLandOrWaterZone]
            tStartLZOrWZTeamData = tStartLZOrWZData[M28Map.subrefWZTeamData][iTeam]
        else
            tStartLZOrWZData = M28Map.tAllPlateaus[iStartPlateauOrZero][M28Map.subrefPlateauLandZones][iStartLandOrWaterZone]
            tStartLZOrWZTeamData = tStartLZOrWZData[M28Map.subrefLZTeamData][iTeam]
        end

        if tStartLZOrWZData then
            function FilterToAvailableTargets(tPotentialTargets, iOptionalCategory) --COPY OF BELOW
                if M28Utilities.IsTableEmpty(tPotentialTargets) == false then
                    local bDontConsiderPlayableArea = not(M28Map.bIsCampaignMap)
                    for iUnit, oUnit in tPotentialTargets do
                        if M28UnitInfo.IsUnitValid(oUnit) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) and (bDontConsiderPlayableArea or M28Conditions.IsLocationInPlayableArea(oUnit:GetPosition())) then
                            if not(iOptionalCategory) or EntityCategoryContains(iOptionalCategory, oUnit.UnitId) then
                                table.insert(tEnemyTargets, oUnit)
                            end
                        end
                    end
                end
            end


            local bDontCheckForPacifism = not(M28Overseer.bPacifistModeActive)
            local iEngiHunterCategories = M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryRadar
            if bDontCheckForPacifism or not(tStartLZOrWZTeamData[M28Map.subrefbPacifistArea]) then FilterToAvailableTargets(tStartLZOrWZTeamData[M28Map.subrefTEnemyUnits], iEngiHunterCategories) end
            local bDontCheckForEnemyThreats = false
            if (tStartLZOrWZTeamData[M28Map.refiEnemyAirAAThreat] or 0) > 0 then bDontCheckForEnemyThreats = true end
            RecordOtherLandAndWaterZonesByDistance(tStartLZOrWZData, tStartLZOrWZData[M28Map.subrefMidpoint])

            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for targets in starting zone, is table of enemy targets empty='..tostring(M28Utilities.IsTableEmpty(tEnemyTargets))) end
            if M28Utilities.IsTableEmpty( tEnemyTargets) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Assigning bomber targets for Engi hunter for units in bomber cur zone') end
                AssignTorpOrBomberTargets(tBomberTable, tEnemyTargets, iAirSubteam, false, true)
                tEnemyTargets = {}
            end

            if M28Utilities.IsTableEmpty(tBomberTable) == false and M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false and M28Utilities.IsTableEmpty(tEnemyTargets) then
                local iSearchSize = 500
                for iEntry, tPathingDetails in tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                    local iOtherPlateauOrZero = tPathingDetails[M28Map.subrefiPlateauOrPond]
                    local iOtherLZOrWZ = tPathingDetails[M28Map.subrefiLandOrWaterZoneRef]
                    if tPathingDetails[M28Map.subrefbIsWaterZone] then iOtherPlateauOrZero = 0 end
                    if iOtherLZOrWZ then
                        local tOtherLZOrWZData
                        local tOtherLZOrWZTeamData
                        if iOtherPlateauOrZero == 0 then
                            tOtherLZOrWZData = M28Map.tPondDetails[tPathingDetails[M28Map.subrefiPlateauOrPond]][M28Map.subrefPondWaterZones][iOtherLZOrWZ]
                            tOtherLZOrWZTeamData = tOtherLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                        else
                            tOtherLZOrWZData = M28Map.tAllPlateaus[iOtherPlateauOrZero][M28Map.subrefPlateauLandZones][iOtherLZOrWZ]
                            tOtherLZOrWZTeamData = tOtherLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                        end
                        if (tOtherLZOrWZData[M28Map.subrefLZTravelDist] or 0) > iSearchSize then break end
                        if bDontCheckForPacifism or not(tOtherLZOrWZData[M28Map.subrefbPacifistArea]) then
                            --Ignore targets with shielding or AA
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering enemies in iOtherPlateauOrZero='..(iOtherPlateauOrZero or 'nil')..'; iOtherLZOrWZ='..(iOtherLZOrWZ or 'nil')..'; Enemy shield threat='..(tOtherLZOrWZTeamData[M28Map.subrefLZThreatEnemyShield] or 0)..'; GroundAA='.. (tOtherLZOrWZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0)..'; Enemy AirAA='..(tOtherLZOrWZTeamData[M28Map.refiEnemyAirAAThreat] or 0)) end
                            if bDontCheckForEnemyThreats or ((tOtherLZOrWZTeamData[M28Map.subrefLZThreatEnemyShield] or 0) == 0 and (tOtherLZOrWZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) == 0 and (tOtherLZOrWZTeamData[M28Map.refiEnemyAirAAThreat] or 0) == 0) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Does enemy have AA threat along the path to this zone='..tostring(DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iOtherPlateauOrZero, iOtherLZOrWZ, true, 1, 400, false, iAirSubteam, true, false, oUnit:GetPosition()))) end
                                if bDontCheckForEnemyThreats or not(DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iOtherPlateauOrZero, iOtherLZOrWZ, true, 1, 400, false, iAirSubteam, true, false, oUnit:GetPosition())) then
                                    FilterToAvailableTargets(tOtherLZOrWZTeamData[M28Map.subrefTEnemyUnits], iEngiHunterCategories)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iOtherPlateauOrZero='..(iOtherPlateauOrZero or 'nil')..'; iOtherLZOrWZ='..(iOtherLZOrWZ or 'nil')..'; dist='..(tPathingDetails[M28Map.subrefiDistance] or 'nil')..'; iSearchSize='..(iSearchSize or 'nil')..'; Does it have enemy units='..tostring(M28Utilities.IsTableEmpty(tOtherLZOrWZTeamData[M28Map.subrefTEnemyUnits]))..'; Is table of targets empty='..tostring(M28Utilities.IsTableEmpty( tEnemyTargets))) end
                                    if M28Utilities.IsTableEmpty( tEnemyTargets) == false then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Assigning bomber targets for Engi hunter, iOtherLZOrWZ='..iOtherLZOrWZ) end
                                        AssignTorpOrBomberTargets(tBomberTable, tEnemyTargets, iAirSubteam, false, true)
                                        tEnemyTargets = {}
                                        if M28Utilities.IsTableEmpty(tBomberTable) then break end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tBomberTable) == false then
                --Find a zone for the bomber to scout to look for engineers
                UpdateScoutingShortlist(iTeam)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering locations to scout with bomber, is table of scouting shortlist empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftLandAndWaterZoneScoutingShortlist]))) end
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftLandAndWaterZoneScoutingShortlist]) == false then
                    local iClosestDist = 100000
                    local iClosestOnEnemySide = 100000
                    local iCurDist, tClosestMidpoint, iClosestPlateauOrZero, iClosestLZOrWZRef, iClosestEnemyPlateauOrZero, iClosestEnemyLZOrWZRef, tClosestEnemySideMidpoint, iModDist, iCurGroundAAThreat
                    for iEntry, tPlateauAndZoneRef in M28Team.tTeamData[iTeam][M28Team.subreftLandAndWaterZoneScoutingShortlist] do
                        --local tScoutingLZOrWZData, tScoutingLZOrWZTeamData
                        if tPlateauAndZoneRef[1] > 0 then
                            --Waterzone - for now only want to target land zone
                            --tScoutingLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[tPlateauAndZoneRef[2]]][M28Map.subrefPondWaterZones][tPlateauAndZoneRef[2]]
                            --tScoutingLZOrWZTeamData = tScoutingLZOrWZData[M28Map.subrefWZTeamData][iTeam]

                            --Land zone
                            local tScoutingLZData = M28Map.tAllPlateaus[tPlateauAndZoneRef[1]][M28Map.subrefPlateauLandZones][tPlateauAndZoneRef[2]]
                            local tScoutingLZTeamData = tScoutingLZData[M28Map.subrefLZTeamData][iTeam]
                            --Dont consider if has enemy AA; also require there to be at least 1 unbuilt mex
                            if (tScoutingLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) == 0 and (tScoutingLZTeamData[M28Map.refiEnemyAirAAThreat] or 0) == 0 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to scout the zone P'..tPlateauAndZoneRef[1]..'Z'..tPlateauAndZoneRef[2]..'; Dist to us='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tScoutingLZData[M28Map.subrefMidpoint])..'; Is table of unbuilt mexes empty='..tostring(M28Utilities.IsTableEmpty(tScoutingLZData[M28Map.subrefMexUnbuiltLocations]))..'; Mod dist%='..(tScoutingLZTeamData[M28Map.refiModDistancePercent] or 'nil')) end
                                if M28Utilities.IsTableEmpty(tScoutingLZData[M28Map.subrefMexUnbuiltLocations]) == false then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tScoutingLZData[M28Map.subrefMidpoint])
                                    --Modify the distance if enemy has groundAA threat here, or lots of mexes
                                    if iCurDist <= iClosestOnEnemySide then
                                        iModDist = iCurDist
                                        --DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iEndPlateauOrZero, iEndLandOrWaterZone, bIgnoreAirAAThreat, iGroundAAThreatThreshold, iAirAAThreatThreshold, bUsingTorpBombers, iAirSubteam, bDoDetailedCheckForAA, bReturnGroundAAThreatInstead, tOptionalStartMidpointAdjustForDetailedCheck)
                                        iCurGroundAAThreat = DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, tPlateauAndZoneRef[1], tPlateauAndZoneRef[2], true,              1,                      400,                false,              iAirSubteam, true,                  true,                           oUnit:GetPosition())
                                        if iCurGroundAAThreat >= 1 then
                                            if iCurGroundAAThreat >= 100 then iModDist = math.max(iModDist * 3, iModDist + 150)
                                            else iModDist = math.max(iModDist * 2, iModDist + 100)
                                            end
                                        end
                                        if table.getn(tScoutingLZData[M28Map.subrefMexUnbuiltLocations]) >= 2 then
                                            if table.getn(tScoutingLZData[M28Map.subrefMexUnbuiltLocations]) >= 4 or table.getn(tScoutingLZData[M28Map.subrefMexUnbuiltLocations]) < (tScoutingLZData[M28Map.subrefLZMexCount] or 0) then
                                                iModDist = iModDist * 0.75
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': iModDist='..iModDist..'; iCurGroundAAThreat='..iCurGroundAAThreat..'; Total unbuilt locations='..table.getn(tScoutingLZData[M28Map.subrefMexUnbuiltLocations])..'; Mex count='.. (tScoutingLZData[M28Map.subrefLZMexCount] or 'nil')) end
                                        if iModDist < iClosestDist then
                                            iClosestDist = iModDist
                                            iClosestPlateauOrZero = tPlateauAndZoneRef[1]
                                            iClosestLZOrWZRef = tPlateauAndZoneRef[2]
                                            tClosestMidpoint = {tScoutingLZData[M28Map.subrefMidpoint][1], tScoutingLZData[M28Map.subrefMidpoint][2], tScoutingLZData[M28Map.subrefMidpoint][3]}
                                        end
                                        if iModDist < iClosestOnEnemySide and (tScoutingLZTeamData[M28Map.refiModDistancePercent] or 0) >= 0.5 then
                                            iClosestOnEnemySide = iModDist
                                            iClosestEnemyPlateauOrZero =  tPlateauAndZoneRef[1]
                                            iClosestEnemyLZOrWZRef = tPlateauAndZoneRef[2]
                                            tClosestEnemySideMidpoint = {tScoutingLZData[M28Map.subrefMidpoint][1], tScoutingLZData[M28Map.subrefMidpoint][2], tScoutingLZData[M28Map.subrefMidpoint][3]}
                                            if bDebugMessages == true then LOG(sFunctionRef..': Updating the closest midpoint on the enemy side of the map') end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': tClosestMidpoint to scout='..repru(tClosestMidpoint)) end
                    if tClosestEnemySideMidpoint then
                        M28Orders.IssueTrackedMove(oUnit, tClosestEnemySideMidpoint, 10, false, 'BScEP'..iClosestEnemyPlateauOrZero..'Z'..iClosestEnemyLZOrWZRef, false)
                        tBomberTable = nil
                    elseif tClosestMidpoint then
                        M28Orders.IssueTrackedMove(oUnit, tClosestMidpoint, 10, false, 'BScAP'..iClosestPlateauOrZero..'Z'..iClosestLZOrWZRef, false)
                        tBomberTable = nil
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Redundancy - will just attack move to enemy base at position '..repru(tStartLZOrWZTeamData[M28Map.reftClosestEnemyBase])) end
                        --aggressive move to the closest enemy base
                        M28Orders.IssueTrackedAggressiveMove(oUnit, tStartLZOrWZTeamData[M28Map.reftClosestEnemyBase], 10, false, 'BAtBs', false)
                        tBomberTable = nil
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageBombers(iTeam, iAirSubteam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageBombers'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local tAvailableBombers, tBombersForRefueling, tUnavailableUnits, tSpecialLogicAvailableBombers = GetAvailableLowFuelAndInUseAirUnits(iTeam, iAirSubteam, M28UnitInfo.refCategoryBomber - categories.EXPERIMENTAL)
    local iOurBomberThreat = 0
    local tEnemyTargets = {}

    function FilterToAvailableTargets(tPotentialTargets, iOptionalCategory, bOptionalCheckNotAlreadyInEnemyTargets) --UPDATE USAGE IN SPECIAL BOMBER LOGIC IF CHANGING (and changes are relevant to engi hunter)
        if M28Utilities.IsTableEmpty(tPotentialTargets) == false then
            local bDontConsiderPlayableArea = not(M28Map.bIsCampaignMap)
            local iOriginalEnemyTargetSize
            if bOptionalCheckNotAlreadyInEnemyTargets then
                if M28Utilities.IsTableEmpty(tEnemyTargets) then bOptionalCheckNotAlreadyInEnemyTargets = false
                else iOriginalEnemyTargetSize = table.getn(tEnemyTargets)
                end
            end
            local bAlreadyRecorded

            for iUnit, oUnit in tPotentialTargets do
                if bDebugMessages == true then
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        LOG(sFunctionRef..': Considering whether to treat unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' as a potential target, is unit valid=true, Is unit attached='..tostring(oUnit:IsUnitState('Attached'))..'; Is unit underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; Is unit in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(oUnit:GetPosition()))..'; Is unit optional category (if is one)='..tostring(not(iOptionalCategory) or EntityCategoryContains(iOptionalCategory, oUnit.UnitId))..'; bOptionalCheckNotAlreadyInEnemyTargets='..tostring(bOptionalCheckNotAlreadyInEnemyTargets or false)..'; Time='..GetGameTimeSeconds())
                    else
                        LOG(sFunctionRef..': Considering whether to treat unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' as a potential target, is unit valid=false')
                    end
                end
                if M28UnitInfo.IsUnitValid(oUnit) and not(oUnit:IsUnitState('Attached')) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) and (bDontConsiderPlayableArea or M28Conditions.IsLocationInPlayableArea(oUnit:GetPosition())) then
                    if not(iOptionalCategory) or EntityCategoryContains(iOptionalCategory, oUnit.UnitId) then
                        if not(bOptionalCheckNotAlreadyInEnemyTargets) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding unit to enemy targets') end
                            table.insert(tEnemyTargets, oUnit)
                        else
                            bAlreadyRecorded = false
                            for iRecordedUnit, oRecordedUnit in tEnemyTargets do
                                if oRecordedUnit == oUnit then
                                    bAlreadyRecorded = true
                                    break
                                elseif iRecordedUnit > iOriginalEnemyTargetSize then
                                    break
                                end
                            end
                            if not(bAlreadyRecorded) then
                                table.insert(tEnemyTargets, oUnit)
                            end
                        end
                    end
                end
            end
        end
    end

    if M28Utilities.IsTableEmpty(tAvailableBombers) == false then

        --Simple logic for now as placeholder in case we get given bombers - attack nearest enemy to rally point in up to a 300 range
        --GetAirThreatLevel(tUnits,      bEnemyUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
        iOurBomberThreat = M28UnitInfo.GetAirThreatLevel(tAvailableBombers, false,      false,          false,              true,                   false,              false)
        local aiBrain
        for iBrain, oBrain in M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains] do
            aiBrain = oBrain
            break
        end
        local iTeam = aiBrain.M28Team
        local tRallyPoint = M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint]

        local iSearchSize = 300
        if M28Map.iMapSize > 512 then iSearchSize = 450 end
        local iAvailableBombers = table.getn(tAvailableBombers)
        if iAvailableBombers >= 10 then iSearchSize = iSearchSize * 1.5 end
        if M28Map.bIsCampaignMap then
            iSearchSize = math.max(M28Map.iMapSize, iSearchSize * 1.5)
        end
        if iAvailableBombers >= 100 and (iAvailableBombers >= 300 or (M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] and (M28Map.bIsCampaignMap or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] < 3))) then
            iSearchSize = iSearchSize * 2
        elseif M28Map.bIsCampaignMap and M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] then iSearchSize = iSearchSize * 1.5
        end

        --Consider snipe targets
        if M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets]) then
            AssignTorpOrBomberTargets(tAvailableBombers, M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets], iAirSubteam, false, true)
        end
        if M28Utilities.IsTableEmpty(tAvailableBombers) == false then
            local bConsiderHigherTechUnitsFirst = false
            if iOurBomberThreat >= 1500 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.TECH3 + categories.EXPERIMENTAL, tAvailableBombers)) == false then
                bConsiderHigherTechUnitsFirst = true
            end

            if bDebugMessages == true then LOG(sFunctionRef..': bConsiderHigherTechUnitsFirst='..tostring(bConsiderHigherTechUnitsFirst or false)) end
            if bConsiderHigherTechUnitsFirst then
                --Consider high priority targets:
                FilterToAvailableTargets(aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand * categories.TECH3 + M28UnitInfo.refCategoryMobileLand * categories.EXPERIMENTAL + M28UnitInfo.refCategoryStructure * categories.TECH3 +  M28UnitInfo.refCategoryStructure * categories.TECH2 + M28UnitInfo.refCategoryStructure * categories.TECH3 + M28UnitInfo.refCategoryNavalSurface - categories.TECH1, tRallyPoint, 300, 'Enemy'))
                if M28Utilities.IsTableEmpty(tEnemyTargets) == false then
                    AssignTorpOrBomberTargets(tAvailableBombers, tEnemyTargets, iAirSubteam, false, true)
                end
                tEnemyTargets = {} --reset targets
            end
            if M28Utilities.IsTableEmpty(tAvailableBombers) == false then
                --Consider nearby defence
                local iRallyPlateauOrZero, iRallyLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tRallyPoint)
                local tRallyLZOrWZData
                local tRallyLZOrWZTeamData
                if iRallyPlateauOrZero == 0 then
                    tRallyLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iRallyLZOrWZ]][M28Map.subrefPondWaterZones][iRallyLZOrWZ]
                    tRallyLZOrWZTeamData = tRallyLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                else
                    tRallyLZOrWZData = M28Map.tAllPlateaus[iRallyPlateauOrZero][M28Map.subrefPlateauLandZones][iRallyLZOrWZ]
                    tRallyLZOrWZTeamData = tRallyLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                end

                FilterToAvailableTargets(tRallyLZOrWZTeamData[M28Map.subrefTEnemyUnits])
                if M28Utilities.IsTableEmpty( tEnemyTargets) == false then
                    AssignTorpOrBomberTargets(tAvailableBombers, tEnemyTargets, iAirSubteam, false, true)
                    tEnemyTargets = {}
                end
                if M28Utilities.IsTableEmpty(tAvailableBombers) == false then
                    local bCheckForObjectiveTargets = false
                    if M28Map.bIsCampaignMap and M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] then
                        bCheckForObjectiveTargets = true
                    end
                    local toObjectiveTargets = {}
                    function AddObjectiveTargetsFromLZTeamData(tLZTeamData)
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of ground fire friendly targets empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoGroundFireFriendlyTarget]))) end
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoGroundFireFriendlyTarget]) == false then
                            if M28Conditions.IsTableOfUnitsStillValid(tLZTeamData[M28Map.reftoGroundFireFriendlyTarget], false) then
                                for iUnit, oUnit in tLZTeamData[M28Map.reftoGroundFireFriendlyTarget] do
                                    table.insert(toObjectiveTargets, oUnit)
                                end
                            end
                        end
                    end
                    --Consider adjacent zones if are on a land zone, and the rally point is closer to our base than the enemy
                    local tbZonesConsideredByPlateau = {}
                    tbZonesConsideredByPlateau[iRallyPlateauOrZero] = {}
                    if iRallyPlateauOrZero > 0 then
                        if (tRallyLZOrWZData[M28Map.refiModDistancePercent] or 0) <= 0.4 then
                            if M28Utilities.IsTableEmpty(tRallyLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                for _, iAdjLZ in tRallyLZOrWZData[M28Map.subrefLZAdjacentLandZones] do
                                    tbZonesConsideredByPlateau[iRallyPlateauOrZero][iAdjLZ] = true
                                    local tAdjLZTeamData = M28Map.tAllPlateaus[iRallyPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                    FilterToAvailableTargets(tAdjLZTeamData[M28Map.subrefTEnemyUnits])
                                    if M28Utilities.IsTableEmpty( tEnemyTargets) == false then
                                        AssignTorpOrBomberTargets(tAvailableBombers, tEnemyTargets, iAirSubteam, false, true)
                                        tEnemyTargets = {}
                                        if M28Utilities.IsTableEmpty(tAvailableBombers) then break end
                                    end
                                    if bCheckForObjectiveTargets then AddObjectiveTargetsFromLZTeamData(tAdjLZTeamData) end
                                end
                            end

                            --Consider adjacent water zones
                            if M28Utilities.IsTableEmpty(tAvailableBombers) == false then
                                if M28Utilities.IsTableEmpty(tRallyLZOrWZData[M28Map.subrefAdjacentWaterZones]) == false then
                                    for iEntry, tSubtable in tRallyLZOrWZData[M28Map.subrefAdjacentWaterZones] do
                                        local iAdjWZ = tSubtable[M28Map.subrefAWZRef]
                                        local tAdjWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iAdjWZ]][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjWZ='..iAdjWZ..'; is table of enemy units empty for this zone='..tostring(M28Utilities.IsTableEmpty(tAdjWZTeamData[M28Map.subrefTEnemyUnits]))) end
                                        FilterToAvailableTargets(tAdjWZTeamData[M28Map.subrefTEnemyUnits])
                                        if M28Utilities.IsTableEmpty( tEnemyTargets) == false then
                                            AssignTorpOrBomberTargets(tAvailableBombers, tEnemyTargets, iAirSubteam, false, true)
                                            tEnemyTargets = {}
                                            if M28Utilities.IsTableEmpty(tAvailableBombers) then break end
                                        end
                                    end
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(tAvailableBombers) == false then
                            --If have air control and lots of bombers available consider further away targets; also consider if rally point is outside the playable area
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of available bombers empty='..tostring(M28Utilities.IsTableEmpty(tAvailableBombers))..'; Do we have air control='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl])..'; iAvailableBombers='..(iAvailableBombers or 'nil')..'; iOurBomberThreat='..(M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurBomberThreat] or 'nil')..'; Time='..GetGameTimeSeconds()) end
                            if M28Utilities.IsTableEmpty(tAvailableBombers) == false and (M28Team.tAirSubteamData[iAirSubteam][M28Team.refbOrigRallyOutsidePlayableArea] or M28Team.tTeamData[iTeam][M28Team.refbDontHaveBuildingsOrACUInPlayableArea] or (M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] and iAvailableBombers >= 8 and (iAvailableBombers >= 60 or M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurBomberThreat] >= 25000 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] < 3 or (M28Map.bIsCampaignMap and iAvailableBombers >= 12 and (iAvailableBombers >= 12 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] or M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap]))))) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of pathing to other zones empty='..tostring(M28Utilities.IsTableEmpty(tRallyLZOrWZData[M28Map.subrefLZPathingToOtherLandZones]))) end
                                if M28Utilities.IsTableEmpty(tRallyLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                                    local bDontCheckForPacifism = not(M28Overseer.bPacifistModeActive)
                                    local iCurGroundAAThreat
                                    local iMaxEnemyGroundAAThreat = M28Team.tTeamData[iTeam][M28Team.subrefiOurBomberThreat]
                                    if M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] then
                                        iMaxEnemyGroundAAThreat = iMaxEnemyGroundAAThreat * 0.2
                                    else
                                        iMaxEnemyGroundAAThreat = iMaxEnemyGroundAAThreat * 0.15
                                    end

                                    for iEntry, tPathingDetails in tRallyLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                                        local iOtherPlateauOrZero = tPathingDetails[M28Map.subrefiPlateauOrPond]
                                        local iOtherLZOrWZ = tPathingDetails[M28Map.subrefiLandOrWaterZoneRef]
                                        if tPathingDetails[M28Map.subrefbIsWaterZone] then iOtherPlateauOrZero = 0 end
                                        local iCurGroundAAThreatAlongPath = 0
                                        local tAAUnitsAlongPath
                                        local bProceedWithAttack
                                        if not(tbZonesConsideredByPlateau[iRallyPlateauOrZero][iOtherLZOrWZ]) and iOtherLZOrWZ then

                                            local tOtherLZOrWZData
                                            local tOtherLZOrWZTeamData
                                            if iOtherPlateauOrZero == 0 then
                                                tOtherLZOrWZData = M28Map.tPondDetails[tPathingDetails[M28Map.subrefiPlateauOrPond]][M28Map.subrefPondWaterZones][iOtherLZOrWZ]
                                                tOtherLZOrWZTeamData = tOtherLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                                                iCurGroundAAThreat = (tOtherLZOrWZTeamData[M28Map.subrefWZThreatEnemyAA] or 0)
                                            else
                                                tOtherLZOrWZData = M28Map.tAllPlateaus[iOtherPlateauOrZero][M28Map.subrefPlateauLandZones][iOtherLZOrWZ]
                                                tOtherLZOrWZTeamData = tOtherLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                                                iCurGroundAAThreat = (tOtherLZOrWZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0)
                                            end
                                            if (tOtherLZOrWZData[M28Map.subrefLZTravelDist] or 0) > iSearchSize and ((tOtherLZOrWZTeamData[M28Map.subrefLZSValue] or 0) == 0 or (tOtherLZOrWZData[M28Map.subrefLZTravelDist] or 0) > iSearchSize + 25) then break end
                                            if bDontCheckForPacifism or not(tOtherLZOrWZData[M28Map.subrefbPacifistArea]) then
                                                --If enemy GroundAA threat is too big then stop looking/dont consider targets that are more than a bit further from here iSearchSize

                                                if bDebugMessages == true then LOG(sFunctionRef..': Dealing with P'..iOtherPlateauOrZero..'Z'..iOtherLZOrWZ..'; iCurGroundAAThreat='..iCurGroundAAThreat..'; Enemy shield='..(tOtherLZOrWZData[M28Map.subrefLZThreatEnemyShield] or 0)..'; iMaxEnemyGroundAAThreat='..iMaxEnemyGroundAAThreat..'; SValue='..(tOtherLZOrWZTeamData[M28Map.subrefLZSValue] or 0)) end
                                                if iCurGroundAAThreat + math.min(iCurGroundAAThreat * 3, (tOtherLZOrWZData[M28Map.subrefLZThreatEnemyShield] or 0)) > iMaxEnemyGroundAAThreat and (tOtherLZOrWZTeamData[M28Map.subrefLZSValue] or 0) == 0 then
                                                    iSearchSize = math.min(iSearchSize, (tOtherLZOrWZData[M28Map.subrefLZTravelDist] or 0) + 25) --i.e. consider a couple more zones in case htey are in another direction
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Zone has too much AA threat so wont target and will stop searching soon') end
                                                else
                                                    FilterToAvailableTargets(tOtherLZOrWZTeamData[M28Map.subrefTEnemyUnits])
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iOtherPlateauOrZero='..(iOtherPlateauOrZero or 'nil')..'; iOtherLZOrWZ='..(iOtherLZOrWZ or 'nil')..'; dist='..(tPathingDetails[M28Map.subrefiDistance] or 'nil')..'; iSearchSize='..(iSearchSize or 'nil')..'; Does it have enemy units='..tostring(M28Utilities.IsTableEmpty(tOtherLZOrWZTeamData[M28Map.subrefTEnemyUnits]))..'; Is table of targets empty='..tostring(M28Utilities.IsTableEmpty( tEnemyTargets))) end
                                                    if M28Utilities.IsTableEmpty( tEnemyTargets) == false then
                                                        iCurGroundAAThreatAlongPath, tAAUnitsAlongPath = DoesEnemyHaveAAThreatAlongPath(iTeam, iRallyPlateauOrZero, iRallyLZOrWZ, iOtherPlateauOrZero, iOtherLZOrWZ, M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl], iMaxEnemyGroundAAThreat, nil, false, iAirSubteam, true, true, nil, true)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Assigning bomber targets for iOtherLZOrWZ='..iOtherLZOrWZ..'; iCurGroundAAThreatAlongPath='..iCurGroundAAThreatAlongPath..'; iMaxEnemyGroundAAThreat='..iMaxEnemyGroundAAThreat) end
                                                        bProceedWithAttack = false
                                                        if iCurGroundAAThreatAlongPath < iMaxEnemyGroundAAThreat then
                                                            bProceedWithAttack = true
                                                            local oClosestEnemyToRally = M28Utilities.GetNearestUnit(tEnemyTargets, tRallyPoint)
                                                            if oClosestEnemyToRally then
                                                                local tNearbyEnemyGroundAA = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryGroundAA, oClosestEnemyToRally:GetPosition(), 80, 'Enemy')
                                                                if M28Utilities.IsTableEmpty(tNearbyEnemyGroundAA) == false then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy GroundAA threat using getunitsaroundpoint='..M28UnitInfo.GetAirThreatLevel(tNearbyEnemyGroundAA, true, false, true, false, false, false)..'; iMaxEnemyGroundAAThreat='..iMaxEnemyGroundAAThreat) end
                                                                    if M28UnitInfo.GetAirThreatLevel(tNearbyEnemyGroundAA, true, false, true, false, false, false) >= iMaxEnemyGroundAAThreat then
                                                                        bProceedWithAttack = false
                                                                    else
                                                                        FilterToAvailableTargets(tNearbyEnemyGroundAA, nil, true)
                                                                    end
                                                                end
                                                            end
                                                            if bProceedWithAttack then
                                                                if M28Utilities.IsTableEmpty(tAAUnitsAlongPath) == false then FilterToAvailableTargets(tAAUnitsAlongPath, nil, true) end
                                                                --Further redundancy for nearby AA - get the closest potential enemy target, and search for nearby groundAA units using getunitsaroundpoint

                                                                AssignTorpOrBomberTargets(tAvailableBombers, tEnemyTargets, iAirSubteam, false, true)
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Have added all enemy units and AA units along the path, are available bombers table empty now='..tostring(M28Utilities.IsTableEmpty(tAvailableBombers))) end
                                                                if M28Utilities.IsTableEmpty(tAvailableBombers) then break end
                                                            end
                                                        end
                                                        if not(bProceedWithAttack) then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Too great an enemy threat so wont add these targets after all') end
                                                            iSearchSize = math.min(iSearchSize, (tOtherLZOrWZData[M28Map.subrefLZTravelDist] or 0) + 25) --i.e. consider a couple more zones in case htey are in another direction
                                                        end
                                                        tEnemyTargets = {}
                                                    end
                                                    if bCheckForObjectiveTargets then AddObjectiveTargetsFromLZTeamData(tOtherLZOrWZTeamData) end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end


                    if bDebugMessages == true then LOG(sFunctionRef..': Finished sending out bombers at targets, is table of available bombers empty='..tostring(M28Utilities.IsTableEmpty(tAvailableBombers))..'; Is table of objective targets empty='..tostring(M28Utilities.IsTableEmpty(toObjectiveTargets))) end
                    if bCheckForObjectiveTargets and M28Utilities.IsTableEmpty(toObjectiveTargets) == false and M28Utilities.IsTableEmpty(tAvailableBombers) == false then
                        AssignTorpOrBomberTargets(tAvailableBombers, toObjectiveTargets, iAirSubteam, true, true)
                    end

                    --Send any remaining bombers to rally point (or for refueling if they are damaged)
                    if M28Utilities.IsTableEmpty(tAvailableBombers) == false then
                        for iUnit, oUnit in tAvailableBombers do
                            if ((oUnit:GetFuelRatio() < 0.6 and oUnit:GetFuelRatio() >= 0) or (M28UnitInfo.GetUnitHealthPercent(oUnit) <= 0.85 and (M28UnitInfo.GetUnitHealthPercent(oUnit) <= 0.7 or EntityCategoryContains(categories.TECH1, oUnit.UnitId) or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint) <= 200))) and not(EntityCategoryContains(categories.CANNOTUSEAIRSTAGING, oUnit.UnitId)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have injured bomber so will send it for refueling as it is idle otherwise, Bomber oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                table.insert(tBombersForRefueling, oUnit)
                            else
                                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 20, false, 'BombIdl', false)
                            end
                        end
                    end
                end
            end
        end
    end

    if M28Utilities.IsTableEmpty(tSpecialLogicAvailableBombers) == false then
        for iUnit, oUnit in tSpecialLogicAvailableBombers do
            if EntityCategoryContains(categories.TECH1, oUnit.UnitId) then
                ApplyEngiHuntingBomberLogic(oUnit, iAirSubteam, iTeam)
            else
                M28Utilities.ErrorHandler('Special bomber logic not implemented other htan for t1 bombers')
            end
        end
    end

    --Send units for refueling
    if bDebugMessages == true then LOG(sFunctionRef..': Finished giving bomber orders, is table of air for refueling empty='..tostring(M28Utilities.IsTableEmpty(tBombersForRefueling))) end
    --Run the function even if no units wanting refueling so already attached untis can be sent on their way
    SendUnitsForRefueling(tBombersForRefueling, iTeam, iAirSubteam)
    if bDebugMessages == true and M28Utilities.IsTableEmpty(tBombersForRefueling) == false then
        LOG(sFunctionRef..': Will send '..table.getn(tBombersForRefueling)..' units to refuel')
    end
    M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurBomberThreat] = iOurBomberThreat
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageTorpedoBombers(iTeam, iAirSubteam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageTorpedoBombers'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    M28Team.tAirSubteamData[iAirSubteam][M28Team.reftWaterZonesHasFriendlyTorps] = {}
    local tAvailableBombers, tBombersForRefueling, tUnavailableUnits = GetAvailableLowFuelAndInUseAirUnits(iTeam, iAirSubteam, M28UnitInfo.refCategoryTorpBomber - M28UnitInfo.refCategoryGunship, true)
    M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurTorpBomberThreat] = M28UnitInfo.GetAirThreatLevel(tAvailableBombers, false, false, false, false, false, true) + M28UnitInfo.GetAirThreatLevel(tBombersForRefueling, false, false, false, false, false, true) + M28UnitInfo.GetAirThreatLevel(tUnavailableUnits, false, false, false, false, false, true)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time='..GetGameTimeSeconds()..'; Is table of available bombers empty='..tostring(M28Utilities.IsTableEmpty(tAvailableBombers))) end
    M28Team.tAirSubteamData[iAirSubteam][M28Team.refbTooMuchGroundNavalAAForTorpBombers] = false
    local iTorpBomberThreat = 0
    local tiWZWithTooMuchAA = {}
    if M28Utilities.IsTableEmpty(tAvailableBombers) == false then

        local tRallyPoint = M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint]
        local tEnemyTargets = {}
        local tbAdjacentWaterZonesConsidered = {}
        local tbWaterZonesConsidered = {}
        function AddEnemyTargetsInWaterZone(iWaterZone, bAddAdjacentZones)
            --See above for refiAASearchTypes, i.e. refiAvoidAllAA, refiAvoidOnlyGroundAA, refiIgnoreAllAA
            if bDebugMessages == true then LOG(sFunctionRef..': Adding enemytargetsi n water zone '..iWaterZone..'; bAddAdjacentZones='..tostring(bAddAdjacentZones or false)..'; tbAdjacentWaterZonesConsidered[iWaterZone]='..tostring(tbAdjacentWaterZonesConsidered[iWaterZone] or false)..'; tbWaterZonesConsidered[iWaterZone]='..tostring(tbWaterZonesConsidered[iWaterZone] or false)) end
            if not(tbAdjacentWaterZonesConsidered[iWaterZone]) and (bAddAdjacentZones or not(tbWaterZonesConsidered[iWaterZone])) then
                tbWaterZonesConsidered[iWaterZone] = true
                local tWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone]
                local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]))) end
                if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    --Add enemy units if not hover
                    for iUnit, oUnit in tWZTeamData[M28Map.subrefTEnemyUnits] do
                        if M28UnitInfo.IsUnitValid(oUnit) and not(EntityCategoryContains(categories.HOVER, oUnit.UnitId)) then
                            --if land layer then unable to target
                            if not(oUnit:GetCurrentLayer() == 'Land') then
                                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of enemy targets, target position='..repru(oUnit:GetPosition())..'; Map water height='..M28Map.iMapWaterHeight..'; Is this location underwater='..tostring(M28Map.IsUnderwater(oUnit:GetPosition(), false, nil))) end
                                table.insert(tEnemyTargets, oUnit)
                            end
                        end
                    end
                end
                if bAddAdjacentZones then
                    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                        for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                            AddEnemyTargetsInWaterZone(iAdjWZ, false)
                        end
                    end
                    tbAdjacentWaterZonesConsidered[iWaterZone] = true
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Is table of defence water zones empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftiTorpedoDefenceWaterZones]))) end
        local tiWaterZoneByDistance = {}
        local tStartLZOrWZData
        local iStartPlateauOrZero, iStartLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tRallyPoint)
        if iStartPlateauOrZero == 0 then
            tStartLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iStartLandOrWaterZone]][M28Map.subrefPondWaterZones][iStartLandOrWaterZone]
        else
            tStartLZOrWZData = M28Map.tAllPlateaus[iStartPlateauOrZero][M28Map.subrefPlateauLandZones][iStartLandOrWaterZone]
        end

        if M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftiTorpedoDefenceWaterZones]) == false then
            for iEntry, iWaterZone in M28Team.tAirSubteamData[iAirSubteam][M28Team.reftiTorpedoDefenceWaterZones] do
                local tWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone]
                tiWaterZoneByDistance[iWaterZone] = M28Utilities.GetDistanceBetweenPositions(tRallyPoint, tWZData[M28Map.subrefMidpoint])
            end
        else
            --Defend all water as presumably enemy has nearby naval units
            if M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                for iEntry, tSubtable in tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                    if tSubtable[M28Map.subrefbIsWaterZone] then
                        tiWaterZoneByDistance[tSubtable[M28Map.subrefiLandOrWaterZoneRef]] = tSubtable[M28Map.subrefiDistance]
                    end
                end
            else
                M28Utilities.ErrorHandler('Have torpedo bombers but no priority areas to defend with them', true)
            end
        end

        if M28Utilities.IsTableEmpty(tiWaterZoneByDistance) == false then
            --Cycle through in order of distance
            iTorpBomberThreat = M28UnitInfo.GetAirThreatLevel(tAvailableBombers, false, false, false, true, false, true, false) + M28UnitInfo.GetAirThreatLevel(tUnavailableUnits, false, false, false, true, false, true, false)

            local iAAThreatThreshold

            local iAirAAThreatThreshold = 0
            if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] then iAirAAThreatThreshold = iTorpBomberThreat * 0.25
            elseif not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir]) then
                iAirAAThreatThreshold = math.min(iTorpBomberThreat * 0.15, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] * 0.25)
            end

            if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through water zones, iTorpBomberThreat='..iTorpBomberThreat..'; iAirAAThreatThreshold='..iAirAAThreatThreshold..'; tiWaterZoneByDistance='..repru(tiWaterZoneByDistance)) end
            for iWaterZone, iDistance in M28Utilities.SortTableByValue(tiWaterZoneByDistance, false) do
                local tWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][iTeam]
                if iTorpBomberThreat >= 6000 or (iTorpBomberThreat >= 4000 and GetGameTimeSeconds() - (tWZTeamData[M28Map.refiTimeOfLastTorpAttack] or -100) >= 3) then --Have so many torp bombers that dont want to worry about enemy groundAA threat unless massively more than us
                    iAAThreatThreshold = iTorpBomberThreat * 5
                    if bDebugMessages == true then LOG(sFunctionRef..': We have a large torp bomber threat so setting a high enemy AA threshold as even if we will lose the torps we may want to suicide them') end
                elseif GetGameTimeSeconds() - (tWZTeamData[M28Map.refiTimeOfLastTorpAttack] or -100) >= 5 then
                    --Havnet attacked for a while, so want more threat than enemy
                    iAAThreatThreshold = iTorpBomberThreat / 1.5
                    if iDistance >= 200 and not(tWZTeamData[M28Map.subrefWZbCoreBase]) then iAAThreatThreshold = iAAThreatThreshold * 0.5 end
                    if bDebugMessages == true then LOG(sFunctionRef..': Havent attacked for a while, so want to delay an attack until we think we have enough threat, i.e. want more mass in torps than enemy has in AA') end
                else
                    --Recently chose to attack here
                    iAAThreatThreshold = iTorpBomberThreat
                    if bDebugMessages == true then LOG(sFunctionRef..': We recently chose to attack this zone, so will be much more likely to attack with torps') end
                end
                if tWZTeamData[M28Map.subrefWZbCoreBase] or iDistance <= 150 then
                    iAAThreatThreshold = iAAThreatThreshold * 0.8
                elseif iDistance >= 300 then
                    iAAThreatThreshold = iAAThreatThreshold * (1 + (iDistance - 300) / 300)
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Considering if enemies in iWaterZone='..iWaterZone..'; iDistance='..iDistance..'; Is table of enemy units in this WZ empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]))..'; tWZTeamData[M28Map.subrefWZbCoreBase]='..tostring(tWZTeamData[M28Map.subrefWZbCoreBase] or false)..'; iTorpBomberThreat='..iTorpBomberThreat) end
                if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to attack, enemy AA threat threshold='..iAAThreatThreshold..'; DoesEnemyHaveAAThreatAlongPath='..tostring(DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, 0, iWaterZone, false, iAAThreatThreshold, 0))) end

                    --DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iEndPlateauOrZero, iEndLandOrWaterZone, bIgnoreAirAAThreat, iGroundAAThreatThreshold, iAirAAThreatThreshold, bUsingTorpBombers, iAirSubteam, bDoDetailedCheckForAA)
                    if not(DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, 0, iWaterZone, false,      iAAThreatThreshold,     iAirAAThreatThreshold, true, iAirSubteam)) then
                        --Add enemies in this water zone and any adjacent water zone
                        AddEnemyTargetsInWaterZone(iWaterZone, true)
                        tWZTeamData[M28Map.refiTimeOfLastTorpAttack] = GetGameTimeSeconds()
                        if bDebugMessages == true then LOG(sFunctionRef..': will attack enemies in this water zone if any valid targets, is tEnemyTargets empty='..tostring(M28Utilities.IsTableEmpty(tEnemyTargets))) end
                        if M28Utilities.IsTableEmpty(tEnemyTargets) == false then
                            --Assign targets by type
                            local iPriorityCat1 = M28UnitInfo.refCategoryGroundAA + M28UnitInfo.refCategoryShieldBoat
                            local iPriorityCat2 = M28UnitInfo.refCategoryFrigate - iPriorityCat1
                            local iOtherCat = categories.ALLUNITS - iPriorityCat1 - iPriorityCat2
                            local tEnemyPriority1 = EntityCategoryFilterDown(iPriorityCat1, tEnemyTargets)
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of priority1 units empty='..tostring(M28Utilities.IsTableEmpty(tEnemyPriority1))) end
                            if M28Utilities.IsTableEmpty(tEnemyPriority1) == false then
                                AssignTorpOrBomberTargets(tAvailableBombers, tEnemyPriority1, iAirSubteam)
                                if M28Utilities.IsTableEmpty(tAvailableBombers) then
                                    break
                                end
                            end
                            local tEnemyPriority2 = EntityCategoryFilterDown(iPriorityCat2, tEnemyTargets)
                            if M28Utilities.IsTableEmpty(tEnemyPriority2) == false then
                                AssignTorpOrBomberTargets(tAvailableBombers, tEnemyPriority2, iAirSubteam)
                                if M28Utilities.IsTableEmpty(tAvailableBombers) then
                                    break
                                end
                            end
                            local tEnemyOther = EntityCategoryFilterDown(iOtherCat, tEnemyTargets)
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table tEnemyOther empty='..tostring(M28Utilities.IsTableEmpty(tEnemyOther))) end
                            if M28Utilities.IsTableEmpty(tEnemyOther) == false then
                                AssignTorpOrBomberTargets(tAvailableBombers, tEnemyOther, iAirSubteam)
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of available bombers empty after assigning torp targets='..tostring(M28Utilities.IsTableEmpty(tAvailableBombers))) end
                                if M28Utilities.IsTableEmpty(tAvailableBombers) then
                                    break
                                end
                            end
                        end
                        --Clear enemy targets (incase e.g. we have decided not to attack some of them because we have enough threat assigned already or outside playable area)
                        tEnemyTargets = {}
                    else
                        tiWZWithTooMuchAA[iWaterZone] = true
                    end
                end
            end
        else
            M28Utilities.ErrorHandler('Have torpedo bombers but no areas to defend with them')
        end
        --Send remaining units to rally point (or refuel if could do with refuel)
        if M28Utilities.IsTableEmpty(tAvailableBombers) == false then
            for iUnit, oUnit in tAvailableBombers do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering idle torp bomber order for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' Unit fuel='..oUnit:GetFuelRatio()..'; Unit health%='..M28UnitInfo.GetUnitHealthPercent(oUnit)..'; rally point='..repru(tRallyPoint)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                if ((oUnit:GetFuelRatio() < 0.6 and oUnit:GetFuelRatio() >= 0) or M28UnitInfo.GetUnitHealthPercent(oUnit) <= 0.85) and not(EntityCategoryContains(categories.CANNOTUSEAIRSTAGING, oUnit.UnitId)) then
                    table.insert(tBombersForRefueling, oUnit)
                else
                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 10, false, 'TpIdle', false)
                end
            end
        end
    end

    --Flag if we lack torpedo bombers
    M28Team.tAirSubteamData[iAirSubteam][M28Team.refbNoAvailableTorpsForEnemies] = false
    if M28Utilities.IsTableEmpty(tAvailableBombers) or M28Utilities.IsTableEmpty(tiWZWithTooMuchAA) == false then
        if M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftiTorpedoDefenceWaterZones]) == false then
            local bConsiderEvenIfTooMuchAA = M28Utilities.IsTableEmpty(tAvailableBombers)
            for iEntry, iWaterZone in M28Team.tAirSubteamData[iAirSubteam][M28Team.reftiTorpedoDefenceWaterZones] do
                if bConsiderEvenIfTooMuchAA or tiWZWithTooMuchAA[iWaterZone] then
                    local tWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone]
                    local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if want torp bombers - considering iWaterZone='..iWaterZone..'; is table of enemy units mpety='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]))..'; does this WZ have only hover enemies='..tostring(tWZTeamData[M28Map.subrefbWZOnlyHoverEnemies])..'; iTorpBomberThreat='..iTorpBomberThreat..'; subrefTThreatEnemyCombatTotal='..(tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')) end
                    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false and not(tWZTeamData[M28Map.subrefbWZOnlyHoverEnemies]) and tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 100 or (tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]  >= 25 and iTorpBomberThreat == 0) then
                        --Check enemy doesnt have a naval fac in this zone if we have a significant torp bomber threat already
                        if iTorpBomberThreat < 2500 or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subrefTEnemyUnits])) then
                            M28Team.tAirSubteamData[iAirSubteam][M28Team.refbNoAvailableTorpsForEnemies] = true
                            if bDebugMessages == true then LOG(sFunctionRef..': We want more torp bombers as we lack available torp bombers') end
                            break
                        end
                    end
                end
            end
        end
    end

    --Send units for refueling
    if bDebugMessages == true then LOG(sFunctionRef..': Finished giving torp bomber orders, is table of air for refueling empty='..tostring(M28Utilities.IsTableEmpty(tBombersForRefueling))..'; M28Team.tAirSubteamData[iAirSubteam][M28Team.refbNoAvailableTorpsForEnemies]='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbNoAvailableTorpsForEnemies])) end
    --Run the function even if no units wanting refueling so already attached untis can be sent on their way
    SendUnitsForRefueling(tBombersForRefueling, iTeam, iAirSubteam)
    if bDebugMessages == true and M28Utilities.IsTableEmpty(tBombersForRefueling) == false then
        LOG(sFunctionRef..': Will send '..table.getn(tBombersForRefueling)..' units to refuel')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AssignTorpOrBomberTargets(tAvailableBombers, tEnemyTargets, iAirSubteam, bForceGroundFire, bTargetAAAndShieldsFirst)
    --NOTE: If want to prioritise by category then do by changing tEnemyTargets and calling this function multiple times

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignTorpOrBomberTargets'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bTargetAAAndShieldsFirst then
        if bDebugMessages == true then LOG(sFunctionRef..': Will split up targets between those iwth AA category and those without; also priority enemy ACUs ahead of all this, mass cost of available bombers='..M28UnitInfo.GetMassCostOfUnits(tAvailableBombers)) end
        if M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurBomberThreat] >= 2000 and EntityCategoryContains(M28UnitInfo.refCategoryBomber, tAvailableBombers[1].UnitId) then
            local tEnemyACU = EntityCategoryFilterDown(categories.COMMAND, tEnemyTargets)
            if bDebugMessages == true then LOG(sFunctionRef..': is table of enemy ACU empty='..tostring(M28Utilities.IsTableEmpty(tEnemyACU))) end
            if M28Utilities.IsTableEmpty(tEnemyACU) == false then
                if M28UnitInfo.GetMassCostOfUnits(tAvailableBombers) >= 15000 then
                    AssignTorpOrBomberTargets(tAvailableBombers, tEnemyACU, iAirSubteam, bForceGroundFire, false)
                end
            end
        end
        if M28Utilities.IsTableEmpty(tAvailableBombers) == false then
            local iSearchCategory = M28UnitInfo.refCategoryGroundAA + M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryMobileLandShield + M28UnitInfo.refCategoryShieldBoat
            local tEnemyAAAndShields = EntityCategoryFilterDown(iSearchCategory, tEnemyTargets)
            if M28Utilities.IsTableEmpty(tEnemyAAAndShields) then
                if bDebugMessages == true then LOG(sFunctionRef..': Have no enemy AA so will call this again and assign targets to all enemy units, without order to target AA first') end
                AssignTorpOrBomberTargets(tAvailableBombers, tEnemyTargets, iAirSubteam, bForceGroundFire, false)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Will call this function again targeting just the enemy AA units') end
                AssignTorpOrBomberTargets(tAvailableBombers, tEnemyAAAndShields, iAirSubteam, bForceGroundFire, false)
                if bDebugMessages == true then LOG(sFunctionRef..': Have finished targeting the enemy AA units, is available bombers empty='..tostring(M28Utilities.IsTableEmpty(tAvailableBombers))) end
                if M28Utilities.IsTableEmpty(tAvailableBombers) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': Still have available bombers so will target all units') end
                    local tOtherTargets = EntityCategoryFilterDown(categories.ALLUNITS - iSearchCategory, tEnemyTargets)
                    if M28Utilities.IsTableEmpty(tOtherTargets) == false then
                        AssignTorpOrBomberTargets(tAvailableBombers, tOtherTargets, iAirSubteam, bForceGroundFire, false)
                    end
                end
            end
        end
    else

        --Copy of M28Utiliteis function (for speed)
        function GetRoughDistanceBetweenPositions(tPosition1, tPosition2)
            --If want a rough indication of proximity but it isnt as important as speed
            return math.max(math.abs(tPosition1[1] - tPosition2[1]), math.abs(tPosition1[3] - tPosition2[3]))
        end



        --local iAvailableAirSize = table.getn(tAvailableBombers)
        local iEnemyTargetSize = table.getn(tEnemyTargets)
        local iClosestUnitDist, oClosestUnit, iCurDist, iClosestTorpRef
        local iCurLoopCount
        local iMaxLoopCount = 200 --Wont assign more than this number of AA units to a particular target, partly as an infinite loop check, and partly to avoid too much on a single unit (e.g. czar or ahwassa)
        local iTotalStrikeDamageWanted
        if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through torp bomber targets, iEnemyTargetSize='..iEnemyTargetSize..'; Time='..GetGameTimeSeconds()) end

        --First order enemy units by distance
        local tRallyPoint = M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint]
        local toEnemyUnitsByDistance = {}
        for iUnit, oUnit in tEnemyTargets do
            toEnemyUnitsByDistance[iUnit] = GetRoughDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint)
        end

        local aiBrain
        local bTorpBombers = false
        local bEnemyHasTorpDefence = false
        if tAvailableBombers[1] then
            aiBrain = tAvailableBombers[1]:GetAIBrain()
            if EntityCategoryContains(M28UnitInfo.refCategoryTorpBomber, tAvailableBombers[1].UnitId) then
                bTorpBombers = true
                for iUnit, oUnit in toEnemyUnitsByDistance do
                    if oUnit[M28UnitInfo.refbHasTorpedoDefence] then bEnemyHasTorpDefence = true break end
                end
            end
        else
            for iUnit, oUnit in tAvailableBombers do
                aiBrain = oUnit:GetAIBrain()
                break
            end
        end
        local bIssueAttackUnitOrder
        --Go through enemy units by distance to rally point (so target the nearest ones first)
        local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
        for iCurEnemyUnit, iDistance in M28Utilities.SortTableByValue(toEnemyUnitsByDistance, false) do
            --for iCurEnemyUnit = iEnemyTargetSize, 1, -1 do
            iClosestUnitDist = 100000
            local oEnemyUnit = tEnemyTargets[iCurEnemyUnit]
            if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(oEnemyUnit:GetPosition()) then
                iTotalStrikeDamageWanted = oEnemyUnit:GetMaxHealth()
                if oEnemyUnit.MyShield.GetMaxHealth then iTotalStrikeDamageWanted = iTotalStrikeDamageWanted + oEnemyUnit.MyShield:GetMaxHealth() end
                if bEnemyHasTorpDefence and bTorpBombers then iTotalStrikeDamageWanted = iTotalStrikeDamageWanted * 1.5 end
                local tBasePosition = oEnemyUnit:GetPosition()
                iCurLoopCount = 0
                --If dealing with an anti-air unit then increase strike damage wanted by 50% to allow for some of the torps dying
                if EntityCategoryContains(M28UnitInfo.refCategoryCruiserCarrier, oEnemyUnit.UnitId) then
                    iTotalStrikeDamageWanted = iTotalStrikeDamageWanted * 1.5
                elseif EntityCategoryContains(M28UnitInfo.refCategoryStructureAA + categories.COMMAND + M28UnitInfo.refCategoryGroundAA * categories.TECH3, oEnemyUnit.UnitId) then
                    iTotalStrikeDamageWanted = iTotalStrikeDamageWanted * 1.2
                    if EntityCategoryContains(categories.COMMAND, oEnemyUnit.UnitId) then
                        --Check if under a fixed shield
                        local iShieldHealth = M28Logic.IsTargetUnderShield(aiBrain, oEnemyUnit, 0, true, false, true, true)
                        iTotalStrikeDamageWanted = iTotalStrikeDamageWanted + (iShieldHealth or 0)
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering targeting oEnemyUnit='..(oEnemyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyUnit)..'; oEnemyUnit[refiStrikeDamageAssigned]='..(oEnemyUnit[refiStrikeDamageAssigned] or 'nil')..'; iTotalStrikeDamageWanted='..iTotalStrikeDamageWanted)..'; Can see unit='..tostring(M28UnitInfo.CanSeeUnit(aiBrain, oEnemyUnit))) end
                while (oEnemyUnit[refiStrikeDamageAssigned] or 0) < iTotalStrikeDamageWanted do
                    iCurLoopCount = iCurLoopCount + 1
                    if iCurLoopCount > iMaxLoopCount then M28Utilities.ErrorHandler('Potential infinite loop unless have '..iMaxLoopCount..' plus torp bombers') break end
                    iClosestUnitDist = 100000
                    for iTorp, oTorp in tAvailableBombers do
                        iCurDist = GetRoughDistanceBetweenPositions(tBasePosition, oTorp:GetPosition())
                        if iCurDist < iClosestUnitDist then
                            iClosestUnitDist = iCurDist
                            oClosestUnit = oTorp
                            iClosestTorpRef = iTorp
                        end
                    end

                    --Attack if we already have an attack order on this unit, or we ahve visibility of it - decided ot comment out as had added  to try and avoid a bug with units not targeting but it was caused by somethign else, left commented out in case want to reintroduce at a later point
                    bIssueAttackUnitOrder = not(bForceGroundFire)
                    --if bIssueAttackUnitOrder then bIssueAttackUnitOrder = M28UnitInfo.CanSeeUnit(aiBrain, oEnemyUnit) end

                    if bIssueAttackUnitOrder then
                        M28Orders.IssueTrackedAttack(oClosestUnit, oEnemyUnit, false, 'ATrp', false)
                    else
                        --Bomber - use attackground; torp bomber - use attackmove
                        if EntityCategoryContains(M28UnitInfo.refCategoryTorpBomber, oClosestUnit.UnitId) then
                            M28Orders.IssueTrackedAggressiveMove(oClosestUnit, oEnemyUnit:GetPosition(), 6, false, 'AMTrp', false)
                        else
                            --Bomber - ground fire
                            --IssueTrackedGroundAttack(oUnit,      tOrderPosition,         iDistanceToReissueOrder, bAddToExistingQueue, sOptionalOrderDesc, bOverrideMicroOrder, oOptionalLinkedUnitTarget)
                            M28Orders.IssueTrackedGroundAttack(oClosestUnit, oEnemyUnit:GetPosition(), 1,                       false,              'ABGrn',            false,                   oEnemyUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Issued ground attack for oEnemyUnit='..oEnemyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyUnit)..' at position '..repru(oEnemyUnit:GetPosition())) end
                        end
                    end
                    AddAssignedAttacker(oEnemyUnit, oClosestUnit) --Must do this after sending the order or else will be cleared
                    if bDebugMessages == true then LOG(sFunctionRef..': Will tell oClosestUnit='..oClosestUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestUnit)..' with distance '..iClosestUnitDist..' to attack enemy oEnemyUnit='..oEnemyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyUnit)..', strike damage of torp bomber='..oClosestUnit[M28UnitInfo.refiStrikeDamage]..'; assigned strike damage after including this='..oEnemyUnit[refiStrikeDamageAssigned]..'; bIssueAttackUnitOrder='..tostring(bIssueAttackUnitOrder or false)..'; oClosestUnit last order reprs='..reprs(oClosestUnit[M28Orders.reftiLastOrders])..'; target cur layer='..reprs(oEnemyUnit:GetCurrentLayer())..'; Will also remove unit from table of available bombers, iClosestTorpRef='..iClosestTorpRef) end

                    table.remove(tAvailableBombers, iClosestTorpRef)
                    if bDebugMessages == true then LOG(sFunctionRef..': Is tAvailableBombers empty after removal of the last entry='..tostring(M28Utilities.IsTableEmpty(tAvailableBombers))) end
                    if M28Utilities.IsTableEmpty(tAvailableBombers) then break end
                end
            end
            if M28Utilities.IsTableEmpty(tAvailableBombers) then break end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': end of code, is table of available bomers empty='..tostring(M28Utilities.IsTableEmpty(tAvailableBombers))) end
end

function GetUnitNearestEnemyBase(tUnitsToConsider, iTeam, tOptionalEnemyBaseOverride)
    --e.g. used to get the front gunship - will use straight line distance so best used for air units
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnitNearestEnemyBase'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCurPlateauOrZero, iCurLZOrWZ
    local iClosestDist = 100000
    local oClosestUnit
    local iCurDist
    for iUnit, oUnit in tUnitsToConsider do
        if not(oClosestUnit) then oClosestUnit = oUnit end --backup incase fail to find a unit with below approach
        if tOptionalEnemyBaseOverride then
            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOptionalEnemyBaseOverride)
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestUnit = oUnit
            end
        else

            --Get land/water zone, and get nearest enemy base from this
            iCurPlateauOrZero, iCurLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
            --[[if (iCurPlateauOrZero or 0) > 0 then
        if (iCurLZOrWZ or 0) == 0 then
            iCurLZOrWZ = M28Map.GetWaterZoneFromPosition(oUnit:GetPosition())
            if (iCurLZOrWZ or 0) > 0 then
                iCurPlateauOrZero = 0
            end
        end
    end--]]
            if (iCurLZOrWZ or 0) > 0 then
                local tLZOrWZTeamData
                if (iCurPlateauOrZero or 0) == 0 then
                    tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurLZOrWZ]][M28Map.subrefPondWaterZones][iCurLZOrWZ][M28Map.subrefWZTeamData][iTeam]
                else
                    tLZOrWZTeamData = M28Map.tAllPlateaus[iCurPlateauOrZero][M28Map.subrefPlateauLandZones][iCurLZOrWZ][M28Map.subrefLZTeamData][iTeam]
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Checking unit distance, iCurPlateauOrZero='..(iCurPlateauOrZero or 'nil')..'; iCurLZOrWZ='..(iCurLZOrWZ or 'nil')..' for oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; iCurLZOrWZ='..(iCurLZOrWZ or 'nil')..'; iCurPlateauOrZero='..(iCurPlateauOrZero or 'nil')..'; tLZOrWZTeamData[M28Map.reftClosestEnemyBase]='..repru(tLZOrWZTeamData[M28Map.reftClosestEnemyBase])) end

                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(),  tLZOrWZTeamData[M28Map.reftClosestEnemyBase])
                if iCurDist < iClosestDist then
                    iClosestDist = iCurDist
                    oClosestUnit = oUnit
                end
            end
        end
    end
    return oClosestUnit
end

function GetGunshipsToMoveToTarget(tAvailableGunships, tTarget)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetGunshipsToMoveToTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iGunshipMoveTolerance = 3 --If last move target was within 2.5 of current move target then wont move
    --Dist adjust - note this is a square, so e.g. if typical gunship range is 20+, then if are at +15x +15z from this, means will be 21 away, i.e. dont want to go further than +/- 15
    --[[local tDistanceAdjustXZ = {{0,0},{-5,-5},{5,5},{-5,5},{5,-5},{0,-5},{0,5},{-5,0},{5,0},
{-10,-10},{10,10},{-10,10},{10,-10},{0,-10},{0,10},{-10,0},{10,0},
{-15,-15},{15,15},{-15,15},{15,-15},{0,-15},{0,15},{-15,0},{15,0},
{-20,-20},{20,20},{-20,20},{20,-20},{0,-20},{0,20},{-20,0},{20,0}}--]]
    if M28Utilities.IsTableEmpty(tDistanceAdjustXZ) then
        table.insert(tDistanceAdjustXZ, {0,0})
        local iAdjustInterval = 6 --At 6.5 sometimes gunships on the outer edges dont have targets
        local iMinGunshipRange = 20
        local iMaxCycles = math.max(math.floor(iMinGunshipRange / iAdjustInterval), 1)
        local iAdjustBase
        local iCornerAdjust
        for iCurCycle = 1, iMaxCycles, 1 do
            --Want to record as ever expanding hollow boxes
            iAdjustBase = iCurCycle * iAdjustInterval
            --First go along the top and bottom of the box; exclude corners if at the last entry
            if iCurCycle < iMaxCycles then iCornerAdjust = 0 else iCornerAdjust = iAdjustInterval end
            for iCurX = - iAdjustBase + iCornerAdjust, iAdjustBase - iCornerAdjust, iAdjustInterval do
                for iCurZ = - iAdjustBase, iAdjustBase, iAdjustBase * 2 do
                    table.insert(tDistanceAdjustXZ, {iCurX, iCurZ})
                end
            end
            --Then do the left and right columns/sides of the box (excl corners which ahve already done per the above)
            for iCurX = - iAdjustBase, iAdjustBase, iAdjustBase * 2 do
                for iCurZ = -iAdjustBase + iAdjustInterval, iAdjustBase - iAdjustInterval, iAdjustInterval do
                    table.insert(tDistanceAdjustXZ, {iCurX, iCurZ})
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': tDistanceAdjustXZ after update has '..table.getn(tDistanceAdjustXZ)..' entries, repru='..repru(tDistanceAdjustXZ)) end
        end
    end
    --Find the first placement that we dont have assigned
    local tiValidPlacements = {}
    local iTotalUnits = table.getn(tAvailableGunships)
    for iUnit, oUnit in tAvailableGunships do
        if bDebugMessages == true then LOG(sFunctionRef..': Working out what gunships already have placements, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Placement='..(oUnit[refiGunshipPlacement] or 'nil')..'; Is easy brain='..tostring(oUnit[M28UnitInfo.refbEasyBrain] or false)) end
        if oUnit[refiGunshipPlacement] then
            if tiValidPlacements[oUnit[refiGunshipPlacement]] then
                --Duplicate entry so need to clear this unit
                oUnit[refiGunshipPlacement] = 10000
            else
                tiValidPlacements[oUnit[refiGunshipPlacement]] = true
            end
        end
    end
    local iFirstMissingPlacement
    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code at time '..GetGameTimeSeconds()..'; iTotalUnits='..iTotalUnits) end
    for iCurPlacement = 1, iTotalUnits do
        if not(tiValidPlacements[iCurPlacement]) then
            iFirstMissingPlacement = iCurPlacement
            if bDebugMessages == true then LOG(sFunctionRef..': First missing placement='..iCurPlacement) end
            break
        end
    end

    local tAdjustedMovePosition
    local iCurPlacement
    local iPlacementSize = table.getn(tDistanceAdjustXZ)
    local iEasyGunships = 0
    if iFirstMissingPlacement then
        local toUnitsToPlace = {}
        for iUnit, oUnit in tAvailableGunships do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering gunship'..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; its placement is '..(oUnit[refiGunshipPlacement] or 'nil')..'; Is easy='..tostring(oUnit[M28UnitInfo.refbEasyBrain] or false)..'; iFirstMissingPlacement='..iFirstMissingPlacement) end
            if (oUnit[refiGunshipPlacement] or 10000) >= iFirstMissingPlacement then
                if oUnit[M28UnitInfo.refbEasyBrain] then
                    --Just attackmove to the target
                    M28Orders.IssueTrackedAggressiveMove(oUnit, tTarget, 4, false, 'GSEsyA', false)
                    iEasyGunships = iEasyGunships + 1
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Gunship '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has placement '..(oUnit[refiGunshipPlacement] or 'nil')..' so will add to table of units needing new placements') end
                    table.insert(toUnitsToPlace, oUnit)
                end
            end
        end

        local iClosestDist
        local iCurDist
        local iClosestUnitRef
        if iEasyGunships == 0 or iFirstMissingPlacement <= iTotalUnits - iEasyGunships then
            for iBasePlacement = iFirstMissingPlacement, iTotalUnits - iEasyGunships do
                --Adjust placement value to reflect we have only defined a limited number of options
                if M28Utilities.IsTableEmpty(toUnitsToPlace) then break end --redundancy
                iCurPlacement = iBasePlacement
                if bDebugMessages == true then LOG(sFunctionRef..': iCurPlacement='..iCurPlacement..'; iPlacementSize='..iPlacementSize..'; will reduce cur placement if it exceeds the size') end
                while iCurPlacement  > iPlacementSize do
                    iCurPlacement = iCurPlacement - iPlacementSize
                end
                --Identify which gunship is closest to each placement point
                tAdjustedMovePosition = {tTarget[1] + tDistanceAdjustXZ[iCurPlacement][1], tTarget[2], tTarget[3] + tDistanceAdjustXZ[iCurPlacement][2]}
                iClosestDist = 10000
                iClosestUnitRef = nil
                for iUnit, oUnit in toUnitsToPlace do
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tAdjustedMovePosition)
                    if iCurDist < iClosestDist then
                        iClosestDist = iCurDist
                        iClosestUnitRef = iUnit
                    end
                end
                --Assign this position to this gunship
                toUnitsToPlace[iClosestUnitRef][refiGunshipPlacement] = iBasePlacement
                if bDebugMessages == true then LOG(sFunctionRef..': Assigning gunship '..toUnitsToPlace[iClosestUnitRef].UnitId..M28UnitInfo.GetUnitLifetimeCount(toUnitsToPlace[iClosestUnitRef])..' to base placement '..iBasePlacement) end
                table.remove(toUnitsToPlace, iClosestUnitRef)
            end
        end
    end

    --Issue move orders
    local toUnitsByBasePlacementRef = {}
    for iUnit, oUnit in tAvailableGunships do
        if oUnit[refiGunshipPlacement] then
            toUnitsByBasePlacementRef[oUnit[refiGunshipPlacement]] = oUnit
            if bDebugMessages == true then LOG(sFunctionRef..': Recording unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with gunship placement '..(oUnit[refiGunshipPlacement] or 'nil')..' in table toUnitsByBasePlacementRef') end
        end
    end

    function MoveIndividualGunship(oClosestUnit, tUnitDestination)
        --Experimental gunship doesnt attack properly when just given a move order
        if EntityCategoryContains(M28UnitInfo.categories.EXPERIMENTAL, oClosestUnit.UnitId) and M28Utilities.GetDistanceBetweenPositions(oClosestUnit:GetPosition(), tUnitDestination) <= 20 then
            M28Orders.IssueTrackedAggressiveMove(oClosestUnit, tUnitDestination, iGunshipMoveTolerance, false, 'GSExA', false)
        else
            M28Orders.IssueTrackedMove(oClosestUnit, tUnitDestination, iGunshipMoveTolerance, false, 'GSAtc', false)
        end
    end

    if iEasyGunships== 0 or iTotalUnits > iEasyGunships then
        for iBasePlacement = 1, iTotalUnits - iEasyGunships do
            iCurPlacement = iBasePlacement
            while iCurPlacement  > iPlacementSize do
                iCurPlacement = iCurPlacement - iPlacementSize
            end

            tAdjustedMovePosition = {tTarget[1] + tDistanceAdjustXZ[iCurPlacement][1], tTarget[2], tTarget[3] + tDistanceAdjustXZ[iCurPlacement][2]}
            tAdjustedMovePosition[2] = GetSurfaceHeight(tAdjustedMovePosition[1], tAdjustedMovePosition[3])
            if bDebugMessages == true then LOG(sFunctionRef..': iBasePlacement='..iBasePlacement..'; Is the entry in UnitsByPlacementRef nil for this='..tostring(not(toUnitsByBasePlacementRef[iBasePlacement]))) end
            if not(toUnitsByBasePlacementRef[iBasePlacement]) then
                M28Utilities.ErrorHandler('Missing gunship for iBasePlacement='..iBasePlacement..'; iEasyGunships='..(iEasyGunships or 'nil')..'; iTotalUnits='..iTotalUnits)
            else
                MoveIndividualGunship(toUnitsByBasePlacementRef[iBasePlacement], tAdjustedMovePosition)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageGunships(iTeam, iAirSubteam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageGunships'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tAvailableGunships, tGunshipsForRefueling, tUnavailableUnits = GetAvailableLowFuelAndInUseAirUnits(iTeam, iAirSubteam, M28UnitInfo.refCategoryGunship + M28UnitInfo.refCategoryCzar + M28UnitInfo.refCategoryTransport * categories.EXPERIMENTAL, nil, not(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets])))
    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, time='..GetGameTimeSeconds()..'; Is tAvailableGunships empty='..tostring(M28Utilities.IsTableEmpty(tAvailableGunships))..'; Is table of active snipe targets empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets]))) end
    M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] = M28UnitInfo.GetAirThreatLevel(tAvailableGunships, false, false, false, true, false, false) + M28UnitInfo.GetAirThreatLevel(tGunshipsForRefueling, false, false, false, true, false, false) + M28UnitInfo.GetAirThreatLevel(tUnavailableUnits, false, false, false, true, false, false)

    local tViaFromRallyPoint --if we use this and via from front gunship we will avoid significant groundAA (where these are specified)
    local tViaFromFrontGunshipPoint
    local iDistToMoveToAltPoint = 150
    local iCloseToFrontThreshold = 50
    local iAngleFromRallyToGunship, iDistFromRallyToGunship
    local iEnemyAirAAThreatNearGunship
    local tTeleportTargetToMoveTo --used if we want to preemptively move to an enemy teleport target location
    if bDebugMessages == true then LOG(sFunctionRef..': Is front gunship valid='..tostring(M28UnitInfo.IsUnitValid(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]))) end
    if M28UnitInfo.IsUnitValid(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]) then
        --If we go from the rally point to the last front gunship, do we come across any zones with a large ground threat? if so then want to try an alt rally point
        local iGunshipPlateauOrZero, iGunshipLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition())
        if iGunshipPlateauOrZero and (iGunshipLandOrWaterZone or 0) > 0 then
            --Ignore this logic if significant AA threat in the gunship current zone
            local tGunshipLandOrWaterZoneData, tGunshipLandOrWaterZoneTeamData
            local iEnemyGroundAAThreatByGunship

            if iGunshipPlateauOrZero == 0 then
                --iGunshipLandOrWaterZone = M28Map.GetWaterZoneFromPosition(oFrontGunship:GetPosition())
                tGunshipLandOrWaterZoneData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iGunshipLandOrWaterZone]][M28Map.subrefPondWaterZones][iGunshipLandOrWaterZone]
                tGunshipLandOrWaterZoneTeamData = tGunshipLandOrWaterZoneData[M28Map.subrefWZTeamData][iTeam]
                iEnemyGroundAAThreatByGunship = (tGunshipLandOrWaterZoneTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0)
                iEnemyAirAAThreatNearGunship = (tGunshipLandOrWaterZoneTeamData[M28Map.refiEnemyAirAAThreat] or 0)
            else
                tGunshipLandOrWaterZoneData = M28Map.tAllPlateaus[iGunshipPlateauOrZero][M28Map.subrefPlateauLandZones][iGunshipLandOrWaterZone]
                tGunshipLandOrWaterZoneTeamData = tGunshipLandOrWaterZoneData[M28Map.subrefLZTeamData][iTeam]
                iEnemyGroundAAThreatByGunship = (tGunshipLandOrWaterZoneTeamData[M28Map.subrefWZThreatEnemyAA] or 0)
                iEnemyAirAAThreatNearGunship = (tGunshipLandOrWaterZoneTeamData[M28Map.refiEnemyAirAAThreat] or 0)
            end
            local tNearbyEnemyAirAA
            if M28UnitInfo.IsUnitValid(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]) and (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] or 0) > 0 then
                tNearbyEnemyAirAA = M28Team.GetFirstActiveM28Brain(iTeam):GetUnitsAroundPoint(M28UnitInfo.refCategoryAirAA + M28UnitInfo.refCategoryCzar + M28UnitInfo.refCategoryRestorer, M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition(), 70, 'Enemy')

                if M28Utilities.IsTableEmpty(tNearbyEnemyAirAA) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': iEnemyAirAAThreatNearGunship before getunitsaroundpoint='..iEnemyAirAAThreatNearGunship..'; Threat from getunitsaroundpoint='..M28UnitInfo.GetAirThreatLevel(tNearbyEnemyAirAA, true, true, false, false, false, false)) end
                    iEnemyAirAAThreatNearGunship = math.max(iEnemyAirAAThreatNearGunship, M28UnitInfo.GetAirThreatLevel(tNearbyEnemyAirAA, true, true, false, false, false, false))
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iEnemyGroundAAThreatByGunship='..iEnemyGroundAAThreatByGunship..'; Gunship threat='..M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat]..'; iEnemyAirAAThreatNearGunship='..iEnemyAirAAThreatNearGunship) end

            if iEnemyGroundAAThreatByGunship <= math.min(2000, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] * 0.15) and iEnemyAirAAThreatNearGunship <= math.min(500, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] * 0.05) then
                iDistFromRallyToGunship = M28Utilities.GetDistanceBetweenPositions(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint], M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition())
                if M28Map.iMapSize >= 1024 and iDistFromRallyToGunship >= 250 then iDistToMoveToAltPoint = 200 end
                if bDebugMessages == true then LOG(sFunctionRef..': iDistFromRallyToGunship='..iDistFromRallyToGunship..'; iDistToMoveToAltPoint='..iDistToMoveToAltPoint) end
                if iDistFromRallyToGunship >= math.max(iDistToMoveToAltPoint * 1.2, 200) and not(tGunshipLandOrWaterZoneTeamData[M28Map.subrefLZbCoreBase]) and M28Utilities.GetDistanceBetweenPositions(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition(), tGunshipLandOrWaterZoneTeamData[M28Map.reftClosestFriendlyBase]) >= 150 then
                    iAngleFromRallyToGunship = M28Utilities.GetAngleFromAToB(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint], M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition())
                    local iRallyPlateauOrZero, iRallyLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint])
                    if iRallyPlateauOrZero and iRallyLandOrWaterZone then
                        --Is there significant enemy ground to air threat along this path? assume gunships will continue moving towards the end a small bit before the check (to reduce cases where we retreat somewhere more dangerous due to a threat miscalculation/ignore a normal path that would be relatively safe); also because front gunship usually isn't the most accurate choice and want somewwhere closer to the current gunship grouping midpoint
                        if bDebugMessages == true then LOG(sFunctionRef..': Front gunship position='..repru(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition())..'; Angle from rally to gunship='..iAngleFromRallyToGunship..'; Rally position='..repru(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint])) end
                        local tAssumedGunshipPositionShortly = M28Utilities.MoveInDirection(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition(), iAngleFromRallyToGunship + 180, 20, true, false, M28Map.bIsCampaignMap)
                        if M28Conditions.IsLocationInPlayableArea(tAssumedGunshipPositionShortly) then --E.g. for campaign map gunship might be outside playable area leading to issues
                            local iEnemyGroundAAAlongPath = DoesEnemyHaveAAThreatAlongPath(iTeam, iGunshipPlateauOrZero, iGunshipLandOrWaterZone, iRallyPlateauOrZero, iRallyLandOrWaterZone, true, 0, nil, false, iAirSubteam, true, true, (tAssumedGunshipPositionShortly or M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition()))
                            if bDebugMessages == true then LOG(sFunctionRef..': iEnemyGroundAAAlongPath='..iEnemyGroundAAAlongPath..'; Front gunship position='..repru(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition())..'; iGunshipPlateauOrZero='..iGunshipPlateauOrZero..'; iGunshipLandOrWaterZone='..iGunshipLandOrWaterZone..'; front gunship last recorded='..(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]) or 'nil')) end
                            if iEnemyGroundAAAlongPath >= math.min(3600, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] * 0.2) then
                                --If we try moving at 90 degrees for a moderate distance both from rally point and front gunship, do we significantly reduce the groundAA?
                                local tRallyViaPoint1 = M28Utilities.MoveInDirection(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint], iAngleFromRallyToGunship + 90, iDistToMoveToAltPoint, true, false, M28Map.bIsCampaignMap)
                                local iMaxGroundAA
                                if M28Conditions.IsLocationInPlayableArea(tRallyViaPoint1) then
                                    local iRally1ViaPlateau, iRally1ViaZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tRallyViaPoint1)
                                    iMaxGroundAA = iEnemyGroundAAAlongPath * 0.75 --no point taking longer detour if not significantly decreasing AA threat
                                    local iGroundAAThreatForPoint1 = DoesEnemyHaveAAThreatAlongPath(iTeam, iRallyPlateauOrZero, iRallyLandOrWaterZone, iRally1ViaPlateau, iRally1ViaZone, true, 0, nil, false, iAirSubteam, true, true)
                                    local tGunshipViaPoint1
                                    if bDebugMessages == true then LOG(sFunctionRef..': iGroundAAThreatForPoint1 just for rally to rally via='..iGroundAAThreatForPoint1..'; tRallyViaPoint1='..repru(tRallyViaPoint1)) end
                                    if iGroundAAThreatForPoint1 < iMaxGroundAA then
                                        tGunshipViaPoint1 = M28Utilities.MoveInDirection(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition(), iAngleFromRallyToGunship - 90, iDistToMoveToAltPoint, true, false, M28Map.bIsCampaignMap)
                                        local iGunshipViaPlateau, iGunshipViaZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tGunshipViaPoint1)
                                        iGroundAAThreatForPoint1 = iGroundAAThreatForPoint1 + DoesEnemyHaveAAThreatAlongPath(iTeam, iRally1ViaPlateau, iRally1ViaZone, iGunshipViaPlateau, iGunshipViaZone, true, 0, nil, false, iAirSubteam, true, true, M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition())
                                        if bDebugMessages == true then LOG(sFunctionRef..': iGroundAAThreatForPoint1 with rally via to gunship via added='..iGroundAAThreatForPoint1..'; tGunshipViaPoint1='..repru(tGunshipViaPoint1)) end
                                        if iGroundAAThreatForPoint1 < iMaxGroundAA then
                                            iGroundAAThreatForPoint1 = iGroundAAThreatForPoint1 + DoesEnemyHaveAAThreatAlongPath(iTeam, iGunshipViaPlateau, iGunshipViaZone, iGunshipPlateauOrZero, iGunshipLandOrWaterZone, true, 0, nil, false, iAirSubteam, true, true, M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition())
                                            if bDebugMessages == true then LOG(sFunctionRef..': iGroundAAThreatForPoint1 with remaining via added='..iGroundAAThreatForPoint1) end
                                        end
                                    end

                                    local tRallyViaPoint2 = M28Utilities.MoveInDirection(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint], iAngleFromRallyToGunship - 90, iDistToMoveToAltPoint, true, false, M28Map.bIsCampaignMap)
                                    if M28Conditions.IsLocationInPlayableArea(tRallyViaPoint2) then
                                        local iRally2ViaPlateau, iRally2ViaZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tRallyViaPoint2)
                                        local iGroundAAThreatForPoint2 = DoesEnemyHaveAAThreatAlongPath(iTeam, iRallyPlateauOrZero, iRallyLandOrWaterZone, iRally2ViaPlateau, iRally2ViaZone, true, 0, nil, false, iAirSubteam, true, true)
                                        local tGunshipViaPoint2
                                        if bDebugMessages == true then LOG(sFunctionRef..': iGroundAAThreatForPoint2 just for rally to rally via='..iGroundAAThreatForPoint2..'; tRallyViaPoint2='..repru(tRallyViaPoint2)) end
                                        if iGroundAAThreatForPoint2 < iMaxGroundAA then
                                            --MoveInDirection(tStart,                                                                   iAngle,                         iDistance,  bKeepInMapBounds, bTravelUnderwater, bKeepInCampaignPlayableArea)
                                            tGunshipViaPoint2 = M28Utilities.MoveInDirection(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition(), iAngleFromRallyToGunship + 90, iDistToMoveToAltPoint, true, false, M28Map.bIsCampaignMap)
                                            local iGunshipViaPlateau, iGunshipViaZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tGunshipViaPoint2)
                                            iGroundAAThreatForPoint2 = iGroundAAThreatForPoint2 + DoesEnemyHaveAAThreatAlongPath(iTeam, iRally2ViaPlateau, iRally2ViaZone, iGunshipViaPlateau, iGunshipViaZone, true, 0, nil, false, iAirSubteam, true, true, M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition())
                                            if bDebugMessages == true then LOG(sFunctionRef..': iGroundAAThreatForPoint2 with via to via='..iGroundAAThreatForPoint2..'; tGunshipViaPoint2='..repru(tGunshipViaPoint2)) end
                                            if iGroundAAThreatForPoint2 < iMaxGroundAA then
                                                iGroundAAThreatForPoint2 = iGroundAAThreatForPoint2 + DoesEnemyHaveAAThreatAlongPath(iTeam, iGunshipViaPlateau, iGunshipViaZone, iGunshipPlateauOrZero, iGunshipLandOrWaterZone, true, 0, nil, false, iAirSubteam, true, true, M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition())
                                                if bDebugMessages == true then LOG(sFunctionRef..': iGroundAAThreatForPoint2 with remainder='..iGroundAAThreatForPoint2) end
                                            end
                                        end
                                        if iGroundAAThreatForPoint1 < iMaxGroundAA then
                                            if iGroundAAThreatForPoint2 < iGroundAAThreatForPoint1 then
                                                --use point 2
                                                tViaFromRallyPoint = {tRallyViaPoint2[1], tRallyViaPoint2[2], tRallyViaPoint2[3]}
                                                tViaFromFrontGunshipPoint = {tGunshipViaPoint2[2], tGunshipViaPoint2[2], tGunshipViaPoint2[3]}
                                            else
                                                --Use point 1
                                                tViaFromRallyPoint = {tRallyViaPoint1[1], tRallyViaPoint1[2], tRallyViaPoint1[3]}
                                                tViaFromFrontGunshipPoint = {tGunshipViaPoint1[2], tGunshipViaPoint1[2], tGunshipViaPoint1[3]}
                                            end
                                        elseif iGroundAAThreatForPoint2 < iMaxGroundAA then
                                            --use point 2
                                            tViaFromRallyPoint = {tRallyViaPoint2[1], tRallyViaPoint2[2], tRallyViaPoint2[3]}
                                            tViaFromFrontGunshipPoint = {tGunshipViaPoint2[2], tGunshipViaPoint2[2], tGunshipViaPoint2[3]}
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': tViaFromFrontGunshipPoint='..repru(tViaFromFrontGunshipPoint)..'; iMaxGroundAA='..(iMaxGroundAA or 'nil')) end
                                --move from gunship via to the rally via
                                if tViaFromFrontGunshipPoint then
                                    tViaFromFrontGunshipPoint = M28Utilities.MoveInDirection(tViaFromFrontGunshipPoint, iAngleFromRallyToGunship + 180, iDistToMoveToAltPoint, true)
                                    --If this is close to the gunship front position then make the gunship via point the rally via point
                                    if bDebugMessages == true then LOG(sFunctionRef..': tViaFromFrontGunshipPoint after moving towards rally some more='..repru(tViaFromFrontGunshipPoint)..'; iAngleFromRallyToGunship='..iAngleFromRallyToGunship..'; Is tViaFromFrontGunshipPoint in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tViaFromFrontGunshipPoint))..'; tViaFromRallyPoint='..repru(tViaFromRallyPoint)..'; Dist from front gunship to front gunship via point='..M28Utilities.GetDistanceBetweenPositions(tViaFromFrontGunshipPoint, M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition())..'; If distance is too close then will replace gunship via point with rally via point')
                                        LOG(sFunctionRef..': Normal rally point='..repru(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint])..'; will draw normal rally point in blue')
                                        M28Utilities.DrawLocation(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint])
                                        LOG(sFunctionRef..': Will draw tViaFromFrontGunshipPoint in red, and tViaFromRallyPoint in gold')
                                        M28Utilities.DrawLocation(tViaFromFrontGunshipPoint, 2)
                                        M28Utilities.DrawLocation(tViaFromRallyPoint, 4)
                                    end
                                    if M28Utilities.GetDistanceBetweenPositions(tViaFromFrontGunshipPoint, M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship]:GetPosition()) <= math.max(30, math.min(iCloseToFrontThreshold, iDistToMoveToAltPoint - 5)) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Front gunship via point is too close so will use rally via point instead') end
                                        tViaFromFrontGunshipPoint = tViaFromRallyPoint
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    local oFrontGunship
    local bGunshipWantsAirScout = false
    if bDebugMessages == true then LOG(sFunctionRef..': About to move onto main gunship logic if have any available, is table of available gunships empty='..tostring(M28Utilities.IsTableEmpty(tAvailableGunships))..'; Is tViaFromFrontGunshipPoint empty='..tostring(M28Utilities.IsTableEmpty(tViaFromFrontGunshipPoint))) end
    if M28Utilities.IsTableEmpty(tAvailableGunships) == false then
        local tiPlateauAndZoneForEnemiesToBeIn = {} --if dont have priority targets, then will use this to focus on higher value targets (e.g. to try and reduce cases where 100 t3 gunships will move halfway across the map for 1 MAA)
        --Prioroity targets to attack - search for enemies around start positions (ignore AA):
        local tEnemyGroundOrGunshipTargets = {}
        --Get the gunship nearest to an enemy base and record this as the front gunship
        local tOptionalEnemyBaseOverride
        if M28Map.bIsCampaignMap and M28Team.GetFirstActiveM28Brain(iTeam).CampaignAI then
            --Get the nearest zone with significant enemy structure threat inside the playable area, if there is such a zone
            tOptionalEnemyBaseOverride = M28Team.GetEnemyMainCampaignBase(iTeam)
        end
        oFrontGunship = GetUnitNearestEnemyBase(tAvailableGunships, iTeam, tOptionalEnemyBaseOverride)
        --Adjustment - consider changing front gunship if previous front gunship is valid and is far away but with significantly more gunships near it (unless its an experimental)
        local iAvailableGunshipCount = table.getn(tAvailableGunships)
        if iAvailableGunshipCount >= 5 and M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftFrontGunshipPosition]) == false and not(M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship] == oFrontGunship) and M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurGunshipThreat] >= 2500 and not(EntityCategoryContains(categories.EXPERIMENTAL, oFrontGunship.UnitId)) and M28Utilities.GetDistanceBetweenPositions(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftFrontGunshipPosition], oFrontGunship:GetPosition()) >= 60 then
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            local tGunshipsNearNewFrontGunship = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryGunship, oFrontGunship:GetPosition(), 50, 'Ally')
            local tGunshipNearOldFrontGunship = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryGunship, M28Team.tAirSubteamData[iAirSubteam][M28Team.reftFrontGunshipPosition], 50, 'Ally')
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if should change front gunship, front gunship before='..oFrontGunship.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFrontGunship)..'; Size of gunships near old front gunship='..table.getn(tGunshipNearOldFrontGunship)..'; Size of gunships near new front gunship='..table.getn(tGunshipsNearNewFrontGunship)..'; Front gunship position='..repru(oFrontGunship:GetPosition())..'; Old position='..repru(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftFrontGunshipPosition])..'; Distance between them='..M28Utilities.GetDistanceBetweenPositions(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftFrontGunshipPosition], oFrontGunship:GetPosition())) end
            if tGunshipNearOldFrontGunship and table.getn(tGunshipNearOldFrontGunship) > 2.5 * table.getn(tGunshipsNearNewFrontGunship) then
                --Get closest gunship to the old front gunship
                local iCurDist
                local iClosestToFrontDist = 10000
                local tOldGunshipPosition = M28Team.tAirSubteamData[iAirSubteam][M28Team.reftFrontGunshipPosition]
                for iUnit, oUnit in tGunshipNearOldFrontGunship do
                    if oUnit:GetAIBrain().M28AirSubteam == iAirSubteam and oUnit[refiGunshipPlacement] < 10000 then
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOldGunshipPosition)
                        if bDebugMessages == true then LOG(sFunctionRef..': Searching for closest unit to old gunship position, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..iCurDist..'; iClosestToFrontDist='..iClosestToFrontDist..'; Gunship placement number='..(oUnit[refiGunshipPlacement] or 'nil')) end
                        if iCurDist < iClosestToFrontDist then
                            oFrontGunship = oUnit
                            iClosestToFrontDist = iCurDist
                            if iClosestToFrontDist < 1 then break end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': oFrontGunship after check='..oFrontGunship.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFrontGunship)) end
            end
        end
        M28Team.tAirSubteamData[iAirSubteam][M28Team.reftFrontGunshipPosition] = {oFrontGunship:GetPosition()[1], oFrontGunship:GetPosition()[2], oFrontGunship:GetPosition()[3]}


        --Cloaked nearby enemy ACU - want gunship to be a priority
        if M28UnitInfo.IsUnitValid(oFrontGunship) and M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits]) then

            local iCloakedUnits = table.getn(M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits])

            for iCurEntry = iCloakedUnits, 1, -1 do
                if not(bGunshipWantsAirScout) and M28Utilities.GetDistanceBetweenPositions(oFrontGunship:GetPosition(), M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits][iCurEntry]:GetPosition()) <= 200 then
                    bGunshipWantsAirScout = true
                    break
                end
            end
        end


        local tGunshipsNearFront = {}
        local tGunshipsNotNearFront = {}
        local iCurDist

        for iUnit, oUnit in tAvailableGunships do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering how close unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is to front gunship '..oFrontGunship.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFrontGunship)..'; Dist='..M28Utilities.GetDistanceBetweenPositions(oFrontGunship:GetPosition(), oUnit:GetPosition())..'; Threat of unit='..M28UnitInfo.GetAirThreatLevel({ oUnit}, false, false, false, true, false, false)) end
            iCurDist = M28Utilities.GetDistanceBetweenPositions(oFrontGunship:GetPosition(), oUnit:GetPosition())
            if iCurDist <= iCloseToFrontThreshold then
                table.insert(tGunshipsNearFront, oUnit)
            else
                table.insert(tGunshipsNotNearFront, oUnit)
            end
            --Track available gunship health
            if EntityCategoryContains(categories.TECH3, oUnit.UnitId) then
                oUnit[M28UnitInfo.refiHealthSecondLastCheck] = oUnit[M28UnitInfo.refiHealthWhenLastChecked]
                oUnit[M28UnitInfo.refiHealthWhenLastChecked] = oUnit:GetHealth()
            end
        end
        local iOurGunshipThreat = M28UnitInfo.GetAirThreatLevel(tGunshipsNearFront, false, false, false, true, false, false)

        --GetAirThreatLevel(tUnits, bEnemyUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
        local iOurGunshipAA = M28UnitInfo.GetAirThreatLevel(tAvailableGunships, false,  true,               false,              false, false, false)
        local bHaveT3Gunships = false
        if iOurGunshipThreat >= 2000 then
            if EntityCategoryContains(categories.TECH3 + categories.EXPERIMENTAL, tAvailableGunships[1].UnitId) then bHaveT3Gunships = true
            elseif M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.TECH3 + categories.EXPERIMENTAL, tAvailableGunships)) == false then
                bHaveT3Gunships = true
            end
        end

        local iGunshipPlateauOrZero, iGunshipLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oFrontGunship:GetPosition())
        local tGunshipLandOrWaterZoneData, tGunshipMidpoint, tGunshipLandOrWaterZoneTeamData
        if iGunshipPlateauOrZero == 0 then
            --iGunshipLandOrWaterZone = M28Map.GetWaterZoneFromPosition(oFrontGunship:GetPosition())
            tGunshipLandOrWaterZoneData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iGunshipLandOrWaterZone]][M28Map.subrefPondWaterZones][iGunshipLandOrWaterZone]
            tGunshipLandOrWaterZoneTeamData = tGunshipLandOrWaterZoneData[M28Map.subrefWZTeamData][iTeam]
            tGunshipMidpoint = tGunshipLandOrWaterZoneData[M28Map.subrefMidpoint]
            if bDebugMessages == true then LOG(sFunctionRef..': Have a water zone, iGunshipLandOrWaterZone='..(iGunshipLandOrWaterZone or 'nil')) end
        else
            tGunshipLandOrWaterZoneData = M28Map.tAllPlateaus[iGunshipPlateauOrZero][M28Map.subrefPlateauLandZones][iGunshipLandOrWaterZone]
            tGunshipLandOrWaterZoneTeamData = tGunshipLandOrWaterZoneData[M28Map.subrefLZTeamData][iTeam]
            tGunshipMidpoint = tGunshipLandOrWaterZoneData[M28Map.subrefMidpoint]
        end
        if bDebugMessages == true then
            LOG(sFunctionRef..': oFrontGunship='..oFrontGunship.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFrontGunship)..'; Position='..repru(oFrontGunship:GetPosition())..'; iGunshipPlateauOrZero='..(iGunshipPlateauOrZero or 'nil')..'; iGunshipLandOrWaterZone='..(iGunshipLandOrWaterZone or 'nil')..'; tGunshipMidpoint='..repru(tGunshipMidpoint)..'; WZ from position='..(M28Map.GetWaterZoneFromPosition(oFrontGunship:GetPosition()) or 'nil')..'; Is table of enemy experimentals empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals])))
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
                local iExperimentalPlateau, iExperimentalZone
                for iExperimental, oExperimental in M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
                    iExperimentalPlateau, iExperimentalZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oExperimental:GetPosition())
                    LOG(sFunctionRef..': Considering oExperimental '..oExperimental.UnitId..M28UnitInfo.GetUnitLifetimeCount(oExperimental)..' at position '..repru(oExperimental:GetPosition())..' and last recorded position '..repru(oExperimental[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; iExperimentalPlateau='..(iExperimentalPlateau or 'nil')..'; iExperimentalZone='..(iExperimentalZone or 'nil'))

                end
            end
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            local tGunshipsNearFront = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryGunship, oFrontGunship:GetPosition(), 50, 'Ally')
            LOG(sFunctionRef..': Threat of gunships within 50 of front gunship='..M28UnitInfo.GetAirThreatLevel(tGunshipsNearFront, false, false, false, true, false, false)..'; iOurGunshipThreat='..iOurGunshipThreat)
        end

        local iMaxEnemyAirAA --Amount of enemy airaa threat required to make gunships to target enemies nearby
        local iDistToSupport = M28Utilities.GetDistanceBetweenPositions(oFrontGunship:GetPosition(), M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint])
        if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir] then
            iMaxEnemyAirAA = math.min(2000, math.max(iOurGunshipAA * 0.2, iOurGunshipThreat * 0.03))
        else
            --Is the air support location nearby?
            if iDistToSupport <= 160 then
                if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] then
                    iMaxEnemyAirAA = math.min(10000, math.max(iOurGunshipThreat * 0.2, iOurGunshipAA * 0.7))
                else
                    iMaxEnemyAirAA = math.min(8000,  math.max(iOurGunshipThreat * 0.075, iOurGunshipAA * 0.6))
                end
            else
                if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] then
                    iMaxEnemyAirAA = math.min(8000,  math.max(iOurGunshipThreat * 0.075, iOurGunshipAA * 0.6))
                else
                    iMaxEnemyAirAA = math.min(5000,  math.max(iOurGunshipThreat * 0.04, iOurGunshipAA * 0.4))
                end
            end
        end
        if M28Map.bIsCampaignMap then
            iMaxEnemyAirAA = math.max(iMaxEnemyAirAA, M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] * 0.5, iOurGunshipAA * 0.8)
            if M28Team.tTeamData[iTeam][M28Team.refbDontHaveBuildingsOrACUInPlayableArea] then iMaxEnemyAirAA = 100000 end
        end

        local bDontLookForMoreTargets = false
        local bDontCheckForPacifism = not(M28Overseer.bPacifistModeActive)
        local tNewlyAddedEnemies

        local bConsiderAttackingEnemyGunships = false
        if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 100 and iOurGunshipThreat >= 400 then
            --Consider if enemy has experimental gunships or we have a greater gunship threat than their air to ground threat
            if iOurGunshipThreat > M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] then
                bConsiderAttackingEnemyGunships = true
            elseif M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryGunship * categories.CYBRAN * categories.EXPERIMENTAL, M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround])) == false then
                bConsiderAttackingEnemyGunships = true
            end
        end


        if bDebugMessages == true then
            LOG(sFunctionRef..': About to look for targets for g unships, iMaxEnemyAirAA='..iMaxEnemyAirAA..'; iDistToSupport='..M28Utilities.GetDistanceBetweenPositions(oFrontGunship:GetPosition(), M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint])..'; iOurGunshipThreat='..iOurGunshipThreat..'; HaveAirControl='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl])..'; Far behind on air='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir])..'; bConsiderAttackingEnemyGunships='..tostring(bConsiderAttackingEnemyGunships)..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; Is table of enemy air to ground empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround])))
            --List out any soulrippers
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround]) == false then
                local tEnemySoulrippers = EntityCategoryFilterDown(M28UnitInfo.refCategoryGunship * categories.CYBRAN * categories.EXPERIMENTAL, M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround])
                if M28Utilities.IsTableEmpty(tEnemySoulrippers) == false then
                    for iUnit, oUnit in tEnemySoulrippers do
                        local iCurExpPlat, iCurExpZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                        LOG(sFunctionRef..': Enemy soulripper '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' reftAssignedPlateauAndLandZoneByTeam='..repru(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam])..'; WZ='..repru(oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam])..'; iCurExpPlat='..(iCurExpPlat or 'nil')..'; iCurExpZone='..(iCurExpZone or 'nil')..'; Soulripper airaa threat='..M28UnitInfo.GetAirThreatLevel({ oUnit }, true, true, true, false, false, false))
                    end
                end
            end
        end
        function AddUnitToTargetsTable(oUnit, bNotCheckedValid)
            if not(bNotCheckedValid) or (M28UnitInfo.IsUnitValid(oUnit) and not(oUnit:IsUnitState('Attached')) and not(M28UnitInfo.IsUnitUnderwater(oUnit))) then
                table.insert(tEnemyGroundOrGunshipTargets, oUnit)
                table.insert(tNewlyAddedEnemies, oUnit)
            end
        end
        function AddEnemyGroundUnitsToTargetsSubjectToAA(iPlateauOrZero, iLandOrWaterZone, iGunshipThreatFactorWanted, bCheckForAirAA, bOnlyIncludeIfMexToProtect, iGroundAAThresholdAdjust, bIgnoreMidpointPlayableCheck, bDetailedAACheckOverride)
            --Campaign specific-  check this is within the playable area first
            tNewlyAddedEnemies = {}
            local iSpecificAirAAThreatLimit
            if not(bCheckForAirAA) then iSpecificAirAAThreatLimit = -1
            else iSpecificAirAAThreatLimit = iMaxEnemyAirAA
            end
            local tLZOrWZData
            local tLZOrWZTeamData
            if iPlateauOrZero > 0 then
                --Land zone
                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]

            else
                --Water zone
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
            end

            --Think we already take into account gorundAA in the main function, so this is effectively doubling up, hence why modifiers arent too high
            if tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.25 then
                iSpecificAirAAThreatLimit = math.max(0, iSpecificAirAAThreatLimit - (tLZOrWZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0) * 3.5)
            elseif tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.4 then
                iSpecificAirAAThreatLimit = math.max(0, iSpecificAirAAThreatLimit - (tLZOrWZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0) * 1.5)
            elseif tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.55 then
                iSpecificAirAAThreatLimit = math.max(0, iSpecificAirAAThreatLimit - (tLZOrWZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0) * 0.5)
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Is midpoint in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tLZOrWZData[M28Map.subrefMidpoint]))..'; bIgnoreMidpointPlayableCheck='..tostring(bIgnoreMidpointPlayableCheck or false)..'; tLZOrWZTeamData[M28Map.subrefLZThreatAllyGroundAA]='..(tLZOrWZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 'nil')) end
            if not(M28Map.bIsCampaignMap) or ((bIgnoreMidpointPlayableCheck or (M28Conditions.IsLocationInPlayableArea(tLZOrWZData[M28Map.subrefMidpoint]))) and (bDontCheckForPacifism or not(tLZOrWZData[M28Map.subrefbPacifistArea]))) then
                function IsHighValueZoneToProtect()
                    if (tLZOrWZTeamData[M28Map.subrefLZSValue] or 0) >= 2000 or (tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] or 0) > 0 or (tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] or 0) > 0 then
                        return true
                    else
                        return false
                    end
                end
                if bDebugMessages == true then LOG('AddEnemyGroundUnitsToTargetsSubjectToAA: Deciding whether to add units for land zone '..iLandOrWaterZone..' plateau '..iPlateauOrZero..'; bOnlyIncludeIfMexToProtect='..tostring(bOnlyIncludeIfMexToProtect)..'; IsHighValueZoneToProtect='..tostring(IsHighValueZoneToProtect())..'; Enemy combat threat in zone if LZ='..(tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)..'; Mobile DF total if LZ='..(tLZOrWZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)..'; Enemy AA total if LZ='..(tLZOrWZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0)..'; tLZOrWZTeamData[M28Map.refiModDistancePercent]='..tLZOrWZTeamData[M28Map.refiModDistancePercent]..'; bConsiderAttackingEnemyGunships='..tostring(bConsiderAttackingEnemyGunships)..'; tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat]='..(tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0)) end
                if not(bOnlyIncludeIfMexToProtect) or IsHighValueZoneToProtect() then
                    local bDoDetailedGroundAACheck = bDetailedAACheckOverride
                    if IsHighValueZoneToProtect() then
                        if (tLZOrWZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) <= 200 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] then iGunshipThreatFactorWanted = math.min(iGunshipThreatFactorWanted, math.max(iGunshipThreatFactorWanted * 0.5, 1.5))
                        else iGunshipThreatFactorWanted = math.min(iGunshipThreatFactorWanted, math.max(iGunshipThreatFactorWanted * 0.8, 1.8))
                        end
                        bDoDetailedGroundAACheck = true
                    elseif tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.35 and bConsiderAttackingEnemyGunships and (tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) >= 500 then
                        bDoDetailedGroundAACheck = true
                    end

                    local iMaxEnemyGroundAA
                    if iGunshipThreatFactorWanted == 0 then
                        iMaxEnemyGroundAA = -1 --   -1 is used to denote infinite in this case
                    else
                        iMaxEnemyGroundAA = iOurGunshipThreat / iGunshipThreatFactorWanted
                    end
                    --Adjust ground AA if we have T2 or T3 mexes or high structure value here (subject to an overall cap)
                    if iGunshipThreatFactorWanted > 2.5 and (tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] or 0) > 0 or (tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] or 0) > 0 or (tLZOrWZTeamData[M28Map.subrefLZSValue] or 0) >= 1000 then
                        iMaxEnemyGroundAA = math.max(iMaxEnemyGroundAA, math.min(iMaxEnemyGroundAA * 1.5, iOurGunshipThreat / 2.5), iOurGunshipThreat / 4.5)

                    end
                    if iGroundAAThresholdAdjust and iMaxEnemyGroundAA >= 0 then iMaxEnemyGroundAA = math.max(0, iMaxEnemyGroundAA + iGroundAAThresholdAdjust) end

                    --Check if enemy has enough AA nearby
                    local bTooMuchAA
                    if not (bCheckForAirAA) and iMaxEnemyGroundAA <= 0 then
                        bTooMuchAA = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy doesnt have any groundAA and we arent checking for AirAA') end
                    else
                        --DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iEndPlateauOrZero, iEndLandOrWaterZone, bIgnoreAirAAThreat,         iGroundAAThreatThreshold, iAirAAThreatThreshold, bUsingTorpBombers, iAirSubteam, bDoDetailedCheckForAA)
                        bTooMuchAA = DoesEnemyHaveAAThreatAlongPath(iTeam, iGunshipPlateauOrZero, iGunshipLandOrWaterZone, iPlateauOrZero, iLandOrWaterZone, not(bCheckForAirAA), iMaxEnemyGroundAA, iSpecificAirAAThreatLimit, false, iAirSubteam, bDoDetailedGroundAACheck)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering zone '..iLandOrWaterZone..'; iPlateauOrZero='..iPlateauOrZero..'; bTooMuchAA='..tostring(bTooMuchAA)..'; bCheckForAirAA='..tostring(bCheckForAirAA or false)..'; iMaxEnemyGroundAA='..(iMaxEnemyGroundAA or 'nil')..'; iSpecificAirAAThreatLimit='..iSpecificAirAAThreatLimit..'; iOurGunshipThreat='..iOurGunshipThreat..'; iGunshipThreatFactorWanted='..iGunshipThreatFactorWanted..'; bDoDetailedGroundAACheck='..tostring(bDoDetailedGroundAACheck)) end

                    if not (bTooMuchAA) then
                        --Add enemy air units in the plateau/land zone to list of enemy unit targets
                        if bDebugMessages == true then LOG(sFunctionRef..': We want to target this zone if it has enemy units in it, Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]))..'; Is table of enemy air units empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftLZEnemyAirUnits]))) end
                        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                            local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
                            local bReplaceOnFirstValidUnit = bOnlyIncludeIfMexToProtect

                            for iUnit, oUnit in tLZOrWZTeamData[M28Map.subrefTEnemyUnits] do
                                --Ignore land scouts - both because they are low threat, and also because in the case of selens they might be cloaked
                                if M28UnitInfo.IsUnitValid(oUnit) and EntityCategoryContains(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategoryMobileLand - M28UnitInfo.refCategoryLandScout, oUnit.UnitId) and not (M28UnitInfo.IsUnitUnderwater(oUnit)) and (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(oUnit:GetPosition())) and not(oUnit:IsUnitState('Attached')) then
                                    if bReplaceOnFirstValidUnit then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to replace first valid unit as bOnlyIncludeIfMexToProtect is true, PlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; SValue='..tLZOrWZTeamData[M28Map.subrefLZSValue]..'; Is high value zone='..tostring(IsHighValueZoneToProtect())) end
                                        tEnemyGroundOrGunshipTargets = {}
                                        bReplaceOnFirstValidUnit = false
                                        bDontLookForMoreTargets = true
                                    end
                                    AddUnitToTargetsTable(oUnit)

                                end
                            end
                        end
                        --Consider adding enemy cybran experimentals or gunships
                        if bConsiderAttackingEnemyGunships and tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftLZEnemyAirUnits]) == false then
                                local tEnemyGunships = EntityCategoryFilterDown(M28UnitInfo.refCategoryGunship, tLZOrWZTeamData[M28Map.reftLZEnemyAirUnits])
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy gunships empty='..tostring(M28Utilities.IsTableEmpty(tEnemyGunships))) end
                                if M28Utilities.IsTableEmpty(tEnemyGunships) == false then
                                    if tLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] * 1.25 < iOurGunshipThreat or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.EXPERIMENTAL * categories.CYBRAN, tEnemyGunships)) == false then
                                        for iUnit, oUnit in  tEnemyGunships do
                                            if M28UnitInfo.IsUnitValid(oUnit) and not(oUnit:IsUnitState('Attached')) then
                                                AddUnitToTargetsTable(oUnit)
                                            end
                                        end
                                    elseif bDebugMessages == true then LOG(sFunctionRef..': we dont have significantly more gunship threat so dont want to attack gunships with our own')
                                    end
                                end
                            end
                        end

                    elseif bDebugMessages == true then LOG(sFunctionRef..': Too much AA so wont try and target this zone')
                    end
                    if not(bOnlyIncludeIfMexToProtect) and M28Utilities.IsTableEmpty(tEnemyGroundOrGunshipTargets) == false and IsHighValueZoneToProtect() then
                        bDontLookForMoreTargets = true
                    end
                end
            end
        end

        local iCurPlateauOrZero, iCurLZOrWZ

        --Retreat if ahwassa bomb exploded near front gunship
        local bRetreatFromAhwassa = false
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to retreat from Ahwassa targets, tiRecentExpBomberTargets='..repru(tiRecentExpBomberTargets)) end
        if oFrontGunship and M28Utilities.IsTableEmpty(tiRecentExpBomberTargets) == false then
            local iDistanceThreshold = 55 + math.min(20, table.getn(tAvailableGunships) * 0.25)
            for iTarget, tTarget in tiRecentExpBomberTargets do
                if bDebugMessages == true then LOG(sFunctionRef..': Dist between front gunship and ahwassa target='..M28Utilities.GetDistanceBetweenPositions(oFrontGunship:GetPosition(), tTarget)..'; iDistanceThreshold='..iDistanceThreshold) end
                if M28Utilities.GetDistanceBetweenPositions(oFrontGunship:GetPosition(), tTarget) <= iDistanceThreshold then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to retreat from ahwassa target, tTarget='..repru(tTarget)..'; Dist to front gunship='..M28Utilities.GetDistanceBetweenPositions(oFrontGunship:GetPosition(), tTarget)) end
                    bRetreatFromAhwassa = true
                    break
                end
            end
        end
        --Snipe target
        local bUsingSnipePriority = false
        local iClosestSnipeTarget = 100000
        if not(bRetreatFromAhwassa) and M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets]) then
            local iAvailableGunshipThreat = M28UnitInfo.GetAirThreatLevel(tAvailableGunships, false, false, false, true)
            if not(tNewlyAddedEnemies) then tNewlyAddedEnemies = {} end
            for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.toActiveSnipeTargets] do
                local iTargetPlateauOrZero, iTargetLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                local tbPlateauAndZoneAdded = {}
                if (iTargetPlateauOrZero or 0) > 0 and (iTargetLZOrWZ or 0) > 0 then
                    if not(tbPlateauAndZoneAdded[iTargetPlateauOrZero]) then tbPlateauAndZoneAdded[iTargetPlateauOrZero] = {} end
                    if not(tbPlateauAndZoneAdded[iTargetPlateauOrZero][iTargetLZOrWZ]) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy snipe target '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Will add all enemy ground units in P'..iTargetPlateauOrZero..'Z'..iTargetLZOrWZ..'; Unit health='..oUnit:GetHealth()..'; iAvailableGunshipThreat='..iAvailableGunshipThreat) end
                        local iAvailableGunshipThreat = M28UnitInfo.GetAirThreatLevel(tAvailableGunships, false, false, false, true)
                        if oUnit:GetHealth() < iOurGunshipThreat then
                            --Just add the ACU as a target
                            if bDebugMessages == true then LOG(sFunctionRef..': Will just add the enemy ACU as a snipe target') end
                            AddUnitToTargetsTable(oUnit, true)
                        else
                            tbPlateauAndZoneAdded[iTargetPlateauOrZero][iTargetLZOrWZ] = true
                            AddEnemyGroundUnitsToTargetsSubjectToAA(iTargetPlateauOrZero, iTargetLZOrWZ, 0, false, nil,nil,true)
                        end

                        iClosestSnipeTarget = math.min(iClosestSnipeTarget, M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oFrontGunship:GetPosition()))
                    end
                end
            end
            --Make sure gunships will prioritise enemy ACU
            bUsingSnipePriority = true
        end

        --Emergency response - first include any ground threats in a core zone and (if none) adjacent to a core zone (v92 and earlier - used start positions instead)
        if not(iClosestSnipeTarget) or iClosestSnipeTarget >= 200 then
            local tiFriendlyStartPositionPlateauAndZones = {}
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau]) == false then
                for iPlateau, tZones in M28Team.tTeamData[iTeam][M28Team.reftiCoreZonesByPlateau] do
                    for iEntry, iZone in tZones do
                        table.insert(tiFriendlyStartPositionPlateauAndZones, {iPlateau, iZone})
                    end
                end
            else
                M28Utilities.ErrorHandler('Dont have any core zones so will revert to player start points')
                --Old code - left in as redundancy
                for iBrain, oBrain in M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains] do
                    local tStartPoint = M28Map.GetPlayerStartPosition(oBrain)
                    iCurPlateauOrZero, iCurLZOrWZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tStartPoint)
                    if (iCurPlateauOrZero or 0) > 0 then
                        if (iCurLZOrWZ or 0) == 0 then
                            iCurLZOrWZ = M28Map.GetWaterZoneFromPosition(tStartPoint)
                            if (iCurLZOrWZ or 0) > 0 then
                                iCurPlateauOrZero = 0
                            end
                        end
                    end
                    if (iCurLZOrWZ or 0) > 0 then
                        if not(iClosestSnipeTarget) or M28Utilities.GetDistanceBetweenPositions(tStartPoint, oFrontGunship:GetPosition()) < iClosestSnipeTarget + 25 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will be soon checking for enemies in the start position for friendly brain '..oBrain.Nickname..' in iCurLZOrWZ='..iCurLZOrWZ..'; iCurPlateauOrZero='..iCurPlateauOrZero) end
                            table.insert(tiFriendlyStartPositionPlateauAndZones, {iCurPlateauOrZero, iCurLZOrWZ})
                            --AddEnemyGroundUnitsToTargetsSubjectToAA(iPlateauOrZero, iLandOrWaterZone, iGunshipThreatFactorWanted, bCheckForAirAA, bOnlyIncludeIfMexToProtect, iGroundAAThresholdAdjust, bIgnoreMidpointPlayableCheck)
                            AddEnemyGroundUnitsToTargetsSubjectToAA(iCurPlateauOrZero, iCurLZOrWZ, 0, false, nil,nil,true)
                        end
                    end
                end
            end


            local bAlwaysInclAdjToStart = M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl]
            if not(bAlwaysInclAdjToStart) and (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] or 0) < iOurGunshipThreat * 0.1 then bAlwaysInclAdjToStart = true end
            if M28Utilities.IsTableEmpty(tiFriendlyStartPositionPlateauAndZones) == false and (not(iClosestSnipeTarget) or iClosestSnipeTarget >= 400) then
                for iEntry, tiPlateauAndZone in tiFriendlyStartPositionPlateauAndZones do
                    --AddEnemyGroundUnitsToTargetsSubjectToAA(iPlateauOrZero, iLandOrWaterZone, iGunshipThreatFactorWanted, bCheckForAirAA, bOnlyIncludeIfMexToProtect, iGroundAAThresholdAdjust, bIgnoreMidpointPlayableCheck)
                    AddEnemyGroundUnitsToTargetsSubjectToAA(tiPlateauAndZone[1], tiPlateauAndZone[2], 0, false, nil, nil, true)
                end
                if M28Utilities.IsTableEmpty(tEnemyGroundOrGunshipTargets) then
                    --Consider land zones adjacent to a land start position provided the zone midpoint is within 25% of the closest base (since we aren't doing an AirAA check), and the enemy doesnt have a large airaa force near us
                    for iEntry, tiPlateauAndZone in tiFriendlyStartPositionPlateauAndZones do
                        if tiPlateauAndZone[1] > 0 then
                            local tLZData = M28Map.tAllPlateaus[tiPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tiPlateauAndZone[2]]
                            if not(bRetreatFromAhwassa) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false and iEnemyAirAAThreatNearGunship < math.min(iOurGunshipThreat * 0.25, iMaxEnemyAirAA) then
                                local iCurDistToBase
                                for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do

                                    --Land zone
                                    local tAdjLZData = M28Map.tAllPlateaus[tiPlateauAndZone[1]][M28Map.subrefPlateauLandZones][iAdjLZ]
                                    local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                                    if tAdjLZTeamData[M28Map.refiModDistancePercent] <= 0.5 then
                                        iCurDistToBase = M28Utilities.GetDistanceBetweenPositions(tAdjLZTeamData[M28Map.reftClosestFriendlyBase], tAdjLZData[M28Map.subrefMidpoint])
                                        if bAlwaysInclAdjToStart or tAdjLZTeamData[M28Map.refiModDistancePercent] <= 0.1 or iCurDistToBase <= 220 then
                                            --Check actual % dist to base
                                            if bAlwaysInclAdjToStart or tAdjLZTeamData[M28Map.refiModDistancePercent] <= 0.1 or iCurDistToBase <= 100 or iCurDistToBase / M28Utilities.GetDistanceBetweenPositions(tAdjLZTeamData[M28Map.reftClosestFriendlyBase], tAdjLZTeamData[M28Map.reftClosestEnemyBase]) <= 0.275 then
                                                AddEnemyGroundUnitsToTargetsSubjectToAA(tiPlateauAndZone[1], iAdjLZ, 3, false)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of enem ytargets empty after checking iAdjLZ='..iAdjLZ..'='..tostring(M28Utilities.IsTableEmpty(tEnemyGroundOrGunshipTargets))..'; iCurDistToBase='..iCurDistToBase..'; % of dist from friendl yto enemy='..iCurDistToBase / M28Utilities.GetDistanceBetweenPositions(tAdjLZTeamData[M28Map.reftClosestFriendlyBase], tAdjLZTeamData[M28Map.reftClosestEnemyBase])..'; Mod dist%='..tAdjLZTeamData[M28Map.refiModDistancePercent]..'; bAlwaysInclAdjToStart='..tostring(bAlwaysInclAdjToStart or false)) end
                                            elseif bDebugMessages == true then LOG(sFunctionRef..': Actual % is too far, iCurDistToBase='..iCurDistToBase..'; tAdjLZTeamData[M28Map.refiModDistancePercent]='..tAdjLZTeamData[M28Map.refiModDistancePercent]..'; Actual %='..iCurDistToBase / M28Utilities.GetDistanceBetweenPositions(tAdjLZTeamData[M28Map.reftClosestFriendlyBase], tAdjLZTeamData[M28Map.reftClosestEnemyBase]))
                                            end
                                        elseif bDebugMessages == true then LOG(sFunctionRef..': Midpoint is too far away, iCurDistToBase='..iCurDistToBase)
                                        end
                                    elseif bDebugMessages == true then LOG(sFunctionRef..': Wont consider iAdjLZ='..iAdjLZ..' as a high priority since tAdjLZTeamData[M28Map.refiModDistancePercent]='..tAdjLZTeamData[M28Map.refiModDistancePercent])
                                    end
                                end
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for enemies in LZ adjacent to core zone, is table of enemy targets empty='..tostring(M28Utilities.IsTableEmpty(tEnemyGroundOrGunshipTargets))..'; if empty then will move on to Checking if too great an enemy threat in zone ghunships are in now (or adjacent to it), IsThereAANearLandOrWaterZone='..tostring(IsThereAANearLandOrWaterZone(iTeam, iGunshipPlateauOrZero, iGunshipLandOrWaterZone, (iGunshipPlateauOrZero == 0), iOurGunshipThreat / 3, iMaxEnemyAirAA))) end
            end
        end

        local bConsiderIgnoringEnemiesInLowValueZones = false --if set to true then will look for more zones in case there is a high value wone we can target
        if not(bRetreatFromAhwassa) and (not(iClosestSnipeTarget) or iClosestSnipeTarget >= 400) then
            --if M28Utilities.IsTableEmpty(tEnemyGroundOrGunshipTargets) then
            --Consider enemy experimental near start position
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then

                local tNearestBase = tGunshipLandOrWaterZoneTeamData[M28Map.reftClosestFriendlyBase]
                local oNearestExperimental
                local iCurDist
                local iClosestDist = 100000
                if M28Utilities.IsTableEmpty(tEnemyGroundOrGunshipTargets) == false then iClosestDist = 100 end
                for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
                    if M28UnitInfo.IsUnitValid(oUnit) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(tNearestBase, oUnit:GetPosition())
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy Exp '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..iCurDist..'; iClosestDist='..iClosestDist) end
                        if iCurDist < iClosestDist then
                            iClosestDist = iCurDist
                            oNearestExperimental = oUnit
                        end
                    end
                end
                if oNearestExperimental and iClosestDist <= 190 then
                    local bCheckForAirAA = true
                    local iThreatFactor = 3.5
                    if iClosestDist <= 130 then
                        bCheckForAirAA = false
                        iThreatFactor = 2
                    end
                    local iTargetPlateau, iTargetZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oNearestExperimental:GetPosition())
                    if (iTargetZone or 0) > 0 then
                        local iGroundAAThreatAdjust = 0
                        if iOurGunshipThreat >= 600 then
                            --Reduce by AA of experimental, i.e. dont want to avoid engaging a ythotha just because of the ythotha AA
                            iGroundAAThreatAdjust = M28UnitInfo.GetAirThreatLevel({ oNearestExperimental }, true, false, true, false, false, false, false) * 0.75
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Will consider adding zone containing the closest experimental, oNearestExperimental='..oNearestExperimental.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestExperimental)..'; iGroundAAThreatAdjust='..iGroundAAThreatAdjust..'; iTargetPlateau='..iTargetPlateau..'; iTargetZone='..iTargetZone) end
                        --AddEnemyGroundUnitsToTargetsSubjectToAA(iPlateauOrZero, iLandOrWaterZone, iGunshipThreatFactorWanted, bCheckForAirAA, bOnlyIncludeIfMexToProtect, iGroundAAThresholdAdjust, bIgnoreMidpointPlayableCheck, bDetailedAACheckOverride)
                        AddEnemyGroundUnitsToTargetsSubjectToAA(iTargetPlateau, iTargetZone, iThreatFactor, bCheckForAirAA, nil, iGroundAAThreatAdjust, nil, true)
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished considering if have appraoching land experimental, oNearestExperimental='..(oNearestExperimental.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestExperimental) or 'nil')..'; iClosestDist='..iClosestDist..'; Is table of enemy targets empty='..tostring(M28Utilities.IsTableEmpty(tEnemyGroundOrGunshipTargets))) end
            end
            if M28Utilities.IsTableEmpty(tEnemyGroundOrGunshipTargets) then
                --Protect ACU if down to last ACU on the team and ACU may be in trouble
                if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] == 1 then
                    local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                    local tACUs = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
                    if M28Utilities.IsTableEmpty(tACUs) == false then
                        for iACU, oACU in tACUs do
                            local iCurACUHealthPercent = M28UnitInfo.GetUnitHealthPercent(oACU)
                            if iCurACUHealthPercent < 0.95 then
                                local iCurACUPlateauOrZero, iCurACUZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oACU:GetPosition())
                                if (iCurACUPlateauOrZero or 0) > 0 then
                                    local tACULZData = M28Map.tAllPlateaus[iCurACUPlateauOrZero][M28Map.subrefPlateauLandZones][iCurACUZone]
                                    local tACULZTeamData = tACULZData[M28Map.subrefLZTeamData][iTeam]
                                    if not(tACULZTeamData[M28Map.subrefLZbCoreBase]) and tACULZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 300 then
                                        if (iCurACUHealthPercent <= 0.7 or tACULZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 1000) and (iCurACUHealthPercent <= 0.5 or tACULZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] < tACULZTeamData[M28Map.subrefTThreatEnemyCombatTotal]) then
                                            --Wnat to defend ACU
                                            --AddEnemyGroundUnitsToTargetsSubjectToAA(iPlateauOrZero, iLandOrWaterZone, iGunshipThreatFactorWanted, bCheckForAirAA, bOnlyIncludeIfMexToProtect, iGroundAAThresholdAdjust, bIgnoreMidpointPlayableCheck)
                                            AddEnemyGroundUnitsToTargetsSubjectToAA(iCurACUPlateauOrZero, iCurACUZone, 0.5 + iCurACUHealthPercent, false, false, nil, true)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Want to defend ACU from enemy units') end

                                        end
                                    end
                                end
                            end
                        end
                    end
                end

                --Check if want gunships to run to rally point if nearby enemy airAA (if give no targets for gunships then they will go to rally point or air staging), or if we have very weak AirAA
                local iGunshipThreatFactorWanted = 1.725
                if M28Map.bIsCampaignMap then
                    iGunshipThreatFactorWanted = 1.6
                    if M28Team.tTeamData[iTeam][M28Team.refbDontHaveBuildingsOrACUInPlayableArea] then iGunshipThreatFactorWanted = 0.01 end
                end

                local bCheckForAirAA = true
                local iDistToStartCheckingForAirAA = 0
                if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] and (M28Map.bIsCampaignMap or M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat] >= 10000) then
                    bCheckForAirAA = false
                    if not(M28Map.bIsCampaignMap) then
                        iDistToStartCheckingForAirAA = 225
                        if M28Team.tTeamData[iTeam][M28Team.refbDontHaveBuildingsOrACUInPlayableArea] then iDistToStartCheckingForAirAA = 1000 end
                    else iDistToStartCheckingForAirAA = 500
                    end
                end

                local bMidpointPlayableOverride = M28Map.bIsCampaignMap

                --Is there a vulnerable fatboy nearby?
                if M28Team.tTeamData[iTeam][M28Team.reftoVulnerableFatboys] and M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftoVulnerableFatboys]) then
                    local iClosestFatboy = 300
                    local iCurFatboyDist
                    local oClosestFatboy
                    for iFatboy, oFatboy in M28Team.tTeamData[iTeam][M28Team.reftoVulnerableFatboys] do
                        if not(M28UnitInfo.IsUnitUnderwater(oFatboy)) then
                            iCurFatboyDist = M28Utilities.GetDistanceBetweenPositions(oFatboy:GetPosition(), oFrontGunship:GetPosition())
                            if iCurFatboyDist < iClosestFatboy then
                                oClosestFatboy = oFatboy
                                iClosestFatboy = iCurFatboyDist
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering priority enemy fatboy as gunship target. oClosestFatboy='..(oClosestFatboy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestFatboy) or 'nil')..'; iClosestFatboy='..iClosestFatboy) end
                    if oClosestFatboy then
                        local iCurFatboyPlateau, iCurFatboyZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oClosestFatboy:GetPosition())
                        if iCurFatboyPlateau and iCurFatboyZone then
                            --AddEnemyGroundUnitsToTargetsSubjectToAA(iPlateauOrZero, iLandOrWaterZone, iGunshipThreatFactorWanted, bCheckForAirAA, bOnlyIncludeIfMexToProtect, iGroundAAThresholdAdjust, bIgnoreMidpointPlayableCheck)
                            AddEnemyGroundUnitsToTargetsSubjectToAA(iCurFatboyPlateau, iCurFatboyZone, iGunshipThreatFactorWanted * (1 + 0.3 * iClosestFatboy / 300), bCheckForAirAA, false, nil, bMidpointPlayableOverride)
                            if bDebugMessages == true then LOG(sFunctionRef..': Finished considering whether to add units in the zone with the fatboy as targets, gunship factor expected to be the threshold='..iGunshipThreatFactorWanted * (1 + 0.3 * iClosestFatboy / 300)) end
                        end
                    end
                end

                --Telesnipe defence - if no targets yet and enemy has queued up a snipe attempt, then have gunships move there
                if M28Utilities.IsTableEmpty(tEnemyGroundOrGunshipTargets) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftRecentEnemyTeleportDetails]) == false and oFrontGunship then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want gunships to prevent a snipe attempt if it isnt too far away') end
                    local iClosestTeleportDist = 500 --If assume a teleport allows about 45s for the unit to teleport there then teleport away (will vary following FAF update), and gunships move at 10 per sec, then if we only consider telesnipe locations within 500 it should cover cases where the gunships are close enough to feasibly help
                    local iCurTeleportDist
                    for iTeleportEntry, tTeleportDetails in M28Team.tTeamData[iTeam][M28Team.reftRecentEnemyTeleportDetails] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering teleport entry for the location '..repru(tTeleportDetails[M28Team.subreftTeleportTarget])..'; Dist to front gunship='..M28Utilities.GetDistanceBetweenPositions(oFrontGunship:GetPosition(), tTeleportDetails[M28Team.subreftTeleportTarget])) end
                        if tTeleportDetails[M28Team.subreftTeleportTarget][2] >= M28Map.iMapWaterHeight - 1 then --dont want to try and target ACUs significantly underwater
                            iCurTeleportDist = M28Utilities.GetDistanceBetweenPositions(oFrontGunship:GetPosition(), tTeleportDetails[M28Team.subreftTeleportTarget])
                            if iCurTeleportDist < iClosestTeleportDist then
                                --Is the target locatin one we want to preemptively defend?
                                local tTeleportLZData, tTeleportLZTeamData = M28Map.GetLandOrWaterZoneData(tTeleportDetails[M28Team.subreftTeleportTarget], true, iTeam)
                                if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to defend the location, SValue='..tTeleportLZTeamData[M28Map.subrefLZSValue]..'; Core base='..tostring(tTeleportLZTeamData[M28Map.subrefLZbCoreBase])..'; Table of allied acus empty?='..tostring(M28Utilities.IsTableEmpty(tTeleportLZTeamData[M28Map.subrefAlliedACU]))..'; Mod dist%='..tTeleportLZTeamData[M28Map.refiModDistancePercent]..'; Enemy groundAA='..tTeleportLZTeamData[M28Map.subrefLZThreatEnemyGroundAA]) end
                                if tTeleportLZTeamData[M28Map.subrefLZSValue] >= 3000 or tTeleportLZTeamData[M28Map.subrefLZbCoreBase] or M28Utilities.IsTableEmpty(tTeleportLZTeamData[M28Map.subrefAlliedACU]) == false or (tTeleportLZTeamData[M28Map.refiModDistancePercent] < 0.4 and tTeleportLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] == 0 and (tTeleportLZTeamData[M28Map.refiModDistancePercent] < 0.15 or (tTeleportLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0) > 1000)) then
                                    iClosestTeleportDist = iCurTeleportDist
                                    tTeleportTargetToMoveTo = {tTeleportDetails[M28Team.subreftTeleportTarget][1], tTeleportDetails[M28Team.subreftTeleportTarget][2], tTeleportDetails[M28Team.subreftTeleportTarget][3]}
                                    if bDebugMessages == true then LOG(sFunctionRef..': recording as a preemptive teleport location target') end
                                end
                            end
                        end
                    end
                end
                if not(tTeleportTargetToMoveTo) then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to check if shoudl run due to high AA near where gunships are, Is there AA near gunship P'..iGunshipPlateauOrZero..'; Z'..iGunshipLandOrWaterZone..'; iMaxEnemyAirAA='..iMaxEnemyAirAA..'; iOurGunshipThreat='..iOurGunshipThreat..'; Is there too much AA='..tostring(IsThereAANearLandOrWaterZone(iTeam, iGunshipPlateauOrZero, iGunshipLandOrWaterZone, (iGunshipPlateauOrZero == 0), iOurGunshipThreat / iGunshipThreatFactorWanted, iMaxEnemyAirAA))) end
                    --IsThereAANearLandOrWaterZone(iTeam, iPlateau,             iLandOrWaterZone,       bIsWaterZone,                               iOptionalGroundThreatThreshold, iOptionalAirAAThreatThreshold, iOptionalMaxDistToEdgeOfAdjacentZone, tOptionalStartPointForEdgeOfAdacentZone)
                    local iSearchDistance = 60
                    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] < 3 or (M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] and iDistToSupport <= 100) then iSearchDistance = 40 end
                    if not(IsThereAANearLandOrWaterZone(iTeam, iGunshipPlateauOrZero, iGunshipLandOrWaterZone, (iGunshipPlateauOrZero == 0), iOurGunshipThreat / math.min(2, iGunshipThreatFactorWanted), iMaxEnemyAirAA                  , iSearchDistance,                               oFrontGunship:GetPosition())) then
                        --no nearby enemy air threat so can just evaluate each land zone or water zone on its own merits - cycle through each in order of distance, but first consider adjacent locations

                        --First consider the land/water zone the gunship is in at the moment
                        --AddEnemyGroundUnitsToTargetsSubjectToAA(iPlateauOrZero, iLandOrWaterZone, iGunshipThreatFactorWanted, bCheckForAirAA, bOnlyIncludeIfMexToProtect, iGroundAAThresholdAdjust, bIgnoreMidpointPlayableCheck)
                        AddEnemyGroundUnitsToTargetsSubjectToAA(iGunshipPlateauOrZero, iGunshipLandOrWaterZone, iGunshipThreatFactorWanted, false, nil, nil, true) --dont check for airaa since we already checked above

                        if bDebugMessages == true then LOG(sFunctionRef..': Is tEnemyGroundOrGunshipTargets empty after considering enemies in the same LZ/WZ as gunship='..tostring(M28Utilities.IsTableEmpty(tEnemyGroundOrGunshipTargets))) end
                        if M28Utilities.IsTableEmpty(tEnemyGroundOrGunshipTargets) then
                            --Is there groundAA in the current plateau/water zone (i.e. there are enemies but we have chosen not to attack due to the threat)?
                            if (tGunshipLandOrWaterZoneData[M28Map.subrefLZThreatEnemyGroundAA] or 0) > 0 or (tGunshipLandOrWaterZoneData[M28Map.subrefWZThreatEnemyAA] or 0) > 0 then
                                --Enemy has AA in the same LZ as our gunships and we dont want to attack enemies, so retreat
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy GroundAA threat exists in same zone as gunships and we have no targets so want to retreat') end
                            else
                                --If lack AirAA then only consider adjacent zones to the gunship, provided one of them has ground to air threat of at least 200
                                local bUseDefensively = false
                                local iMaxDefensiveRange = 50
                                if bDebugMessages == true then LOG(sFunctionRef..': COnsidering if we want to use gunships defnesively, our AA threat='..M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat]..'; iOurGunshipAA='..iOurGunshipAA..'; Enemy AirAA threat='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat]) end
                                if M28Team.tAirSubteamData[iAirSubteam][M28Team.subrefiOurAirAAThreat] + iOurGunshipAA < math.max(100, M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.7) then
                                    local iNearbyGroundToAirThreat = (tGunshipLandOrWaterZoneTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0) + (tGunshipLandOrWaterZoneTeamData[M28Map.subrefWZThreatAlliedAA] or 0)
                                    if M28Utilities.IsTableEmpty(tGunshipLandOrWaterZoneData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                                        for iEntry, tSubtable in tGunshipLandOrWaterZoneData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                                            if tSubtable[M28Map.subrefiDistance] <= 110 then
                                                iNearbyGroundToAirThreat = iNearbyGroundToAirThreat + 0.5 * (tGunshipLandOrWaterZoneTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0) + (tGunshipLandOrWaterZoneTeamData[M28Map.subrefWZThreatAlliedAA] or 0)
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': iNearbyGroundToAirThreat='..iNearbyGroundToAirThreat) end
                                    if iNearbyGroundToAirThreat < 200 then
                                        bUseDefensively = true
                                        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] < 3 then
                                            iMaxDefensiveRange = 150
                                        end
                                        if M28Utilities.GetDistanceBetweenPositions(tGunshipLandOrWaterZoneData[M28Map.subrefMidpoint], tGunshipLandOrWaterZoneTeamData[M28Map.reftClosestFriendlyBase]) >= 150 then iMaxDefensiveRange = math.min(50, iMaxDefensiveRange * 0.5) end
                                    end
                                end
                                if M28Team.tTeamData[iTeam][M28Team.refbDontHaveBuildingsOrACUInPlayableArea] then iMaxDefensiveRange = math.max(iMaxDefensiveRange, 1000) end

                                if bDebugMessages == true then LOG(sFunctionRef..': oFrontGunship='..oFrontGunship.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFrontGunship)..'; iGunshipPlateauOrZero='..(iGunshipPlateauOrZero or 'nil')..'; iGunshipLandOrWaterZone='..(iGunshipLandOrWaterZone or 'nil')..'; tGunshipMidpoint='..repru(tGunshipMidpoint)..'; bUseDefensively='..tostring(bUseDefensively)) end

                                RecordOtherLandAndWaterZonesByDistance(tGunshipLandOrWaterZoneData, tGunshipMidpoint)
                                if M28Utilities.IsTableEmpty(tGunshipLandOrWaterZoneData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                                    local iGunshipThreatFactorWanted
                                    local iPostFirstTargetCount = 0 --used so once we have a target we will still consider a few extra zones in case they are more important
                                    local iDistanceOfFirstTarget
                                    local iPostTargetMaxDistance = 80
                                    local iPostTargetMaxZoneCheck = 4
                                    local iLowValueZoneThreshold = math.min(4000, 0.1 * iOurGunshipThreat)
                                    local iHighestEnemyValueZone = 0

                                    for iEntry, tSubtable in tGunshipLandOrWaterZoneData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                                        --Once found a zone with targets, use that unless we have another zone where mex is under threat that we want to consider instaed
                                        if bUseDefensively and tSubtable[M28Map.subrefiDistance] > iMaxDefensiveRange then break end
                                        if iPostFirstTargetCount == 0 or (tSubtable[M28Map.subrefiDistance] <= iDistanceOfFirstTarget + iPostTargetMaxDistance and not(bDontLookForMoreTargets)) then
                                            if bMidpointPlayableOverride and tSubtable[M28Map.subrefiDistance] >= 120 then bMidpointPlayableOverride = false end
                                            if not(bCheckForAirAA) and tSubtable[M28Map.subrefiDistance] > iDistToStartCheckingForAirAA then bCheckForAirAA = true end
                                            if tSubtable[M28Map.subrefiDistance] <= 110 or M28Map.bIsCampaignMap then
                                                if tSubtable[M28Map.subrefiDistance] <= 70 then iGunshipThreatFactorWanted = 3
                                                else
                                                    iGunshipThreatFactorWanted = 3.5
                                                end
                                                if M28Map.bIsCampaignMap then --lower threshold for gunships to attack
                                                    if tSubtable[M28Map.subrefiDistance] <= 350 then iGunshipThreatFactorWanted = iGunshipThreatFactorWanted * 0.75
                                                    else iGunshipThreatFactorWanted = iGunshipThreatFactorWanted * 0.85
                                                    end

                                                    --Large numbers of T2 gunships in campaign - lower threshold to attack
                                                    if iOurGunshipThreat >= 10000 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] < 3 then
                                                        iGunshipThreatFactorWanted = math.max(2.05, iGunshipThreatFactorWanted * 0.8)
                                                    else
                                                        iGunshipThreatFactorWanted = math.max(2.05, iGunshipThreatFactorWanted)
                                                    end
                                                    if M28Team.tTeamData[iTeam][M28Team.refbDontHaveBuildingsOrACUInPlayableArea] then iGunshipThreatFactorWanted = 0.01 end
                                                end
                                            else
                                                if tSubtable[M28Map.subrefiDistance] <= 200 then
                                                    iGunshipThreatFactorWanted = 4
                                                else
                                                    iGunshipThreatFactorWanted = 4.5
                                                end
                                            end
                                            --Reduce threat factor if we have air control
                                            if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] then iGunshipThreatFactorWanted = math.max(math.min(2.7, iGunshipThreatFactorWanted), iGunshipThreatFactorWanted * 0.8) end
                                            --Reduce gunship threat factor if we have T3 gunships and our overall threat factor means enemy wouldnt have more than 3 SAMs (even 4 SAMs shouldnt do enough damage to 1-shot a gunship)
                                            if bHaveT3Gunships and (iOurGunshipThreat / iGunshipThreatFactorWanted <= 5000 or tSubtable[M28Map.subrefiDistance] <= 60) then --3 sams is 4800
                                                if M28Map.bIsCampaignMap then
                                                    iGunshipThreatFactorWanted = math.max(2.05, iGunshipThreatFactorWanted * 0.6)
                                                else
                                                    iGunshipThreatFactorWanted = math.max(2.05, iGunshipThreatFactorWanted * 0.8)
                                                end
                                            end

                                            if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbGunshipsHadAttackOrderLastCycle] then iGunshipThreatFactorWanted = iGunshipThreatFactorWanted * 0.85 end
                                            if tSubtable[M28Map.subrefbIsWaterZone] then
                                                --AddEnemyGroundUnitsToTargetsSubjectToAA(iPlateauOrZero, iLandOrWaterZone, iGunshipThreatFactorWanted, bCheckForAirAA, bOnlyIncludeIfMexToProtect, iGroundAAThresholdAdjust, bIgnoreMidpointPlayableCheck)
                                                AddEnemyGroundUnitsToTargetsSubjectToAA(0, tSubtable[M28Map.subrefiLandOrWaterZoneRef], iGunshipThreatFactorWanted, bCheckForAirAA, iPostFirstTargetCount > 0, nil, bMidpointPlayableOverride)
                                            else
                                                AddEnemyGroundUnitsToTargetsSubjectToAA(tSubtable[M28Map.subrefiPlateauOrPond], tSubtable[M28Map.subrefiLandOrWaterZoneRef], iGunshipThreatFactorWanted, bCheckForAirAA, iPostFirstTargetCount > 0, nil, bMidpointPlayableOverride)
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Have just finished calling AddEnemyGroundUnitsToTargetsSubjectToAA for zone '..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..', PlateauOrPond='..tSubtable[M28Map.subrefiPlateauOrPond]..'; Is table of enemy targets empty='..tostring(M28Utilities.IsTableEmpty(tEnemyGroundOrGunshipTargets))..'; Is tNewlyAddedEnemies empty='..tostring(M28Utilities.IsTableEmpty(tNewlyAddedEnemies))..'; tSubtable='..repru(tSubtable)..'; iGunshipThreatFactorWanted='..iGunshipThreatFactorWanted..'; M28Team.tAirSubteamData[iAirSubteam][M28Team.refbGunshipsHadAttackOrderLastCycle]='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbGunshipsHadAttackOrderLastCycle] or false)) end
                                            if M28Utilities.IsTableEmpty(tEnemyGroundOrGunshipTargets) == false then
                                                --We have enemies to potentially target - however if tthey are of very low value relative to gunships want to search for other more high value zones that wea re interested in targeting
                                                local iCurEnemyPlateauOrZero
                                                if tSubtable[M28Map.subrefbIsWaterZone] then iCurEnemyPlateauOrZero = 0
                                                else iCurEnemyPlateauOrZero = tSubtable[M28Map.subrefiPlateauOrPond]
                                                end
                                                local iCurEnemyZone = tSubtable[M28Map.subrefiLandOrWaterZoneRef]

                                                local iMassValueOfTargets = M28UnitInfo.GetMassCostOfUnits(tNewlyAddedEnemies)
                                                local tCurEnemyZoneData, tCurEnemyTeamData
                                                if iCurEnemyPlateauOrZero > 0 then
                                                    --Land zone
                                                    tCurEnemyZoneData = M28Map.tAllPlateaus[iCurEnemyPlateauOrZero][M28Map.subrefPlateauLandZones][iCurEnemyZone]
                                                    tCurEnemyTeamData = tCurEnemyZoneData[M28Map.subrefLZTeamData][iTeam]

                                                else
                                                    --Water zone
                                                    tCurEnemyZoneData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurEnemyZone]][M28Map.subrefPondWaterZones][iCurEnemyZone]
                                                    tCurEnemyTeamData = tCurEnemyZoneData[M28Map.subrefWZTeamData][iTeam]
                                                end

                                                if bDebugMessages == true then LOG(sFunctionRef..': Have targets for this zone, p'..iCurEnemyPlateauOrZero..'Z'.. iCurEnemyZone..' iPostFirstTargetCount='..iPostFirstTargetCount..'; bDontLookForMoreTargets='..tostring(bDontLookForMoreTargets)..'; iMassValueOfTargets='..iMassValueOfTargets..'; iLowValueZoneThreshold='..iLowValueZoneThreshold) end
                                                if iPostFirstTargetCount == 0 then
                                                    iDistanceOfFirstTarget = tSubtable[M28Map.subrefiDistance]
                                                    --Get mass value of targets

                                                    if iMassValueOfTargets < iLowValueZoneThreshold and ((tCurEnemyTeamData[M28Map.subrefLZSValue] or 0) < 100 or iMassValueOfTargets * 5 < (tCurEnemyTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)) then
                                                        iPostTargetMaxDistance = math.min(750, math.max(250, M28Map.iMapSize * 0.5))
                                                        iPostTargetMaxZoneCheck = 100
                                                        bConsiderIgnoringEnemiesInLowValueZones = true
                                                    else
                                                        iPostTargetMaxDistance = 80
                                                        iPostTargetMaxZoneCheck = 4
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': iMassValueOfTargets='..iMassValueOfTargets..'; iOurGunshipThreat='..iOurGunshipThreat..'; iPostTargetMaxDistance='..iPostTargetMaxDistance..'; iPostTargetMaxZoneCheck='..iPostTargetMaxZoneCheck..'; SValue='..(tCurEnemyTeamData[M28Map.subrefLZSValue] or 'nil')) end
                                                end
                                                iPostFirstTargetCount = iPostFirstTargetCount + 1
                                                if (bConsiderIgnoringEnemiesInLowValueZones and (iMassValueOfTargets > math.max(iLowValueZoneThreshold, iHighestEnemyValueZone * 2) or (tCurEnemyTeamData[M28Map.subrefLZSValue] or 0) > 100 and iMassValueOfTargets * 5 > (tCurEnemyTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0))) or (not(bConsiderIgnoringEnemiesInLowValueZones) and iMassValueOfTargets > iLowValueZoneThreshold and iOurGunshipThreat > 12000) then
                                                    --require units to be in this zone
                                                    bConsiderIgnoringEnemiesInLowValueZones = true
                                                    table.insert(tiPlateauAndZoneForEnemiesToBeIn, {iCurEnemyPlateauOrZero, iCurEnemyPlateauOrZero})
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Adding zone as one for enemies to be in to be selected, iCurEnemyPlateauOrZero='..iCurEnemyPlateauOrZero..'; iCurEnemyPlateauOrZero='..iCurEnemyPlateauOrZero..'; iMassValueOfTargets='..iMassValueOfTargets..'; SIze of enemy units='..table.getn(tEnemyGroundOrGunshipTargets)..'; SValue='..(tCurEnemyTeamData[M28Map.subrefLZSValue] or 'nil')) end
                                                end

                                                iHighestEnemyValueZone = math.max(iHighestEnemyValueZone, iMassValueOfTargets)
                                                if iPostFirstTargetCount >= iPostTargetMaxZoneCheck or bDontLookForMoreTargets then
                                                    break
                                                elseif iPostTargetMaxZoneCheck > 4 then
                                                    local iMassValueOfTargets = M28UnitInfo.GetMassCostOfUnits(tEnemyGroundOrGunshipTargets)
                                                    if iMassValueOfTargets > iLowValueZoneThreshold or ((tCurEnemyTeamData[M28Map.subrefLZSValue] or 0) > 100 and iMassValueOfTargets * 5 > (tCurEnemyTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)) then
                                                        iPostTargetMaxZoneCheck = 4
                                                        iPostTargetMaxDistance = 80
                                                        if iPostFirstTargetCount < iPostTargetMaxZoneCheck then
                                                            bConsiderIgnoringEnemiesInLowValueZones = false
                                                        else
                                                            break
                                                        end
                                                    end
                                                end
                                            end
                                        elseif iPostFirstTargetCount > 0 or bDontLookForMoreTargets then break
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        if M28Utilities.IsTableEmpty(tEnemyGroundOrGunshipTargets) then
            if oFrontGunship and tTeleportTargetToMoveTo then
                if bDebugMessages == true then LOG(sFunctionRef..': Will move gunships to teleport target location, tTeleportTargetToMoveTo='..repru(tTeleportTargetToMoveTo)) end
                M28Team.tAirSubteamData[iAirSubteam][M28Team.refbGunshipsHadAttackOrderLastCycle] = true
                GetGunshipsToMoveToTarget(tAvailableGunships, tTeleportTargetToMoveTo)
            else
                M28Team.tAirSubteamData[iAirSubteam][M28Team.refbGunshipsHadAttackOrderLastCycle] = false
                --Return available gunships to rally point
                if bDebugMessages == true then LOG(sFunctionRef..': Finished considering gunships targets for all land and water zones, will send any remaining gunships to refuel or go to rally (or support point if we have air control). M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl]='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl])) end
                if M28Utilities.IsTableEmpty(tAvailableGunships) == false then --redundancy
                    if tViaFromRallyPoint and M28Conditions.IsLocationInPlayableArea(tViaFromRallyPoint) and tViaFromFrontGunshipPoint and M28Conditions.IsLocationInPlayableArea(tViaFromFrontGunshipPoint) then
                        --Risk flying over lots of AA if we go directly to the rally point

                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Want to avoid going directly to the rally point, tViaFromRallyPoint='..repru(tViaFromRallyPoint)..'; will draw in blue, and will draw gunship rally '..repru(tViaFromFrontGunshipPoint)..' in red. Is table of gunships near front empty='..tostring(M28Utilities.IsTableEmpty(tGunshipsNearFront))..'; is table of gunships not near front empty='..tostring(M28Utilities.IsTableEmpty(tGunshipsNotNearFront))..'; Map plyaable area='..repru(M28Map.rMapPlayableArea)..'; Is gunship via point in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tViaFromFrontGunshipPoint))..'; tViaFromFrontGunshipPoint='..repru(tViaFromFrontGunshipPoint))
                            M28Utilities.DrawLocation(tViaFromRallyPoint, 1)
                            M28Utilities.DrawLocation(tViaFromFrontGunshipPoint, 2)
                        end
                        if M28Utilities.IsTableEmpty(tGunshipsNearFront) == false then
                            for iUnit, oUnit in tGunshipsNearFront do
                                if bDebugMessages == true then LOG(sFunctionRef..': sending gunship that is near front, '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at position '..repru(oUnit:GetPosition())..' to front gunship via point='..repru(tViaFromFrontGunshipPoint)..' which is distance='..M28Utilities.GetDistanceBetweenPositions(tViaFromFrontGunshipPoint, oUnit:GetPosition())) end
                                M28Orders.IssueTrackedMove(oUnit, tViaFromFrontGunshipPoint, 10, false, 'GSViaG', false)
                            end
                        end
                        if M28Utilities.IsTableEmpty(tGunshipsNotNearFront) == false then
                            for iUnit, oUnit in tGunshipsNotNearFront do
                                if bDebugMessages == true then LOG(sFunctionRef..': Sending gunship that is not near front, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit position='..repru(oUnit:GetPosition())..'; tViaFromRallyPoint='..repru(tViaFromRallyPoint)..'; Dist from gunship to via='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tViaFromRallyPoint)) end
                                M28Orders.IssueTrackedMove(oUnit, tViaFromRallyPoint, 10, false, 'GSViaR', false)
                            end
                        end
                    else
                        local tMovePoint = M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint]
                        --DOnt wnat to move to support point, as support point is based in part on front gunship, so end up with a circular logic
                        if M28Utilities.IsTableEmpty(tGunshipsNearFront) == false then
                            for iUnit, oUnit in tGunshipsNearFront do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering idle gunship order for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' Unit fuel='..oUnit:GetFuelRatio()..'; Unit health%='..M28UnitInfo.GetUnitHealthPercent(oUnit)..'; support point='..repru(tMovePoint)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                                if ((oUnit:GetFuelRatio() < 0.6 and oUnit:GetFuelRatio() >= 0) or M28UnitInfo.GetUnitHealthPercent(oUnit) <= 0.85) and not(EntityCategoryContains(categories.CANNOTUSEAIRSTAGING, oUnit.UnitId)) then
                                    table.insert(tGunshipsForRefueling, oUnit)
                                else
                                    M28Orders.IssueTrackedMove(oUnit, tMovePoint, 10, false, 'GSIdle', false)
                                end
                            end
                        end

                        --Further away gunships - consider whether we want to move closer to the front gunship, if it is in the playable area
                        if M28Utilities.IsTableEmpty(tGunshipsNotNearFront) == false and (not(M28Map.bIsCampaignMap) or M28Conditions.IsLocationInPlayableArea(oFrontGunship:GetPosition())) then
                            local tiPlateauAndZonesConsidered = {}
                            local bCurEntrySafe

                            for iUnit, oUnit in tGunshipsNotNearFront do
                                if ((oUnit:GetFuelRatio() < 0.6 and oUnit:GetFuelRatio() >= 0) or M28UnitInfo.GetUnitHealthPercent(oUnit) <= 0.85) and not(EntityCategoryContains(categories.CANNOTUSEAIRSTAGING, oUnit.UnitId)) then
                                    table.insert(tGunshipsForRefueling, oUnit)
                                else
                                    local iCurPlateauOrZero, iCurZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                                    if tiPlateauAndZonesConsidered[iCurPlateauOrZero][iCurZone] == nil then --will approximate by assuming every gunship in the same zone will give the same result, even if the positiontowardsfront may be slightly different
                                        bCurEntrySafe = false
                                        local tPositionTowardsFront = M28Utilities.MoveInDirection(oUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), oFrontGunship:GetPosition()), iCloseToFrontThreshold * 0.5, true, false, false)
                                        if tPositionTowardsFront then
                                            local iFrontPlateauOrZero, iFrontZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tPositionTowardsFront)
                                            bCurEntrySafe = not(DoesEnemyHaveAAThreatAlongPath(iTeam, iCurPlateauOrZero, iCurZone, iFrontPlateauOrZero, iFrontZone, false, 140, 0, false, iAirSubteam, true, false, nil))

                                            if not(tiPlateauAndZonesConsidered[iCurPlateauOrZero]) then tiPlateauAndZonesConsidered[iCurPlateauOrZero] = {} end
                                            tiPlateauAndZonesConsidered[iCurPlateauOrZero][iCurZone] = bCurEntrySafe
                                        end
                                    else
                                        bCurEntrySafe = tiPlateauAndZonesConsidered[iCurPlateauOrZero][iCurZone]
                                    end
                                    if bCurEntrySafe then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Moving unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to be closer to front gunship despite the general retreat order') end
                                        M28Orders.IssueTrackedMove(oUnit, oFrontGunship:GetPosition(), 10, false, 'FACons', false)
                                    else
                                        M28Orders.IssueTrackedMove(oUnit, tMovePoint, 10, false, 'FAGSId', false)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        else
            --Revise list of enemy targets if we only want to consider those in higher value zones
            local tRevisedEnemyGroundTargets
            if M28Utilities.IsTableEmpty(tiPlateauAndZoneForEnemiesToBeIn) then
                tRevisedEnemyGroundTargets = tEnemyGroundOrGunshipTargets
            else
                tRevisedEnemyGroundTargets = {}
                for iUnit, oUnit in tEnemyGroundOrGunshipTargets do
                    for iEntry, tPlateauAndZone in tiPlateauAndZoneForEnemiesToBeIn do
                        if (oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][2] == tPlateauAndZone[2] and oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][1] == tPlateauAndZone[1]) then
                            table.insert(tRevisedEnemyGroundTargets, oUnit)
                        elseif tPlateauAndZone[1] == 0 and oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam] == tPlateauAndZone[2] then
                            table.insert(tRevisedEnemyGroundTargets, oUnit)
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tRevisedEnemyGroundTargets) then tRevisedEnemyGroundTargets = tEnemyGroundOrGunshipTargets end
                if bDebugMessages == true then LOG(sFunctionRef..': Limiting to only units in high value zones, size of tEnemyGroundOrGunshipTargets='..table.getn(tEnemyGroundOrGunshipTargets)..'; Size of tRevisedEnemyGroundTargets='..table.getn(tRevisedEnemyGroundTargets)..'; tiPlateauAndZoneForEnemiesToBeIn='..repru(tiPlateauAndZoneForEnemiesToBeIn)) end
            end
            M28Team.tAirSubteamData[iAirSubteam][M28Team.refbGunshipsHadAttackOrderLastCycle] = true
            --Have targets for gunships, and have available gunships - send orders for targeting
            local oClosestEnemy
            --Get the closest enemy unit to the front gunship; first filter to only consider AA, then (if no AA) consider experimentals and mexes; then (if none of these consider other units
            local tiCategoryPriorities = {M28UnitInfo.refCategoryGroundAA, M28UnitInfo.refCategoryExperimentalLevel + M28UnitInfo.refCategoryMex - categories.TECH1 + M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryMobileLandShield + M28UnitInfo.refCategoryShieldBoat, categories.ALLUNITS}
            local iCurDist
            local iClosestDist = 100000
            for iCurCategoryEntry, iCategoryPriority in tiCategoryPriorities do
                local tPotentialTargets = EntityCategoryFilterDown(iCategoryPriority, tRevisedEnemyGroundTargets)
                if M28Utilities.IsTableEmpty(tPotentialTargets) == false then
                    for iUnit, oUnit in tPotentialTargets do
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oFrontGunship:GetPosition(), oUnit:GetPosition())
                        if iCurDist < iClosestDist then
                            iClosestDist = iCurDist
                            oClosestEnemy = oUnit
                        end
                    end
                end
                if oClosestEnemy then
                    --Dont avoid attacking exp just because there are some AA near another base
                    if iCurCategoryEntry == 1 and iClosestDist >= 70 then
                        local tExperimentalsInTargets = EntityCategoryFilterDown(M28UnitInfo.refCategoryExperimentalLevel, tRevisedEnemyGroundTargets)
                        if M28Utilities.IsTableEmpty(tExperimentalsInTargets) == false then
                            local iSearchThreshold = iClosestDist - 65
                            for iUnit, oUnit in tExperimentalsInTargets do
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oFrontGunship:GetPosition(), oUnit:GetPosition())
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to prioritise enemy experimental instead of MAA, iCurDist='..iCurDist..'; iSearchThreshold='..iSearchThreshold..'; iClosestDist='..iClosestDist) end
                                if iCurDist < iSearchThreshold then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will target nearby enemy experimental in priority to near but further away MAA') end
                                    iClosestDist = iCurDist
                                    iSearchThreshold = iCurDist
                                    oClosestEnemy = oUnit
                                end
                            end
                        end
                    end
                    break
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Closest priority enemy='..oClosestEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestEnemy)) end

            --Check we arent near a nuke
            if M28Conditions.IsTargetNearActiveNukeTarget(oClosestEnemy:GetPosition(), iTeam, 60) then
                if bDebugMessages == true then LOG(sFunctionRef..': We are near an active nuke target so will change gunship position to go to rally point') end
                --Return to rally instead
                GetGunshipsToMoveToTarget(tAvailableGunships, M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint])

            else
                if bDebugMessages == true then LOG(sFunctionRef..': Will try and get gunships to move to oClosestEnemy at position '..repru(oClosestEnemy:GetPosition())..'; is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(oClosestEnemy:GetPosition()))) end
                --If closest enemy is covered by a fixed shield then make sure all gunships will prioritise fixed shields over AA
                if bUsingSnipePriority then
                    for iGunship, oGunship in tAvailableGunships do
                        if oGunship[M28UnitInfo.refbUsingDefaultWeaponPriority] then
                            M28UnitInfo.SetUnitWeaponTargetPriorities(oGunship, M28UnitInfo.refWeaponPriorityGunshipSnipe, true)
                            oGunship[M28UnitInfo.refbUsingDefaultWeaponPriority] = false
                        end
                    end
                elseif M28Utilities.IsTableEmpty(oClosestEnemy[M28Building.reftoUnitsCoveredByShield]) == false then
                    for iGunship, oGunship in tAvailableGunships do
                        if oGunship[M28UnitInfo.refbUsingDefaultWeaponPriority] then
                            M28UnitInfo.SetUnitWeaponTargetPriorities(oGunship, M28UnitInfo.refWeaponPriorityGunshipShield, true)
                            oGunship[M28UnitInfo.refbUsingDefaultWeaponPriority] = false
                        end
                    end
                else
                    for iGunship, oGunship in tAvailableGunships do
                        if not(oGunship[M28UnitInfo.refbUsingDefaultWeaponPriority]) then
                            M28UnitInfo.SetUnitWeaponTargetPriorities(oGunship, M28UnitInfo.refWeaponPriorityGunship, true)
                            oGunship[M28UnitInfo.refbUsingDefaultWeaponPriority] = true
                        end

                    end
                end
                GetGunshipsToMoveToTarget(tAvailableGunships, oClosestEnemy:GetPosition())
            end
        end
    else
        M28Team.tAirSubteamData[iAirSubteam][M28Team.refbGunshipsHadAttackOrderLastCycle] = false
    end

    --Clear assignment flags for any refueling gunships
    if M28Utilities.IsTableEmpty(tGunshipsForRefueling) == false then
        for iUnit, oUnit in tGunshipsForRefueling do
            oUnit[refiGunshipPlacement] = 10000
        end
    end

    --Send units for refueling
    if bDebugMessages == true then LOG(sFunctionRef..': Finished giving gunship orders, is table of gunships for refueling empty='..tostring(M28Utilities.IsTableEmpty(tGunshipsForRefueling))..'; will first consider avoiding enemy ground AA, tViaFromRallyPoint='..repru(tViaFromRallyPoint)..'; iAngleFromRallyToGunship='..(iAngleFromRallyToGunship or 'nil')) end
    if tViaFromRallyPoint and M28Utilities.IsTableEmpty(tGunshipsForRefueling) == false and iAngleFromRallyToGunship and M28Conditions.IsLocationInPlayableArea(tViaFromRallyPoint) then

        if bDebugMessages == true then
            LOG(sFunctionRef..': Want to avoid going directly to the rally point for refueling, number of gunships for refueling='..table.getn(tGunshipsForRefueling)..', tViaFromRallyPoint='..repru(tViaFromRallyPoint)..'; will draw in blue, and will draw gunship rally '..repru(tViaFromFrontGunshipPoint)..' in red. Map plyaable area='..repru(M28Map.rMapPlayableArea)..'; Is gunship via point in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tViaFromFrontGunshipPoint)))
            M28Utilities.DrawLocation(tViaFromRallyPoint, 1)
            M28Utilities.DrawLocation(tViaFromFrontGunshipPoint, 2)
        end
        local iUnitDistToRally, iAngleFromRallyToUnit
        local tRallyPoint = M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint]
        for iCurEntry = table.getn(tGunshipsForRefueling), 1, -1 do
            local oUnit =  tGunshipsForRefueling[iCurEntry]
            iUnitDistToRally = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint)
            if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..': iUnitDistToRally='..iUnitDistToRally..'; iDistToMoveToAltPoint='..iDistToMoveToAltPoint..'; iDistFromRallyToGunship='..iDistFromRallyToGunship) end
            if iUnitDistToRally > 10 + iDistToMoveToAltPoint and iUnitDistToRally / iDistFromRallyToGunship >= 0.25  then
                iAngleFromRallyToUnit = M28Utilities.GetAngleFromAToB(tRallyPoint, oUnit:GetPosition())
                if bDebugMessages == true then LOG(sFunctionRef..': iAngleFromRallyToUnit='..iAngleFromRallyToUnit..'; iAngleFromRallyToGunship='..iAngleFromRallyToGunship..'; Angle to via rally point to unit='..M28Utilities.GetAngleFromAToB(tViaFromRallyPoint, oUnit:GetPosition())) end
                if M28Utilities.GetAngleDifference(iAngleFromRallyToUnit, iAngleFromRallyToGunship) <= 10 or M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(tViaFromRallyPoint, oUnit:GetPosition()), iAngleFromRallyToGunship) <= 10 then
                    --Go to alt rally point instead of refueling
                    if bDebugMessages == true then LOG(sFunctionRef..': Will send unit to via point instead of for refueling') end
                    M28Orders.IssueTrackedMove(oUnit, tViaFromRallyPoint, 10, false, 'GSRefV', false)
                    table.remove(tGunshipsForRefueling, iCurEntry)
                end
            end
        end



    end
    --Run the function even if no units wanting refueling so already attached untis can be sent on their way
    SendUnitsForRefueling(tGunshipsForRefueling, iTeam, iAirSubteam)
    if bDebugMessages == true and M28Utilities.IsTableEmpty(tGunshipsForRefueling) == false then
        LOG(sFunctionRef..': Will send '..table.getn(tGunshipsForRefueling)..' units to refuel')
    end

    --Update front gunship (or set to nilif none available)
    M28Team.tAirSubteamData[iAirSubteam][M28Team.refoFrontGunship] = oFrontGunship

    --Update if gunship wants scout (for cloaked neemies)
    --First remove any existing assignment
    if M28Utilities.IsTableEmpty( M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout]) == false then
        local iExistingEntries = table.getn(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout])
        for iCurEntry = iExistingEntries, 1, -1 do
            if not(M28UnitInfo.IsUnitValid(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout][iCurEntry])) or EntityCategoryContains(M28UnitInfo.refCategoryGunship, M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout].UnitId) then
                table.remove(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout], iCurEntry)
            end
        end
    end
    if bGunshipWantsAirScout and oFrontGunship then
        if not(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout]) then M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout] = {} end
        AddUnitWantingPriorityScout(oFrontGunship)
    end

    --Disable gunship weapons over pacifist areas
    if M28Overseer.bPacifistModeActive or M28Overseer.bHaveDisabledGunshipWeaponsForPacifism then
        M28Overseer.bHaveDisabledGunshipWeaponsForPacifism = M28Overseer.bPacifistModeActive
        for iBrain, oBrain in M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains] do
            local tAllGunships = oBrain:GetListOfUnits(M28UnitInfo.refCategoryGunship, false, true)
            if M28Utilities.IsTableEmpty(tAllGunships) == false then
                local iCurSegmentX, iCurSegmentZ
                local sPathing = M28Map.refPathingTypeHover
                local bDisableWeapon
                for iGunship, oGunship in tAllGunships do
                    bDisableWeapon = false
                    if oGunship:GetFractionComplete() == 1 then
                        if NavUtils.GetLabel(sPathing, oGunship:GetPosition()) then
                            local tGunshipLZOrWZData = M28Map.GetLandOrWaterZoneData(oGunship:GetPosition())
                            if tGunshipLZOrWZData[M28Map.subrefbPacifistArea] then
                                bDisableWeapon = true
                            end
                        end
                        if bDisableWeapon then
                            M28UnitInfo.DisableUnitWeapon(oGunship)
                        else
                            M28UnitInfo.EnableUnitWeapon(oGunship)
                        end
                    end
                end
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateScoutingShortlist(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateScoutingShortlist'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.subrefiTimeOfScoutingShortlistUpdate] or 0) >= 0.89 then

        --Decide how often we want to scout
        local tiTimeByPriority = {[M28Map.subrefiScoutingHighPriority] = 60, [M28Map.subrefiScoutingMediumPriority] = 120, [M28Map.subrefiScoutingLowPriority] = 360}
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] < 3 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 12 then
            for iEntry, iInterval in tiTimeByPriority do
                iInterval = iInterval * 2
            end
        end
        local iRadarFactor = 4 --If have radar coverage then dont want to scout as often
        local iLongestOverdueScoutingTarget = 0
        --Create shortlist
        M28Team.tTeamData[iTeam][M28Team.subrefiTimeOfScoutingShortlistUpdate] = GetGameTimeSeconds()
        M28Team.tTeamData[iTeam][M28Team.subreftLandAndWaterZoneScoutingShortlist] = {}
        local tShortlist = M28Team.tTeamData[iTeam][M28Team.subreftLandAndWaterZoneScoutingShortlist]

        local iIntervalWanted
        local iLongestOverdueRequirement = 0
        local bConsiderOverdueLimit = false
        if M28Team.tTeamData[iTeam][M28Team.subrefiLongestOverdueScoutingTarget] >= 360 then --we have some locations we haven't scouted for at least 6 minutes after we wanted to
            iLongestOverdueRequirement = M28Team.tTeamData[iTeam][M28Team.subrefiLongestOverdueScoutingTarget] * 0.25
            bConsiderOverdueLimit = true
        end
        local tiEntriesBelowOverdueRequirement = {}
        local iEntriesAboveOverdueRequirement = 0
        local iMinSegmentsWantedForMexFreeZones = 400 / M28Map.iLandZoneSegmentSize
        local iAmountOverIntervalWanted
        local iShortlistEntry = 0
        local iLowPriorityShortlistEntryCount = 0

        if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through each plateau and land zone, M28Team.tTeamData[iTeam][M28Team.subrefiLongestOverdueScoutingTarget]='..M28Team.tTeamData[iTeam][M28Team.subrefiLongestOverdueScoutingTarget]..'; iLongestOverdueRequirement='..iLongestOverdueRequirement) end
        for iPlateau, tPlateauSubtable in M28Map.tAllPlateaus do
            for iLandZone, tLZData in tPlateauSubtable[M28Map.subrefPlateauLandZones] do
                if tLZData[M28Map.subrefLZMexCount] > 0 or tLZData[M28Map.subrefLZTotalSegmentCount] >= iMinSegmentsWantedForMexFreeZones then
                    local tLZOrWZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                    iIntervalWanted =  tiTimeByPriority[tLZOrWZTeamData[M28Map.refiScoutingPriority]] + tLZOrWZTeamData[M28Map.refiRecentlyFailedScoutAttempts] ^ 3
                    if tLZOrWZTeamData[M28Map.refiRadarCoverage] >= 40 then iIntervalWanted = iIntervalWanted * iRadarFactor end
                    iAmountOverIntervalWanted = GetGameTimeSeconds() - (tLZOrWZTeamData[M28Map.refiTimeLastHadVisual] or 0) - iIntervalWanted
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; tiTimeByPriority[tLZOrWZTeamData[M28Map.refiScoutingPriority]]='..tiTimeByPriority[tLZOrWZTeamData[M28Map.refiScoutingPriority]]..'; tLZOrWZTeamData[M28Map.refiRecentlyFailedScoutAttempts]='..tLZOrWZTeamData[M28Map.refiRecentlyFailedScoutAttempts]..'; Time last had visual='..(tLZOrWZTeamData[M28Map.refiTimeLastHadVisual] or 0)..'; Cur time='..GetGameTimeSeconds()..'; Do we expect to be adding this to shortlist='..tostring(GetGameTimeSeconds() - (tLZOrWZTeamData[M28Map.refiTimeLastHadVisual] or 0) > iIntervalWanted)..'; iAmountOverIntervalWanted='..iAmountOverIntervalWanted) end
                    if iAmountOverIntervalWanted > 0 then
                        table.insert(tShortlist, {iPlateau, iLandZone})
                        if bConsiderOverdueLimit then
                            iShortlistEntry = iShortlistEntry + 1
                            if iAmountOverIntervalWanted >= iLongestOverdueRequirement then
                                iEntriesAboveOverdueRequirement = iEntriesAboveOverdueRequirement + 1
                            else
                                table.insert(tiEntriesBelowOverdueRequirement, iShortlistEntry)
                                iLowPriorityShortlistEntryCount = iLowPriorityShortlistEntryCount + 1
                            end
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iEntriesAboveOverdueRequirement='..(iEntriesAboveOverdueRequirement or 'nil')..'; iLowPriorityShortlistEntryCount='..(iLowPriorityShortlistEntryCount or 'nil')..'; bConsiderOverdueLimit='..tostring(bConsiderOverdueLimit)) end

        if bConsiderOverdueLimit and M28Utilities.IsTableEmpty(tiEntriesBelowOverdueRequirement) == false and iEntriesAboveOverdueRequirement >= 5 and iLowPriorityShortlistEntryCount >= 5 then
            --Consider removing the entries we have scouted most recently based on how many spyp planes we have
            local iAirScouts = M28Conditions.GetCurrentM28UnitsOfCategoryInTeam(M28UnitInfo.refCategoryAirScout, iTeam)
            if iAirScouts < iEntriesAboveOverdueRequirement then
                for iEntryToRemove = iLowPriorityShortlistEntryCount, 1 do
                    if bDebugMessages == true then LOG(sFunctionRef..': Are removing a shortlist entry as we have so many') end
                    table.remove(tShortlist, tiEntriesBelowOverdueRequirement[iEntryToRemove])
                end
            end

        end

        M28Team.tTeamData[iTeam][M28Team.subrefiLongestOverdueScoutingTarget] = iLongestOverdueScoutingTarget

        --Same for water zones with mexes
        for iPond, tPondSubtable in M28Map.tPondDetails do
            for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
                local tLZOrWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                iIntervalWanted =  tiTimeByPriority[tLZOrWZTeamData[M28Map.refiScoutingPriority]] + tLZOrWZTeamData[M28Map.refiRecentlyFailedScoutAttempts] ^ 3
                if tLZOrWZTeamData[M28Map.refiRadarCoverage] >= 50 then iIntervalWanted = iIntervalWanted * iRadarFactor end
                if GetGameTimeSeconds() - (tLZOrWZTeamData[M28Map.refiTimeLastHadVisual] or 0) > iIntervalWanted then
                    iLongestOverdueScoutingTarget = math.max(GetGameTimeSeconds() - (tLZOrWZTeamData[M28Map.refiTimeLastHadVisual] or 0) - iIntervalWanted, iLongestOverdueScoutingTarget)
                    if iLongestOverdueScoutingTarget >= iLongestOverdueRequirement then
                        table.insert(tShortlist, {0, iWaterZone})
                    end
                end
            end
        end

        if bDebugMessages == true then
            if M28Utilities.IsTableEmpty(tShortlist) == false then
                LOG(sFunctionRef..': end of code, size of tShortlist='..table.getn(tShortlist)..'; tShortlist='..repru(tShortlist)..'; iLongestOverdueScoutingTarget='..iLongestOverdueScoutingTarget)
            else
                LOG(sFunctionRef..': End of code, tShortlist='..repru(tShortlist)..'; iLongestOverdueScoutingTarget='..iLongestOverdueScoutingTarget)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageAirScouts(iTeam, iAirSubteam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageAirScouts'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tAvailableScouts, tScoutsForRefueling, tUnavailableUnits = GetAvailableLowFuelAndInUseAirUnits(iTeam, iAirSubteam, M28UnitInfo.refCategoryAirScout)

    --First record as having visual of every land/water zone that an air scout is in
    local tBombersForVision = {}
    for iBrain, oBrain in M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains] do
        if oBrain.M28AI then
            local tCurUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryBomber - categories.EXPERIMENTAL, false, true)
            if M28Utilities.IsTableEmpty(tCurUnits) == false then
                for iUnit, oUnit in tCurUnits do
                    if oUnit:GetFractionComplete() == 1 and not(oUnit:IsUnitState('Attached')) then
                        table.insert(tBombersForVision, oUnit)
                    end
                end
            end
        end
    end
    local tUnitsGivingVisual = {tAvailableScouts, tScoutsForRefueling, tUnavailableUnits, tBombersForVision}
    for iEntry, tScoutTable in tUnitsGivingVisual do
        if M28Utilities.IsTableEmpty(tScoutTable) == false then
            local iCurPlateauOrZero, iCurLZOrWZ
            for iUnit, oUnit in tScoutTable do
                iCurPlateauOrZero, iCurLZOrWZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                if (iCurPlateauOrZero or 0) > 0 then
                    if (iCurLZOrWZ or 0) == 0 then
                        iCurLZOrWZ = M28Map.GetWaterZoneFromPosition(oUnit:GetPosition())
                        if (iCurLZOrWZ or 0) > 0 then
                            iCurPlateauOrZero = 0
                        end
                    end
                    if (iCurLZOrWZ or 0) > 0 then
                        if iCurPlateauOrZero == 0 then
                            --Water zone
                            M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurLZOrWZ]][M28Map.subrefPondWaterZones][iCurLZOrWZ][M28Map.subrefWZTeamData][iTeam][M28Map.refiTimeLastHadVisual] = GetGameTimeSeconds()
                        else
                            --Land zone
                            local tScoutLZTeamData = M28Map.tAllPlateaus[iCurPlateauOrZero][M28Map.subrefPlateauLandZones][iCurLZOrWZ][M28Map.subrefLZTeamData][iTeam]

                            if not(tScoutLZTeamData) then
                                local iAltPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, oUnit:GetPosition())
                                if (iAltPlateau or 0) > 0 and not(iAltPlateau == iCurPlateauOrZero) then
                                    iCurPlateauOrZero = iAltPlateau
                                    tScoutLZTeamData = M28Map.tAllPlateaus[iCurPlateauOrZero][M28Map.subrefPlateauLandZones][iCurLZOrWZ][M28Map.subrefLZTeamData][iTeam]
                                end
                                if not(tScoutLZTeamData) then
                                    iCurPlateauOrZero, iCurLZOrWZ = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                                    tScoutLZTeamData = M28Map.tAllPlateaus[iCurPlateauOrZero][M28Map.subrefPlateauLandZones][iCurLZOrWZ][M28Map.subrefLZTeamData][iTeam]
                                end
                            end
                            if tScoutLZTeamData then
                                tScoutLZTeamData[M28Map.refiTimeLastHadVisual] = GetGameTimeSeconds()
                            end
                        end
                    end
                end
            end
        end
    end

    --Shortlist of locations to scout if haven't recently
    UpdateScoutingShortlist(iTeam)
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Is table of available scouts empty='..tostring(M28Utilities.IsTableEmpty(tAvailableScouts))) end
    if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
        local tScoutsWithNoDestination = {}
        local tRallyPoint = M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint]
        --First assign any priority scouts
        if M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout]) == false then
            --Refresh the list
            local iPriorityUnitsToScout = table.getn(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout])
            for iEntry = iPriorityUnitsToScout, 1, -1 do
                if not(M28UnitInfo.IsUnitValid(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout][iEntry])) or GetGameTimeSeconds() - (M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout][iEntry][refiTimeLastWantedPriorityAirScout] or GetGameTimeSeconds()) >= 20 then
                    table.remove(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout], iEntry)
                end
            end
            if M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout]) == false then
                local iCurDist, iClosestDist
                for iUnitToScout, oUnitToScout in M28Team.tAirSubteamData[iAirSubteam][M28Team.reftPriorityUnitsWantingScout] do
                    --Find the nearest spy plane
                    iClosestDist = 100000
                    local iClosestRef
                    for iUnit, oUnit in tAvailableScouts do
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnitToScout:GetPosition())
                        if iCurDist < iClosestDist then
                            iClosestRef = iUnit
                            iClosestDist = iCurDist
                        end
                    end
                    if iClosestRef then
                        M28Orders.IssueTrackedMove(tAvailableScouts[iClosestRef], oUnitToScout:GetPosition(), 10, false, 'PrASc', false)
                        table.remove(tAvailableScouts, iClosestRef)
                    end
                    if M28Utilities.IsTableEmpty(tAvailableScouts) then
                        break
                    end
                end
            end
        end

        if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
            --Do we have locations available for scouting?
            if bDebugMessages == true then LOG(sFunctionRef..': Do we have locations available for scouting - is table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftLandAndWaterZoneScoutingShortlist]))) end
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftLandAndWaterZoneScoutingShortlist]) == false then
                local tiScoutRefByDistance = {}
                for iUnit, oUnit in tAvailableScouts do
                    tiScoutRefByDistance[iUnit] = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint)
                end
                --Sort through scouts by distance and find the nearest location overdue for scouting
                local iCurDist, iClosestDist, iClosestPlateauOrZero, iClosestLZOrWZRef, tClosestMidpoint, iClosestShortlistRef
                for iUnit, iDistance in M28Utilities.SortTableByValue(tiScoutRefByDistance, false) do
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftLandAndWaterZoneScoutingShortlist]) == false then


                        iClosestDist = 100000
                        for iEntry, tPlateauAndZoneRef in M28Team.tTeamData[iTeam][M28Team.subreftLandAndWaterZoneScoutingShortlist] do
                            local tMidpoint
                            if tPlateauAndZoneRef[1] == 0 then
                                --Waterzone
                                tMidpoint = M28Map.tPondDetails[M28Map.tiPondByWaterZone[tPlateauAndZoneRef[2]]][M28Map.subrefPondWaterZones][tPlateauAndZoneRef[2]][M28Map.subrefMidpoint]
                            else
                                tMidpoint = M28Map.tAllPlateaus[tPlateauAndZoneRef[1]][M28Map.subrefPlateauLandZones][tPlateauAndZoneRef[2]][M28Map.subrefMidpoint]
                            end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(tMidpoint, tAvailableScouts[iUnit]:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestPlateauOrZero = tPlateauAndZoneRef[1]
                                iClosestLZOrWZRef = tPlateauAndZoneRef[2]
                                tClosestMidpoint = {tMidpoint[1], tMidpoint[2], tMidpoint[3]}
                                iClosestShortlistRef = iEntry
                            end
                        end
                        M28Orders.IssueTrackedMove(tAvailableScouts[iUnit], tClosestMidpoint, 10, false, 'ASP'..iClosestPlateauOrZero..'Z'..iClosestLZOrWZRef, false)
                        --Update tracking
                        tAvailableScouts[iUnit][reftScoutAssignedPlateauAndZoneRef] = {[1] = iClosestPlateauOrZero, [2] = iClosestLZOrWZRef}
                        table.remove(M28Team.tTeamData[iTeam][M28Team.subreftLandAndWaterZoneScoutingShortlist], iClosestShortlistRef)
                    else
                        table.insert(tScoutsWithNoDestination, tAvailableScouts[iUnit])
                    end
                end
            else
                tScoutsWithNoDestination = tAvailableScouts
            end
            if M28Utilities.IsTableEmpty(tScoutsWithNoDestination) == false then
                for iUnit, oUnit in tScoutsWithNoDestination do
                    --If still have remaining available scouts send for refueling with lower threshold
                    if ((oUnit:GetFuelRatio() < 0.6 and oUnit:GetFuelRatio() >= 0) or M28UnitInfo.GetUnitHealthPercent(oUnit) <= 0.7) and not(EntityCategoryContains(categories.CANNOTUSEAIRSTAGING, oUnit.UnitId)) then
                        table.insert(tScoutsForRefueling, oUnit)
                    else
                        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 10, false, 'ASIdle', false)
                    end
                end
            end
        end
    end
    SendUnitsForRefueling(tScoutsForRefueling, iTeam, iAirSubteam)
    if bDebugMessages == true and M28Utilities.IsTableEmpty(tScoutsForRefueling) == false then
        LOG(sFunctionRef..': Will send '..table.getn(tScoutsForRefueling)..' units to refuel')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function OnAirScoutDeath(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OnAirScoutDeath'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTargetPlateauOrZero = oUnit[reftScoutAssignedPlateauAndZoneRef][1]
    local iTargetLZOrWZ = oUnit[reftScoutAssignedPlateauAndZoneRef][2]
    local tLZOrWZTeamData
    local iTeam = oUnit:GetAIBrain().M28Team
    if iTargetPlateauOrZero == 0 then
        --Water zone
        tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iTargetLZOrWZ]][M28Map.subrefPondWaterZones][iTargetLZOrWZ][M28Map.subrefWZTeamData][iTeam]
    else
        tLZOrWZTeamData = M28Map.tAllPlateaus[iTargetPlateauOrZero][M28Map.subrefPlateauLandZones][iTargetLZOrWZ][M28Map.subrefLZTeamData][iTeam]
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[reftScoutAssignedPlateauAndZoneRef]='..repru(oUnit[reftScoutAssignedPlateauAndZoneRef])..'; iTargetPlateauOrZero='..(iTargetPlateauOrZero or 'nil')..'; iTargetLZOrWZ='..(iTargetLZOrWZ or 'nil')..'; tLZOrWZTeamData[M28Map.refiRecentlyFailedScoutAttempts]='..(tLZOrWZTeamData[M28Map.refiRecentlyFailedScoutAttempts] or 'nil')..'; iTeam='..(iTeam or 'nil')) end
    tLZOrWZTeamData[M28Map.refiRecentlyFailedScoutAttempts] = tLZOrWZTeamData[M28Map.refiRecentlyFailedScoutAttempts] + 1
    ForkThread(DelayAirScoutVariableChange, tLZOrWZTeamData)
    oUnit[reftScoutAssignedPlateauAndZoneRef] = nil
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end
function DelayAirScoutVariableChange(tLZOrWZTeamData)
    WaitSeconds(300)
    tLZOrWZTeamData[M28Map.refiRecentlyFailedScoutAttempts] = math.max(0, tLZOrWZTeamData[M28Map.refiRecentlyFailedScoutAttempts] - 1)
end

function AddZoneToPotentialDropZonesSameIslandOrDifPond(iTeam, iPlateauOrZero, iLandOrWaterZone)
    if iPlateauOrZero == 0 then
        if not(M28Team.tTeamData[iTeam][M28Team.reftiPotentialPondDropZones]) then M28Team.tTeamData[iTeam][M28Team.reftiPotentialPondDropZones] = {} end --redundancy
        table.insert(M28Team.tTeamData[iTeam][M28Team.reftiPotentialPondDropZones], iLandOrWaterZone)
    else
        if not( M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau]) then
            M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau] = {}
        end
        if not(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau][iPlateauOrZero]) then
            if not(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau]) then M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau] = {} end
            M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau][iPlateauOrZero] = {}
        end
        table.insert(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau][iPlateauOrZero], iLandOrWaterZone)
    end
end

function UpdateTransportShortlistForFarAwayLandZoneDrops(iTeam)
    --Once per game generate list of land zones that are on the same island as a base but far away, or are on an island with lots of zones but far away from the existing island, so we can consider dropping these as well
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateTransportShortlistForFarAwayLandZoneDrops'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Dont even consider for small maps
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..' for team '..iTeam..'; iMapSize='..M28Map.iMapSize) end
    if M28Map.iMapSize > 256 then
        if not( M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau]) then --redundancy (this function should only be called once per team each game)

            M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau] = {}
            --Generate shortlist of islands that have a friendly M28AI base on them
            local tiPlayerStartByPlateauAndIsland = {}
            local iCurPlateau, iCurLZ, iCurIsland

            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                local tStartPoint = M28Map.GetPlayerStartPosition(oBrain)
                iCurPlateau, iCurLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tStartPoint)
                iCurIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tStartPoint)
                if (iCurIsland or 0) > 0 and (iCurLZ or 0) > 0 then
                    if not(tiPlayerStartByPlateauAndIsland[iCurPlateau]) then tiPlayerStartByPlateauAndIsland[iCurPlateau] = {} end
                    tiPlayerStartByPlateauAndIsland[iCurPlateau][iCurIsland] = true
                end
            end

            --Add in large land zone count islands
            local tiOtherFarAwayIslandsByPlateau = {}
            for iPlateau, tPlateauSubtable in M28Map.tAllPlateaus do
                if M28Utilities.IsTableEmpty(tPlateauSubtable[M28Map.subrefPlateauIslandLandZones]) == false then
                    for iIsland, iLZCount in tPlateauSubtable[M28Map.subrefPlateauIslandLandZones] do
                        if iLZCount >= 10 and  tPlateauSubtable[M28Map.subrefPlateauIslandMexCount] >= 14 then
                            if not(tiOtherFarAwayIslandsByPlateau[iPlateau]) then tiOtherFarAwayIslandsByPlateau[iPlateau] = {} end
                            tiOtherFarAwayIslandsByPlateau[iPlateau][iIsland] = true
                        end
                    end
                end
            end

            local iTravelDistance, iClosestBasePlateau, iClosestBaseLandZone
            local iTravelThreshold = 200
            if M28Map.iMapSize >= 1024 then iTravelThreshold = 260 end
            function ConsiderAdditionalDropZoneForIsland(iPlateau, iIsland, bCheckDistFromExistingDropLocations)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iIsland '..iIsland..' in iPlateau='..iPlateau) end
                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][iIsland]) == false then
                    for iEntry, iLandZone in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][iIsland] do
                        local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iLandZone='..iLandZone..'; with mexcount='..(tLZData[M28Map.subrefLZMexCount] or 0)) end
                        if (tLZData[M28Map.subrefLZMexCount] or 0) >= 3 then
                            local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                            --Is it on our side of the map (or almost on our side of the map)?
                            if bDebugMessages == true then LOG(sFunctionRef..': refiModDistancePercent='..tLZTeamData[M28Map.refiModDistancePercent]) end
                            if tLZTeamData[M28Map.refiModDistancePercent] <= 0.55 and not(tLZTeamData[M28Map.subrefLZbCoreBase]) then --core base check is a redundancy, not even sure if it gets set before this code runs anyway
                                --Get travel distance to closest friendly base
                                iClosestBasePlateau, iClosestBaseLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tLZTeamData[M28Map.reftClosestFriendlyBase])
                                if bDebugMessages == true then LOG(sFunctionRef..': iClosestBasePlateau='..(iClosestBasePlateau or 'nil')..'; iClosestBaseLandZone='..(iClosestBaseLandZone or 'nil')) end
                                if (iClosestBaseLandZone or 0) > 0 and iClosestBasePlateau == iPlateau then
                                    iTravelDistance = (M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iClosestBaseLandZone, iLandZone) or 10000)
                                    if bDebugMessages == true then LOG(sFunctionRef..': iClosestBaseLandZone='..(iClosestBaseLandZone or 'nil')..'; iTravelDistance='..(iTravelDistance or 'nil')) end
                                    if iTravelDistance >= 275 then
                                        local bDropLocation = true
                                        if  bCheckDistFromExistingDropLocations then
                                            if iPlateau > 0 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau][iPlateau]) == false then
                                                for iExistingEntry, iExistingLandZone in M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau][iPlateau] do
                                                    local tExistingLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iExistingLandZone]
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Already have a drop location for this plateau for zone '..iExistingLandZone..'; Travel dist to here='..(M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iExistingLandZone) or 'nil')) end
                                                    if (M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iExistingLandZone) or 10000) <= iTravelThreshold then
                                                        bDropLocation = false
                                                        break
                                                    end
                                                end
                                            end
                                        end
                                        --Want to consider dropping this location during the game
                                        if bDropLocation then
                                            AddZoneToPotentialDropZonesSameIslandOrDifPond(iTeam, iPlateau, iLandZone)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Added plateau and zone to potential drop zones, iPlateau='..iPlateau..'; iLandZone='..iLandZone) end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end

            --Cycle through each of these islands, and find land zones iwth lots of mexes (3+) that we want to consider expanding to
            if M28Utilities.IsTableEmpty(tiPlayerStartByPlateauAndIsland) == false then
                for iPlateau, tSubtable in tiPlayerStartByPlateauAndIsland do
                    for iIsland, bConsider in tSubtable do
                        ConsiderAdditionalDropZoneForIsland(iPlateau, iIsland, false)
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tiOtherFarAwayIslandsByPlateau) == false then
                for iPlateau, tSubtable in tiOtherFarAwayIslandsByPlateau do
                    for iIsland, bConsider in tSubtable do
                        ConsiderAdditionalDropZoneForIsland(iPlateau, iIsland, true)
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau]='..repru(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau])) end
    --Active check - i.e. factoring in current conditions, do we still want to drop the zone?
    M28Team.tTeamData[iTeam][M28Team.reftTransportFarAwaySameIslandPlateauLandZoneDropShortlist] = {}
    local tShortlist = M28Team.tTeamData[iTeam][M28Team.reftTransportFarAwaySameIslandPlateauLandZoneDropShortlist]
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau]) == false then
        local tiPlateauAndZoneWithAdjacentEngineers = {}
        local bCampaignMap = M28Map.bIsCampaignMap
        --Dont drop if we have engineers in this zone or adjacent, or there are dangerous enemy units
        for iPlateau, tLandZones in M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau] do
            for iEntry, iLandZone in tLandZones do
                local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': Considering the land zone '..iLandZone..' in iPlateau='..iPlateau..'; tLZTeamData[M28Map.subrefLZSValue]='..tLZTeamData[M28Map.subrefLZSValue]..'; subrefLZMexCount='..(tLZData[M28Map.subrefLZMexCount] or 'nil')) end
                if tLZTeamData[M28Map.subrefLZSValue] <= 200 and (tLZTeamData[M28Map.refiTransportRecentUnloadCount] or 0) < 3 then --i.e. dont have a land factory or better in the zone, or if we have dropped at least twice recently here
                    --Check we havent already got mexes on any of the positions
                    if bDebugMessages == true then LOG(sFunctionRef..': tLZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
                    if tLZTeamData[M28Map.subrefMexCountByTech][1] + tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] == 0 then
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])..'; tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA]='..(tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 'nil')..'; Is table of units to repair empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToRepair]))..'; Is midpoint in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]))..'; bCampaignMap='..tostring(bCampaignMap)..'; First unit to repair='..(tLZData[M28Map.subreftoUnitsToRepair][1].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tLZData[M28Map.subreftoUnitsToRepair][1]) or 'nil'))
                            if tLZData[M28Map.subreftoUnitsToRepair][1] then LOG(sFunctionRef..': Health percent of first unit to repair='..M28UnitInfo.GetUnitHealthPercent(tLZData[M28Map.subreftoUnitsToRepair][1])) end
                        end

                        if (not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and (tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) == 0) or (bCampaignMap and M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) and M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToRepair]) == false and M28UnitInfo.GetUnitHealthPercent(tLZData[M28Map.subreftoUnitsToRepair][1]) <= 0.15) then
                            --Do we want BP for this zone?
                            if bDebugMessages == true then LOG(sFunctionRef..': tLZTeamData[M28Map.subrefTbWantBP]='..tostring(tLZTeamData[M28Map.subrefTbWantBP] or false)..'; tLZTeamData[M28Map.subrefTBuildPowerByTechWanted]='..repru(tLZTeamData[M28Map.subrefTBuildPowerByTechWanted])) end
                            local bBPWanted = tLZTeamData[M28Map.subrefTbWantBP]
                            if not(bBPWanted) then
                                --Do we not want BP because we have engineers trying to travel here?
                                if bDebugMessages == true then LOG(sFunctionRef..': Is subrefTEngineersTravelingHere empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEngineersTravelingHere]))) end
                                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
                                    if M28Map.bIsCampaignMap then bBPWanted = true
                                    else
                                        local iClosestEngineer = 100000
                                        local iCurDist
                                        for iEngineer, oEngineer in tLZTeamData[M28Map.subrefTEngineersTravelingHere] do
                                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                            if iCurDist < iClosestEngineer then
                                                iClosestEngineer = iCurDist
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': iClosestEngineer='..iClosestEngineer) end
                                        if iClosestEngineer >= 120 then
                                            bBPWanted = true
                                        end
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': bBPWanted='..tostring(bBPWanted)) end
                            if bBPWanted then
                                --Do we have any engineers or factories in this zone?
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
                                local bHaveUnattachedEngineersOrFactories = false
                                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) then
                                    --Do nothing - no allied units there so no engineers or factories will be there
                                else
                                    local tFactoriesAndEngineers = M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryEngineer + categories.COMMAND + categories.SUBCOMMANDER, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))
                                    if M28Utilities.IsTableEmpty(tFactoriesAndEngineers) == false then
                                        --This will include transport if it is about to land
                                        for iUnit, oUnit in tFactoriesAndEngineers do
                                            if not(oUnit:IsUnitState('Attached')) and oUnit:GetFractionComplete() == 1 then
                                                bHaveUnattachedEngineersOrFactories = true
                                            end
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))..'; bHaveUnattachedEngineersOrFactories='..tostring(bHaveUnattachedEngineersOrFactories)) end
                                if not(bHaveUnattachedEngineersOrFactories) then
                                    --Do we have engineers in an adjacent zone?
                                    local bHaveNearbyFactoriesOrLargeThreat = false
                                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                            local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                            if bDebugMessages == true then LOG(sFunctionRef..': iAdjLZ='..iAdjLZ..'; tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..(tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')..'; Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
                                            if tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 100 and not(bCampaignMap) then
                                                bHaveNearbyFactoriesOrLargeThreat = true
                                                break
                                            else
                                                if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                                    local tFactoriesAndEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryEngineer + categories.COMMAND + categories.SUBCOMMANDER, tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                                    if M28Utilities.IsTableEmpty(tFactoriesAndEngineers) == false then
                                                        for iUnit, oUnit in tFactoriesAndEngineers do
                                                            if not(oUnit:IsUnitState('Attached')) and oUnit:GetFractionComplete() == 1 then
                                                                bHaveUnattachedEngineersOrFactories = true

                                                                if EntityCategoryContains(M28UnitInfo.refCategoryFactory, oUnit.UnitId) then
                                                                    bHaveNearbyFactoriesOrLargeThreat = true
                                                                    break
                                                                end
                                                            end
                                                        end
                                                        if bDebugMessages == true then LOG(sFunctionRef..': bHaveUnattachedEngineersOrFactories='..tostring(bHaveUnattachedEngineersOrFactories)..'; Either we have engineers/factory or enemy has combat threat in this adj LZ') end
                                                        if bHaveNearbyFactoriesOrLargeThreat then break end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    if not(bHaveNearbyFactoriesOrLargeThreat) then
                                        --Check the zone itself as well
                                        if bDebugMessages == true then LOG(sFunctionRef..': No major adjacent enemy threats, considering zone itself, enemy combat='..(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)..'; Enemy ground AA='..tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA]..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))) end
                                        if not(bCampaignMap) and ((tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 100 or tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] >= 175) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Drop zone itself has too great an enemy threat') end
                                            bHaveNearbyFactoriesOrLargeThreat = true
                                        end
                                    end
                                    if not(bHaveNearbyFactoriesOrLargeThreat) then
                                        if not(bHaveUnattachedEngineersOrFactories) then
                                            --Want to add to shortlist to consider dropping
                                            if bDebugMessages == true then LOG(sFunctionRef..': Adding plateau '..iPlateau..'; land zone '..iLandZone..'; to shortlist of locations to consider dropping') end
                                            table.insert(tShortlist, {iPlateau, iLandZone})
                                        else
                                            --Add to lower priority shortlist
                                            table.insert(tiPlateauAndZoneWithAdjacentEngineers, {iPlateau, iLandZone})
                                            if bDebugMessages == true then LOG(sFunctionRef..': Have adjacent zone with engineers but no factory or significant enemy threat so will still consider dropping') end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tShortlist) and M28Utilities.IsTableEmpty(tiPlateauAndZoneWithAdjacentEngineers) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Dont have high priority transport drop location but do have a lower priority one with adjacent engineers') end
                for iEntry, tSubtable in tiPlateauAndZoneWithAdjacentEngineers do
                    table.insert(tShortlist, {tSubtable[1], tSubtable[2]})
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tShortlist='..repru(tShortlist)) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateTransportShortlistForPondDrops(iTeam, tbPlateausWithPlayerStartOrIslandDrop)
    --See if we have any underwater mexes on a plateau that doesnt have an island drop planned or a player start position
    --This is only called once each game per team; must be called after the 'far away land zone' logic or else far away land zone logic wont run at all due to check if below table is nil
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateTransportShortlistForPondDrops'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not( M28Team.tTeamData[iTeam][M28Team.reftiPotentialPondDropZones]) then
        M28Team.tTeamData[iTeam][M28Team.reftiPotentialPondDropZones] = {}
        if M28Utilities.IsTableEmpty(M28Map.tPondDetails) == false then
            local tWZWithUnderwaterMexesByPond = {}
            local iCurMexPlateau, iCurMexPond, iCurSegmentX, iCurSegmentZ, iCurWZ
            local tbWZConsidered = {}
            for iMex, tMex in M28Map.tMassPoints do
                if M28Map.IsUnderwater(tMex) then
                    iCurMexPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tMex)
                    iCurSegmentX, iCurSegmentZ = M28Map.GetPathingSegmentFromPosition(tMex)
                    iCurWZ = M28Map.tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ]
                    if iCurWZ and not(tbWZConsidered[iCurWZ]) then
                        tbWZConsidered[iCurWZ] = true
                        local tWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurWZ]][M28Map.subrefPondWaterZones][iCurWZ]
                        local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                        if tWZTeamData[M28Map.reftClosestFriendlyBase] then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have an underwater mex, tMex='..repru(tMex)..'; iCurMexPlateau='..(iCurMexPlateau or 'nil')..'; tbPlateausWithPlayerStartOrIslandDrop[iCurMexPlateau]='..tostring(tbPlateausWithPlayerStartOrIslandDrop[iCurMexPlateau] or false)..'; Dist from midpoint to closest base='..M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], tWZTeamData[M28Map.reftClosestFriendlyBase])..'; iCurWZ='..iCurWZ) end
                            if iCurMexPlateau and not(tbPlateausWithPlayerStartOrIslandDrop[iCurMexPlateau]) or (M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], tWZTeamData[M28Map.reftClosestFriendlyBase]) >= math.max(130, M28Map.iMapSize * 0.3) and M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], tWZTeamData[M28Map.reftClosestEnemyBase]) >= math.max(130, M28Map.iMapSize * 0.4)) then


                                iCurMexPond = M28Map.tiPondByWaterZone[iCurWZ]
                                if iCurMexPond then
                                    if not(tWZWithUnderwaterMexesByPond[iCurMexPond]) then tWZWithUnderwaterMexesByPond[iCurMexPond] = {} end
                                    table.insert(tWZWithUnderwaterMexesByPond[iCurMexPond], iCurWZ)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Adding iCurWZ='..iCurWZ..' to list of water zones to consider dropping, iCurMexPond='..iCurMexPond) end
                                end
                            end
                        end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tWZWithUnderwaterMexesByPond) == false then
                for iPond, tWZs in tWZWithUnderwaterMexesByPond do
                    --Get the mex that is closest to a friendly base
                    local iCurDist
                    local iClosestDist = 100000
                    local iClosestWZRef
                    for iEntry, iWaterZone in tWZs do
                        local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
                        local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                        if tWZTeamData[M28Map.reftClosestFriendlyBase] then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], tWZTeamData[M28Map.reftClosestFriendlyBase])
                            if iCurDist < iClosestDist then
                                iClosestWZRef = iWaterZone
                                iClosestDist = iCurDist
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iPond='..iPond..'; iClosestWZRef='..(iClosestWZRef or 'nil')..'; iClosestDist='..iClosestDist) end
                    if iClosestWZRef then
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding water zone '..iClosestWZRef..' to potential drop zones') end
                        AddZoneToPotentialDropZonesSameIslandOrDifPond(iTeam, 0, iClosestWZRef)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateTransportLocationShortlist(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateTransportLocationShortlist'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastTransportShortlistUpdate] = GetGameTimeSeconds()
    M28Team.tTeamData[iTeam][M28Team.reftTransportIslandDropShortlist] = {}
    local tbPlateausWithPlayerStartOrIslandDrop = {}

    --First record (once per game) potential islands to consider dropping for this team
    if not(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropIslandsByPlateau]) then
        if bDebugMessages == true then LOG(sFunctionRef..': About to do one-off exercise at start of game to identify islands to drop, time='..GetGameTimeSeconds()) end
        M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropIslandsByPlateau] = {}
        --First identify any islands by plateau that have mexes and dont have an enemy or friendly start position
        local tiPlayerStartByPlateauAndIsland = {}
        local iCurPlateau, iCurLZ, iCurIsland
        local toBrainsToConsider = {}

        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
            table.insert(toBrainsToConsider, oBrain)
        end
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
            table.insert(toBrainsToConsider, oBrain)
        end
        for iBrain, oBrain in toBrainsToConsider do
            local tEnemyStart = M28Map.GetPlayerStartPosition(oBrain)
            iCurPlateau, iCurLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tEnemyStart)
            iCurIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tEnemyStart)
            if (iCurIsland or 0) > 0 then
                if not(tiPlayerStartByPlateauAndIsland[iCurPlateau]) then tiPlayerStartByPlateauAndIsland[iCurPlateau] = {} end
                if bDebugMessages == true then LOG(sFunctionRef..': tEnemyStart='..repru(tEnemyStart)..' for brain '..oBrain.Nickname..'; iCurPlateau='..(iCurPlateau or 'nil')..'; iCurIsland='..(iCurIsland or 'nil')) end
                tiPlayerStartByPlateauAndIsland[iCurPlateau][iCurIsland] = true
            end
        end

        --Cycle through every island, check it's not listed in the above table, and then record as a potential island to consider dropping
        local bAlreadyIncluded = false
        local iClosestLZToBase, iClosestBasePlateau, iClosestBaseLZ, iCurDistToFriendlyBase
        local iMexesAlreadyBuiltOn, bHaveLandFactoryOnIsland
        for iPlateau, tPlateauSubtable in M28Map.tAllPlateaus do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateau='..iPlateau..'; Is table of island land zones empty='..tostring(M28Utilities.IsTableEmpty(tPlateauSubtable[M28Map.subrefPlateauIslandLandZones]))) end
            if M28Utilities.IsTableEmpty(tPlateauSubtable[M28Map.subrefPlateauIslandLandZones]) == false then
                for iIsland, tLandZonesInIsland in tPlateauSubtable[M28Map.subrefPlateauIslandLandZones] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iIsland='..iIsland..'; tiPlayerStartByPlateauAndIsland[iPlateau][iIsland]='..reprs(tiPlayerStartByPlateauAndIsland[iPlateau][iIsland])..'; Mex count='..(tPlateauSubtable[M28Map.subrefPlateauIslandMexCount][iIsland] or 0)) end
                    if not(tiPlayerStartByPlateauAndIsland[iPlateau][iIsland]) then
                        --Does the island have mexes? (v90 - effectively removed this requirement and just require that it has land zones, while later on have a requirement for there to be mexes or reclaim)
                        if (tPlateauSubtable[M28Map.subrefPlateauIslandMexCount][iIsland] or 0) > 0 or M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][iIsland]) == false then
                            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][iIsland]) then M28Utilities.ErrorHandler('Island has mexes but no land zone')
                            else
                                local iSignificantReclaimValue = 0
                                --Are we close to a friendly base (such that there's no point trying to drop here?)
                                iClosestLZToBase = 100000
                                iClosestBasePlateau = nil
                                iClosestBaseLZ = nil
                                --Cycle through every land zone to check for friendly bases on the same plateau, and for how many mexes we have built on
                                for iEntry, iLandZone in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][iIsland] do
                                    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                                    --if not(tLZData[M28Map.subrefLastReclaimRefresh]) then
                                    --M28Map.RefreshLandOrWaterZoneReclaimValue(iPlateau, iLandZone, false, true, true) --end --reworked how reclaim zones are updated so this should no longer be necessary
                                    iSignificantReclaimValue = iSignificantReclaimValue + (tLZData[M28Map.subrefTotalSignificantMassReclaim] or 0)
                                    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                                    --Get plateau of the nearest allied base for the first entry, since presumably all land zones have the same plateau, so stop searching if the first one is on a dif plateau
                                    if not(iClosestBasePlateau) then
                                        iClosestBasePlateau, iClosestBaseLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tLZTeamData[M28Map.reftClosestFriendlyBase])
                                        if not(iClosestBasePlateau) then break
                                        end
                                    end
                                    iCurDistToFriendlyBase = (M28Utilities.GetApproxTravelDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], tLZTeamData[M28Map.subrefMidpoint]) or 100000)
                                    if iCurDistToFriendlyBase < iClosestLZToBase then
                                        iClosestLZToBase = iCurDistToFriendlyBase
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': P'..iPlateau..'Z'..iLandZone..'; tLZOrWZData[subrefLastReclaimRefresh]='..(tLZData[M28Map.subrefLastReclaimRefresh] or 'nil')..'; iCurDistToFriendlyBase='..iCurDistToFriendlyBase..'; Signif reclaim val for just this zone='..(tLZData[M28Map.subrefTotalSignificantMassReclaim] or 0)) end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering island '..iIsland..'; iClosestLZToBase='..iClosestLZToBase..'; iClosestBasePlateau='..(iClosestBasePlateau or 'nil')..'; iClosestLZToBase='..(iClosestLZToBase or 'nil')..'; Island mex count='..tPlateauSubtable[M28Map.subrefPlateauIslandMexCount][iIsland]..'; iSignificantReclaimValue='..iSignificantReclaimValue) end
                                if iClosestLZToBase >= 190 or (iClosestLZToBase >= 140 and tPlateauSubtable[M28Map.subrefPlateauIslandMexCount][iIsland] >= 7) or (not(iClosestBasePlateau == iPlateau) and (tPlateauSubtable[M28Map.subrefPlateauIslandMexCount][iIsland] or 0) > 0) then
                                    bAlreadyIncluded = false
                                    if not(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropIslandsByPlateau][iPlateau]) then M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropIslandsByPlateau][iPlateau] = {}
                                    else
                                        for iEntry, iRecordedIsland in M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropIslandsByPlateau][iPlateau] do
                                            if iIsland == iRecordedIsland then
                                                bAlreadyIncluded = true
                                                break
                                            end
                                        end
                                    end
                                    if not(bAlreadyIncluded) then
                                        --A transport is 120 mass, an engi is 52 mass, so want >200 mass for it to be worthwhile to consider dropping engi (on assumption will also be some lower value reclaim to give a profit)
                                        if (tPlateauSubtable[M28Map.subrefPlateauIslandMexCount][iIsland] or 0) > 0 or iSignificantReclaimValue >= iReclaimWantedForTransportDrop then
                                            --this is a 1-off at game start that records locations we might conceivably want to drop during the game - see later loop which factors in things like friendly units
                                            if bDebugMessages == true then LOG(sFunctionRef..': Including iIsland='..iIsland..' on iPlateau='..iPlateau..' in potential drop locations, mex count='..(tPlateauSubtable[M28Map.subrefPlateauIslandMexCount][iIsland] or 0)..'; iSignificantReclaimValue='..iSignificantReclaimValue) end
                                            table.insert(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropIslandsByPlateau][iPlateau], iIsland)
                                            tbPlateausWithPlayerStartOrIslandDrop[iPlateau] = true
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        --Consider ponds with mexes that cant be reached by land - most of the logic is handled in UpdateTransportShortlistForPondDrops
        --First record all plateaus that have a player start position
        for iBrain, oBrain in toBrainsToConsider do
            local tPlayerStart = M28Map.GetPlayerStartPosition(oBrain)
            local iStartPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tPlayerStart)
            if iStartPlateau then tbPlateausWithPlayerStartOrIslandDrop[iStartPlateau] = true end
        end
    end

    local tShortlist = M28Team.tTeamData[iTeam][M28Team.reftTransportIslandDropShortlist]
    local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
    local bDontHaveLocationInPlayableArea
    --Now go through potential islands to consider dropping, and decide which of them we want in the shortlist if any
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..' About to create shortlist of isalnds to drop, is reftiPotentialDropIslandsByPlateau empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropIslandsByPlateau]))..'; repru of this='..repru(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropIslandsByPlateau])) end
    local iRecentDropCount
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropIslandsByPlateau]) == false then
        local bTooMuchThreatOrEngisTraveling
        local iMexesAlreadyBuiltOn = 0
        local iZonesWithSignificantThreat = 0
        local iZonesWithMexesAndNoEnemyThreatOrFriendlyEngis
        local iSignificantReclaimValue

        for iPlateau, tIslands in M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropIslandsByPlateau] do
            iZonesWithMexesAndNoEnemyThreatOrFriendlyEngis = 0
            for iEntry, iIsland in tIslands do
                --Have we not had a recent failed drop?
                bDontHaveLocationInPlayableArea = not(bDontCheckPlayableArea)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering the iIsland='..iIsland..' in iPlateau '..iPlateau..'; Time of last failed drop='..(M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandDropTime][iIsland] or 'nil')) end
                if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandDropTime][iIsland] or -600) >= 300 then --at least 5m since we last attempted a drop
                    iRecentDropCount = 0
                    --Cycle through every land zone on island and check if enemy has large threat (>600) indicating an ACU is present or isgnificant army, or we have engineers traveling here or already on the island (and unattached)
                    bTooMuchThreatOrEngisTraveling = false
                    iSignificantReclaimValue = 0
                    for iLZEntry, iLandZone in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][iIsland] do
                        local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                        iSignificantReclaimValue = iSignificantReclaimValue + (tLZData[M28Map.subrefTotalSignificantMassReclaim] or 0)
                        local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                        if bDontHaveLocationInPlayableArea then bDontHaveLocationInPlayableArea = not(M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint])) end
                        iMexesAlreadyBuiltOn = 0
                        iRecentDropCount = iRecentDropCount + (tLZTeamData[M28Map.refiTransportRecentUnloadCount] or 0)
                        iMexesAlreadyBuiltOn = iMexesAlreadyBuiltOn + tLZTeamData[M28Map.subrefMexCountByTech][1] + tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3]
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iLandZone='..iLandZone..' in the island, enemy threat='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Is table of enemy engineers traveling here empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEngineersTravelingHere]))..'; iMexesAlreadyBuiltOn='..iMexesAlreadyBuiltOn) end
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': we already have engineers traveling here so will abort') end
                            bTooMuchThreatOrEngisTraveling = true
                            break
                        elseif tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] >= 175 then
                            if (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) + (tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0) >= 100 then
                                iZonesWithSignificantThreat = iZonesWithSignificantThreat + 1
                            end
                        elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                            --(we already checked for factories earlier so this is partially a redundancy, as well as expanding to include engineers
                            local tEngineersAndFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                            if M28Utilities.IsTableEmpty(tEngineersAndFactories) == false then
                                for iUnit, oUnit in tEngineersAndFactories do
                                    if not(oUnit:IsUnitState('Attached')) and oUnit:GetFractionComplete() >= 1 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': we already have engineers or factories here') end
                                        bTooMuchThreatOrEngisTraveling = true
                                        break
                                    end
                                end
                            end
                            if (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) == 0 and ((tLZData[M28Map.subrefLZMexCount] or 0) > 0 or iSignificantReclaimValue >= iReclaimWantedForTransportDrop) then iZonesWithMexesAndNoEnemyThreatOrFriendlyEngis = iZonesWithMexesAndNoEnemyThreatOrFriendlyEngis + 1 end
                        else
                            if (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) == 0 and ((tLZData[M28Map.subrefLZMexCount] or 0) > 0 or iSignificantReclaimValue >= iReclaimWantedForTransportDrop) then iZonesWithMexesAndNoEnemyThreatOrFriendlyEngis = iZonesWithMexesAndNoEnemyThreatOrFriendlyEngis + 1 end
                        end
                        if bTooMuchThreatOrEngisTraveling then break end
                    end
                    if iZonesWithSignificantThreat > 0 then
                        if iZonesWithMexesAndNoEnemyThreatOrFriendlyEngis == 0 then
                            bTooMuchThreatOrEngisTraveling = true
                            if bDebugMessages == true then LOG(sFunctionRef..': All zones have significant enemy threat') end
                        elseif iZonesWithMexesAndNoEnemyThreatOrFriendlyEngis < iZonesWithSignificantThreat * 6 then
                            --If there are lots of zones without significant enemy threat then still consider
                            bTooMuchThreatOrEngisTraveling = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Enoguh zones have threat relative to zones without threat that we dont want to drop, iZonesWithMexesAndNoEnemyThreatOrFriendlyEngis='..iZonesWithMexesAndNoEnemyThreatOrFriendlyEngis..'; iZonesWithSignificantThreat='..iZonesWithSignificantThreat) end
                        end
                    end

                    if not(bTooMuchThreatOrEngisTraveling) and iMexesAlreadyBuiltOn >= (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][iIsland] or 0) then
                        if iMexesAlreadyBuiltOn > 0 then
                            bTooMuchThreatOrEngisTraveling = true
                        elseif  iSignificantReclaimValue < iReclaimWantedForTransportDrop then
                            bTooMuchThreatOrEngisTraveling = true
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': bTooMuchThreatOrEngisTraveling='..tostring(bTooMuchThreatOrEngisTraveling)) end
                    if not(bTooMuchThreatOrEngisTraveling) and iRecentDropCount < 3 then --note this probably is effectively 1 less than the value noted, since if the transport is given the order to unload then that location is removed from the shortlist it will potentially cancel its unload order
                        if not(bDontHaveLocationInPlayableArea) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding iIsland='..iIsland..' in plateau '..iPlateau..' to the transport shortlist') end
                            table.insert(tShortlist, {iPlateau, iIsland})
                        end
                    end
                end
            end
        end
    end

    --Now consider adding land zonesi n same island:
    local bFirstTimeConsidering = false
    if not( M28Team.tTeamData[iTeam][M28Team.reftiPotentialDropZonesByPlateau]) and not(M28Team.tTeamData[iTeam][M28Team.reftiPotentialPondDropZones]) then bFirstTimeConsidering = true end
    UpdateTransportShortlistForFarAwayLandZoneDrops(iTeam) --want to run every time, has code in it to make sure one part only runs at start of game
    if bFirstTimeConsidering then
        --Also drop locations for ponds
        UpdateTransportShortlistForPondDrops(iTeam, tbPlateausWithPlayerStartOrIslandDrop)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetIslandPlateauAndLandZoneForTransportToTravelTo(iTeam, oUnit)
    --Returns island, plateau and land zone that we want to drop at (or nil if there are none)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetIslandPlateauAndLandZoneForTransportToTravelTo'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTargetIsland, iTargetPlateau, iTargetLandZone
    local tShortlist = M28Team.tTeamData[iTeam][M28Team.reftTransportIslandDropShortlist]
    if bDebugMessages == true then LOG(sFunctionRef..': Is the island shortlist empty='..tostring(M28Utilities.IsTableEmpty(tShortlist))..'; repru of tShortlist='..repru(tShortlist)) end
    if M28Utilities.IsTableEmpty(tShortlist) == false then
        local iCurDist
        local iClosestLZ
        local iClosestDist = 100000
        local iClosestIslandDist = 100000
        local iCurIslandDist
        local iAirSubteam = oUnit:GetAIBrain().M28AirSubteam

        --Unit cur plateau and land/water zone
        local iCurPlateauOrZero, iCurLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
        if bDebugMessages == true then LOG(sFunctionRef..': Closest plateau and land or water zone to unit position: Unit position='..repru(oUnit:GetPosition())..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurPlateauOrZero='..(iCurPlateauOrZero or 'nil')..'; iCurLandOrWaterZone='..(iCurLandOrWaterZone or 'nil')) end
        for iEntry, tiPlateauAndIsland in tShortlist do
            --Get the closest land zone to oUnit
            iClosestDist = 100000
            for iLZEntry, iLandZone in M28Map.tAllPlateaus[tiPlateauAndIsland[1]][M28Map.subrefPlateauIslandLandZones][tiPlateauAndIsland[2]] do
                local tLZData = M28Map.tAllPlateaus[tiPlateauAndIsland[1]][M28Map.subrefPlateauLandZones][iLandZone]
                --Only consider LZs with mexes so we land close to where we likely want to be
                if tLZData[M28Map.subrefLZMexCount] > 0 then
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                    if iCurDist < iClosestDist then
                        iClosestDist = iCurDist
                        iClosestLZ = iLandZone
                    end
                end
            end
            --Is it safe to travel here?
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..'; tiPlateauAndIsland='..repru(tiPlateauAndIsland)..'; iCurPlateauOrZero='..iCurPlateauOrZero..'; iCurLandOrWaterZone='..iCurLandOrWaterZone..'; Does enemy have aa threat along path='..tostring(DoesEnemyHaveAAThreatAlongPath(iTeam, iCurPlateauOrZero, iCurLandOrWaterZone, tiPlateauAndIsland[1], iClosestLZ, false, 60))..'; M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime][tiPlateauAndIsland[2]][iClosestLZ]='..(M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime][tiPlateauAndIsland[2]][iClosestLZ] or 'nil')..'; Does enemy have AA using detailed check='..tostring(DoesEnemyHaveAAThreatAlongPath(iTeam, iCurPlateauOrZero, iCurLandOrWaterZone, tiPlateauAndIsland[1], iClosestLZ, false, 60,          nil,                     false,         iAirSubteam,         true))) end
            --Has a transport recently died trying to get here?
            if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime][tiPlateauAndIsland[2]][iClosestLZ] or -300) > 180 then
                    --DoesEnemyHaveAAThreatAlongPath(iTeam, iStartPlateauOrZero, iStartLandOrWaterZone, iEndPlateauOrZero, iEndLandOrWaterZone, bIgnoreAirAAThreat, iGroundAAThreatThreshold, iAirAAThreatThreshold, bUsingTorpBombers, iAirSubteam, bDoDetailedCheckForAA, bReturnGroundAAThreatInstead, tOptionalStartMidpointAdjustForDetailedCheck)
                if not(DoesEnemyHaveAAThreatAlongPath(iTeam, iCurPlateauOrZero, iCurLandOrWaterZone, tiPlateauAndIsland[1], iClosestLZ, false, 60,          nil,                     false,         iAirSubteam,         true, nil, oUnit:GetPosition())) then
                    iCurIslandDist = iClosestDist
                    if bDebugMessages == true then LOG(sFunctionRef..': iCurIslandDist='..iCurIslandDist..'; iClosestIslandDist='..iClosestIslandDist) end
                    if iCurIslandDist < iClosestIslandDist then
                        iClosestIslandDist = iCurIslandDist
                        iTargetIsland = tiPlateauAndIsland[2]
                        iTargetPlateau = tiPlateauAndIsland[1]
                        iTargetLandZone = iClosestLZ
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': end of code, iTargetIsland='..(iTargetIsland or 'nil')..'; iTargetPlateau='..(iTargetPlateau or 'nil')..'; iTargetLandZone='..(iTargetLandZone or 'nil')) end
    return iTargetIsland, iTargetPlateau, iTargetLandZone
end

function GetFarAwayLandZoneOnCurrentIslandForTransportToTravelTo(iTeam, oUnit)
    --Returns island, plateau and land zone that we want to drop at (or nil if there are none)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetFarAwayLandZoneOnCurrentIslandForTransportToTravelTo'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTargetIsland, iTargetPlateau, iTargetLandZone
    local tShortlist = M28Team.tTeamData[iTeam][M28Team.reftTransportFarAwaySameIslandPlateauLandZoneDropShortlist] --(UpdateTransportShortlistForFarAwayLandZoneDrops determins the shortlist)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for shortlist, time='..GetGameTimeSeconds()..', is shortlist empty='..tostring(M28Utilities.IsTableEmpty(tShortlist))) end
    if M28Utilities.IsTableEmpty(tShortlist) == false then
        local iCurDist
        local iClosestDist = 100000
        local tiClosestPlateauAndZone
        local iAirSubteam = oUnit:GetAIBrain().M28AirSubteam

        --Unit cur plateau and land/water zone
        local iCurPlateauOrZero, iCurLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
        if bDebugMessages == true then LOG(sFunctionRef..': Closest plateau and land or water zone to unit position: Unit position='..repru(oUnit:GetPosition())..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurPlateauOrZero='..(iCurPlateauOrZero or 'nil')..'; iCurLandOrWaterZone='..(iCurLandOrWaterZone or 'nil')) end

        local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
        local bDontHaveLocationInPlayableArea

        for iEntry, tiPlateauAndZone in tShortlist do
            bDontHaveLocationInPlayableArea = not(bDontCheckPlayableArea)
            local tLZData = M28Map.tAllPlateaus[tiPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tiPlateauAndZone[2]]
            if bDontHaveLocationInPlayableArea then bDontHaveLocationInPlayableArea = not(M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint])) end
            if not(bDontHaveLocationInPlayableArea) then
                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                if bDebugMessages == true then LOG(sFunctionRef..': Considering zone with distance of '..iCurDist) end
                if iCurDist < iClosestDist then
                    --Is it safe to travel here?
                    if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime][tLZData[M28Map.subrefLZIslandRef]][tiPlateauAndZone[2]] or -300) > 180 then

                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..'; tiPlateauAndZone='..repru(tiPlateauAndZone)..'; iCurPlateauOrZero='..iCurPlateauOrZero..'; iCurLandOrWaterZone='..iCurLandOrWaterZone..'; Does enemy have aa threat along path='..tostring(DoesEnemyHaveAAThreatAlongPath(iTeam, iCurPlateauOrZero, iCurLandOrWaterZone, tiPlateauAndZone[1], tiPlateauAndZone[2], false, 60,          nil,                     false,         iAirSubteam,         true, nil, oUnit:GetPosition()))) end
                        if not(DoesEnemyHaveAAThreatAlongPath(iTeam, iCurPlateauOrZero, iCurLandOrWaterZone, tiPlateauAndZone[1], tiPlateauAndZone[2], false, 60,          nil,                     false,         iAirSubteam,         true, nil, oUnit:GetPosition())) then
                            iClosestDist = iCurDist
                            tiClosestPlateauAndZone = {tiPlateauAndZone[1], tiPlateauAndZone[2]}
                        end
                    end
                end
            end
        end
        if tiClosestPlateauAndZone then
            iTargetPlateau = tiClosestPlateauAndZone[1]
            iTargetLandZone = tiClosestPlateauAndZone[2]
            local tLZData = M28Map.tAllPlateaus[iTargetPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone]
            iTargetIsland = tLZData[M28Map.subrefLZIslandRef]
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iTargetIsland='..(iTargetIsland or 'nil')..'; iTargetPlateau='..(iTargetPlateau or 'nil')..'; iTargetLandZone='..(iTargetLandZone or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iTargetIsland, iTargetPlateau, iTargetLandZone
end

function GetWaterZoneForTransportToTravelTo(iTeam, oUnit)
    --Returns island, plateau and land zone that we want to drop at (or nil if there are none)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetWaterZoneForTransportToTravelTo'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTargetWaterZone
    local tShortlist = M28Team.tTeamData[iTeam][M28Team.reftiPotentialPondDropZones]
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for shortlist, time='..GetGameTimeSeconds()..', is shortlist empty='..tostring(M28Utilities.IsTableEmpty(tShortlist))) end
    if M28Utilities.IsTableEmpty(tShortlist) == false then
        local iCurDist
        local iClosestDist = 100000

        --Unit cur plateau and land/water zone
        local iCurPlateauOrZero, iCurLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
        if bDebugMessages == true then LOG(sFunctionRef..': Closest plateau and land or water zone to unit position: Unit position='..repru(oUnit:GetPosition())..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurPlateauOrZero='..(iCurPlateauOrZero or 'nil')..'; iCurLandOrWaterZone='..(iCurLandOrWaterZone or 'nil')..'; tShortlist='..repru(tShortlist)) end

        local bDontCheckPlayableArea = not(M28Map.bIsCampaignMap)
        local bDontHaveLocationInPlayableArea

        for iEntry, iWaterZone in tShortlist do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry '..iEntry..'; iWaterZone='..iWaterZone..'; Time last failed to drop here='..(M28Team.tTeamData[iTeam][M28Team.refiLastFailedWaterZoneDropTime][iWaterZone] or 'nil')) end
            if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiLastFailedWaterZoneDropTime][iWaterZone] or -300) >= 300 then
                bDontHaveLocationInPlayableArea = not(bDontCheckPlayableArea)
                local tWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone]
                if bDontHaveLocationInPlayableArea then bDontHaveLocationInPlayableArea = not(M28Conditions.IsLocationInPlayableArea(tWZData[M28Map.subrefMidpoint])) end
                if not(bDontHaveLocationInPlayableArea) then
                    --Only drop if there are unbuilt mexes in this zone
                    if bDebugMessages == true then LOG(sFunctionRef..': is table of unbuilt locations empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]))) end
                    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]) == false then
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tWZData[M28Map.subrefMidpoint])
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering water zone '..iWaterZone..' with distance of '..iCurDist) end
                        if iCurDist < iClosestDist then
                            --Is it safe to travel here?
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..'; iWaterZone='..iWaterZone..'; will see if safe to travel here, does enemy have AA threat='..tostring(DoesEnemyHaveAAThreatAlongPath(iTeam, iCurPlateauOrZero, iCurLandOrWaterZone, 0, iWaterZone, false, 60))) end
                            if not(DoesEnemyHaveAAThreatAlongPath(iTeam, iCurPlateauOrZero, iCurLandOrWaterZone, 0, iWaterZone, false, 60)) then
                                iClosestDist = iCurDist
                                iTargetWaterZone = iWaterZone
                            end
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iTargetWaterZone='..(iTargetWaterZone or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iTargetWaterZone
end

function GetTransportEngiCargoAndRemainingCapacity(oUnit, iEngiTechLevel)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetTransportEngiCargoAndRemainingCapacity'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': About to try and get cargo for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; is oUnit.GetCargo nil='..tostring(oUnit.GetCargo == nil)..'; Does unit contain transport category='..tostring(EntityCategoryContains(categories.TRANSPORTATION, oUnit.UnitId))..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
    local tCargo = oUnit:GetCargo()
    local tiClampsByType = M28UnitInfo.GetClampsByType(oUnit)
    local iCargoSize = 0
    if M28Utilities.IsTableEmpty(tCargo) == false then
        iCargoSize = table.getn(tCargo)
        local iCurCargoTechLevel
        local iCurClampType

        for iCargo, oCargo in tCargo do
            if tiClampsByType[M28UnitInfo.refClampStinger] > 0 then
                iCurClampType = M28UnitInfo.refClampStinger
            else
                iCurCargoTechLevel = M28UnitInfo.GetUnitTechLevel(oCargo)
                if iCurCargoTechLevel == 3 or EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oCargo.UnitId) then
                    iCurClampType = M28UnitInfo.refClampLarge
                elseif iCurCargoTechLevel <= 1 then
                    iCurClampType = M28UnitInfo.refClampSmall
                elseif iCurCargoTechLevel <= 2 then
                    iCurClampType = M28UnitInfo.refClampMedium
                elseif iCurCargoTechLevel == 4 then
                    iCurClampType = M28UnitInfo.refClampExperimental
                else
                    --Redundancy
                    iCurClampType = M28UnitInfo.refClampLarge
                end
            end
            if tiClampsByType[iCurClampType] > 0 then
                tiClampsByType[iCurClampType] = tiClampsByType[iCurClampType] - 1
            else
                --Find the next largest clamp and reset
                if bDebugMessages == true then LOG(sFunctionRef..': Dont have enough of the smallest clamp type, iCurClampType='..iCurClampType..'; tiClampsByType='..repru(tiClampsByType)) end
                for iClampType, iClampsAvailable in tiClampsByType do
                    if iClampsAvailable > 0 then
                        tiClampsByType[iClampType] = tiClampsByType[iClampType] - 1
                        if iClampType == M28UnitInfo.refClampMedium then
                            --if bDebugMessages == true then LOG(sFunctionRef..': Splitting medium out as it can take 2 small units') end
                            tiClampsByType[M28UnitInfo.refClampSmall] = tiClampsByType[M28UnitInfo.refClampSmall] + 1
                        elseif iClampType == M28UnitInfo.refClampLarge then
                            if iCurClampType == M28UnitInfo.refClampSmall then
                                --if bDebugMessages == true then LOG(sFunctionRef..': Splitting large out as it can take 4 small units') end
                                tiClampsByType[M28UnitInfo.refClampSmall] = tiClampsByType[M28UnitInfo.refClampSmall] + 3
                            else
                                --if bDebugMessages == true then LOG(sFunctionRef..': Splitting large out as it can take 2 medium units') end
                                tiClampsByType[M28UnitInfo.refClampMedium] = tiClampsByType[M28UnitInfo.refClampMedium] + 1
                            end
                        end
                    end
                end
            end
        end
    end

    --How many of the tech level wanted can we fit in?
    local tiTechLevelCountByClamp = {[M28UnitInfo.refClampSmall] = {[1]=1,[2]=0,[3]=0,[4]=0},
                                     [M28UnitInfo.refClampMedium] = {[1]=2,[2]=1,[3]=0,[4]=0},
                                     [M28UnitInfo.refClampLarge] = {[1]=4,[2]=2,[3]=1,[4]=0},
                                     [M28UnitInfo.refClampExperimental] = {[1]=1,[2]=1,[3]=1,[4]=1},
                                     [M28UnitInfo.refClampStinger] = {[1]=1,[2]=1,[3]=0,[4]=0}}


    local iCurLevelCapacity = 0
    for iClampType, iClampsAvailable in tiClampsByType do
        if iClampsAvailable > 0 then

            iCurLevelCapacity = iCurLevelCapacity + tiTechLevelCountByClamp[iClampType][iEngiTechLevel] * iClampsAvailable
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iCurLevelCapacity='..iCurLevelCapacity..'; iCargoSize='..iCargoSize..'; iEngiTechLevel='..iEngiTechLevel..'; tiClampsByType='..repru(tiClampsByType)) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iCargoSize, iCurLevelCapacity
    --return iCargoSize, iTotalCapacity - iCargoSize
end

function ManageTransports(iTeam, iAirSubteam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageTransports'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Time of last transport shortlist update='..(M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastTransportShortlistUpdate] or 0)..'; Cur time='..GetGameTimeSeconds()..'; Dif='..GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastTransportShortlistUpdate] or 0)) end
    if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastTransportShortlistUpdate] or 0) >= 0.8 then
        UpdateTransportLocationShortlist(iTeam)
    end
    local tAvailableTransports, tTransportsForRefueling, tUnavailableUnits = GetAvailableLowFuelAndInUseAirUnits(iTeam, iAirSubteam, M28UnitInfo.refCategoryTransport - categories.EXPERIMENTAL) --In reality shouldnt have any units for refueling
    local tRallyPoint = M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint]

    if bDebugMessages == true then LOG(sFunctionRef..': Near start, time='..GetGameTimeSeconds()..'; Is table of available transports empty='..tostring(M28Utilities.IsTableEmpty(tAvailableTransports))..'; tRallyPoint='..repru(tRallyPoint)) end
    if M28Utilities.IsTableEmpty(tAvailableTransports) == false then
        --Cycle through each transport, and decide the best island to try and drop to - first sort transports by distance so are less likely to have a far away transport go to a aplteau that a closer one can reach


        if table.getn(tAvailableTransports) > 1 then
            --Multiple transports can have issues with being stuck in a loop depending on the location of the drop target; therefore want to exclude any avaialble tranpsorts that have been given an unload order
            local bRemovedEntry
            for iCurTransportEntry = table.getn(tAvailableTransports), 1, -1 do
                bRemovedEntry = false
                local oTransport = tAvailableTransports[iCurTransportEntry]
                M28Orders.UpdateRecordedOrders(oTransport)
                local tLastOrder = oTransport[M28Orders.reftiLastOrders][oTransport[M28Orders.refiOrderCount]]
                if bDebugMessages == true then LOG(sFunctionRef..': Considering oTransport='..oTransport.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTransport)..'; last order type='..(tLastOrder[M28Orders.subrefiOrderType] or 'nil')..'; refiTargetZoneForDrop='..(oTransport[refiTargetZoneForDrop] or 'nil')) end
                if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderUnloadTransport and oTransport[refiTargetZoneForDrop] and M28Utilities.IsTableEmpty(tLastOrder[M28Orders.subreftOrderPosition]) == false then
                    local iTargetPlateau, iTargetZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tLastOrder[M28Orders.subreftOrderPosition])
                    if iTargetZone == oTransport[refiTargetZoneForDrop] then
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftTransportIslandDropShortlist]) == false then
                            local iTargetIsland = NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tLastOrder[M28Orders.subreftOrderPosition])
                            if bDebugMessages == true then LOG(sFunctionRef..': iTargetPlateau='..(iTargetPlateau or 'nil')..'; iTargetZone='..(iTargetZone or 'nil')..'; iTargetIsland='..(iTargetIsland or 'nil')..'; will check if on island drop hsortlist') end
                            if iTargetIsland then
                                for iEntry, tPlateauAndIsland in M28Team.tTeamData[iTeam][M28Team.reftTransportIslandDropShortlist] do
                                    if tPlateauAndIsland[1] == iTargetPlateau and tPlateauAndIsland[2] == iTargetIsland then
                                        bRemovedEntry = true
                                        table.remove(M28Team.tTeamData[iTeam][M28Team.reftTransportIslandDropShortlist], iEntry)
                                        break
                                    end
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftTransportFarAwaySameIslandPlateauLandZoneDropShortlist]) == false then
                            for iEntry, tPlateauAndLZ in M28Team.tTeamData[iTeam][M28Team.reftTransportFarAwaySameIslandPlateauLandZoneDropShortlist] do
                                if tPlateauAndLZ[1] == iTargetPlateau and tPlateauAndLZ[2] == iTargetZone then
                                    bRemovedEntry = true
                                    table.remove(M28Team.tTeamData[iTeam][M28Team.reftTransportFarAwaySameIslandPlateauLandZoneDropShortlist], iEntry)
                                    break
                                end
                            end
                        end
                    end
                    local bAbort = false
                    if not(bRemovedEntry) then
                        local tTargetZoneData, tTargetZoneTeamData
                        if iTargetPlateau == 0 then
                            tTargetZoneData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iTargetZone]][M28Map.subrefPondWaterZones][iTargetZone]
                            tTargetZoneTeamData = tTargetZoneData[M28Map.subrefWZTeamData][iTeam]
                        else
                            tTargetZoneData = M28Map.tAllPlateaus[iTargetPlateau][M28Map.subrefPlateauLandZones][iTargetZone]
                            tTargetZoneTeamData = tTargetZoneData[M28Map.subrefLZTeamData][iTeam]
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': We didnt remove the target from the shortlist which sugests we no longer think the target is suitable - if it has an ACU or there are sufficient enemies around the dropzone then abort the drop, enemy combat threat at zone='..(tTargetZoneTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil')) end
                        local iCombatThreshold = 50
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftTransportFarAwaySameIslandPlateauLandZoneDropShortlist]) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftTransportIslandDropShortlist]) then
                            --Might as well chance a drop, maybe our engineers can reclaim a tank or they move away before we get there
                            iCombatThreshold = 125
                        end
                        if (tTargetZoneTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= iCombatThreshold and not(tTargetZoneTeamData[M28Map.subrefLZbCoreBase]) then
                            if M28Conditions.IsTableOfUnitsStillValid(tTargetZoneTeamData[M28Map.subrefTEnemyUnits]) then
                                local tUnitsNearDropZone = {}
                                for iUnit, oUnit in tTargetZoneTeamData[M28Map.subrefTEnemyUnits] do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit combat range='..(oUnit[M28UnitInfo.refiCombatRange] or 0)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Dist from unit position to order position='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLastOrder[M28Orders.subreftOrderPosition])) end
                                    if (oUnit[M28UnitInfo.refiCombatRange] or 0) >= 15 and oUnit:GetFractionComplete() >= 0.9 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLastOrder[M28Orders.subreftOrderPosition]) <= oUnit[M28UnitInfo.refiCombatRange] + 5 then
                                        table.insert(tUnitsNearDropZone, oUnit)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Adding unit as one of those close to the drop zone') end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Combat threat of units near drop zone='..M28UnitInfo.GetCombatThreatRating(tUnitsNearDropZone, true, false)..'; iCombatThreshold='..iCombatThreshold) end
                                if M28Utilities.IsTableEmpty(tUnitsNearDropZone) == false and M28UnitInfo.GetCombatThreatRating(tUnitsNearDropZone, true, false) >= iCombatThreshold then
                                    bAbort = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to abort transport drop for target zone '..iTargetZone..'; PlateauOrZero='..iTargetPlateau..' and transport '..oTransport.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTransport)..' as enemy has too large a combat threat near the drop point') end
                                elseif bDebugMessages == true then LOG(sFunctionRef..': Combat threat near drop zone is low enough that will risk dropping')
                                end
                            end
                        end
                    end
                    if not(bAbort) then
                        if bDebugMessages == true then LOG(sFunctionRef..': bRemovedEntry='..tostring(bRemovedEntry or false)) end
                        --if bRemovedEntry then
                        table.remove(tAvailableTransports, iCurTransportEntry)
                        --end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Will clear the transport orders and make it available') end
                        M28Orders.IssueTrackedClearCommands(oTransport)
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tAvailableTransports) == false then



            --DoesEnemyHaveAAThreatAlongPath(iTeam, iCurPlateauOrZero, iCurLandOrWaterZone, tiPlateauAndIsland[1], iClosestLZ, false, 60)) then


            local tiTransportDistance = {}
            for iUnit, oUnit in tAvailableTransports do
                tiTransportDistance[iUnit] = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint)
                oUnit[refiEngisWanted] = 0
                oUnit[refiTargetIslandForDrop] = nil --will change later if we are dropping
            end

            local iIslandToTravelTo, iPlateauToTravelTo, iLandZoneToTravelTo, iExtraEngisWanted, iEngisHave, iEngiRemainingCapacity
            local iTechLevel = M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]
            for iUnitRef, iDistance in M28Utilities.SortTableByValue(tiTransportDistance, true) do --sort high to low, with thel ogic that rally is likely close to our base, so high dist is likely closer to enemy/plateau
                local oUnit = tAvailableTransports[iUnitRef]
                local bTravelToSameIsland = false
                local iWaterZoneToTravelTo
                iIslandToTravelTo, iPlateauToTravelTo, iLandZoneToTravelTo = GetIslandPlateauAndLandZoneForTransportToTravelTo(iTeam, oUnit)
                if bDebugMessages == true then LOG(sFunctionRef..': iUnitRef='..iUnitRef..'; Considering transport '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iDistance='..iDistance..'; iIslandToTravelTo='..(iIslandToTravelTo or 'nil')..'; iPlateauToTravelTo='..(iPlateauToTravelTo or 'nil')..'; iLandZoneToTravelTo='..(iLandZoneToTravelTo or 'nil')) end
                if not(iIslandToTravelTo) then

                    iIslandToTravelTo, iPlateauToTravelTo, iLandZoneToTravelTo = GetFarAwayLandZoneOnCurrentIslandForTransportToTravelTo(iTeam, oUnit)
                    if bDebugMessages == true then LOG(sFunctionRef..': Transport doesnt have an island to travel to, will see if have far away land zones we want to travel to instead, iIslandToTravelTo after check='..(iIslandToTravelTo or 'nil')) end
                    if iIslandToTravelTo then bTravelToSameIsland = true
                    else
                        iWaterZoneToTravelTo = GetWaterZoneForTransportToTravelTo(iTeam, oUnit)
                        iLandZoneToTravelTo = nil --redundancy
                        iPlateauToTravelTo = 0 --redundancy
                    end
                end
                if iIslandToTravelTo or iWaterZoneToTravelTo then
                    local tLZOrWZData
                    if iIslandToTravelTo then tLZOrWZData = M28Map.tAllPlateaus[iPlateauToTravelTo][M28Map.subrefPlateauLandZones][iLandZoneToTravelTo]
                    else tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZoneToTravelTo]][M28Map.subrefPondWaterZones][iWaterZoneToTravelTo]
                    end

                    --Decide how many engineers we want to drop on this LZ
                    iEngisHave, iEngiRemainingCapacity = GetTransportEngiCargoAndRemainingCapacity(oUnit, iTechLevel)
                    if iEngisHave >= 4 or iEngiRemainingCapacity < 0 or (iEngiRemainingCapacity == 1 and iEngisHave >= 3) then
                        iExtraEngisWanted = 0
                    elseif iEngisHave >= 1 and oUnit[M28Orders.reftiLastOrders][1][M28Orders.subrefiOrderType] == M28Orders.refiOrderUnloadTransport then
                        --Want transport to drop with what it has
                        iExtraEngisWanted = 0
                    else
                        --First calculate how many we want (ignoring ones we already have):
                        local iBuildRate = math.max(1, (oUnit:GetAIBrain()[M28Economy.refiBrainBuildRateMultiplier] or 1))
                        if iWaterZoneToTravelTo then iExtraEngisWanted = 1
                        else
                            iExtraEngisWanted = math.max(1, M28Map.tAllPlateaus[iPlateauToTravelTo][M28Map.subrefPlateauIslandMexCount][iIslandToTravelTo] / iBuildRate)
                            if M28Map.tAllPlateaus[iPlateauToTravelTo][M28Map.subrefPlateauIslandMexCount][iIslandToTravelTo] <= 2 then iExtraEngisWanted = 1 end
                        end

                        if iExtraEngisWanted == 2 then iExtraEngisWanted = 1 end --Only want 1 engi for 1-2 mex plateaus (as wont be building land fac)
                        --Cap engis at 4 (fewer if likely T2 or T3 engis), and also reduce for the number of engineers we already have
                        iExtraEngisWanted = math.min(5 - iTechLevel, math.max(1, 4 / iBuildRate) - iEngisHave, math.max(0, iExtraEngisWanted - iEngisHave), iEngiRemainingCapacity)
                        --Reduce extra engis wanted if we have been waiting a while
                        if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have been waiting a while, in which case do we want to reduce engineers wnated, time spent waiting='..(oUnit[refiTransportTimeSpentWaiting] or 'nil')..'; iEngisHave='..iEngisHave..'; iExtraEngisWanted pre adjust='..iExtraEngisWanted..'; Dist to zone midpoint='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZOrWZData[M28Map.subrefMidpoint])) end
                        if (oUnit[refiTransportTimeSpentWaiting] or 0) >= 30 and iEngisHave >= 1 and iEngisHave >= iExtraEngisWanted then
                            if bDebugMessages == true then LOG(sFunctionRef..': Time spent waiting >= 30 so dont want more engineers') end
                            iExtraEngisWanted = 0
                        elseif iEngisHave >= 2 then
                            local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZOrWZData[M28Map.subrefMidpoint])
                            if iDistToTarget <= 250 and iEngisHave >= 3 / iBuildRate and ((oUnit[refiTransportTimeSpentWaiting] or 0) >= 2 and not(M28UnitInfo.IsUnitValid(oUnit[refoTransportUnitTryingToLoad]))) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have been waiting for at least 2 seconds and no engineers trying to load so dont want more engineers') end
                                iExtraEngisWanted = 0
                            elseif (oUnit[refiTransportTimeSpentWaiting] or 0) >= 10 then
                                if iDistToTarget <= 350 then
                                    if iEngisHave >= 3 / iBuildRate then
                                        iExtraEngisWanted = 0
                                    elseif iDistToTarget <= 240 then
                                        iExtraEngisWanted = 0
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': iExtraEngisWanted after dist check='..iExtraEngisWanted) end
                            end
                        end
                    end
                    local bGetMoreEngis = false
                    if bDebugMessages == true then LOG(sFunctionRef..': iExtraEngisWanted='..iExtraEngisWanted..'; iEngisHave='..iEngisHave..'; iTechLevel='..iTechLevel..'; Mex count of target island='..M28Map.tAllPlateaus[iPlateauToTravelTo][M28Map.subrefPlateauIslandMexCount][iIslandToTravelTo]..'; iEngiRemainingCapacity='..iEngiRemainingCapacity) end
                    if iExtraEngisWanted == 0 and iEngisHave == 0 then
                        M28Utilities.ErrorHandler('Dont have any engis but dont want any, something has gone wrong')
                    elseif iExtraEngisWanted > 0 then
                        oUnit[refiTransportTimeSpentWaiting] = (oUnit[refiTransportTimeSpentWaiting] or 0) + 1
                        --Want to wait for more engineers unless have some already and arent on a core LZ
                        local iCurPlateauOrZero, iCurLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())

                        local tCurLZOrWZTeamData
                        local tCurLZOrWZData
                        if iCurPlateauOrZero > 0 then
                            --Dealing with a land zone so it might have a land factory
                            tCurLZOrWZData = M28Map.tAllPlateaus[iCurPlateauOrZero][M28Map.subrefPlateauLandZones][iCurLandOrWaterZone]
                            tCurLZOrWZTeamData = tCurLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                        else
                            tCurLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurLandOrWaterZone]][M28Map.subrefPondWaterZones][iCurLandOrWaterZone]
                            tCurLZOrWZTeamData = tCurLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iCurPlateauOrZero='..(iCurPlateauOrZero or 'nil')..'; iCurLandOrWaterZone='..(iCurLandOrWaterZone or 'nil')..'; Is this a core base='..tostring(tCurLZOrWZTeamData[M28Map.subrefLZbCoreBase] or false)) end
                        if tCurLZOrWZTeamData[M28Map.subrefLZbCoreBase] or iEngisHave == 0 then
                            bGetMoreEngis = true
                            oUnit[refiEngisWanted] = iExtraEngisWanted
                            --Get more engis
                            if tCurLZOrWZTeamData[M28Map.subrefLZbCoreBase] then

                                if M28UnitInfo.IsUnitValid(oUnit[refoTransportUnitTryingToLoad]) and not(oUnit[refoTransportUnitTryingToLoad]:IsUnitState('Attached')) and oUnit[M28Engineer.refiAssignedAction] == M28Engineer.refActionLoadOntoTransport then
                                    --Do nothing re orders if transport already has an engineer assigned to load onto it (as dont want to override transport orders incase engineers are trying to load onto it)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Already have an engineer assigned to load onto this transport='..oUnit[refoTransportUnitTryingToLoad].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[refoTransportUnitTryingToLoad])..'; Engineer action='..oUnit[M28Engineer.refiAssignedAction]) end
                                else
                                    --Find the closest engineer to us that has an order to load onto a transport, if there is one, otherwise move to the midpoint
                                    local tHoldingLocation
                                    local oClosestLoadingEngineer
                                    local iClosestLoadingEngineerDist = 1000
                                    local iCurEngiDist
                                    local tEngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tCurLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                    for iEngineer, oEngineer in tEngineersInZone do
                                        if M28UnitInfo.IsUnitValid(oEngineer) and oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionLoadOntoTransport and not(oEngineer:IsUnitState('Attached')) then
                                            local tEngineerLastOrder = oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]]
                                            if not(M28UnitInfo.IsUnitValid(tEngineerLastOrder[M28Orders.subrefoOrderUnitTarget])) or tEngineerLastOrder[M28Orders.subrefoOrderUnitTarget] == oUnit or not(EntityCategoryContains(M28UnitInfo.refCategoryTransport, oUnit)) then
                                                iCurEngiDist = M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), oUnit:GetPosition())
                                                if iCurEngiDist < iClosestLoadingEngineerDist then
                                                    iClosestLoadingEngineerDist = iCurEngiDist
                                                    oClosestLoadingEngineer = oEngineer
                                                end
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': iClosestLoadingEngineerDist='..iClosestLoadingEngineerDist..'; oClosestLoadingEngineer='..(oClosestLoadingEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestLoadingEngineer) or 'nil')) end
                                    if oClosestLoadingEngineer then
                                        tHoldingLocation = oClosestLoadingEngineer:GetPosition()
                                        --If we are close to the engineer then instead get the engineer to give an order to load onto this transport, if we dont have such an engineer recorded

                                        if iClosestLoadingEngineerDist <= 12 then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will try and get closest loading engineer to load onto transport, unit state='..M28UnitInfo.GetUnitState(oClosestLoadingEngineer)) end
                                            M28Orders.IssueTrackedTransportLoad(oClosestLoadingEngineer, oUnit, false, 'TrLEng', false)
                                        else
                                            M28Orders.IssueTrackedMove(oUnit, tHoldingLocation, 5,                   false,              'TRlWtE',            false)
                                        end
                                    else
                                        tHoldingLocation = {tCurLZOrWZData[M28Map.subrefMidpoint][1], tCurLZOrWZData[M28Map.subrefMidpoint][2], tCurLZOrWZData[M28Map.subrefMidpoint][3]}
                                        M28Orders.IssueTrackedMove(oUnit, tHoldingLocation, 5,                   false,              'TRlWtE',            false)
                                    end


                                end

                                --However, want to record that we are waiting for an engineer if not already recorded
                                local bRecordAgainstLZ = true
                                if M28Utilities.IsTableEmpty(tCurLZOrWZTeamData[M28Map.reftoTransportsWaitingForEngineers]) == false then
                                    for iRecordedTransport, oRecordedTransport in tCurLZOrWZTeamData[M28Map.reftoTransportsWaitingForEngineers] do
                                        if oRecordedTransport == oUnit then
                                            bRecordAgainstLZ = false
                                        end
                                    end
                                end
                                if bRecordAgainstLZ then
                                    table.insert(tCurLZOrWZTeamData[M28Map.reftoTransportsWaitingForEngineers], oUnit)
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Transport is in core base iCurPlateauOrZero='..(iCurPlateauOrZero or 'nil')..'; iCurLandOrWaterZone='..(iCurLandOrWaterZone or 'nil')..'; is table of transports waiting for engineers empty='..tostring(M28Utilities.IsTableEmpty(tCurLZOrWZTeamData[M28Map.reftoTransportsWaitingForEngineers]))) end
                            else
                                --Want engineers, but not on core base, so move to core base
                                if M28Utilities.IsTableEmpty(tCurLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) then M28Utilities.ErrorHandler('Dont have a closest friendly base for iCurPlateauOrZero='..(iCurPlateauOrZero or 'nil')..'; iCurLandOrWaterZone='..(iCurLandOrWaterZone or 'nil')) end
                                if bDebugMessages == true then LOG(sFunctionRef..': Transport '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' wants engineers but not in core base so will move there iCurPlateauOrZero='..(iCurPlateauOrZero or 'nil')..'; iCurLandOrWaterZone='..(iCurLandOrWaterZone or 'nil')..'; Is transport valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; tCurLZOrWZTeamData[M28Map.reftClosestFriendlyBase]='..repru(tCurLZOrWZTeamData[M28Map.reftClosestFriendlyBase])..'; Unit last order position='..repru(oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition])) end
                                --IssueTrackedMove(oUnit, tOrderPosition,                           iDistanceToReissueOrder, bAddToExistingQueue, sOptionalOrderDesc, bOverrideMicroOrder)
                                M28Orders.IssueTrackedMove(oUnit, tCurLZOrWZTeamData[M28Map.reftClosestFriendlyBase], 10,                   false,              'TWntE',            false)

                            end
                        end

                    end
                    if not(bGetMoreEngis) then
                        oUnit[refiTransportTimeSpentWaiting] = 0
                        --Have enough engineers (or arent on core lZ so dont want to delay by going back for more) - unload at the target land zone
                        oUnit[refiTargetIslandForDrop] = iIslandToTravelTo
                        oUnit[refiTargetZoneForDrop] = iLandZoneToTravelTo or iWaterZoneToTravelTo --must set before calling the transportunload order
                        M28Orders.IssueTrackedTransportUnload(oUnit, tLZOrWZData[M28Map.subrefMidpoint], 10, false, 'TRLZUnlI'..(iIslandToTravelTo or 0)..'Z'..(iLandZoneToTravelTo or iWaterZoneToTravelTo), false)
                        --Set this as an expansion zone if it is in same isalnd (as normal logic wont flag it as an expansion)
                        if bDebugMessages == true then LOG(sFunctionRef..': Just tried to send order for transport to go to iIslandToTravelTo='..iIslandToTravelTo..'; iLandZoneToTravelTo='..iLandZoneToTravelTo..'; LZ midpoint='..repru(tLZOrWZData[M28Map.subrefMidpoint])) end
                        if bTravelToSameIsland then
                            local tTargetLZData =  M28Map.tAllPlateaus[iPlateauToTravelTo][M28Map.subrefPlateauLandZones][iLandZoneToTravelTo]
                            local tLZTeamData = tTargetLZData[M28Map.subrefLZTeamData][iTeam]
                            if not(tLZTeamData[M28Map.subrefLZCoreExpansion]) and (tLZOrWZData[M28Map.subrefLZMexCount] >= 3 or (M28Map.bIsCampaignMap and (M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subreftoUnitsToRepair]) == false or M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subreftoUnitsToCapture]) == false))) then
                                tLZTeamData[M28Map.subrefLZExpansionOverride] = true
                            end
                        end

                        --Remove this location from the shortlist
                        if bTravelToSameIsland then
                            for iEntry, tiPlateauAndLandZone in M28Team.tTeamData[iTeam][M28Team.reftTransportFarAwaySameIslandPlateauLandZoneDropShortlist] do
                                if tiPlateauAndLandZone[2] == iLandZoneToTravelTo then
                                    table.remove(M28Team.tTeamData[iTeam][M28Team.reftTransportFarAwaySameIslandPlateauLandZoneDropShortlist], iEntry)
                                    break
                                end
                            end
                        else
                            for iEntry, tiPlateauAndIsland in M28Team.tTeamData[iTeam][M28Team.reftTransportIslandDropShortlist] do
                                if tiPlateauAndIsland[1] == iPlateauToTravelTo and tiPlateauAndIsland[2] == iIslandToTravelTo then
                                    table.remove(M28Team.tTeamData[iTeam][M28Team.reftTransportIslandDropShortlist], iEntry)
                                    break
                                end
                            end
                        end
                    end

                else
                    if bDebugMessages == true then LOG(sFunctionRef..': We dont have island to travel to so unload unless transport already on its way and might be justified') end
                    --Do we have engineers loaded? if so then unload
                    local tCargo = oUnit:GetCargo()
                    if M28Utilities.IsTableEmpty(tCargo) == false then
                        --Consider proceeding
                        local tLastOrder = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]]
                        local bUnloadAtRallyOrOtherZone = true
                        local bDropDueToAirAA = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Last order='..reprs(tLastOrder)..'; Is last order tyep unoad transport='..tostring(tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderUnloadTransport)) end
                        if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderUnloadTransport then
                            --Consider dropping immediately due to enemy AirAA threat
                            local tCurZoneData, tCurZoneTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                            if bDebugMessages == true then LOG(sFunctionRef..': enemy AirAA threat in this zone='..(tCurZoneTeamData[M28Map.refiEnemyAirAAThreat] or 0)) end
                            if (tCurZoneTeamData[M28Map.refiEnemyAirAAThreat] or 0) > 0 and (NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oUnit:GetPosition()) or 0) > 0 and M28Utilities.IsTableEmpty(tCurZoneTeamData[M28Map.reftLZEnemyAirUnits]) == false then
                                local iAirAAThreshold = math.max(10, ((oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) - 60) * 0.3 * M28UnitInfo.GetUnitHealthPercent(oUnit))
                                if tCurZoneTeamData[M28Map.refiEnemyAirAAThreat] > iAirAAThreshold then

                                    --Check for nearby enemy airaa units by distance
                                    local iClosestEnemyAirAA = 10000
                                    for iEnemy, oEnemy in tCurZoneTeamData[M28Map.reftLZEnemyAirUnits] do
                                        if M28UnitInfo.IsUnitValid(oEnemy) and EntityCategoryContains(M28UnitInfo.refCategoryAirAA, oEnemy.UnitId) then
                                            iClosestEnemyAirAA = math.min(iClosestEnemyAirAA, M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition()))
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will consider dropping transport early, special micro active='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive])..'; Dist to cur unload destination='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLastOrder[M28Orders.subreftOrderPosition])..'; Last order detsination pre update='..repru(tLastOrder[M28Orders.subreftOrderPosition])..'; iClosestEnemyAirAA='..iClosestEnemyAirAA) end
                                    if iClosestEnemyAirAA <= 35 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Dropping early as enemy has AirAA') end
                                        M28Orders.IssueTrackedTransportUnload(oUnit, oUnit:GetPosition(), 8, false, 'EmergDr', false)
                                        bDropDueToAirAA = true
                                        bUnloadAtRallyOrOtherZone = false
                                    end
                                end
                            end
                            if not(bDropDueToAirAA) then
                                local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLastOrder[M28Orders.subreftOrderPosition])
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to drop due to target being dangerous, iDistToTarget='..iDistToTarget) end
                                if iDistToTarget <= 30 then
                                    --Might as well unload - significant risk we just die if we return by this stage anyway
                                    bUnloadAtRallyOrOtherZone = false
                                elseif iDistToTarget <= 250 then
                                    local tTargetLZOrWZData, tTargetLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(tLastOrder[M28Orders.subreftOrderPosition], true, iTeam)
                                    local iCargoSize = table.getn(tCargo)
                                    if (tTargetLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) - (tTargetLZOrWZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0) < iCargoSize * 30 then
                                        bUnloadAtRallyOrOtherZone = false
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': iCargoSize='..iCargoSize..'; Enemy combat threat='..tTargetLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; bUnloadAtRallyOrOtherZone='..tostring(bUnloadAtRallyOrOtherZone)) end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Have a cargo, bUnloadAtRallyOrOtherZone='..tostring(bUnloadAtRallyOrOtherZone)..'; Last order destination='..repru(tLastOrder[M28Orders.subreftOrderPosition])) end
                        if bUnloadAtRallyOrOtherZone then
                            --If far from rally then look for nearest zone to unload at
                            local iTransportPlateauOrZero, iTransportLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                            local tTransportLZOrWZData, tTransportLZOrWZTeamData
                            if iTransportLandOrWaterZone then
                                if iTransportPlateauOrZero == 0 then
                                    tTransportLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iTransportLandOrWaterZone]][M28Map.subrefPondWaterZones][iTransportLandOrWaterZone]
                                    tTransportLZOrWZTeamData = tTransportLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                                else
                                    tTransportLZOrWZData = M28Map.tAllPlateaus[iTransportPlateauOrZero][M28Map.subrefPlateauLandZones][iTransportLandOrWaterZone]
                                    tTransportLZOrWZTeamData = tTransportLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                                end
                                if tTransportLZOrWZTeamData[M28Map.subrefLZbCoreBase] then
                                    M28Orders.IssueTrackedTransportUnload(oUnit, oUnit:GetPosition(), 10, false, 'TRUnlBas', false)
                                elseif M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tRallyPoint) <= 50 then
                                    M28Orders.IssueTrackedTransportUnload(oUnit, tRallyPoint, 10, false, 'TRUnlR', false)
                                else
                                    --Find the nearest zone wanting engineers (or unload at rally point if cant find any
                                    local tMidpointToUnloadAt
                                    RecordOtherLandAndWaterZonesByDistance(tTransportLZOrWZData, tTransportLZOrWZData[M28Map.subrefMidpoint])
                                    if M28Utilities.IsTableEmpty(tTransportLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                                        local tTargetLZOrWZData, tTargetLZOrWZTeamData
                                        for iEntry, tSubtable in tTransportLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                                            if tSubtable[M28Map.subrefbIsWaterZone] then
                                                tTargetLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[tSubtable[M28Map.subrefiLandOrWaterZoneRef]]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                                tTargetLZOrWZTeamData = tTargetLZOrWZData[M28Map.subrefWZTeamData][iTeam]

                                            else
                                                tTargetLZOrWZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                                tTargetLZOrWZTeamData = tTargetLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                                            end
                                            if tTargetLZOrWZTeamData[M28Map.subrefTbWantBP] and (tTargetLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) <= 20 and M28Utilities.IsTableEmpty(tTargetLZOrWZTeamData[M28Map.reftoNearestCombatEnemies]) then
                                                tMidpointToUnloadAt = {tTargetLZOrWZData[M28Map.subrefMidpoint][1], tTargetLZOrWZData[M28Map.subrefMidpoint][2], tTargetLZOrWZData[M28Map.subrefMidpoint][3]}
                                                break
                                            end
                                        end
                                    end
                                    if M28Utilities.IsTableEmpty(tMidpointToUnloadAt) == false then
                                        M28Orders.IssueTrackedTransportUnload(oUnit, tMidpointToUnloadAt, 10, false, 'TRUnlZ', false)
                                    else
                                        --No zones wanting engineers so unload at rally point
                                        M28Orders.IssueTrackedTransportUnload(oUnit, tRallyPoint, 10, false, 'TRUnlB1', false)
                                    end
                                end
                            end
                        elseif not(bDropDueToAirAA) then
                            --Cant identify where we are, go to last unnload position if we have one (to avoid getting stuck in a loop), otherwise go to rally
                            if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderUnloadTransport then
                                M28Orders.IssueTrackedTransportUnload(oUnit, tLastOrder[M28Orders.subreftOrderPosition], 10, false, 'TRUnlB2', false)
                            else
                                M28Orders.IssueTrackedTransportUnload(oUnit, tRallyPoint, 10, false, 'TRUnlB3', false)
                            end
                        end
                    else
                        --Go to rally point
                        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 10, false, 'TIdle', false)
                    end
                end
            end
        end
    end
    if M28Utilities.IsTableEmpty(tTransportsForRefueling) == false then
        for iUnit, oUnit in tTransportsForRefueling do
            --confirm no cargo
            local tCargo = oUnit:GetCargo()
            if M28Utilities.IsTableEmpty(tCargo) == false then
                M28Orders.IssueTrackedTransportUnload(oUnit, tRallyPoint, 10, false, 'TRFalUnl', false)
            else
                if M28Utilities.GetDistanceBetweenPositions(tRallyPoint, oUnit:GetPosition()) <= 30 and (not(oUnit[M28UnitInfo.refbCampaignTriggerAdded]) or not(M28Map.bIsCampaignMap)) and not(EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId)) then --(exp exclusion is a redundancy, shoudlnt get to this point)
                    ForkThread(M28Micro.MoveAndKillAirUnit,oUnit)
                    --M28Orders.IssueTrackedKillUnit(oUnit)
                else
                    --Go to rally point
                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 10, false, 'TIdle', false)
                end
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageNovax(iTeam, iAirSubteam)
    --Wont bother with normal air availability since arent interested in fuel or health
    local iPlateauOrZero, iLandOrWaterZone
    for iBrain, oBrain in M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains] do
        if oBrain.M28AI then
            local tCurUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategorySatellite, false, true)
            for iUnit, oUnit in tCurUnits do
                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() >= 1 then
                    --Refresh positions of enemies in the zone the novax is in
                    iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                    local tLZOrWZTeamData
                    if iLandOrWaterZone > 0 then
                        if iPlateauOrZero == 0 then
                            --Water zone
                            tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
                            if GetGameTimeSeconds() - (tLZOrWZTeamData[M28Map.subrefiTimeOfLastEnemyUnitPosUpdate] or -100) >= 2 then
                                --UpdateUnitPositionsAndWaterZone(aiBrain, tUnits,                              iTeam, iRecordedWaterZone, bUseLastKnownPosition, bAreAirUnits, tWZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
                                M28Navy.UpdateUnitPositionsAndWaterZone(oBrain, tLZOrWZTeamData[M28Map.subrefTEnemyUnits], iTeam, iLandOrWaterZone, false,                  false,      tLZOrWZTeamData, true,                              true)
                            end
                        else
                            tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
                            if GetGameTimeSeconds() - (tLZOrWZTeamData[M28Map.subrefiTimeOfLastEnemyUnitPosUpdate] or -100) >= 2 then
                                --UpdateUnitPositionsAndLandZone(aiBrain, tUnits,                                  iTeam, iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
                                M28Land.UpdateUnitPositionsAndLandZone(oBrain, tLZOrWZTeamData[M28Map.subrefTEnemyUnits], iTeam, iPlateauOrZero, iLandOrWaterZone, false,                   false, tLZOrWZTeamData,     true,                                   true)
                            end
                        end
                    end
                    ForkThread(NovaxCoreTargetLoop, oBrain, oUnit)
                end
            end
        end
    end
end

function NovaxCoreTargetLoop(aiBrain, oNovax, bCalledFromUnitDeath)
    --Used so can do forkthread of this in case come across errors
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'NovaxCoreTargetLoop'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28UnitInfo.IsUnitValid(oNovax) then

        --If called from a unit dying only get a new target if the novax has an attack order on a unit
        local bGetNewTarget = true
        if bCalledFromUnitDeath and oNovax[M28Orders.refiOrderCount] > 0 then
            bGetNewTarget = false
            local tLastOrder = oNovax[M28Orders.reftiLastOrders][oNovax[M28Orders.refiOrderCount]]
            if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAttack then
                bGetNewTarget = true
            end
        end
        if bGetNewTarget then

            local iEffectiveRange = math.max(20, oNovax:GetBlueprint().Weapon[1].MaxRadius) + 10
            local oTarget

            local iOrderType
            local refiLastIssuedOrderType = 'M28NovaxLastOrderType'
            local refoLastIssuedOrderUnit = 'M28NovaxLastOrderUnit'
            local reftLastIssuedOrderLocation = 'M28NovaxLastOrderLocation'
            local refOrderAttack = 1
            local refOrderMove = 2
            oTarget = GetNovaxTarget(aiBrain, oNovax)
            oNovax[refoNovaxLastTarget] = oTarget
            if oTarget then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': GameTime='..GetGameTimeSeconds()..'; Have a target ' .. oTarget.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oTarget) .. '; will decide whether to attack or move to it; Distance to target=' .. M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), oNovax:GetPosition()))
                end
                if M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), oNovax:GetPosition()) > iEffectiveRange then
                    iOrderType = refOrderMove
                else
                    iOrderType = refOrderAttack
                end

                if iOrderType == refOrderMove then
                    M28Orders.IssueTrackedMove(oNovax, oTarget:GetPosition(), 8, false, 'NVMv', false)
                else
                    M28Orders.IssueTrackedAttack(oNovax, oTarget, false, 'NVAtc', false)
                end
            else
                if bDebugMessages == true then LOG(sFunctionRef .. ': No target so move to enemy base') end

                --No target so move towards enemy base
                M28Orders.IssueTrackedMove(oNovax, M28Map.GetPrimaryEnemyBaseLocation(aiBrain), 8, false, 'NVBsMv', false)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetEnemyUnitsInCurrentAndAdjacentZonesOfCategory(iStartPlateauOrZero, tStartLZOrWZData, tStartLZOrWZTeamData, iTeam, iOptionalCategory)
    --iOptionalCategoyr - if nil will just return all units
    local tUnitsOfCategory = {}
    function AddUnitsFromZoneTeamData(tLZOrWZTeamData)
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) == false then
            local tZoneUnitsOfCategory
            if iOptionalCategory then tZoneUnitsOfCategory = EntityCategoryFilterDown(iOptionalCategory, tLZOrWZTeamData[M28Map.subrefTEnemyUnits])
            else tZoneUnitsOfCategory = tLZOrWZTeamData[M28Map.subrefTEnemyUnits]
            end
            if M28Utilities.IsTableEmpty(tZoneUnitsOfCategory) == false then
                for iUnit, oUnit in tZoneUnitsOfCategory do
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        table.insert(tUnitsOfCategory, oUnit)
                    end
                end
            end
        end
    end
    AddUnitsFromZoneTeamData(tStartLZOrWZTeamData)
    if iStartPlateauOrZero == 0 then
        if M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefAdjacentLandZones]) == false then
            for iEntry, tSubtable in tStartLZOrWZData[M28Map.subrefAdjacentLandZones] do
                AddUnitsFromZoneTeamData(M28Map.tAllPlateaus[tSubtable[M28Map.subrefWPlatAndLZNumber][1]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefWPlatAndLZNumber][2]][M28Map.subrefLZTeamData][iTeam])
            end
        end
        if M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
            for iEntry, iWaterZone in tStartLZOrWZData[M28Map.subrefWZAdjacentWaterZones] do
                AddUnitsFromZoneTeamData(M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][iTeam])
            end
        end
    else
        --Dealing with land zone
        if M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for iEntry, iLandZone in tStartLZOrWZData[M28Map.subrefLZAdjacentLandZones] do
                AddUnitsFromZoneTeamData(M28Map.tAllPlateaus[iStartPlateauOrZero][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam])
            end
        end
        if M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefAdjacentWaterZones]) == false then
            for iEntry, tSubtable in tStartLZOrWZData[M28Map.subrefAdjacentWaterZones] do
                AddUnitsFromZoneTeamData(M28Map.tPondDetails[M28Map.tiPondByWaterZone[tSubtable[M28Map.subrefAWZRef]]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefAWZRef]][M28Map.subrefWZTeamData][iTeam])
            end
        end
    end
    return tUnitsOfCategory
end

function GetNovaxTarget(aiBrain, oNovax)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNovaxTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local oTarget
    local iTeam = aiBrain.M28Team
    local iStartPlateauOrZero, iStartLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oNovax:GetPosition())
    local tStartLZOrWZData
    local tStartLZOrWZTeamData
    if iStartPlateauOrZero == 0 then
        tStartLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iStartLandOrWaterZone]][M28Map.subrefPondWaterZones][iStartLandOrWaterZone]
        tStartLZOrWZTeamData = tStartLZOrWZData[M28Map.subrefLZTeamData][iTeam]
    else
        tStartLZOrWZData =  M28Map.tAllPlateaus[iStartPlateauOrZero][M28Map.subrefPlateauLandZones][iStartLandOrWaterZone]
        tStartLZOrWZTeamData = tStartLZOrWZData[M28Map.subrefLZTeamData][iTeam]
    end

    --Get list of significant enemy shielding (will ignore targets under these shields)
    local iMediumSearchRange = 53
    local tNearbyEnemyShields = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryShieldBoat + M28UnitInfo.refCategoryMobileLandShield * categories.TECH3 - M28UnitInfo.refCategoryFatboy, oNovax:GetPosition(), iMediumSearchRange + 60, 'Enemy') --shield boats have a size of 120 so a radius of 60, so want to include max enemy search range (iMediumSearchRange) plus this, to make sure all shields are taken into account
    --tNearbyEnemyShields = GetEnemyUnitsInCurrentAndAdjacentZonesOfCategory(iStartPlateauOrZero, tStartLZOrWZData, tStartLZOrWZTeamData, iTeam, M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryShieldBoat + M28UnitInfo.refCategoryMobileLandShield * categories.TECH3)
    local tNotLowHealthNearbyShields = {}
    local tMobileShieldsToCheck = {}
    local tNearbyNovax = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategorySatellite, oNovax:GetPosition(), 30, 'Ally')
    local iNearbyNovax = table.getn(tNearbyNovax)
    local iShieldHealthThreshold = 3000 * iNearbyNovax
    if M28Utilities.IsTableEmpty(tNearbyEnemyShields) == false then
        local iCurShield, iMaxShield
        for iUnit, oUnit in tNearbyEnemyShields do
            iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, false)
            if iCurShield >= iShieldHealthThreshold and not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                table.insert(tNotLowHealthNearbyShields, oUnit)
                if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then
                    table.insert(tMobileShieldsToCheck, oUnit)
                end
            end

        end
    end
    local bHaveShieldsToCheck = not(M28Utilities.IsTableEmpty(tNotLowHealthNearbyShields))

    function DoShieldsCoverUnit(oTargetUnit, oOptionalShieldToIgnore, bUseDetailedShieldCheck, iOptionalThresholdOverride)
        local tPosition = oTargetUnit:GetPosition()
        if bUseDetailedShieldCheck or EntityCategoryContains(M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryFixedShield, oTargetUnit.UnitId) then
            local bUnderFixedShield = M28Logic.IsTargetUnderShield(aiBrain, oTargetUnit, iOptionalThresholdOverride or iShieldHealthThreshold, false, true, false, true)
            if bDebugMessages == true then LOG(sFunctionRef..': Will use istargetundershield function for this unit, bUnderFixedShield='..tostring(bUnderFixedShield or false)) end
            if bUnderFixedShield then
                return true
            elseif M28Utilities.IsTableEmpty(tMobileShieldsToCheck) == false then
                for iUnit, oUnit in tMobileShieldsToCheck do
                    if M28Utilities.GetDistanceBetweenPositions(tPosition, oUnit:GetPosition()) <= oUnit:GetBlueprint().Defense.Shield.ShieldSize * 0.5 then
                        return true
                    end
                end
            end
        elseif bHaveShieldsToCheck then
            for iUnit, oUnit in tNotLowHealthNearbyShields do
                if not(oUnit == oOptionalShieldToIgnore) then
                    if M28Utilities.GetDistanceBetweenPositions(tPosition, oUnit:GetPosition()) <= oUnit:GetBlueprint().Defense.Shield.ShieldSize * 0.5 then
                        return true
                    end
                end
            end
        end
        return false
    end

    --Check for priority override (but still consider shields and ACU even if have a priority target)
    if bDebugMessages == true then LOG(sFunctionRef .. ': Time='..GetGameTimeSeconds()..'; Is there a valid target override set=' .. tostring(oNovax[refoPriorityTargetOverride]) .. '; Time since last override=' .. GetGameTimeSeconds() - (oNovax[refiTimeOfLastOverride] or -100)) end
    if M28UnitInfo.IsUnitValid(oNovax[refoPriorityTargetOverride]) and (GetGameTimeSeconds() - oNovax[refiTimeOfLastOverride]) <= 11 then

        --Are there any near-exposed shields nearby? Then target them instead

        if bDebugMessages == true then LOG(sFunctionRef .. ': is table of nearby shields empty=' .. tostring(M28Utilities.IsTableEmpty(tNearbyEnemyShields)) .. '; target subject to this=' .. oNovax[refoPriorityTargetOverride].UnitId .. M28UnitInfo.GetUnitLifetimeCount(oNovax[refoPriorityTargetOverride])) end
        if M28Utilities.IsTableEmpty(tNearbyEnemyShields) == false then
            local iCurShield, iMaxShield
            local iLowestShield = 4000 + 1000 * iNearbyNovax
            local iMaxShieldPercent = (0.3 + math.min(0.4, iNearbyNovax * 0.1))
            for iUnit, oUnit in tNearbyEnemyShields do
                iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to target enemy near-exposed shield, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurShield='..iCurShield..'; iMaxShield='..iMaxShield) end
                if iCurShield <= iLowestShield and iCurShield <= iMaxShield * iMaxShieldPercent then
                    if not (M28Logic.IsTargetUnderShield(aiBrain, oUnit, iLowestShield + 1,                     false,                      false,                  false)) then
                        oTarget = oUnit
                        iLowestShield = iCurShield
                        if bDebugMessages == true then LOG(sFunctionRef .. ': Nearby shield with low health, setting oTarget=' .. oTarget.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oTarget)) end
                    end
                end
            end
        end
        if not(oTarget) then
            --Is there an expoesd enemy ACU that we can kill instead?
            if ScenarioInfo.Options.Victory == "demoralization" then
                local iRange = math.max(20, oNovax:GetBlueprint().Weapon[1].MaxRadius)
                local tNearbyACUs = GetEnemyUnitsInCurrentAndAdjacentZonesOfCategory(iStartPlateauOrZero, tStartLZOrWZData, tStartLZOrWZTeamData, iTeam, categories.COMMAND)
                local iDPS = 243

                if M28Utilities.IsTableEmpty(tNearbyACUs) == false then
                    local iShortestTimeToKillTarget = 60 --Wont consider ACUs where will take more than this time to kill them
                    local iTimeToKillTarget
                    local iCurDPSMod = 0
                    for iACU, oACU in tNearbyACUs do
                        iTimeToKillTarget = 10000
                        if not(oACU:IsUnitState('Attached')) and not(M28Map.IsUnderwater(oACU:GetPosition())) then --Even if ACU slightly above water watn to ignore since it could probably easily get underwater
                            local iACUCurShield, iACUMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oACU)
                            iCurDPSMod = -M28UnitInfo.GetACUShieldRegenRate(oACU) - M28UnitInfo.GetUnitHealthRegenRate(oACU)
                            local iACUHealth = oACU:GetHealth() + iACUCurShield
                            if -iCurDPSMod < iCurDPSMod then
                                iTimeToKillTarget = iACUHealth / (iDPS + iCurDPSMod)
                                if iTimeToKillTarget > 0 and  iTimeToKillTarget < iShortestTimeToKillTarget then
                                    --Are there nearby shields?
                                    if not(DoShieldsCoverUnit(oACU, nil, true)) then
                                        iShortestTimeToKillTarget = iTimeToKillTarget
                                        oTarget = oACU
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iShortestTimeToKillTarget='..iShortestTimeToKillTarget..'; is oTarget valid='..tostring(M28UnitInfo.IsUnitValid(oTarget))) end
                end
            end

            if not(oTarget) then
                --Target the priority override
                oTarget = oNovax[refoPriorityTargetOverride]
            end
        end
    end

    if not (oTarget) then
        --Normal targeting logic - see M28 devlog and xls for logic behind some of this
        local iRange = math.max(20, oNovax:GetBlueprint().Weapon[1].MaxRadius)
        local iSpeed = oNovax:GetBlueprint().Physics.MaxSpeed
        local iTimeToTarget
        local iTimeToKillTarget
        local iDPS = 243
        local iCurDPSMod
        local iBestTargetValue = 105
        local iBestValueWithNoThreshold = 0
        local oBestTargetWithNoThreshold
        local iCurValue
        local iCategoriesToSearch
        local iMassFactor
        local iCurShield, iMaxShield
        local tPositionToSearchFrom = oNovax:GetPosition()
        local iNearestShield, iCurShieldDistance, iNearestWater, tPossiblePosition, tPossibleShields, iACUSpeed, iCurAmphibiousGroup

        local tEnemyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategoryStructure, tPositionToSearchFrom, iMediumSearchRange, 'Enemy')
        if not(tEnemyUnits) then tEnemyUnits = {} end
        --GetEnemyUnitsInCurrentAndAdjacentZonesOfCategory(iStartPlateauOrZero, tStartLZOrWZData, tStartLZOrWZTeamData, iTeam, nil)
        local bIncreaseMAAWeighting = false
        if M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiOurGunshipThreat] >= 5000 and not(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir]) and (M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl] or M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiOurGunshipThreat] >= 30000) then bIncreaseMAAWeighting = true end
        function GetUnitTypeMassWeighting(oUnit)
            if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryMobileLandShield + M28UnitInfo.refCategoryShieldBoat, oUnit.UnitId) then
                return 4
            elseif EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oUnit.UnitId) then
                return 5
            elseif EntityCategoryContains(M28UnitInfo.refCategoryT2Mex, oUnit.UnitId) then
                return 2
            elseif EntityCategoryContains(M28UnitInfo.refCategoryT3Mex, oUnit.UnitId) then
                return 1.5
            elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and ScenarioInfo.Options.Victory == "demoralization" then
                return 3
            elseif EntityCategoryContains(categories.VOLATILE * categories.STRUCTURE + categories.VOLATILE * categories.LAND, oUnit.UnitId) and oUnit.GetFractionComplete and oUnit:GetFractionComplete() == 1 then
                return 2
                --Adjustments for certain categories to just bring them above iBestTargetValue starting threshold
            elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                return 1.35
            elseif bIncreaseMAAWeighting and EntityCategoryContains(M28UnitInfo.refCategoryGroundAA, oUnit.UnitId) then
                return 1.5
            elseif EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId) then
                if oUnit.MyShield.GetHealth and oUnit.MyShield:GetHealth() <= 3000 then
                    return 1.5
                else return 1.25
                end
            else
                return 1
            end
        end
        local oUnitBP
        --Add current target to enemy units to be considered if it's still valid (wont worry about duplication); originally was essential when doing the 'include adjacent zone units' approach, but now is more of a redundancy for if the novax moves just too far away while circling a target
        if bDebugMessages == true then LOG(sFunctionRef..'; Considering if last novax target still valid, oNovax[refoNovaxLastTarget]='..(oNovax[refoNovaxLastTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNovax[refoNovaxLastTarget]) or 'nil')..'; Is valid='..tostring(M28UnitInfo.IsUnitValid(oNovax[refoNovaxLastTarget]))) end
        if M28UnitInfo.IsUnitValid(oNovax[refoNovaxLastTarget]) then table.insert(tEnemyUnits, oNovax[refoNovaxLastTarget]) end

        local iFractionComplete
        local toUnshieldedNearbyFixedShields = {}
        for iUnit, oUnit in tEnemyUnits do
            --Ignore units that are mobile and attached, or underwater
            if bDebugMessages == true then LOG(sFunctionRef .. ': Considering enemy unit ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. '; Unit state=' .. M28UnitInfo.GetUnitState(oUnit) .. '; Does it contain mobile category=' .. tostring(EntityCategoryContains(categories.MOBILE, oUnit.UnitId)) .. '; is it underwater=' .. tostring(M28UnitInfo.IsUnitUnderwater(oUnit)) .. '; Is it under shield=' .. tostring(DoShieldsCoverUnit(oUnit, oUnit))..'; Unti AIBrain owner='..oUnit:GetAIBrain().Nickname..' with index '..oUnit:GetAIBrain():GetArmyIndex()..'; Dist to unit='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNovax:GetPosition())) end
            if not (oUnit:IsUnitState('Attached') and EntityCategoryContains(categories.MOBILE, oUnit.UnitId)) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                --Ignore units that are shielded
                if not (DoShieldsCoverUnit(oUnit, oUnit)) or (EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId) and (oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][1] or 0) > 0 and (M28Map.tAllPlateaus[oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][1]][M28Map.subrefPlateauLandZones][oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][2]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatEnemyShield] or 0) == 0) then
                    iMassFactor = GetUnitTypeMassWeighting(oUnit)
                    oUnitBP = oUnit:GetBlueprint()
                    iCurDPSMod = 0
                    iCurValue = (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * iMassFactor
                    iFractionComplete = oUnit:GetFractionComplete()
                    if iFractionComplete < 0.9 then
                        if iFractionComplete < 0.2 or not(EntityCategoryContains(categories.SHIELD + categories.PERSONALSHIELD, oUnit.UnitId)) then
                            iCurValue = iCurValue * iFractionComplete
                        end
                    end
                    if oUnitBP.Defense.Shield and M28UnitInfo.IsUnitShieldEnabled(oUnit) then
                        if oUnit.MyShield.GetHealth and oUnit.MyShield:GetHealth() > 0 then
                            iCurDPSMod = oUnitBP.Defense.Shield.ShieldRegenRate
                            if not (iCurDPSMod) then
                                if EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oUnit.UnitId) then
                                    iCurDPSMod = M28UnitInfo.GetACUShieldRegenRate(oUnit)
                                    if (iCurDPSMod or 0) == 0 then
                                        M28Utilities.ErrorHandler('For some reason the unit has a shield with health but no regen rate; oUnit=' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit), nil, true)
                                        iCurDPSMod = 0
                                    end
                                else
                                    M28Utilities.ErrorHandler('For some reason the unit has a shield with health but no regen rate; oUnit=' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit), nil, true)
                                    iCurDPSMod = 0
                                end
                            end
                        else
                            iCurDPSMod = 0
                        end
                    else
                        iCurDPSMod = 0
                    end
                    iCurDPSMod = iCurDPSMod + (oUnitBP.Defense.RegenRate or 0)
                    iTimeToTarget = math.max(0, M28Utilities.GetDistanceBetweenPositions(oNovax:GetPosition(), oUnit:GetPosition()) - iRange) / iSpeed
                    iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit)

                    if iMaxShield >= 6000 and iCurShield == 0 and oUnit:GetHealth() < 1000 then
                        if not(DoShieldsCoverUnit(oUnit, oUnit, true, 100)) then
                            table.insert(toUnshieldedNearbyFixedShields, oUnit)
                            iCurValue = iCurValue * 2
                        end
                    end

                    iTimeToKillTarget = (oUnit:GetHealth() + iCurShield + math.min(iMaxShield - iCurShield, iTimeToTarget * iCurDPSMod)) / math.max(0.001, iDPS - iCurDPSMod)
                    if iMaxShield == 0 and not (EntityCategoryContains(categories.COMMAND, oUnit.UnitId)) then
                        --If target is already in firing range then prioritise low health units; if its outside firing range then instead prioritise higher health units (that are worth a detour to kill)
                        if iTimeToTarget > 0 then
                            iCurValue = iCurValue * math.max(M28UnitInfo.GetUnitHealthPercent(oUnit), 0.25)
                        elseif oUnit:GetMaxHealth() >= 600 then
                            iCurValue = iCurValue * (1 + 0.2 * (1-M28UnitInfo.GetUnitHealthPercent(oUnit)))
                        end
                    end
                    iCurValue = iCurValue / math.max(1.5, iTimeToTarget * 0.9 + iTimeToKillTarget)


                    --Massively adjust mass factor if dealing with nearby ACU that can kill before it gets to safety
                    if iCategoriesToSearch == categories.COMMAND and (iTimeToTarget + iTimeToKillTarget) < 60 and (iMaxShield + oUnit:GetMaxHealth()) <= 25000 then
                        iACUSpeed = oUnitBP.Physics.MaxSpeed
                        --Get nearest shield
                        iNearestShield = 10000
                        tPossibleShields = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedShield, oUnit:GetPosition(), 102, 'Enemy')
                        --Dont do mobile shields since risk thinking no mobile shields, then revealing them and aborting attack, then losing intle on the mobile shield and repeating attack; so better to just attack if there's a mobile shield
                        if M28Utilities.IsTableEmpty(tPossibleShields) == false then
                            for iShield, oShield in tPossibleShields do
                                iCurShieldDistance = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oUnit:GetPosition()) - oShield:GetBlueprint().Defense.Shield.ShieldSize * 0.5
                                if iCurShieldDistance < iNearestShield then
                                    iNearestShield = iCurShieldDistance
                                end
                            end
                        end
                        --Could the ACU get under a shield before it dies?
                        if bDebugMessages == true then LOG(sFunctionRef .. ': Have a nearby ACU target, will consider if we can kill it before it gets to safety; iNearestShield=' .. iNearestShield .. '; iACUSpeed=' .. iACUSpeed) end
                        if iNearestShield / iACUSpeed > iTimeToKillTarget then

                            iNearestWater = nil
                            if iStartPlateauOrZero > 0 and M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefAdjacentWaterZones]) then
                                iNearestWater = 10000
                            else
                                --Where is the nearest water to the ACU
                                iCurAmphibiousGroup = NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, oUnit:GetPosition())
                                for iDistance = 20, 100, 20 do
                                    for iAngle = 0, 315, 45 do
                                        tPossiblePosition = M28Utilities.MoveInDirection(oUnit:GetPosition(), iAngle, iDistance, true, false, true)
                                        tPossiblePosition[2] = GetTerrainHeight(tPossiblePosition[1], tPossiblePosition[3])
                                        if M28Map.IsUnderwater(tPossiblePosition) then
                                            --Can the enemy ACU path here?
                                            if NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, tPossiblePosition) == iCurAmphibiousGroup then
                                                iNearestWater = iDistance
                                                break
                                            end
                                        end
                                    end
                                    if iNearestWater then
                                        break
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef .. ': iNearestWater=' .. (iNearestWater or 'nil')) end
                            if (iNearestWater or 10000) / iACUSpeed > iTimeToKillTarget then
                                iCurValue = iCurValue * 30
                                if bDebugMessages == true then LOG(sFunctionRef .. ': Think we can kill the ACU so massively increasing the curvalue to ' .. iCurValue) end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef .. ' Unit ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. ' iCurValue=' .. iCurValue .. '; iTimeToTarget=' .. iTimeToTarget .. '; iTimeToKillTarget=' .. iTimeToKillTarget .. '; iCurShield=' .. iCurShield .. '; iMaxShield=' .. iMaxShield .. '; iCurDPSMod=' .. iCurDPSMod) end
                    if iCurValue > iBestTargetValue then
                        if bDebugMessages == true then LOG(sFunctionRef .. ': Have a new best target, iBestTargetValue=' .. iBestTargetValue .. '; Target=' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                        iBestTargetValue = iCurValue
                        oTarget = oUnit
                    elseif not(oTarget) and iCurValue > iBestValueWithNoThreshold then
                        iBestValueWithNoThreshold = iCurValue
                        oBestTargetWithNoThreshold = oUnit
                    end
                elseif bDebugMessages == true then
                    LOG(sFunctionRef .. ': Target unit ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. ' is underwater or under a shield')
                end
            end
        end
        if oTarget and M28Utilities.IsTableEmpty(toUnshieldedNearbyFixedShields) == false and not(oTarget.MyShield) then
            if bDebugMessages == true then LOG(sFunctionRef..': Considering switching from actual best target to a vulnerable nearby shield') end
            local iClosestShieldDist = 10000
            local iCurShieldDist
            for iUnit, oUnit in toUnshieldedNearbyFixedShields do
                iCurShieldDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNovax:GetPosition())
                if iCurShieldDist < iClosestShieldDist then
                    iClosestShieldDist = iCurShieldDist
                    oTarget = oUnit
                    if bDebugMessages == true then LOG(sFunctionRef..': Switching target to oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                end
            end
        end

        --If shields have recently dropped to T3 arti and the unit is far enough away that it wont have been considered from the above, then consider targeting (unless we are already targeting a fixed shield or ACU)
        local oNearestRecentlyFailedShield
        local iNearestRecentlyFailedShieldDist = 100000
        if (not(oTarget) or not(EntityCategoryContains(M28UnitInfo.refCategoryFixedShield + categories.COMMAND + M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti, oTarget.UnitId))) then
            local tiUnitsToRemove = {}
            local iCurDist
            local bAdjustValueForDistance = false
            local bAssignedPriorityShield = false

            function ConsiderTableOfPriorityUnits(tTableOfUnits, iPriorityShieldSearchDist)
                for iUnit, oUnit in tTableOfUnits do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering priority unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Health of shield='..oUnit.MyShield:GetHealth()..'; Dist to novax='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNovax:GetPosition())..'; Do shields cover this shield='..tostring((DoShieldsCoverUnit(oUnit, oUnit)))..'; iBestTargetValue='..iBestTargetValue) end
                    if oUnit.MyShield and oUnit.MyShield:GetHealth() >= 3000 then
                        table.insert(tiUnitsToRemove, iUnit)
                    elseif oUnit:GetFractionComplete() == 1 then
                        --Is the unit outside of the search range from above, but still close enoguh that we want to consider?
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNovax:GetPosition())
                        if iCurDist < iNearestRecentlyFailedShieldDist and oUnit.MyShield:GetHealth() == 1 then
                            iNearestRecentlyFailedShieldDist = iCurDist
                            oNearestRecentlyFailedShield = oUnit
                        end
                        if iCurDist > iMediumSearchRange and iCurDist < iPriorityShieldSearchDist then
                            --Is the unit covered by another shield?
                            if not (DoShieldsCoverUnit(oUnit, oUnit)) then
                                iMassFactor = GetUnitTypeMassWeighting(oUnit)
                                iCurValue = (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) * iMassFactor
                                --Want to get the closest recently dropped sheidl (in case more than one)
                                if bAdjustValueForDistance then iCurValue = iCurValue * (0.5 + (1-iCurDist / iPriorityShieldSearchDist)) end
                                if bDebugMessages == true then LOG(sFunctionRef..': Recently dropped shield iCurValue='..iCurValue) end
                                if iCurValue > iBestTargetValue then
                                    if not(bAdjustValueForDistance) then
                                        bAdjustValueForDistance = true
                                        iCurValue = iCurValue * (0.5 + (1-iCurDist / iPriorityShieldSearchDist))
                                    end
                                    iBestTargetValue = iCurValue
                                    oTarget = oUnit
                                    bAssignedPriorityShield = true
                                end
                            end
                        end
                        -- iMediumSearchRange
                    end
                end
                if M28Utilities.IsTableEmpty(tiUnitsToRemove) == false then
                    for iCurEntry = table.getn(tiUnitsToRemove), 1, -1 do
                        table.remove(tTableOfUnits, iCurEntry)
                    end
                end
            end
            if M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftEnemyShieldsFailedToArti]) then
                ConsiderTableOfPriorityUnits(M28Team.tTeamData[iTeam][M28Team.reftEnemyShieldsFailedToArti], math.max(iMediumSearchRange * 2, 150))
            end
            if not(bAssignedPriorityShield) and (not(oTarget) or not(EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oTarget.UnitId))) and M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftoVulnerableFatboys]) then
                ConsiderTableOfPriorityUnits(M28Team.tTeamData[iTeam][M28Team.reftoVulnerableFatboys], math.max(iMediumSearchRange * 3, 350))
            end
        end

        --Consider ignoring closest target and focusing on something furhter away if we dont have a high value target
        local bConsiderFurtherAwayMexes = false
        if not(oTarget) then bConsiderFurtherAwayMexes = true
            --NOTE: iBestTargetValue is already set at a threshold to mean really low value targets are ignored
        else
            if GetUnitTypeMassWeighting(oTarget) < 1.5 and iBestTargetValue < 150 then
                --Not a high value category; consider if we will still deal lots of damage relative to the mass cost; e.g. a T2 mex costs 900 mass with 2.5k health, so a dps of 243 would take 10.3s to kill, so 900 / 10.3 = 87.4 (ignoring the x2 weighting).  for a sniperbot, it's c.2s to kill a 880 mass unit so worth targeting (value is c.440); for a blaze it's c.4s to kill a 180 mass unit so c.45 mass/s; for UEF Fixed T2 flak (no modifier) it's 39 mass/s; i.e. if go with a value of 80 then it should exclude a lot of low value targets
                bConsiderFurtherAwayMexes = true --will consider further away mexes, but not much further away
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Finished considering all units at time '..GetGameTimeSeconds()..' in cur and adjacent zones, iStartPlateauOrZero='..(iStartPlateauOrZero)..'; iStartLandOrWaterZone='..iStartLandOrWaterZone..'; oTarget='..(oTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTarget) or 'nil')..'; iBestTargetValue='..iBestTargetValue..'; bConsiderFurtherAwayMexes='..tostring(bConsiderFurtherAwayMexes)) end

        if bConsiderFurtherAwayMexes then
            local iFurtherAwayMexTargetDist
            if oTarget then
                iFurtherAwayMexTargetDist = math.min(150, M28Map.iMapSize * 0.4)
            else
                iFurtherAwayMexTargetDist = math.min(750, math.max(200, M28Map.iMapSize * 0.6))
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Searching for unshielded T1 and T2 mexes, iFurtherAwayMexTargetDist='..iFurtherAwayMexTargetDist..'; M28Map.iMapSize='..M28Map.iMapSize) end


            --Get low priority target (i.e. further away target) - for now have done a copy of M27 approach
            tEnemyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryT2Mex + M28UnitInfo.refCategoryT3Mex, oNovax:GetPosition(), iFurtherAwayMexTargetDist, 'Enemy')
            local iClosestTarget = 10000
            local iCurDist
            if M28Utilities.IsTableEmpty(tEnemyUnits) == false then
                for iUnit, oUnit in tEnemyUnits do
                    if bDebugMessages == true then LOG(sFunctionRef..': Searching for mexes, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Dist to novax='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNovax:GetPosition())..'; Is underwtaer='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; Is under shield='..tostring(M28Logic.IsTargetUnderShield(aiBrain, oUnit, 0, false, false, true, false))) end
                    if oUnit:GetFractionComplete() == 1 and not(M28UnitInfo.IsUnitUnderwater(oUnit)) and not (M28Logic.IsTargetUnderShield(aiBrain, oUnit, 0, false, false, true, false)) then
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNovax:GetPosition())
                        if iCurDist < iClosestTarget then
                            iClosestTarget = iCurDist
                            oTarget = oUnit
                        end
                    end
                end
            end

            if oNearestRecentlyFailedShield and oTarget and iClosestTarget * 2 > iNearestRecentlyFailedShieldDist then
                oTarget = oNearestRecentlyFailedShield
            end

            if bDebugMessages == true then LOG(sFunctionRef..': oTarget after searching for nearby mexes='..(oTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTarget) or 'nil')..'; iClosestTarget='..(iClosestTarget or 'nil')) end

            --If enemy has fatboys then consider targeting one of these if the zone lacks enemy fixed shields
            if iClosestTarget >= 100 and (iClosestTarget >= 350 or not(oTarget) or not(oTarget == oNearestRecentlyFailedShield)) then

                if (not(oTarget) or M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefoNearbyEnemyLongRangeThreats]) == false) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
                    local tFatboysToConsider
                    if oTarget then tFatboysToConsider = EntityCategoryFilterDown(M28UnitInfo.refCategoryFatboy, tStartLZOrWZData[M28Map.subrefoNearbyEnemyLongRangeThreats])
                    else tFatboysToConsider = EntityCategoryFilterDown(M28UnitInfo.refCategoryFatboy, M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals])
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy LR threats empty='..tostring(tStartLZOrWZData[M28Map.subrefoNearbyEnemyLongRangeThreats])..'; is tFatboysToConsider empty='..tostring(M28Utilities.IsTableEmpty(tFatboysToConsider))) end
                    if M28Utilities.IsTableEmpty(tFatboysToConsider) == false then
                        for iUnit, oUnit in tFatboysToConsider do
                            if M28UnitInfo.IsUnitValid(oUnit) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) and oUnit:GetFractionComplete() >= 0.35 then
                                --Check no fixed shields in this LZ
                                local tUnitLZData, tUnitLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                if bDebugMessages == true then LOG(sFunctionRef..': Fatboy oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Dist to fatboy='.. M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNovax:GetPosition())) end
                                if (tUnitLZTeamData[M28Map.subrefLZThreatEnemyShield] or 0) <= 350 then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNovax:GetPosition())
                                    if iCurDist < iClosestTarget then
                                        iClosestTarget = iCurDist
                                        oTarget = oUnit
                                    end
                                end
                            end
                        end
                    end
                end

            end
            if not(oTarget) and oNearestRecentlyFailedShield and iNearestRecentlyFailedShieldDist < 500 then
                oTarget = oNearestRecentlyFailedShield
                iClosestTarget = iNearestRecentlyFailedShieldDist
            end

            if not (oTarget) or iClosestTarget >= 500 then
                --Prev target was closer and a mex or surface navy that isn't under shield coverage? (redundancy as shouldve already considered earlier)
                if M28UnitInfo.IsUnitValid(oNovax[refoNovaxLastTarget]) and EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryNavalSurface, oNovax[refoNovaxLastTarget].UnitId) then
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oNovax[refoNovaxLastTarget]:GetPosition(), tPositionToSearchFrom)
                    if iCurDist < iClosestTarget and not(M28UnitInfo.IsUnitUnderwater(oNovax[refoNovaxLastTarget])) and not(M28Logic.IsTargetUnderShield(aiBrain, oNovax[refoNovaxLastTarget], 2000, false, false, false, nil)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': setting oTarget to the novax last target for now, although will also consider enemy naval surface in a moment, iCurDist='..iCurDist) end
                        oTarget = oNovax[refoNovaxLastTarget]
                        iClosestTarget = iCurDist
                    end
                end

                --Nearest surface naval unit
                tEnemyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryNavalSurface, tPositionToSearchFrom, 1000, 'Enemy')
                if bDebugMessages == true then LOG(sFunctionRef .. ': No high priority targets, will search for lower priority, first with surface naval units. Is table empty=' .. tostring(M28Utilities.IsTableEmpty(tEnemyUnits))) end
                if M28Utilities.IsTableEmpty(tEnemyUnits) == false then
                    local iClosestDist = 10000
                    if oTarget then iClosestDist = iClosestTarget end
                    for iUnit, oUnit in tEnemyUnits do
                        if not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tPositionToSearchFrom)
                            if iCurDist < iClosestDist then
                                if not(M28Logic.IsTargetUnderShield(aiBrain, oUnit, 2000, false, false, false, nil)) then
                                    iClosestDist = iCurDist
                                    oTarget = oUnit
                                end
                            end
                        end
                    end
                else
                    --Target nearest unshielded T3+ mobile land unit or T2 structure; if are none, then just get the nearest mobile land unit:
                    tEnemyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure, tPositionToSearchFrom, 1000, 'Enemy')
                    if M28Utilities.IsTableEmpty(tEnemyUnits) == false then
                        local iCurDist
                        local iClosestUnshieldedDist = 10000
                        local iClosestShieldedDist = 10000
                        local oClosestShieldedUnit
                        local oClosestUnshieldedUnit
                        local oClosestHighValueUnit
                        local iClosestHighValueUnit = 10000
                        if oTarget then iClosestHighValueUnit = iClosestTarget oClosestHighValueUnit = oTarget end
                        local tNovaxPosition = oNovax:GetPosition()
                        for iUnit, oUnit in tEnemyUnits do
                            if not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tNovaxPosition)
                                if iCurDist < math.max(iClosestUnshieldedDist, iClosestShieldedDist, iClosestHighValueUnit) then
                                    if iCurDist < iClosestShieldedDist then
                                        oClosestShieldedUnit = oUnit
                                        iClosestShieldedDist = iCurDist
                                    end
                                    if iCurDist < iClosestUnshieldedDist and iCurDist <= math.max(250, iClosestShieldedDist) then
                                        if not (M28Logic.IsTargetUnderShield(aiBrain, oUnit, 10000, false, true, true, false)) then
                                            oClosestUnshieldedUnit = oUnit
                                            iClosestUnshieldedDist = iCurDist
                                        end
                                    end
                                    if iCurDist < iClosestHighValueUnit then
                                        oClosestHighValueUnit = oUnit
                                    end
                                end
                            end
                        end

                        if oClosestUnshieldedUnit and iClosestUnshieldedDist <= math.max(250, iClosestShieldedDist + 60) then
                            oTarget = oClosestUnshieldedUnit
                        elseif oClosestShieldedUnit then
                            oTarget = oClosestShieldedUnit
                        else
                            oTarget = oClosestHighValueUnit --If nil then will just be ttargeting enemy base/start position
                        end
                    end
                end
            end
        end
        if not(oTarget) and iBestValueWithNoThreshold >= iBestTargetValue * 0.5 then --i.e. we didnt find anything with iBestTargetValue, so will now consider units with up to half of it
            oTarget = oBestTargetWithNoThreshold
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oTarget
end

function ManageExperimentalBomber(iTeam, iAirSubteam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageExperimentalBomber'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tAvailableBombers, tBombersForRetreating, tUnavailableUnits = GetAvailableLowFuelAndInUseAirUnits(iTeam, iAirSubteam, M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL)
    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, time='..GetGameTimeSeconds()..'; Is tAvailableBombers empty='..tostring(M28Utilities.IsTableEmpty(tAvailableBombers))) end

    if M28Utilities.IsTableEmpty(tAvailableBombers) == false then
        local iTotalExpBombers = table.getn(tAvailableBombers)
        local iBombersPerTick = math.max(1, math.ceil(iTotalExpBombers / 3)) --Logic can run slowly so want to spread it out over 3 ticks
        local iCurBomberPerTick = 0

        if M28Utilities.IsTableEmpty(tBombersForRetreating) == false then iTotalExpBombers = iTotalExpBombers + table.getn(tBombersForRetreating) end
        if M28Utilities.IsTableEmpty(tUnavailableUnits) == false then iTotalExpBombers = iTotalExpBombers + table.getn(tUnavailableUnits) end

        for iBomber, oBomber in tAvailableBombers do
            if M28UnitInfo.IsUnitValid(oBomber) then --needed as will spread out logic over a number of ticks
                local tiZonesByPlateauConsidered = {}
                local aiBrain = oBomber:GetAIBrain()
                local iAOE, iDamage = M28UnitInfo.GetBomberAOEAndStrikeDamage(oBomber)
                local tEnemyGroundTargets = {}
                local iBomberPlateauOrZero, iBomberLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oBomber:GetPosition())
                local tBomberLandOrWaterZoneData, tBomberLandOrWaterZoneTeamData
                local tBomberZoneMidpoint
                if iBomberPlateauOrZero == 0 then
                    tBomberLandOrWaterZoneData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iBomberLandOrWaterZone]][M28Map.subrefPondWaterZones][iBomberLandOrWaterZone]
                    tBomberLandOrWaterZoneTeamData = tBomberLandOrWaterZoneData[M28Map.subrefWZTeamData][iTeam]
                    tBomberZoneMidpoint =    tBomberLandOrWaterZoneData[M28Map.subrefMidpoint]
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a water zone, iBomberLandOrWaterZone='..(iBomberLandOrWaterZone or 'nil')) end
                else
                    tBomberLandOrWaterZoneData = M28Map.tAllPlateaus[iBomberPlateauOrZero][M28Map.subrefPlateauLandZones][iBomberLandOrWaterZone]
                    tBomberLandOrWaterZoneTeamData = tBomberLandOrWaterZoneData[M28Map.subrefLZTeamData][iTeam]
                    tBomberZoneMidpoint =    tBomberLandOrWaterZoneData[M28Map.subrefMidpoint]
                end
                if bDebugMessages == true then LOG(sFunctionRef..': oExpBomber='..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; Position='..repru(oBomber:GetPosition())..'; iBomberPlateauOrZero='..(iBomberPlateauOrZero or 'nil')..'; iBomberLandOrWaterZone='..(iBomberLandOrWaterZone or 'nil')..'; tGunshipMidpoint='..repru(tBomberZoneMidpoint)..'; WZ from position='..(M28Map.GetWaterZoneFromPosition(oBomber:GetPosition()) or 'nil')) end

                local iMaxEnemyAirAA --Amount of enemy airaa threat required to make gunships to target enemies nearby
                if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir] and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] >= 6000 then
                    iMaxEnemyAirAA = 1000
                else
                    --Is the air support location nearby?
                    local iDistToSupport = M28Utilities.GetDistanceBetweenPositions(oBomber:GetPosition(), M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint])
                    if iDistToSupport <= 200 then
                        if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] then
                            iMaxEnemyAirAA = 10000
                        else
                            iMaxEnemyAirAA = 6000
                        end
                    else
                        if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl] then
                            iMaxEnemyAirAA = 7000
                        else
                            iMaxEnemyAirAA = 3500
                        end
                    end
                end
                iMaxEnemyAirAA = iMaxEnemyAirAA + (tBomberLandOrWaterZoneTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0) + (tBomberLandOrWaterZoneTeamData[M28Map.subrefWZThreatAlliedAA] or 0)
                iMaxEnemyAirAA = iMaxEnemyAirAA * iTotalExpBombers
                if M28Team.tTeamData[iTeam][M28Team.refbDontHaveBuildingsOrACUInPlayableArea] then iMaxEnemyAirAA = 100000 end

                if bDebugMessages == true then LOG(sFunctionRef..': About to look for targets for experimental bomber, iMaxEnemyAirAA='..iMaxEnemyAirAA..'; iDistToSupport='..M28Utilities.GetDistanceBetweenPositions(oBomber:GetPosition(), M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubSupportPoint])..'; HaveAirControl='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbHaveAirControl])..'; Far behind on air='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbFarBehindOnAir])..'; Enemy total AirAA='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat]) end
                function AddEnemyGroundUnitsToTargetsSubjectToAA(iPlateauOrZero, iLandOrWaterZone, bCheckForAirAA)
                    if not(tiZonesByPlateauConsidered[iPlateauOrZero][iLandOrWaterZone]) then
                        if not(tiZonesByPlateauConsidered[iPlateauOrZero]) then tiZonesByPlateauConsidered[iPlateauOrZero] = {} end
                        tiZonesByPlateauConsidered[iPlateauOrZero][iLandOrWaterZone] = true
                        local iMaxEnemyGroundAA = -1
                        --Check if sufficient threat in the LZ/WZ to consider targeting
                        local tLZOrWZTeamData
                        if iPlateauOrZero > 0 then
                            --Land zone
                            tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
                        else
                            --Water zone
                            tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering targeting untis in iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]))..'; Is table of allied ACUs empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefAlliedACU]))..'; Enemy combat total='..tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Enemy structure total mass='..tLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]) end
                        --Only consider zones with enemy units, no friendly ACUs, and sufficient threat to be worth bombing
                        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEnemyUnits]) == false and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefAlliedACU]) and (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) + (tLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) + ((tLZOrWZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) + (tLZOrWZTeamData[M28Map.subrefWZThreatEnemyAA] or 0)) * 2 >= 1500 then
                            --Only include if enemy threat is high and our threat isnt high (as dont want to nuke our own units); however dont ignore if has high AA threat as otherwise risk targeting something near this and dying to the AA; also dont ignore if very high mass value as could be t3 arti/game ender that we want to kill asap
                            if bDebugMessages == true then LOG(sFunctionRef..': Are potential enemies to target, checking overall threat vs friendly threat, ally combat total='..(tLZOrWZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)..'; Enemy combat total='..(tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)..'; tLZOrWZTeamData[M28Map.subrefLZThreatEnemyGroundAA]='..(tLZOrWZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 'nil')..'; tLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass]='..(tLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 'nil')) end
                            if (tLZOrWZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) >= 2000 or ((tLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) >= 100000 and ((tLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) >= (tLZOrWZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0) * 0.25)) or
                                    ((tLZOrWZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0) * 1.75 <= (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) + ((tLZOrWZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) + (tLZOrWZTeamData[M28Map.subrefWZThreatEnemyAA] or 0)) * 0.6 + (tLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) * 0.05 and
                                            ((tLZOrWZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0) <= 200 or (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) + (tLZOrWZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) + (tLZOrWZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) + (tLZOrWZTeamData[M28Map.subrefWZThreatEnemyAA] or 0) >= 2500 + (tLZOrWZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0) * 3)) then

                                --Check if enemy has enough AA nearby
                                local bTooMuchAA
                                if not (bCheckForAirAA) and iMaxEnemyGroundAA < 0 then
                                    bTooMuchAA = false
                                else
                                    bTooMuchAA = DoesEnemyHaveAAThreatAlongPath(iTeam, iBomberPlateauOrZero, iBomberLandOrWaterZone, iPlateauOrZero, iLandOrWaterZone, not(bCheckForAirAA), iMaxEnemyGroundAA, iMaxEnemyAirAA)
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': bTooMuchAA='..tostring(bTooMuchAA)..'; iBomberPlateauOrZero='..iBomberPlateauOrZero..'; iBomberLandOrWaterZone='..iBomberLandOrWaterZone..'; iMaxEnemyGroundAA='..iMaxEnemyGroundAA..'; iMaxEnemyAirAA='..iMaxEnemyAirAA) end

                                if not (bTooMuchAA) then
                                    --Add enemy ground units in the plateau/land zone to list of enemy unit targets
                                    local tPriorityTargets = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategoryMobileLand * categories.TECH2 + M28UnitInfo.refCategoryMobileLand * categories.TECH3 + M28UnitInfo.refCategoryMobileLand * categories.EXPERIMENTAL + categories.COMMAND, tLZOrWZTeamData[M28Map.subrefTEnemyUnits])
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will add targets to consider, Is tPriorityTargets empty='..tostring(M28Utilities.IsTableEmpty(tPriorityTargets))) end
                                    if M28Utilities.IsTableEmpty(tPriorityTargets) == false then
                                        local iCurUnitSegmentX, iCurUnitSegmentZ, bAddUnit
                                        for iUnit, oUnit in tLZOrWZTeamData[M28Map.subrefTEnemyUnits] do
                                            if M28UnitInfo.IsUnitValid(oUnit) and not(oUnit:IsUnitState('Attached')) and not(M28Map.IsUnderwater(oUnit:GetPosition(), false, math.max(0, iAOE - 4))) then
                                                --Is enemy still in this zone if we no longer have intel?
                                                bAddUnit = false
                                                if bDebugMessages == true then LOG(sFunctionRef..': Checking if have a mobile unit that has moved far from the lastk nown position such that we will end up targeting a different zone by mistake, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Can see unit='..tostring(M28UnitInfo.CanSeeUnit(aiBrain, oUnit))..'; Dist between position and last known position='..M28Utilities.GetRoughDistanceBetweenPositions(oUnit:GetPosition(), oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])) end
                                                if EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) or M28UnitInfo.CanSeeUnit(aiBrain, oUnit) then
                                                    bAddUnit = true
                                                else
                                                    --dealing with mobile unit, is it still in this zone?
                                                    iCurUnitSegmentX, iCurUnitSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnit:GetPosition())
                                                    if iPlateauOrZero == 0 then
                                                        if M28Map.tWaterZoneBySegment[iCurUnitSegmentX][iCurUnitSegmentZ] == iLandOrWaterZone then
                                                            bAddUnit = true
                                                        elseif M28Utilities.GetRoughDistanceBetweenPositions(oUnit:GetPosition(), oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 15 then
                                                            bAddUnit = true
                                                        end
                                                    else
                                                        --Land zone
                                                        if M28Map.tLandZoneBySegment[iCurUnitSegmentX][iCurUnitSegmentZ] == iLandOrWaterZone then
                                                            bAddUnit = true
                                                        elseif M28Utilities.GetRoughDistanceBetweenPositions(oUnit:GetPosition(), oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 15 then
                                                            bAddUnit = true
                                                        end
                                                    end
                                                    if not(bAddUnit) then
                                                        --Update last position as unit is in a differnet zone so want to avoid it being treated as invisible
                                                        oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam] = {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]}
                                                    end
                                                end

                                                if bAddUnit then
                                                    table.insert(tEnemyGroundTargets, oUnit)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': We have already considered P'..iPlateauOrZero..'Z'..iLandOrWaterZone..' for this bomber')
                    end
                end

                local iCurPlateauOrZero, iCurLZOrWZ

                --Emergency response - first include any ground threats in a start position
                for iBrain, oBrain in M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains] do
                    local tStartPoint = M28Map.GetPlayerStartPosition(oBrain)
                    iCurPlateauOrZero, iCurLZOrWZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tStartPoint)
                    if (iCurPlateauOrZero or 0) > 0 then
                        if (iCurLZOrWZ or 0) == 0 then
                            iCurLZOrWZ = M28Map.GetWaterZoneFromPosition(tStartPoint)
                            if (iCurLZOrWZ or 0) > 0 then
                                iCurPlateauOrZero = 0
                            end
                        end
                    end
                    if (iCurLZOrWZ or 0) > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Emergency response for ground threats in a start position, iCurLZOrWZ='..iCurLZOrWZ..'; will look to add targets') end
                        AddEnemyGroundUnitsToTargetsSubjectToAA(iCurPlateauOrZero, iCurLZOrWZ, false)
                    end
                end

                if M28Utilities.IsTableEmpty(tEnemyGroundTargets) then
                    --Check if want exp bomber to run to rally point if nearby enemy airAA (if give no targets for exp bomber then they will go to rally point or air staging
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if too great an enemy threat in zone IsThereAANearLandOrWaterZone='..tostring(IsThereAANearLandOrWaterZone(iTeam, iBomberPlateauOrZero, iBomberLandOrWaterZone, (iBomberPlateauOrZero == 0), -1, iMaxEnemyAirAA))) end
                    if not(IsThereAANearLandOrWaterZone(iTeam, iBomberPlateauOrZero, iBomberLandOrWaterZone, (iBomberPlateauOrZero == 0), -1, iMaxEnemyAirAA)) then
                        --If there is enemy groundAA in the zone we are currently in and we are facing the rally point and are more than 20 from it, then keep moving to the rally point
                        if (tBomberLandOrWaterZoneTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) + (tBomberLandOrWaterZoneTeamData[M28Map.subrefWZThreatEnemyAA] or 0) < 1000 or M28Utilities.GetAngleDifference(M28UnitInfo.GetUnitFacingAngle(oBomber), M28Utilities.GetAngleFromAToB(oBomber:GetPosition(),M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint])) >= 25 then
                            --no nearby enemy air threat so can just evaluate each land zone or water zone on its own merits - cycle through each in order of distance, but first consider adjacent locations

                            --First consider the land/water zone the bomber is in at the moment and any nearby zones
                            AddEnemyGroundUnitsToTargetsSubjectToAA(iBomberPlateauOrZero, iBomberLandOrWaterZone, true)


                            local tFirstZoneWithTargetsMidpoint
                            local iZonesConsideredAfterFirstTarget = 0
                            local iDistFromFirstZoneToBomber
                            if bDebugMessages == true then LOG(sFunctionRef..': Is tEnemyGroundTargets empty after considering enemies in the same LZ/WZ as experimental bomber='..tostring(M28Utilities.IsTableEmpty(tEnemyGroundTargets))) end
                            if M28Utilities.IsTableEmpty(tEnemyGroundTargets) == false then
                                tFirstZoneWithTargetsMidpoint = tBomberZoneMidpoint
                                iDistFromFirstZoneToBomber = 0
                            end
                            --if M28Utilities.IsTableEmpty(tEnemyGroundTargets) then
                            --Is there groundAA in the current plateau/water zone (i.e. there are enemies but we have chosen not to attack due to the threat)?
                            if (tBomberLandOrWaterZoneData[M28Map.subrefLZThreatEnemyGroundAA] or 0) > 0 or (tBomberLandOrWaterZoneData[M28Map.subrefWZThreatEnemyAA] or 0) > 0 then
                                --Enemy has AA in the same LZ as our exp bomber and we dont want to attack enemies, so retreat (if no targets)
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy GroundAA threat exists in same zone as exp bomber so want to retreat if not already got targets') end
                            else

                                if bDebugMessages == true then LOG(sFunctionRef..': oBomber='..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; iBomberPlateauOrZero='..(iBomberPlateauOrZero or 'nil')..'; iBomberLandOrWaterZone='..(iBomberLandOrWaterZone or 'nil')..'; tBomberZoneMidpoint='..repru(tBomberZoneMidpoint)) end
                                RecordOtherLandAndWaterZonesByDistance(tBomberLandOrWaterZoneData, tBomberZoneMidpoint)
                                if M28Utilities.IsTableEmpty(tBomberLandOrWaterZoneData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                                    if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through each other zone by distance and consider the best target, tFirstZoneWithTargetsMidpoint='..repru(tFirstZoneWithTargetsMidpoint)) end
                                    local bZoneIsCloseToFirstTargetZone
                                    --local tiFirstPlateauAndZone
                                    for iEntry, tSubtable in tBomberLandOrWaterZoneData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                                        if tFirstZoneWithTargetsMidpoint then
                                            iZonesConsideredAfterFirstTarget = iZonesConsideredAfterFirstTarget + 1
                                            if iZonesConsideredAfterFirstTarget >= 6 then
                                                if iZonesConsideredAfterFirstTarget >= 20 or (tSubtable[M28Map.subrefiDistance] or 0) - (iDistFromFirstZoneToBomber or 50) >= 90 then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Already considered '..(iZonesConsideredAfterFirstTarget - 1)..' zones after the first, dist threshold vs dist from first zone to bomber='..tSubtable[M28Map.subrefiDistance] - iDistFromFirstZoneToBomber..' so will stop searching for more, dist to bomber zone='..tSubtable[M28Map.subrefiDistance]) end
                                                    break
                                                end
                                            end
                                        end

                                        bZoneIsCloseToFirstTargetZone = true
                                        if tFirstZoneWithTargetsMidpoint then
                                            local tOtherZoneLZOrWZData
                                            if tSubtable[M28Map.subrefbIsWaterZone] then
                                                tOtherZoneLZOrWZData = M28Map.tPondDetails[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                            else
                                                tOtherZoneLZOrWZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                            end

                                            bZoneIsCloseToFirstTargetZone = false

                                            if M28Utilities.GetDistanceBetweenPositions(tFirstZoneWithTargetsMidpoint, tOtherZoneLZOrWZData[M28Map.subrefMidpoint]) <= 100 then
                                                bZoneIsCloseToFirstTargetZone = true
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if potential zone P'..tSubtable[M28Map.subrefiPlateauOrPond]..'Z'..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..' is close enough to the first zone target to warrant considering, dist to zone midpoint='..M28Utilities.GetDistanceBetweenPositions(tFirstZoneWithTargetsMidpoint, tOtherZoneLZOrWZData[M28Map.subrefMidpoint])..'; bZoneIsCloseToFirstTargetZone='..tostring(bZoneIsCloseToFirstTargetZone)..'; Dist to bomber zone='..tSubtable[M28Map.subrefiDistance]) end
                                        end
                                        if bZoneIsCloseToFirstTargetZone then
                                            if tSubtable[M28Map.subrefbIsWaterZone] then
                                                AddEnemyGroundUnitsToTargetsSubjectToAA(0, tSubtable[M28Map.subrefiLandOrWaterZoneRef],  true)
                                            else
                                                AddEnemyGroundUnitsToTargetsSubjectToAA(tSubtable[M28Map.subrefiPlateauOrPond], tSubtable[M28Map.subrefiLandOrWaterZoneRef],  true)
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Have just finished calling AddEnemyGroundUnitsToTargetsSubjectToAA for bombers for zone '..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..', Is table of enemy targets empty='..tostring(M28Utilities.IsTableEmpty(tEnemyGroundTargets))..'; tSubtable='..repru(tSubtable)) end
                                            if not(tFirstZoneWithTargetsMidpoint) and M28Utilities.IsTableEmpty(tEnemyGroundTargets) == false then
                                                local tOtherZoneLZOrWZData
                                                if tSubtable[M28Map.subrefbIsWaterZone] then
                                                    tOtherZoneLZOrWZData = M28Map.tPondDetails[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                                else
                                                    tOtherZoneLZOrWZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                                end
                                                tFirstZoneWithTargetsMidpoint = tOtherZoneLZOrWZData[M28Map.subrefMidpoint]
                                                iDistFromFirstZoneToBomber = (tSubtable[M28Map.subrefiDistance] or M28Utilities.GetDistanceBetweenPositions(tFirstZoneWithTargetsMidpoint, oBomber:GetPosition()))
                                                --tiFirstPlateauAndZone = {tSubtable[M28Map.subrefiPlateauOrPond], tSubtable[M28Map.subrefiLandOrWaterZoneRef]}
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have the first zone to target, tFirstZoneWithTargetsMidpoint='..repru(tFirstZoneWithTargetsMidpoint)..'; Dist to bomber zone='..tSubtable[M28Map.subrefiDistance]) end
                                            end
                                            --if M28Utilities.IsTableEmpty(tEnemyGroundTargets) == false then break end
                                        end
                                    end
                                    if M28Utilities.IsTableEmpty(tFirstZoneWithTargetsMidpoint) == false then
                                        --We have a target, so consider SAMs and T3 MAA in nearby zones that we haven't already considered that are near here
                                        local tMidpoint = M28Utilities.MoveInDirection(oBomber:GetPosition(), M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), tFirstZoneWithTargetsMidpoint), iDistFromFirstZoneToBomber * 0.7)
                                        local tNearbyDangerousAA = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryGroundAA + M28UnitInfo.refCategoryCruiser, tMidpoint, math.min(175, iDistFromFirstZoneToBomber * 0.5), 'Enemy')
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will cycle through each nearby T3 SAM, MAA or cruiser near the target and make sure that zone has been included in the table of potentail targets, is tNearbyDangerousAA empty='..tostring(M28Utilities.IsTableEmpty(tNearbyDangerousAA))) end
                                        if M28Utilities.IsTableEmpty(tNearbyDangerousAA) == false then
                                            for iUnit, oUnit in tNearbyDangerousAA do
                                                if oUnit:GetFractionComplete() >= 1 then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Assessing enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Assigned Plateau and LZ='..repru(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam])) end
                                                    if M28Utilities.IsTableEmpty(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam]) == false then
                                                        --AddEnemyGroundUnitsToTargetsSubjectToAA(iPlateauOrZero, iLandOrWaterZone, bCheckForAirAA)
                                                        AddEnemyGroundUnitsToTargetsSubjectToAA(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1], oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2],  true)
                                                    elseif oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] then
                                                        AddEnemyGroundUnitsToTargetsSubjectToAA(0, oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam],  true)
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        --end
                    end
                end

                if M28Utilities.IsTableEmpty(tEnemyGroundTargets) then
                    --Return bomber to nearest rally point (NOTE: if changing this appraoch then need to rethink above appraoch that determines bomber angle to rally point to decide whether to keep moving)
                    local tMovePoint = M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint]
                    M28Orders.IssueTrackedMove(oBomber, tMovePoint, 10, false, 'ExBIdle', false)
                else
                    --Have targets for bomber, send orders for targeting - if enemy has dangerous AA then target the closest such AA, otherwise pick the target that will deal the most damage


                    local oBestEnemyTarget
                    local iCurDamage
                    local iHighestDamage = 0
                    local aiBrain = oBomber:GetAIBrain()
                    local iFriendlyUnitDamageReductionFactor = 0.8
                    local iFriendlyUnitAOEFactor = 1.6
                    local iMobileUnitInnerDamageFactor = 0.75
                    local iOptionalShieldReductionFactor = 0.15
                    local iBomberFacingAngle = M28UnitInfo.GetUnitFacingAngle(oBomber)
                    local iAngleDif

                    local tDangerousAATargets = EntityCategoryFilterDown(M28UnitInfo.refCategoryGroundAA - categories.TECH1, tEnemyGroundTargets)
                    if M28Utilities.IsTableEmpty( tDangerousAATargets) == false then
                        --Only include if almost complete
                        local iCurDist
                        local iDistOfBestTarget = 100000



                        for iUnit, oUnit in tDangerousAATargets do
                            if oUnit:GetFractionComplete() >= 0.8 then
                                --Add increase in distance if we arent facing the target
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oBomber:GetPosition())
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to target AA oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..iCurDist..'; iDistOfBestTarget='..iDistOfBestTarget) end
                                if iCurDist <= iDistOfBestTarget + 25 then
                                    iAngleDif = M28Utilities.GetAngleDifference(iBomberFacingAngle, M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), oUnit:GetPosition()))
                                    if iAngleDif >= 15 then
                                        iCurDist = iCurDist + (iAngleDif / 180) * 90
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': iAngleDif='..iAngleDif..'; iCurDist after angle adjustment='..iCurDist) end
                                    if iCurDist <= iDistOfBestTarget + 25 then
                                        --Get damage from a bomb - increase by 400% for AA targets so will prioritise taking out enemy groundAA
                                        --GetDamageFromBomb(aiBrain, tBaseLocation,         iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies)
                                        iCurDamage = M28Logic.GetDamageFromBomb(aiBrain, oUnit:GetPosition(), iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor,    nil,                            nil,                nil,                            iMobileUnitInnerDamageFactor,                nil,               iOptionalShieldReductionFactor,     true, 4, M28UnitInfo.refCategoryGroundAA)
                                        if bDebugMessages == true then LOG(sFunctionRef..': iCurDamage='..iCurDamage..'; iHighestDamage='..iHighestDamage) end
                                        if iCurDist < iDistOfBestTarget - 25 or iCurDamage > iHighestDamage * 1.25 or (iCurDist < iDistOfBestTarget and iCurDamage >= iHighestDamage) then
                                            iHighestDamage = iCurDamage
                                            oBestEnemyTarget = oUnit
                                            iDistOfBestTarget = iCurDist
                                            if bDebugMessages == true then LOG(sFunctionRef..': Recording unit as the newest best target') end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering if we have nearby dangerous groundAA that we want to target, is oBestEnemyTarget nil='..tostring(oBestEnemyTarget == nil)) end
                    if not(oBestEnemyTarget) or iHighestDamage <= 2000 then --we are multiplying AA value by 4, so this is equivalent to 1 T2 flak
                        for iUnit, oUnit in tEnemyGroundTargets do
                            --Pick the target that will deal the most damage
                            --GetDamageFromBomb(aiBrain, tBaseLocation,         iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor, bIncludePreviouslySeenEnemies)
                            iCurDamage = M28Logic.GetDamageFromBomb(aiBrain, oUnit:GetPosition(), iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor,    nil,                            nil,                nil,                            iMobileUnitInnerDamageFactor,                nil,               iOptionalShieldReductionFactor,     true, 4, M28UnitInfo.refCategoryGroundAA)
                            if bDebugMessages == true then LOG(sFunctionRef..': Damage if target unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'='..iCurDamage..'; iHighestDamage='..iHighestDamage) end
                            if iCurDamage > iHighestDamage then
                                iAngleDif = M28Utilities.GetAngleDifference(iBomberFacingAngle, M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), oUnit:GetPosition()))
                                if iAngleDif >= 15 then
                                    --Reudce value by up to 30% depending on how big a difference in bomber angle targets there is
                                    iCurDamage = iCurDamage * (1 - 0.3 * (iAngleDif / 180))
                                end
                                iHighestDamage = iCurDamage
                                oBestEnemyTarget = oUnit
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': oBestEnemyTarget='..(oBestEnemyTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBestEnemyTarget) or 'nil')..'; iHighestDamage='..iHighestDamage)
                        if M28UnitInfo.IsUnitValid(oBestEnemyTarget) and M28UnitInfo.IsUnitValid(oBomber) then
                            LOG(sFunctionRef..': oBestEnemyTarget is valid, Dist to target='..M28Utilities.GetDistanceBetweenPositions(oBestEnemyTarget:GetPosition(), oBomber:GetPosition())..'; oBestEnemyTarget='..oBestEnemyTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestEnemyTarget))
                        end
                    end
                    if M28UnitInfo.IsUnitValid(oBestEnemyTarget) then
                        --Units under heavy shield with AA - land the bomb so the aoe just hits the unit, unless have lots of experimental bombers nearby
                        local iDamageForIfUnderShield = iDamage - 1000
                        if iTotalExpBombers >= 2 and M28Utilities.IsTableEmpty(oBestEnemyTarget[M28Building.reftoShieldsProvidingCoverage]) == false then
                            local iNearbyBomberCount = 0
                            local tNearbyBombers = aiBrain:GetUnitsAroundPoint(categories.BOMBER * categories.EXPERIMENTAL, oBomber:GetPosition(), 100, 'Ally')
                            if M28Utilities.IsTableEmpty(tNearbyBombers) == false then
                                for iNearbyBomber, oNearbyBomber in tNearbyBombers do
                                    if oNearbyBomber == oBomber then
                                        iNearbyBomberCount = iNearbyBomberCount + 1
                                        --Include bombers who have fired recently
                                    elseif oNearbyBomber:GetFractionComplete() == 1 and GetGameTimeSeconds() - (oNearbyBomber[M28UnitInfo.refiLastWeaponEvent] or -100) <= 6 and oNearbyBomber[M28UnitInfo.refbSpecialMicroActive] then
                                        iNearbyBomberCount = iNearbyBomberCount + 1
                                    end
                                end
                            end
                            if iNearbyBomberCount >= 2 then
                                iDamageForIfUnderShield = math.max(1000, iDamage - 1000) + iDamage * (iNearbyBomberCount - 1)
                            end
                        end

                        local bUseAOEForTargetIfNotTooClose = false
                        if M28Logic.IsTargetUnderShield(aiBrain, oBestEnemyTarget, iDamageForIfUnderShield, false, true, false, false) then
                            bUseAOEForTargetIfNotTooClose = true
                            --If only have 1 exp bomber and targeting a fixed unit be more cautious if significant enemy groundAA threat near the target
                        elseif iTotalExpBombers == 1 and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oBestEnemyTarget.UnitId) then
                            local iTargetPlateau, iTargetZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oBestEnemyTarget:GetPosition())
                            if (iTargetPlateau or 0) > 0 and iTargetZone then
                                local tTargetLZData = M28Map.tAllPlateaus[iTargetPlateau][M28Map.subrefPlateauLandZones][iTargetZone]
                                local tTargetLZTeamData = tTargetLZData[M28Map.subrefLZTeamData][iTeam]
                                if bDebugMessages == true then LOG(sFunctionRef..': Only have 1 exp bomber, target is unshielded, but will consider if ground AA threat so great we want to do aoe attack on the AOE, (tTargetLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0)='..(tTargetLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0)) end
                                if (tTargetLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) >= 8000 then --Equiv of 5 SAMs
                                    bUseAOEForTargetIfNotTooClose = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will use aoe to attack target due to significant enemy ground threat') end
                                end
                            end
                        end
                        if bUseAOEForTargetIfNotTooClose then
                            local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oBestEnemyTarget:GetPosition(), oBomber:GetPosition())
                            if iDistToTarget >= 40 then
                                --Just try to target the unit with our aoe, provided there aren't friendly units near it
                                local tTarget = M28Utilities.MoveInDirection(oBomber:GetPosition(), M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), oBestEnemyTarget:GetPosition()), iDistToTarget - iAOE + math.max(iAOE * 0.1, 3), true, false, true)
                                if M28Logic.GetDamageFromBomb(aiBrain, tTarget, iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor,    nil,                            nil,                nil,                            iMobileUnitInnerDamageFactor,                nil,               iOptionalShieldReductionFactor,     true, 4, M28UnitInfo.refCategoryGroundAA) > 0 then
                                    M28Orders.IssueTrackedGroundAttack(oBomber, tTarget, iAOE * 0.5, false, 'ExpAG', false)
                                    bUseAOEForTargetIfNotTooClose = true
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to ground fire near the shielded target, tTarget='..repru(tTarget)..'; bUseAOEForTargetIfNotTooClose='..tostring(bUseAOEForTargetIfNotTooClose)..'; Damage from bomb='..M28Logic.GetDamageFromBomb(aiBrain, tTarget, iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor,    nil,                            nil,                nil,                            iMobileUnitInnerDamageFactor,                nil,               iOptionalShieldReductionFactor,     true, 4, M28UnitInfo.refCategoryGroundAA)) end
                            else
                                bUseAOEForTargetIfNotTooClose = false
                                if bDebugMessages == true then LOG(sFunctionRef..': Target is too close to bomber so wont use aoe attack') end
                            end
                        end

                        if not(bUseAOEForTargetIfNotTooClose) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will ground fire the location that deals the most damage') end
                            --Structures - get best aoe target
                            if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oBestEnemyTarget.UnitId) then
                                local tTarget = M28Logic.GetBestAOETarget(oBomber:GetAIBrain(), oBestEnemyTarget:GetPosition(), iAOE, iDamage, false, nil, nil, nil, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, nil, iMobileUnitInnerDamageFactor, iOptionalShieldReductionFactor)
                                M28Orders.IssueTrackedGroundAttack(oBomber, tTarget, iAOE * 0.5, false, 'ExpAG', false)
                            elseif M28UnitInfo.IsUnitUnderwater(oBestEnemyTarget) then
                                M28Orders.IssueTrackedGroundAttack(oBomber, oBestEnemyTarget:GetPosition(), iAOE * 0.5, false, 'ExpAG', false)
                            else
                                M28Orders.IssueTrackedAttack(oBomber, oBestEnemyTarget, false, 'ExpAU', false)
                            end
                        end
                    end
                end

                iCurBomberPerTick = iCurBomberPerTick + 1
                if iCurBomberPerTick >= iBombersPerTick then
                    iCurBomberPerTick = 0
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(1)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                end
            end
        end
    end


    --Clear assignment flags for any refueling gunships
    if M28Utilities.IsTableEmpty(tBombersForRetreating) == false then
        for iBomber, oBomber in tBombersForRetreating do
            if M28UnitInfo.IsUnitValid(oBomber) then
                local tMovePoint = M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint]
                M28Orders.IssueTrackedMove(oBomber, tMovePoint, 10, false, 'ExBRetr', false)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageOtherAir(iTeam, iAirSubteam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageOtherAir'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local tAvailableBombers, tBombersForRefueling, tUnavailableUnits = GetAvailableLowFuelAndInUseAirUnits(iTeam, iAirSubteam, M28UnitInfo.refCategoryMercy)

    if M28Utilities.IsTableEmpty(tAvailableBombers) == false then
        --Simple logic for now as placeholder in case we get given bombers - attack nearest enemy to rally point in up to a 300 range

        local aiBrain
        for iBrain, oBrain in M28Team.tAirSubteamData[iAirSubteam][M28Team.subreftoFriendlyM28Brains] do
            aiBrain = oBrain
            break
        end
        local tRallyPoint = M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint]
        local tNearbyEnemyUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryStructure - categories.TECH1 + categories.COMMAND, tRallyPoint, 300, 'Enemy')
        if M28Utilities.IsTableEmpty(tNearbyEnemyUnits) == false then
            local iClosestUnitDist = 10000
            local oClosestUnit
            local iCurDist

            for iUnit, oUnit in tNearbyEnemyUnits do
                if oUnit:GetFractionComplete() >= 0.8 and not(oUnit:IsUnitState('Attached')) and not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tRallyPoint, oUnit:GetPosition())
                    if iCurDist < iClosestUnitDist then
                        iClosestUnitDist = iCurDist
                        oClosestUnit = oUnit
                    end
                end
            end
            if oClosestUnit then
                for iBomber, oBomber in tAvailableBombers do
                    M28Orders.IssueTrackedAttack(oBomber, oClosestUnit, false, 'PlaceholderMA', false)
                end
            end
        end
    end

    --Send units for refueling
    if bDebugMessages == true then LOG(sFunctionRef..': Finished giving bomber orders, is table of air for refueling empty='..tostring(M28Utilities.IsTableEmpty(tBombersForRefueling))) end
    --Run the function even if no units wanting refueling so already attached untis can be sent on their way
    SendUnitsForRefueling(tBombersForRefueling, iTeam, iAirSubteam)
    if bDebugMessages == true and M28Utilities.IsTableEmpty(tBombersForRefueling) == false then
        LOG(sFunctionRef..': Will send '..table.getn(tBombersForRefueling)..' units to refuel')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedNovaxUnloadCheck(oUnit)
    --Redundancy to try and ensure a satellite is launched
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DelayedNovaxUnloadCheck'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if oUnit.Satellite then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        function CheckAndReleaseIfRelevant()
            if bDebugMessages == true then LOG(sFunctionRef..': Checking for novax '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at time='..GetGameTimeSeconds()..'; reprs='..reprs(oUnit)) end
            if oUnit.Satellite and M28UnitInfo.IsUnitValid(oUnit.Satellite) then
                DetachSatellite(oUnit.Satellite, nil)
            end

        end
        if M28UnitInfo.IsUnitValid(oUnit) then
            if not(oUnit[refbActiveNovaxUnloadCheck]) then
                oUnit[refbActiveNovaxUnloadCheck] = true
                while M28UnitInfo.IsUnitValid(oUnit) do
                    CheckAndReleaseIfRelevant()
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitSeconds(30)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                end
            else
                --Check as a 1-off
                CheckAndReleaseIfRelevant()
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DetachSatellite(oNovaxSatellite, iOptionalDelayInSeconds)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DetachSatellite'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if (iOptionalDelayInSeconds or 0) > 0 then
        WaitSeconds(iOptionalDelayInSeconds)
    end
    if M28UnitInfo.IsUnitValid(oNovaxSatellite) then
        if bDebugMessages == true then LOG(sFunctionRef..': Unit state of satellite='..M28UnitInfo.GetUnitState(oNovaxSatellite)..'; Time='..GetGameTimeSeconds()) end
        if oNovaxSatellite:IsUnitState('Attached') then
            oNovaxSatellite:DetachFrom()
            local tMoveLocation = oNovaxSatellite:GetPosition()
            tMoveLocation[1] = tMoveLocation[1] - 1
            tMoveLocation[3] = tMoveLocation[3] - 1
            tMoveLocation[2] = GetSurfaceHeight(tMoveLocation[1], tMoveLocation[3])
            IssueMove({oNovaxSatellite}, tMoveLocation)
            oNovaxSatellite:Open()
        end
        --self.Satellite:DetachFrom()
        --IssueToUnitMove(self.Satellite, self:GetRallyPoint())
        --self.Satellite:Open()
    end
end

function ConsiderRecordingStratBomberToSuicideInto(oBomber, bBomberKilledMex)
    --E.g. if enemy strat bomber fires a bomb, and we dont have it recorded as a 'suicide into' target, consider adding it
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderRecordingStratBomberToSuicideInto'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(oBomber[refiAssignedSuicideASF]) then
        --Is bomber on our side of the map, or we have air control, or did ut kill a mex?
        if bDebugMessages == true then LOG(sFunctionRef..': Considering bomber '..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..' owned by brain '..oBomber:GetAIBrain().Nickname..'; bBomberKilledMex='..tostring(bBomberKilledMex or false)..'; Our AirAA='..M28Team.tTeamData[oBomber:GetAIBrain().M28Team][M28Team.subrefiOurAirAAThreat]..'; Time='..GetGameTimeSeconds()) end
        local iBomberTeam = oBomber:GetAIBrain().M28Team
        local bHaveNoM28Enemies = true
        local tbTeamsConsidered = {}
        local bIncludeForAirSubteam
        for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
            if not(oBrain.M28Team == iBomberTeam) then
                bHaveNoM28Enemies = false
                if not(tbTeamsConsidered[oBrain.M28Team]) then
                    tbTeamsConsidered[oBrain.M28Team] = true

                    --How close is the bomber to closest friendly base vs closest enemy base?
                    bIncludeForAirSubteam = false
                    if bBomberKilledMex then
                        bIncludeForAirSubteam = true
                    else
                        --Is the bomber on our side of the map or about to go onto our side?
                        local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oBomber:GetPosition(), true, oBrain.M28Team)
                        if tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.5 then
                            bIncludeForAirSubteam = true
                        elseif tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.65 and (((tLZOrWZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) + (tLZOrWZTeamData[M28Map.subrefWZThreatEnemyAA] or 0) < 800 and M28Team.tAirSubteamData[oBrain.M28AirSubteam][M28Team.refbHaveAirControl])) or
                            (tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.6 and (M28Team.tTeamData[oBrain.M28Team][M28Team.subrefiOurAirAAThreat] >= 10000 or (tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.55 and M28Team.tTeamData[oBrain.M28Team][M28Team.subrefiOurAirAAThreat] >= 5000 and M28Utilities.GetAngleDifference(M28UnitInfo.GetUnitFacingAngle(oBomber), M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), tLZOrWZTeamData[M28Map.reftClosestFriendlyBase])) <= 50))) then
                            bIncludeForAirSubteam = true
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Mod dist%='..tLZOrWZTeamData[M28Map.refiModDistancePercent]..'; Enemy groundAA='..(tLZOrWZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) + (tLZOrWZTeamData[M28Map.subrefWZThreatEnemyAA] or 0)..'; Have air control='..tostring(M28Team.tAirSubteamData[oBrain.M28AirSubteam][M28Team.refbHaveAirControl])..'; bIncludeForAirSubteam='..tostring(bIncludeForAirSubteam)) end
                    end
                    if bIncludeForAirSubteam then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will add bomber to potential suicide targets') end
                        AddBomberToPotentialSuicideTargets(oBomber, oBrain.M28Team)
                    end
                end
            end
        end
        if bHaveNoM28Enemies then
            oBomber[refiAssignedSuicideASF] = 0 --Dont want to consider this logic again
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AddBomberToPotentialSuicideTargets(oBomber, iTeam)
    if not(M28Team.tTeamData[iTeam][M28Team.toBomberSuicideTargets]) then M28Team.tTeamData[iTeam][M28Team.toBomberSuicideTargets] = {} end
    table.insert(M28Team.tTeamData[iTeam][M28Team.toBomberSuicideTargets], oBomber)
end

function AssignASFsToEnemyStrats(tAvailableAirAA, iTeam, iAirSubteam)
    --Checks if we have any asfs or swifties in tAvailableAirAA, and if so assigns them to target enemy strats
    local toASFs = EntityCategoryFilterDown(categories.TECH2 + categories.TECH3, tAvailableAirAA)

    if M28Utilities.IsTableEmpty(toASFs) == false then
        --For simplicity will just consider the closest enemy strat (since we will be running this logic every second if we have more available asfs)
        local oClosestStratToRallyPoint
        local iCurDist
        local iClosestDist = 10000
        local tRally = M28Team.tAirSubteamData[iAirSubteam][M28Team.reftAirSubRallyPoint]
        for iStrat, oStrat in M28Team.tTeamData[iTeam][M28Team.toBomberSuicideTargets] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tRally, oStrat:GetPosition())
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestStratToRallyPoint = oStrat
            end
        end
        --Get closest (available) asfs to the strat
        local iClosest1Dist = 10000
        local iClosest2Dist = 10000
        local oClosest1, oClosest2
        for iUnit, oUnit in toASFs do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(oClosestStratToRallyPoint:GetPosition(), oUnit:GetPosition())
            if iCurDist < iClosest2Dist then
                if iCurDist < iClosest1Dist then
                    iClosest2Dist = iClosest1Dist
                    oClosest2 = oClosest1
                    iClosest1Dist = iCurDist
                    oClosest1 = oUnit
                else
                    oClosest2 = oUnit
                    iClosest2Dist = iCurDist
                end
            end
        end


        if oClosestStratToRallyPoint[refiAssignedSuicideASF] < 1 and oClosest2 then
            --Assign both asfs
            ForkThread(SuicideASFIntoStrat, oClosestStratToRallyPoint, oClosest1)
            ForkThread(SuicideASFIntoStrat, oClosestStratToRallyPoint, oClosest2)
            for iUnit, oUnit in tAvailableAirAA do
                if oUnit == oClosest1 or oUnit == oClosest2 then
                    table.remove(tAvailableAirAA, iUnit)
                end
            end
        else
            ForkThread(SuicideASFIntoStrat, oClosestStratToRallyPoint, oClosest1)
            for iUnit, oUnit in tAvailableAirAA do
                if oUnit == oClosest1 then
                    table.remove(tAvailableAirAA, iUnit)
                end
            end
        end
    end
end

function SuicideASFIntoStrat(oStrat, oASF, bNoLimitOnASFToAssign)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SuicideASFIntoStrat'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28UnitInfo.IsUnitValid(oStrat) and M28UnitInfo.IsUnitValid(oASF) then
        if bDebugMessages == true then LOG(sFunctionRef..': will suicide asf '..oASF.UnitId..M28UnitInfo.GetUnitLifetimeCount(oASF)..' into oStrat '..oStrat.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStrat)..'; bNoLimitOnASFToAssign='..tostring(bNoLimitOnASFToAssign or false)..'; Start of code, time='..GetGameTimeSeconds()) end
        local iASFValue = 1
        if EntityCategoryContains(categories.TECH2, oASF.UnitId) then
            iASFValue = 0.5
        end
        oStrat[refiAssignedSuicideASF] = (oStrat[refiAssignedSuicideASF] or 0) + iASFValue
        oASF[M28UnitInfo.refbSpecialMicroActive] = true
        local iTeam = oASF:GetAIBrain().M28Team
        if oStrat[refiAssignedSuicideASF] >= 2 and not(bNoLimitOnASFToAssign) then
            for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.toBomberSuicideTargets] do
                if oUnit == oStrat then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will remove strat from list of suicide targets as we now have at least 2 ASFs assigned to it') end
                    table.remove(M28Team.tTeamData[iTeam][M28Team.toBomberSuicideTargets], iUnit)
                    break
                end
            end
        end
        --Move into range
        while M28Utilities.GetDistanceBetweenPositions(oStrat:GetPosition(), oASF:GetPosition()) > 30 do
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and move asf '..oASF.UnitId..M28UnitInfo.GetUnitLifetimeCount(oASF)..' into position as are far away from the strat '..oStrat.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStrat)) end
            M28Orders.IssueTrackedMove(oASF, oStrat:GetPosition(), 10, false, 'SuicM', true)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if not(M28UnitInfo.IsUnitValid(oStrat)) or not(M28UnitInfo.IsUnitValid(oASF)) then break end
        end
        --Issue attack, and dont stop until either asf or strat is dead
        while M28UnitInfo.IsUnitValid(oStrat) and M28UnitInfo.IsUnitValid(oASF) do
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and give attack order to asf '..oASF.UnitId..M28UnitInfo.GetUnitLifetimeCount(oASF)..' to attack strat '..oStrat.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStrat)..'; Is ASF special micro still true='..tostring(oASF[M28UnitInfo.refbSpecialMicroActive] or false)) end
            M28Orders.IssueTrackedAttack(oASF, oStrat, false, 'SuicA', true)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Either asf or strat is no longer valid, clearing asf special micro flag') end
        oASF[M28UnitInfo.refbSpecialMicroActive] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RemoveFirstExpBomberTarget(iDelayBeforeRemoving)
    WaitSeconds(iDelayBeforeRemoving)
    if tiRecentExpBomberTargets[1] then table.remove(tiRecentExpBomberTargets, 1) end
end

function EnemyT1BomberTracker(oBomber, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'EnemyT1BomberTracker'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --For the first 15m track enemy t1 bomber and get nearby engineers to the target
    if bDebugMessages == true then LOG(sFunctionRef..': oBomber='..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; reprs='..reprs(oBomber)) end
    --For simplicity will just do a square (not as accurate but avoids neeidng to do moveindirection multiple times)
    --bomber has range of 40; allowing for targeting of enemies within slightly shorter dist than this, and speed of bomber and delay in unit response, go with 30 min 60 max which equals 45 average
    local iAvDist = 45
    --[[local iMinDist = 30
    local iMaxDist = 60
    local iWidth = 20
    local iAvDist = (iMinDist + iMaxDist)*0.5--]]
    local iRadius = 20

    local iCurFacingDirection
    while M28UnitInfo.IsUnitValid(oBomber) and GetGameTimeSeconds() <= 900 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] < 3 do
        --Get bomber facing direction, and then get any friendly engineers in this area
        iCurFacingDirection = M28UnitInfo.GetUnitFacingAngle(oBomber)
        local tMidpoint = M28Utilities.MoveInDirection(oBomber:GetPosition(), iCurFacingDirection, iAvDist)
        local rPotentialTargetRect = M28Utilities.GetRectAroundLocation(tMidpoint, iRadius)
        local tUnitsInRect = GetUnitsInRect(rPotentialTargetRect)
        if bDebugMessages == true then
            LOG(sFunctionRef..': Checking if have units in rPotentialTargetRect='..repru(rPotentialTargetRect)..'; Is table empty='..tostring(M28Utilities.IsTableEmpty(tUnitsInRect))..'; oBomber='..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber))
            M28Utilities.DrawRectangle(rPotentialTargetRect)
        end
        if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
            local tEngisInArea = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer - categories.AIR, tUnitsInRect)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy engineers near bomber '..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; Is table empty='..tostring(M28Utilities.IsTableEmpty(tEngisInArea))) end
            if M28Utilities.IsTableEmpty(tEngisInArea) == false then
                for iEngi, oEngi in tEngisInArea do
                    if bDebugMessages == true then LOG(sFunctionRef..': Engi '..oEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngi)..' owned by '..oEngi:GetAIBrain().Nickname..' on team '..oEngi:GetAIBrain().M28Team..' - is special micro active='..tostring(oEngi[M28UnitInfo.refbSpecialMicroActive] or false)..'; Backup dist='..(oEngi:GetBlueprint().Physics.BackUpDistance or 'nil')) end
                    if oEngi:GetAIBrain().M28AI and oEngi:GetAIBrain().M28Team == iTeam and not(oEngi:GetAIBrain().M28Easy) then
                        --Have an M28AI engineer on our team that is near to the enemy t1 bomber; if special micro isn't active then have the engi move towards the bomber and flag a 'special micro flag that can be ignored if want to dodge shot'
                        if not(oEngi[M28UnitInfo.refbSpecialMicroActive]) or oEngi[M28UnitInfo.refbLowerPriorityMicroActive] then
                            local iCurBackupDist = oEngi:GetBlueprint().Physics.BackUpDistance
                            if (iCurBackupDist or 0) > 0 then
                                local iEngiFacingDist =  M28UnitInfo.GetUnitFacingAngle(oEngi)
                                local iAngleFromEngiToBomber = M28Utilities.GetAngleFromAToB(oEngi:GetPosition(), oBomber:GetPosition())
                                local iAngleDifBetweenEngineerAndBomber = M28Utilities.GetAngleDifference(iEngiFacingDist, iAngleFromEngiToBomber)
                                local tPotentialMoveLocation
                                --want the engineer to move away from the bomber, either by moving forwards, or backwards (and would then hopefully move towards it via the normal dodge logic), since if the bomber is approaching us and is cybran/uef then the later missiles are moelikely to hit us
                                if iAngleDifBetweenEngineerAndBomber >= 90 then
                                    --Engi facing direction means it should move away from the bomber if going forwards
                                    tPotentialMoveLocation = M28Utilities.MoveInDirection(oEngi:GetPosition(), iEngiFacingDist, iCurBackupDist - 1) --tried with -0.5 but engi would turn around instead of moving there
                                else
                                    --Engi facing direction means it should move away from the bomber if going backwards
                                    tPotentialMoveLocation = M28Utilities.MoveInDirection(oEngi:GetPosition(), iEngiFacingDist - 180, iCurBackupDist - 1) --tried with -0.5 but engi would turn around instead of moving there
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to backup, iEngiFacingDist='..iEngiFacingDist..'; tPotentialMoveLocation='..repru(tPotentialMoveLocation)..'; Engi position='..repru(oEngi:GetPosition())..'; Plateau of tPotentialMoveLocation='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, tPotentialMoveLocation) or 'nil')..'; Engi plateau='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oEngi:GetPosition()) or 'nil')) end
                                if M28Utilities.IsTableEmpty(tPotentialMoveLocation) == false and NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, tPotentialMoveLocation) == NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oEngi:GetPosition()) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will move in opposite direction of engi cur facing dist, as a backup move, as there is an appraoching bomber (so hopefully it is easier to dodge the bomber shot when dodge bomb micro triggers), Time='..GetGameTimeSeconds()) end
                                    M28Orders.IssueTrackedMove(oEngi, tPotentialMoveLocation, math.min(3, iCurBackupDist - 2), false, 'PreemDodB', true)
                                    M28Micro.TrackTemporaryUnitMicro(oEngi, 2, nil, true) --will reduce by 0.001ish as part of the function
                                end
                            end
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end