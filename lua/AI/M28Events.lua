---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 09:03
---



local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Config = import('/mods/M28AI/lua/M28Config.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
local M28Chat = import('/mods/M28AI/lua/AI/M28Chat.lua')

refiLastWeaponEvent = 'M28LastWep' --Gametimeseconds that last updated onweapon
refbAlreadyRunUnitKilled = 'M28EventsOnKilledRun'


function OnPlayerDefeated(aiBrain)

    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnPlayerDefeated'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': Player has been defeated, brain='..aiBrain.Nickname..'; Was this an M28AI='..tostring(aiBrain.M28AI or false)..'; ScenarioInfo.Options.Share='..(ScenarioInfo.Options.Share or 'nil')) end
        aiBrain.M28IsDefeated = true

        M28Team.tTeamData[aiBrain.M28Team][M28Team.refiTimeOfLastTeammateDeath] = GetGameTimeSeconds()

        --Was it an M28AI?
        if aiBrain.M28AI then
            --Give resources to teammates
            local bHaveTeammates = false
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
                for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyHumanAndAIBrains] do
                    if not(oBrain == aiBrain) and not(oBrain.M28IsDefeated) and not(oBrain:IsDefeated()) then
                        bHaveTeammates = true
                        break
                    end
                end
            end
            if bHaveTeammates then
                ForkThread(M28Team.GiveAllResourcesToAllies, aiBrain)
                M28Team.tTeamData[aiBrain.M28Team][M28Team.refiTimeOfLastM28PlayerDefeat] = GetGameTimeSeconds()
            else
                --Message on death - Will cover as part of M28Chat function
            end
        end

        --Update tables tracking the various brains
        ForkThread(M28Team.RefreshActiveBrainListForBrainDeath, aiBrain)
        --if the base will have been destroyed, or there isn't a base anyway, then rerecord positions
        if not(ScenarioInfo.Options.Share == 'FullShare') or aiBrain:GetCurrentUnits(categories.ALLUNITS - categories.INSIGNIFICANTUNIT) <= 2 then
            ForkThread(M28Map.ReassessPositionsForPlayerDeath, aiBrain)
        end
        ForkThread(M28Chat.ConsiderEndOfGameMessage, aiBrain)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnACUKilled(oUnit)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnACUKilled'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then
            local oKilledBrain = oUnit:GetAIBrain()
            if oKilledBrain then
                LOG(sFunctionRef..': ACU '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has just died, and its brain is '..oKilledBrain.Nickname..'; ScenarioInfo.Options.Victory='..(ScenarioInfo.Options.Victory or 'nil')..'; Cur ACU and SACU units='..oUnit:GetAIBrain():GetCurrentUnits(categories.COMMAND + categories.SUBCOMMANDER))
            else
                LOG(sFunctionRef..': ACU '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has just died, and it doesnt have a brain')
            end
        end
        local oKilledBrain = oUnit:GetAIBrain()
        local bDefeated = false

        if ScenarioInfo.Options.Victory == "demoralization" then
            bDefeated = true
        elseif oKilledBrain and not(oKilledBrain.M28IsDefeated) and ScenarioInfo.Options.Victory == 'decapitation' then
            local tCurUnits = oKilledBrain:GetListOfUnits(categories.COMMAND + categories.SUBCOMMANDER, false, true)
            if M28Utilities.IsTableEmpty(tCurUnits) then
                bDefeated = true
            else
                bDefeated = true
                for iOwnedUnit, oOwnedUnit in tCurUnits do
                    if not(oOwnedUnit == oUnit) and not(oOwnedUnit.Dead) and not(oUnit['M28Dead']) then
                        bDefeated = false
                        break
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Will consider calling OnPlayerDefeated, .M28IsDefeated='..tostring(oUnit:GetAIBrain().M28IsDefeated or false)..'; bDefeated='..tostring(bDefeated)) end
        if bDefeated then
            if oUnit:GetAIBrain() then
                if not(oUnit:GetAIBrain().M28IsDefeated) then
                    OnPlayerDefeated(oUnit:GetAIBrain())
                end
            else
                --Possibility that we have already recorded the unit death, so wait 1 second and then if any brains show as defeated but not M28Defeated then run the function
                ForkThread(M28Team.DelayedPlayerDeathCheck)
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnKilled(oUnitKilled, instigator, type, overkillRatio)
    --WARNING: Doesnt trigger when an ACU is killed
    --Will make sure the OnUnitDeath event is called, i.e. this function should only be used where we only want something to run when we killed something, or an enemy killed something of ours

    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnKilled'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': event triggered for unit '..(oUnitKilled.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitKilled) or 'nil')..' owned by brain '..oUnitKilled:GetAIBrain().Nickname..'; Have already run='..tostring(oUnitKilled[refbAlreadyRunUnitKilled] or false)) end

        if not(oUnitKilled[refbAlreadyRunUnitKilled]) then
            oUnitKilled[refbAlreadyRunUnitKilled] = true

            if bDebugMessages == true then LOG(sFunctionRef..': oUnitKilled='..oUnitKilled.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitKilled)..'; GameTime='..GetGameTimeSeconds()) end
            if oUnitKilled.GetAIBrain then
                OnUnitDeath(oUnitKilled) --Ensure this is run when a unit dies

                --were we killed by something?
                local oKillerUnit

                if instigator and not(instigator:BeenDestroyed()) and not(instigator.Dead) then
                    if instigator.GetLauncher and instigator:GetLauncher() then
                        oKillerUnit = instigator:GetLauncher()
                    elseif instigator.DamageData and not(instigator.unit) and not(instigator.UnitId) then
                        --Can get errors for artillery shells when running IsProjectile
                    elseif IsProjectile(instigator) or IsCollisionBeam(instigator) then
                        if instigator.unit then
                            oKillerUnit = instigator.unit
                        end
                    elseif IsUnit(instigator) then
                        oKillerUnit = instigator
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Have an instigator, checking if have valid killer unit. Is valid='..tostring(M28UnitInfo.IsUnitValid(oKillerUnit))) end
                    if oKillerUnit and oKillerUnit.GetAIBrain then

                        --Non-M28 specific killer logic:

                        if EntityCategoryContains(M28UnitInfo.refCategoryBomber * categories.TECH3, oKillerUnit.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryT3Power + M28UnitInfo.refCategoryT2Power, oKillerUnit.UnitId) then
                            ForkThread(ConsiderRecordingStratBomberToSuicideInto, oKillerUnit, true)
                        end

                        --T2 arti firebase tracking if they get lots of kills:
                        if oUnitKilled:GetAIBrain().M28AI then
                            if EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oKillerUnit.UnitId) then M28Land.ConsiderIfHaveEnemyFirebase(oUnitKilled:GetAIBrain().M28Team, oKillerUnit) end
                        end

                        --M28 specific killer logic
                        local oKillerBrain = oKillerUnit:GetAIBrain()
                        if oKillerBrain.M28AI then
                            if EntityCategoryContains(M28UnitInfo.refCategorySatellite, instigator.UnitId) and M28UnitInfo.IsUnitValid(oKillerUnit) then
                                ForkThread(M28Air.NovaxCoreTargetLoop, oKillerBrain, instigator, true)
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oKillerUnit.UnitId) and not(type) and not(overkillRatio) and not(oKillerBrain.M28Team == oUnitKilled:GetAIBrain().M28Team) then
                                --We have reclaimed an enemy - if there arent many enemies in this zone then update the zone; also check for enemy targets within build range to reclaim
                                local tNearbyReclaimableEnemies = oKillerBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryReclaimable, oKillerUnit:GetPosition(), oKillerUnit:GetBlueprint().Economy.MaxBuildDistance, 'Enemy')
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby reclaimable enemies empty='..tostring( M28Utilities.IsTableEmpty(tNearbyReclaimableEnemies))) end
                                local bNotGivenReclaimOrder = true
                                if M28Utilities.IsTableEmpty(tNearbyReclaimableEnemies) == false then
                                    for iPotentialEnemy, oPotentialEnemy in tNearbyReclaimableEnemies do
                                        if not(oPotentialEnemy == oUnitKilled) and M28UnitInfo.IsUnitValid(oPotentialEnemy) and oPotentialEnemy:GetHealth() > 0 then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will issue new reclaim order for oKillerUnit='..(oKillerUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oKillerUnit) or 'nil')..' owend by brain'..oKillerUnit:GetAIBrain().Nickname..' to target enemy unit '..(oPotentialEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oPotentialEnemy) or 'nil')..'; Time='..GetGameTimeSeconds()..'; Enemy unit health='..oPotentialEnemy:GetHealth()..'; Enemy unit brain owner='..oPotentialEnemy:GetAIBrain().Nickname) end

                                            ForkThread(M28Orders.IssueTrackedReclaim, oKillerUnit, oPotentialEnemy, false, 'FollowRec', false) --WHen tried doing but not via forked thread ended up with game crashing
                                            bNotGivenReclaimOrder = false
                                            break
                                        end
                                    end
                                end
                                if bNotGivenReclaimOrder then
                                    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnitKilled:GetPosition())
                                    if (iPlateauOrZero or 0) > 0 and (iLandOrWaterZone or 0) > 0 then
                                        local tLZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][oKillerBrain.M28Team]
                                        --if we reclaimed an enemy unit, then update units in that zone if arent many units left
                                        if not(tLZTeamData[M28Map.subrefTEnemyUnits][2]) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                                            if bDebugMessages == true then LOG(sFunctionRef..': have just killed a unit so will update the position of all enemy units in the zone, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; Time='..GetGameTimeSeconds()) end
                                            --UpdateUnitPositionsAndLandZone(aiBrain,   tUnits,                                 iTeam,              iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
                                            M28Land.UpdateUnitPositionsAndLandZone(oKillerBrain, tLZTeamData[M28Map.subrefTEnemyUnits], oKillerBrain.M28Team, iPlateauOrZero, iLandOrWaterZone, true,                   false,          tLZTeamData, true,                                  true)
                                        end
                                    end

                                end
                            end
                            if EntityCategoryContains(M28UnitInfo.refCategoryT3Mex + M28UnitInfo.refCategoryT3Power + M28UnitInfo.refCategoryExperimentalLevel, oUnitKilled.UnitId) then
                                --Scathis special message if killed by UEF
                                if oKillerUnit and EntityCategoryContains(M28UnitInfo.refCategoryScathis, oUnitKilled.UnitId) and EntityCategoryContains(categories.UEF, oKillerUnit.UnitId) and oKillerUnit:GetAIBrain()[M28Chat.refiAssignedPersonality] == M28Chat.refiFletcher then
                                    ForkThread(M28Chat.SendMessage, oKillerUnit:GetAIBrain(), 'UEFKilledScathis', LOC('<LOC X05_M02_050_010>[{i Fletcher}]: Scratch one Scathis. Fletcher out.'), 1, 600, false, true, 'X05_Fletcher_M02_03831', 'X05_VO')
                                    --Dont trigger if killed via nuke
                                elseif oKillerUnit and not(EntityCategoryContains(M28UnitInfo.refCategorySML, oKillerUnit.UnitId)) then
                                    --Check mod dist is far enoguh away from our core base that unlikely it has dealt lots of damage
                                    local bConsiderMessage = true
                                    if EntityCategoryContains(categories.MOBILE, oUnitKilled.UnitId) then
                                        bConsiderMessage = false
                                        local tUnitLZData, tUnitLZTeamData = M28Map.GetLandOrWaterZoneData(oUnitKilled:GetPosition(), true, oKillerUnit:GetAIBrain().M28Team)
                                        if tUnitLZTeamData and tUnitLZTeamData[M28Map.refiModDistancePercent] >= 0.3 and not(tUnitLZTeamData[M28Map.subrefLZbCoreBase]) and ((oUnitKilled.VetExperience or oUnitKilled.Sync.totalMassKilled or 0) < 12000) then
                                            bConsiderMessage = true
                                        end
                                    end
                                    if bConsiderMessage then
                                        if (oUnitKilled.VetExperience or oUnitKilled.Sync.totalMassKilled or 0) < (oUnitKilled[M28UnitInfo.refiUnitMassCost] or 0) * 0.5 or EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryGameEnder, oUnitKilled.UnitId) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': About to call chat for valuable unit killed, oUnitKilled='..oUnitKilled.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitKilled)..', owned by brain '..oUnitKilled:GetAIBrain().Nickname..'; oKillerUnit='..oKillerUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oKillerUnit)..' owned by brain '..(oKillerUnit:GetAIBrain().Nickname or 'nil')) end
                                            ForkThread(M28Chat.JustKilledEnemyValuableUnit, oUnitKilled.UnitId, oUnitKilled:GetAIBrain(), oKillerBrain) --If dont do as forked thread then any error breaks the game
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                --Consider message if this was a significant unit
                if oUnitKilled:GetAIBrain().M28AI and EntityCategoryContains(M28UnitInfo.refCategoryT3Mex + M28UnitInfo.refCategoryT3Power + M28UnitInfo.refCategoryStructure * categories.EXPERIMENTAL + M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategorySML * categories.STRUCTURE, oUnitKilled.UnitId) then
                    if oUnitKilled:GetFractionComplete() == 1 or (EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnitKilled.UnitId) and oUnitKilled:GetFractionComplete() >= 0.6) then
                        local tUnitLZData, tUnitLZTeamData = M28Map.GetLandOrWaterZoneData(oUnitKilled:GetPosition(), true, oUnitKilled:GetAIBrain().M28Team)
                        --Was the unit in a mod dist of <=0.4 (so getting close to base or in base)?
                        if tUnitLZTeamData[M28Map.refiModDistancePercent] <= 0.4 and (tUnitLZTeamData[M28Map.refiModDistancePercent] <= 0.3 or not(EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnitKilled.UnitId))) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Just lost unit '..oUnitKilled.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitKilled)..', owned by brain'..oUnitKilled:GetAIBrain().Nickname..'; Mod dist='..(tUnitLZTeamData[M28Map.refiModDistancePercent] or 'nil')..'; oKillerUnit='..(oKillerUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oKillerUnit) or 'nil')..'; will send taunt if havent sent one recently, Time='..GetGameTimeSeconds()) end
                            ForkThread(M28Chat.JustLostValuableUnit, oUnitKilled.UnitId, oUnitKilled:GetAIBrain()) --If dont do as forked thread then any error breaks the game
                        end
                    end
                end
            elseif bDebugMessages == true then LOG(sFunctionRef..': Unit killed doesnt have a brain')
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnPropDestroyed(oProp)
    --Confirmed manually this triggers e.g. if a bomber destroys a rock, and if a tree is reclaimed
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnPropDestroyed'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnYthothaDeath(oUnit)
    --Called when a ythotha (oUnit) is flagged as dying or being killed
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnYthothaDeath'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        local refbYthothaDeath = 'M28EventYthothaDeath'

        if not(oUnit[refbYthothaDeath]) then
            oUnit[refbYthothaDeath] = true
            local tNearbyUnits
            if bDebugMessages == true then LOG(sFunctionRef..': Ythotha has just died, will look for nearby units and tell them to run away') end
            local iTimeToRun
            local iSearchRange = 70
            for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                tNearbyUnits = oBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand, oUnit:GetPosition(), 50, 'Ally')
                if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                    for iFriendlyUnit, oFriendlyUnit in tNearbyUnits do
                        if bDebugMessages == true then LOG(sFunctionRef..': oFriendlyUnit='..oFriendlyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFriendlyUnit)..'; if we own it then will make it run away') end
                        if oFriendlyUnit:GetAIBrain() == oBrain then --Only do this for M28 units
                            if M28UnitInfo.IsUnitValid(oFriendlyUnit, true) then
                                if not(oFriendlyUnit[M28UnitInfo.refbEasyBrain]) then
                                    iTimeToRun = math.min(32, math.max(10, 18 + (50 - M28Utilities.GetDistanceBetweenPositions(oFriendlyUnit:GetPosition(), oUnit:GetPosition()) / (oFriendlyUnit:GetBlueprint().Physics.MaxSpeed or 1))))
                                    if bDebugMessages == true then LOG(sFunctionRef..': Telling friendly unit '..oFriendlyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFriendlyUnit)..' to move away for 18s via moveawayfromtarget order') end
                                    ForkThread(M28Micro.MoveAwayFromTargetTemporarily, oFriendlyUnit, iTimeToRun, oUnit:GetPosition())
                                end
                            end
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnUnitDeath(oUnit)
    --NOTE: This is called by the death of any unit of any player, so careful with what commands are given
        --Some callbacks line onkilled will call this as well to make sure it is run (since for some things like when an ACU is killed it doesnt trigger directly)
    if M28Utilities.bM28AIInGame and M28Map.bMapLandSetupComplete then --No point running on death logic for units at start of the game
        local sFunctionRef = 'OnUnitDeath'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



        if bDebugMessages == true then
            LOG(sFunctionRef..'Hook successful. oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; GameTime='..GetGameTimeSeconds()..'; oUnit[refbAlreadyRunUnitKilled]='..tostring(oUnit[refbAlreadyRunUnitKilled] or false)..'; oUnit[M28Dead]='..tostring(oUnit['M28Dead'] or false))
            if oUnit.GetAIBrain then LOG(sFunctionRef..': Unit owner='..oUnit:GetAIBrain().Nickname) end
        end
        --Is it an ACU?
        if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) or (ScenarioInfo.Options.Victory == 'decapitation' and EntityCategoryContains(categories.SUBCOMMANDER, oUnit.UnitId)) then
            OnACUKilled(oUnit)
        else
            if oUnit.CachePosition and (not(oUnit.UnitId) or not(EntityCategoryContains(categories.ALLUNITS - categories.INSIGNIFICANTUNIT, oUnit.UnitId))) then --Redundancy to check not dealing with a unit, not sure this will actually trigger as looks like wreck deaths are picked up by the prop logic above
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Unit killed has a cache position, will draw in blue around it')
                    M28Utilities.DrawLocation(oUnit.CachePosition, nil, 1, 100, nil)
                end
                ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, oUnit.CachePosition, 0)
            else
                if oUnit.GetAIBrain then
                    --------Non-M28 Specific logic------
                    --Rough unit count
                    if not(oUnit['M28Dead']) then
                        oUnit['M28Dead'] = true
                        M28Overseer.refiRoughTotalUnitsInGame = M28Overseer.refiRoughTotalUnitsInGame - 1

                        --Adjust T3 MAA count
                        if M28Utilities.IsTableEmpty(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam]) == false then
                            for iRecordedTeam, bRecorded in oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam] do
                                M28Team.tTeamData[iRecordedTeam][M28Team.iEnemyT3MAAActiveCount] = (M28Team.tTeamData[iRecordedTeam][M28Team.iEnemyT3MAAActiveCount] or 0) - 1
                            end
                        end



                        --TMD protection logic - refresh land zone TMD entries
                        if oUnit[M28Building.refbUnitWantsMoreTMD] then M28Building.UpdateLZUnitsWantingTMDForUnitDeath(oUnit) end

                        --Big threat global team table update
                        if M28Utilities.IsTableEmpty(oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable]) == false then
                            M28Team.RemoveUnitFromBigThreatTable(oUnit)
                        end


                        M28Orders.ClearAnyRepairingUnits(oUnit)

                        --Hydro resource location made available again
                        if EntityCategoryContains(M28UnitInfo.refCategoryHydro, oUnit.UnitId) then
                            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroLocations]) == false then
                                for iHydroLocation, tHydroLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroLocations] do
                                    if M28Utilities.GetDistanceBetweenPositions(tHydroLocation, oUnit:GetPosition()) <= 2 then
                                        table.insert(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations], tHydroLocation)
                                        break
                                    end
                                end
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                            --Record mex position first as it is a forked thread so may lose position if the unit dies; however ignore if looks like an upgrading mex unit
                            if bDebugMessages == true then LOG(sFunctionRef..': We have a mex that has died, checking if it was the upgrading element, .CanTakeDamage='..tostring(oUnit.CanTakeDamage or false)..'; .IsUpgrade='..tostring(oUnit.IsUpgrade or false)) end
                            if not(oUnit.CanTakeDamage == false and oUnit.IsUpgrade == true) then
                                local tMexPosition = {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]}
                                if bDebugMessages == true then LOG(sFunctionRef..': About to call OnMexDeath via fork, tMexPosition='..repru(tMexPosition)) end
                                if tMexPosition[1] == 0 and tMexPosition[2] == 0 then M28Utilities.ErrorHandler('Dont have a valid mex position - mex is showing as 0,0,0') end
                                ForkThread(M28Building.OnMexDeath, tMexPosition, (oUnit.UnitId or 'nil'), (M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil'), oUnit:GetAIBrain():GetArmyIndex()) --Need to fork thread or else get an error when try to wait in the building logic
                            end
                            --[[local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]) == false then
                                for iMexLocation, tMexLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations] do
                                    --Prev line - redid at same time as changing approach for removing an unbuilt location to try and be more accurate
                                    --if M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition()) <= 0.9 then
                                    --Revised line:
                                    if math.abs(tMexLocation[1] - oUnit:GetPosition()[1]) < 0.9 and math.abs(tMexLocation[3] - oUnit:GetPosition()[3]) < 0.9 then
                                        table.insert(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations], tMexLocation)
                                        break
                                    end
                                end
                            end--]]
                            --Radar intel coverage update
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryRadar, oUnit.UnitId) then
                            ForkThread(M28Land.UpdateRadarCoverageForDestroyedRadar, oUnit)
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySonar, oUnit.UnitId) then
                            ForkThread(M28Navy.UpdateSonarCoverageForDestroyedSonar, oUnit)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryWall, oUnit.UnitId) and not(oUnit:GetAIBrain().M28AI) then
                            M28Land.TrackWallSegment(oUnit, false)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) then
                            --For each M28 team with active M28AI consider if we have a firebase
                            M28Land.ConsiderIfAnyEnemyTeamsStillHaveFirebaseOnT2ArtiDeath(oUnit)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryTMD + M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                            if EntityCategoryContains(M28UnitInfo.refCategoryTMD, oUnit.UnitId) then
                                M28Building.TMDDied(oUnit)
                            else
                                M28Building.TMLDied(oUnit)
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySMD, oUnit.UnitId) then
                            if oUnit:GetFractionComplete() == 1 then
                                --Go through each team other team with M28 in it, and if they have nukes with loaded missiles, consider firing immediately
                                for iTeam = 1, M28Team.iTotalTeamCount do
                                    if (M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or 0) > 0 then
                                        ForkThread(M28Building.ConsiderFiringFirstLoadedNukeOnTeam, iTeam)
                                    end
                                end
                            end
                        end

                        --Fixed shields
                        if M28Utilities.IsTableEmpty(oUnit[M28Building.reftoUnitsCoveredByShield]) == false then
                            M28Building.UpdateShieldCoverageOfUnits(oUnit, true)
                            --Units having shield coverage - update the shield table
                        elseif oUnit[M28Building.reftoShieldsProvidingCoverage] and M28Utilities.IsTableEmpty(oUnit[M28Building.reftoShieldsProvidingCoverage]) == false then
                            for iShield, oShield in oUnit[M28Building.reftoShieldsProvidingCoverage] do
                                if M28UnitInfo.IsUnitValid(oShield) and M28Utilities.IsTableEmpty(oShield[M28Building.reftoUnitsCoveredByShield]) == false then
                                    for iEntry, oEntry in oShield[M28Building.reftoUnitsCoveredByShield] do
                                        if oEntry == oUnit then
                                            table.remove(oShield[M28Building.reftoUnitsCoveredByShield], iEntry)
                                            break
                                        end
                                    end
                                end
                            end
                        end

                        --Ythotha deathball avoidance
                        --Note -seraphimunits.lua contains SEnergyBallUnit which looks like it is for when the death ball is spawned; ID is XSL0402; SpawnElectroStorm is in the ythotha script
                        --Sandbox test - have c.36s from ythotha dying to energy ball dying, so want to run away for half of this (18s) plus extra time based on how far away we already were
                        if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental * categories.SERAPHIM, oUnit.UnitId) then
                            OnYthothaDeath(oUnit)
                        end
                        if EntityCategoryContains(categories.STRUCTURE + categories.EXPERIMENTAL -M28UnitInfo.refCategoryMex -M28UnitInfo.refCategoryHydro, oUnit.UnitId) and (EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) or oUnit:GetFractionComplete() < 1) then
                            if oUnit[M28Engineer.reftUnitBlacklistSegmentXZ] then --EntityCategoryContains(categories.EXPERIMENTAL * categories.MOBILE - M28UnitInfo.refCategoryExperimentalArti, oJustBuilt.UnitId) then
                                --Treat area around experimental under construction as available again
                                M28Engineer.ClearBlacklistForUnitConstructed(oUnit)
                            end
                            M28Engineer.SearchForBuildableLocationsNearDestroyedBuilding(oUnit)
                        end

                        --Campaign specific - upgrading structure that isn't yet complete
                        if M28Map.bIsCampaignMap and oUnit[M28UnitInfo.refbObjectiveUnit] and not(oUnit[refbAlreadyRunUnitKilled]) and oUnit:GetFractionComplete() < 1 and oUnit:GetAIBrain().CampaignAI and oUnit.DoUnitCallbacks and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) then
                            oUnit:DoUnitCallbacks('OnKilled')
                        end

                        -------M28 specific logic---------
                        if bDebugMessages == true then LOG(sFunctionRef..': About to consider M28specific on death logic, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Owned by brain '..oUnit:GetAIBrain().Nickname..'; Is M28='..tostring(oUnit:GetAIBrain().M28AI or false)) end
                        --Is the unit owned by M28AI?
                        if oUnit:GetAIBrain().M28AI then
                            --Air units - remove any assigned strike damage
                            if oUnit[M28Air.refoStrikeDamageAssigned] then
                                M28Air.RemoveAssignedAttacker(oUnit[M28Air.refoStrikeDamageAssigned], oUnit)
                            end
                            --Air scout death - record the target zone as dangerous
                            if oUnit[M28Air.reftScoutAssignedPlateauAndZoneRef] then
                                M28Air.OnAirScoutDeath(oUnit)
                            end
                            --Transport death - record target island as dangerous
                            if oUnit[M28Air.refiTargetIslandForDrop] then
                                local iTeam = oUnit:GetAIBrain().M28Team
                                local iTargetIsland = oUnit[M28Air.refiTargetIslandForDrop]
                                M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandDropTime][iTargetIsland] = GetGameTimeSeconds()
                                if oUnit[M28Air.refiTargetZoneForDrop] then
                                    if not(M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime][iTargetIsland]) then
                                        if not(M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime]) then M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime] = {} end
                                        M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime][iTargetIsland] = {}
                                    end
                                    M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime][iTargetIsland][oUnit[M28Air.refiTargetZoneForDrop]] = GetGameTimeSeconds()
                                end
                            elseif oUnit[M28Air.refiTargetZoneForDrop] then --presumably a water zone if it has no island ref
                                local iTeam = oUnit:GetAIBrain().M28Team
                                if not(M28Team.tTeamData[iTeam][M28Team.refiLastFailedWaterZoneDropTime]) then M28Team.tTeamData[iTeam][M28Team.refiLastFailedWaterZoneDropTime] = {} end
                                M28Team.tTeamData[iTeam][M28Team.refiLastFailedWaterZoneDropTime][oUnit[M28Air.refiTargetZoneForDrop]] = GetGameTimeSeconds()
                            end

                            --Logic that doesnt require the unit to ahve finished construction:

                            --Fixed shielding
                            if oUnit[M28Building.refbUnitWantsShielding] or oUnit[M28Building.reftoUnitsCoveredByShield] then --or oUnit[M28Building.reftoShieldsProvidingCoverage] then
                                --[[if oUnit[M28Building.reftoUnitsCoveredByShield] then
                                    --M28Building.UpdateShieldCoverageOfUnits(oUnit, true) --Already done above for all ai now --]]
                                --else
                                M28Building.CheckIfUnitWantsFixedShield(oUnit) --I.e. if a fixed hsield has died that is owned by M28, then want to run this function so can reassess if we hae any units that now want shielding
                                --end
                            end

                            --GE template shielding
                            if oUnit[M28Building.reftArtiTemplateRefs] and EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oUnit.UnitId) then
                                local tArtiTemplate = M28Map.tAllPlateaus[oUnit[M28Building.reftArtiTemplateRefs][1]][M28Map.subrefPlateauLandZones][oUnit[M28Building.reftArtiTemplateRefs][2]][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftActiveGameEnderTemplates][oUnit[M28Building.reftArtiTemplateRefs][3]]
                                if tArtiTemplate then
                                    tArtiTemplate[M28Map.subrefGEbDontNeedEngineers] = false
                                    --also set to false in 5s due ot building animation
                                    M28Utilities.DelayChangeVariable(tArtiTemplate, M28Map.subrefGEbDontNeedEngineers, false, 5)
                                end

                            end

                            --Special tracking e.g. for factions and shields and game enders - update
                            if oUnit[M28Building.refoNearbyFactoryOfFaction] then --i.e. gameender that wants a factory's engineers - the gameender is dead so want to clear entries for it
                                M28Building.ClearTrackingOfDeadUnitWantingFactoryEngineers(oUnit)
                            end
                            if oUnit[M28Building.reftoUnitsWantingFactoryEngineers] then --i.e. a factory that was down as the one providing engineers to a gameender - want to find a new factory
                                M28Building.UpdateTrackingOfDeadFactoryProvidingEngineers(oUnit)
                            end

                            --PD specific - stop trying to build here (in case we have far away engineers still trying to build at this location for this unit)
                            if EntityCategoryContains(M28UnitInfo.refCategoryPD, oUnit.UnitId) then
                                M28Engineer.ConsiderClearingEngineersForUnitJustDamagedOrDestroyed(oUnit, M28Engineer.refActionBuildEmergencyPD)
                            end

                            --Run unit type specific on death logic where the unit is completed
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if need to run certain M28AI on death logic, unit fraction ocmplete='..oUnit:GetFractionComplete()) end
                            if oUnit:GetFractionComplete() == 1 then
                                M28Economy.UpdateGrossIncomeForUnit(oUnit, true) --Dont fork thread
                                --Dropped units - flag that this island is dangerous if were dropped recently
                                if oUnit[M28Air.refiLastIslandDrop] and oUnit[M28Air.refiTimeLastDropped] and GetGameTimeSeconds() - oUnit[M28Air.refiTimeLastDropped] <= 90 then
                                    local iTeam = oUnit:GetAIBrain().M28Team
                                    if not(M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandDropTime]) then M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandDropTime] = {} end
                                    --Check we dont still have factories or signif structures here
                                    local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                    if (tLZOrWZTeamData[M28Map.subrefLZSValue] or 0) < 1000 and (tLZOrWZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0) < 100 then
                                        local bHaveCompletedFactory = false
                                        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                            local tFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                            if M28Utilities.IsTableEmpty(tFactories) == false then
                                                for iFactory, oFactory in tFactories do
                                                    if M28UnitInfo.IsUnitValid(oFactory) and oFactory:GetFractionComplete() == 1 then
                                                        bHaveCompletedFactory = true
                                                        break
                                                    end
                                                end
                                            end
                                        end
                                        if not(bHaveCompletedFactory) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Recording that island '..(oUnit[M28Air.refiLastIslandDrop] or 'nil')..' is dangerous as we just had a previously dropped unit die here') end
                                            M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandDropTime][oUnit[M28Air.refiLastIslandDrop]] = GetGameTimeSeconds()
                                        end
                                    end
                                end


                                if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                                    M28Engineer.ClearEngineerTracking(oUnit)
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryScathis, oUnit.UnitId) then
                                    if M28Utilities.IsTableEmpty(M28Engineer.tAllScathis) == false then
                                        for iScathis, oScathis in M28Engineer.tAllScathis do
                                            if oScathis == oUnit then
                                                table.remove(M28Engineer.tAllScathis, iScathis) --Only doing this once so can get away with using table.remove, otherwise would want to use M28Utilities.ArrayRemove
                                                break
                                            end
                                        end
                                    end
                                elseif EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                                    --Check for upgrades
                                    --Upgrade tracking (even if have run this already)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will check if upgrade tracking needs updating, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                    M28Team.UpdateUpgradeTrackingOfUnit(oUnit, true)
                                    if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                                        M28Economy.UpdateZoneM28MexByTechCount(oUnit, true)
                                        --Update upgrading mexes
                                        M28Economy.UpdateTableOfUpgradingMexesForTeam(oUnit:GetAIBrain().M28Team)
                                        --Losing HQ but have a teammate of the relevant faction with better tech
                                    elseif EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories - categories.TECH1, oUnit.UnitId) then
                                        if M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.subrefiActiveM28BrainCount] > 1 then
                                            ForkThread(M28Team.ConsiderGiftingSupportFactoriesToTeammateWithBetterHQ, oUnit:GetAIBrain(), oUnit.UnitId)
                                        end
                                    elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedShield - categories.TECH2 - categories.TECH1, oUnit.UnitId) then
                                        --Shield tracking
                                        local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, oUnit:GetAIBrain().M28Team)
                                        if tLZTeamData then
                                            tLZTeamData[M28Map.subrefiT3FixedShieldConstructedCount] = math.max(0, (tLZTeamData[M28Map.subrefiT3FixedShieldConstructedCount] or 0) - 1)
                                        end
                                    end
                                    M28Economy.UpdateHighestFactoryTechLevelForDestroyedUnit(oUnit) --checks if it was a factory as part of this function

                                elseif EntityCategoryContains(M28UnitInfo.refCategoryMobileLand, oUnit.UnitId) then
                                    --If unit was traveling to another land zone, then update that land zone so it no longer things the unit is traveling here
                                    M28Land.RemoveUnitFromListOfUnitsTravelingToLandZone(oUnit) --(this will check if it was or not)
                                end

                                --Mobile shield update
                                if oUnit[M28Land.refoAssignedMobileShield] then
                                    oUnit[M28Land.refoAssignedMobileShield][M28Land.refoMobileShieldTarget] = nil
                                end
                                if oUnit[M28Land.refoMobileShieldTarget] then
                                    oUnit[M28Land.refoMobileShieldTarget][M28Land.refoAssignedMobileShield] = nil
                                end
                            end
                            --Update record of units with disabled weapons
                            if oUnit[M28UnitInfo.refbWeaponDisabled] then
                                local iTeam = oUnit:GetAIBrain().M28Team
                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons]) == false then
                                    for iRecorded, oRecorded in M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons] do
                                        if oRecorded == oUnit then
                                            table.remove(M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons], iRecorded)
                                            break
                                        end
                                    end
                                end
                            end

                            if oUnit[M28Building.refbActiveOpticsManager] then
                                local iTeam = oUnit:GetAIBrain().M28Team
                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoAlliedQuantumOptics]) == false then
                                    for iRecorded, oRecorded in M28Team.tTeamData[iTeam][M28Team.reftoAlliedQuantumOptics] do
                                        if oUnit == oRecorded then
                                            table.remove(M28Team.tTeamData[iTeam][M28Team.reftoAlliedQuantumOptics], iRecorded)
                                            break
                                        end
                                    end
                                end
                            end

                            --If unit was paused, update the table
                            if oUnit[M28UnitInfo.refiPausedPriority] then
                                M28UnitInfo.AddOrRemoveUnitFromListOfPausedUnits(oUnit, false)
                            end
                        else
                            --Specific logic to apply only if the unit is not owned by M28
                            if oUnit[M28UnitInfo.reftiTeamsRecordedAsNonM28Ally] and EntityCategoryContains(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                                local sTeamDataRef
                                if EntityCategoryContains(M28UnitInfo.refCategoryFactory, oUnit.UnitId) then
                                    sTeamDataRef = M28Map.refiNonM28TeammateFactoryCount
                                else
                                    sTeamDataRef = M28Map.refiNonM28TeammateMexCount
                                end

                                for _, iTeam in oUnit[M28UnitInfo.reftiTeamsRecordedAsNonM28Ally] do
                                    local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                    if tLZOrWZTeamData then
                                        tLZOrWZTeamData[sTeamDataRef] = math.max(0, (tLZOrWZTeamData[sTeamDataRef] or 0) - 1)
                                    end
                                end
                            end
                            if oUnit[M28UnitInfo.refbNonM28ExpConstruction] then
                                local iTeam = oUnit:GetAIBrain().M28Team
                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoNonM28ConstructingExpAndT3Navy]) == false then
                                    for iRecordedUnit, oRecordedUnit in M28Team.tTeamData[iTeam][M28Team.reftoNonM28ConstructingExpAndT3Navy] do
                                        if oRecordedUnit == oUnit then
                                            table.remove(M28Team.tTeamData[iTeam][M28Team.reftoNonM28ConstructingExpAndT3Navy], iRecordedUnit)
                                            break
                                        end
                                    end
                                end
                                oUnit[M28UnitInfo.refbNonM28ExpConstruction] = false
                            end
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        end
    end

--function OnWorkEnd(self, work)
    --Have commented out the line that calls this since not currently using it

    --Not sure when/if this even triggers - would need to review if plan to use
    --LOG('WOrk end has finished for self='..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self)..'; work reprs='..reprs(work))
--end

function OnEnhancementComplete(oUnit, sEnhancement)
    if M28Utilities.bM28AIInGame then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnEnhancementComplete'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        --Check we haven't just run this
        if GetGameTimeSeconds() - (oUnit[M28UnitInfo.reftiTimeOfLastEnhancementComplete][sEnhancement] or -100) >= 0.5 then
            if not(oUnit[M28UnitInfo.reftiTimeOfLastEnhancementComplete]) then oUnit[M28UnitInfo.reftiTimeOfLastEnhancementComplete] = {} end
            if oUnit[M28ACU.refbWantsPriorityUpgrade] then oUnit[M28ACU.refbWantsPriorityUpgrade] = nil end
            oUnit[M28UnitInfo.reftiTimeOfLastEnhancementComplete][sEnhancement] = GetGameTimeSeconds()
            if bDebugMessages == true then LOG(sFunctionRef..': Enhancement completed for self='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..'; sEnhancement='..reprs(sEnhancement)..'; Has enhancement for this='..tostring(oUnit:HasEnhancement(sEnhancement))..'; Unit DF range pre upgrade='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')) end
            M28UnitInfo.UpdateUnitCombatMassRatingForUpgrades(oUnit)
            local iDFRangePreUpgrade = (oUnit[M28UnitInfo.refiDFRange] or 0)
            M28UnitInfo.RecordUnitRange(oUnit) --Refresh the range incase enhancement has increased anything
            --LOUD specific - manually reflect weapon ranges for the basic gun upgrades as arent recorded against the blueprint
            if M28Utilities.bLoudModActive and (oUnit[M28UnitInfo.refiDFRange] or 0) < 30 then
                local tsOtherUpgradeNames = {
                    'EXRipperBooster',
                    'EXZephyrBooster',
                    'EXChronotronBooster',
                    'EXDisruptorrBooster',
                }
                for iUpgrade, sUpgrade in tsOtherUpgradeNames do
                    if oUnit:HasEnhancement(sUpgrade) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Adjusting unit range for LOUD enhancement, DFRange pre increase='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; iDFRangePreUpgrade='..iDFRangePreUpgrade) end
                        oUnit[M28UnitInfo.refiDFRange] = (oUnit[M28UnitInfo.refiDFRange] or 0) + 5
                        break
                    end
                end
            end
            if (oUnit[M28UnitInfo.refiDFRange] or 0) > iDFRangePreUpgrade then
                M28Overseer.bLikelyGunUpgrade = true
            end

            --Mobile TML logic (e.g. ACU and SACU, and billy nuke) - note some manual ranges are e.g. for overcharge
            if (oUnit[M28UnitInfo.refiManualRange] or 0) > 50 then
                --Record this against every opposing M28 Team
                if bDebugMessages == true then LOG(sFunctionRef..': have unit with tml upgrade, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                ForkThread(M28Team.RecordMobileTMLThreatForAllEnemyTeams, oUnit)
            end

            --Update ACU upgrade count
            if EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oUnit.UnitId) then
                oUnit[M28ACU.refiUpgradeCount] = (oUnit[M28ACU.refiUpgradeCount] or 0) + 1
                if sEnhancement == 'Teleporter' then
                    if bDebugMessages == true then LOG(sFunctionRef..': Flagging that unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has got teleporter upgrade and setting weapon prioritisation accordingly') end
                    oUnit[M28ACU.refbACUHasTeleport] = true
                    if ScenarioInfo.Options.Victory == "demoralization" then
                        M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityTeleSnipeInclACU, false)
                    else
                        M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityTeleSnipeExclACU, false)
                    end
                elseif sEnhancement == 'AdvancedEngineering' then
                    oUnit[M28ACU.refiBuildTech] = 2
                elseif sEnhancement == 'T3Engineering' then
                    oUnit[M28ACU.refiBuildTech] = 3
                end
                if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                    --Consider being more aggressive with ACU again (mainly relevant for team games)
                    oUnit[M28ACU.refbUseACUAggressively] = M28ACU.DoWeStillWantToBeAggressiveWithACU(oUnit)
                end
            end
            --Fix AIx modifier
            if oUnit:GetAIBrain().CheatEnabled then
                M28UnitInfo.FixUnitResourceCheatModifiers(oUnit)
            end
            if oUnit:GetAIBrain().M28AI then
                if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                    M28ACU.GetUpgradePathForACU(oUnit)
                end
                --Remove any upgrade tracking
                M28Team.UpdateUpgradeTrackingOfUnit(oUnit, true, sEnhancement)
            end
            if sEnhancement == 'CloakingGenerator' then
                --Record in table for enemy teams
                CloakedUnitIdentified(oUnit)
            end
            --Update eco for RAS
            local tEnhancement = oUnit:GetBlueprint().Enhancements[sEnhancement]
            if bDebugMessages == true then LOG(sFunctionRef..': tEnhancement='..reprs(tEnhancement)) end
            if tEnhancement then
                if tEnhancement.ProductionPerSecondEnergy or tEnhancement.ProductionperSecondMass then
                    --Remove existing entries for unit then create new ones
                    M28Economy.UpdateGrossIncomeForUnit(oUnit, true, true)
                    M28Economy.UpdateGrossIncomeForUnit(oUnit, false, false)
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Unit DF range after updating recorded range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')) end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function CloakedUnitIdentified(oUnit)
    if M28Utilities.bM28AIInGame then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'CloakedUnitIdentified'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        local iUnitBrainIndex = oUnit:GetAIBrain():GetArmyIndex()
        local tbTeamsConsidered = {}
        for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
            if IsEnemy(oBrain:GetArmyIndex(), iUnitBrainIndex) and not(tbTeamsConsidered[oBrain.M28Team]) then
                local iTeam = oBrain.M28Team
                tbTeamsConsidered[iTeam] = true
                local bAddToTable = true
                if not(M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits]) then
                    M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits] = {}
                else
                    for iRecorded, oRecorded in M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits] do
                        if oRecorded == oUnit then
                            bAddToTable = false
                            break
                        end
                    end
                end
                if bAddToTable then
                    table.insert(M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits], oUnit)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Added unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by brain '..oUnit:GetAIBrain().Nickname..' to table of cloaked units for iTeam='..iTeam..' unless was already recorded, bAddToTable='..tostring(bAddToTable)..'; Time='..GetGameTimeSeconds()) end
            end
        end
        oUnit[M28UnitInfo.refbUnitIsCloaked] = true
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnShieldBubbleDamaged(self, instigator)
    if M28Utilities.bM28AIInGame then
        local oShield = self.Owner
        --LOG('Shield damaged, self='..reprs(self)..'; owner='..reprs(self.Owner))
        if not(oShield.Dead) then
            if oShield:GetAIBrain().M28AI then
                oShield[M28UnitInfo.refiTimeLastDamaged] = GetGameTimeSeconds()
            end
            --LOG('instigator='..reprs(instigator))
            if M28UnitInfo.IsUnitValid(instigator) and instigator:GetAIBrain().M28AI and IsEnemy(oShield:GetAIBrain():GetArmyIndex(), instigator:GetAIBrain():GetArmyIndex()) then
                if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oShield.UnitId) then
                    if EntityCategoryContains(M28UnitInfo.refCategoryMML, instigator.UnitId) then
                        local iShieldPlateau, iShieldLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oShield:GetPosition())
                        if (iShieldLandZone or 0) > 0 and iShieldPlateau > 0 then
                            local tLZTeamData = M28Map.tAllPlateaus[iShieldPlateau][M28Map.subrefPlateauLandZones][iShieldLandZone][M28Map.subrefLZTeamData][instigator:GetAIBrain().M28Team]
                            tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] = GetGameTimeSeconds()
                            local iMMLPlateau, iMMLZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(instigator:GetPosition())
                            if (iMMLPlateau or 0) > 0 and (iMMLZone or 0) > 0 and not(iMMLZone == iShieldLandZone and iMMLPlateau == iShieldPlateau) then
                                local tMMLLZTeamData = M28Map.tAllPlateaus[iMMLPlateau][M28Map.subrefPlateauLandZones][iMMLZone][M28Map.subrefLZTeamData][instigator:GetAIBrain().M28Team]
                                tMMLLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] = GetGameTimeSeconds()
                            end
                            --LOG('Flagging that we have had missiles intercepted by TMD or shield for iShieldLandZone and MML zone, iShieldLandZone='..(iShieldLandZone or 'nil')..'; iMMLZone='..(iMMLZone or 'nil')..'; iMMLPlateau='..(iMMLPlateau or 'nil'))
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, instigator.UnitId) then
                        --LOG('Cur shield health='..oShield.MyShield:GetHealth())
                        if oShield.MyShield.GetHealth and oShield.MyShield:GetHealth() <= 750 then
                            --Record shield in table of recently failed shields for if we have a novax
                            local iTeam = instigator:GetAIBrain().M28Team
                            local bRecordedAlready
                            if not(M28Team.tTeamData[iTeam][M28Team.reftEnemyShieldsFailedToArti]) then
                                M28Team.tTeamData[iTeam][M28Team.reftEnemyShieldsFailedToArti] = {}
                            else
                                for iEntry, oRecorded in M28Team.tTeamData[iTeam][M28Team.reftEnemyShieldsFailedToArti] do
                                    if oRecorded == oShield then
                                        bRecordedAlready = true
                                        break
                                    end
                                end
                            end
                            if not(bRecordedAlready) then
                                table.insert(M28Team.tTeamData[iTeam][M28Team.reftEnemyShieldsFailedToArti], oShield)
                            end
                        end
                    end
                else
                    --Fatboy specific; if changing threshold here then also change in team
                    if EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oShield.UnitId) and oShield.MyShield:GetHealth() <= oShield.MyShield:GetMaxHealth() * 0.5 then
                        local iTeam = instigator:GetAIBrain().M28Team
                        local bRecordedAlready
                        if oShield.MyShield:GetHealth() <= 1250 then
                            if not(M28Team.tTeamData[iTeam][M28Team.reftEnemyShieldsFailedToArti]) then
                                M28Team.tTeamData[iTeam][M28Team.reftEnemyShieldsFailedToArti] = {}
                            else
                                for iEntry, oRecorded in M28Team.tTeamData[iTeam][M28Team.reftEnemyShieldsFailedToArti] do
                                    if oRecorded == oShield then
                                        bRecordedAlready = true
                                        break
                                    end
                                end
                            end
                            if not(bRecordedAlready) then
                                table.insert(M28Team.tTeamData[iTeam][M28Team.reftEnemyShieldsFailedToArti], oShield)
                            end
                        end
                        bRecordedAlready = false
                        if not(M28Team.tTeamData[iTeam][M28Team.reftoVulnerableFatboys]) then M28Team.tTeamData[iTeam][M28Team.reftoVulnerableFatboys] = {}
                        else
                            for iEntry, oRecorded in M28Team.tTeamData[iTeam][M28Team.reftoVulnerableFatboys] do
                                if oRecorded == oShield then
                                    bRecordedAlready = true
                                    break
                                end
                            end
                        end
                        if not(bRecordedAlready) then
                            table.insert(M28Team.tTeamData[iTeam][M28Team.reftoVulnerableFatboys], oShield)
                            ForkThread(M28Team.MonitorVulnerableFatboys,iTeam)
                        end
                    end
                end
            end
        end
    end
end

function OnDamaged(self, instigator) --This doesnt trigger when a shield bubble is damaged - see OnShieldBubbleDamaged for this
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnDamaged'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if self.IsWreckage then
            --Will only update when props and wrecks are destroyed for performance reasons
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Non-wreck damaged') end
            if self.GetUnitId then
                local oUnitCausingDamage
                if instigator and not(instigator:BeenDestroyed()) then
                    if instigator.GetLauncher and instigator:GetLauncher() then
                        oUnitCausingDamage = instigator:GetLauncher()
                    elseif instigator.DamageData and not(instigator.unit) and not(instigator.UnitId) then
                        --Can get errors for artillery shells when running IsProjectile
                    elseif IsProjectile(instigator) or IsCollisionBeam(instigator) then
                        if instigator.unit then
                            oUnitCausingDamage = instigator.unit
                        end
                    elseif IsUnit(instigator) then
                        oUnitCausingDamage = instigator
                    end
                    if bDebugMessages == true then
                        if not(oUnitCausingDamage) then LOG(sFunctionRef..': Dont ahve a valid unit as instigator')
                        else LOG(sFunctionRef..': Have a unit causing damage='..oUnitCausingDamage.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitCausingDamage)) end
                    end
                end

                --Logic specific to M28 units dealing damage
                if M28UnitInfo.IsUnitValid(oUnitCausingDamage) and oUnitCausingDamage:GetAIBrain().M28AI then
                    --Update so unit isnt treated as having shot blocked
                    oUnitCausingDamage[M28UnitInfo.refbLastShotBlocked] = false
                    oUnitCausingDamage[M28UnitInfo.refiTimeOfLastUnblockedShot] = GetGameTimeSeconds()
                    if M28UnitInfo.IsUnitValid(self) and (self[M28UnitInfo.refiTargetShotBlockedCount] or 0) > 0 then self[M28UnitInfo.refiTargetShotBlockedCount] = self[M28UnitInfo.refiTargetShotBlockedCount] - 10 end

                    --T3/experimental arti specific
                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, oUnitCausingDamage.UnitId) then
                        --Reset the arti shot count if damaged a high value unit
                        if M28UnitInfo.IsUnitValid(self) then
                            if bDebugMessages == true then LOG(sFunctionRef..': T3/Exp arti owned by M28 brain '..oUnitCausingDamage:GetAIBrain().Nickname..', arti unit='..oUnitCausingDamage.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitCausingDamage)..' has just damaged unit '..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self)..' which is valid') end
                            local iUnitDamagedMassValue = self[M28UnitInfo.refiUnitMassCost] * self:GetFractionComplete()
                            if iUnitDamagedMassValue >= 700 then
                                --Reduce the ineffective arti shot count
                                local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(self:GetPosition())
                                local tLZOrWZTeamData
                                if iPlateauOrZero > 0 then
                                    tLZOrWZTeamData  = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][oUnitCausingDamage:GetAIBrain().M28Team]
                                else
                                    --Water zone
                                    tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][oUnitCausingDamage:GetAIBrain().M28Team]
                                end
                                local iReductionValue
                                if iUnitDamagedMassValue >= 10000 then
                                    iReductionValue = 50
                                elseif iUnitDamagedMassValue >= 3000 then
                                    iReductionValue = 12
                                else
                                    iReductionValue = 6
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Changing ineffective shot count, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWateZone='..iLandOrWaterZone..'; tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount]='..(tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 'nil')..'; iReductionValue='..iReductionValue) end
                                tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] = math.max(0, (tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 0) - iReductionValue)
                            end
                        end
                    end
                    if EntityCategoryContains(categories.EXPERIMENTAL, self.UnitId) and self:GetFractionComplete() < 1 and self:GetFractionComplete() > 0.1 then
                        ForkThread(M28Chat.PartCompleteExperimentalDamaged, self, oUnitCausingDamage)
                    end
                end

                --Logic specific to M28 units dealt damage
                if self:GetAIBrain().M28AI then
                    if EntityCategoryContains(categories.COMMAND, self.UnitId) then
                        if self:IsUnitState('Upgrading') then
                            --Do we want to cancel the upgrade? If were hit by a TML then want to
                            if M28UnitInfo.IsUnitValid(oUnitCausingDamage) and EntityCategoryContains(M28UnitInfo.refCategoryTML, oUnitCausingDamage.UnitId) then
                                if not(self[M28UnitInfo.refbEasyBrain]) then
                                    M28Micro.MoveAwayFromTargetTemporarily(self, 5, oUnitCausingDamage:GetPosition())
                                end
                            end
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryPD, self.UnitId) and M28UnitInfo.IsUnitValid(self) and (self:GetFractionComplete() <= 0.7 or (self:GetFractionComplete() <= 0.85 and M28UnitInfo.GetUnitHealthPercent(self) <= 0.5)) and EntityCategoryContains(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryIndirect, oUnitCausingDamage.UnitId) then
                        M28Engineer.ConsiderClearingEngineersForUnitJustDamagedOrDestroyed(self,  M28Engineer.refActionBuildEmergencyPD)
                        --Special voice message for fletcher fatboy damaged by soulripper
                    elseif self[M28Air.refiTargetZoneForDrop] and EntityCategoryContains(M28UnitInfo.refCategoryTransport, self.UnitId) then
                        self[M28UnitInfo.refiTimeLastDamaged] = GetGameTimeSeconds()
                    elseif oUnitCausingDamage.UnitId and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, self.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryGunship * categories.CYBRAN * categories.EXPERIMENTAL, oUnitCausingDamage.UnitId) and self:GetAIBrain()[M28Chat.refiAssignedPersonality] == M28Chat.refiFletcher then
                        ForkThread(M28Chat.SendMessage, self:GetAIBrain(), 'SoulripperDmgFatboy', LOC('<LOC X05_M02_240_010>[{i Fletcher}]: Soul Rippers are tearing up my Fatboy! I need air cover, now!'), 1, 600, false, true, 'X05_Fletcher_M02_04945', 'X05_VO')
                    end
                    --General - if enemy has non-long range direct fire structure that hit an M28 unit, then check if it is in the same or adjacen tzone, so can record if it isnt
                    if oUnitCausingDamage.GetPosition and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnitCausingDamage.UnitId) and oUnitCausingDamage[M28UnitInfo.refiDFRange] and oUnitCausingDamage[M28UnitInfo.refiDFRange] < 100 and oUnitCausingDamage[M28UnitInfo.refiDFRange] > 0 and self.GetPosition then
                        if oUnitCausingDamage[M28UnitInfo.refiDFRange] < 60 or M28Utilities.GetDistanceBetweenPositions(oUnitCausingDamage:GetPosition(), self:GetPosition()) < 60 then
                            local iPDPlateauOrZero, iPDZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnitCausingDamage:GetPosition())
                            local iDamagedPlateauOrZero, iDamagedZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(self:GetPosition())
                            if not(iPDPlateauOrZero == iDamagedPlateauOrZero and iPDZone == iDamagedZone) and (iPDPlateauOrZero or 0) > 0 and iDamagedPlateauOrZero > 0 then
                                --Arent in the same zone, but are both in land zones are we in an adjacent zone?
                                local tDamagedLZData = M28Map.tAllPlateaus[iDamagedPlateauOrZero][M28Map.subrefPlateauLandZones][iDamagedZone]
                                local bPDIsInAdjacentZone = false
                                if iDamagedPlateauOrZero == iPDPlateauOrZero and M28Utilities.IsTableEmpty(tDamagedLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                    for _, iAdjLZ in tDamagedLZData[M28Map.subrefLZAdjacentLandZones] do
                                        if iAdjLZ == iPDZone then
                                            bPDIsInAdjacentZone = true
                                            break
                                        end
                                    end
                                end
                                if not(bPDIsInAdjacentZone) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have PD in a nearby non-adjacent zone, oUnitCausingDamage='..oUnitCausingDamage.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitCausingDamage)..'; iPDPlateauOrZero='..iPDPlateauOrZero..'; iPDZone='..iPDZone..'; iDamagedPlateauOrZero='..iDamagedPlateauOrZero..'; iDamagedZone='..iDamagedZone..'; Time='..GetGameTimeSeconds()) end
                                    local bAlreadyRecorded = false
                                    if not(tDamagedLZData[M28Map.subrefDangerousNearbyPlateauAndZones]) then
                                        tDamagedLZData[M28Map.subrefDangerousNearbyPlateauAndZones] = {}
                                    else
                                        for iEntry, tPlateauAndZone in tDamagedLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                                            if tPlateauAndZone[2] == iPDZone and tPlateauAndZone[1] == iPDPlateauOrZero then
                                                bAlreadyRecorded = true
                                                break
                                            end
                                        end
                                    end
                                    if not(bAlreadyRecorded) then
                                        table.insert(tDamagedLZData[M28Map.subrefDangerousNearbyPlateauAndZones], {iPDPlateauOrZero, iPDZone})
                                        local tPDLZData = M28Map.tAllPlateaus[iPDPlateauOrZero][M28Map.subrefPlateauLandZones][iPDZone]
                                        if not(tPDLZData[M28Map.subrefDangerousNearbyPlateauAndZones]) then tPDLZData[M28Map.subrefDangerousNearbyPlateauAndZones] = {} end
                                        table.insert(tPDLZData[M28Map.subrefDangerousNearbyPlateauAndZones], {iDamagedPlateauOrZero, iDamagedZone})
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': tDamagedLZData[M28Map.subrefDangerousNearbyPlateauAndZones]='..reprs(tDamagedLZData[M28Map.subrefDangerousNearbyPlateauAndZones])) end
                                end
                            end
                        end
                    end
                end

            end

        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnBombFired(oWeapon, projectile)
    if M28Utilities.bM28AIInGame then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnBombFired'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
        local oUnit = oWeapon.unit
        if oUnit and oUnit.GetUnitId then
            oUnit[M28UnitInfo.refiLastBombFired] = GetGameTimeSeconds()
            local sUnitID = oUnit.UnitId

            if bDebugMessages == true then LOG(sFunctionRef..': bomber position when firing bomb='..repru(oUnit:GetPosition())..'; Bomber='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Owner='..oUnit:GetAIBrain().Nickname..'; Time='..GetGameTimeSeconds()..'; Time since last bomber event='..(GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastDodgeBombEvent] or 0))) end
            if EntityCategoryContains(M28UnitInfo.refCategoryBomber + M28UnitInfo.refCategoryTorpBomber, sUnitID) then
                --if not(EntityCategoryContains(categories.EXPERIMENTAL, sUnitID)) then
                if GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastDodgeBombEvent] or 0) >= 2 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and dodge the bomb fired by unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                    M28Micro.DodgeBomb(oUnit, oWeapon, projectile)
                end

                --Ahwassa - micro the bomber
                if EntityCategoryContains(categories.EXPERIMENTAL, sUnitID) then
                    --Experimental bomber - micro to turn around and go to rally point
                    if oUnit:GetAIBrain().M28AI then
                        if not(oUnit[M28UnitInfo.refbEasyBrain]) then
                            if bDebugMessages == true then LOG(sFunctionRef..': will get ahwassa to head towards rally point, bomber='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Bomber position='..repru(oUnit:GetPosition())..'; Rally point='..repru(M28Team.tAirSubteamData[oUnit:GetAIBrain().M28AirSubteam][M28Team.reftAirSubRallyPoint])..'; Dist to rally point='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), M28Team.tAirSubteamData[oUnit:GetAIBrain().M28AirSubteam][M28Team.reftAirSubRallyPoint])..'; Angle from bomber to rally='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), M28Team.tAirSubteamData[oUnit:GetAIBrain().M28AirSubteam][M28Team.reftAirSubRallyPoint])..'; Angle from bomber to its owners start position='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), M28Map.GetPlayerStartPosition(oUnit:GetAIBrain()))) end

                            --Decide whether to retreat to air rally point or nearest base; most of the time go to rally, but switch to base if angel to rally is significantly different and has a high mod dist, in case we risk passing by enemy AA on the way
                            local aiBrain = oUnit:GetAIBrain()
                            local tNearestFriendlyBase
                            local bCloseToDangerousFriendlyBase = false
                            local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, aiBrain.M28Team)
                            if tLZOrWZTeamData then
                                tNearestFriendlyBase = {tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][1], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][2], tLZOrWZTeamData[M28Map.reftClosestFriendlyBase][3]}
                                if tLZOrWZTeamData[M28Map.refiModDistancePercent] <= 0.3 and tLZOrWZTeamData[M28Map.subrefLZSValue] < 1000 and (tLZOrWZTeamData[M28Map.subrefLZThreatEnemyGroundAA] or 0) > 0 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tNearestFriendlyBase) <= 250 then bCloseToDangerousFriendlyBase = true end --if are close to base then is a risk enemy has overrun it
                            end
                            if not(tNearestFriendlyBase) then tNearestFriendlyBase = M28Map.GetPlayerStartPosition(aiBrain) end

                            local tAirRallyPoint = M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.reftAirSubRallyPoint]
                            local tRallyLZOrWZData, tRallyLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, aiBrain.M28Team)
                            local tRetreatLocation
                            if not(bCloseToDangerousFriendlyBase) and tRallyLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.3 then
                                local iAngleToBase = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tNearestFriendlyBase)
                                local iAngleToRally = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tAirRallyPoint)
                                if M28Utilities.GetAngleDifference(iAngleToBase, iAngleToRally) >= 35 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tNearestFriendlyBase) >= 60 then
                                    if tRallyLZOrWZTeamData[M28Map.refiModDistancePercent] >= 0.5 then
                                        tRetreatLocation = {tNearestFriendlyBase[1], tNearestFriendlyBase[2], tNearestFriendlyBase[3]}
                                    else
                                        local iRallyPlateauOrZero, iRallyZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tAirRallyPoint)
                                        local iUnitPlateauOrZero, iUnitZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                                        if iRallyPlateauOrZero and iUnitPlateauOrZero and iRallyZone and iUnitZone then
                                            M28Air.CalculateAirTravelPath(iUnitPlateauOrZero, iUnitZone, iRallyPlateauOrZero, iRallyZone)
                                            if M28Air.DoesEnemyHaveAAThreatAlongPath(aiBrain.M28Team, iUnitPlateauOrZero, iUnitZone, iRallyPlateauOrZero, iRallyZone, false, 1000, 1000, false, aiBrain.M28AirSubteam, true, false, oUnit:GetPosition(), false) then
                                                tRetreatLocation = {tNearestFriendlyBase[1], tNearestFriendlyBase[2], tNearestFriendlyBase[3]}
                                            end
                                        end
                                    end
                                end
                            end
                            if not(tRetreatLocation) then tRetreatLocation = {tAirRallyPoint[1], tAirRallyPoint[2], tAirRallyPoint[3]} end
                            ForkThread(M28Micro.TurnAirUnitAndMoveToTarget, oUnit, tRetreatLocation, 15, 3)
                        end

                        --Have friendly gunships dodge
                        M28Micro.FriendlyGunshipsAvoidBomb(oUnit, oWeapon, projectile)
                    end
                    --T1 bombers targeting enemy ACU when not in snipe mode - consider reassigning/retreating if groundAA or AirAA threat nearby
                elseif EntityCategoryContains(categories.TECH1 * M28UnitInfo.refCategoryBomber + categories.TECH2 * M28UnitInfo.refCategoryBomber, oUnit.UnitId) and M28Utilities.IsTableEmpty(M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.toActiveSnipeTargets]) then
                    local tLastOrder = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]]
                    local oLastTarget = tLastOrder[M28Orders.subrefoOrderUnitTarget]
                    if M28UnitInfo.IsUnitValid(oLastTarget) and EntityCategoryContains(categories.COMMAND, oLastTarget.UnitId) then
                        --Check we arent close to killing the ACU
                        if oLastTarget:GetHealth() > (oLastTarget[M28Air.refiStrikeDamageAssigned] or 0) * 5 then
                            ForkThread(M28Air.ConsiderIfBomberTargetingACUShouldReassign, oUnit, oLastTarget)
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

--WARNING: OnWeaponFired and/or OnProjectilfeFired - one of these (probably the latter) resulted in error messages when t1 arti fired, disabled both of them as dont use now

function OnWeaponFired(oWeapon)
    if M28Utilities.bM28AIInGame then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnWeaponFired'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if not(M28Map.bWaterZoneInitialCreation) then
            while GetGameTimeSeconds() < 5 do
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if M28Map.bWaterZoneInitialCreation then break end
            end
        end



        if bDebugMessages == true then LOG(sFunctionRef..': Start of code; does the weapon have a valid unit='..tostring(M28UnitInfo.IsUnitValid(oWeapon.unit))..'; Weapon unitID='..(oWeapon.unit.UnitId or 'nil')..'; oWeapon[M28UnitInfo.refiLastWeaponEvent]='..(oWeapon[M28UnitInfo.refiLastWeaponEvent] or 'nil')..'; reprs='..reprs(oWeapon)..'; Time='..GetGameTimeSeconds()) end
        local oUnit = oWeapon.unit
        if oUnit and oUnit.GetUnitId and oUnit.GetAIBrain and M28UnitInfo.IsUnitValid(oUnit) then

            local oParentBrain = oUnit:GetAIBrain()
            --M28 torp bomber micro (done here as want to make sure we pick up the last weapon event)
            if oParentBrain.M28AI then
                if EntityCategoryContains(M28UnitInfo.refCategoryTorpBomber, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbSpecialMicroActive]) then
                    --Micro torp bombers if this is the last shot and torp only has 1 rack
                    if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..' has just fired a shot, Time='..GetGameTimeSeconds()..'; oWeapon[M28UnitInfo.refiLastWeaponEvent]='..(oWeapon[M28UnitInfo.refiLastWeaponEvent] or 'nil')..'; is salvo data nil='..tostring(oUnit.CurrentSalvoData == nil)..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; Is unit state attacking='..tostring(oUnit:IsUnitState('Attacking'))..'; reprs of Weapon salvo data='..reprs(oWeapon.CurrentSalvoData)..'; reprs of weapon='..reprs(oWeapon)..'; Weapon blueprint='..reprs(oWeapon.Blueprint)..'; Is rack size highest value='..tostring((oWeapon.CurrentRackSalvoNumber or 0) >= (oWeapon.Blueprint.RackSalvoSize or 0))..'; Is salvo size highest value='..tostring((oWeapon.CurrentSalvoNumber or 0) >= (oWeapon.Blueprint.MuzzleSalvoSize or 0))..'; oWeapon.CurrentRackSalvoNumber='..(oWeapon.CurrentRackSalvoNumber or 'nil')..'; oWeapon.Blueprint.RackSalvoSize='..oWeapon.Blueprint.RackSalvoSize..';oWeapon.CurrentSalvoNumber='..(oWeapon.CurrentSalvoNumber or 'nil')..'; Muzzle salvo size='..(oWeapon.Blueprint.MuzzleSalvoSize or 0)) end
                    if (oWeapon.CurrentRackSalvoNumber or 0) >= (oWeapon.Blueprint.RackSalvoSize or 0) and (oWeapon.CurrentSalvoNumber or 0) >= (oWeapon.Blueprint.MuzzleSalvoSize or 0) then
                        if not(oUnit[M28UnitInfo.refbEasyBrain]) then
                            ForkThread(M28Micro.TurnAirUnitAndMoveToTarget, oUnit, M28Team.tAirSubteamData[oParentBrain.M28AirSubteam][M28Team.reftAirSubRallyPoint], 25, 1)
                        end
                    end
                elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) then
                    ForkThread(M28Building.ConsiderManualT2ArtiTarget, oUnit, oWeapon)
                end


            end

            if not(oWeapon[M28UnitInfo.refiLastWeaponEvent]) or GetGameTimeSeconds() - (oWeapon[M28UnitInfo.refiLastWeaponEvent] or -1) >= 0.5 then
                oWeapon[M28UnitInfo.refiLastWeaponEvent] = GetGameTimeSeconds()
                oUnit[M28UnitInfo.refiLastWeaponEvent] = GetGameTimeSeconds()
                --Update unit last known position/record it
                for iTeam, tTeam in M28Team.tTeamData do
                    if not(iTeam == oParentBrain.M28Team) then
                        if M28Utilities.IsTableEmpty(tTeam[M28Team.subreftoFriendlyActiveM28Brains]) == false then
                            for iBrain, oBrain in tTeam[M28Team.subreftoFriendlyActiveM28Brains] do
                                M28Team.ConsiderAssigningUnitToZoneForBrain(oBrain, oUnit) --This function includes check of whether this is an M28 brain, and updates last known position
                                break
                            end
                        end
                    end
                end

                --Consider dodging
                if bDebugMessages == true then LOG(sFunctionRef..': About to consider dodging logic and recording non-M28 nuke target locations, weapon.DamageType='..(oWeapon.DamageType or 'nil')..'; oWeapon.Blueprint.DamageType='..(oWeapon.Blueprint.DamageType or 'nil')..'; Weapon label='..(oWeapon.Label or 'nil')..'; reprs of oWeapon='..reprs(oWeapon)) end
                if EntityCategoryContains(M28UnitInfo.refCategoryBomber, oUnit.UnitId) and (oWeapon.Label == 'GroundMissile') then
                    --Corsairs dont trigger the onbombfired event normally hence why we have this
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Weapon fired by corsair, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
                        if oWeapon:GetCurrentTarget().GetPosition then LOG(sFunctionRef..': Target of weapon='..repru(oWeapon:GetCurrentTarget():GetPosition())) end
                    end
                    if GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastDodgeBombEvent] or 0) >= 2 then
                        ForkThread(M28Micro.DodgeBomb, oUnit, oWeapon, nil)
                    end
                else
                    if EntityCategoryContains(M28UnitInfo.refCategorySML, oUnit.UnitId) and oWeapon.Blueprint.DamageType == 'Nuke' then
                        --Nuke missile fired - update the table for non-M28 AI (M28AI will have recorded the target when the order was given)
                        if bDebugMessages == true then LOG(sFunctionRef..': Unit brain='..oUnit:GetAIBrain().Nickname..'; GetCurrentTarget()='..reprs(oWeapon:GetCurrentTarget())..'; GetCurrentTargetPos='..reprs(oWeapon:GetCurrentTargetPos())) end
                        if not(oUnit:GetAIBrain().M28AI) and oWeapon.GetCurrentTargetPos then
                            local iTeam = oUnit:GetAIBrain().M28Team
                            local tCurrentTarget = oWeapon:GetCurrentTargetPos()
                            if M28Utilities.IsTableEmpty(tCurrentTarget) == false then
                                M28Building.RecordNukeTarget(iTeam, tCurrentTarget)
                                if bDebugMessages == true then LOG(sFunctionRef..': Target of weapon='..repru(tCurrentTarget)) end
                            end
                        end
                    end
                    --Dodge logic for certain other attacks (conditions for this are in considerdodgingshot)
                    if bDebugMessages == true then LOG(sFunctionRef..': Will consider whether we want to dodge the shot') end
                    ForkThread(M28Micro.ConsiderDodgingShot, oUnit, oWeapon)
                end

                --Update overcharge tracking
                if oWeapon.GetBlueprint and oWeapon.GetBlueprint and not(oWeapon:BeenDestroyed()) and oWeapon:GetBlueprint().Overcharge then
                    if bDebugMessages == true then LOG(sFunctionRef..': Overcharge weapon has just fired') end
                    oUnit[M28UnitInfo.refiTimeOfLastOverchargeShot] = GetGameTimeSeconds()
                    if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and oUnit:GetAIBrain().M28AI then
                        --Get another order immediately rather than waiting (means we dont have to try and queue orders up for ACU logic)
                        M28ACU.GetACUOrder(oUnit:GetAIBrain(), oUnit)
                    end
                end

                --M28 owned unit specific logic
                if oUnit:GetAIBrain().M28AI then
                    --Shot is blocked logic

                    if bDebugMessages == true then LOG(sFunctionRef..': COnsidering if unit shot is blocked Time='..GetGameTimeSeconds()..', range category='..(oWeapon.Blueprint.RangeCategory or 'nil')..'; Is unit a relevant DF category='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE + M28UnitInfo.refCategorySeraphimDestroyer - M28UnitInfo.refCategoryMissileShip, oUnit.UnitId))) end
                    if (oWeapon.Blueprint.RangeCategory == 'UWRC_DirectFire' and EntityCategoryContains(M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE + M28UnitInfo.refCategorySeraphimDestroyer - M28UnitInfo.refCategoryMissileShip, oUnit.UnitId)) or (oWeapon.Blueprint.RangeCategory == 'UWRC_AntiNavy' and EntityCategoryContains(M28UnitInfo.refCategorySubmarine, oUnit.UnitId)) then
                        --Get weapon target if it is a DF weapon or sub torpedo
                        local oTarget
                        if oWeapon.GetCurrentTarget and not(oWeapon:BeenDestroyed()) then oTarget = oWeapon:GetCurrentTarget() end
                        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has just fired a shot. Do we have a valid target for our weapon='..tostring(M28UnitInfo.IsUnitValid(oTarget))..'; time last shot was blocked='..(oUnit[M28UnitInfo.refiTimeOfLastCheck] or 'nil')) end
                        if M28UnitInfo.IsUnitValid(oTarget) then
                            if not(oUnit[M28UnitInfo.refbLastShotBlocked]) then oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] = math.max((oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100), (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) end
                            oUnit[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds()
                            oUnit[M28UnitInfo.refbLastShotBlocked] = M28Logic.IsShotBlocked(oUnit, oTarget, EntityCategoryContains(M28UnitInfo.refCategorySubmarine, oUnit.UnitId))
                            if bDebugMessages == true then LOG(sFunctionRef..': oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Is shot blocked='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked])..'; built in blocking terrain result for low profile='..tostring(oUnit:GetAIBrain():CheckBlockingTerrain(oUnit:GetPosition(), oTarget:GetPosition(), 'Low'))..'; High profile='..tostring(oUnit:GetAIBrain():CheckBlockingTerrain(oUnit:GetPosition(), oTarget:GetPosition(), 'High'))) end

                            if oUnit[M28UnitInfo.refbLastShotBlocked] then
                                --Reset after 20s if we havent fired any more shots at the target
                                --function DelayChangeVariable(oVariableOwner, sVariableName, vVariableValue, iDelayInSeconds, sOptionalOwnerConditionRef, iMustBeLessThanThisTimeValue, iMustBeMoreThanThisTimeValue, vMustNotEqualThisValue)
                                M28Utilities.DelayChangeVariable(oUnit, M28UnitInfo.refbLastShotBlocked, false, 20, M28UnitInfo.refiTimeOfLastCheck, GetGameTimeSeconds() + 0.01)
                                --Increase shot blocked count if this is a longer ranged naval unit firing at a structure
                                if oUnit[M28UnitInfo.refiCombatRange] > 50 and EntityCategoryContains(M28UnitInfo.refCategoryNavalSurface, oUnit.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oTarget.UnitId) then
                                    oTarget[M28UnitInfo.refiTargetShotBlockedCount] = (oTarget[M28UnitInfo.refiTargetShotBlockedCount] or 0) + 1
                                end
                            elseif oUnit[M28UnitInfo.refiCombatRange] > 50 and EntityCategoryContains(M28UnitInfo.refCategoryNavalSurface, oUnit.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oTarget.UnitId) then
                                oTarget[M28UnitInfo.refiTargetShotBlockedCount] = 0
                            end
                        end
                        if EntityCategoryContains(M28UnitInfo.refCategorySMD, oUnit.UnitId) then
                            if oUnit:GetNukeSiloAmmoCount() >= 1 then
                                oUnit[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds() - 240 - M28Building.iTimeForSMDToBeConstructed
                            else
                                oUnit[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds() - M28Building.iTimeForSMDToBeConstructed --For an SMD this will effectively mean we think the SMD isnt loaded anymore; below acts as a basic check to approximate scenarios where SMD has been around a while (ideally if improving on this would just use a dif variable to refiTimeOfLastCheck so can track the actual values wanted)
                            end
                            --If this was an Aeon SMD owned by vendetta personality then send voice taunt
                            if oUnit:GetAIBrain()[M28Chat.refiAssignedPersonality] == M28Chat.refiVendetta then
                                ForkThread(M28Chat.SendMessage, oUnit:GetAIBrain(), 'VendettaSMD', LOC('<LOC X06_T01_560_010>[{i Vendetta}]: Nice try.'), 1, 600, false, true, 'X06_Vedetta_T01_03018', 'X06_VO')
                            end
                        end
                    end
                    --T3 arti targeting logic; TML missile tracking
                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, oUnit.UnitId) then
                        ForkThread(M28Building.GetT3ArtiTarget, oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                        if M28UnitInfo.IsUnitValid(oUnit[M28Building.refoLastTMLTarget]) then
                            oUnit[M28Building.refoLastTMLTarget][M28Building.refiTimeOfLastLaunch] = GetGameTimeSeconds()
                            if bDebugMessages == true then LOG(sFunctionRef..': have set time of last launch to '..oUnit[M28Building.refoLastTMLTarget][M28Building.refiTimeOfLastLaunch]..' for target '..oUnit[M28Building.refoLastTMLTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28Building.refoLastTMLTarget])) end
                        end
                    end
                    --SML, TML and SMD - unpause (if paused)
                    if EntityCategoryContains(M28UnitInfo.refCategorySML + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                        M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, false)
                        --TML and nuke - consider launching missile if have any remaining
                        ForkThread(M28Building.JustFiredMissile, oUnit)
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

    end
end

--[[function ProjectileFiredAtGround(oProjectile)
    if oProjectile.GetCurrentTargetPosition then
        LOG('TEMP TEST will draw projectile targeting ground target')
        M28Utilities.DrawLocation(oProjectile:GetCurrentTargetPosition(), 2)
    end
end--]]

function ProjectileCreated(oProjectile, inWater)
    --[[if oProjectile.GetCurrentTargetPosition then
        LOG('TEMP TEST will draw projectile created target')
        M28Utilities.DrawLocation(oProjectile:GetCurrentTargetPosition(), 2)
    end--]]
    if oProjectile.BeenDestroyed and not(oProjectile:BeenDestroyed()) then
        local bTrackingProjectile = false
        if oProjectile.GetTrackingTarget then
            local oTarget = oProjectile:GetTrackingTarget()
            --M28 target specific logic:
            if M28UnitInfo.IsUnitValid(oTarget) then
                bTrackingProjectile = true
                if oTarget:GetAIBrain().M28AI and not(oTarget:GetAIBrain().M28Easy) then
                    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
                    local sFunctionRef = 'ProjectileCreated'
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

                    --Gunships - consider retreating early
                    if EntityCategoryContains(M28UnitInfo.refCategoryGunship - categories.CANNOTUSEAIRSTAGING, oTarget.UnitId) and not(oTarget.MyShield) and not(oTarget[M28UnitInfo.refbProjectilesMeanShouldRefuel]) then
                        if M28UnitInfo.IsUnitValid(oTarget) then
                            if not(oTarget[M28UnitInfo.reftoEnemyProjectiles]) then
                                oTarget[M28UnitInfo.reftoEnemyProjectiles] = {}
                            end
                            table.insert(oTarget[M28UnitInfo.reftoEnemyProjectiles], oProjectile)
                            --Estimate total damage to be dealt
                            local iTotalDamage = 0
                            for iCurProjectile = table.getn(oTarget[M28UnitInfo.reftoEnemyProjectiles]), 1, -1 do
                                local oCurProjectile = oTarget[M28UnitInfo.reftoEnemyProjectiles][iCurProjectile]
                                if oCurProjectile:BeenDestroyed() then
                                    table.remove(oTarget[M28UnitInfo.reftoEnemyProjectiles], iCurProjectile)
                                else
                                    iTotalDamage = iTotalDamage + (oCurProjectile.DamageData.DamageAmount or 'nil')
                                end
                            end

                            local iCurHealth = oTarget:GetHealth()
                            local iMaxHealth = oTarget:GetMaxHealth()
                            if (iCurHealth - iTotalDamage) <= iMaxHealth * M28Air.iProjectileLowHealthThreshold then
                                oTarget[M28UnitInfo.refbProjectilesMeanShouldRefuel] = true
                                M28Air.SendUnitsForRefueling({ oTarget }, oTarget:GetAIBrain().M28Team, oTarget:GetAIBrain().M28AirSubteam, true)
                                if bDebugMessages == true then LOG(sFunctionRef..'; sent gunship '..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..' for refueling') end
                            end

                            --LOG('TEMP oProjectile targeting gunship reprs='..reprs(oProjectile)..'; reprs of damage data='..reprs(oProjectile.DamageData)..'; damageData.DamageAmount='..(oProjectile.DamageData.DamageAmount or 'nil'))
                            if bDebugMessages == true then LOG(sFunctionRef..': projectile target='..(oTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTarget) or 'nil')..'; Cur projectile damage='..(oProjectile.DamageData.DamageAmount or 'nil')..'; iTotalDamage='..iTotalDamage..'; iCurHealth='..iCurHealth..'; iMaxHealth='..iMaxHealth..'; oTarget[M28UnitInfo.refbProjectilesMeanShouldRefuel]='..tostring(oTarget[M28UnitInfo.refbProjectilesMeanShouldRefuel] or false)..'; Time='..GetGameTimeSeconds()) end
                        end
                    end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                end
            end
        end
        if not(bTrackingProjectile) then
            --LOG('reprs of oProjectile='..reprs(oProjectile)..'; reprs of oProjectile.Launcher='..reprs(oProjectile.Launcher)..'; oProjectile.InnerRing is nil='..tostring(oProjectile.InnerRing == nil)..'; oProjectile.OuterRing is nil='..tostring(oProjectile.OuterRing == nil)..'; Is launcher a nuke='..tostring(EntityCategoryContains(M28UnitInfo.refCategorySML, oProjectile.Launcher.UnitId)))
            if oProjectile.Launcher.UnitId and oProjectile.InnerRing and oProjectile.OuterRing and EntityCategoryContains(M28UnitInfo.refCategorySML, oProjectile.Launcher.UnitId) then
                --Have a nuke missile that has just been fired
                local oLauncher = oProjectile.Launcher
                --LOG('Is launcher valid='..tostring(M28UnitInfo.IsUnitValid(oLauncher)))
                if M28UnitInfo.IsUnitValid(oLauncher) then
                    local iTeam = oLauncher:GetAIBrain().M28Team
                    if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 0 then
                        ForkThread(M28Micro.MonitorNukeTargetForFriendlyUnits, oProjectile, oLauncher, iTeam)
                    end
                end

            end
        end
    end
end

--[[function ProjectileFiredFromWeapon(oProjectile)
    if oProjectile.GetCurrentTargetPosition then
        LOG('TEMP TEST will draw projectile created from firing weapon, oProjectile.UnitId='..(oProjectile.Unitid or 'nil')..'; launcher unit id='..(oProjectile.Launcher.UnitId or 'nil')..'; drawing projectile target='..repru(oProjectile:GetCurrentTargetPosition())..'; reprs of projectile='..reprs(oProjectile))
        for iEntry, tTable in oProjectile do
            LOG('reprs of iEntry='..iEntry..'='..reprs(tTable))
        end
        M28Utilities.DrawLocation(oProjectile:GetCurrentTargetPosition(), 3)
    else
        LOG('Projectyile fired but doesnt have a target position')
    end
end--]]

function OnMissileBuilt(self, weapon)
    if M28Utilities.bM28AIInGame then
        if self.GetAIBrain and self:GetAIBrain().M28AI then
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            local sFunctionRef = 'OnMissileBuilt'
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

            self[M28Building.refbMissileRecentlyBuilt] = true
            M28Utilities.DelayChangeVariable(self, M28Building.refbMissileRecentlyBuilt, false, 5)


            --Pause if we already have 2 missiles (mroe if smd and enemy has nukes)
            if bDebugMessages == true then
                if M28UnitInfo.IsUnitValid(self) then
                    LOG(sFunctionRef..': Have valid unit='..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self))
                else
                    LOG(sFunctionRef..': self='..reprs(self))
                end
            end

            local iMissiles = 1 --For some reason the count is off by 1, presumably a slight delay between the event being called and the below ammo counts working
            if self.GetTacticalSiloAmmoCount then iMissiles = iMissiles + self:GetTacticalSiloAmmoCount() end
            if bDebugMessages == true then LOG(sFunctionRef..': iMissiles based on tactical silo ammo='..iMissiles) end
            if self.GetNukeSiloAmmoCount then iMissiles = iMissiles + self:GetNukeSiloAmmoCount() end
            if bDebugMessages == true then LOG(sFunctionRef..': iMissiles after Nuke silo ammo='..iMissiles) end
            if iMissiles >= 1 then
                --Stop assisting units (so can reassess if we still want to assist)
                if M28Utilities.IsTableEmpty(self[M28UnitInfo.reftoUnitsAssistingThis]) == false then
                    local tEngineersToStop = {}
                    for iEngineer, oEngineer in self[M28UnitInfo.reftoUnitsAssistingThis] do
                        table.insert(tEngineersToStop, oEngineer)
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to make engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to stop assisting') end
                    end
                    for iEngineer, oEngineer in tEngineersToStop do
                        if M28UnitInfo.IsUnitValid(oEngineer) then
                            M28Orders.IssueTrackedClearCommands(oEngineer)
                            if bDebugMessages == true then LOG(sFunctionRef..': Just sent a clear order to '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to stop assisting') end
                        end
                    end
                end

                --If 2+ missiles then pause, and consider unpausing later
                if iMissiles >= 2 and not(EntityCategoryContains(categories.EXPERIMENTAL, self.UnitId)) then
                    if not(EntityCategoryContains(M28UnitInfo.refCategorySMD, self.UnitId)) or
                            --SMD specific
                            (iMissiles >= 4 or M28Utilities.IsTableEmpty(M28Team.tTeamData[self:GetAIBrain().M28Team][M28Team.reftEnemyNukeLaunchers]) or iMissiles >= 2 + table.getn(M28Team.tTeamData[self:GetAIBrain().M28Team][M28Team.reftEnemyNukeLaunchers])) then
                        local iTeam = self:GetAIBrain().M28Team
                        --Dont pause if overflowing
                        if M28Conditions.HaveLowPower(iTeam) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 400 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.8 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 30 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 25 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.99))) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have at least 2 missiles so will set paused to true on unit '..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self)) end
                            self:SetPaused(true)
                            if self.SetAutoMode then self:SetAutoMode(false) end

                            --Recheck every minute
                            ForkThread(M28Building.CheckIfWantToBuildAnotherMissile, self)
                        end
                    end
                end
                if EntityCategoryContains(M28UnitInfo.refCategorySMD, self.UnitId) then
                    --Do we have any SMD without missiles, and no yolona on the team? If so then change the flag about needing resources for missiles
                    local bHaveSMDOrSMLNeedingMissiles = false
                    local iTeam = self:GetAIBrain().M28Team
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        if oBrain:GetCurrentUnits(M28UnitInfo.refCategorySML) > 0 then
                            bHaveSMDOrSMLNeedingMissiles = true
                            break
                        else
                            local tSMD = oBrain:GetListOfUnits(M28UnitInfo.refCategorySMD, false, true)
                            if M28Utilities.IsTableEmpty(tSMD) == false then
                                for iSMD, oSMD in tSMD do
                                    if not(oSMD == self) then
                                        if oSMD:GetFractionComplete() < 1 or oSMD:GetNukeSiloAmmoCount() == 0 then
                                            bHaveSMDOrSMLNeedingMissiles = true
                                            break
                                        end
                                    end
                                end
                                if bHaveSMDOrSMLNeedingMissiles then break end
                            end
                        end
                    end
                    if not(bHaveSMDOrSMLNeedingMissiles) then
                        M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] = false
                    end
                end
            end

            if not(EntityCategoryContains(M28UnitInfo.refCategorySMD, self.UnitId)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Calling logic to consider launching a missile') end
                --LOG('Forked consideration of launching missile 6')
                ForkThread(M28Building.ConsiderLaunchingMissile, self, weapon)
            end
        end

    end
end

--[[
function OnProjectileFired(oWeapon, oMuzzle)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OnProjectileFired'
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
    if oWeapon.GetBlueprint then
        LOG('OnWeaponFired hook for blueprint='..repru(oWeapon:GetBlueprint()))
    end
    if oWeapon.unit then
        LOG('Have a unit; unit position='..repru(oWeapon.unit:GetPosition()))
    end
end--]]

function OnConstructionStarted(oEngineer, oConstruction, sOrder)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnConstructionStarted'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



        --Update land zone queued orders
        if M28Utilities.IsTableEmpty(oEngineer[M28Engineer.reftQueuedBuildings]) == false then
            M28Engineer.RemoveBuildingFromQueuedBuildings(oEngineer, oConstruction)
        end


        --M28 specific
        if oEngineer:GetAIBrain().M28AI then
            --Stuff to update every time construction starts
            if oEngineer[M28Building.reftArtiTemplateRefs] then oEngineer[M28Conditions.refiEngineerStuckCheckCount] = 0 end
            if oConstruction.GetUnitId and not(oConstruction[M28UnitInfo.refbConstructionStart]) then
                oConstruction[M28UnitInfo.refbConstructionStart] = true



                if bDebugMessages == true then
                    --local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oConstruction:GetPosition()) --decided not to include due to worry this might desync replays
                    LOG(sFunctionRef..': Construction just started by M28 engineer belonging to '..oEngineer:GetAIBrain().Nickname..' on oConstruction='..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction)..'; postiion='..repru(oConstruction:GetPosition())..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; oEngineer[M28Building.reftArtiTemplateRefs]='..repru(oEngineer[M28Building.reftArtiTemplateRefs])..'; Engi action (if any)='..(oEngineer[M28Engineer.refiAssignedAction] or 'nil')..' at time '..GetGameTimeSeconds())
                end
                --Record any mexes so we can repair them if construction gets interrupted
                if EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oConstruction.UnitId) then
                    M28Engineer.RecordPartBuiltMex(oEngineer, oConstruction)
                end

                --Track special game ender logic buildings
                if oEngineer[M28Building.reftArtiTemplateRefs] then
                    if bDebugMessages == true then LOG(sFunctionRef..': We have construction being built by engi with arti template ref, so will copy over engineer arti template ref, oEngineer[M28Building.reftArtiTemplateRefs]='..repru(oEngineer[M28Building.reftArtiTemplateRefs])) end
                    oConstruction[M28Building.reftArtiTemplateRefs] =  {oEngineer[M28Building.reftArtiTemplateRefs][1], oEngineer[M28Building.reftArtiTemplateRefs][2], oEngineer[M28Building.reftArtiTemplateRefs][3]}

                    local tLZTeamData = M28Map.tAllPlateaus[oEngineer[M28Building.reftArtiTemplateRefs][1]][M28Map.subrefPlateauLandZones][oEngineer[M28Building.reftArtiTemplateRefs][2]][M28Map.subrefLZTeamData][oConstruction:GetAIBrain().M28Team]
                    if tLZTeamData then
                        if bDebugMessages == true then
                            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oConstruction:GetPosition())
                            LOG(sFunctionRef..': Arti template recording of unit where construction started; engineer template ref='..repru(oEngineer[M28Building.reftArtiTemplateRefs])..'; Is table of active game ender templates for this ref empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates][oEngineer[M28Building.reftArtiTemplateRefs]]))..'; Is tLZTeamData[M28Map.reftActiveGameEnderTemplates] empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates]))..'; Construction plateau='..(iPlateau or 'nil')..'; LZ='..(iLandZone or 'nil')..'; Engineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; oConstruction='..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction))
                        end
                        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oConstruction.UnitId) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have started fixed shield so will add to table of shields for this reference') end
                            local tTemplateRef = tLZTeamData[M28Map.reftActiveGameEnderTemplates][oEngineer[M28Building.reftArtiTemplateRefs][3]]
                            --Check shield isn't already recorded
                            local bAlreadyRecorded = false
                            if M28Utilities.IsTableEmpty(tTemplateRef[M28Map.subrefGEShieldUnits]) == false then
                                for iRecordedShield, oRecordedShield in tTemplateRef[M28Map.subrefGEShieldUnits] do
                                    if oRecordedShield == oConstruction then
                                        bAlreadyRecorded = true
                                        break
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': bAlreadyRecorded='..tostring(bAlreadyRecorded)) end
                            if not(bAlreadyRecorded) then
                                table.insert(tTemplateRef[M28Map.subrefGEShieldUnits], oConstruction)
                                if bDebugMessages == true then LOG(sFunctionRef..': Added unit to table of shield units') end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Wont record shield '..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction)..' against arti template as it was already recorded') end
                            end

                            --Check if we no longer need special faction engineers
                            if M28Utilities.IsTableEmpty(tTemplateRef[M28Map.subrefGEArtiUnits]) == false and table.getn(tTemplateRef[M28Map.subrefGEShieldUnits]) >= math.min(7, table.getn(tTemplateRef[M28Map.subrefGEShieldLocations])) then
                                for iArti, oArti in tTemplateRef[M28Map.subrefGEArtiUnits] do
                                    if oArti[M28Building.refoNearbyFactoryOfFaction] then
                                        M28Building.UnitNoLongerRequiresFactoryFactionShieldEngineers(oArti)
                                    end
                                end
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oConstruction.UnitId) then
                            local tTemplateRef = tLZTeamData[M28Map.reftActiveGameEnderTemplates][oEngineer[M28Building.reftArtiTemplateRefs][3]]
                            local bAlreadyRecorded = false
                            if M28Utilities.IsTableEmpty(tTemplateRef[M28Map.subrefGEArtiUnits]) == false then
                                for iRecordedArti, oRecordedArti in tTemplateRef[M28Map.subrefGEArtiUnits] do
                                    if oRecordedArti == oConstruction then
                                        bAlreadyRecorded = true
                                        break
                                    end
                                end
                            end
                            if not(bAlreadyRecorded) then
                                --Check this isn't a mobile non-scathis unit
                                if not(EntityCategoryContains(categories.MOBILE, oConstruction.UnitId)) or M28UnitInfo.GetBlueprintMaxGroundRange(oConstruction:GetBlueprint()) >= 500 then
                                    table.insert(tTemplateRef[M28Map.subrefGEArtiUnits], oConstruction)
                                elseif bDebugMessages == true then LOG(sFunctionRef..': We have constructed a mobile unit with a short range so wont record as an arti unit')
                                end
                            end
                            tTemplateRef[M28Map.subrefbFailedToGetArtiLocation] = false
                            if bDebugMessages == true then LOG(sFunctionRef..': Have started experimental type unit so will add to table of arti for this reference, oConstruction='..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction)..'; bAlreadyRecorded='..tostring(bAlreadyRecorded)) end
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySMD, oConstruction.UnitId) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have started SMD unit so will add to table of SMD for this reference') end
                            tLZTeamData[M28Map.reftActiveGameEnderTemplates][oEngineer[M28Building.reftArtiTemplateRefs][3]][M28Map.subrefGESMDUnit] = oConstruction
                        else
                            M28Utilities.ErrorHandler('Engineer has just started construction on a unit that isnt one we would expect to be built for gameender template logic, Unit='..(oConstruction.UnitId or 'nil')..'; Engineer action='..(oEngineer[M28Engineer.refiAssignedAction] or 'nil')..'; Engineer='..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil'))
                            oConstruction[M28Building.reftArtiTemplateRefs] = nil
                            if EntityCategoryContains(M28UnitInfo.refCategoryFactory + categories.EXTERNALFACTORYUNIT, oEngineer.UnitId) then oEngineer[M28Building.reftArtiTemplateRefs] = nil end
                            if bDebugMessages == true then LOG(sFunctionRef..': Engi starting unexpected category, oEngineer='..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil')..'; Brain='..oEngineer:GetAIBrain().Nickname..'; index='..oEngineer:GetAIBrain():GetArmyIndex()) end
                        end
                    else M28Utilities.ErrorHandler('Started building a unit for arti template but it isnt in a zone')
                    end
                end

                --Decide if want to shield this construction and update buildable location, or (in the case of experimentals) if we want to cancel the construction
                if EntityCategoryContains(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryExperimentalLevel, oConstruction.UnitId) then
                    local bCancelBuilding = false
                    if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti, oConstruction.UnitId) and not(oConstruction[M28Building.reftArtiTemplateRefs]) and not(oEngineer[M28Building.reftArtiTemplateRefs]) then
                        local iTeam = oEngineer:GetAIBrain().M28Team
                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.9 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] < 3 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] < 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.6)) then
                            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oConstruction:GetPosition())
                            if iPlateau > 0 and (iLandZone or 0) > 0 then
                                --NOTE: If changing above thresholds then consider also changing M28Engineer ConsiderActionToAssign threshold (want above to be less likely to trigger to avoid constant loop of starting and cancelling)
                                local iSearchRange = math.max(175, 450 - M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) --(slightly further search range than the M28Engineer approach)
                                local iSearchCategory = nil --means will search for everything
                                if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder, oConstruction.UnitId) then iSearchCategory = M28UnitInfo.refCategoryGameEnder
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti, oConstruction.UnitId) then iSearchCategory = M28UnitInfo.refCategoryFixedT3Arti
                                else
                                    --Search for all experimentals  (so leave as nil) - however given the above restriction this is more for redundancy as would only expect to be here if are building game ender or t3 arti
                                end
                                local bHaveExperimentalForThisLandZone, iOtherLandZonesWithExperimental, iMassToComplete = M28Engineer.GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateau, iLandZone, true, iSearchRange, iSearchCategory)
                                if iMassToComplete >= math.max(17500, M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] * 1.3) then
                                    --Estimate how long it will take to complete if we manage to spend 40% of gross mass on existing experimentals
                                    if (iMassToComplete - M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]) / M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 0.4 > 40 then
                                        bCancelBuilding = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to cancel construction that we just started, iMassToComplete='..iMassToComplete..'; Mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) end
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': bCancelBuilding='..tostring(bCancelBuilding)) end
                    if bCancelBuilding then
                        --Clear all engineeres trying to build this
                        M28Engineer.ClearEngineersBuildingUnit(oEngineer, oConstruction)
                        --Tell the engi that just constructed to reclaim
                        M28Orders.IssueTrackedReclaim(oEngineer, oConstruction, false, 'AbrtNRec', true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have told engineer to abort consturction of '..oConstruction.UnitId..' and to reclaim it instead') end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Engineer that is starting this construction='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; oEngineer[M28Engineer.refiAssignedAction]='..(oEngineer[M28Engineer.refiAssignedAction] or 'nil')) end
                        if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oConstruction.UnitId) then
                            local iTeam = oConstruction:GetAIBrain().M28Team
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to cancel experimental queued in other zones, bCancelBuilding='..tostring(bCancelBuilding)..'; M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount]='..M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount]..'; Mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Team has low mass='..tostring(M28Conditions.TeamHasLowMass(iTeam))) end
                            if M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] < 20000 and M28Conditions.TeamHasLowMass(iTeam) then
                                --If dont have an experimental constructed yet then when we start our first exp go through each other zone with engineers trying to build an experimental and clear the engineers if we have low mass and the engineers havent started building yet
                                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oConstruction:GetPosition())
                                if iPlateau > 0 and iLandZone > 0 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will consider cancelling other queued engineer construction if there is any; M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]) end
                                    M28Engineer.GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateau, iLandZone, false, nil, nil, true)
                                end
                            end
                        end

                        --Game ender and T3 arti specific - reserve locations for shields
                        if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti, oConstruction.UnitId) and not(oConstruction[M28Building.reftArtiTemplateRefs]) then
                            M28Building.ReserveLocationsForGameEnder(oConstruction)
                            --Record shields against the gameender/T3 arti if they are in the reserved location
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oConstruction.UnitId) then
                            if oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionSpecialShieldDefence then
                                M28Building.AssignShieldToGameEnder(oConstruction, oEngineer)
                            else
                                --Consider adding normal shields to the gameender defence if they are built very near to a game ender location
                                if oConstruction:GetAIBrain().M28AI and oEngineer:GetAIBrain().M28AI then
                                    local iShieldRadius = (oConstruction:GetBlueprint().Defense.Shield.ShieldSize or 0) * 0.5
                                    if iShieldRadius > 10 then --larger than a T2 aeon shield
                                        local iTeam = oEngineer:GetAIBrain().M28Team
                                        local tShieldLZData, tShieldLZTeamData = M28Map.GetLandOrWaterZoneData(oConstruction:GetPosition(), true, iTeam)
                                        local bHaveMatch = false

                                        if M28Utilities.IsTableEmpty(tShieldLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) == false then
                                            for iGameEnder, oGameEnder in tShieldLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
                                                if M28Utilities.IsTableEmpty(oGameEnder[M28Building.reftLocationsForPriorityShield]) == false then
                                                    for iLocation, tLocation in oGameEnder[M28Building.reftLocationsForPriorityShield] do
                                                        if M28Utilities.GetRoughDistanceBetweenPositions(tLocation, oConstruction:GetPosition()) <= 3 then
                                                            if M28Utilities.GetDistanceBetweenPositions(oConstruction:GetPosition(), oGameEnder:GetPosition()) <= iShieldRadius * 0.9 then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Fixed shield construction '..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction)..' built by engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; will be assigned to a game ender shield as it is close to oGameEnder '..oGameEnder.UnitId..M28UnitInfo.GetUnitLifetimeCount(oGameEnder)) end
                                                                bHaveMatch = true
                                                                M28Building.AssignShieldToGameEnder(oConstruction, oEngineer)
                                                                break
                                                            end
                                                        end
                                                    end
                                                    if bHaveMatch then break end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            --ACU building t1 power far from base - flag that we dont want it assisted
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryT1Power, oConstruction.UnitId) and EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then
                            local oEngineerBrain = oEngineer:GetAIBrain()
                            if oEngineerBrain[M28Economy.refiGrossMassBaseIncome] >= 1.5 then
                                local tEngineerLZData = M28Map.GetLandOrWaterZoneData(oConstruction:GetPosition())
                                if M28Utilities.GetDistanceBetweenPositions(tEngineerLZData[M28Map.subrefMidpoint], oEngineer:GetPosition()) >= 25 then
                                    oConstruction[M28Engineer.refbDontIncludeAsPartCompleteBuildingForConstruction] = true
                                end
                            end
                        end
                        M28Building.CheckIfUnitWantsFixedShield(oConstruction, true)
                        --If this is a fixed shield then instead update shield coverage
                        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oConstruction.UnitId) then
                            M28Building.UpdateShieldCoverageOfUnits(oConstruction, false)
                        end

                        --Buildable locations - update for unit construction started (do form obile experimentals since the location is temporarily not buildable)
                        if EntityCategoryContains(M28UnitInfo.refCategoryStructure + categories.MOBILE - M28UnitInfo.refCategoryMex - M28UnitInfo.refCategoryHydro, oConstruction.UnitId) then
                            if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oConstruction.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Just started construction of unit '..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction)..'; Is it valid to build a T1 pgen at this location='..tostring(oEngineer:GetAIBrain():CanBuildStructureAt('ueb1101', oConstruction:GetPosition()))) end
                                ForkThread(M28Engineer.CheckIfBuildableLocationsNearPositionStillValid, oEngineer:GetAIBrain(), oConstruction:GetPosition(), false, M28UnitInfo.GetBuildingSize(oConstruction.UnitId) * 0.5)
                            else
                                --i.e. experimentalal started, the CanBuildStructureAt check doesnt work properly for this so first need to record a blacklist (will only have recorded for 4m) and then check for this
                                if bDebugMessages == true then LOG(sFunctionRef..': Just started construction of experimental mobile unit='..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction)..'; Is it valid to build a T1 pgen at this location='..tostring(oEngineer:GetAIBrain():CanBuildStructureAt('ueb1101', oConstruction:GetPosition()))) end
                                M28Engineer.RecordBlacklistLocation(oConstruction:GetPosition(), M28UnitInfo.GetBuildingSize(oConstruction.UnitId) * 0.5, 420, oConstruction)
                                ForkThread(M28Engineer.CheckIfBuildableLocationsNearPositionStillValid, oEngineer:GetAIBrain(), oConstruction:GetPosition(), true, M28UnitInfo.GetBuildingSize(oConstruction.UnitId) * 0.5)
                            end
                        end
                        --end
                        --Both structures and experimentals - clear any engineers trying to build something else that will be blocked by this
                        ForkThread(M28Engineer.ClearEngineersWhoseTargetIsNowBlockedByUnitConstructionStarted, oEngineer, oConstruction)
                    end
                else
                    --Mobile unit - special logic for navla factories for mini bombardment (raid) target
                    if EntityCategoryContains(M28UnitInfo.refCategoryBombardment, oConstruction.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oEngineer.UnitId) then
                        M28Navy.ConsiderAssigningRaidingNavalUnit(oConstruction, oEngineer)
                    end
                end

            end
        else
            --Non-M28 only
            if not(oConstruction[M28UnitInfo.refbConstructionStart]) then
                oConstruction[M28UnitInfo.refbConstructionStart] = true
                --If this is a fixed shield then instead update shield coverage (note - we also do this for M28 brains above, but with some extra logic to decide if we want to try and shield, and using a more efficient emthod of identifying shields)
                if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oConstruction.UnitId) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a shield that we have just started ubilding so will update shield coverage') end
                    M28Building.UpdateShieldCoverageOfUnits(oConstruction, false)
                elseif EntityCategoryContains(M28UnitInfo.refCategoryStructure - categories.MOBILE, oConstruction.UnitId) then
                    --Record if this unit is under fixed shield coverage if it's not owned by an M28AI brain (M28AI units will separately check this by using the LZ data info)
                    local tNearbyShields = oConstruction:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedShield, oConstruction:GetPosition(), 60, 'Ally')
                    if bDebugMessages == true then LOG(sFunctionRef..': have just started construction of a building, will check for nearby shields, is tNearbyShields empty='..tostring(M28Utilities.IsTableEmpty(tNearbyShields))) end
                    if M28Utilities.IsTableEmpty(tNearbyShields) == false then
                        local iShieldRadius
                        for iShield, oShield in tNearbyShields do
                            iShieldRadius = oShield:GetBlueprint().Defense.Shield.ShieldSize * 0.5 -0.1 -- - 1
                            M28Building.RecordIfShieldIsProtectingUnit(oShield, oConstruction, iShieldRadius, true)
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnConstructed(oEngineer, oJustBuilt)
    --WARNING: This doesnt seem to trigger for the ACU; it does trigger when untis are constructed by a factory

    --NOTE: This is called every time an engineer stops building a unit whose fractioncomplete is 100%, so can be called multiple times
    if M28Utilities.bM28AIInGame then
        --NonM28 specific - dont set the M28OnConstructionCalled for this, so need to  be careful that any code here will not be run repeatedly
        --LOG('OnConstructed at time '..GetGameTimeSeconds()..' for unit '..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..' owned by brain '..oJustBuilt:GetAIBrain().Nickname..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; M28Map.bMapLandSetupComplete='..tostring(M28Map.bMapLandSetupComplete or false))
        if not(M28Map.bFirstM28TeamHasBeenInitialised) or not(M28Map.bMapLandSetupComplete) then
            local iWaitCount = 0
            local bDontCallAgain = false
            while not(M28Map.bFirstM28TeamHasBeenInitialised) or not(M28Map.bMapLandSetupComplete) do
                WaitTicks(1)
                iWaitCount = iWaitCount + 1
                if iWaitCount >= 300 then
                    M28Utilities.ErrorHandler('Waited more than 5m for map setup or team setup to complete, something has gone wrong, M28Map.bFirstM28TeamHasBeenInitialised='..tostring(M28Map.bFirstM28TeamHasBeenInitialised or false)..'; M28Map.bMapLandSetupComplete='..tostring(M28Map.bMapLandSetupComplete or false))
                    bDontCallAgain = true
                    break
                end
            end
            if not(bDontCallAgain) and M28UnitInfo.IsUnitValid(oJustBuilt) then
                OnConstructed(oEngineer, oJustBuilt)
            end
        else
            local sFunctionRef = 'OnConstructed'
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

            if not(oJustBuilt.UnitId) then --LOUD compatibility redundancy (OnCreate should also do this)
                if not(M28Utilities.bFAFActive) then
                    if not(oJustBuilt.EntityId) then oJustBuilt.EntityId = oJustBuilt:GetEntityId() end
                    oJustBuilt.UnitId = oJustBuilt:GetBlueprint().BlueprintId
                end
            end

            M28Orders.ClearAnyRepairingUnits(oJustBuilt)
            if M28Utilities.IsTableEmpty(oJustBuilt[M28Land.reftoUnitsToKillOnCompletion]) == false then
                for iUnit, oUnit in oJustBuilt[M28Land.reftoUnitsToKillOnCompletion] do
                    if M28UnitInfo.IsUnitValid(oUnit) and (not(oUnit[M28UnitInfo.refbCampaignTriggerAdded]) or not(M28Map.bIsCampaignMap)) then
                        M28Orders.IssueTrackedKillUnit(oUnit)
                    end
                end
                oJustBuilt[M28Land.reftoUnitsToKillOnCompletion] = nil
            end

            if EntityCategoryContains(categories.STRUCTURE, oJustBuilt.UnitId) then
                --If a building has just build a building, then make sure all M28 are aware of it (since a player would be)
                if EntityCategoryContains(categories.STRUCTURE, oEngineer.UnitId) then
                    local tTeamsUpdated = {}
                    for iBrain, oBrain in M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subreftoEnemyBrains] do
                        if oBrain.M28AI and not(tTeamsUpdated[oBrain.M28Team]) then
                            tTeamsUpdated[oBrain.M28Team] = true
                            M28Team.AssignUnitToLandZoneOrPond(oBrain, oJustBuilt, false, false, true)
                        end
                    end
                end
                --Also update the name
                if M28Config.M28ShowUnitNames then
                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oJustBuilt:GetPosition(), false)

                    local sWZOrLZRef = ''
                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oJustBuilt:GetPosition())
                    local iWaterZone
                    if (iLandZone or 0) == 0 then
                        iWaterZone = M28Map.GetWaterZoneFromPosition(oJustBuilt:GetPosition())
                        if (iWaterZone or 0) > 0 then
                            sWZOrLZRef = 'WZ'..iWaterZone
                        end
                    else
                        sWZOrLZRef = ':P='..(iPlateau or 0)..'LZ='..(iLandZone or 0)
                    end

                    if M28Config.M28ShowUnitNames then oJustBuilt:SetCustomName(oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..sWZOrLZRef..': Built') end
                end

                --Redundnacy - If we have just built a radar then update radar logic (note that AssignUnitToLandZoneOrPond should already cover this when construction is started)
                if EntityCategoryContains(M28UnitInfo.refCategoryRadar, oJustBuilt.UnitId) then
                    ForkThread(M28Land.UpdateZoneIntelForRadar, oJustBuilt)
                elseif EntityCategoryContains(M28UnitInfo.refCategorySonar, oJustBuilt.UnitId) then
                    ForkThread(M28Navy.UpdateZoneIntelForSonar, oJustBuilt)

                    --Air staging - reset timer on when we last needed one
                elseif EntityCategoryContains(M28UnitInfo.refCategoryAirStaging, oJustBuilt.UnitId) then
                    M28Team.tTeamData[oJustBuilt:GetAIBrain().M28Team][M28Team.refiTimeOfLastAirStagingShortage] = 0
                end

                --Track non-M28AI wall segments
                if EntityCategoryContains(M28UnitInfo.refCategoryWall, oJustBuilt.UnitId) and not(oJustBuilt:GetAIBrain().M28AI) then
                    M28Land.TrackWallSegment(oJustBuilt, true)
                end
            elseif oJustBuilt[M28Engineer.reftUnitBlacklistSegmentXZ] then --EntityCategoryContains(categories.EXPERIMENTAL * categories.MOBILE - M28UnitInfo.refCategoryExperimentalArti, oJustBuilt.UnitId) then
                --Treat area around experimental under construction as available again
                M28Engineer.ClearBlacklistForUnitConstructed(oJustBuilt)
                M28Engineer.SearchForBuildableLocationsNearDestroyedBuilding(oJustBuilt)
            end

            M28Building.RecordUnitShieldCoverage(oJustBuilt)



            if not(oJustBuilt.M28OnConstructedCalled) then
                oJustBuilt.M28OnConstructedCalled = true

                if bDebugMessages == true then LOG(sFunctionRef..': First time calling for unit '..(oJustBuilt.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oJustBuilt) or 'nil')..' owned by '..oJustBuilt:GetAIBrain().Nickname..', was this M28 brain='..tostring(oJustBuilt:GetAIBrain().M28AI or false)..'; Built at time='..GetGameTimeSeconds()) end

                --Both M28 and Non-M28 where not already run onconstructioncalled:
                --SMD - update with more accurate estimate of time when built
                if oJustBuilt[M28UnitInfo.refiTimeOfLastCheck] and EntityCategoryContains(M28UnitInfo.refCategorySMD, oJustBuilt.UnitId) then


                    oJustBuilt[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds() - M28Building.iTimeForSMDToBeConstructed
                    if bDebugMessages == true then LOG(sFunctionRef..': Just built SMD, oJustBuilt='..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; Owner='..oJustBuilt:GetAIBrain().Nickname..'; Time='..GetGameTimeSeconds()) end
                end

                --M28 specific
                if oJustBuilt:GetAIBrain().M28AI then

                    if bDebugMessages == true then LOG(sFunctionRef..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just built '..oJustBuilt.UnitId) end
                    local aiBrain = oJustBuilt:GetAIBrain()
                    local iTeam = aiBrain.M28Team
                    --experimental level construction count, and paragon and yolona specific logic
                    if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oJustBuilt.UnitId) then
                        M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] = M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] + 1
                        local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oJustBuilt:GetPosition(), true, iTeam)
                        tLZTeamData[M28Map.refiZoneConstructedExperimentalCount] = (tLZTeamData[M28Map.refiZoneConstructedExperimentalCount] or 0) + 1
                        if EntityCategoryContains(M28UnitInfo.refCategoryParagon, oJustBuilt.UnitId) then
                            ForkThread(M28Building.JustBuiltParagon, oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySML * categories.EXPERIMENTAL, oJustBuilt.UnitId) then
                            M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] = true
                        end

                        if EntityCategoryContains(M28UnitInfo.refCategoryNovaxCentre, oJustBuilt.UnitId) then
                            ForkThread(M28Air.DelayedNovaxUnloadCheck, oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryNovaxCentre, oEngineer.UnitId) and oEngineer:GetAIBrain().M28AI then
                            ForkThread(M28Air.DelayedNovaxUnloadCheck, oEngineer)
                        end

                    end

                    --Experimental air - no longer record in land/water zone
                    if EntityCategoryContains(M28UnitInfo.refCategoryAllAir, oJustBuilt.UnitId) then
                        --Transport specific - tell the factory that just built the transport to build something else
                        if EntityCategoryContains(M28UnitInfo.refCategoryTransport, oJustBuilt.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryAirFactory * categories.TECH1, oEngineer.UnitId) then
                            oEngineer[M28Factory.refbWantNextUnitToBeEngineer] = true
                        end

                        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oJustBuilt:GetPosition())
                        if (iLandOrWaterZone or 0) > 0 then
                            local tLZOrWZData
                            local tLZOrWZTeamData
                            local sUnitTableRef

                            if iPlateauOrZero == 0 then
                                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                                sUnitTableRef = M28Map.subreftoLZOrWZAlliedUnits
                            else
                                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                                sUnitTableRef = M28Map.subreftoLZOrWZAlliedUnits
                            end
                            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[sUnitTableRef]) == false then
                                for iUnit, oUnit in tLZOrWZTeamData[sUnitTableRef] do
                                    if oUnit == oJustBuilt then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Removing unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from zone '..iLandOrWaterZone..' as it is a construction completed experimental') end
                                        table.remove(tLZOrWZTeamData[sUnitTableRef], iUnit)
                                        break
                                    end
                                end
                            end
                        end
                    end

                    --Logic based on the unit that was just built:

                    --Check build locations for units not built at a factory
                    local bDontClearEngineer = false
                    if bDebugMessages == true then LOG(sFunctionRef..': Will now consider logic for units not built at a factory, was this a structure or experimental='..tostring(EntityCategoryContains(categories.STRUCTURE + categories.EXPERIMENTAL, oJustBuilt.UnitId))) end
                    if EntityCategoryContains(categories.STRUCTURE + categories.EXPERIMENTAL, oJustBuilt.UnitId) then

                        if not(oJustBuilt[M28UnitInfo.refbConstructionStart]) then
                            M28Engineer.CheckIfBuildableLocationsNearPositionStillValid(aiBrain, oJustBuilt:GetPosition(), false, M28UnitInfo.GetBuildingSize(oJustBuilt.UnitId) * 0.5)
                        end
                        M28Economy.UpdateHighestFactoryTechLevelForBuiltUnit(oJustBuilt) --includes a check to see if are dealing with a factory HQ
                        if EntityCategoryContains(M28UnitInfo.refCategoryMex, oJustBuilt.UnitId) then
                            M28Team.tTeamData[iTeam][M28Team.refiUpgradedMexCount] = (M28Team.tTeamData[iTeam][M28Team.refiUpgradedMexCount] or 0) + 1
                            ForkThread(M28Economy.UpdateZoneM28MexByTechCount, oJustBuilt, false, 10)
                            --If have storage owned by M28 on same team by this mex, gift it over
                            --All mexes - on construction check if we have allied M28 mass storage nearby (e.g. we have rebuilt on a mex that they used to have) and if so then have that M28 gift over their mass storage
                            M28Team.GiftAdjacentStorageToMexOwner(oJustBuilt)

                            --Update part built t1 mex tracking
                            local bGiftingToTeammate = false
                            if EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oJustBuilt.UnitId) then
                                M28Engineer.UpdatePartBuiltListForCompletedMex(oJustBuilt)
                                --Check if teammate has enough factories that we should give this to them - require mex to be closer to their base and for them to have factories in the zone, and for us to have no T2+ mexes
                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false and table.getn(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) > 1 then
                                    local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oJustBuilt:GetPosition(), true, oJustBuilt:GetAIBrain().M28Team)
                                    if GetGameTimeSeconds() >= 100 and not(tLZTeamData[M28Map.subrefLZbCoreBase]) and (tLZTeamData[M28Map.refiNonM28TeammateFactoryCount] or 0) > 0 and tLZTeamData[M28Map.subrefMexCountByTech][2] == 0 and tLZTeamData[M28Map.subrefMexCountByTech][3] == 0 and tLZTeamData[M28Map.subrefMexCountByTech][1] <= 3 then
                                        local iClosestNonM28BrainDistBase = 100000
                                        local oClosestNonM28Brain
                                        local iClosestM28BrainDistBase = 100000

                                        local iCurDist
                                        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                                            if not(oBrain:IsDefeated()) then
                                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oJustBuilt:GetPosition(), M28Map.GetPlayerStartPosition(oBrain))
                                                if oBrain.M28AI then iClosestM28BrainDistBase = math.min(iClosestM28BrainDistBase, iCurDist)
                                                elseif iClosestNonM28BrainDistBase > iCurDist then
                                                    iClosestNonM28BrainDistBase = iCurDist
                                                    oClosestNonM28Brain = oBrain
                                                end
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to gift T1 mex '..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..' to a teammate, iClosestNonM28BrainDistBase='..iClosestNonM28BrainDistBase..'; iClosestM28BrainDistBase='..iClosestM28BrainDistBase) end
                                        if iClosestNonM28BrainDistBase <= 200 and iClosestNonM28BrainDistBase + 50 <= iClosestM28BrainDistBase then
                                            ForkThread(M28Team.DelayedUnitTransferToPlayer, { oJustBuilt }, oClosestNonM28Brain:GetArmyIndex(), 0.2)
                                            M28Chat.SendMessage(oJustBuilt:GetAIBrain(), 'GiveT1Mex', 'I guess this is one of your mexes '..oClosestNonM28Brain.Nickname..', try to claim it faster next time', 1, 90, true, true)
                                            bGiftingToTeammate = true
                                        end
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to apply special logic for upgrading further mex in the zone after this one, was this a T1 mex='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oJustBuilt.UnitId))..'; bGiftingToTeammate='..tostring(bGiftingToTeammate or false)) end
                            if not(bGiftingToTeammate) then
                                if EntityCategoryContains(M28UnitInfo.refCategoryMex, oJustBuilt.UnitId) then
                                    --If can upgrade then consider future upgrade
                                    local sUpgrade = oJustBuilt:GetBlueprint().General.UpgradesTo
                                    if sUpgrade and not(sUpgrade == '') then
                                        ForkThread(M28Economy.ConsiderFutureMexUpgrade, oJustBuilt)
                                        if EntityCategoryContains(categories.TECH3, oJustBuilt.UnitId) then M28Economy.bT3MexCanBeUpgraded = true end
                                    end
                                end
                                --COnsider upgrading another mex in this zone
                                ForkThread(M28Economy.ConsiderUpgradingMexDueToCompletion, oJustBuilt, oEngineer)
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMassStorage, oJustBuilt.UnitId) then
                            --If just built a mass storage but we dont own the mex it is adjacent to, then gift the storage
                            local rSearchRectangle = M28Utilities.GetRectAroundLocation(oJustBuilt:GetPosition(), 2.749)
                            local tNearbyUnits = GetUnitsInRect(rSearchRectangle) --at 1.5 end up with storage thats not adjacent being gifted in some cases but not in others; at 1 none of it gets gifted; the mass storage should be exactly 2 from the mex; however even at 2.1, 2.25 and 2.499 had cases where the mex wasnt identified so will try 2.75 since distances can vary/be snapped to the nearest 0.5 I think
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Storage gifting where built storage - oJustBuilt='..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; owner='..aiBrain.Nickname..'; is tNearbyUnits empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnits)))
                                if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                                    for iUnit, oUnit in tNearbyUnits do
                                        LOG(sFunctionRef..': iUnit '..iUnit..' in tNearbyUnits='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; owner='..oUnit:GetAIBrain().Nickname)
                                    end
                                end
                            end
                            if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                                local tNearbyMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tNearbyUnits)
                                if M28Utilities.IsTableEmpty(tNearbyMexes) == false then
                                    local bHaveMexWeOwnNearby = false
                                    local oBrainToTransferToIfWeOwnNoMexes
                                    for iUnit, oUnit in tNearbyMexes do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering nearby unit oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname) end
                                        if oUnit:GetAIBrain() == aiBrain then
                                            bHaveMexWeOwnNearby = true
                                        elseif oUnit:GetAIBrain().M28Team == iTeam then
                                            oBrainToTransferToIfWeOwnNoMexes = oUnit:GetAIBrain()
                                        end
                                    end
                                    if not(bHaveMexWeOwnNearby) and oBrainToTransferToIfWeOwnNoMexes then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and gift the storage to the player who owns the mex already there') end
                                        M28Team.TransferUnitsToPlayer({oJustBuilt}, oBrainToTransferToIfWeOwnNoMexes:GetArmyIndex(), false)
                                    end
                                end
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryEnergyStorage, oJustBuilt.UnitId) then
                            M28Team.TeamEconomyRefresh(iTeam)
                            M28Team.ConsiderGiftingStorageToTeammate(oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oJustBuilt.UnitId) then
                            --Clear the desire to build land facs by mexes - i.e. only want hte first one to be built as such
                            if bDebugMessages == true then LOG(sFunctionRef..': Have just build land factory so clearing adjacency desire for all M28 brains') end
                            M28Engineer.tiActionAdjacentCategory[M28Engineer.refActionBuildLandFactory] = nil
                            if M28UnitInfo.GetUnitLifetimeCount(oJustBuilt) == 1 and EntityCategoryContains(categories.TECH1, oJustBuilt.UnitId) and EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then
                                --Make first land factory built be a core base if it isnt already
                                local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oJustBuilt:GetPosition(), true, oJustBuilt:GetAIBrain().M28Team)
                                if bDebugMessages == true then LOG(sFunctionRef..': Just built our first land factory with our ACU, is this core base='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])) end
                                if not(tLZTeamData[M28Map.subrefLZbCoreBase]) then
                                    tLZTeamData[M28Map.subrefbCoreBaseOverride] = true
                                end
                            end

                            M28Economy.ConsiderImmediateUpgradeOfFactory(oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oJustBuilt.UnitId) then
                            M28Economy.ConsiderImmediateUpgradeOfFactory(oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, oJustBuilt.UnitId) then
                            ForkThread(M28Building.GetT3ArtiTarget, oJustBuilt)
                            ForkThread(M28Economy.JustBuiltT2PlusPowerOrExperimentalInZone, oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryPD * categories.TECH1 + M28UnitInfo.refCategoryWall, oJustBuilt.UnitId) then
                            --Build T1 walls around T1 PD
                            --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition,                                           oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
                            local sWallBP = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28Engineer.tiActionCategory[M28Engineer.refActionBuildWall], oEngineer)
                            if sWallBP then
                                local tWallBuildLocation = M28Engineer.GetLocationToBuildWall(oEngineer, oJustBuilt, sWallBP)
                                if tWallBuildLocation then
                                    --First generate list of other engineers to also help with wall building (as theyll potentially get cleared when we clear the original engineer)
                                    local tOtherEngineersHelpingConstruction = {}
                                    local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oJustBuilt:GetPosition(), true, oEngineer:GetAIBrain().M28Team)
                                    local tEngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                    if M28Utilities.IsTableEmpty(tEngineersInZone) == false then
                                        for iUnit, oUnit in tEngineersInZone do
                                            if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering other engineer in zone, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Assigned action='..(oUnit[M28Engineer.refiAssignedAction] or 'nil')) end
                                                if oUnit[M28Engineer.refiAssignedAction] == M28Engineer.refActionBuildEmergencyPD then --dont need to do for walsl as eahc engi builds individually
                                                    local oFocusUnit = oUnit:GetFocusUnit()
                                                    if bDebugMessages == true then
                                                        LOG(sFunctionRef..': oFocusUnit='..(oFocusUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oFocusUnit) or 'nil')..'; Last order='..reprs(oUnit[M28Orders.reftiLastOrders]))
                                                        if M28Utilities.IsTableEmpty(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]) == false then
                                                            LOG(sFunctionRef..': Dist of last order to just built='..M28Utilities.GetDistanceBetweenPositions(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition], oJustBuilt:GetPosition())..'; Dist of last order to engineer='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oJustBuilt:GetPosition()))
                                                        end
                                                    end

                                                    if oFocusUnit == oEngineer or oFocusUnit == oJustBuilt or (not(oFocusUnit) and M28Utilities.IsTableEmpty(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]) == false and M28Utilities.GetDistanceBetweenPositions(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition], oJustBuilt:GetPosition()) < 1 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oJustBuilt:GetPosition()) <= oUnit:GetBlueprint().Economy.MaxBuildDistance + 1) then
                                                        table.insert(tOtherEngineersHelpingConstruction, oUnit)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': have a supporting engineer that helped build the T1 PD') end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    M28Orders.IssueTrackedBuild(oEngineer, tWallBuildLocation, sWallBP, false, 'WallP')
                                    M28Engineer.TrackEngineerAction(oEngineer, M28Engineer.refActionBuildWall, true, 1)
                                    bDontClearEngineer = true
                                    if M28Utilities.IsTableEmpty(tOtherEngineersHelpingConstruction) == false then
                                        for iUnit, oUnit in tOtherEngineersHelpingConstruction do
                                            local tWallBuildLocation = M28Engineer.GetLocationToBuildWall(oUnit, oJustBuilt, sWallBP)
                                            if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; tWallBuildLocation='..repru(tWallBuildLocation)) end
                                            if tWallBuildLocation then
                                                M28Orders.IssueTrackedBuild(oUnit, tWallBuildLocation, sWallBP, false, 'WallS')
                                                M28Engineer.TrackEngineerAction(oUnit, M28Engineer.refActionBuildWall, true, 1)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will tell unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to build a wall at '..repru(tWallBuildLocation)) end
                                            end
                                        end
                                    end
                                end
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryPower * categories.TECH3, oJustBuilt.UnitId) then
                            ForkThread(M28Building.ConsiderGiftingPowerToTeammateForAdjacency, oJustBuilt)
                            ForkThread(M28Economy.JustBuiltT2PlusPowerOrExperimentalInZone, oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryPower * categories.TECH2, oJustBuilt.UnitId) then
                            ForkThread(M28Economy.JustBuiltT2PlusPowerOrExperimentalInZone, oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySMD, oJustBuilt.UnitId) then
                            --If enemy has nuke then flag we need resources for missile
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false then
                                M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] = true
                            end
                            ForkThread(M28Economy.JustBuiltT2PlusPowerOrExperimentalInZone, oJustBuilt)
                            --T2 arti - consider manual shot targets
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oJustBuilt.UnitId) then
                            ForkThread(M28Building.ConsiderManualT2ArtiTarget, oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oJustBuilt.UnitId) then
                            --Cybran ED1 shields - upgrade if enemy has novax or t3 arti
                            if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield * categories.BUILTBYTIER2ENGINEER * categories.CYBRAN, oJustBuilt.UnitId) then
                                if M28Team.tTeamData[oJustBuilt:GetAIBrain().M28Team][M28Team.refbDefendAgainstArti] then
                                    M28Economy.UpgradeUnit(oJustBuilt, true)
                                end
                            end

                            --Shield tracking
                            if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield  - categories.TECH2 - categories.TECH1, oJustBuilt.UnitId) then
                                local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oJustBuilt:GetPosition(), true, oJustBuilt:GetAIBrain().M28Team)
                                if tLZTeamData then
                                    tLZTeamData[M28Map.subrefiT3FixedShieldConstructedCount] = (tLZTeamData[M28Map.subrefiT3FixedShieldConstructedCount] or 0) + 1
                                end
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oJustBuilt.UnitId) then
                            ForkThread(M28Economy.JustBuiltT2PlusPowerOrExperimentalInZone, oJustBuilt)
                            if EntityCategoryContains(M28UnitInfo.refCategoryEnergyStorage + M28UnitInfo.refCategoryParagon + M28UnitInfo.refCategoryQuantumOptics, oJustBuilt.UnitId) then
                                M28Team.TeamEconomyRefresh(iTeam)
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryEnergyStorage + M28UnitInfo.refCategoryParagon + M28UnitInfo.refCategoryQuantumOptics, oJustBuilt.UnitId) then
                            --I.e. for energy storage units not caught by energy storage above or experimental level (paragon) - i.e. first two categories are just a redundancy
                            M28Team.TeamEconomyRefresh(iTeam)
                        end
                        if EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti - categories.MOBILE + M28UnitInfo.refCategorySML * categories.TECH3 + M28UnitInfo.refCategoryAirFactory * categories.TECH3 + M28UnitInfo.refCategoryMassFab * categories.TECH3 + M28UnitInfo.refCategoryT3Radar, oJustBuilt.UnitId) then
                        ForkThread(M28Building.ConsiderGiftingPowerToTeammateForAdjacency, oJustBuilt)
                            end
                            --Clear engineers that just built this
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryIndirect * categories.TECH1, oJustBuilt.UnitId) then
                        --Check if we have transports wanting combat drops
                        local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oJustBuilt:GetPosition(), true, oJustBuilt:GetAIBrain().M28Team)
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoTransportsWaitingForUnits]) == false then
                            for iTransport, oTransport in tLZTeamData[M28Map.reftoTransportsWaitingForUnits] do
                                if (oTransport[M28Air.refiCombatUnitsWanted] or 0) > 0 then
                                    ForkThread(M28Air.LoadCombatUnitOntoTransport, oJustBuilt)
                                    break
                                end
                            end
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryIndirectT3, oJustBuilt.UnitId) then
                        if not(M28Team.tTeamData[iTeam][M28Team.refbBuiltLotsOfT3Combat]) then
                            if M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryIndirectT3) >= 30 then
                                M28Team.tTeamData[iTeam][M28Team.refbBuiltLotsOfT3Combat] = true
                            end
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer * categories.TECH3, oJustBuilt.UnitId) then
                        --Late game - destroy lower tech engineers to help with pathing (up to 2 for every T3 engi built)
                        ForkThread(M28Engineer.ConsiderDestroyingLowTechEngineers, oJustBuilt)
                    elseif EntityCategoryContains(categories.MOBILE * categories.SUBMERSIBLE, oJustBuilt.UnitId) then
                        ForkThread(M28Navy.DelayedCheckIfShouldSubmerge, oJustBuilt)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oJustBuilt.UnitId) then
                        if not(M28Team.tLandSubteamData[oJustBuilt:GetAIBrain().M28LandSubteam][M28Team.refbConsideredScoutFactionRestrictions]) then
                            M28Team.UpdateFactionBlueprintBlacklist(oJustBuilt:GetAIBrain().M28LandSubteam)
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryBomber * categories.TECH1, oJustBuilt.UnitId) then
                        if M28UnitInfo.GetUnitLifetimeCount(oJustBuilt) == 1 then
                            oEngineer[M28Factory.refbJustBuiltFirstT1Bomber] = true
                            M28Utilities.DelayChangeVariable(oEngineer, M28Factory.refbJustBuiltFirstT1Bomber, false, 5)
                        end
                    end

                    --Update economy tracking (this function will check if it is an economic unit as part of it)
                    M28Economy.UpdateGrossIncomeForUnit(oJustBuilt)
                    if EntityCategoryContains(M28UnitInfo.refCategoryScathis, oJustBuilt.UnitId) then
                        table.insert(M28Engineer.tAllScathis, oJustBuilt)
                    end

                    if EntityCategoryContains(M28UnitInfo.refCategorySatellite, oJustBuilt.UnitId) then
                        if bDebugMessages == true then LOG(sFunctionRef..'Novax created, reprs='..reprs(oUnit)) end
                        ForkThread(M28Air.DetachSatellite,oJustBuilt, 1)
                    end


                    --Logic based on the engineer
                    if EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then
                        M28ACU.GetACUOrder(oEngineer:GetAIBrain(), oEngineer)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryQuantumGateway + M28UnitInfo.refCategoryMobileLandFactory + M28UnitInfo.refCategorySpecialFactory + M28UnitInfo.refCategoryMobileAircraftFactory + categories.EXTERNALFACTORYUNIT, oEngineer.UnitId) then
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': A factory has just built a unit so will get the next order for the factory, oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer))
                        end
                        ForkThread(M28Factory.DecideAndBuildUnitForFactory, oEngineer:GetAIBrain(), oEngineer)
                        --Treat the unit just built as having micro active so it doesn't receive orders for a couple of seconds (so it can clear the factory)
                        if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryNavalFactory + M28UnitInfo.refCategoryMobileLandFactory, oEngineer.UnitId) and EntityCategoryContains(categories.MOBILE - categories.AIR, oJustBuilt.UnitId) then
                            --Also give unit a move order (queued onto its existing order)
                            if M28Utilities.IsTableEmpty(oEngineer[M28Factory.reftFactoryRallyPoint]) then
                                M28Factory.SetFactoryRallyPoint(oEngineer)
                            end

                            M28Orders.IssueTrackedMove(oJustBuilt, oEngineer[M28Factory.reftFactoryRallyPoint], 0.1, true, 'RollOff', false)

                            M28Micro.TrackTemporaryUnitMicro(oJustBuilt, 1.5) --i.e. want to increase likelihood that a unit has exited the land factory before it starts being given orders
                            if bDebugMessages == true then LOG(sFunctionRef..': Engineer parent='..reprs(oEngineer.Parent)..'; Unit ID = or parent'..(oEngineer.Parent.UnitId or 'nil')) end
                            if oEngineer.UnitId == 'uel0401ef' or (oEngineer.Parent.UnitId and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oEngineer.Parent.UnitId)) then
                                --Want some MAA to stick by fatboy so theyre protected by its shield
                                if EntityCategoryContains(M28UnitInfo.refCategoryMAA, oJustBuilt.UnitId) then
                                    ForkThread(M28Land.ConsiderAssigningMAABodyguardToFatboy,oJustBuilt, oEngineer)
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory - categories.MOBILE, oEngineer.UnitId) then
                                --Consider assigning T2 MAA to ACU
                                if EntityCategoryContains(M28UnitInfo.refCategoryMAA * categories.TECH2, oJustBuilt.UnitId) then
                                    ForkThread(M28Land.ConsiderAssigningMAABodyguardToACU, oJustBuilt)
                                end
                            end
                        end


                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to clear refiFirstTimeOfLastOrder='..(oEngineer[M28Factory.refiFirstTimeOfLastOrder] or 'nil')..' for facotyr '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' at game time '..GetGameTimeSeconds()) end
                        if oEngineer[M28Factory.refiFirstTimeOfLastOrder] and GetGameTimeSeconds() - oEngineer[M28Factory.refiFirstTimeOfLastOrder] > 0.1 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Clearing refiFirstTimeOfLastOrder for the factory') end
                            oEngineer[M28Factory.refiFirstTimeOfLastOrder] = nil
                        end --Clear time as only want to use this to track incase have blocking unit
                        oEngineer[M28Factory.refiTotalBuildCount] = (oEngineer[M28Factory.refiTotalBuildCount] or 0) + 1
                        oEngineer:GetAIBrain()[M28Factory.refiHighestFactoryBuildCount] = math.max((oEngineer:GetAIBrain()[M28Factory.refiHighestFactoryBuildCount] or 0), (oEngineer[M28Factory.refiTotalBuildCount] or 0))
                        --If T3 support factory just built a T1 unit, then consider gifting it to a teammate
                        if EntityCategoryContains(M28UnitInfo.categories.SUPPORTFACTORY * categories.TECH3, oEngineer.UnitId) and EntityCategoryContains(categories.TECH1, oJustBuilt.UnitId) then
                            --Do we lack HQs for this brain and are dealing with an air or naval fac (since land fac should rebuild anyway)
                            if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oEngineer.UnitId) then
                                if oEngineer:GetAIBrain()[M28Economy.refiOurHighestAirFactoryTech] == 0 then
                                    ForkThread(M28Team.ConsiderGiftingSupportFactoriesToTeammateWithBetterHQ, oEngineer:GetAIBrain(), oEngineer.UnitId)
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oEngineer.UnitId) then
                                if oEngineer:GetAIBrain()[M28Economy.refiOurHighestNavalFactoryTech] == 0 then
                                    ForkThread(M28Team.ConsiderGiftingSupportFactoriesToTeammateWithBetterHQ, oEngineer:GetAIBrain(), oEngineer.UnitId)
                                end
                            end
                        end

                        --External factories that have just built an air unit - unload the air unit
                        if EntityCategoryContains(categories.EXTERNALFACTORYUNIT, oEngineer.UnitId) and EntityCategoryContains(categories.AIR - categories.EXPERIMENTAL, oJustBuilt.UnitId) and oEngineer.Parent.UnitId then
                            local oParentUnit = oEngineer.Parent
                            if bDebugMessages == true then LOG(sFunctionRef..': Just built unit state='..M28UnitInfo.GetUnitState(oJustBuilt)..'; Will try and unload from the engineer; reprs='..reprs(oEngineer)..'; oParentUnit UnitID='..(oParentUnit.UnitId or 'nil')) end
                            local tCargo = oParentUnit:GetCargo()
                            if M28Utilities.IsTableEmpty(tCargo) == false then
                                M28Orders.ReleaseStoredUnits(oParentUnit, false, 'Carrier', false)
                            end
                        end

                    elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oEngineer.UnitId) then
                        --Clear any engineers trying to build this unit if we just built a building or experimental
                        if not(bDontClearEngineer) and EntityCategoryContains(categories.STRUCTURE + categories.EXPERIMENTAL, oJustBuilt.UnitId) then
                            M28Engineer.ClearEngineersBuildingUnit(oEngineer, oJustBuilt, true)
                        end
                    end

                    --Logic based on the type of unit built
                    if EntityCategoryContains(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryQuantumGateway + M28UnitInfo.refCategoryMobileLandFactory + M28UnitInfo.refCategorySpecialFactory + M28UnitInfo.refCategoryMobileAircraftFactory + categories.EXTERNALFACTORYUNIT, oJustBuilt.UnitId) then
                        if bDebugMessages == true then LOG(sFunctionRef..': A factory has just been built so will get the next order for the factory') end
                        ForkThread(M28Factory.DecideAndBuildUnitForFactory, aiBrain, oJustBuilt)
                        if EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oJustBuilt.UnitId) then
                            aiBrain[M28Economy.refiOurHighestFactoryTechLevel] = math.max(M28UnitInfo.GetUnitTechLevel(oJustBuilt), aiBrain[M28Economy.refiOurHighestFactoryTechLevel])
                        end
                    elseif EntityCategoryContains(categories.STEALTH, oJustBuilt.UnitId) then
                        --Make sure stealth is enabled
                        M28UnitInfo.EnableUnitStealth(oJustBuilt)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryPower + M28UnitInfo.refCategoryMex, oJustBuilt.UnitId) then
                        --Consider gifting power and mexes to a teammate
                        local aiBrain = oJustBuilt:GetAIBrain()
                        if aiBrain[M28Economy.refbBuiltParagon] and aiBrain[M28Economy.refiGrossMassBaseIncome] >= math.min(1000, 900 * aiBrain[M28Economy.refiBrainResourceMultiplier]) and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >=  math.min(100000, 90000 * aiBrain[M28Economy.refiBrainResourceMultiplier]) then
                            local oParagonBrain = oJustBuilt:GetAIBrain()
                            if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 then
                                for iBrain, oBrain in  M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                    if not(oBrain == oParagonBrain) and not(oBrain.M28IsDefeated) and oBrain[M28Economy.refiGrossMassBaseIncome] < 1000 then
                                        M28Team.TransferUnitsToPlayer({ oJustBuilt }, oBrain:GetArmyIndex(), false)
                                        break
                                    end
                                end
                            end
                            --Check if we own any paused non-mexes that we own, and unpause them
                            if M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount] > 0 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority]) == false then
                                for iPriority, tUnits in M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority] do
                                    for iPaused, oPaused in tUnits do
                                        if M28UnitInfo.IsUnitValid(oPaused) and oPaused:GetAIBrain() == oParagonBrain then
                                            M28UnitInfo.PauseOrUnpauseEnergyUsage(oPaused, false, false, oParagonBrain.M28Team)
                                        end
                                    end
                                end
                            end
                        end
                    end

                    --Mobile land units - give a micro move order so they dont block the factory
                    if EntityCategoryContains(M28UnitInfo.refCategoryMobileLand, oJustBuilt.UnitId) then
                        ForkThread(M28Micro.MoveAwayFromFactory, oJustBuilt, oEngineer)
                    end

                    --Unit cap - refresh if are within 25 of the cap since it isnt accurate if have current units
                    if bDebugMessages == true then LOG(sFunctionRef..': will call function to refresh unit cap if we are close, is oJustBuilt valid='..tostring(M28UnitInfo.IsUnitValid(oJustBuilt))..'; Close to unit cap='..tostring(aiBrain[M28Overseer.refbCloseToUnitCap] or false)..'; Expected remaining cap='..(aiBrain[M28Overseer.refiExpectedRemainingCap] or 'nil')) end
                    if M28UnitInfo.IsUnitValid(oJustBuilt) and aiBrain[M28Overseer.refbCloseToUnitCap] and aiBrain[M28Overseer.refiExpectedRemainingCap] <= 25 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will check unit cap, time='..GetGameTimeSeconds()) end
                        M28Overseer.CheckUnitCap(aiBrain)
                    end

                    --air fac restriction - review if campaign in case things have changed if are dealing with the player (dont do for campaign AI though as they sometimes have different settings)
                    if M28Overseer.bAirFactoriesCantBeBuilt and M28Map.bIsCampaignMap and not(aiBrain.CampaignAI) then
                        local tACUs = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
                        if M28Utilities.IsTableEmpty(tACUs) == false then
                            local sAirFac = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryAirFactory, tACUs[1])
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Just built '..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; Time='..GetGameTimeSeconds()..'; sAirFac='..(sAirFac or 'nil'))
                                if sAirFac then LOG(sFunctionRef..': Is sAirFac restricted='..tostring(M28UnitInfo.IsUnitRestricted(sAirFac, aiBrain:GetArmyIndex()))) end
                            end
                            if sAirFac and not(M28UnitInfo.IsUnitRestricted(sAirFac, aiBrain:GetArmyIndex())) then
                                M28Overseer.bAirFactoriesCantBeBuilt = false
                            end
                        end
                    end
                else
                    --Non-M28 only units

                    --If build an M28 unit then will record its plateau and LZ; so for non-M28 AI also want to do this so we have a backup for pathfinding if dont already have something
                    if M28Utilities.IsTableEmpty(oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) and not(EntityCategoryContains(categories.AIR, oJustBuilt.UnitId)) then
                        local iPlateau, iLandZone = M28Map.GetPathingOverridePlateauAndLandZone(oJustBuilt:GetPosition(), true, oJustBuilt)
                        if not(oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) then oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] = {} end
                        oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][oJustBuilt:GetAIBrain().M28Team] = {iPlateau, iLandZone}
                        if iPlateau and not(iLandZone) then
                            --May be on water
                            local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(oJustBuilt:GetPosition())
                            local iWaterZone = M28Map.tWaterZoneBySegment[iSegmentX][iSegmentZ]
                            if iWaterZone then
                                if not(oJustBuilt[M28UnitInfo.reftAssignedWaterZoneByTeam]) then oJustBuilt[M28UnitInfo.reftAssignedWaterZoneByTeam] = {} end
                                oJustBuilt[M28UnitInfo.reftAssignedWaterZoneByTeam][oJustBuilt:GetAIBrain().M28Team] = iWaterZone
                            end
                        end
                        --[[if (iPlateau or 0) > 0 then
                            if not(oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) then oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] = {} end
                            oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][oJustBuilt:GetAIBrain().M28Team] = {iPlateau, iLandZone}
                        end--]]
                    end
                    --Tracking of under construction experimentals
                    if oJustBuilt[M28UnitInfo.refbNonM28ExpConstruction] then
                        local iTeam = oJustBuilt:GetAIBrain().M28Team
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoNonM28ConstructingExpAndT3Navy]) == false then
                            for iRecordedUnit, oRecordedUnit in M28Team.tTeamData[iTeam][M28Team.reftoNonM28ConstructingExpAndT3Navy] do
                                if oRecordedUnit == oJustBuilt then
                                    table.remove(M28Team.tTeamData[iTeam][M28Team.reftoNonM28ConstructingExpAndT3Navy], iRecordedUnit)
                                    break
                                end
                            end
                        end
                        oJustBuilt[M28UnitInfo.refbNonM28ExpConstruction] = false
                    end

                end

            else
                --M28 unit has finished construction, but we have alreayd called the main onconstruction event - have any special logic here that we want to run where this isn't the first time onconstructed has been called?
                --(note - wall building logic - engineers get cleared when the first one completes construction, so will have wall building logic as part of that, so no need to go here)
            end

            --Logic to run every time whether have called onconstruction or not
            --Upgrade tracking (even if have run this already)
            if bDebugMessages == true then LOG(sFunctionRef..': Will refresh upgrade tracking for buildings that have just built a building (i.e. upgrading buildings, was unit just built a structure='..tostring(EntityCategoryContains(categories.STRUCTURE, (oJustBuilt.UnitId or oJustBuilt:GetBlueprint().BlueprintId)))) end
            if oEngineer.GetAIBrain and EntityCategoryContains(categories.STRUCTURE, oEngineer.UnitId) and EntityCategoryContains(categories.STRUCTURE, (oJustBuilt.UnitId or oJustBuilt:GetBlueprint().BlueprintId)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Was just built owned by M28AI='..tostring(oJustBuilt:GetAIBrain().M28AI or false)) end
                if oJustBuilt:GetAIBrain().M28AI or (M28UnitInfo.IsUnitValid(oEngineer) and oEngineer:GetAIBrain().M28AI) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will update upgrade tracking of the unit that has just been built, oJustBuilt='..(oJustBuilt.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oJustBuilt) or 'nil')..'; oEngineer='..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil')) end
                    M28Team.UpdateUpgradeTrackingOfUnit(oEngineer, true)
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        end
    end
end

function OnReclaimStarted(oEngineer, oReclaim)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnReclaimStarted'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if M28UnitInfo.IsUnitValid(oReclaim) and oReclaim:GetFractionComplete() == 1 and oReclaim:GetAIBrain().M28AI and not(oEngineer:GetAIBrain().M28AI) and IsAlly(oReclaim:GetAIBrain():GetArmyIndex(), oEngineer:GetAIBrain():GetArmyIndex()) then
            M28Chat.SendUnitReclaimedMessage(oEngineer, oReclaim)
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnReclaimFinished(oEngineer, oReclaim)
    if M28Utilities.bM28AIInGame then
        --Update the segment that the reclaim is at, or the engineer if hte reclaim doesnt have one
        local sFunctionRef = 'OnReclaimFinished'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just finished reclaiming, gametime='..GetGameTimeSeconds()) end
        if oReclaim and oReclaim.CachePosition then
            --LOG('OnReclaimFinished temp log - remove once confirmed this works - about to update reclaim data near location='..repru(oReclaim.CachePosition))
            ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, oReclaim.CachePosition, 0)
        else
            --LOG('OnReclaimFinished alt temp log - couldnt find reclaim position so will use engineer position')
            ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, oEngineer:GetPosition(), 1)
        end

        --M28 specific
        if M28UnitInfo.IsUnitValid(oEngineer) and oEngineer:GetAIBrain().M28AI then
            --Was the engineer reclaiming an area? if so check if still nearby reclaim
            if bDebugMessages == true then LOG(sFunctionRef..': oEngineer[M28Engineer.refiAssignedAction]='..(oEngineer[M28Engineer.refiAssignedAction] or 'nil')..'; Is table of units reclaiming the now reclaimed wreck empty='..tostring(M28Utilities.IsTableEmpty(oReclaim[M28Engineer.reftUnitsReclaimingUs]))) end
            if oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionReclaimArea then
                --Only keep reclaiming if we dont have lots of mass
                if M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subrefiTeamAverageMassPercentStored] <= 0.7 then
                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
                    if (iLandZone or 0) > 0 then
                        local iTeam =  oEngineer:GetAIBrain().M28Team
                        local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                        local iMinReclaimValue = M28Map.iSignificantMassThreshold
                        --Do we have unclaimed mexes in this zone?
                        if tLZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] then iMinReclaimValue = iMinReclaimValue * 2 end
                        local bWantEnergy = M28Conditions.WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone)
                        if bWantEnergy and EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) and (M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subrefiTeamAverageEnergyPercentStored] >= 0.5 or oEngineer:GetAIBrain():GetEconomyStored('ENERGY') >= 2000 or oEngineer:GetAIBrain()[M28Economy.refiGrossEnergyBaseIncome] >= 50) then
                            iMinReclaimValue = 150 --only want a tree group
                        end
                        --GetEngineerToReclaimNearbyArea(oEngineer, iPriorityOverride, tLZOrWZTeamData, iPlateauOrPond, iLandOrWaterZone, bWantEnergyNotMass,                   bOnlyConsiderReclaimInRangeOfEngineer, iMinIndividualValueOverride, bIsWaterZone)
                        M28Engineer.GetEngineerToReclaimNearbyArea(oEngineer, nil,              tLZTeamData,        iPlateau,   iLandZone, M28Conditions.WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone), true, iMinReclaimValue)--(tLZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] or GetGameTimeSeconds() <= 300 or GetUnitLifetimeCount(oEngineer) <= 5 or M28UnitInfo.GetUnitTechLevel(oEngineer) >= 3), iMinReclaimValue)
                    end
                end
            elseif EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then
                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
                if (iLandZone or 0) > 0 then
                    local iTeam =  oEngineer:GetAIBrain().M28Team
                    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                    M28ACU.ConsiderNearbyReclaimForACUOrEngineer(iPlateau, iLandZone, tLZData, tLZTeamData, oEngineer, true)
                end
            elseif M28Utilities.IsTableEmpty(oReclaim[M28Engineer.reftUnitsReclaimingUs]) == false then
                local tEngineersToClear = {}
                for iEngineer, oEngineer in oReclaim[M28Engineer.reftUnitsReclaimingUs] do
                    if M28UnitInfo.IsUnitValid(oEngineer) then
                        table.insert(tEngineersToClear, oEngineer)
                    end
                end
                for iEngineer, oEngineer in tEngineersToClear do
                    M28Orders.IssueTrackedClearCommands(oEngineer)
                end
            end
        end

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnCreateWreck(tPosition, iMass, iEnergy)
    --Dont check if M28brains are in game yet as can be called at start of game before we have recorded any aiBrain
    if M28Utilities.bM28AIInGame then
        if not(M28Map.bReclaimManagerActive) then
            if GetGameTimeSeconds() >= 20 then return nil
            else
                local iWaitCount = 0
                while not(M28Map.bReclaimManagerActive) do
                    WaitTicks(1)
                    iWaitCount = iWaitCount + 1
                    if iWaitCount >= 50 and (iWaitCount >= 60 or M28Utilities.bFAFActive) then M28Utilities.ErrorHandler('Map setup not complete') break end
                end
            end
        end
        --[[if iMass >= 35 then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tPosition)
            local iReclaimSegmentX, iReclaimSegmentZ = M28Map.GetReclaimSegmentsFromLocation(tPosition)
            LOG('OnCreateWreck: Time='..GetGameTimeSeconds()..'; iMass='..iMass..'; tPosition='..repru(tPosition)..'; will record we want to update reclaim at this location, iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iReclaimSegmentX='..iReclaimSegmentX..'; iReclaimSegmentZ='..iReclaimSegmentZ)
        end--]]
        ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, tPosition, 0)
    end
end

function OnTransportLoad(oUnit, oTransport, bone)
    if M28Utilities.bM28AIInGame then
        local aiBrain = oTransport:GetAIBrain()
        if aiBrain.M28AI then
            --Reduce engis wanted (in case of delay between this being updated and engineer logic running)
            if EntityCategoryContains(M28UnitInfo.refCategoryTransport, oTransport.UnitId) then
                if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                    if oTransport[M28Air.refiEngisWanted] then
                        oTransport[M28Air.refiEngisWanted] = math.max(0, oTransport[M28Air.refiEngisWanted] - 1)
                    end
                else
                    oTransport[M28Air.refiCombatUnitsWanted] = math.max(0, (oTransport[M28Air.refiCombatUnitsWanted] or 0) - 1)
                end
                --Clear the last assigned unit
                oTransport[M28Air.refoTransportUnitTryingToLoad] = nil
                --Clear any LZTeamData tracking
                if oUnit[M28Air.reftCombatDropPlateauAndZone] then
                    local tLZData = M28Map.tAllPlateaus[oUnit[M28Air.reftCombatDropPlateauAndZone][1]][M28Map.subrefPlateauLandZones][oUnit[M28Air.reftCombatDropPlateauAndZone][2]]
                    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoCombatUnitsLoadingOntoTransport]) == false then
                        for iEntry, oEntry in tLZTeamData[M28Map.reftoCombatUnitsLoadingOntoTransport] do
                            if oEntry == oUnit then
                                table.remove(tLZTeamData[M28Map.reftoCombatUnitsLoadingOntoTransport], iEntry)
                                break
                            end
                        end
                    end
                    oUnit[M28Air.reftCombatDropPlateauAndZone] = nil
                    oUnit[M28Engineer.refiAssignedAction] = nil
                end
            end

        end
    end
end

function OnTransportUnload(oUnit, oTransport, bone)
    if M28Utilities.bM28AIInGame then
        if M28UnitInfo.IsUnitValid(oTransport) and oTransport:GetAIBrain().M28AI then
            oTransport[M28Air.refiTransportTimeSpentWaiting] = 0
            if oTransport[M28Air.refiTargetIslandForDrop] then
                oUnit[M28Air.refiLastIslandDrop] = oTransport[M28Air.refiTargetIslandForDrop]
                oUnit[M28Air.refiTimeLastDropped] = GetGameTimeSeconds()
            end
        end
        if M28UnitInfo.IsUnitValid(oUnit) and oUnit[M28Engineer.refiAssignedAction] == M28Engineer.refActionLoadOntoTransport then oUnit[M28Engineer.refiAssignedAction] = nil end
    end
end

function OnDetectedBy(oUnitDetected, iBrainIndex)
    --Appears to be called when iBrainIndex detects oUnitDetected, triggers for teammate units but not own units?
    --For now used to make sure we have up to date unit info

    if M28Utilities.bM28AIInGame then
        if not(EntityCategoryContains(categories.INSIGNIFICANTUNIT, oUnitDetected.UnitId)) then --redundancy, doesnt look like ubnits like cybran build drones cause this to happen
            local aiBrain = ArmyBrains[iBrainIndex]
            M28Team.ConsiderAssigningUnitToZoneForBrain(aiBrain, oUnitDetected) --This function includes check of whether this is an M28 brain, and updates last known position
            if aiBrain.M28AI then
                if aiBrain.M28Team and not(oUnitDetected[M28UnitInfo.refbHaveSeenUnitByTeam][aiBrain.M28Team]) then
                    if not(oUnitDetected[M28UnitInfo.refbHaveSeenUnitByTeam]) then oUnitDetected[M28UnitInfo.refbHaveSeenUnitByTeam] = {} end
                    oUnitDetected[M28UnitInfo.refbHaveSeenUnitByTeam][aiBrain.M28Team] = true
                    if oUnitDetected[M28Air.refiTimeLastWantedPriorityAirScout] and EntityCategoryContains(M28UnitInfo.refCategoryTMD, oUnitDetected.UnitId) then
                        oUnitDetected[M28Air.refiTimeLastWantedPriorityAirScout] = nil --not ideal for multi-team game but hopefully in most cases will be ok and is for niche scenairo anyway - i.e. if MMLs come across TMD with no intel they flag as a priority scout target; then when the unit is detected it gets cleared
                    end
                end
                --Update highest enemy ground unti health
                if M28Map.bFirstM28TeamHasBeenInitialised and M28UnitInfo.IsUnitValid(oUnitDetected) and EntityCategoryContains(M28UnitInfo.refCategoryLandCombat - categories.COMMAND - categories.SUBCOMMANDER - M28UnitInfo.refCategoryLandScout, oUnitDetected.UnitId) then
                    local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnitDetected)
                    local iMaxHealth = oUnitDetected:GetMaxHealth() + iMaxShield
                    if iMaxHealth > (M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyHighestMobileLandHealth] or 0) and M28Map.bMapLandSetupComplete then
                        M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyHighestMobileLandHealth] = iMaxHealth
                    end
                end
            end
        end
    end
end

function OnCreate(oUnit, bIgnoreMapSetup)
    --LOG('OnCreate pre M28InGamecheck, M28Utilities.bM28AIInGame='..tostring(M28Utilities.bM28AIInGame))
    if M28Utilities.bM28AIInGame then
        if not(oUnit.UnitId) then --LOUD compatibility
            if not(M28Utilities.bFAFActive) then
                if not(oUnit.EntityId) then oUnit.EntityId = oUnit:GetEntityId() end
                oUnit.UnitId = oUnit:GetBlueprint().BlueprintId
            end
        end
        if M28UnitInfo.IsUnitValid(oUnit) and not(EntityCategoryContains(categories.INSIGNIFICANTUNIT, oUnit.UnitId)) then --redundancy, doesnt look like units like cybran build drones cause this to happen

            local sFunctionRef = 'OnCreate'
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



            if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time'..GetGameTimeSeconds()..'; oUnit[M28OnCrRn]='..tostring(oUnit['M28OnCrRn'] or false)..'; M28Map.bMapLandSetupComplete='..tostring(M28Map.bMapLandSetupComplete or false)..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; M28Map.bWaterZoneInitialCreation='..tostring(M28Map.bWaterZoneInitialCreation)..'; Unit brain='..oUnit:GetAIBrain().Nickname..'; Is civliain brain='..tostring(M28Conditions.IsCivilianBrain(oUnit:GetAIBrain()))..'; Unit fraction complete='..oUnit:GetFractionComplete()..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; UnitID='..(oUnit.UnitId or 'nil')) end
            if (not(M28Map.bMapLandSetupComplete) or not(M28Map.bWaterZoneInitialCreation)) and not(bIgnoreMapSetup) then --Start of game ACU creation happens before we have setup the map
                while not(M28Map.bMapLandSetupComplete) or not(M28Map.bWaterZoneInitialCreation) do
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(1)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    if GetGameTimeSeconds() >= 5 and M28Map.bMapLandSetupComplete and (GetGameTimeSeconds() >= 6 or M28Utilities.bFAFActive) then
                        M28Utilities.ErrorHandler('Water zone initial creation still not done, will stop waiting now')
                        break
                    end
                end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if M28UnitInfo.IsUnitValid(oUnit) then OnCreate(oUnit, true) end
            else
                if not(oUnit['M28OnCrRn']) then
                    oUnit['M28OnCrRn'] = true
                    oUnit[M28UnitInfo.refiTimeCreated] = math.floor(GetGameTimeSeconds())
                    M28Overseer.refiRoughTotalUnitsInGame = M28Overseer.refiRoughTotalUnitsInGame + 1
                    M28UnitInfo.GetUnitLifetimeCount(oUnit) --essential so lifetimecount logic works

                    --All units (not just M28 specific):
                    M28UnitInfo.RecordUnitRange(oUnit)

                    M28Team.ConsiderAssigningUnitToZoneForBrain(oUnit:GetAIBrain(), oUnit) --This function includes check of whether this is an M28 brain
                    if M28Map.bIsCampaignMap then
                        local tiTeamsConsidered = {[(oUnit:GetAIBrain().M28Team or 0)] = true}
                        for iBrain, oBrain in ArmyBrains do
                            if oBrain.M28AI and not(tiTeamsConsidered[oBrain.M28Team]) then
                                tiTeamsConsidered[oBrain.M28Team] = true
                                M28Team.ConsiderAssigningUnitToZoneForBrain(oBrain, oUnit)
                            end
                        end
                    end


                    if bDebugMessages == true then LOG(sFunctionRef..': First time M28OnCreate has run, just recorded unit ranges for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Unit fraction complete='..oUnit:GetFractionComplete()) end
                    if M28Config.M28ShowEnemyUnitNames then
                        local sWZOrLZRef = ''
                        if EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                            local iWaterZone
                            if (iLandZone or 0) == 0 then
                                iWaterZone = M28Map.GetWaterZoneFromPosition(oUnit:GetPosition())
                                if (iWaterZone or 0) > 0 then
                                    sWZOrLZRef = 'P0WZ'..iWaterZone
                                end
                            else
                                sWZOrLZRef = 'P'..(iPlateau or 'x')..'LZ'..iLandZone
                            end
                        end
                        if M28Config.M28ShowUnitNames then oUnit:SetCustomName(oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..sWZOrLZRef) end
                    end

                    --Units with upgrade - update the base threat value
                    if EntityCategoryContains(categories.SUBCOMMANDER, oUnit.UnitId) or (oUnit.HasEnhancement and EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and (oUnit:HasEnhancement('ResourceAllocation') or oUnit:HasEnhancement('ResourceAllocationAdvanced'))) then
                        M28UnitInfo.UpdateUnitCombatMassRatingForUpgrades(oUnit) --Will check if unit has enhancements as part of this
                        if oUnit:GetAIBrain().CheatEnabled then ForkThread(M28UnitInfo.FixUnitResourceCheatModifiers, oUnit) end
                    elseif M28Utilities.bLoudModActive and oUnit:GetAIBrain().CheatEnabled then
                        ForkThread(M28UnitInfo.FixUnitResourceCheatModifiers, oUnit)
                    end

                    --Hydro resource locations
                    if EntityCategoryContains(M28UnitInfo.refCategoryHydro, oUnit.UnitId) then
                        --Treat location as no longer having no buildings on it
                        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations]) == false then
                            --LOG('About to loop through hydro locations; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; reprs='..reprs(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations]))
                            for iHydroLocation, tHydroLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations] do
                                if M28Utilities.GetDistanceBetweenPositions(tHydroLocation, oUnit:GetPosition()) <= 2 then
                                    table.remove(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations], iHydroLocation)
                                    break
                                end
                            end
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                        --Treat location as having buildings on it (if we were treating it as unbuilt previously)
                        ForkThread(M28Building.OnMexConstructionStarted, oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                        M28Building.RecordUnitsInRangeOfTMLAndAnyTMDProtection(oUnit, nil)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryTMD, oUnit.UnitId) then
                        M28Building.TMDJustBuilt(oUnit)
                    end
                    if EntityCategoryContains(M28UnitInfo.refCategoryProtectFromTML, oUnit.UnitId) then
                        M28Building.RecordTMLAndTMDForUnitJustBuilt(oUnit)
                    end

                    --M28 team specific for constructed units - e.g. radar and sonar that are constructed
                    if (M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.subrefiActiveM28BrainCount] or 0) > 0 and oUnit:GetFractionComplete() == 1 then
                        local iTeam = oUnit:GetAIBrain().M28Team
                        if EntityCategoryContains(M28UnitInfo.refCategoryRadar, oUnit.UnitId) then
                            M28Land.UpdateZoneIntelForRadar(oUnit)
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySonar, oUnit.UnitId) then
                            M28Navy.UpdateZoneIntelForSonar(oUnit)
                        end
                    end

                    --Constructed units (general, i.e. all AI not just M28)
                    if oUnit:GetFractionComplete() == 1 then
                        M28Building.RecordUnitShieldCoverage(oUnit)
                        if EntityCategoryContains(M28UnitInfo.refCategorySMD, oUnit.UnitId) then
                            --Cover off scenario where loaded SMD is xferred between players, since M28 will think an SMD has died and a new one created, i.e. want to avoid abuse of M28s logic by making it think they have no SMD coverage (when it knows htey do)
                            if oUnit.GetTacticalSiloAmmoCount and oUnit:GetTacticalSiloAmmoCount() > 1 or oUnit:GetWorkProgress() >= 0.8 then
                                oUnit[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds() - 240 - M28Building.iTimeForSMDToBeConstructed
                            end
                        end
                    end



                    --M28 specific:
                    if oUnit:GetAIBrain().M28AI then
                        --Set Easy flag
                        if oUnit:GetAIBrain().M28Easy then oUnit[M28UnitInfo.refbEasyBrain] = true end

                        --Check for upgrading unit transferred to us
                        if oUnit.IsUpgrade then
                            local aiBrain = oUnit:GetAIBrain()
                            if bDebugMessages == true then LOG(sFunctionRef..': Upgrading hidden unit detected, Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; aiBrain='..aiBrain.Nickname..'; Is table of mexes and factories empty='..tostring(M28Utilities.IsTableEmpty(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount]))) end
                            if M28Utilities.IsTableEmpty(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount]) == false then
                                local iClosestUnitRef
                                local iClosestUnitTransferCount
                                local iClosestDist = 2
                                local iCurDist


                                for iTransferCount, tUnitTable in aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount] do
                                    if M28Utilities.IsTableEmpty(tUnitTable) == false then
                                        for iCompletedUnit, oCompletedUnit in tUnitTable do
                                            if M28UnitInfo.IsUnitValid(oCompletedUnit) then
                                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oCompletedUnit:GetPosition(), oUnit:GetPosition())
                                                if iCurDist < iClosestDist then
                                                    iClosestDist = iCurDist
                                                    iClosestUnitRef = iCompletedUnit
                                                    iClosestUnitTransferCount = iTransferCount
                                                end
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished searching completed units near to unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..', iClosestUnitRef='..(iClosestUnitRef or 'nil')..'; iClosestDist='..iClosestDist) end
                                    if iClosestUnitRef then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will track completed unit '..aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iClosestUnitTransferCount][iClosestUnitRef].UnitId..M28UnitInfo.GetUnitLifetimeCount(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iClosestUnitTransferCount][iClosestUnitRef])..' as an upgrading unit, given unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is upgrading and nearby') end
                                        M28Team.UpdateUpgradeTrackingOfUnit(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iClosestUnitTransferCount][iClosestUnitRef], false, oUnit.UnitId)
                                        table.remove(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iClosestUnitTransferCount], iClosestUnitRef)
                                    end
                                end
                            end
                        end

                        --Cover units transferred to us or cheated in or presumably that we have captured - will leave outside the OnCreate flag above in case the oncreate variable transfers over when a unit is captured/gifted
                        --First handle units that are important enough we have logic for while they are part-constructed
                        if oUnit:GetFractionComplete() >= 0.1 and not(oUnit[M28UnitInfo.refbConstructionStart]) and EntityCategoryContains(M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryNovaxCentre + M28UnitInfo.refCategoryFixedShield, oUnit.UnitId) then
                            --Gameender/t3 arti and fixed shields and SMD - consider shielding/game ender template usage
                            if not(oUnit[M28UnitInfo.refbConstructionStart]) and EntityCategoryContains(M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryNovaxCentre + M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategorySMD - categories.FACTORY - categories.EXTERNALFACTORYUNIT, oUnit.UnitId) then
                                --Work out if we are already in a special game ender template area
                                if not(oUnit[M28Building.reftArtiTemplateRefs]) then
                                    local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, oUnit:GetAIBrain().M28Team)
                                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates]) == false then
                                        local bLikelyInTemplatePosition = false
                                        local bArti = EntityCategoryContains(M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryNovaxCentre, oUnit.UnitId)
                                        for iTemplate, tSubtable in tLZTeamData[M28Map.reftActiveGameEnderTemplates] do
                                            if bArti then
                                                if M28Utilities.IsTableEmpty(tSubtable[M28Map.subrefGEArtiLocations]) == false then
                                                    for iArtiLoc, tArtiLoc in tSubtable[M28Map.subrefGEArtiLocations] do
                                                        if M28Utilities.GetDistanceBetweenPositions(tArtiLoc, oUnit:GetPosition()) < 2.5 then
                                                            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                                                            oUnit[M28Building.reftArtiTemplateRefs] = {iPlateau, iLandZone, iTemplate}
                                                            --Check not already in the table
                                                            local bAlreadyRecorded = false
                                                            if M28Utilities.IsTableEmpty(tSubtable[M28Map.subrefGEArtiUnits]) == false then
                                                                for iRecordedArti, oRecordedArti in tSubtable[M28Map.subrefGEArtiUnits] do
                                                                    if oRecordedArti == oUnit then
                                                                        bAlreadyRecorded = true
                                                                        break
                                                                    end
                                                                end
                                                            end
                                                            if not(bAlreadyRecorded) then
                                                                table.insert(tSubtable[M28Map.subrefGEArtiUnits], oUnit)
                                                            end
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Added arti unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to template ref='..iTemplate..'; in iLandZone='..iLandZone..'; bAlreadyRecorded='..tostring(bAlreadyRecorded)) end
                                                        end
                                                    end
                                                end
                                            elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oUnit.UnitId) then --dealing with fixed shield
                                                if M28Utilities.IsTableEmpty(tSubtable[M28Map.subrefGEShieldLocations]) == false then
                                                    for iShieldLoc, tShieldLoc in tSubtable[M28Map.subrefGEShieldLocations] do
                                                        if M28Utilities.GetDistanceBetweenPositions(tShieldLoc, oUnit:GetPosition()) < 1 then
                                                            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                                                            oUnit[M28Building.reftArtiTemplateRefs] = {iPlateau, iLandZone, iTemplate}
                                                            --Check not already in the table (redundancy)
                                                            local bAlreadyRecorded = false
                                                            if M28Utilities.IsTableEmpty(tSubtable[M28Map.subrefGEShieldUnits]) == false then
                                                                for iRecordedShield, oRecordedShield in tSubtable[M28Map.subrefGEShieldUnits] do
                                                                    if oRecordedShield == oUnit then
                                                                        bAlreadyRecorded = true
                                                                        break
                                                                    end
                                                                end
                                                            end
                                                            if not(bAlreadyRecorded) then
                                                                table.insert(tSubtable[M28Map.subrefGEShieldUnits], oUnit)
                                                            else
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Wont add shield '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' against GE template as it was already recorded') end
                                                            end
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Added shiled unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to template ref='..iTemplate..'; in iLandZone='..iLandZone..' unless already recorded, bAlreadyRecorded='..tostring(bAlreadyRecorded)) end
                                                        end
                                                    end
                                                end
                                            elseif EntityCategoryContains(M28UnitInfo.refCategorySMD, oUnit.UnitId) then
                                                if M28Utilities.IsTableEmpty(tSubtable[M28Map.subrefGESMDLocation]) == false and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(),tSubtable[M28Map.subrefGESMDLocation]) < 1 then
                                                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                                                    oUnit[M28Building.reftArtiTemplateRefs] = {iPlateau, iLandZone, iTemplate}
                                                    tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplate][M28Map.subrefGESMDUnit] = oUnit
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Recorded SMD as being in arti template location, SMD Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTemplate='..iTemplate..'; Time='..GetGameTimeSeconds()) end
                                                end
                                            else M28Utilities.ErrorHandler('Unrecognised category when checking if constructed unit is in arti template area', true)
                                            end
                                        end
                                    end
                                    --Special shielding and air defence logic
                                    if not(oUnit[M28Building.reftArtiTemplateRefs]) and EntityCategoryContains(M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti, oUnit.UnitId) then
                                        M28Building.ReserveLocationsForGameEnder(oUnit)
                                        M28Air.AddPriorityAirDefenceTarget(oUnit)
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering special logic for units created via cheat or transfer, fraction complete='..oUnit:GetFractionComplete()) end
                        if oUnit:GetFractionComplete() == 1 then
                            if EntityCategoryContains(M28UnitInfo.refCategorySML + M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                                --put here as extra redundancy since the 'unpause unit on transfer' code which has something similar didnt fix an issue with a loaded yolona being transferred not then firing
                                --LOG('Forked consideration of launching missile Delay5')
                                ForkThread(M28Building.DelayedConsiderLaunchingMissile, oUnit, 15, true)
                            end


                            M28Economy.UpdateHighestFactoryTechLevelForBuiltUnit(oUnit) --this includes a check to see if are dealing with a factory HQ
                            M28Economy.UpdateGrossIncomeForUnit(oUnit, false) --This both includes a check of the unit type, and cehcks we havent already recorded
                            if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) and not(oUnit.M28OnConstructedCalled) then
                                if bDebugMessages == true then LOG(sFunctionRef..': we have just built a mex so will call logic relating to that') end
                                ForkThread(M28Economy.UpdateZoneM28MexByTechCount, oUnit) --we run the same logic via onconstructed
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryParagon, oUnit.UnitId) and not(oUnit.M28OnConstructedCalled) then
                                if bDebugMessages == true then LOG(sFunctionRef..': We have just built a paragon, will call special paragon logic') end
                                ForkThread(M28Building.JustBuiltParagon, oUnit)
                                --Campaign specific - expand core zones for campaign AI
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryLandHQ + M28UnitInfo.refCategoryAirHQ + categories.COMMAND, oUnit.UnitId) and M28Map.bIsCampaignMap and oUnit:GetAIBrain().CampaignAI then
                                local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, oUnit:GetAIBrain().M28Team)
                                tLZTeamData[M28Map.subrefbCoreBaseOverride] = true
                                if bDebugMessages == true then
                                    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                                    LOG(sFunctionRef..': Will set core baes override to true for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' for brain '..oUnit:GetAIBrain().Nickname..' team, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone)
                                end
                                if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and oUnit:GetAIBrain().CampaignAI and (not(M28UnitInfo.IsUnitValid(oUnit:GetAIBrain()[M28ACU.refoPrimaryACU])) or not(EntityCategoryContains(categories.COMMAND, oUnit:GetAIBrain()[M28ACU.refoPrimaryACU]))) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will run ACU thread for this unit') end
                                    ForkThread(M28ACU.ManageACU, oUnit:GetAIBrain(), oUnit)
                                end
                            end

                            --Nuke launcher - if have 5+ non-experimental then consider unpausing all existing ones
                            if EntityCategoryContains(M28UnitInfo.refCategorySML, oUnit.UnitId) then
                                ForkThread(M28Overseer.ConsiderUnpausingAllCreatedNukes, oUnit:GetAIBrain().M28Team)
                            end
                            --Consider unpausing this unit regardless of whether it's an SML
                            ForkThread(M28Overseer.DelayedUnpauseOfUnits, {oUnit}, 1)
                            if EntityCategoryContains(M28UnitInfo.refCategorySatellite, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..'Novax created, reprs='..reprs(oUnit)) end
                                ForkThread(M28Air.DetachSatellite,oUnit, 1)
                            end
                        end
                        --General logic that want to make sure runs on M28 units even if theyre not constructed yet or to ensure we cover scenarios where we are gifted units
                        local aiBrain = oUnit:GetAIBrain()
                        if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel - M28UnitInfo.refCategorySatellite, oUnit.UnitId) then
                            M28Air.AddPriorityAirDefenceTarget(oUnit)
                            if EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId) then
                                M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityFatboy, true)
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryMegalith, oUnit.UnitId) then
                                M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityMegalith, true)
                            end
                            --WEAPON PRIORITIES
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryGunship, oUnit.UnitId) then
                            M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityGunship, true)
                            oUnit[M28UnitInfo.refbUsingDefaultWeaponPriority] = true
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryDestroyer, oUnit.UnitId) then
                            M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityDestroyer, true)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMissileShip + M28UnitInfo.refCategoryCruiser, oUnit.UnitId) then
                            M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityMissileShip, true)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryBattleship, oUnit.UnitId) then
                            M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityBattleShip, true)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) then
                            M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityT2Arti, true)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryQuantumOptics, oUnit.UnitId) then
                            local iTeam = aiBrain.M28Team
                            local bAlreadyRecorded = false
                            if not(M28Team.tTeamData[iTeam][M28Team.reftoAlliedQuantumOptics]) then M28Team.tTeamData[iTeam][M28Team.reftoAlliedQuantumOptics] = {}
                            else
                                for iRecorded, oRecorded in M28Team.tTeamData[iTeam][M28Team.reftoAlliedQuantumOptics] do
                                    if oRecorded == oUnit then
                                        bAlreadyRecorded = true
                                        break
                                    end
                                end
                            end
                            if not(bAlreadyRecorded) then
                                table.insert(M28Team.tTeamData[iTeam][M28Team.reftoAlliedQuantumOptics], oUnit)
                                ForkThread(M28Building.QuantumOpticsManager, aiBrain, oUnit)
                            end
                        end


                        --Non-weapon priority logic
                        if bDebugMessages == true then LOG(sFunctionRef..': Is this an external factory='..tostring(EntityCategoryContains(categories.EXTERNALFACTORYUNIT, oUnit.UnitId))..'; Is this an aircraft factory='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryMobileAircraftFactory, oUnit.UnitId))) end
                        if EntityCategoryContains(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryQuantumGateway + M28UnitInfo.refCategoryMobileLandFactory + M28UnitInfo.refCategorySpecialFactory + M28UnitInfo.refCategoryMobileAircraftFactory + categories.EXTERNALFACTORYUNIT, oUnit.UnitId) then
                            --If have been gifted factory or created via cheat then want to start building something
                            oUnit[M28Factory.refiTotalBuildCount] = 0
                            if oUnit:GetFractionComplete() >= 1 then
                                ForkThread(M28Factory.DecideAndBuildUnitForFactory, oUnit:GetAIBrain(), oUnit)
                            end
                        end
                        --Check unit cap
                        if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have too many units, expected remaining cap='..(aiBrain[M28Overseer.refiExpectedRemainingCap] or 0)) end
                        if (aiBrain[M28Overseer.refiExpectedRemainingCap] or 0) <= 100 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will check the unit cap') end
                            M28Overseer.CheckUnitCap(aiBrain)
                        else
                            aiBrain[M28Overseer.refiExpectedRemainingCap] = aiBrain[M28Overseer.refiExpectedRemainingCap] - 1
                        end
                    end
                end
            end
        end
    end
end

function OnCreateBrain(aiBrain, planName, bIsHuman)
    local sFunctionRef = 'OnCreateBrain'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.bSteamActive then import('/mods/M28AI/lua/AI/Steam/SteamCompatibility.lua').OtherSteamCompatibilityInformation() end
    if bDebugMessages == true then LOG(sFunctionRef..': aiBrain has just been created at time '..GetGameTimeSeconds()..'; Brain nickname='..(aiBrain.Nickname or 'nil')..'; Has setup been run='..tostring(aiBrain['M28BrainSetupRun'] or false)..'; Brain type='..(aiBrain.BrainType or 'nil')..'; M28Team (if brain setup)='..(aiBrain.M28Team or 'nil')..'; aiBrain.Civilian='..tostring(aiBrain.Civilian or false)..'; .M28AI='..tostring(aiBrain.M28AI or false)..'; .M27AI='..tostring(aiBrain.M27AI or false)..'; M28Overseer.iTimeOfLatestBrainToCheckForM28Logic='..(M28Overseer.iTimeOfLatestBrainToCheckForM28Logic or 'nil')) end
    if M28Overseer.iTimeOfLatestBrainToCheckForM28Logic >= 0 then
        while GetGameTimeSeconds() < M28Overseer.iTimeOfLatestBrainToCheckForM28Logic + 1 do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting for M28Overseer.iTimeOfLatestBrainToCheckForM28Logic (if applicable), Brain='..(aiBrain.Nickname or 'nil')..'; .M28AI='..tostring(aiBrain.M28AI or false)) end
    if not(aiBrain['M28BrainSetupRun']) then
        if M28Config.M28RunProfiling then ForkThread(M28Profiler.ProfilerActualTimePerTick) end
        if bIsHuman == nil then
            if aiBrain.BrainType == "AI" or not(aiBrain.BrainType) or string.find(aiBrain.BrainType, "AI") then bIsHuman = false else bIsHuman = true end
        end
        if not(bIsHuman) and (ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28ai' or ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28aicheat' or ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28aie' or ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28aiecheat') then
            aiBrain.M28AI = true
            M28Utilities.bM28AIInGame = true
            --LOG('M28 in game 1')
        end

        aiBrain['M28BrainSetupRun'] = true
        if not(M28Utilities.bM28AIInGame) then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        if M28Utilities.bM28AIInGame then

            while (not(M28Overseer.bBeginSessionTriggered) and GetGameTimeSeconds() < 4) do
                if bDebugMessages == true then LOG(sFunctionRef..': bBeginSessionTriggered not true yet, GameTime='..GetGameTimeSeconds()..'; will wait 1 tick; aiBrain='..aiBrain.Nickname) end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
            --Make sure we have checked if this is a scenario map (run for each AI to be safe since minimal load and ensures this happens ahead of any other M28 code)
            M28Overseer.CheckIfScenarioMap()
            if bDebugMessages == true then LOG(sFunctionRef..': M28Map.bIsCampaignMap='..tostring(M28Map.bIsCampaignMap or false)) end

            --Logic to run for all brains
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            M28Map.RecordBrainStartPoint(aiBrain)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

            if bIsHuman then
                LOG('Human player brain '..aiBrain.Nickname..' created; Index='..aiBrain:GetArmyIndex()..'; start position='..repru(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()]))
            else
                --Logic to run just for M28AI
                if aiBrain.M28AI then
                    --Redundancy - if have M27 brain then change this back to false
                    if aiBrain.M27AI then aiBrain.M28AI = false end
                    if bDebugMessages == true then LOG(sFunctionRef..': M28 brain created, aiBrain.Nickname='..(aiBrain.Nickname or 'nil')) end

                    --Copy of parts of aiBrain OnCreateAI that still want to retain
                    if planName and (not(M28Utilities.bLoudModActive) or aiBrain.CreateBrainShared) then
                        aiBrain:CreateBrainShared(planName)
                    end
                    --aiBrain:InitializeEconomyState()
                    aiBrain.BrainType = 'AI'
                    local per = ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality
                    local cheatPos = string.find(per, 'cheat')
                    if cheatPos then
                        if not(M28Utilities.bLoudModActive) then
                            local AIUtils = import('/lua/ai/aiutilities.lua')
                            AIUtils.SetupCheat(aiBrain, true)
                            ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality = string.sub(per, 1, cheatPos - 1)
                        end
                    end

                    --M28AIBrainClass.OnCreateAI(aiBrain, planName)
                    ForkThread(M28Overseer.M28BrainCreated, aiBrain)
                else
                    LOG('OnCreateBrain hook for Non-M28 ai with personality '..(ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality or 'nil'))
                    --Reundancy - check M27 isn't being treated as M28AI
                    ForkThread(M28Overseer.DelayedM27M28BrainCheck, aiBrain)
                end
            end
        end
    elseif aiBrain.M28AI and aiBrain.M27AI then
        aiBrain.M28AI = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function OnMissileImpactTerrain(self, target, position)
    if M28Utilities.bM28AIInGame then
        --LOG('Missile impact terrain at time '..GetGameTimeSeconds()..'; self='..reprs(self))
        --Was this an M28 unit?
        if M28UnitInfo.IsUnitValid(self) and self:GetAIBrain().M28AI then
            local sFunctionRef = 'OnMissileImpactTerrain'
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

            local tLastOrder = self[M28Orders.reftiLastOrders][self[M28Orders.refiOrderCount]]
            if bDebugMessages == true then LOG(sFunctionRef..': self='..(self.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(self) or 'nil')..'; target='..reprs(target)..'; position='..repru(position)..'; tLastOrder='..reprs(tLastOrder)..'; self[M28Building.refiLastTMLMassKills]='..(self[M28Building.refiLastTMLMassKills] or 'nil')..'; Acual XP='..(self.VetExperience or self.Sync.totalMassKilled or 0)) end
            if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueTMLMissile or M28Utilities.IsTableEmpty(target) == false then
                --Did we not gain any mass kills (e.g. mightve hit the ground deliberately for aoe)
                if (self[M28Building.refiLastTMLMassKills] or 0) == (self.VetExperience or self.Sync.totalMassKilled or 0) then
                    if not(self[M28Building.reftTerrainBlockedTargets]) then self[M28Building.reftTerrainBlockedTargets] = {} end
                    local tLastTarget = tLastOrder[M28Orders.subreftOrderPosition]

                    if M28Utilities.IsTableEmpty(tLastTarget) == false then table.insert(self[M28Building.reftTerrainBlockedTargets], {tLastTarget[1], tLastTarget[2], tLastTarget[3]}) end
                    if M28Utilities.IsTableEmpty(tLastTarget) or M28Utilities.GetDistanceBetweenPositions(tLastTarget, target) >= 1 then table.insert(self[M28Building.reftTerrainBlockedTargets], {target[1], target[2], target[3]}) end
                    if bDebugMessages == true then LOG(sFunctionRef..': Added locations to blackist, repru of blacklist='..repru(self[M28Building.reftTerrainBlockedTargets])) end
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        end
    end
end

function OnMissileImpact(self, targetType, targetEntity)
    if M28Utilities.bM28AIInGame then
        --LOG('Missile impact at time '..GetGameTimeSeconds()..'; self='..reprs(self))
        local launcher = self.Launcher
        --M28 Specific launcher
        if launcher and M28UnitInfo.IsUnitValid(launcher) and launcher:GetAIBrain().M28AI then
            --Nukes
            if EntityCategoryContains(M28UnitInfo.refCategorySML, launcher.UnitId) then
                M28Building.UpdateForNukeMissileDeath(launcher, self:GetPosition())
            end
        end
    end
end

function OnMapResizeFORSEARCHONLY()  end --So can find onplayableareachange easier
function OnPlayableAreaChange(rect, voFlag)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnPlayableAreaChange'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Playable area change detected, rect='..repru(rect)..'; voFlag='..reprs(voFlag)..'; Time='..GetGameTimeSeconds()) end
        local ScenarioUtils = import("/lua/sim/scenarioutilities.lua")
        if type(rect) == 'string' then
            rect = ScenarioUtils.AreaToRect(rect)
        end
        if M28Utilities.bM28AIInGame or GetGameTimeSeconds() <= 5 then M28Map.SetupPlayableAreaAndSegmentSizes(rect) end
        ForkThread(M28Overseer.UpdateMaxUnitCapForRelevantBrains)
        ForkThread(M28Engineer.CheckForSpecialCampaignCaptureTargets)
        --Wait 5s then consider campaign special objectives
        ForkThread(M28Overseer.ConsiderSpecialCampaignObjectives, nil, nil, nil, nil, nil, nil, nil, nil,  5)
        --Update location of nearest friendly base (intended to help if we are applying M28AI to hostile AI)
        ForkThread(M28Map.RefreshCampaignStartPositionsAfterDelay, 5)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function CaptureTriggerAdded(FunctionForOldUnit, FunctionForNewUnit, oUnit)
    --Intended for campaign maps where a capture objective gets captured by the enemy, e.g. black sun control centre
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'CaptureTriggerAdded'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if M28Utilities.bM28AIInGame and M28Map.bIsCampaignMap then
            oUnit[M28UnitInfo.refbCampaignTriggerAdded] = true
            if not(EntityCategoryContains(categories.MOBILE, oUnit.UnitId)) then

                if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                if M28UnitInfo.IsUnitValid(oUnit) then
                    local aiBrain
                    if M28Utilities.IsTableEmpty(M28Overseer.tAllActiveM28Brains) == false then
                        for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                            aiBrain = oBrain
                            if not(oBrain.CampaignAI) then break end
                        end
                        if not(IsAlly(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex())) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Unit is not an ally so will record as a capture target') end
                            M28Engineer.RecordUnitAsCaptureTarget(oUnit)
                        end
                    end
                end
            end
            oUnit[M28UnitInfo.refbCampaignTriggerAdded] = true
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function DeathTriggerAdded(oUnit)
    if M28Utilities.bM28AIInGame then
        oUnit[M28UnitInfo.refbCampaignTriggerAdded] = true
    end
end
function CreateUnitReclaimedTrigger(oUnit)
    if M28Utilities.bM28AIInGame then
        oUnit[M28UnitInfo.refbCampaignTriggerAdded] = true
    end
end

function ObjectiveAdded(Type, Complete, Title, Description, ActionImage, Target, IsLoading, loadedTag)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'ObjectiveAdded'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; if map setup not complete then will wait for it to be complete') end
        --Wait until map setup complete
        while not(M28Map.bMapLandSetupComplete) or not(M28Map.bWaterZoneInitialCreation) do
            if GetGameTimeSeconds() >= 10 then break end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end


        if M28Utilities.bM28AIInGame then
            --Record capture missions
            if bDebugMessages == true then LOG('Have a mission, Title='..Title..'; Description='..Description..'; Target.captured='..(Target.captured or 'nil')..'; reprs of Target='..reprs(Target)) end
            if Target.captured == 0 then
                if bDebugMessages == true then  LOG('Have a capture mission, is target empty='..tostring(M28Utilities.IsTableEmpty(Target))) end
                --Record every unit to be captured
                if M28Utilities.IsTableEmpty(Target.Units) == false then
                    for iEntry, oUnit in Target.Units do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..' in Target; Is valid unit='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            M28Engineer.RecordUnitAsCaptureTarget(oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': WIll record unit as capture target assuming it is in a land zone') end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': size of target units='..table.getn(Target.Units)) end
                    --If only have 1 unit (i.e. is a key location) then flag to fortify
                    if table.getn(Target.Units) == 1 then
                        local oFirstM28Brain
                        for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                            oFirstM28Brain = oBrain
                            if not(oBrain.CampaignAI) then
                                break
                            end
                        end
                        local iTeam = oFirstM28Brain.M28Team
                        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(Target.Units[1]:GetPosition())
                        M28Map.MarkZoneForFortification(iPlateauOrZero, iLandOrWaterZone, iTeam)
                        if bDebugMessages == true then LOG(sFunctionRef..': flagged to fortify zone for unit '..Target.Units[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(Target.Units[1])..' at position '..repru(Target.Units[1]:GetPosition())..'; iTeam='..iTeam) end
                    end
                end
            elseif M28Utilities.IsTableEmpty(Target.Units) == false then
                local bOnlyHaveAllies = true
                local bHaveLowHealthAlly = true
                local oFirstM28Brain
                for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                    oFirstM28Brain = oBrain
                    if not(oBrain.CampaignAI) then
                        break
                    end
                end
                local iTeam = oFirstM28Brain.M28Team
                local tUnitsToRepair = {}
                for iUnit, oUnit in Target.Units do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit)))
                        if M28UnitInfo.IsUnitValid(oUnit) then LOG(sFunctionRef..': Unit is valid, Health%='..M28UnitInfo.GetUnitHealthPercent(oUnit)..'; Is enemy='..tostring(IsEnemy(oFirstM28Brain:GetArmyIndex(),  oUnit:GetAIBrain():GetArmyIndex()))..'; IsAlly='..tostring(IsAlly(oFirstM28Brain:GetArmyIndex(),  oUnit:GetAIBrain():GetArmyIndex()))) end
                    end

                    if M28UnitInfo.IsUnitValid(oUnit) then
                        if IsAlly(oFirstM28Brain:GetArmyIndex(),  oUnit:GetAIBrain():GetArmyIndex()) then
                            if bDebugMessages == true then LOG(sFunctionRef..'; Unit is an ally, health%='..M28UnitInfo.GetUnitHealthPercent(oUnit)) end
                            if M28UnitInfo.GetUnitHealthPercent(oUnit) < 1 then
                                table.insert(tUnitsToRepair, oUnit)
                            else
                                bHaveLowHealthAlly = false
                            end
                        else
                            bOnlyHaveAllies = false
                            if IsEnemy(oFirstM28Brain:GetArmyIndex(),  oUnit:GetAIBrain():GetArmyIndex()) then
                                --Make sure we are tracking this unit
                                if bDebugMessages == true then LOG(sFunctionRef..': Sent enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to be recorded in case we lack intel of it, is oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam] true for first M28brain='..tostring(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][oFirstM28Brain.M28Team] or false)) end
                                M28Team.AssignUnitToLandZoneOrPond(oFirstM28Brain, oUnit, nil, nil, true)
                                --Track air experimentals as special targets

                                if EntityCategoryContains(M28UnitInfo.refCategoryAllAir * categories.EXPERIMENTAL, oUnit.UnitId) then
                                    local bAlreadyIncluded = false
                                    if not(M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives]) then M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives] = {}
                                    else
                                        for iRecordedUnit, oRecordedUnit in M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives] do
                                            if oRecordedUnit == oUnit then bAlreadyIncluded = true break end
                                        end
                                    end
                                    if not(bAlreadyIncluded) then
                                        table.insert(M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives], oUnit)
                                    end
                                end
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': bHaveLowHealthAlly='..tostring(bHaveLowHealthAlly)..'; Is table of units to repair empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToRepair))) end
                if bHaveLowHealthAlly and M28Utilities.IsTableEmpty(tUnitsToRepair) == false then
                    local iPlateauOrZero, iLandOrWaterZone
                    local iTeam
                    for iBrain, oBrain in ArmyBrains do
                        if oBrain.M28AI then
                            iTeam = oBrain.M28Team
                            if not(oBrain.CampaignAI) then
                                break
                            end
                        end
                    end
                    for iEntry, oUnit in tUnitsToRepair do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..' in tUnitsToRepair; Is valid unit='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                            local tLZOrWZData
                            if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; Unit position='..repru(oUnit:GetPosition())) end
                            if iLandOrWaterZone > 0 then
                                local tLZOrWZTeamData
                                if iPlateauOrZero == 0 then
                                    tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                                    tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                                else
                                    tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                                    tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                                end
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subreftoUnitsToRepair]) then tLZOrWZData[M28Map.subreftoUnitsToRepair] = {} end
                                table.insert(tLZOrWZData[M28Map.subreftoUnitsToRepair], oUnit)
                                M28Air.AddPriorityAirDefenceTarget(oUnit)
                                if bDebugMessages == true then LOG(sFunctionRef..': Added unit to table of units to repair') end
                                --Consider adding this zone as somewhere to drop if it's not adjacent to a core zone
                                if iPlateauOrZero > 0 then
                                    local bAdjacentToCoreBase = false
                                    if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] then
                                        bAdjacentToCoreBase = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': Are in a core base; tLZOrWZTeamData[M28Map.subrefbCoreBaseOverride]='..tostring(tLZOrWZTeamData[M28Map.subrefbCoreBaseOverride])) end

                                    elseif M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                        for _, iAdjLZ in tLZOrWZData[M28Map.subrefLZAdjacentLandZones] do
                                            if M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] then
                                                if bDebugMessages == true then LOG(sFunctionRef..': iAdjLZ '..iAdjLZ..' is a core base, midpoint of adjlz='..repru(M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMidpoint])..'; Dist to midpoint of this LZ='..M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMidpoint], tLZOrWZData[M28Map.subrefMidpoint])..'; Travel distance='..(M28Map.GetTravelDistanceBetweenLandZones(iPlateauOrZero, iLandOrWaterZone, iAdjLZ) or 'nil')) end
                                                bAdjacentToCoreBase = true
                                                break
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to add location as a drop zone target, bAdjacentToCoreBase='..tostring(bAdjacentToCoreBase)..'; iTeam='..iTeam) end
                                    if not(bAdjacentToCoreBase) then
                                        --Add to locations for priority transport drop
                                        M28Air.UpdateTransportLocationShortlist(iTeam) --incase not already run
                                        M28Air.AddZoneToPotentialDropZonesSameIslandOrDifPond(iTeam, iPlateauOrZero, iLandOrWaterZone)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have tried toa dd to same island drop list, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; iTeam='..iTeam) end
                                    end
                                end
                            end
                        end
                    end
                    --If only have 1 unit (i.e. is a key location) then flag to fortify
                    if table.getn(Target.Units) == 1 then
                        local oFirstM28Brain
                        for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                            oFirstM28Brain = oBrain
                            if not(oFirstM28Brain.CampaignAI) then
                                break
                            end
                        end
                        local iTeam = oFirstM28Brain.M28Team
                        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(Target.Units[1]:GetPosition())
                        M28Map.MarkZoneForFortification(iPlateauOrZero, iLandOrWaterZone, iTeam)
                        if bDebugMessages == true then
                            local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(Target.Units[1]:GetPosition())
                            LOG(sFunctionRef..': flagged to fortify zone for repair target, ='..Target.Units[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(Target.Units[1])..' at position '..repru(Target.Units[1]:GetPosition())..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Fortify zone flag='..tostring(M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZFortify] or false))
                        end
                    end
                elseif bOnlyHaveAllies then
                    if bDebugMessages == true then LOG(sFunctionRef..': Only have allies so setting priority air defence target and will make sure we arent going to try and reclaim them') end
                    for iUnit, oUnit in Target.Units do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            M28Air.AddPriorityAirDefenceTarget(oUnit)
                            oUnit[M28UnitInfo.refbIsReclaimTarget] = false
                            if M28Utilities.IsTableEmpty(oUnit[M28UnitInfo.refiTeamsWithThisAsReclaimTarget]) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': We had recorded this as a reclaim target for the following teams - will now remove.'..repru(oUnit[M28UnitInfo.refiTeamsWithThisAsReclaimTarget])) end
                                for _, iRecordedTeam in oUnit[M28UnitInfo.refiTeamsWithThisAsReclaimTarget] do
                                    local tUnitLZData, tUnitLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iRecordedTeam)
                                    if M28Utilities.IsTableEmpty(tUnitLZTeamData[M28Map.subreftoUnitsToReclaim]) == false then
                                        for iRecordedUnit, oRecordedUnit in tUnitLZTeamData[M28Map.subreftoUnitsToReclaim] do
                                            if oRecordedUnit == oUnit then
                                                table.remove(tUnitLZTeamData[M28Map.subreftoUnitsToReclaim], iRecordedUnit)
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            elseif bDebugMessages == true then LOG(sFunctionRef..': Target.Units is empty; Target.UnitId='..(Target.UnitId or 'nil'))
            end

            --Record units as objective targets generally (used to trigger onkilled callback from upgrades)
            if M28Utilities.IsTableEmpty(Target.Units) == false then
                for iUnit, oUnit in Target.Units do
                    oUnit[M28UnitInfo.refbObjectiveUnit] = true
                    --Trigger the on-death for the unit if it is an external factory unit
                    if EntityCategoryContains(categories.EXTERNALFACTORYUNIT, oUnit.UnitId) and oUnit.EventCallbacks.OnKilled then
                        oUnit:DoUnitCallbacks('OnKilled')
                    end
                end
            end

            --Manual objective checks (e.g. where campaign doesnt use the function for adding objectives)
            M28Engineer.CheckForSpecialCampaignCaptureTargets()
            if bDebugMessages == true then LOG(sFunctionRef..': About to check for special campaign objectives') end
            ForkThread(M28Overseer.ConsiderSpecialCampaignObjectives,Type, Complete, Title, Description, ActionImage, Target, IsLoading, loadedTag)
        end

        ForkThread(M28Overseer.UpdateMaxUnitCapForRelevantBrains)

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function ReclaimTargetObjectiveAdded(Type, Complete, Title, Description, Target)
    --Triggers when SimObjectives.Reclaim function is called
    --Note that objectiveadded function above will also be triggered
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'ReclaimTargetObjectiveAdded'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; if map setup not complete then will wait for it to be complete') end
        --Wait until map setup complete
        while not(M28Map.bMapLandSetupComplete) or not(M28Map.bWaterZoneInitialCreation) do
            if GetGameTimeSeconds() >= 10 then break end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end


        if M28Utilities.bM28AIInGame then
            if M28Utilities.IsTableEmpty(Target.Units) == false then
                local oFirstM28Brain
                for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                    oFirstM28Brain = oBrain
                    if not(oBrain.CampaignAI) then
                        break
                    end
                end
                local iPlateauOrZero, iLandOrWaterZone
                local iTeam = oFirstM28Brain.M28Team

                for iEntry, oUnit in Target.Units do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..' in units to reclaim; Is valid unit='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                        local tLZOrWZData
                        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; Unit position='..repru(oUnit:GetPosition())) end
                        if iLandOrWaterZone > 0 then
                            local tLZOrWZTeamData
                            if iPlateauOrZero == 0 then --Waterzone
                                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                            else
                                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                            end
                            if not(tLZOrWZTeamData[M28Map.subreftoUnitsToReclaim]) then tLZOrWZTeamData[M28Map.subreftoUnitsToReclaim] = {} end
                            table.insert(tLZOrWZTeamData[M28Map.subreftoUnitsToReclaim], oUnit)
                            oUnit[M28UnitInfo.refbIsReclaimTarget] = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of units to reclaim for team '..iTeam..' in iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; iTeam='..iTeam..'; oFirstM28Brain='..oFirstM28Brain.Nickname..'; Is tLZOrWZTeamData[M28Map.subreftoUnitsToReclaim] empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoUnitsToReclaim]))) end
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnMissileIntercepted(oLauncher, target, oTMD, position)
    --M28AI specific - also exclude if TMD is owned by the same team, as as of 24/09/2023 there's a bug with FAF where this callback triggers with oTMD being another or the same MML
    if M28Utilities.bM28AIInGame then
        if not(oLauncher.Dead) and oLauncher:GetAIBrain().M28AI and M28UnitInfo.IsUnitValid(oTMD) and not(oLauncher:GetAIBrain().M28Team == oTMD:GetAIBrain().M28Team) then
            local sFunctionRef = 'OnMissileIntercepted'
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

            --MML - record time that were last intercepted if dealing with non-aeo TMD (used to build more MML) for both the MML and the TMD land zones
            if bDebugMessages == true then LOG('Missile intercepted, oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..'; is launcher a nuke='..tostring(EntityCategoryContains(M28UnitInfo.refCategorySML, oLauncher.UnitId))..'; is launcher valid='..tostring(M28UnitInfo.IsUnitValid(oLauncher))) end
            if EntityCategoryContains(M28UnitInfo.refCategoryMML, oLauncher.UnitId) then --and not(EntityCategoryContains(categories.AEON, oTMD.UnitId)) and EntityCategoryContains(M28UnitInfo.refCategoryTMD, oTMD.UnitId) then
                local iTeam = oLauncher:GetAIBrain().M28Team
                if bDebugMessages == true then LOG('MML intercepted by tmd, oLauncher='..(oLauncher.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oLauncher) or 'nil')..'; oTMD='..(oTMD.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTMD) or 'nil')..'; Launcher team='..iTeam..'; Launcher brain='..oLauncher:GetAIBrain().Nickname..'; TMD nickname='..oTMD:GetAIBrain().Nickname) end
                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oLauncher:GetPosition(), true, oLauncher)
                if (iLandZone or 0) > 0 and iPlateau > 0 then
                    local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                    tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] = GetGameTimeSeconds()
                end
                local iTMDPlateau, iTMDLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oTMD:GetPosition())
                if (iTMDLandZone or 0) > 0 and iTMDPlateau > 0 and not(iTMDLandZone == iLandZone and iTMDPlateau == iPlateau) then
                    local tLZTeamData = M28Map.tAllPlateaus[iTMDPlateau][M28Map.subrefPlateauLandZones][iTMDLandZone][M28Map.subrefLZTeamData][iTeam]
                    tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] = GetGameTimeSeconds()
                end
                --sometimes the launcher is receiving its orders from an adjacent zone, so want that adjacnet zone's combat logic to recognise this when deciding whether to syncrhonise shots
                if oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][2] and not( oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][2] == iLandZone and oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][1] == iPlateau) and not( oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][2] == iTMDLandZone and oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][1] == iTMDPlateau) then
                    local tAssignedLZTeamData = M28Map.tAllPlateaus[oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][1]][M28Map.subrefPlateauLandZones][oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][2]][M28Map.subrefLZTeamData][iTeam]
                    tAssignedLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] = GetGameTimeSeconds()
                end
            elseif EntityCategoryContains(M28UnitInfo.refCategorySML, oLauncher.UnitId) and M28UnitInfo.IsUnitValid(oLauncher) then
                if bDebugMessages == true then LOG('Will call nuke missile death logic') end
                M28Building.UpdateForNukeMissileDeath(oLauncher)
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        end
    end

end

function DelayedUnpauseOfTransferredUnits(toCapturedUnits, iArmyIndex)
    --Tracks transferred units (to help with spotting upgrades for those already in progress), and also unpauses all units
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'DelayedUnpauseOfTransferredUnits'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


        local iCapturedUnitCount
        local aiBrain
        local tFactoriesAndMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryMex, toCapturedUnits)
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, is tFactoriesAndMexes empty='..tostring(M28Utilities.IsTableEmpty(tFactoriesAndMexes))..'; iArmyIndex='..iArmyIndex..'; Time='..GetGameTimeSeconds()) end
        if M28Utilities.IsTableEmpty(tFactoriesAndMexes) == false then
            for iBrain, oBrain in ArmyBrains do
                if oBrain:GetArmyIndex() == iArmyIndex then
                    aiBrain = oBrain
                    break
                end
            end
            if aiBrain then
                local tCompletedUnits = {}
                local tUpgradingUnit = {}
                for iUnit, oUnit in tFactoriesAndMexes do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; IsUpgrade='..tostring(oUnit.IsUpgrade or false)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Unit tech level='..M28UnitInfo.GetUnitTechLevel(oUnit)) end
                    --if oUnit.IsUpgrade then table.insert(tUpgradingUnit, oUnit)
                    if oUnit:GetFractionComplete() == 1 and  M28UnitInfo.GetUnitTechLevel(oUnit) <= 2 then
                        table.insert(tCompletedUnits, oUnit)
                    end
                end
                if M28Utilities.IsTableEmpty(tCompletedUnits) == false then
                    aiBrain[M28Overseer.refiTransferedUnitCount] = (aiBrain[M28Overseer.refiTransferedUnitCount] or 0) + 1
                    iCapturedUnitCount = aiBrain[M28Overseer.refiTransferedUnitCount]
                    if not(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount]) then aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount] = {} end
                    aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iCapturedUnitCount] = {}
                    for iUnit, oUnit in tCompletedUnits do
                        table.insert(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iCapturedUnitCount], oUnit)
                        --Delayed consideration of launching a missile
                    end
                    local tMissileLaunchers = EntityCategoryFilterDown(categories.SILO, tCompletedUnits)
                    if M28Utilities.IsTableEmpty(tMissileLaunchers) == false then
                        local iCurMissiles
                        for iLauncher, oLauncher in tMissileLaunchers do
                            --LOG('Forked consideration of launching missile Delay6')
                            M28Conditions.DelayedConsiderLaunchingMissile(oLauncher, 1, bCheckHaveMissile)
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of completed units empty='..tostring(M28Utilities.IsTableEmpty(tCompletedUnits))..'; Is table of upgrading units empty='..tostring(M28Utilities.IsTableEmpty(tUpgradingUnit))) end
                if M28Utilities.IsTableEmpty(tCompletedUnits) == false and M28Utilities.IsTableEmpty(tUpgradingUnit) == false then
                    local iClosestUnitRef, iClosestDist, iCurDist
                    for iUnit, oUnit in tUpgradingUnit do
                        iClosestDist = 2
                        iClosestUnitRef = nil
                        for iCompletedUnit, oCompletedUnit in tCompletedUnits do
                            iCurDist = M28Utilities.GetDistanceBetweenPosition(oCompletedUnit:GetPosition(), oUnit:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestUnitRef = iCompletedUnit
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished searching completed units near to unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..', iClosestUnitRef='..(iClosestUnitRef or 'nil')..'; iClosestDist='..iClosestDist) end
                        if iClosestUnitRef then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will track completed unit '..tCompletedUnits[iClosestUnitRef].UnitId..M28UnitInfo.GetUnitLifetimeCount(tCompletedUnits[iClosestUnitRef])..' as an upgrading unit, given unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is upgrading and nearby') end
                            M28Team.UpdateUpgradeTrackingOfUnit(tCompletedUnits[iClosestUnitRef], false, oUnit.UnitId)
                            table.remove(tCompletedUnits, iClosestUnitRef)
                        end
                    end
                end
            end
        end
        --Also flag for every unit that it has been transferred
        for iUnit, oUnit in toCapturedUnits do
            oUnit[M28UnitInfo.refbTransferredUnit] = true
        end
        ForkThread(M28Overseer.DelayedUnpauseOfUnits,toCapturedUnits, 1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1) --tried 1 tick but it didnt help
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        --[[for iUnit, oUnit in toCapturedUnits do --covered via DelayedUnpauseOfUnits now
            if M28UnitInfo.IsUnitValid(oUnit) then
                M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, false)
            end
        end--]]
        if aiBrain and iCapturedUnitCount then
            aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iCapturedUnitCount] = nil
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnCaptured(toCapturedUnits, iArmyIndex, bCaptured)
    --looks like if multiple engineers are trying to capture a unit at once this triggers for each engineer
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnCaptured'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time'..GetGameTimeSeconds()..', is toCapturedUnits empty='..tostring(M28Utilities.IsTableEmpty(toCapturedUnits))..'; Army='..reprs(iArmyIndex)..'; Captured='..reprs(bCaptured)) end
        if M28Utilities.bM28AIInGame then
            if bCaptured and M28Utilities.IsTableEmpty(toCapturedUnits) == false then
                --Below is to cover scenarios like FA Mission 6 where a capture target can be captured by the enemy
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Will cycle through each captured unit')
                    for iUnit, oUnit in toCapturedUnits do
                        LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; owned by '..oUnit:GetAIBrain().Nickname)
                    end
                end

                --Is the unit owned by an enemy to the first M28AI in the game?
                local oM28Brain
                local oCapturingBrain
                for iBrain, oBrain in ArmyBrains do
                    if not(oM28Brain) then
                        if oBrain.M28AI then
                            oM28Brain = oBrain

                        end
                    end
                    if oBrain:GetArmyIndex() == iArmyIndex then oCapturingBrain = oBrain end
                end


                local bCheckForBlackSun = M28Map.bIsCampaignMap
                for iUnit, oUnit in toCapturedUnits do
                    if bDebugMessages == true then LOG(sFunctionRef..': Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bCheckForBlackSun='..tostring(bCheckForBlackSun)..'; Is M3P2 active='..tostring(ScenarioInfo.M3P2.Active)..'; Unit brain='..oUnit:GetAIBrain().Nickname) end
                    if not(oM28Brain.M28Team == oUnit:GetAIBrain().M28Team) and not(IsAlly(oM28Brain:GetArmyIndex(), iArmyIndex)) then
                        M28Engineer.RecordUnitAsCaptureTarget(oUnit, true)
                        --Cybran M6 - fire black sun if we have just captured it
                    elseif bCheckForBlackSun and oUnit.UnitId == 'uec1901' and ScenarioInfo.M3P2.Active and oUnit:GetAIBrain().M28AI and oUnit:GetAIBrain():GetFactionIndex() == M28UnitInfo.refFactionCybran then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to fire black sun to complete cybran campaign - will fire in a bit') end
                        ForkThread(M28Overseer.DelayedCybranFireBlackSun, oUnit:GetAIBrain())
                    end
                end
                --Aeon M4 - flag the zone to be fortified (redundancy)
                if bDebugMessages == true then LOG(sFunctionRef..': Aeon M4 check, ScenarioInfo.PlayerCapturedMainframe='..tostring(ScenarioInfo.PlayerCapturedMainframe or false)..'; toCapturedUnits[1].UnitId='..(toCapturedUnits[1].UnitId or 'nil'))
                    LOG(sFunctionRef..': Aeon M6 check - treat as core zone if captured control centre, toCapturedUnits[1].UnitId='..(toCapturedUnits[1].UnitId or 'nil')..'; oCapturingBrain.Nickname='..(oCapturingBrain.Nickname or 'nil'))
                end
                if M28Map.bIsCampaignMap then
                    if ScenarioInfo.PlayerCapturedMainframe and (toCapturedUnits[1].UnitId == 'urc1901' or toCapturedUnits[1].UnitId == 'urc1902') then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have captured the mainframe, will cycle through brains to find a human brain to check if it is aeon, and hence if this is likely to be Aeon M4') end
                        for iBrain, oBrain in ArmyBrains do
                            if oBrain.BrainType == 'Human' then
                                if bDebugMessages == true then LOG(sFunctionRef..': Is human brain aeon='..tostring(oBrain:GetFactionIndex() == M28UnitInfo.refFactionAeon)) end
                                if oBrain:GetFactionIndex() == M28UnitInfo.refFactionAeon then
                                    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(toCapturedUnits[1]:GetPosition())
                                    M28Map.MarkZoneForFortification(iPlateauOrZero, iLandOrWaterZone, oBrain.M28Team)
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef..': Have flagged zone to be fortified, iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iCaptureZone='..(iCaptureZone or 'nil'))
                                    end

                                end
                                break
                            end
                        end
                        --Aeon M6 - fortify the black sun control centre
                    elseif toCapturedUnits[1].UnitId == 'uec1902' and oCapturingBrain.M28AI and not(oCapturingBrain.HostileCampaignAI) and oCapturingBrain:GetFactionIndex() == M28UnitInfo.refFactionAeon then
                        local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(toCapturedUnits[1]:GetPosition(), true, oCapturingBrain.M28Team)
                        if bDebugMessages == true then LOG(sFunctionRef..': Fortify zone being set for the black sun control centre') end
                        if tLZOrWZTeamData then
                            local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(toCapturedUnits[1]:GetPosition())
                            M28Map.MarkZoneForFortification(iPlateauOrZero, iLandOrWaterZone, oCapturingBrain.M28Team)
                        end
                    end

                end
            elseif not(bCaptured) then
                if M28Utilities.IsTableEmpty(toCapturedUnits) == false then
                    ForkThread(DelayedUnpauseOfTransferredUnits, toCapturedUnits, iArmyIndex)
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function ScenarioPlatoonCreated(oPlatoon, strArmy, strGroup, formation, tblNode, platoon, balance)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'ScenarioPlatoonCreated'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Scenario platoon created') end
        local tPlatoonUnits = oPlatoon:GetPlatoonUnits()

        if M28Utilities.IsTableEmpty(tPlatoonUnits) == false then
            for iUnit, oUnit in tPlatoonUnits do
                if M28UnitInfo.IsUnitValid(oUnit) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Calling onCreate for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                    OnCreate(oUnit)
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnTeleportComplete(self, teleporter, location, orientation)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnTeleportComplete'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        self[M28UnitInfo.reftActiveTeleportLocation] = nil
        --if bDebugMessages == true then LOG('OnTeleportComplete - self='..reprs(self)..'; teleporter='..reprs(teleporter)..'; location='..reprs(location)) end
        if self:GetAIBrain().M28AI and self[M28ACU.refbACUHasTeleport] then
            --If we arent in a core base then teleport back
            local iTeam = self:GetAIBrain().M28Team
            local tCurLZData, tCurLZTeamData = M28Map.GetLandOrWaterZoneData(self:GetPosition(), true, iTeam)
            if bDebugMessages == true then LOG(sFunctionRef..': tCurLZTeamData[M28Map.subrefLZbCoreBase]='..tostring(tCurLZTeamData[M28Map.subrefLZbCoreBase] or false)) end
            if not(tCurLZTeamData[M28Map.subrefLZbCoreBase]) then
                local tLocationToTeleportTo
                if M28Utilities.IsTableEmpty(self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder]) == false then
                    local tPrevLZData, tPrevLZTeamData = M28Map.GetLandOrWaterZoneData(self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder], true, iTeam)
                    if tPrevLZTeamData[M28Map.subrefLZbCoreBase] then
                        tLocationToTeleportTo = {self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder][1], self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder][2], self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder][3]}
                    end
                end
                if not(tLocationToTeleportTo) then
                    tLocationToTeleportTo = {tCurLZTeamData[M28Map.reftClosestFriendlyBase][1], tCurLZTeamData[M28Map.reftClosestFriendlyBase][2], tCurLZTeamData[M28Map.reftClosestFriendlyBase][3]}
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Will teleport back to '..repru(tLocationToTeleportTo)) end
                --Add to existing queue due to issue where this callback can take place even though the ACU hasn't compelted its teleport
                if M28Utilities.GetDistanceBetweenPositions(self:GetPosition(), tLocationToTeleportTo) >= 50 then
                    --Check we are relatively near the last location we were trying to teleport to
                    if M28Utilities.IsTableEmpty(self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder]) == false and M28Utilities.GetDistanceBetweenPositions(self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder], self:GetPosition()) <= 100 then
                        M28Orders.IssueTrackedTeleport(self, tLocationToTeleportTo, 5, true, 'TelRet', true)
                    end
                end
            end
        end

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnStartTeleport(self, teleporter, location, orientation)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnStartTeleport'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if M28UnitInfo.IsUnitValid(self) then
            local iTeleportTeam = self:GetAIBrain().M28Team
            self[M28UnitInfo.reftActiveTeleportLocation] = {location[1], location[2], location[3]}
            if bDebugMessages == true then LOG(sFunctionRef..': Teleport attempt detected by unit '..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self)..'; location='..repru(location)..'; brain owner='..self:GetAIBrain().Nickname) end
            for iCurTeam = 1, M28Team.iTotalTeamCount do
                if not(iCurTeam == iTeleportTeam) and M28Team.tTeamData[iCurTeam][M28Team.subrefiActiveM28BrainCount] > 0 then
                    if not(M28Team.tTeamData[iCurTeam][M28Team.reftRecentEnemyTeleportDetails]) then
                        M28Team.tTeamData[iCurTeam][M28Team.reftRecentEnemyTeleportDetails] = {}
                    end
                    table.insert(M28Team.tTeamData[iCurTeam][M28Team.reftRecentEnemyTeleportDetails], {[M28Team.subrefoTeleportUnit] = self, [M28Team.subreftTeleportTarget] = {location[1], math.max(location[2], GetTerrainHeight(location[1], location[3])), location[3]}, [M28Team.subrefiTeleportTime] = GetGameTimeSeconds()})
                end
            end
        end

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnGameStart()
    --Called vai hook of simInit
    if import('/mods/M28AI/lua/M28Config.lua').M28RunSimpleProfiling then
        ForkThread(M28Profiler.SimpleProfiler, 10)
    end

    --Check if we have M28 in game at this stage (in addition to setting this to true whenever an M28 brain is created):
    if not(M28Utilities.bM28AIInGame) then
        if M28Utilities.IsTableEmpty(ScenarioInfo.ArmySetup) == false then
            for sEntry, tData in ScenarioInfo.ArmySetup do
                --LOG('Considering sEntry='..sEntry..'; tData.AIPersonality='..(tData.AIPersonality or 'nil'))
                if tData.AIPersonality and string.find(tData.AIPersonality, 'm28') then
                    M28Utilities.bM28AIInGame = true
                    --LOG('M28 in game 2')
                    break
                end
            end
        end
        --[aiBrain.Name].AIPersonality
    end
end

function ShieldRechargeStarted(oUnit)
    --LOUD specific - used becuase LOUD doesnt have FAF code for shield.enabled
    oUnit[M28UnitInfo.refbShieldDown] = true
end

function ShieldDisabled(oUnit)
    --LOUD specific - used becuase LOUD doesnt have FAF code for shield.enabled
    oUnit[M28UnitInfo.refbShieldDown] = true
end
function ShieldEnabled(oUnit)
    --LOUD specific - used becuase LOUD doesnt have FAF code for shield.enabled
    oUnit[M28UnitInfo.refbShieldDown] = false
end