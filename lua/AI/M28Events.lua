---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 09:03
---



local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Config = import('/mods/M28AI/lua/M28Config.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
local M28Chat = import('/mods/M28AI/lua/AI/M28Chat.lua')

refiLastWeaponEvent = 'M28LastWep' --Gametimeseconds that last updated onweapon
refbAlreadyRunUnitKilled = 'M28EventsOnKilledRun'


function OnPlayerDefeated(aiBrain)

    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnPlayerDefeated'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': Player has been defeated, brain='..aiBrain.Nickname..'; Was this an M28AI='..tostring(aiBrain.M28AI or false)..'; ScenarioInfo.Options.Share='..(ScenarioInfo.Options.Share or 'nil')) end
        local iTeam = aiBrain.M28Team
        aiBrain.M28IsDefeated = true

        M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastTeammateDeath] = GetGameTimeSeconds()

        --Was it an M28AI?
        if aiBrain.M28AI and (M28Orders.bDontConsiderCombinedArmy or aiBrain.BrainType == 'AI') then
            --Give resources to teammates
            local bHaveTeammates = false
            local oFirstM28Brain
            local oFirstOtherBrain
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                    if not(oBrain == aiBrain) and not(oBrain.M28IsDefeated) and not(oBrain:IsDefeated()) then
                        bHaveTeammates = true
                        if not(oFirstM28Brain) then
                            if oBrain.M28AI then oFirstM28Brain = oBrain
                            elseif not(oFirstOtherBrain) then oFirstOtherBrain = oBrain
                            end
                        end
                    end
                end
            end
            if bHaveTeammates then
                ForkThread(M28Team.GiveAllResourcesToAllies, aiBrain)
                M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastM28PlayerDefeat] = GetGameTimeSeconds()
                if oFirstM28Brain or oFirstOtherBrain then
                    local oBrainToTransfer = oFirstM28Brain or oFirstOtherBrain
                    local tFriendlyUnits = aiBrain:GetListOfUnits(categories.ALLUNITS - categories.UNSELECTABLE - categories.COMMAND, false, true)
                    if M28Utilities.IsTableEmpty(tFriendlyUnits) == false then
                        ForkThread(M28Team.TransferUnitsToPlayer, tFriendlyUnits, oBrainToTransfer:GetArmyIndex(), false)
                    end
                end
            else
                --Message on death - Will cover as part of M28Chat function
            end
        end

        --Was it a team with omni vision, that still has M28 on the team?
        if M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmniVision] and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
            local bStillHaveOmni = false
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                if not(oBrain.M28IsDefeated) and M28Conditions.DoesBrainHaveOmniVision(oBrain) then
                    bStillHaveOmni = true
                    break
                end
            end
            if not(bStillHaveOmni) then
                M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmniVision] = false --So we can do forked thread without worrying about calling multiple times at once
                ForkThread(M28Team.TeamHasLostAIxOmniVision, iTeam) --Just in case an error occurs
            end
        end

        --Update tables tracking the various brains
        ForkThread(M28Team.RefreshActiveBrainListForBrainDeath, aiBrain)
        --if the base will have been destroyed, or there isn't a base anyway, then rerecord positions
        if not(ScenarioInfo.Options.Share == 'FullShare') or aiBrain:GetCurrentUnits(categories.ALLUNITS - categories.INSIGNIFICANTUNIT) <= 2 then
            ForkThread(M28Map.ReassessPositionsForPlayerDeath, aiBrain)
        end
        ForkThread(M28Chat.ConsiderEndOfGameMessage, aiBrain)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnACUKilled(oUnit)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnACUKilled'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then
            local oKilledBrain = oUnit:GetAIBrain()
            if oKilledBrain then
                LOG(sFunctionRef..': ACU '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has just died, and its brain is '..oKilledBrain.Nickname..'; ScenarioInfo.Options.Victory='..(ScenarioInfo.Options.Victory or 'nil')..'; Cur ACU and SACU units='..oUnit:GetAIBrain():GetCurrentUnits(categories.COMMAND + categories.SUBCOMMANDER))
            else
                LOG(sFunctionRef..': ACU '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has just died, and it doesnt have a brain')
            end
        end
        local oKilledBrain = oUnit:GetAIBrain()
        local bDefeated = false

        if ScenarioInfo.Options.Victory == "demoralization" then
            bDefeated = true
        elseif oKilledBrain and not(oKilledBrain.M28IsDefeated) and ScenarioInfo.Options.Victory == 'decapitation' then
            --In FAF this means all teammate ACUs; outside of FAF means ACUs and SACUs of that player
            if M28Utilities.bFAFActive then
                bDefeated = true
                if EntityCategoryContains(categories.SUBCOMMANDER, oUnit.UnitId) and oKilledBrain:GetCurrentUnits(categories.COMMAND) > 0 then
                    bDefeated = false
                    if bDebugMessages == true then LOG(sFunctionRef..': We still have an ACU so not defeated yet') end
                else
                    local iTeam = oKilledBrain.M28Team
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of friendly brains on our team empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains]))) end
                    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
                        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering teammate '..oBrain.Nickname..'; IsDefeated='..tostring(oBrain:IsDefeated())..'; Cur ACUs owned='..oBrain:GetCurrentUnits(categories.COMMAND)) end
                            if not(oBrain == oKilledBrain) and oBrain.IsDefeated and not(oBrain:IsDefeated()) then
                                if oBrain:GetCurrentUnits(categories.COMMAND) > 0 then
                                    bDefeated = false
                                    break
                                end
                            end
                        end
                    end
                end
            else
                local tCurUnits = oKilledBrain:GetListOfUnits(categories.COMMAND + categories.SUBCOMMANDER, false, true)
                if M28Utilities.IsTableEmpty(tCurUnits) then
                    bDefeated = true
                else
                    bDefeated = true
                    for iOwnedUnit, oOwnedUnit in tCurUnits do
                        if not(oOwnedUnit == oUnit) and not(oOwnedUnit.Dead) and not(oUnit['M28Dead']) then
                            bDefeated = false
                            break
                        end
                    end
                end
            end
        end
        --Update the table of enemy ACUs for every team
        for iCurTeam = 1, M28Team.iTotalTeamCount do
            if not(iCurTeam == oKilledBrain.M28Team) then
                if M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iCurTeam][M28Team.reftEnemyACUs]) then
                    --Do nothing (function will have cleansed the table of old entries already)
                end
            elseif oKilledBrain.M28AI then
                if M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iCurTeam][M28Team.reftM28ACUs]) then
                    --Do nothing (function will have cleansed the table of old entries already)
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Will consider calling OnPlayerDefeated, .M28IsDefeated='..tostring(oUnit:GetAIBrain().M28IsDefeated or false)..'; bDefeated='..tostring(bDefeated)) end
        if bDefeated then
            if oUnit:GetAIBrain() then
                if not(oUnit:GetAIBrain().M28IsDefeated) then
                    OnPlayerDefeated(oUnit:GetAIBrain())
                end
            else
                --Possibility that we have already recorded the unit death, so wait 1 second and then if any brains show as defeated but not M28Defeated then run the function
                ForkThread(M28Team.DelayedPlayerDeathCheck)
            end
        else
            local aiBrain = oUnit:GetAIBrain()
            local iStartPlateauOrZero, iStartZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(M28Map.GetPlayerStartPosition(aiBrain))
            local tLZOrWZData, tLZOrWZTeamData
            local iTeam = aiBrain.M28Team
            if iStartPlateauOrZero == 0 then
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iStartZone]][M28Map.subrefPondWaterZones][iStartZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
            else
                tLZOrWZData = M28Map.tAllPlateaus[iStartPlateauOrZero][M28Map.subrefPlateauLandZones][iStartZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
            end
            ForkThread(M28Map.DelayedConsiderationOfWhetherToIgnoreFriendlyBase, tLZOrWZData, tLZOrWZTeamData, aiBrain.M28Team, iStartPlateauOrZero, iStartZone, M28Land.iTicksPerLandCycle * 0.1 + 0.1)
        end

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnKilled(oUnitKilled, instigator, type, overkillRatio)
    --WARNING: Doesnt trigger when an ACU is killed
    --Will make sure the OnUnitDeath event is called, i.e. this function should only be used where we only want something to run when we killed something, or an enemy killed something of ours

    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnKilled'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': event triggered for unit '..(oUnitKilled.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitKilled) or 'nil')..' owned by brain '..oUnitKilled:GetAIBrain().Nickname..'; Have already run='..tostring(oUnitKilled[refbAlreadyRunUnitKilled] or false)) end

        if not(oUnitKilled[refbAlreadyRunUnitKilled]) then
            oUnitKilled[refbAlreadyRunUnitKilled] = true

            if bDebugMessages == true then LOG(sFunctionRef..': oUnitKilled='..oUnitKilled.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitKilled)..'; GameTime='..GetGameTimeSeconds()) end
            if oUnitKilled.GetAIBrain then
                OnUnitDeath(oUnitKilled) --Ensure this is run when a unit dies

                --were we killed by something?
                local oKillerUnit
                local oKillerBrain

                if instigator and not(instigator:BeenDestroyed()) and not(instigator.Dead) then
                    if instigator.GetLauncher and instigator:GetLauncher() then
                        oKillerUnit = instigator:GetLauncher()
                    elseif instigator.DamageData and not(instigator.unit) and not(instigator.UnitId) then
                        --Can get errors for artillery shells when running IsProjectile
                    elseif IsProjectile(instigator) or IsCollisionBeam(instigator) then
                        if instigator.unit then
                            oKillerUnit = instigator.unit
                        end
                    elseif IsUnit(instigator) then
                        oKillerUnit = instigator
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Have an instigator, checking if have valid killer unit. Is valid='..tostring(M28UnitInfo.IsUnitValid(oKillerUnit))) end
                    if oKillerUnit and oKillerUnit.GetAIBrain then
                        oKillerBrain = oKillerUnit:GetAIBrain()
                        if bDebugMessages == true then LOG(sFunctionRef..': oKillerUnit='..oKillerUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oKillerUnit)..'; oKillerBrain='..oKillerBrain.Nickname..'; Killer unit assigned plateau+zone (for killed unit brain team)='..repru(oKillerUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][oUnitKilled:GetAIBrain().M28Team])..'; Assigned water zone='..(oKillerUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][oUnitKilled:GetAIBrain().M28Team] or 'nil')) end

                        --Non-M28 specific killer logic:

                        if EntityCategoryContains(M28UnitInfo.refCategoryBomber * categories.TECH3, oKillerUnit.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryT3Power + M28UnitInfo.refCategoryT2Power, oKillerUnit.UnitId) then
                            ForkThread(ConsiderRecordingStratBomberToSuicideInto, oKillerUnit, true)
                        end

                        --Logic specific to where M28 unit is killed:
                        if oUnitKilled:GetAIBrain().M28AI then
                            local iTeam = oUnitKilled:GetAIBrain().M28Team
                            --Tracking for certain units that are killed - T2 arti and gunships:
                            if EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oKillerUnit.UnitId) then M28Land.ConsiderIfHaveEnemyFirebase(iTeam, oKillerUnit) end
                            --Track non-experimental air units
                            if EntityCategoryContains(M28UnitInfo.refCategoryGunship + M28UnitInfo.refCategoryBomber - M28UnitInfo.refCategoryTorpBomber - categories.EXPERIMENTAL, oUnitKilled.UnitId) then
                                if EntityCategoryContains(M28UnitInfo.refCategoryBomber, oUnitKilled.UnitId) then
                                    M28Team.tTeamData[iTeam][M28Team.refiBomberLosses] = M28Team.tTeamData[iTeam][M28Team.refiBomberLosses] + M28UnitInfo.GetUnitMassCost(oUnitKilled)
                                else
                                    M28Team.tTeamData[iTeam][M28Team.refiGunshipLosses] = M28Team.tTeamData[iTeam][M28Team.refiGunshipLosses] + M28UnitInfo.GetUnitMassCost(oUnitKilled)
                                    --Adjust gunship retreat logic if killed by a ground unit
                                    if oKillerUnit and M28Air.iBaseLowHealthThreshold < 0.75 and EntityCategoryContains(M28UnitInfo.refCategoryGroundAA, oKillerUnit.UnitId) and EntityCategoryContains(categories.TECH3, oUnitKilled.UnitId) then
                                        if M28Team.tTeamData[iTeam][M28Team.refiGunshipLosses] > M28Team.tTeamData[iTeam][M28Team.refiGunshipKills] * 0.7 then
                                            M28Air.iBaseLowHealthThreshold = M28Air.iBaseLowHealthThreshold + 0.03
                                            M28Air.iProjectileLowHealthThreshold = M28Air.iProjectileLowHealthThreshold + 0.03
                                        else
                                            M28Air.iBaseLowHealthThreshold = M28Air.iBaseLowHealthThreshold + 0.02
                                            M28Air.iProjectileLowHealthThreshold = M28Air.iProjectileLowHealthThreshold + 0.02
                                        end
                                    end
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryAirAA, oUnitKilled.UnitId) then
                                --If we died to enemy air unit then track
                                if oKillerUnit and EntityCategoryContains(M28UnitInfo.refCategoryAirNonScout, oKillerUnit.UnitId) then
                                    M28Team.tTeamData[iTeam][M28Team.refiAirAALossesToAir] = M28Team.tTeamData[iTeam][M28Team.refiAirAALossesToAir] + M28UnitInfo.GetUnitMassCost(oUnitKilled)
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oUnitKilled.UnitId) and not(iTeam == oKillerBrain.M28Team) then
                                if oKillerBrain.M28Team then
                                    --I.e. we have an M28 naval fac killed by a unit from another team
                                    local tWZData, tWZTeamData = M28Map.GetLandOrWaterZoneData(oUnitKilled:GetPosition(), true, iTeam)
                                    if tWZTeamData then tWZTeamData[M28Map.subrefWZFactoryDestroyedCount] = (tWZTeamData[M28Map.subrefWZFactoryDestroyedCount] or 0) + 1 end
                                end
                            end
                            if EntityCategoryContains(M28UnitInfo.refCategoryTML, oKillerUnit.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnitKilled.UnitId) then
                                local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnitKilled:GetPosition(), true, iTeam)
                                if tLZOrWZTeamData then tLZOrWZTeamData[M28Map.subrefiTimeOfLastBuildingDeathToTML] = GetGameTimeSeconds() end
                            end
                        end

                        --M28 specific killer logic
                        if oKillerBrain.M28AI then
                            --Logic based on the category of the killer:
                            if EntityCategoryContains(M28UnitInfo.refCategorySatellite, instigator.UnitId) and M28UnitInfo.IsUnitValid(oKillerUnit) then
                                ForkThread(M28Air.NovaxCoreTargetLoop, oKillerBrain, instigator, true)
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oKillerUnit.UnitId) and not(type) and not(overkillRatio) and not(oKillerBrain.M28Team == oUnitKilled:GetAIBrain().M28Team) then
                                --We have reclaimed an enemy - if there arent many enemies in this zone then update the zone; also check for enemy targets within build range to reclaim
                                local tNearbyReclaimableEnemies = oKillerBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryReclaimable, oKillerUnit:GetPosition(), oKillerUnit:GetBlueprint().Economy.MaxBuildDistance, 'Enemy')
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby reclaimable enemies empty='..tostring( M28Utilities.IsTableEmpty(tNearbyReclaimableEnemies))) end
                                local bNotGivenReclaimOrder = true
                                if M28Utilities.IsTableEmpty(tNearbyReclaimableEnemies) == false then
                                    for iPotentialEnemy, oPotentialEnemy in tNearbyReclaimableEnemies do
                                        if not(oPotentialEnemy == oUnitKilled) and M28UnitInfo.IsUnitValid(oPotentialEnemy) and oPotentialEnemy:GetHealth() > 0 then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will issue new reclaim order for oKillerUnit='..(oKillerUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oKillerUnit) or 'nil')..' owend by brain'..oKillerBrain.Nickname..' to target enemy unit '..(oPotentialEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oPotentialEnemy) or 'nil')..'; Time='..GetGameTimeSeconds()..'; Enemy unit health='..oPotentialEnemy:GetHealth()..'; Enemy unit brain owner='..oPotentialEnemy:GetAIBrain().Nickname) end

                                            ForkThread(M28Orders.IssueTrackedReclaim, oKillerUnit, oPotentialEnemy, false, 'FollowRec', false) --WHen tried doing but not via forked thread ended up with game crashing
                                            bNotGivenReclaimOrder = false
                                            break
                                        end
                                    end
                                end
                                if bNotGivenReclaimOrder then
                                    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnitKilled:GetPosition())
                                    if (iPlateauOrZero or 0) > 0 and (iLandOrWaterZone or 0) > 0 then
                                        local tLZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][oKillerBrain.M28Team]
                                        --if we reclaimed an enemy unit, then update units in that zone if arent many units left
                                        if not(tLZTeamData[M28Map.subrefTEnemyUnits][2]) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                                            if bDebugMessages == true then LOG(sFunctionRef..': have just killed a unit so will update the position of all enemy units in the zone, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; Time='..GetGameTimeSeconds()) end
                                            --UpdateUnitPositionsAndLandZone(aiBrain,   tUnits,                                 iTeam,              iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
                                            M28Land.UpdateUnitPositionsAndLandZone(oKillerBrain, tLZTeamData[M28Map.subrefTEnemyUnits], oKillerBrain.M28Team, iPlateauOrZero, iLandOrWaterZone, true,                   false,          tLZTeamData, true,                                  true)
                                        end
                                    end

                                end
                                --Gunship and strat bomber tracking (non-experimental)
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryGunship + M28UnitInfo.refCategoryBomber - M28UnitInfo.refCategoryTorpBomber - categories.EXPERIMENTAL, oKillerUnit.UnitId) then
                                local iTeam = oKillerBrain.M28Team
                                if EntityCategoryContains(M28UnitInfo.refCategoryBomber, oKillerUnit.UnitId) then
                                    M28Team.tTeamData[iTeam][M28Team.refiBomberKills] = M28Team.tTeamData[iTeam][M28Team.refiBomberKills] + M28UnitInfo.GetUnitMassCost(oKillerUnit)
                                else
                                    M28Team.tTeamData[iTeam][M28Team.refiGunshipKills] = M28Team.tTeamData[iTeam][M28Team.refiGunshipKills] + M28UnitInfo.GetUnitMassCost(oKillerUnit)
                                end
                                --AirAA tracking
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryAirAA, oKillerUnit.UnitId) then
                                local iTeam = oKillerBrain.M28Team
                                M28Team.tTeamData[iTeam][M28Team.refiAirAAKills] = M28Team.tTeamData[iTeam][M28Team.refiAirAAKills] + M28UnitInfo.GetUnitMassCost(oKillerUnit)
                            end

                            --Logic based on the category of the unit killed
                            if EntityCategoryContains(M28UnitInfo.refCategoryT3Mex + M28UnitInfo.refCategoryT3Power + M28UnitInfo.refCategoryExperimentalLevel, oUnitKilled.UnitId) then
                                if M28Orders.bDontConsiderCombinedArmy or oKillerUnit.M28Active then
                                    --Scathis special message if killed by UEF
                                    if oKillerUnit and EntityCategoryContains(M28UnitInfo.refCategoryScathis, oUnitKilled.UnitId) and EntityCategoryContains(categories.UEF, oKillerUnit.UnitId) and oKillerBrain[M28Chat.refiAssignedPersonality] == M28Chat.refiFletcher then
                                        ForkThread(M28Chat.SendMessage, oKillerBrain, 'UEFKilledScathis', LOC('<LOC X05_M02_050_010>[{i Fletcher}]: Scratch one Scathis. Fletcher out.'), 1, 600, false, true, 'X05_Fletcher_M02_03831', 'X05_VO')
                                        --Killed T3 arti or experimental arti and there are no other friendly T3/Exp arti units on that team
                                    elseif oKillerUnit and EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, oUnitKilled.UnitId) and M28Chat.IsTeamCoalition(oKillerBrain.M28Team) and M28Utilities.IsTableEmpty(oUnitKilled:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, oUnitKilled:GetPosition(), M28Map.iMapSize * 2, 'Ally')) then
                                        local bSendToTeam = false
                                        if math.random(1,2) == 1 and M28Utilities.IsTableEmpty(M28Team.tTeamData[oKillerBrain.M28Team][M28Team.subreftoFriendlyHumanAndAIBrains]) == false and table.getn(M28Team.tTeamData[oKillerBrain.M28Team][M28Team.subreftoFriendlyHumanAndAIBrains]) >= 2 then bSendToTeam = true end
                                        --SendMessage(aiBrain, sMessageType,        sMessage,                                                                       iOptionalDelayBeforeSending, iOptionalTimeBetweenMessageType, bOnlySendToTeam, bWaitUntilHaveACU, sOptionalSoundCue, sOptionalSoundBank, oOptionalOnlyBrainToSendTo)
                                        M28Chat.SendMessage(oKillerBrain, 'CoalKillArti', LOC('<LOC X01_M01_200_010>[{i HQ}]: That\'s the last of them -- all the artillery positions are down.'), 1,       600,                            bSendToTeam,          true,               'X01_HQ_M01_03631', 'X01_VO')
                                        --Dont trigger if killed via nuke
                                    elseif oKillerUnit and not(EntityCategoryContains(M28UnitInfo.refCategorySML, oKillerUnit.UnitId)) then
                                        --Check mod dist is far enoguh away from our core base that unlikely it has dealt lots of damage
                                        local bConsiderMessage = true
                                        if EntityCategoryContains(categories.MOBILE, oUnitKilled.UnitId) then
                                            bConsiderMessage = false
                                            local tUnitLZData, tUnitLZTeamData = M28Map.GetLandOrWaterZoneData(oUnitKilled:GetPosition(), true, oKillerBrain.M28Team)
                                            if tUnitLZTeamData and tUnitLZTeamData[M28Map.refiModDistancePercent] >= 0.3 and not(tUnitLZTeamData[M28Map.subrefLZbCoreBase]) and ((oUnitKilled.VetExperience or oUnitKilled.Sync.totalMassKilled or 0) < 12000) then
                                                bConsiderMessage = true
                                            end
                                        end
                                        if bConsiderMessage then
                                            if (oUnitKilled.VetExperience or oUnitKilled.Sync.totalMassKilled or 0) < (oUnitKilled[M28UnitInfo.refiUnitMassCost] or 0) * 0.5 or EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryGameEnder, oUnitKilled.UnitId) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': About to call chat for valuable unit killed, oUnitKilled='..oUnitKilled.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitKilled)..', owned by brain '..oUnitKilled:GetAIBrain().Nickname..'; oKillerUnit='..oKillerUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oKillerUnit)..' owned by brain '..(oKillerBrain.Nickname or 'nil')) end
                                                ForkThread(M28Chat.JustKilledEnemyValuableUnit, oUnitKilled.UnitId, oUnitKilled:GetAIBrain(), oKillerBrain) --If dont do as forked thread then any error breaks the game
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                --Consider message if this was a significant unit
                if EntityCategoryContains(M28UnitInfo.refCategoryT3Mex + M28UnitInfo.refCategoryT3Power + M28UnitInfo.refCategoryExperimentalLevel, oUnitKilled.UnitId) then
                    if oUnitKilled:GetFractionComplete() == 1 or (EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnitKilled.UnitId) and oUnitKilled:GetFractionComplete() >= 0.6) then
                        local bConsideredNormalMessage = false
                        --Send distress message
                        if oUnitKilled:GetAIBrain().M28AI and (M28Orders.bDontConsiderCombinedArmy or oUnitKilled.M28Active) then
                            local tUnitLZData, tUnitLZTeamData = M28Map.GetLandOrWaterZoneData(oUnitKilled:GetPosition(), true, oUnitKilled:GetAIBrain().M28Team)
                            --Was the unit in a mod dist of <=0.4 (so getting close to base or in base)?
                            if tUnitLZTeamData[M28Map.refiModDistancePercent] <= 0.4 and (tUnitLZTeamData[M28Map.refiModDistancePercent] <= 0.3 or not(EntityCategoryContains(M28UnitInfo.refCategoryMex + categories.MOBILE, oUnitKilled.UnitId))) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Just lost unit '..oUnitKilled.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitKilled)..', owned by brain'..oUnitKilled:GetAIBrain().Nickname..'; Mod dist='..(tUnitLZTeamData[M28Map.refiModDistancePercent] or 'nil')..'; oKillerUnit='..(oKillerUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oKillerUnit) or 'nil')..'; will send taunt if havent sent one recently, Time='..GetGameTimeSeconds()) end
                                ForkThread(M28Chat.JustLostValuableUnit, oUnitKilled.UnitId, oUnitKilled:GetAIBrain(), oKillerBrain) --If dont do as forked thread then any error breaks the game
                                bConsideredNormalMessage = true
                            end
                        end
                        if not(bConsideredNormalMessage) and EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnitKilled.UnitId) then
                            --Special message if we have a hall personality M28 teammate, and killer brain was UEF
                            if oKillerBrain and oKillerBrain:GetFactionIndex() == M28UnitInfo.refFactionUEF then
                                --Do we have hall as a teammate?
                                local iTeam = oKillerBrain.M28Team
                                local bHaveHall = false
                                local oBrainToSendMessage
                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                        if oBrain[M28Chat.refiAssignedPersonality] == M28Chat.refiHall and oBrain.BrainType == 'AI' and not(oBrain == oKillerBrain) then
                                            oBrainToSendMessage = oBrain
                                            break
                                        end
                                    end
                                end
                                if oBrainToSendMessage then
                                    ForkThread(M28Chat.SendMessage, oBrainToSendMessage, 'HallCongrats', LOC('<LOC X01_M02_210_010>[{i Hall}]: Good work, Colonel. I\'m damn proud to have you in the UEF.'), 1, 10000, false, true, 'X01_Hall_M02_03658', 'X01_VO')
                                end
                            end
                        end
                    end
                end
            elseif bDebugMessages == true then LOG(sFunctionRef..': Unit killed doesnt have a brain')
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnPropDestroyed(oProp)
    --Confirmed manually this triggers e.g. if a bomber destroys a rock, and if a tree is reclaimed
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnPropDestroyed'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnYthothaDeath(oUnit)
    --Called when a ythotha (oUnit) is flagged as dying or being killed
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnYthothaDeath'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        local refbYthothaDeath = 'M28EventYthothaDeath'

        if not(oUnit[refbYthothaDeath]) then
            oUnit[refbYthothaDeath] = true
            local tNearbyUnits
            if bDebugMessages == true then LOG(sFunctionRef..': Ythotha has just died, will look for nearby units and tell them to run away') end
            local iTimeToRun
            local iSearchRange = 70 --at 50 distance a fatboy can end up dying to it
            for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                tNearbyUnits = oBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand, oUnit:GetPosition(), iSearchRange, 'Ally')
                if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                    local bRunCurrentUnit
                    for iFriendlyUnit, oFriendlyUnit in tNearbyUnits do
                        if bDebugMessages == true then LOG(sFunctionRef..': oFriendlyUnit='..oFriendlyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFriendlyUnit)..'; if we own it then will make it run away') end
                        if oFriendlyUnit:GetAIBrain() == oBrain then --Only do this for M28 units
                            if M28UnitInfo.IsUnitValid(oFriendlyUnit, true) then
                                if not(oFriendlyUnit[M28UnitInfo.refbEasyBrain]) then
                                    bRunCurrentUnit = true
                                    if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oFriendlyUnit.UnitId) and (oFriendlyUnit:IsUnitState('Building') or oFriendlyUnit:IsUnitState('Repairing')) and oFriendlyUnit:GetWorkProgress() >= 0.94 and (oFriendlyUnit:GetWorkProgress() >= 0.97 or oFriendlyUnit:GetFocusUnit().UnitId and EntityCategoryContains(M28UnitInfo.refCategoryAllShieldUnits + categories.MOBILE, oFriendlyUnit:GetFocusUnit().UnitId)) then
                                        bRunCurrentUnit = false
                                    end
                                    if bRunCurrentUnit then
                                        --Engineers that are assisting a near-complete shield or mobile unit - keep building
                                        iTimeToRun = math.min(32, math.max(10, 18 + (50 - M28Utilities.GetDistanceBetweenPositions(oFriendlyUnit:GetPosition(), oUnit:GetPosition()) / (oFriendlyUnit:GetBlueprint().Physics.MaxSpeed or 1))))
                                        if bDebugMessages == true then LOG(sFunctionRef..': Telling friendly unit '..oFriendlyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFriendlyUnit)..' to move away for 18s via moveawayfromtarget order') end
                                        ForkThread(M28Micro.MoveAwayFromTargetTemporarily, oFriendlyUnit, iTimeToRun, oUnit:GetPosition())
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnUnitDeath(oUnit)
    --NOTE: This is called by the death of any unit of any player, so careful with what commands are given
        --Some callbacks line onkilled will call this as well to make sure it is run (since for some things like when an ACU is killed it doesnt trigger directly)
    if M28Utilities.bM28AIInGame and M28Map.bWaterZoneInitialCreation then --No point running on death logic for units at start of the game
        local sFunctionRef = 'OnUnitDeath'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



        if bDebugMessages == true then
            LOG(sFunctionRef..'Hook successful. oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; GameTime='..GetGameTimeSeconds()..'; oUnit[refbAlreadyRunUnitKilled]='..tostring(oUnit[refbAlreadyRunUnitKilled] or false)..'; oUnit[M28Dead]='..tostring(oUnit['M28Dead'] or false))
            if oUnit.GetAIBrain then LOG(sFunctionRef..': Unit owner='..oUnit:GetAIBrain().Nickname) end
        end
        --Is it an ACU?
        if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) or (ScenarioInfo.Options.Victory == 'decapitation' and EntityCategoryContains(categories.SUBCOMMANDER, oUnit.UnitId)) then
            OnACUKilled(oUnit)
        else
            if oUnit.CachePosition and (not(oUnit.UnitId) or not(EntityCategoryContains(categories.ALLUNITS - categories.INSIGNIFICANTUNIT, oUnit.UnitId))) then --Redundancy to check not dealing with a unit, not sure this will actually trigger as looks like wreck deaths are picked up by the prop logic above
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Unit killed has a cache position, will draw in blue around it')
                    M28Utilities.DrawLocation(oUnit.CachePosition, nil, 1, 100, nil)
                end
                ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, oUnit.CachePosition, 0)
            else
                if oUnit.GetAIBrain then
                    --------Non-M28 Specific logic------
                    --Rough unit count
                    if not(oUnit['M28Dead']) then
                        oUnit['M28Dead'] = true
                        M28Overseer.refiRoughTotalUnitsInGame = M28Overseer.refiRoughTotalUnitsInGame - 1

                        --Adjust T3 MAA count
                        if M28Utilities.IsTableEmpty(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam]) == false and EntityCategoryContains(M28UnitInfo.refCategoryMAA * categories.TECH3, oUnit.UnitId) then
                            for iRecordedTeam, bRecorded in oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam] do
                                M28Team.tTeamData[iRecordedTeam][M28Team.iEnemyT3MAAActiveCount] = math.max(0, (M28Team.tTeamData[iRecordedTeam][M28Team.iEnemyT3MAAActiveCount] or 0) - 1)
                            end
                        end



                        --TMD protection logic - refresh land zone TMD entries
                        if oUnit[M28Building.refbUnitWantsMoreTMD] then M28Building.UpdateLZUnitsWantingTMDForUnitDeath(oUnit) end

                        --Big threat global team table update
                        if M28Utilities.IsTableEmpty(oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable]) == false then
                            M28Team.RemoveUnitFromBigThreatTable(oUnit)
                        end


                        M28Orders.ClearAnyRepairingUnits(oUnit)

                        --Hydro resource location made available again
                        if EntityCategoryContains(M28UnitInfo.refCategoryHydro, oUnit.UnitId) then
                            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroLocations]) == false then
                                for iHydroLocation, tHydroLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroLocations] do
                                    if M28Utilities.GetDistanceBetweenPositions(tHydroLocation, oUnit:GetPosition()) <= 2 then
                                        --Check we have no built hydros that are a different unit (to support upgrading hydros)
                                        local rPotentialTargetRect = M28Utilities.GetRectAroundLocation(tHydroLocation, 1)
                                        local tUnitsInRect = GetUnitsInRect(rPotentialTargetRect)
                                        local bHaveHydroOnPoint = false
                                        if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                                            local tHydrosInRect = EntityCategoryFilterDown(M28UnitInfo.refCategoryHydro, tUnitsInRect)
                                            if M28Utilities.IsTableEmpty(tHydrosInRect) == false then
                                                for iExistingHydro, oExistingHydro in tHydrosInRect do
                                                    if M28UnitInfo.IsUnitValid(oExistingHydro) and not(oExistingHydro == oUnit) then
                                                        bHaveHydroOnPoint = true
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Have another hydro unit blocking this hydro point so wont mark it as available, oExistingHydro='..oExistingHydro.UnitId..M28UnitInfo.GetUnitLifetimeCount(oExistingHydro)) end
                                                        break
                                                    end
                                                end
                                            end
                                        end
                                        if not(bHaveHydroOnPoint) then
                                            table.insert(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations], tHydroLocation)
                                        end
                                        break
                                    end
                                end
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                            --Record mex position first as it is a forked thread so may lose position if the unit dies; however ignore if looks like an upgrading mex unit
                            if bDebugMessages == true then LOG(sFunctionRef..': We have a mex that has died, checking if it was the upgrading element, .CanTakeDamage='..tostring(oUnit.CanTakeDamage or false)..'; .IsUpgrade='..tostring(oUnit.IsUpgrade or false)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Owner='..oUnit:GetAIBrain().Nickname) end
                            if not(oUnit.CanTakeDamage == false and oUnit.IsUpgrade == true) then
                                local tMexPosition = {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]}
                                if bDebugMessages == true then LOG(sFunctionRef..': About to call OnMexDeath via fork, tMexPosition='..repru(tMexPosition)) end
                                if tMexPosition[1] == 0 and tMexPosition[2] == 0 then M28Utilities.ErrorHandler('Dont have a valid mex position - mex is showing as 0,0,0') end
                                ForkThread(M28Building.OnMexDeath, tMexPosition, (oUnit.UnitId or 'nil'), (M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil'), oUnit:GetAIBrain():GetArmyIndex(), oUnit:GetFractionComplete() == 1) --Need to fork thread or else get an error when try to wait in the building logic
                            elseif oUnit:GetFractionComplete() == 1 then
                                --Rare case where a constructed unit showed in LOUD with .IsUpgrade as true and .CanTakeDamage as false
                                ForkThread(M28Building.ConsiderDelayedOnMexDeathCall, {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]}, (oUnit.UnitId or 'nil'), (M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil'), oUnit:GetAIBrain():GetArmyIndex(), oUnit:GetAIBrain().M28Team, true)
                            end
                            --[[local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZOrWZMexLocations]) == false then
                                for iMexLocation, tMexLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZOrWZMexLocations] do
                                    --Prev line - redid at same time as changing approach for removing an unbuilt location to try and be more accurate
                                    --if M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition()) <= 0.9 then
                                    --Revised line:
                                    if math.abs(tMexLocation[1] - oUnit:GetPosition()[1]) < 0.9 and math.abs(tMexLocation[3] - oUnit:GetPosition()[3]) < 0.9 then
                                        table.insert(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations], tMexLocation)
                                        break
                                    end
                                end
                            end--]]
                            --Radar intel coverage update
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryRadar, oUnit.UnitId) then
                            ForkThread(M28Land.UpdateRadarCoverageForDestroyedRadar, oUnit)
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySonar, oUnit.UnitId) then
                            ForkThread(M28Navy.UpdateSonarCoverageForDestroyedSonar, oUnit)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryWall, oUnit.UnitId) and not(oUnit:GetAIBrain().M28AI) then
                            M28Land.TrackWallSegment(oUnit, false)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) then
                            --For each M28 team with active M28AI consider if we have a firebase
                            M28Land.ConsiderIfAnyEnemyTeamsStillHaveFirebaseOnT2ArtiDeath(oUnit)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryTMD + M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                            if EntityCategoryContains(M28UnitInfo.refCategoryTMD, oUnit.UnitId) then
                                M28Building.TMDDied(oUnit)
                            else
                                M28Building.TMLDied(oUnit)
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySMD, oUnit.UnitId) then
                            if oUnit:GetFractionComplete() == 1 then
                                --Go through each team other team with M28 in it, and if they have nukes with loaded missiles, consider firing immediately
                                for iTeam = 1, M28Team.iTotalTeamCount do
                                    if (M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or 0) > 0 then
                                        ForkThread(M28Building.ConsiderFiringFirstLoadedNukeOnTeam, iTeam)
                                    end
                                end
                            end
                        end

                        --Fixed shields
                        if M28Utilities.IsTableEmpty(oUnit[M28Building.reftoUnitsCoveredByShield]) == false then
                            M28Building.UpdateShieldCoverageOfUnits(oUnit, true)
                            --Units having shield coverage - update the shield table
                        elseif oUnit[M28Building.reftoShieldsProvidingCoverage] and M28Utilities.IsTableEmpty(oUnit[M28Building.reftoShieldsProvidingCoverage]) == false then
                            for iShield, oShield in oUnit[M28Building.reftoShieldsProvidingCoverage] do
                                if M28UnitInfo.IsUnitValid(oShield) and M28Utilities.IsTableEmpty(oShield[M28Building.reftoUnitsCoveredByShield]) == false then
                                    for iEntry, oEntry in oShield[M28Building.reftoUnitsCoveredByShield] do
                                        if oEntry == oUnit then
                                            table.remove(oShield[M28Building.reftoUnitsCoveredByShield], iEntry)
                                            break
                                        end
                                    end
                                end
                            end
                        end

                        --Ythotha deathball avoidance
                        --Note -seraphimunits.lua contains SEnergyBallUnit which looks like it is for when the death ball is spawned; ID is XSL0402; SpawnElectroStorm is in the ythotha script
                        --Sandbox test - have c.36s from ythotha dying to energy ball dying, so want to run away for half of this (18s) plus extra time based on how far away we already were
                        if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental * categories.SERAPHIM, oUnit.UnitId) then
                            OnYthothaDeath(oUnit)
                        end
                        if EntityCategoryContains(categories.STRUCTURE + categories.EXPERIMENTAL -M28UnitInfo.refCategoryMex -M28UnitInfo.refCategoryHydro, oUnit.UnitId) and (EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) or oUnit:GetFractionComplete() < 1) then
                            if oUnit[M28Engineer.reftUnitBlacklistSegmentXZ] then --EntityCategoryContains(categories.EXPERIMENTAL * categories.MOBILE - M28UnitInfo.refCategoryExperimentalArti, oJustBuilt.UnitId) then
                                --Treat area around experimental under construction as available again
                                M28Engineer.ClearBlacklistForUnitConstructed(oUnit)
                            end
                            M28Engineer.SearchForBuildableLocationsNearDestroyedBuilding(oUnit)
                        end

                        --Campaign specific - upgrading structure that isn't yet complete
                        if M28Map.bIsCampaignMap and oUnit[M28UnitInfo.refbObjectiveUnit] and not(oUnit[refbAlreadyRunUnitKilled]) and oUnit:GetFractionComplete() < 1 and oUnit:GetAIBrain().CampaignAI and oUnit.DoUnitCallbacks and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) then
                            oUnit:DoUnitCallbacks('OnKilled')
                        end

                        -------M28 specific logic---------
                        if bDebugMessages == true then LOG(sFunctionRef..': About to consider M28specific on death logic, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Owned by brain '..oUnit:GetAIBrain().Nickname..'; Is M28='..tostring(oUnit:GetAIBrain().M28AI or false)) end
                        --Is the unit owned by M28AI?
                        if oUnit:GetAIBrain().M28AI then
                            --Air units - remove any assigned strike damage
                            if oUnit[M28Air.refoStrikeDamageAssigned] then
                                M28Air.RemoveAssignedAttacker(oUnit[M28Air.refoStrikeDamageAssigned], oUnit)
                            end
                            --Air scout death - record the target zone as dangerous
                            if oUnit[M28Air.reftScoutAssignedPlateauAndZoneRef] then
                                M28Air.OnAirScoutDeath(oUnit)
                            end
                            --Transport death - record target island as dangerous
                            if oUnit[M28Air.refiTargetIslandForDrop] then
                                local iTeam = oUnit:GetAIBrain().M28Team
                                local iTargetIsland = oUnit[M28Air.refiTargetIslandForDrop]
                                M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandDropTime][iTargetIsland] = GetGameTimeSeconds()
                                if oUnit[M28Air.refiTargetZoneForDrop] then
                                    if not(M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime][iTargetIsland]) then
                                        if not(M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime]) then M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime] = {} end
                                        M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime][iTargetIsland] = {}
                                    end
                                    M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime][iTargetIsland][oUnit[M28Air.refiTargetZoneForDrop]] = GetGameTimeSeconds()
                                end
                            elseif oUnit[M28Air.refiTargetZoneForDrop] then --presumably a water zone if it has no island ref
                                local iTeam = oUnit:GetAIBrain().M28Team
                                if not(M28Team.tTeamData[iTeam][M28Team.refiLastFailedWaterZoneDropTime]) then M28Team.tTeamData[iTeam][M28Team.refiLastFailedWaterZoneDropTime] = {} end
                                M28Team.tTeamData[iTeam][M28Team.refiLastFailedWaterZoneDropTime][oUnit[M28Air.refiTargetZoneForDrop]] = GetGameTimeSeconds()
                            end

                            --Logic that doesnt require the unit to ahve finished construction:

                            --Fixed shielding
                            if oUnit[M28Building.refbUnitWantsShielding] or oUnit[M28Building.reftoUnitsCoveredByShield] then --or oUnit[M28Building.reftoShieldsProvidingCoverage] then
                                --[[if oUnit[M28Building.reftoUnitsCoveredByShield] then
                                    --M28Building.UpdateShieldCoverageOfUnits(oUnit, true) --Already done above for all ai now --]]
                                --else
                                M28Building.CheckIfUnitWantsFixedShield(oUnit) --I.e. if a fixed hsield has died that is owned by M28, then want to run this function so can reassess if we hae any units that now want shielding
                                --end
                            end

                            --Gameender build tracker
                            if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder, oUnit.UnitId) then M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiFriendlyGameEnderCount] = math.max(0, (M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiFriendlyGameEnderCount] or 0) - 1) end

                            --GE template shielding
                            if oUnit[M28Building.reftArtiTemplateRefs] then
                                if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oUnit.UnitId) then
                                    local tArtiTemplate = M28Map.tAllPlateaus[oUnit[M28Building.reftArtiTemplateRefs][1]][M28Map.subrefPlateauLandZones][oUnit[M28Building.reftArtiTemplateRefs][2]][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftActiveGameEnderTemplates][oUnit[M28Building.reftArtiTemplateRefs][3]]
                                    if tArtiTemplate then
                                        tArtiTemplate[M28Map.subrefGEbDontNeedEngineers] = false
                                        --also set to false in 5s due ot building animation
                                        M28Utilities.DelayChangeVariable(tArtiTemplate, M28Map.subrefGEbDontNeedEngineers, false, 5)
                                    end
                                    --Update shieldSACUs if this is a UEF SACU
                                elseif EntityCategoryContains(categories.UEF * categories.SUBCOMMANDER, oUnit.UnitId) then
                                    local tArtiTemplate = M28Map.tAllPlateaus[oUnit[M28Building.reftArtiTemplateRefs][1]][M28Map.subrefPlateauLandZones][oUnit[M28Building.reftArtiTemplateRefs][2]][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][M28Map.reftActiveGameEnderTemplates][oUnit[M28Building.reftArtiTemplateRefs][3]]
                                    if tArtiTemplate and M28Utilities.IsTableEmpty(tArtiTemplate[M28Map.subreftoGEShieldSACUs]) == false then
                                        for iSACU, oSACU in tArtiTemplate[M28Map.subreftoGEShieldSACUs] do
                                            if oSACU == oUnit then table.remove(tArtiTemplate[M28Map.subreftoGEShieldSACUs], iSACU) break end
                                        end
                                    end
                                end
                            end

                            --Special tracking e.g. for factions and shields and game enders - update
                            if oUnit[M28Building.refoNearbyFactoryOfFaction] then --i.e. gameender that wants a factory's engineers - the gameender is dead so want to clear entries for it
                                M28Building.ClearTrackingOfDeadUnitWantingFactoryEngineers(oUnit)
                            end
                            if oUnit[M28Building.reftoUnitsWantingFactoryEngineers] then --i.e. a factory that was down as the one providing engineers to a gameender - want to find a new factory
                                M28Building.UpdateTrackingOfDeadFactoryProvidingEngineers(oUnit)
                            end

                            --PD specific - stop trying to build here (in case we have far away engineers still trying to build at this location for this unit)
                            if EntityCategoryContains(M28UnitInfo.refCategoryPD, oUnit.UnitId) then
                                M28Engineer.ConsiderClearingEngineersForUnitJustDamagedOrDestroyed(oUnit, M28Engineer.refActionBuildEmergencyPD)
                            end

                            --Run unit type specific on death logic where the unit is completed
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if need to run certain M28AI on death logic, unit fraction ocmplete='..oUnit:GetFractionComplete()) end
                            if oUnit:GetFractionComplete() == 1 then
                                M28Economy.UpdateGrossIncomeForUnit(oUnit, true) --Dont fork thread
                                --Dropped units - flag that this island is dangerous if were dropped recently
                                if oUnit[M28Air.refiLastIslandDrop] and oUnit[M28Air.refiTimeLastDropped] and GetGameTimeSeconds() - oUnit[M28Air.refiTimeLastDropped] <= 90 then
                                    local iTeam = oUnit:GetAIBrain().M28Team
                                    if not(M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandDropTime]) then M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandDropTime] = {} end
                                    --Check we dont still have factories or signif structures here
                                    local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                    if (tLZOrWZTeamData[M28Map.subrefLZSValue] or 0) < 1000 and (tLZOrWZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0) < 100 then
                                        local bHaveCompletedFactory = false
                                        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                            local tFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                            if M28Utilities.IsTableEmpty(tFactories) == false then
                                                for iFactory, oFactory in tFactories do
                                                    if M28UnitInfo.IsUnitValid(oFactory) and oFactory:GetFractionComplete() == 1 then
                                                        bHaveCompletedFactory = true
                                                        break
                                                    end
                                                end
                                            end
                                        end
                                        if not(bHaveCompletedFactory) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Recording that island '..(oUnit[M28Air.refiLastIslandDrop] or 'nil')..' is dangerous as we just had a previously dropped unit die here') end
                                            M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandDropTime][oUnit[M28Air.refiLastIslandDrop]] = GetGameTimeSeconds()
                                        end
                                    end
                                end


                                if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                                    M28Engineer.ClearEngineerTracking(oUnit)
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryScathis, oUnit.UnitId) then
                                    if M28Utilities.IsTableEmpty(M28Engineer.tAllScathis) == false then
                                        for iScathis, oScathis in M28Engineer.tAllScathis do
                                            if oScathis == oUnit then
                                                table.remove(M28Engineer.tAllScathis, iScathis) --Only doing this once so can get away with using table.remove, otherwise would want to use M28Utilities.ArrayRemove
                                                break
                                            end
                                        end
                                    end
                                elseif EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                                    --Check for upgrades
                                    --Upgrade tracking (even if have run this already)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will check if upgrade tracking needs updating, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                    M28Team.UpdateUpgradeTrackingOfUnit(oUnit, true)
                                    if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                                        M28Economy.UpdateZoneM28MexByTechCount(oUnit, true)
                                        --Update upgrading mexes
                                        M28Economy.UpdateTableOfUpgradingMexesForTeam(oUnit:GetAIBrain().M28Team)
                                        --Losing HQ but have a teammate of the relevant faction with better tech
                                    elseif EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories - categories.TECH1, oUnit.UnitId) then
                                        if M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.subrefiActiveM28BrainCount] > 1 then
                                            ForkThread(M28Team.ConsiderGiftingSupportFactoriesToTeammateWithBetterHQ, oUnit:GetAIBrain(), oUnit.UnitId)
                                        end
                                    elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedShield - categories.TECH2 - categories.TECH1, oUnit.UnitId) then
                                        --Shield tracking
                                        local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, oUnit:GetAIBrain().M28Team)
                                        if tLZTeamData then
                                            tLZTeamData[M28Map.subrefiT3FixedShieldConstructedCount] = math.max(0, (tLZTeamData[M28Map.subrefiT3FixedShieldConstructedCount] or 0) - 1)
                                            if oUnit:GetBlueprint().Defense.Shield.ShieldMaxHealth >= M28Building.iExperimentalShieldHealthValue then
                                                tLZTeamData[M28Map.subrefiExperimentalShieldConstructedCount] = math.max(0, (tLZTeamData[M28Map.subrefiExperimentalShieldConstructedCount] or 0) - 1)
                                            end
                                        end
                                    end
                                    M28Economy.UpdateHighestFactoryTechLevelForDestroyedUnit(oUnit) --checks if it was a factory as part of this function

                                elseif EntityCategoryContains(M28UnitInfo.refCategoryMobileLand, oUnit.UnitId) then
                                    --If unit was traveling to another land zone, then update that land zone so it no longer things the unit is traveling here
                                    M28Land.RemoveUnitFromListOfUnitsTravelingToLandZone(oUnit) --(this will check if it was or not)
                                end

                                --Mobile shield update
                                if oUnit[M28Land.refoAssignedMobileShield] then
                                    oUnit[M28Land.refoAssignedMobileShield][M28Land.refoMobileShieldTarget] = nil
                                end
                                if oUnit[M28Land.refoMobileShieldTarget] then
                                    oUnit[M28Land.refoMobileShieldTarget][M28Land.refoAssignedMobileShield] = nil
                                end
                            else
                                --Fraction complete is <1
                                if EntityCategoryContains(M28UnitInfo.refCategoryFactory, oUnit.UnitId) then
                                    M28Economy.UpdateHighestFactoryTechLevelForDestroyedUnit(oUnit) --still want to consider due to issue had where ACU was rebuilding only land fac was part-compelte, it got destroyed, but it thought it had T1 land fac available
                                end
                            end
                            --Update record of units with disabled weapons
                            if oUnit[M28UnitInfo.refbWeaponDisabled] then
                                local iTeam = oUnit:GetAIBrain().M28Team
                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons]) == false then
                                    for iRecorded, oRecorded in M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons] do
                                        if oRecorded == oUnit then
                                            table.remove(M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons], iRecorded)
                                            break
                                        end
                                    end
                                end
                            end

                            if oUnit[M28Building.refbActiveOpticsManager] then
                                local iTeam = oUnit:GetAIBrain().M28Team
                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoAlliedQuantumOptics]) == false then
                                    for iRecorded, oRecorded in M28Team.tTeamData[iTeam][M28Team.reftoAlliedQuantumOptics] do
                                        if oUnit == oRecorded then
                                            table.remove(M28Team.tTeamData[iTeam][M28Team.reftoAlliedQuantumOptics], iRecorded)
                                            break
                                        end
                                    end
                                end
                            end

                            --If unit was paused, update the table
                            if oUnit[M28UnitInfo.refiPausedPriority] then
                                M28UnitInfo.AddOrRemoveUnitFromListOfPausedUnits(oUnit, false)
                            end

                            --Primary naval fac - remove
                            if oUnit[M28Factory.refbPrimaryFactoryForIslandOrPond] and EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oUnit.UnitId) then
                                local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnit:GetPosition())
                                local iPond = M28Map.tPondBySegment[iSegmentX][iSegmentZ]
                                if iPond then
                                    local iTeam = oUnit:GetAIBrain().M28Team

                                    if not(M28UnitInfo.IsUnitValid(M28Team.tTeamData[iTeam][M28Team.refoPrimaryPondNavalFactory][iPond])) or M28Team.tTeamData[iTeam][M28Team.refoPrimaryPondNavalFactory][iPond] == oUnit then
                                        M28Team.tTeamData[iTeam][M28Team.refoPrimaryPondNavalFactory][iPond] = nil
                                    end
                                end
                            end
                        else
                            --Specific logic to apply only if the unit is not owned by M28
                            if oUnit[M28UnitInfo.reftiTeamsRecordedAsNonM28Ally] and EntityCategoryContains(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                                local sTeamDataRef
                                if EntityCategoryContains(M28UnitInfo.refCategoryFactory, oUnit.UnitId) then
                                    sTeamDataRef = M28Map.refiNonM28TeammateFactoryCount
                                else
                                    sTeamDataRef = M28Map.refiNonM28TeammateMexCount
                                end

                                for _, iTeam in oUnit[M28UnitInfo.reftiTeamsRecordedAsNonM28Ally] do
                                    local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                    if tLZOrWZTeamData then
                                        tLZOrWZTeamData[sTeamDataRef] = math.max(0, (tLZOrWZTeamData[sTeamDataRef] or 0) - 1)
                                    end
                                end
                            end
                            if oUnit[M28UnitInfo.refbNonM28ExpConstruction] then
                                local iTeam = oUnit:GetAIBrain().M28Team
                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoNonM28ConstructingExpAndT3Navy]) == false then
                                    for iRecordedUnit, oRecordedUnit in M28Team.tTeamData[iTeam][M28Team.reftoNonM28ConstructingExpAndT3Navy] do
                                        if oRecordedUnit == oUnit then
                                            table.remove(M28Team.tTeamData[iTeam][M28Team.reftoNonM28ConstructingExpAndT3Navy], iRecordedUnit)
                                            break
                                        end
                                    end
                                end
                                oUnit[M28UnitInfo.refbNonM28ExpConstruction] = false
                            end
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        end
    end

--function OnWorkEnd(self, work)
    --Have commented out the line that calls this since not currently using it

    --Not sure when/if this even triggers - would need to review if plan to use
    --LOG('WOrk end has finished for self='..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self)..'; work reprs='..reprs(work))
--end

function OnEnhancementStarted(self, work)
    --e.g. returns log like OnEhancementStarted start, self.UnitId==url0001; work="CoolingUpgrade"
    if M28Utilities.bM28AIInGame then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnEnhancementStarted'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': start, self.UnitId=='..(self.UnitId or 'nil')..'; work='..reprs(work)..'; owner='..self:GetAIBrain().Nickname..' on team='..self:GetAIBrain().M28Team) end
        self[M28UnitInfo.refsLastEnhancementStarted] = work
        if work == 'Teleporter' and self.GetAIBrain then
            local iACUTeam = self:GetAIBrain().M28Team
            for iTeam = 1, M28Team.iTotalTeamCount do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering team '..iTeam..' with M28Brain count='..(M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or 'nil')) end
                if not(iTeam == iACUTeam) and M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 0 then
                    local oFirstBrain = M28Team.GetFirstActiveM28Brain(iTeam)
                    if bDebugMessages == true then LOG(sFunctionRef..': Is first M28 brain an enemy of the ACU that compelted an enhancement='..tostring(IsEnemy(self:GetAIBrain():GetArmyIndex(), M28Team.GetFirstActiveM28Brain(iTeam):GetArmyIndex()))) end
                    if oFirstBrain.GetArmyIndex and not(oFirstBrain.M28IsDefeated) and IsEnemy(self:GetAIBrain():GetArmyIndex(), M28Team.GetFirstActiveM28Brain(iTeam):GetArmyIndex()) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will monitor for when enemy starts ont eleport upgrade') end
                        ForkThread(M28Team.MonitorEnemyTeleportUpgrade, self, iTeam, work)
                    end
                end
            end
        end
    end
end

function OnEnhancementComplete(oUnit, sEnhancement)
    if M28Utilities.bM28AIInGame then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnEnhancementComplete'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        --Check we haven't just run this
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Time we last completed sEnhancmeent '..sEnhancement..' for oUnit owned by player '..oUnit:GetAIBrain().Nickname..'='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.reftiTimeOfLastEnhancementComplete][sEnhancement] or -100)..'; Upgrade count before update='..(oUnit[M28ACU.refiUpgradeCount] or 'nil')) end
        if GetGameTimeSeconds() - (oUnit[M28UnitInfo.reftiTimeOfLastEnhancementComplete][sEnhancement] or -100) >= 0.5 then
            --Clear micro flag as we set it to true for some units to avoid orders overriding
            if oUnit[M28UnitInfo.refbSpecialMicroActive] then oUnit[M28UnitInfo.refbSpecialMicroActive] = nil end
            if not(oUnit[M28UnitInfo.reftiTimeOfLastEnhancementComplete]) then oUnit[M28UnitInfo.reftiTimeOfLastEnhancementComplete] = {} end
            if oUnit[M28ACU.refbWantsPriorityUpgrade] then oUnit[M28ACU.refbWantsPriorityUpgrade] = nil end
            oUnit[M28UnitInfo.reftiTimeOfLastEnhancementComplete][sEnhancement] = GetGameTimeSeconds()
            if bDebugMessages == true then LOG(sFunctionRef..': Enhancement completed for self='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..'; sEnhancement='..reprs(sEnhancement)..'; Has enhancement for this='..tostring(oUnit:HasEnhancement(sEnhancement))..'; Unit DF range pre upgrade='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')) end
            M28UnitInfo.UpdateUnitCombatMassRatingForUpgrades(oUnit)
            local iDFRangePreUpgrade = (oUnit[M28UnitInfo.refiDFRange] or 0)
            M28UnitInfo.RecordUnitRange(oUnit) --Refresh the range incase enhancement has increased anything
            if (oUnit[M28UnitInfo.refiDFRange] or 0) > iDFRangePreUpgrade and oUnit[M28UnitInfo.refiDFRange] >= 30 and not(oUnit.Dead) and oUnit:GetAIBrain().M28AI then
                M28Land.ConsiderPriorityLandScoutFlag(oUnit)
            end
            --LOUD specific - manually reflect weapon ranges for the basic gun upgrades as arent recorded against the blueprint
            if (M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) and (oUnit[M28UnitInfo.refiDFRange] or 0) < 30 then
                local tsOtherUpgradeNames = {
                    'EXRipperBooster',
                    'EXZephyrBooster',
                    'EXChronotronBooster',
                    'EXDisruptorrBooster',
                }
                for iUpgrade, sUpgrade in tsOtherUpgradeNames do
                    if oUnit:HasEnhancement(sUpgrade) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Adjusting unit range for LOUD/QUIET enhancement, DFRange pre increase='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; iDFRangePreUpgrade='..iDFRangePreUpgrade) end
                        oUnit[M28UnitInfo.refiDFRange] = (oUnit[M28UnitInfo.refiDFRange] or 0) + 5
                        break
                    end
                end
            end
            if (oUnit[M28UnitInfo.refiDFRange] or 0) > iDFRangePreUpgrade then
                M28Overseer.bLikelyGunUpgrade = true
            end

            --Mobile TML logic (e.g. ACU and SACU, and billy nuke) - note some manual ranges are e.g. for overcharge
            if (oUnit[M28UnitInfo.refiManualRange] or 0) > 50 then
                --Record this against every opposing M28 Team
                if bDebugMessages == true then LOG(sFunctionRef..': have unit with tml upgrade, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                ForkThread(M28Team.RecordMobileTMLThreatForAllEnemyTeams, oUnit)
            end

            --Update upgrade count
            oUnit[M28ACU.refiUpgradeCount] = (oUnit[M28ACU.refiUpgradeCount] or 0) + 1
            if EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oUnit.UnitId) then
                if sEnhancement == 'Teleporter' then
                    if bDebugMessages == true then LOG(sFunctionRef..': Flagging that unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has got teleporter upgrade and setting weapon prioritisation accordingly') end
                    oUnit[M28ACU.refbACUHasTeleport] = true
                    if ScenarioInfo.Options.Victory == "demoralization" then
                        M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityTeleSnipeInclACU, false)
                    else
                        M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityTeleSnipeExclACU, false)
                    end
                elseif sEnhancement == 'AdvancedEngineering' then
                    oUnit[M28ACU.refiBuildTech] = 2
                elseif sEnhancement == 'T3Engineering' then
                    oUnit[M28ACU.refiBuildTech] = 3
                elseif sEnhancement == 'AdvancedEngineeringRemove' then
                    oUnit[M28ACU.refiBuildTech] = 1
                elseif sEnhancement == 'T3EngineeringRemove' then
                    oUnit[M28ACU.refiBuildTech] = 1
                elseif  sEnhancement == 'StealthGenerator' or sEnhancement == 'FAF_SelfRepairSystem' or sEnhancement == 'CloakingGenerator' then
                    if oUnit[M28Land.refoAssignedMobileStealth] then
                        oUnit[M28Land.refoAssignedMobileStealth][M28Land.refoMobileStealthTarget] = nil
                    end
                    --Have all enemy M28 teams send air scouts to keep an eye on this unit
                    for iTeam = 1, M28Team.iTotalTeamCount do
                        if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 0 then
                            ForkThread(M28Air.MonitorEnemyACUForScoutPrioritisation,oUnit, iTeam)
                        end
                    end
                    --Treat enemies with laser com or seraphim gun as being land experimentals so they are seen as greater threat
                elseif sEnhancement == 'MicrowaveLaserGenerator' or sEnhancement == 'BlastAttack' then
                    --double-check the upgrade mass cost indicates it is a deadly upgrade
                    local iUpgradeMassCost = oUnit:GetBlueprint().Enhancements[sEnhancement].BuildCostMass
                    if bDebugMessages == true then LOG(sFunctionRef..': Have got laser or sera gun, iUpgradeMassCost='..iUpgradeMassCost) end
                    if iUpgradeMassCost >= 3000 then
                        --Every other team - add to bigthreat table
                        local iOurTeam = oUnit:GetAIBrain().M28Team
                        for iTeam = 1, M28Team.iTotalTeamCount do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering adding to big threat table for iTeam='..iTeam..'; M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]='..M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]..'; Team of the ACU='..iOurTeam) end
                            if not(iOurTeam == iTeam) and M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 0 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Adding to big threat table') end
                                M28Team.AddUnitToBigThreatTable(iTeam, oUnit)
                            end
                        end
                    end
                    --Enable autoovercharge if this is an M28ACU and flag we dont want to manually overcharge
                    if oUnit.SetAutoOvercharge and oUnit:GetAIBrain().M28AI and (M28Orders.bDontConsiderCombinedArmy or oUnit.M28Active) then
                        oUnit:SetAutoOvercharge(true)
                        oUnit[M28UnitInfo.refbDisableOvercharge] = true
                    end
                end
                if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                    --Consider being more aggressive with ACU again (mainly relevant for team games)
                    oUnit[M28ACU.refbUseACUAggressively] = M28ACU.DoWeStillWantToBeAggressiveWithACU(oUnit)
                end
                --Flag that enemy has a dangerous ACU if they have multiple combat upgrades
                if oUnit[M28ACU.refiUpgradeCount] >= 2 and (oUnit[M28UnitInfo.refiDFMassThreatOverride] or 0) - M28UnitInfo.iBaseACUThreat >= 1600 and (oUnit:GetMaxHealth() >= M28UnitInfo.iBaseACUExpectedHealth + 2000 or (oUnit.MyShield and oUnit.MyShield:GetMaxHealth() > 0) or oUnit:HasEnhancement('StealthGenerator')) then
                    local iTeamToIgnore = oUnit:GetAIBrain().M28Team
                    for iCurTeam = 1, M28Team.iTotalTeamCount do
                        if not(iCurTeam == iTeamToIgnore) and (M28Team.tTeamData[iCurTeam][M28Team.subrefiActiveM28BrainCount] or 0) > 0 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Flagging that the enemy has a dangerous ACU for team '..iCurTeam..'; due to ACU owned by '..oUnit:GetAIBrain().Nickname..' with upgrade count='..oUnit[M28ACU.refiUpgradeCount]) end
                            M28Team.tTeamData[iCurTeam][M28Team.refbEnemyHasDangerousACU] = true
                        end
                    end
                end


            elseif EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnit.UnitId) then
                oUnit[M28Factory.refbPrimaryFactoryForIslandOrPond] = true --makes sure we dont pause this factory in a mass stall now it has enhancements
            end
            --Fix AIx modifier
            if oUnit:GetAIBrain().CheatEnabled then
                M28UnitInfo.FixUnitResourceCheatModifiers(oUnit)
            end
            if oUnit:GetAIBrain().M28AI then
                if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                    M28ACU.GetUpgradePathForACU(oUnit)
                end
                --Remove any upgrade tracking
                M28Team.UpdateUpgradeTrackingOfUnit(oUnit, true, sEnhancement)
            end
            if sEnhancement == 'CloakingGenerator' then
                --Record in table for enemy teams
                CloakedUnitIdentified(oUnit)
            end
            --Update eco for RAS
            local tEnhancement = oUnit:GetBlueprint().Enhancements[sEnhancement]
            if bDebugMessages == true then LOG(sFunctionRef..': tEnhancement='..reprs(tEnhancement)) end
            if tEnhancement then
                if tEnhancement.ProductionPerSecondEnergy or tEnhancement.ProductionperSecondMass then
                    --Remove existing entries for unit then create new ones
                    M28Economy.UpdateGrossIncomeForUnit(oUnit, true, true)
                    M28Economy.UpdateGrossIncomeForUnit(oUnit, false, false)
                end
            end

            --Teleport details
            if sEnhancement == 'Teleporter' then
                for iCurTeam = 1, M28Team.iTotalTeamCount do
                    if not(iCurTeam == oUnit:GetAIBrain().M28Team) and M28Team.tTeamData[iCurTeam][M28Team.subrefiActiveM28BrainCount] > 0 then
                        M28Team.tTeamData[iCurTeam][M28Team.refbEnemyHasTeleport] = true
                    end
                end
            end

            --Paragon - xfer SACU (disabled as we lose upgrades on transfer as at Aug 25
            --[[if sEnhancement == 'ResourceAllocation' and EntityCategoryContains(categories.SUBCOMMANDER, oUnit.UnitId) and oUnit:GetAIBrain().M28AI and (M28Orders.bDontConsiderCombinedArmy or oUnit.M28Active) and oUnit:GetAIBrain()[M28Economy.refbBuiltParagon] then
                local oLeastMassNonParagonBrain
                local iLeastNetMass = 500
                for iBrain, oBrain in M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.subreftoFriendlyActiveM28Brains] do
                    if not(oBrain[M28Economy.refbBuiltParagon]) and oBrain[M28Economy.refiNetMassBaseIncome] < iLeastNetMass then
                        iLeastNetMass = oBrain[M28Economy.refiNetMassBaseIncome]
                        oLeastMassNonParagonBrain = oBrain
                    end
                end
                if oLeastMassNonParagonBrain then
                    ForkThread(M28Team.TransferUnitsToPlayer, { oUnit }, oLeastMassNonParagonBrain:GetArmyIndex(), false)
                end
            end--]]

            if bDebugMessages == true then LOG(sFunctionRef..': Unit DF range after updating recorded range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')) end
        end
        --if not(oUnit.Dead) and oUnit.SetAutoOvercharge and oUnit:GetAIBrain().M28AI and (M28Orders.bDontConsiderCombinedArmy or oUnit.M28Active) then oUnit:SetAutoOvercharge(false) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function CloakedUnitIdentified(oUnit)
    if M28Utilities.bM28AIInGame then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'CloakedUnitIdentified'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        local iUnitBrainIndex = oUnit:GetAIBrain():GetArmyIndex()
        local tbTeamsConsidered = {}
        for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
            if IsEnemy(oBrain:GetArmyIndex(), iUnitBrainIndex) and not(tbTeamsConsidered[oBrain.M28Team]) then
                local iTeam = oBrain.M28Team
                tbTeamsConsidered[iTeam] = true
                local bAddToTable = true
                if not(M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits]) then
                    M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits] = {}
                else
                    for iRecorded, oRecorded in M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits] do
                        if oRecorded == oUnit then
                            bAddToTable = false
                            break
                        end
                    end
                end
                if bAddToTable then
                    table.insert(M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits], oUnit)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Added unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by brain '..oUnit:GetAIBrain().Nickname..' to table of cloaked units for iTeam='..iTeam..' unless was already recorded, bAddToTable='..tostring(bAddToTable)..'; Time='..GetGameTimeSeconds()) end
            end
        end
        oUnit[M28UnitInfo.refbUnitIsCloaked] = true
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnShieldBubbleDamaged(self, instigator)
    if M28Utilities.bM28AIInGame then
        local oShield = self.Owner
        --LOG('Shield damaged, self='..reprs(self)..'; owner='..reprs(self.Owner))
        if not(oShield.Dead) then
            if oShield:GetAIBrain().M28AI then
                oShield[M28UnitInfo.refiTimeLastDamaged] = GetGameTimeSeconds()
                --If damaged by Aeon T3 arti set a temporary flag
                if instigator.UnitId == 'uab2302' then oShield[M28Building.refiTimeOfLastAeonT3ArtiDamageToShield] = GetGameTimeSeconds() end
            end
            --LOG('instigator='..reprs(instigator))
            if M28UnitInfo.IsUnitValid(instigator) and instigator:GetAIBrain().M28AI and IsEnemy(oShield:GetAIBrain():GetArmyIndex(), instigator:GetAIBrain():GetArmyIndex()) then
                local oUnitCausingDamage
                if instigator and not(instigator:BeenDestroyed()) then
                    if instigator.GetLauncher and instigator:GetLauncher() then
                        oUnitCausingDamage = instigator:GetLauncher()
                    elseif instigator.DamageData and not(instigator.unit) and not(instigator.UnitId) then
                        --Can get errors for artillery shells when running IsProjectile
                    elseif IsProjectile(instigator) or IsCollisionBeam(instigator) then
                        if instigator.unit then
                            oUnitCausingDamage = instigator.unit
                        end
                    elseif IsUnit(instigator) then
                        oUnitCausingDamage = instigator
                    end
                end
                if oUnitCausingDamage and not(oUnitCausingDamage.Dead) then oUnitCausingDamage[M28UnitInfo.refiTimeOfLastUnblockedShot] = GetGameTimeSeconds() end
                if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oShield.UnitId) then
                    if EntityCategoryContains(M28UnitInfo.refCategoryMML, instigator.UnitId) then
                        local iShieldPlateau, iShieldLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oShield:GetPosition())
                        if (iShieldLandZone or 0) > 0 and iShieldPlateau > 0 then
                            local tLZTeamData = M28Map.tAllPlateaus[iShieldPlateau][M28Map.subrefPlateauLandZones][iShieldLandZone][M28Map.subrefLZTeamData][instigator:GetAIBrain().M28Team]
                            tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] = GetGameTimeSeconds()
                            local iMMLPlateau, iMMLZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(instigator:GetPosition())
                            if (iMMLPlateau or 0) > 0 and (iMMLZone or 0) > 0 and not(iMMLZone == iShieldLandZone and iMMLPlateau == iShieldPlateau) then
                                local tMMLLZTeamData = M28Map.tAllPlateaus[iMMLPlateau][M28Map.subrefPlateauLandZones][iMMLZone][M28Map.subrefLZTeamData][instigator:GetAIBrain().M28Team]
                                tMMLLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] = GetGameTimeSeconds()
                            end
                            --LOG('Flagging that we have had missiles intercepted by TMD or shield for iShieldLandZone and MML zone, iShieldLandZone='..(iShieldLandZone or 'nil')..'; iMMLZone='..(iMMLZone or 'nil')..'; iMMLPlateau='..(iMMLPlateau or 'nil'))
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, instigator.UnitId) then
                        --LOG('Cur shield health='..oShield.MyShield:GetHealth())
                        if oShield.MyShield.GetHealth and oShield.MyShield:GetHealth() <= 750 then
                            --Record shield in table of recently failed shields for if we have a novax
                            local iTeam = instigator:GetAIBrain().M28Team
                            local bRecordedAlready
                            if not(M28Team.tTeamData[iTeam][M28Team.reftEnemyShieldsFailedToArti]) then
                                M28Team.tTeamData[iTeam][M28Team.reftEnemyShieldsFailedToArti] = {}
                            else
                                for iEntry, oRecorded in M28Team.tTeamData[iTeam][M28Team.reftEnemyShieldsFailedToArti] do
                                    if oRecorded == oShield then
                                        bRecordedAlready = true
                                        break
                                    end
                                end
                            end
                            if not(bRecordedAlready) then
                                table.insert(M28Team.tTeamData[iTeam][M28Team.reftEnemyShieldsFailedToArti], oShield)
                            end
                        end
                    end
                else
                    --Fatboy specific; if changing threshold here then also change in team
                    if EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oShield.UnitId) then
                        if (oShield[M28Building.refiTMLShotsFired] or 0) > 0 and oUnitCausingDamage.GetAIBrain and oUnitCausingDamage:GetAIBrain().M28AI and EntityCategoryContains(M28UnitInfo.refCategoryTML, oUnitCausingDamage.UnitId) then
                            oShield[M28Building.refiTMLShotsHit] = (oShield[M28Building.refiTMLShotsHit] or 0) + 1
                        end
                        if oShield.MyShield.GetHealth and oShield.MyShield:GetHealth() <= oShield.MyShield:GetMaxHealth() * 0.5 then
                            local iTeam = instigator:GetAIBrain().M28Team
                            local bRecordedAlready
                            if oShield.MyShield:GetHealth() <= 1250 then
                                if not(M28Team.tTeamData[iTeam][M28Team.reftEnemyShieldsFailedToArti]) then
                                    M28Team.tTeamData[iTeam][M28Team.reftEnemyShieldsFailedToArti] = {}
                                else
                                    for iEntry, oRecorded in M28Team.tTeamData[iTeam][M28Team.reftEnemyShieldsFailedToArti] do
                                        if oRecorded == oShield then
                                            bRecordedAlready = true
                                            break
                                        end
                                    end
                                end
                                if not(bRecordedAlready) then
                                    table.insert(M28Team.tTeamData[iTeam][M28Team.reftEnemyShieldsFailedToArti], oShield)
                                end
                            end
                            bRecordedAlready = false
                            if not(M28Team.tTeamData[iTeam][M28Team.reftoVulnerableFatboys]) then M28Team.tTeamData[iTeam][M28Team.reftoVulnerableFatboys] = {}
                            else
                                for iEntry, oRecorded in M28Team.tTeamData[iTeam][M28Team.reftoVulnerableFatboys] do
                                    if oRecorded == oShield then
                                        bRecordedAlready = true
                                        break
                                    end
                                end
                            end
                            if not(bRecordedAlready) then
                                table.insert(M28Team.tTeamData[iTeam][M28Team.reftoVulnerableFatboys], oShield)
                                ForkThread(M28Team.MonitorVulnerableFatboys,iTeam)
                            end
                        end
                    end
                end
            end
        end
    end
end

function OnDamaged(self, instigator) --This doesnt trigger when a shield bubble is damaged - see OnShieldBubbleDamaged for this
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnDamaged'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if self.IsWreckage then
            --Will only update when props and wrecks are destroyed for performance reasons
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Non-wreck damaged') end
            if self.GetUnitId and (not(M28Map.bIsCampaignMap) or GetGameTimeSeconds() >= 300 or not(ScenarioInfo.OpEnded)) then
                local oUnitCausingDamage
                if instigator and not(instigator:BeenDestroyed()) then
                    if instigator.GetLauncher and instigator:GetLauncher() then
                        oUnitCausingDamage = instigator:GetLauncher()
                    elseif instigator.DamageData and not(instigator.unit) and not(instigator.UnitId) then
                        --Can get errors for artillery shells when running IsProjectile
                    elseif IsProjectile(instigator) or IsCollisionBeam(instigator) then
                        if instigator.unit then
                            oUnitCausingDamage = instigator.unit
                        end
                    elseif IsUnit(instigator) then
                        oUnitCausingDamage = instigator
                    end
                    if bDebugMessages == true then
                        if not(oUnitCausingDamage) then LOG(sFunctionRef..': Dont ahve a valid unit as instigator')
                        else LOG(sFunctionRef..': Have a unit causing damage='..oUnitCausingDamage.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitCausingDamage)) end
                    end
                end

                --Logic specific to M28 units dealing damage
                if M28UnitInfo.IsUnitValid(oUnitCausingDamage) and oUnitCausingDamage:GetAIBrain().M28AI then
                    --Update so unit isnt treated as having shot blocked
                    oUnitCausingDamage[M28UnitInfo.refbLastShotBlocked] = false
                    oUnitCausingDamage[M28UnitInfo.refiTimeOfLastUnblockedShot] = GetGameTimeSeconds()
                    if M28UnitInfo.IsUnitValid(self) and (self[M28UnitInfo.refiTargetShotBlockedCount] or 0) > 0 then self[M28UnitInfo.refiTargetShotBlockedCount] = self[M28UnitInfo.refiTargetShotBlockedCount] - 10 end

                    --Unit category specific:
                        --T3/experimental arti specific
                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, oUnitCausingDamage.UnitId) then
                        --Reset the arti shot count if damaged a high value unit
                        if M28UnitInfo.IsUnitValid(self) then
                            if bDebugMessages == true then LOG(sFunctionRef..': T3/Exp arti owned by M28 brain '..oUnitCausingDamage:GetAIBrain().Nickname..', arti unit='..oUnitCausingDamage.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitCausingDamage)..' has just damaged unit '..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self)..' which is valid') end
                            local iUnitDamagedMassValue = (self[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(self)) * self:GetFractionComplete()
                            if iUnitDamagedMassValue >= 700 then
                                --Reduce the ineffective arti shot count
                                local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(self:GetPosition())
                                local tLZOrWZTeamData
                                if iPlateauOrZero > 0 then
                                    tLZOrWZTeamData  = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][oUnitCausingDamage:GetAIBrain().M28Team]
                                else
                                    --Water zone
                                    tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][oUnitCausingDamage:GetAIBrain().M28Team]
                                end
                                local iReductionValue
                                if iUnitDamagedMassValue >= 10000 then
                                    iReductionValue = 50
                                elseif iUnitDamagedMassValue >= 3000 then
                                    iReductionValue = 12
                                else
                                    iReductionValue = 6
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Changing ineffective shot count, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWateZone='..iLandOrWaterZone..'; tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount]='..(tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 'nil')..'; iReductionValue='..iReductionValue) end
                                tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] = math.max(0, (tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 0) - iReductionValue)
                            end
                        end
                        --TML - update shots hit
                    elseif self[M28Building.refiTMLShotsFired] or 0 > 0 and EntityCategoryContains(M28UnitInfo.refCategoryTML, oUnitCausingDamage.UnitId) then
                        self[M28Building.refiTMLShotsHit] = (self[M28Building.refiTMLShotsHit] or 0) + 1
                        --Mobile missile units that have a missed count - record
                    elseif self[M28UnitInfo.refiMissileShotBlockedCount] and oUnitCausingDamage[M28UnitInfo.reftoTargetBlockedMissileCountByEntityId][self.EntityId] then
                        self[M28UnitInfo.refiMissileShotBlockedCount] = math.max(0, self[M28UnitInfo.refiMissileShotBlockedCount] - 8) --Missile ships have quite a high degree of firing randomness, so want to decrease by a lot if we manage to hit
                        oUnitCausingDamage[M28UnitInfo.reftoTargetBlockedMissileCountByEntityId][self.EntityId] = math.max(0, oUnitCausingDamage[M28UnitInfo.reftoTargetBlockedMissileCountByEntityId][self.EntityId] - 3)
                    --Bombers - record that have successfully damaged the target (i.e. that our bomb didnt miss after all)
                    elseif self[M28UnitInfo.refiBombMissedCount] and EntityCategoryContains(M28UnitInfo.refCategoryBomber, oUnitCausingDamage.UnitId) then
                        self[M28UnitInfo.refiBombMissedCount] = nil
                    end
                    if EntityCategoryContains(categories.EXPERIMENTAL, self.UnitId) and self:GetFractionComplete() < 1 and self:GetFractionComplete() > 0.1 then
                        if (M28Orders.bDontConsiderCombinedArmy or oUnitCausingDamage.M28Active) then
                            ForkThread(M28Chat.PartCompleteExperimentalDamaged, self, oUnitCausingDamage)
                        end
                    end
                    --If damaging enemy ACU consider all-in attack to kill it
                    if not(self.Dead) and EntityCategoryContains(categories.COMMAND, self.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryMobileDFLand, oUnitCausingDamage.UnitId) and self:GetHealth() <= 12500 then
                        ForkThread(M28Micro.ConsiderAllInLandPushOnACU, oUnitCausingDamage:GetAIBrain(), self)
                    end
                end

                --Logic specific to M28 units dealt damage
                if self:GetAIBrain().M28AI then
                    if bDebugMessages == true then LOG(sFunctionRef..': M28AI owned unit just taken damage, unit='..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self)..'; Is this a gunship that can refuel='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryGunship - categories.CANNOTUSEAIRSTAGING, self.UnitId) and not(self.MyShield) and not(self[M28UnitInfo.refbProjectilesMeanShouldRefuel]))..'; self.MyShield==nil='..tostring(self.MyShield == nil)..'; self[M28UnitInfo.refbProjectilesMeanShouldRefuel]='..tostring(self[M28UnitInfo.refbProjectilesMeanShouldRefuel] or false)..'; oUnitCausingDamage='..(oUnitCausingDamage.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitCausingDamage) or 'nil')) end
                    if EntityCategoryContains(categories.COMMAND, self.UnitId) then
                        if self:IsUnitState('Upgrading') then
                            --Do we want to cancel the upgrade? If were hit by a TML then want to
                            if M28UnitInfo.IsUnitValid(oUnitCausingDamage) and EntityCategoryContains(M28UnitInfo.refCategoryTML, oUnitCausingDamage.UnitId) then
                                if not(self[M28UnitInfo.refbEasyBrain]) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will cancel upgrade and move away temporarily') end
                                    M28Micro.MoveAwayFromTargetTemporarily(self, 5, oUnitCausingDamage:GetPosition())
                                    self[M28UnitInfo.refiTimeLastCanceledUpgrade] = GetGameTimeSeconds()
                                    local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(self:GetPosition(), true, self:GetAIBrain().M28Team)
                                    self[M28UnitInfo.refiDistToEnemyBaseWhenLastCanceledUpgrade] = M28Utilities.GetDistanceBetweenPositions(self:GetPosition(), tLZTeamData[M28Map.reftClosestEnemyBase])
                                end
                            end
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryPD, self.UnitId) and M28UnitInfo.IsUnitValid(self) and (self:GetFractionComplete() <= 0.7 or (self:GetFractionComplete() <= 0.85 and M28UnitInfo.GetUnitHealthPercent(self) <= 0.5)) and EntityCategoryContains(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryIndirect, oUnitCausingDamage.UnitId) then
                        M28Engineer.ConsiderClearingEngineersForUnitJustDamagedOrDestroyed(self,  M28Engineer.refActionBuildEmergencyPD)
                        --Special voice message for fletcher fatboy damaged by soulripper
                    elseif self[M28Air.refiTargetZoneForDrop] and EntityCategoryContains(M28UnitInfo.refCategoryTransport, self.UnitId) then
                        self[M28UnitInfo.refiTimeLastDamaged] = GetGameTimeSeconds()
                    elseif oUnitCausingDamage.UnitId and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, self.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryGunship * categories.CYBRAN * categories.EXPERIMENTAL, oUnitCausingDamage.UnitId) and self:GetAIBrain()[M28Chat.refiAssignedPersonality] == M28Chat.refiFletcher then
                        if M28Orders.bDontConsiderCombinedArmy or oUnitCausingDamage.M28Active then
                            ForkThread(M28Chat.SendMessage, self:GetAIBrain(), 'SoulripperDmgFatboy', LOC('<LOC X05_M02_240_010>[{i Fletcher}]: Soul Rippers are tearing up my Fatboy! I need air cover, now!'), 1, 600, false, true, 'X05_Fletcher_M02_04945', 'X05_VO')
                        end
                        --Gunships - consider retreating early
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryGunship - categories.CANNOTUSEAIRSTAGING, self.UnitId) and not(self.MyShield) and not(self[M28UnitInfo.refbProjectilesMeanShouldRefuel]) then
                        if M28UnitInfo.IsUnitValid(self) then
                            local iCurHealth = self:GetHealth()
                            local iMaxHealth = self:GetMaxHealth()

                            if bDebugMessages == true then LOG(sFunctionRef..': iCurHealth='..iCurHealth..'; iMaxHealth='..iMaxHealth..'; %='..iCurHealth / iMaxHealth..'; Projectile low health%='..M28Air.GetHealthRunThreshold(iMaxHealth, self)) end
                            if iCurHealth <= iMaxHealth * M28Air.GetHealthRunThreshold(iMaxHealth, self) then
                                self[M28UnitInfo.refbProjectilesMeanShouldRefuel] = true
                                M28Air.SendUnitsForRefueling({ self }, self:GetAIBrain().M28Team, self:GetAIBrain().M28AirSubteam, true)
                                if bDebugMessages == true then LOG(sFunctionRef..'; sent gunship '..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self)..' for refueling due to existing damage taken') end
                            end
                        end
                    end
                    --General - if enemy has non-long range direct fire structure that hit an M28 unit, then check if it is in the same or adjacen tzone, so can record if it isnt
                    if oUnitCausingDamage.GetPosition and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnitCausingDamage.UnitId) and oUnitCausingDamage[M28UnitInfo.refiDFRange] and oUnitCausingDamage[M28UnitInfo.refiDFRange] < 100 and oUnitCausingDamage[M28UnitInfo.refiDFRange] > 0 and self.GetPosition then
                        if oUnitCausingDamage[M28UnitInfo.refiDFRange] < 60 or M28Utilities.GetDistanceBetweenPositions(oUnitCausingDamage:GetPosition(), self:GetPosition()) < 60 then
                            local iPDPlateauOrZero, iPDZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnitCausingDamage:GetPosition())
                            local iDamagedPlateauOrZero, iDamagedZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(self:GetPosition())
                            if not(iPDPlateauOrZero == iDamagedPlateauOrZero and iPDZone == iDamagedZone) and (iPDPlateauOrZero or 0) > 0 and iDamagedPlateauOrZero > 0 then
                                --Arent in the same zone, but are both in land zones are we in an adjacent zone?
                                local tDamagedLZData = M28Map.tAllPlateaus[iDamagedPlateauOrZero][M28Map.subrefPlateauLandZones][iDamagedZone]
                                local bPDIsInAdjacentZone = false
                                if iDamagedPlateauOrZero == iPDPlateauOrZero and M28Utilities.IsTableEmpty(tDamagedLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                    for _, iAdjLZ in tDamagedLZData[M28Map.subrefLZAdjacentLandZones] do
                                        if iAdjLZ == iPDZone then
                                            bPDIsInAdjacentZone = true
                                            break
                                        end
                                    end
                                end
                                if not(bPDIsInAdjacentZone) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have PD in a nearby non-adjacent zone, oUnitCausingDamage='..oUnitCausingDamage.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitCausingDamage)..'; iPDPlateauOrZero='..iPDPlateauOrZero..'; iPDZone='..iPDZone..'; iDamagedPlateauOrZero='..iDamagedPlateauOrZero..'; iDamagedZone='..iDamagedZone..'; Time='..GetGameTimeSeconds()) end
                                    local bAlreadyRecorded = false
                                    if not(tDamagedLZData[M28Map.subrefDangerousNearbyPlateauAndZones]) then
                                        tDamagedLZData[M28Map.subrefDangerousNearbyPlateauAndZones] = {}
                                    else
                                        for iEntry, tPlateauAndZone in tDamagedLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                                            if tPlateauAndZone[2] == iPDZone and tPlateauAndZone[1] == iPDPlateauOrZero then
                                                bAlreadyRecorded = true
                                                break
                                            end
                                        end
                                    end
                                    if not(bAlreadyRecorded) then
                                        table.insert(tDamagedLZData[M28Map.subrefDangerousNearbyPlateauAndZones], {iPDPlateauOrZero, iPDZone})
                                        local tPDLZData = M28Map.tAllPlateaus[iPDPlateauOrZero][M28Map.subrefPlateauLandZones][iPDZone]
                                        if not(tPDLZData[M28Map.subrefDangerousNearbyPlateauAndZones]) then tPDLZData[M28Map.subrefDangerousNearbyPlateauAndZones] = {} end
                                        table.insert(tPDLZData[M28Map.subrefDangerousNearbyPlateauAndZones], {iDamagedPlateauOrZero, iDamagedZone})
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': tDamagedLZData[M28Map.subrefDangerousNearbyPlateauAndZones]='..reprs(tDamagedLZData[M28Map.subrefDangerousNearbyPlateauAndZones])) end
                                end
                            end
                        end
                    end
                end

            end

        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnBombFired(oWeapon, projectile, bIgnoreProjectileCheck)
    --bIgnoreProjectileCheck - if this is true, then will run the main part of the logic even if have fired a bomb recently and have no projectile specified (i.e. intended use is with the redundancy for onweaponfired which calls this logic)
    if M28Utilities.bM28AIInGame then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnBombFired'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
        local oUnit = oWeapon.unit
        if oUnit and oUnit.GetUnitId and (projectile or bIgnoreProjectileCheck or GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastDodgeBombEvent] or 0) >= 2) then
            oUnit[M28UnitInfo.refiLastBombFired] = GetGameTimeSeconds()
            local sUnitID = oUnit.UnitId

            if bDebugMessages == true then LOG(sFunctionRef..': bomber position when firing bomb='..repru(oUnit:GetPosition())..'; Bomber='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Owner='..oUnit:GetAIBrain().Nickname..'; Time='..GetGameTimeSeconds()..'; Time since last bomber event='..(GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastDodgeBombEvent] or 0))) end
            if EntityCategoryContains(M28UnitInfo.refCategoryBomber + M28UnitInfo.refCategoryTorpBomber, sUnitID) then
                --if not(EntityCategoryContains(categories.EXPERIMENTAL, sUnitID)) then
                if GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastDodgeBombEvent] or 0) >= 2 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and dodge the bomb fired by unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                    M28Micro.DodgeBomb(oUnit, oWeapon, projectile)
                end
                --Logic relating to the bomber itself:
                if not(oUnit.Dead) then
                    --Ahwassa and strats - micro the bomber so they turn around and retreat to rally point/nearest base, but dont micro the first couple of strats as the enemy is less likely to have T3 AA (and slowing down to micro could cause them to die to flak)
                    if EntityCategoryContains(categories.EXPERIMENTAL + M28UnitInfo.refCategoryBomber, sUnitID) and ((not(oUnit[M28UnitInfo.refbSpecialMicroActive]) and not(oUnit[M28Air.rebEarlyBomberTargetBase]) and not(oUnit[M28Air.refiBomberTargetNavalEngiWZ])) or not(EntityCategoryContains(categories.TECH1, sUnitID))) then
                        --bombers - micro to turn around and go to rally point
                        if oUnit:GetAIBrain().M28AI then
                            local oTargetUnit = oUnit[M28Orders.reftiLastOrders][M28Orders.subrefoOrderUnitTarget]
                            if M28UnitInfo.IsUnitValid(oUnit) then
                                oUnit[M28UnitInfo.refiBombMissedCount] = ( oUnit[M28UnitInfo.refiBombMissedCount] or 0) + 1
                            end
                            if oUnit[M28Air.refbBomberUsingMexHunterLogic] then
                                ForkThread(M28Air.AttackTargetForMexHuntingBomber, oUnit, true)
                            elseif not(oUnit[M28UnitInfo.refbEasyBrain]) or oUnit.UnitId == 'xsa0402' then
                                --T1 early bomber - disable run away logic
                                if oUnit[M28Air.rebEarlyBomberTargetBase] then
                                    if not(M28UnitInfo.DoesBomberFireSalvo(oUnit)) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Clearing any micro flags we have for the bomber') end
                                        if oUnit[M28UnitInfo.refbSpecialMicroActive] then oUnit[M28UnitInfo.refbSpecialMicroActive] = false end
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': Do nothing as bomber firing a salvo and is a 1st bomber') end
                                    end
                                elseif oUnit[M28Air.refiBomberTargetNavalEngiWZ] then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Do nothing as naval engi bomber') end
                                else
                                    --Track exp bombs fired (relevant for when trying to use our aoe to hit mobile targets safely)
                                    if bDebugMessages == true then LOG(sFunctionRef..': will get bomber to head towards rally point, bomber='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Bomber position='..repru(oUnit:GetPosition())..'; Rally point='..repru(M28Team.tAirSubteamData[oUnit:GetAIBrain().M28AirSubteam][M28Team.reftAirSubRallyPoint])..'; Dist to rally point='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), M28Team.tAirSubteamData[oUnit:GetAIBrain().M28AirSubteam][M28Team.reftAirSubRallyPoint])..'; Angle from bomber to rally='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), M28Team.tAirSubteamData[oUnit:GetAIBrain().M28AirSubteam][M28Team.reftAirSubRallyPoint])..'; Angle from bomber to its owners start position='..M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), M28Map.GetPlayerStartPosition(oUnit:GetAIBrain()))..'; oTargetUnit='..(oTargetUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTargetUnit) or 'nil')) end
                                    if M28UnitInfo.IsUnitValid(oTargetUnit) and EntityCategoryContains(categories.EXPERIMENTAL, sUnitID) then
                                        oTargetUnit[M28Air.refiExpBomberShotCount] = (oTargetUnit[M28Air.refiExpBomberShotCount] or 0) + 1
                                    end

                                    --Decide whether to retreat to air rally point or nearest base; most of the time go to rally, but switch to base if angel to rally is significantly different and has a high mod dist, in case we risk passing by enemy AA on the way
                                    local tRetreatLocation = M28Air.GetRetreatLocationForBomberThatJustFired(oUnit)

                                    if bDebugMessages == true then LOG(sFunctionRef..': Will try turning around to a retreat location if special micro not already active, oUnit[M28UnitInfo.refbSpecialMicroActive]='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive] or false)) end
                                    if not(oUnit[M28UnitInfo.refbSpecialMicroActive]) and M28Utilities.IsTableEmpty(tRetreatLocation) == false then
                                        local iTimeToTurnToRally = 15
                                        if oUnit.UnitId == 'xsa0402' then iTimeToTurnToRally = M28Air.GetTimeForExpBomberToTurnToRally(oUnit, oWeapon, projectile) end
                                        ForkThread(M28Micro.TurnAirUnitAndMoveToTarget, oUnit, tRetreatLocation, iTimeToTurnToRally, 3)
                                    end
                                end
                            end

                            --Have friendly gunships dodge
                            M28Micro.FriendlyGunshipsAvoidBomb(oUnit, oWeapon, projectile)
                        end
                        --T1 bombers targeting enemy ACU when not in snipe mode - consider reassigning/retreating if groundAA or AirAA threat nearby
                    elseif EntityCategoryContains(categories.TECH1 * M28UnitInfo.refCategoryBomber + categories.TECH2 * M28UnitInfo.refCategoryBomber, oUnit.UnitId) and M28Utilities.IsTableEmpty(M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.toActiveSnipeTargets]) then
                        local tLastOrder = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]]
                        local oLastTarget = tLastOrder[M28Orders.subrefoOrderUnitTarget]
                        if M28UnitInfo.IsUnitValid(oLastTarget) and EntityCategoryContains(categories.COMMAND, oLastTarget.UnitId) then
                            --Check we arent close to killing the ACU
                            if oLastTarget:GetHealth() > (oLastTarget[M28Air.refiStrikeDamageAssigned] or 0) * 5 then
                                ForkThread(M28Air.ConsiderIfBomberTargetingACUShouldReassign, oUnit, oLastTarget)
                            end
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

--WARNING: OnWeaponFired and/or OnProjectilfeFired - one of these (probably the latter) resulted in error messages when t1 arti fired, disabled both of them as dont use now

function OnWeaponFired(oWeapon)
    if M28Utilities.bM28AIInGame then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnWeaponFired'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if not(M28Map.bWaterZoneInitialCreation) then
            while GetGameTimeSeconds() < 5 do
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if M28Map.bWaterZoneInitialCreation then break end
            end
        end



        if bDebugMessages == true then LOG(sFunctionRef..': Start of code; does the weapon have a valid unit='..tostring(M28UnitInfo.IsUnitValid(oWeapon.unit))..'; Weapon unitID='..(oWeapon.unit.UnitId or 'nil')..'; oWeapon[M28UnitInfo.refiLastWeaponEvent]='..(oWeapon[M28UnitInfo.refiLastWeaponEvent] or 'nil')..'; reprs='..reprs(oWeapon)..'; oWeapon.Label='..(oWeapon.Label or 'nil')..'; oWeapon.Blueprint.Label='..(oWeapon.Blueprint.Label or 'nil')..'; oWeapon.bp.Label='..(oWeapon.bp.Label or 'nil')..'; Time='..GetGameTimeSeconds()) end
        local oUnit = oWeapon.unit
        if oUnit and oUnit.GetUnitId and oUnit.GetAIBrain and M28UnitInfo.IsUnitValid(oUnit) then

            local oParentBrain = oUnit:GetAIBrain()
            --M28 torp bomber micro (done here as want to make sure we pick up the last weapon event)
            if oParentBrain.M28AI then
                if EntityCategoryContains(M28UnitInfo.refCategoryTorpBomber, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbSpecialMicroActive]) then
                    --Micro torp bombers if this is the last shot and torp only has 1 rack
                    if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..' has just fired a shot, Time='..GetGameTimeSeconds()..'; oWeapon[M28UnitInfo.refiLastWeaponEvent]='..(oWeapon[M28UnitInfo.refiLastWeaponEvent] or 'nil')..'; is salvo data nil='..tostring(oUnit.CurrentSalvoData == nil)..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; Is unit state attacking='..tostring(oUnit:IsUnitState('Attacking'))..'; reprs of Weapon salvo data='..reprs(oWeapon.CurrentSalvoData)..'; Weapon blueprint='..reprs((oWeapon.Blueprint or oWeapon.bp))..'; Is rack size highest value='..tostring((oWeapon.CurrentRackSalvoNumber or 0) >= ((oWeapon.Blueprint or oWeapon.bp).RackSalvoSize or 0))..'; Is salvo size highest value='..tostring((oWeapon.CurrentSalvoNumber or 0) >= ((oWeapon.Blueprint or oWeapon.bp).MuzzleSalvoSize or 0))..'; oWeapon.CurrentRackSalvoNumber='..(oWeapon.CurrentRackSalvoNumber or 'nil')..'; (oWeapon.Blueprint or oWeapon.bp).RackSalvoSize='..(oWeapon.Blueprint or oWeapon.bp).RackSalvoSize..';oWeapon.CurrentSalvoNumber='..(oWeapon.CurrentSalvoNumber or 'nil')..'; Muzzle salvo size='..((oWeapon.Blueprint or oWeapon.bp).MuzzleSalvoSize or 0)) end
                    if (oWeapon.CurrentRackSalvoNumber or 0) >= ((oWeapon.Blueprint or oWeapon.bp).RackSalvoSize or 0) and (oWeapon.CurrentSalvoNumber or 0) >= ((oWeapon.Blueprint or oWeapon.bp).MuzzleSalvoSize or 0) then
                        if not(oUnit[M28UnitInfo.refbEasyBrain]) then
                            ForkThread(M28Micro.TurnAirUnitAndMoveToTarget, oUnit, M28Team.tAirSubteamData[oParentBrain.M28AirSubteam][M28Team.reftAirSubRallyPoint], 25, 1)
                        end
                    end
                elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) then
                    ForkThread(M28Building.ConsiderManualT2ArtiTarget, oUnit, oWeapon)
                    local iTeam = oParentBrain.M28Team
                    local tLZTeamData = M28Map.tAllPlateaus[oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1]][M28Map.subrefPlateauLandZones][oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]][M28Map.subrefLZTeamData][iTeam]
                    if tLZTeamData then tLZTeamData[M28Map.refiTimeOurT2ArtiLastFired] = GetGameTimeSeconds() end
                elseif EntityCategoryContains(M28UnitInfo.refCategoryAirAA, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbSpecialMicroActive]) then
                    --Micro asfs and inties to hover-fire at slower targets
                    if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..' has just fired a shot, Time='..GetGameTimeSeconds()..'; oWeapon[M28UnitInfo.refiLastWeaponEvent]='..(oWeapon[M28UnitInfo.refiLastWeaponEvent] or 'nil')..'; is salvo data nil='..tostring(oUnit.CurrentSalvoData == nil)..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; Is unit state attacking='..tostring(oUnit:IsUnitState('Attacking'))..'; reprs of Weapon salvo data='..reprs(oWeapon.CurrentSalvoData)..'; reprs of weapon='..reprs(oWeapon)..'; Weapon blueprint='..reprs((oWeapon.Blueprint or oWeapon.bp))..'; Is rack size highest value='..tostring((oWeapon.CurrentRackSalvoNumber or 0) >= ((oWeapon.Blueprint or oWeapon.bp).RackSalvoSize or 0))..'; Is salvo size highest value='..tostring((oWeapon.CurrentSalvoNumber or 0) >= ((oWeapon.Blueprint or oWeapon.bp).MuzzleSalvoSize or 0))..'; oWeapon.CurrentRackSalvoNumber='..(oWeapon.CurrentRackSalvoNumber or 'nil')..'; (oWeapon.Blueprint or oWeapon.bp).RackSalvoSize='..(oWeapon.Blueprint or oWeapon.bp).RackSalvoSize..';oWeapon.CurrentSalvoNumber='..(oWeapon.CurrentSalvoNumber or 'nil')..'; Muzzle salvo size='..((oWeapon.Blueprint or oWeapon.bp).MuzzleSalvoSize or 0)) end
                    if (oWeapon.CurrentRackSalvoNumber or 0) >= ((oWeapon.Blueprint or oWeapon.bp).RackSalvoSize or 0) and (oWeapon.CurrentSalvoNumber or 0) >= ((oWeapon.Blueprint or oWeapon.bp).MuzzleSalvoSize or 0) then

                        if not(oUnit[M28UnitInfo.refbEasyBrain]) and not(oUnit:GetAIBrain()[M28Micro.refiMaxUnitsToHoverMicroAtOnce]) then --If have limit on how many units can hover-micro then want to save for bombers, not waste on 1 asf/intie
                            ForkThread(M28Micro.ConsiderAirAAHoverAttackTowardsTarget, oUnit, oWeapon)
                        end
                    end
                end


            end
            if bDebugMessages == true then LOG(sFunctionRef..': Time since last weapon event='..GetGameTimeSeconds() - (oWeapon[M28UnitInfo.refiLastWeaponEvent] or -1)) end
            if not(oWeapon[M28UnitInfo.refiLastWeaponEvent]) or GetGameTimeSeconds() - oWeapon[M28UnitInfo.refiLastWeaponEvent] >= 0.5 then
                oWeapon[M28UnitInfo.refiLastWeaponEvent] = GetGameTimeSeconds()
                oUnit[M28UnitInfo.refiLastWeaponEvent] = GetGameTimeSeconds()
                --Update unit last known position/record it
                for iTeam, tTeam in M28Team.tTeamData do
                    if not(iTeam == oParentBrain.M28Team) then
                        if M28Utilities.IsTableEmpty(tTeam[M28Team.subreftoFriendlyActiveM28Brains]) == false then
                            for iBrain, oBrain in tTeam[M28Team.subreftoFriendlyActiveM28Brains] do
                                M28Team.ConsiderAssigningUnitToZoneForBrain(oBrain, oUnit) --This function includes check of whether this is an M28 brain, and updates last known position
                                break
                            end
                        end
                    end
                end

                --Consider dodging
                if bDebugMessages == true then LOG(sFunctionRef..': About to consider dodging logic and recording non-M28 nuke target locations, weapon.DamageType='..(oWeapon.DamageType or 'nil')..'; (oWeapon.Blueprint or oWeapon.bp).DamageType='..((oWeapon.Blueprint or oWeapon.bp).DamageType or 'nil')..'; Weapon label='..(oWeapon.Label or 'nil')..'; reprs of oWeapon='..reprs(oWeapon)) end
                if EntityCategoryContains(M28UnitInfo.refCategoryBomber, oUnit.UnitId) and ((oWeapon.Label or oWeapon.Blueprint.Label or oWeapon.bp.Label) == 'GroundMissile') then
                    --Corsairs dont trigger the onbombfired event normally hence why we have this
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Weapon fired by corsair, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
                        if oWeapon:GetCurrentTarget().GetPosition then LOG(sFunctionRef..': Target of weapon='..repru(oWeapon:GetCurrentTarget():GetPosition())) end
                    end
                    if GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiLastDodgeBombEvent] or 0) >= 2 then
                        ForkThread(M28Micro.DodgeBomb, oUnit, oWeapon, nil)
                    end
                else
                    if EntityCategoryContains(M28UnitInfo.refCategorySML, oUnit.UnitId) and (oWeapon.Blueprint or oWeapon.bp).DamageType == 'Nuke' then
                        --Nuke missile fired - update the table for non-M28 AI (M28AI will have recorded the target when the order was given)
                        if bDebugMessages == true then LOG(sFunctionRef..': Unit brain='..oUnit:GetAIBrain().Nickname..'; GetCurrentTarget()='..reprs(oWeapon:GetCurrentTarget())..'; GetCurrentTargetPos='..reprs(oWeapon:GetCurrentTargetPos())) end
                        if not(oUnit:GetAIBrain().M28AI) and oWeapon.GetCurrentTargetPos then
                            local iTeam = oUnit:GetAIBrain().M28Team
                            local tCurrentTarget = oWeapon:GetCurrentTargetPos()
                            if M28Utilities.IsTableEmpty(tCurrentTarget) == false then
                                M28Building.RecordNukeTarget(iTeam, tCurrentTarget)
                                if bDebugMessages == true then LOG(sFunctionRef..': Target of weapon='..repru(tCurrentTarget)) end
                            end
                        end
                    end
                    --Dodge logic for certain other attacks (conditions for this are in considerdodgingshot)
                    if bDebugMessages == true then LOG(sFunctionRef..': Will consider whether we want to dodge the shot, oWeapon.unit.UnitId='..(oWeapon.unit.UnitId or 'nil')) end
                    ForkThread(M28Micro.ConsiderDodgingShot, oUnit, oWeapon)
                end

                --Update overcharge tracking
                if oWeapon.GetBlueprint and oWeapon.BeenDestroyed and not(oWeapon:BeenDestroyed()) and oWeapon:GetBlueprint().Overcharge then
                    if bDebugMessages == true then LOG(sFunctionRef..': Overcharge weapon has just fired') end
                    oUnit[M28UnitInfo.refiTimeOfLastOverchargeShot] = GetGameTimeSeconds()
                    if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and oUnit:GetAIBrain().M28AI then
                        --Get another order immediately rather than waiting (means we dont have to try and queue orders up for ACU logic)
                        M28ACU.GetACUOrder(oUnit:GetAIBrain(), oUnit)
                    end
                end

                --M28 owned unit specific logic
                if oUnit:GetAIBrain().M28AI then
                    --Shot is blocked logic
                    if bDebugMessages == true then LOG(sFunctionRef..': COnsidering if unit shot is blocked Time='..GetGameTimeSeconds()..', range category='..((oWeapon.Blueprint or oWeapon.bp).RangeCategory or 'nil')..'; reprs of .RangeCategory='..reprs((oWeapon.Blueprint or oWeapon.bp).RangeCategory)..'; Is unit a relevant DF category='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryMobileDFLand + M28UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE + M28UnitInfo.refCategorySeraphimDestroyer + categories.uas0401 - M28UnitInfo.refCategoryMissileShip, oUnit.UnitId))..'; repr of oWeapon.Blueproint='..reprs((oWeapon.Blueprint or oWeapon.bp))) end
                    local iWeaponRangeCategory = ((oWeapon.Blueprint or oWeapon.bp).RangeCategory)
                    if (iWeaponRangeCategory == 'UWRC_DirectFire' and EntityCategoryContains(M28UnitInfo.refCategoryPD + M28UnitInfo.refCategoryMobileDFLand + M28UnitInfo.refCategoryCombatScout + M28UnitInfo.refCategoryLightAttackBot + M28UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE + M28UnitInfo.refCategorySeraphimDestroyer + categories.uas0401 - M28UnitInfo.refCategoryMissileShip, oUnit.UnitId)) or (iWeaponRangeCategory == 'UWRC_AntiNavy' and EntityCategoryContains(M28UnitInfo.refCategorySubmarine, oUnit.UnitId)) then
                        --Get weapon target if it is a DF weapon or sub torpedo
                        local oTarget
                        if oWeapon.GetCurrentTarget and not(oWeapon:BeenDestroyed()) then oTarget = oWeapon:GetCurrentTarget() end
                        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has just fired a shot. Do we have a valid target for our weapon='..tostring(M28UnitInfo.IsUnitValid(oTarget))..'; time last shot was blocked='..(oUnit[M28UnitInfo.refiTimeOfLastCheck] or 'nil')) end
                        if M28UnitInfo.IsUnitValid(oTarget) then
                            if not(oUnit[M28UnitInfo.refbLastShotBlocked]) then oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] = math.max((oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100), (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) end
                            oUnit[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds()
                            oUnit[M28UnitInfo.refbLastShotBlocked] = M28Logic.IsShotBlocked(oUnit, oTarget, EntityCategoryContains(M28UnitInfo.refCategorySubmarine, oUnit.UnitId))
                            if bDebugMessages == true then LOG(sFunctionRef..': oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Is shot blocked='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked])..'; built in blocking terrain result for low profile='..tostring(oUnit:GetAIBrain():CheckBlockingTerrain(oUnit:GetPosition(), oTarget:GetPosition(), 'Low'))..'; High profile='..tostring(oUnit:GetAIBrain():CheckBlockingTerrain(oUnit:GetPosition(), oTarget:GetPosition(), 'High'))) end

                            if oUnit[M28UnitInfo.refbLastShotBlocked] then
                                --Reset after 20s if we havent fired any more shots at the target
                                --function DelayChangeVariable(oVariableOwner, sVariableName, vVariableValue, iDelayInSeconds, sOptionalOwnerConditionRef, iMustBeLessThanThisTimeValue, iMustBeMoreThanThisTimeValue, vMustNotEqualThisValue)
                                M28Utilities.DelayChangeVariable(oUnit, M28UnitInfo.refbLastShotBlocked, false, 20, M28UnitInfo.refiTimeOfLastCheck, GetGameTimeSeconds() + 0.01)
                                --Increase shot blocked count if this is a longer ranged naval unit firing at a structure
                                if oUnit[M28UnitInfo.refiCombatRange] > 50 and EntityCategoryContains(M28UnitInfo.refCategoryNavalSurface, oUnit.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oTarget.UnitId) then
                                    oTarget[M28UnitInfo.refiTargetShotBlockedCount] = (oTarget[M28UnitInfo.refiTargetShotBlockedCount] or 0) + 1
                                end
                                --PD - consider manual control
                                if EntityCategoryContains(M28UnitInfo.refCategoryPD, oUnit.UnitId) then
                                    ForkThread(M28Building.GetManualPDTarget, oUnit, oTarget)
                                end
                            elseif oUnit[M28UnitInfo.refiCombatRange] > 50 and EntityCategoryContains(M28UnitInfo.refCategoryNavalSurface, oUnit.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oTarget.UnitId) then
                                oTarget[M28UnitInfo.refiTargetShotBlockedCount] = 0
                            end
                        end
                        if EntityCategoryContains(M28UnitInfo.refCategorySMD, oUnit.UnitId) then
                            if oUnit:GetNukeSiloAmmoCount() >= 1 then
                                oUnit[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds() - 240 - M28Building.iTimeForSMDToBeConstructed
                            else
                                oUnit[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds() - M28Building.iTimeForSMDToBeConstructed --For an SMD this will effectively mean we think the SMD isnt loaded anymore; below acts as a basic check to approximate scenarios where SMD has been around a while (ideally if improving on this would just use a dif variable to refiTimeOfLastCheck so can track the actual values wanted)
                            end
                            --If this was an Aeon SMD owned by vendetta personality then send voice taunt
                            if oUnit:GetAIBrain()[M28Chat.refiAssignedPersonality] == M28Chat.refiVendetta and (M28Orders.bDontConsiderCombinedArmy or oUnit.M28Active) then
                                ForkThread(M28Chat.SendMessage, oUnit:GetAIBrain(), 'VendettaSMD', LOC('<LOC X06_T01_560_010>[{i Vendetta}]: Nice try.'), 1, 600, false, true, 'X06_Vedetta_T01_03018', 'X06_VO')
                            end
                        end
                    end
                    --T3 arti targeting logic; TML missile tracking
                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, oUnit.UnitId) then
                        ForkThread(M28Building.GetT3ArtiTarget, oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                        if M28UnitInfo.IsUnitValid(oUnit[M28Building.refoLastTMLTarget]) then
                            oUnit[M28Building.refoLastTMLTarget][M28Building.refiTimeOfLastLaunch] = GetGameTimeSeconds()
                            if bDebugMessages == true then LOG(sFunctionRef..': have set time of last launch to '..oUnit[M28Building.refoLastTMLTarget][M28Building.refiTimeOfLastLaunch]..' for target '..oUnit[M28Building.refoLastTMLTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28Building.refoLastTMLTarget])) end
                        end
                    end
                    --SML, TML and SMD - unpause (if paused)
                    if EntityCategoryContains(M28UnitInfo.refCategorySML + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                        M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, false)
                        --TML and nuke - consider launching missile if have any remaining
                        ForkThread(M28Building.JustFiredMissile, oUnit)
                    end
                end

                --T2 bombers - call OnBombFired event (doesnt fire properly normally since it fires missiles)
                if (oUnit.UnitId == 'dra0202' or (not(M28Utilities.bFAFActive) and (oWeapon.Label or oWeapon.Blueprint.Label or oWeapon.bp.Label) == 'Bomb')) and (not(oUnit[M28UnitInfo.refiLastBombFired]) or GetGameTimeSeconds() - oUnit[M28UnitInfo.refiLastBombFired] > 0.1) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will call onbombfired as a redundancy') end
                    OnBombFired(oWeapon, nil, oUnit.UnitId == 'dra0202')
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

    end
end

--[[function ProjectileFiredAtGround(oProjectile)
    if oProjectile.GetCurrentTargetPosition then
        LOG('TEMP TEST will draw projectile targeting ground target')
        M28Utilities.DrawLocation(oProjectile:GetCurrentTargetPosition(), 2)
    end
end--]]

function ProjectileFiredAtGunship(oTarget, oProjectile)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ProjectileFiredAtGunship'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(oTarget[M28UnitInfo.reftoEnemyProjectiles]) then
        oTarget[M28UnitInfo.reftoEnemyProjectiles] = {}
    end
    table.insert(oTarget[M28UnitInfo.reftoEnemyProjectiles], oProjectile)
    --Estimate total damage to be dealt
    local iTotalDamage = 0
    for iCurProjectile = table.getn(oTarget[M28UnitInfo.reftoEnemyProjectiles]), 1, -1 do
        local oCurProjectile = oTarget[M28UnitInfo.reftoEnemyProjectiles][iCurProjectile]
        if oCurProjectile:BeenDestroyed() then
            table.remove(oTarget[M28UnitInfo.reftoEnemyProjectiles], iCurProjectile)
        else
            iTotalDamage = iTotalDamage + (oCurProjectile.DamageData.DamageAmount or 'nil')
        end
    end

    local iCurHealth = oTarget:GetHealth()
    local iMaxHealth = oTarget:GetMaxHealth()
    if (iCurHealth - iTotalDamage) <= iMaxHealth * M28Air.GetHealthRunThreshold(iMaxHealth, oTarget) then
        oTarget[M28UnitInfo.refbProjectilesMeanShouldRefuel] = true
        M28Air.SendUnitsForRefueling({ oTarget }, oTarget:GetAIBrain().M28Team, oTarget:GetAIBrain().M28AirSubteam, true)
        if bDebugMessages == true then LOG(sFunctionRef..'; sent gunship '..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..' for refueling') end
    end

    --LOG('TEMP oProjectile targeting gunship reprs='..reprs(oProjectile)..'; reprs of damage data='..reprs(oProjectile.DamageData)..'; damageData.DamageAmount='..(oProjectile.DamageData.DamageAmount or 'nil'))
    if bDebugMessages == true then LOG(sFunctionRef..': projectile target='..(oTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTarget) or 'nil')..'; Cur projectile damage='..(oProjectile.DamageData.DamageAmount or 'nil')..'; iTotalDamage='..iTotalDamage..'; iCurHealth='..iCurHealth..'; iMaxHealth='..iMaxHealth..'; oTarget[M28UnitInfo.refbProjectilesMeanShouldRefuel]='..tostring(oTarget[M28UnitInfo.refbProjectilesMeanShouldRefuel] or false)..'; Time='..GetGameTimeSeconds()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ProjectileCreated(oProjectile, inWater)
    --LOG('TEMPCODE projectile created, oProjectile.Launcher.UnitId='..(oProjectile.Launcher.UnitId or 'nil')..'; Is .Launcher nil='..tostring(oProjectile.Launcher == nil)..'; .GetLauncher is nil='..tostring(oProjectile.GetLauncher == nil)..';  oProjectile.BeenDestroyed is nil='..tostring( oProjectile.BeenDestroyed == nil))
    --[[if oProjectile.GetCurrentTargetPosition then
        LOG('TEMPCODE will draw projectile created target')
        M28Utilities.DrawLocation(oProjectile:GetCurrentTargetPosition(), 2)
    end--]]
    if oProjectile.BeenDestroyed and not(oProjectile:BeenDestroyed()) and (not(M28Map.bIsCampaignMap) or GetGameTimeSeconds() >= 300 or not(ScenarioInfo.OpEnded)) then
        local bTrackingProjectile = false
        --LOG('TEMPCODE GetTrackingTarget=nil='..tostring(oProjectile.GetTrackingTarget == nil))
        if oProjectile.GetTrackingTarget then
            local oTarget = oProjectile:GetTrackingTarget()
            --M28 target specific logic:
            --LOG('TEMPCODE oTarget='..(oTarget.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTarget) or 'nil'))
            if M28UnitInfo.IsUnitValid(oTarget) then
                bTrackingProjectile = true
                if oTarget:GetAIBrain().M28AI and not(oTarget:GetAIBrain().M28Easy) then
                    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
                    local sFunctionRef = 'ProjectileCreated'
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

                    --Gunships - consider retreating early
                    if EntityCategoryContains(M28UnitInfo.refCategoryGunship - categories.CANNOTUSEAIRSTAGING, oTarget.UnitId) and not(oTarget.MyShield) and not(oTarget[M28UnitInfo.refbProjectilesMeanShouldRefuel]) then
                        ProjectileFiredAtGunship(oTarget, oProjectile)
                    end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                end
            end
        end
        if not(bTrackingProjectile) then
            --LOG('TEMPCODE reprs of oProjectile='..reprs(oProjectile)..'; reprs of oProjectile.Launcher='..reprs(oProjectile.Launcher)..'; oProjectile.InnerRing is nil='..tostring(oProjectile.InnerRing == nil)..'; oProjectile.OuterRing is nil='..tostring(oProjectile.OuterRing == nil)..'; Is launcher a nuke='..tostring(EntityCategoryContains(M28UnitInfo.refCategorySML, oProjectile.Launcher.UnitId)))
            --Gunship related
            if oProjectile.OriginalTarget then
                local oTarget = oProjectile.OriginalTarget
                if M28UnitInfo.IsUnitValid(oTarget) and oTarget:GetAIBrain().M28AI and not(oTarget:GetAIBrain().M28Easy) then
                    --Gunships - consider retreating early
                    if EntityCategoryContains(M28UnitInfo.refCategoryGunship - categories.CANNOTUSEAIRSTAGING, oTarget.UnitId) and not(oTarget.MyShield) and not(oTarget[M28UnitInfo.refbProjectilesMeanShouldRefuel]) then
                        ProjectileFiredAtGunship(oTarget, oProjectile)
                    end
                end
            end

            if not(oProjectile.Launcher) and not(M28Utilities.bFAFActive) and oProjectile.GetLauncher then
                oProjectile.Launcher = oProjectile:GetLauncher()
                --Consider adding inner and outer rings if this is a nuke launcher
                if oProjectile.Launcher.UnitId and EntityCategoryContains(M28UnitInfo.refCategorySML, oProjectile.Launcher.UnitId) and not(oProjectile.InnerRing) then
                    --Battleship exception - if target isnt far away assume we are dealing with normal battleship weapon
                    local bIncludeNukeRings = true
                    if oProjectile.Launcher[M28UnitInfo.refiDFRange] and oProjectile.GetCurrentTargetPosition then
                        local tTarget = oProjectile:GetCurrentTargetPosition()
                        if M28Utilities.IsTableEmpty(tTarget) == false and M28Utilities.GetDistanceBetweenPositions(tTarget, oProjectile.Launcher:GetPosition()) <= oProjectile.Launcher[M28UnitInfo.refiDFRange] + 5 then
                            bIncludeNukeRings = false
                        end
                    end
                    if bIncludeNukeRings then
                        local oLauncherBP = oProjectile.Launcher:GetBlueprint()
                        if oLauncherBP.Weapon then
                            for iWeapon, tWeapon in oLauncherBP.Weapon do
                                if tWeapon.NukeInnerRingRadius then
                                    --LOG('TEMPCODE setting nuke inner and outer radius')
                                    oProjectile.InnerRing = tWeapon.NukeInnerRingRadius
                                    oProjectile.OuterRing = (tWeapon.NukeOuterRingRadius or 40)
                                    break
                                end
                            end
                        end
                    else
                    end
                end
            end
            --LOG('TEMPCODE oProjectile.Launcher.UnitId='..(oProjectile.Launcher.UnitId or 'nil')..'; oProjectile.InnerRing='..(oProjectile.InnerRing or 'nil')..'; oProjectile.OuterRing='..(oProjectile.OuterRing or 'nil')..'; Launcher is SML='..tostring(EntityCategoryContains(M28UnitInfo.refCategorySML, (oProjectile.Launcher.UnitId or 'uel0001'))))
            if oProjectile.Launcher.UnitId and oProjectile.InnerRing and oProjectile.OuterRing and EntityCategoryContains(M28UnitInfo.refCategorySML, oProjectile.Launcher.UnitId) then
                --Have a nuke missile that has just been fired
                local oLauncher = oProjectile.Launcher
                --LOG('Is launcher valid='..tostring(M28UnitInfo.IsUnitValid(oLauncher)))
                if M28UnitInfo.IsUnitValid(oLauncher) then
                    local iTeam = oLauncher:GetAIBrain().M28Team
                    if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 0 then
                        ForkThread(M28Micro.MonitorNukeTargetForNukeWeHaveIntelOf, oProjectile, oLauncher, iTeam)
                    end
                    --Start a threat for each team with M28 in that isnt an ally to check if we have visual of the missile
                    for iCurTeam = 1, M28Team.iTotalTeamCount do
                        if not(iCurTeam == iTeam) and M28Team.tTeamData[iCurTeam][M28Team.subrefiActiveM28BrainCount] > 0 then
                            ForkThread(M28Micro.MonitorEnemyNukeForIntel, oProjectile, iCurTeam)
                        end
                    end
                end

            end
            --TML targeting
            if oProjectile.Launcher.UnitId and oProjectile.Launcher[M28Building.refoLastTMLTarget] and EntityCategoryContains(M28UnitInfo.refCategoryTML, oProjectile.Launcher.UnitId) then
                local oLauncher = oProjectile.Launcher
                if M28UnitInfo.IsUnitValid(oLauncher) and oLauncher:GetAIBrain().M28AI then
                    --Track the missile target against the projectile
                    oProjectile[M28Building.refoLastTMLTarget] = oLauncher[M28Building.refoLastTMLTarget]
                end
            end
        end
    end
end

--[[function ProjectileFiredFromWeapon(oProjectile)
    if oProjectile.GetCurrentTargetPosition then
        LOG('TEMP TEST will draw projectile created from firing weapon, oProjectile.UnitId='..(oProjectile.Unitid or 'nil')..'; launcher unit id='..(oProjectile.Launcher.UnitId or 'nil')..'; drawing projectile target='..repru(oProjectile:GetCurrentTargetPosition())..'; reprs of projectile='..reprs(oProjectile))
        for iEntry, tTable in oProjectile do
            LOG('reprs of iEntry='..iEntry..'='..reprs(tTable))
        end
        M28Utilities.DrawLocation(oProjectile:GetCurrentTargetPosition(), 3)
    else
        LOG('Projectyile fired but doesnt have a target position')
    end
end--]]

function OnMissileBuilt(self, weapon)
    if M28Utilities.bM28AIInGame then
        if self.GetAIBrain and self:GetAIBrain().M28AI then
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            local sFunctionRef = 'OnMissileBuilt'
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

            self[M28Building.refbMissileRecentlyBuilt] = true
            M28Utilities.DelayChangeVariable(self, M28Building.refbMissileRecentlyBuilt, false, 5)


            --Pause if we already have 2 missiles (mroe if smd and enemy has nukes)
            if bDebugMessages == true then
                if M28UnitInfo.IsUnitValid(self) then
                    LOG(sFunctionRef..': Have valid unit='..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self))
                else
                    LOG(sFunctionRef..': self='..reprs(self))
                end
            end

            local iMissiles = 1 --For some reason the count is off by 1, presumably a slight delay between the event being called and the below ammo counts working
            if self.GetTacticalSiloAmmoCount then iMissiles = iMissiles + self:GetTacticalSiloAmmoCount() end
            if bDebugMessages == true then LOG(sFunctionRef..': iMissiles based on tactical silo ammo='..iMissiles) end
            if self.GetNukeSiloAmmoCount then iMissiles = iMissiles + self:GetNukeSiloAmmoCount() end
            if bDebugMessages == true then LOG(sFunctionRef..': iMissiles after Nuke silo ammo='..iMissiles) end
            if iMissiles >= 1 then
                --Stop assisting units (so can reassess if we still want to assist)
                if M28Utilities.IsTableEmpty(self[M28UnitInfo.reftoUnitsAssistingThis]) == false then
                    local tEngineersToStop = {}
                    for iEngineer, oEngineer in self[M28UnitInfo.reftoUnitsAssistingThis] do
                        table.insert(tEngineersToStop, oEngineer)
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to make engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to stop assisting') end
                    end
                    for iEngineer, oEngineer in tEngineersToStop do
                        if M28UnitInfo.IsUnitValid(oEngineer) then
                            M28Orders.IssueTrackedClearCommands(oEngineer)
                            if bDebugMessages == true then LOG(sFunctionRef..': Just sent a clear order to '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to stop assisting') end
                        end
                    end
                end
                --SMD - use specical function to assess if have too many missiles
                local bPauseMissile
                if EntityCategoryContains(M28UnitInfo.refCategorySMD, self.UnitId) then
                    bPauseMissile = M28Conditions.WantToPauseSMD(self, true)
                    --Do we have any SMD without missiles, and no yolona on the team? If so then change the flag about needing resources for missiles
                    local bHaveSMDOrSMLNeedingMissiles = false
                    local iTeam = self:GetAIBrain().M28Team
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        if oBrain:GetCurrentUnits(M28UnitInfo.refCategorySML) > 0 then
                            bHaveSMDOrSMLNeedingMissiles = true
                            break
                        else
                            local tSMD = oBrain:GetListOfUnits(M28UnitInfo.refCategorySMD, false, true)
                            if M28Utilities.IsTableEmpty(tSMD) == false then
                                for iSMD, oSMD in tSMD do
                                    if not(oSMD == self) then
                                        if oSMD:GetFractionComplete() < 1 or oSMD:GetNukeSiloAmmoCount() == 0 then
                                            bHaveSMDOrSMLNeedingMissiles = true
                                            break
                                        end
                                    end
                                end
                                if bHaveSMDOrSMLNeedingMissiles then break end
                            end
                        end
                    end
                    if not(bHaveSMDOrSMLNeedingMissiles) then
                        M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] = false
                    end
                else
                    --Nuke launcher - If 2+ missiles then pause, and consider unpausing later
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy nuke launchers empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[self:GetAIBrain().M28Team][M28Team.reftEnemyNukeLaunchers]))..'; Have low power='..tostring(M28Conditions.HaveLowPower(self:GetAIBrain().M28Team))..'; Gross mass='..M28Team.tTeamData[self:GetAIBrain().M28Team][M28Team.subrefiTeamGrossMass]..'; Mass % stored='..M28Team.tTeamData[self:GetAIBrain().M28Team][M28Team.subrefiTeamAverageMassPercentStored]) end
                    if iMissiles >= 2 and not(EntityCategoryContains(categories.EXPERIMENTAL, self.UnitId)) then
                        local iTeam = self:GetAIBrain().M28Team
                        --Dont pause if overflowing
                        if M28Conditions.HaveLowPower(iTeam) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 400 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.8 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 30 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 25 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.99))) then
                            bPauseMissile = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Have at least 2 missiles so will set paused to true on unit '..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self)) end
                        end
                    end
                end
                if bPauseMissile then
                    --self:SetPaused(true)
                    M28UnitInfo.PauseOrUnpauseUnitWithoutTracking(self, true)
                    M28UnitInfo.SetUnitMissileAutoBuildStatus(self, false)
                    --if self.SetAutoMode then self:SetAutoMode(false) end

                    --Recheck every 10s
                    ForkThread(M28Building.CheckIfWantToBuildAnotherMissile, self)
                end
            end

            if not(EntityCategoryContains(M28UnitInfo.refCategorySMD, self.UnitId)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Calling logic to consider launching a missile') end
                --LOG('Forked consideration of launching missile 6')
                ForkThread(M28Building.ConsiderLaunchingMissile, self, weapon)
            end
        end

    end
end

--[[
function OnProjectileFired(oWeapon, oMuzzle)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OnProjectileFired'
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
    if oWeapon.GetBlueprint then
        LOG('OnWeaponFired hook for blueprint='..repru(oWeapon:GetBlueprint()))
    end
    if oWeapon.unit then
        LOG('Have a unit; unit position='..repru(oWeapon.unit:GetPosition()))
    end
end--]]

function OnConstructionStarted(oEngineer, oConstruction, sOrder)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnConstructionStarted'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if not(oConstruction.UnitId) then --LOUD compatibility redundancy (OnCreate should also do this)
            if not(M28Utilities.bFAFActive) then
                if not(oConstruction.EntityId) then oConstruction.EntityId = oConstruction:GetEntityId() end
                oConstruction.UnitId = oConstruction:GetBlueprint().BlueprintId
            end
        end



        --Update land zone queued orders
        if M28Utilities.IsTableEmpty(oEngineer[M28Engineer.reftQueuedBuildings]) == false then
            M28Engineer.RemoveBuildingFromQueuedBuildings(oEngineer, oConstruction)
        end

        --Both M28 and non-M28:
        if not(oConstruction[M28UnitInfo.refbConstructionStart]) then
            --Construction is being done of a building, by a building
            if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oConstruction.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oEngineer.UnitId) then
                --Mex and hydro upgrade tracking redundancy if not FAF
                if not(M28Utilities.bFAFActive) and EntityCategoryContains(M28UnitInfo.refCategoryHydro + M28UnitInfo.refCategoryMex, oConstruction.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryHydro + M28UnitInfo.refCategoryMex, oEngineer.UnitId) then
                    oConstruction.IsUpgrade = true
                end

                --Intel approximation - a human player would be able to infer that if they'd scouted a mex and now it is greyed out, that means the opponent has upgraded it; so it is reasonable for the AI to be given the same information
                local iConstructionTeam = oConstruction:GetAIBrain().M28Team
                for iTeam = 1, M28Team.iTotalTeamCount, 1 do
                    if not(iTeam == iConstructionTeam) and oEngineer[M28UnitInfo.reftbConsideredForAssignmentByTeam][iTeam] then
                        local oFirstM28Brain = M28Team.GetFirstActiveM28Brain(iTeam)
                        if oFirstM28Brain then
                            M28Team.AssignUnitToLandZoneOrPond(oFirstM28Brain, oConstruction, false, false, true)
                        end
                    end
                end
            end
        end


        --M28 specific
        if oEngineer:GetAIBrain().M28AI then
            --Stuff to update every time construction starts
            if oEngineer[M28Building.reftArtiTemplateRefs] then oEngineer[M28Conditions.refiEngineerStuckCheckCount] = 0 end
            if oEngineer[M28Orders.refiMoveAndBuildStuckCount] then oEngineer[M28Orders.refiMoveAndBuildStuckCount] = 0 end
            if oConstruction.GetUnitId and not(oConstruction[M28UnitInfo.refbConstructionStart]) then
                oConstruction[M28UnitInfo.refbConstructionStart] = true
                --Enable M28Active status if the engineer is active and we have set to inherit
                if not(M28Orders.bDontConsiderCombinedArmy) and (oEngineer.M28Active or (oEngineer.Parent and oEngineer.Parent.M28Active and EntityCategoryContains(categories.EXTERNALFACTORYUNIT, oEngineer.UnitId))) and oEngineer:GetAIBrain().BrainType == 'Human' and tonumber(ScenarioInfo.Options.M28CAInherit or 2) == 1 and not(oConstruction.M28Active) and not(tonumber(ScenarioInfo.Options.M28CombinedArmy or 2) == 3) then
                    oConstruction.M28Active = true
                    oConstruction:UpdateStat('M28Active', 1)
                end

                if bDebugMessages == true then
                    --local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oConstruction:GetPosition()) --decided not to include due to worry this might desync replays
                    LOG(sFunctionRef..': Construction just started by M28 engineer belonging to '..oEngineer:GetAIBrain().Nickname..' on oConstruction='..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction)..'; postiion='..repru(oConstruction:GetPosition())..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; oEngineer[M28Building.reftArtiTemplateRefs]='..repru(oEngineer[M28Building.reftArtiTemplateRefs])..'; Engi action (if any)='..(oEngineer[M28Engineer.refiAssignedAction] or 'nil')..'; Parent='..(oEngineer.Parent.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer.Parent) or 'nil')..'; time='..GetGameTimeSeconds())
                end
                --Record any mexes so we can repair them if construction gets interrupted
                if EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oConstruction.UnitId) then
                    M28Engineer.RecordPartBuiltMex(oEngineer, oConstruction)
                end

                --Track special game ender logic buildings
                if oEngineer[M28Building.reftArtiTemplateRefs] then
                    if bDebugMessages == true then LOG(sFunctionRef..': We have construction being built by engi with arti template ref, so will copy over engineer arti template ref, oEngineer[M28Building.reftArtiTemplateRefs]='..repru(oEngineer[M28Building.reftArtiTemplateRefs])) end
                    oConstruction[M28Building.reftArtiTemplateRefs] =  {oEngineer[M28Building.reftArtiTemplateRefs][1], oEngineer[M28Building.reftArtiTemplateRefs][2], oEngineer[M28Building.reftArtiTemplateRefs][3]}

                    local tLZTeamData = M28Map.tAllPlateaus[oEngineer[M28Building.reftArtiTemplateRefs][1]][M28Map.subrefPlateauLandZones][oEngineer[M28Building.reftArtiTemplateRefs][2]][M28Map.subrefLZTeamData][oConstruction:GetAIBrain().M28Team]
                    if tLZTeamData then
                        if bDebugMessages == true then
                            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oConstruction:GetPosition())
                            LOG(sFunctionRef..': Arti template recording of unit where construction started; engineer template ref='..repru(oEngineer[M28Building.reftArtiTemplateRefs])..'; Is table of active game ender templates for this ref empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates][oEngineer[M28Building.reftArtiTemplateRefs]]))..'; Is tLZTeamData[M28Map.reftActiveGameEnderTemplates] empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates]))..'; Construction plateau='..(iPlateau or 'nil')..'; LZ='..(iLandZone or 'nil')..'; Engineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; oConstruction='..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction))
                        end
                        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oConstruction.UnitId) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have started fixed shield so will add to table of shields for this reference') end
                            local tTemplateRef = tLZTeamData[M28Map.reftActiveGameEnderTemplates][oEngineer[M28Building.reftArtiTemplateRefs][3]]
                            --Check shield isn't already recorded
                            local bAlreadyRecorded = false
                            if M28Utilities.IsTableEmpty(tTemplateRef[M28Map.subrefGEShieldUnits]) == false then
                                for iRecordedShield, oRecordedShield in tTemplateRef[M28Map.subrefGEShieldUnits] do
                                    if oRecordedShield == oConstruction then
                                        bAlreadyRecorded = true
                                        break
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': bAlreadyRecorded='..tostring(bAlreadyRecorded)) end
                            if not(bAlreadyRecorded) then
                                table.insert(tTemplateRef[M28Map.subrefGEShieldUnits], oConstruction)
                                if bDebugMessages == true then LOG(sFunctionRef..': Added unit to table of shield units') end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Wont record shield '..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction)..' against arti template as it was already recorded') end
                            end

                            --Check if we no longer need special faction engineers
                            if M28Utilities.IsTableEmpty(tTemplateRef[M28Map.subrefGEArtiUnits]) == false and table.getn(tTemplateRef[M28Map.subrefGEShieldUnits]) >= math.min(7, table.getn(tTemplateRef[M28Map.subrefGEShieldLocations])) then
                                for iArti, oArti in tTemplateRef[M28Map.subrefGEArtiUnits] do
                                    if oArti[M28Building.refoNearbyFactoryOfFaction] then
                                        M28Building.UnitNoLongerRequiresFactoryFactionShieldEngineers(oArti)
                                    end
                                end
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oConstruction.UnitId) then
                            local tTemplateRef = tLZTeamData[M28Map.reftActiveGameEnderTemplates][oEngineer[M28Building.reftArtiTemplateRefs][3]]
                            local bAlreadyRecorded = false
                            if M28Utilities.IsTableEmpty(tTemplateRef[M28Map.subrefGEArtiUnits]) == false then
                                for iRecordedArti, oRecordedArti in tTemplateRef[M28Map.subrefGEArtiUnits] do
                                    if oRecordedArti == oConstruction then
                                        bAlreadyRecorded = true
                                        break
                                    end
                                end
                            end
                            if not(bAlreadyRecorded) then
                                --Check this isn't a mobile non-scathis unit
                                if not(EntityCategoryContains(categories.MOBILE, oConstruction.UnitId)) or M28UnitInfo.GetBlueprintMaxGroundRange(oConstruction:GetBlueprint()) >= 500 then
                                    table.insert(tTemplateRef[M28Map.subrefGEArtiUnits], oConstruction)
                                elseif bDebugMessages == true then LOG(sFunctionRef..': We have constructed a mobile unit with a short range so wont record as an arti unit')
                                end
                            end
                            tTemplateRef[M28Map.subrefbFailedToGetArtiLocation] = false
                            if bDebugMessages == true then LOG(sFunctionRef..': Have started experimental type unit so will add to table of arti for this reference, oConstruction='..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction)..'; bAlreadyRecorded='..tostring(bAlreadyRecorded)) end
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySMD, oConstruction.UnitId) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have started SMD unit so will add to table of SMD for this reference') end
                            tLZTeamData[M28Map.reftActiveGameEnderTemplates][oEngineer[M28Building.reftArtiTemplateRefs][3]][M28Map.subrefGESMDUnit] = oConstruction
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryGroundAA + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryPD, oConstruction.UnitId) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Just started on AA/SAM/PD/T2 arti unit so will add to table of defences for this reference') end
                            if not(tLZTeamData[M28Map.reftActiveGameEnderTemplates][oEngineer[M28Building.reftArtiTemplateRefs][3]][M28Map.subrefGEDefenceUnits]) then tLZTeamData[M28Map.reftActiveGameEnderTemplates][oEngineer[M28Building.reftArtiTemplateRefs][3]][M28Map.subrefGEDefenceUnits] = {} end
                            table.insert(tLZTeamData[M28Map.reftActiveGameEnderTemplates][oEngineer[M28Building.reftArtiTemplateRefs][3]][M28Map.subrefGEDefenceUnits], oConstruction)
                        else
                            M28Utilities.ErrorHandler('Engineer has just started construction on a unit that isnt one we would expect to be built for gameender template logic, Unit='..(oConstruction.UnitId or 'nil')..'; Engineer action='..(oEngineer[M28Engineer.refiAssignedAction] or 'nil')..'; Engineer='..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil'))
                            oConstruction[M28Building.reftArtiTemplateRefs] = nil
                            if EntityCategoryContains(M28UnitInfo.refCategoryFactory + categories.EXTERNALFACTORYUNIT, oEngineer.UnitId) then oEngineer[M28Building.reftArtiTemplateRefs] = nil end
                            if bDebugMessages == true then LOG(sFunctionRef..': Engi starting unexpected category, oEngineer='..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil')..'; Brain='..oEngineer:GetAIBrain().Nickname..'; index='..oEngineer:GetAIBrain():GetArmyIndex()) end
                        end
                    else M28Utilities.ErrorHandler('Started building a unit for arti template but it isnt in a zone')
                    end
                end

                --Decide if want to shield this construction and update buildable location, or (in the case of experimentals) if we want to cancel the construction
                if EntityCategoryContains(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryExperimentalLevel, oConstruction.UnitId) then
                    local bCancelBuilding = false
                    --LOUD specific - cant build resource gens near each other
                    if (M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) and EntityCategoryContains(categories.EXPERIMENTAL * categories.MASSFABRICATION, oConstruction.UnitId) then
                        ForkThread(M28Building.RecordExperimentalResourceGen, oConstruction)
                    end
                    if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti, oConstruction.UnitId) and not(oConstruction[M28Building.reftArtiTemplateRefs]) and not(oEngineer[M28Building.reftArtiTemplateRefs]) then
                        local iTeam = oEngineer:GetAIBrain().M28Team
                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.9 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] < 3 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] < 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.6)) then
                            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oConstruction:GetPosition())
                            if iPlateau > 0 and (iLandZone or 0) > 0 then
                                --NOTE: If changing above thresholds then consider also changing M28Engineer ConsiderActionToAssign threshold (want above to be less likely to trigger to avoid constant loop of starting and cancelling)
                                local iSearchRange = math.max(175, 450 - M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) --(slightly further search range than the M28Engineer approach)
                                local iSearchCategory = nil --means will search for everything
                                if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder, oConstruction.UnitId) then iSearchCategory = M28UnitInfo.refCategoryGameEnder
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti, oConstruction.UnitId) then iSearchCategory = M28UnitInfo.refCategoryFixedT3Arti
                                else
                                    --Search for all experimentals  (so leave as nil) - however given the above restriction this is more for redundancy as would only expect to be here if are building game ender or t3 arti
                                end
                                local bHaveExperimentalForThisLandZone, iOtherLandZonesWithExperimental, iMassToComplete = M28Engineer.GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateau, iLandZone, true, iSearchRange, iSearchCategory)
                                if iMassToComplete >= math.max(17500, M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] * 1.3) then
                                    --Estimate how long it will take to complete if we manage to spend 40% of gross mass on existing experimentals
                                    if (iMassToComplete - M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]) / M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 0.4 > 40 then
                                        bCancelBuilding = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to cancel construction that we just started, iMassToComplete='..iMassToComplete..'; Mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) end
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': bCancelBuilding='..tostring(bCancelBuilding)) end
                    if bCancelBuilding then
                        --Clear all engineeres trying to build this
                        M28Engineer.ClearEngineersBuildingUnit(oEngineer, oConstruction)
                        --Tell the engi that just constructed to reclaim
                        M28Orders.IssueTrackedReclaim(oEngineer, oConstruction, false, 'AbrtNRec', true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have told engineer to abort consturction of '..oConstruction.UnitId..' and to reclaim it instead') end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Engineer that is starting this construction='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; oEngineer[M28Engineer.refiAssignedAction]='..(oEngineer[M28Engineer.refiAssignedAction] or 'nil')) end
                        if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oConstruction.UnitId) then
                            local iTeam = oConstruction:GetAIBrain().M28Team
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to cancel experimental queued in other zones, bCancelBuilding='..tostring(bCancelBuilding)..'; M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount]='..M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount]..'; Mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Team has low mass='..tostring(M28Conditions.TeamHasLowMass(iTeam))) end
                            if M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] < 20000 and M28Conditions.TeamHasLowMass(iTeam) then
                                --If dont have an experimental constructed yet then when we start our first exp go through each other zone with engineers trying to build an experimental and clear the engineers if we have low mass and the engineers havent started building yet
                                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oConstruction:GetPosition())
                                if iPlateau > 0 and iLandZone > 0 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will consider cancelling other queued engineer construction if there is any; M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]) end
                                    M28Engineer.GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateau, iLandZone, false, nil, nil, true, nil, oConstruction:GetAIBrain().M28AirSubteam)
                                end
                            end
                        end

                        --Game ender and T3 arti specific - reserve locations for shields
                        if bDebugMessages == true then LOG(sFunctionRef..': is oConstruction[M28Building.reftArtiTemplateRefs] nil='..tostring(oConstruction[M28Building.reftArtiTemplateRefs] == nil)) end
                        if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti, oConstruction.UnitId) and not(oConstruction[M28Building.reftArtiTemplateRefs]) then
                            --Record shields against the gameender/T3 arti if they are in the reserved location
                            M28Building.ReserveLocationsForGameEnder(oConstruction)
                            if bDebugMessages == true then LOG(sFunctionRef..': Will reserve location for gameender and alternative shielding') end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oConstruction.UnitId) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with a shield '..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction)..', if part of special shield defence then will assign to GE template') end
                            if oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionSpecialShieldDefence then
                                M28Building.AssignShieldToGameEnder(oConstruction, oEngineer)
                            else
                                --Consider adding normal shields to the gameender defence if they are built very near to a game ender location
                                if oConstruction:GetAIBrain().M28AI and oEngineer:GetAIBrain().M28AI then
                                    local iShieldRadius = (oConstruction:GetBlueprint().Defense.Shield.ShieldSize or 0) * 0.5
                                    if iShieldRadius > 10 then --larger than a T2 aeon shield
                                        local iTeam = oEngineer:GetAIBrain().M28Team
                                        local tShieldLZData, tShieldLZTeamData = M28Map.GetLandOrWaterZoneData(oConstruction:GetPosition(), true, iTeam)
                                        local bHaveMatch = false

                                        if M28Utilities.IsTableEmpty(tShieldLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) == false then
                                            for iGameEnder, oGameEnder in tShieldLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if oGameEnder as priorit yshield locations, is reftLocationsForPriorityShield empty='..tostring(M28Utilities.IsTableEmpty(oGameEnder[M28Building.reftLocationsForPriorityShield]))) end
                                                if M28Utilities.IsTableEmpty(oGameEnder[M28Building.reftLocationsForPriorityShield]) == false then
                                                    for iLocation, tLocation in oGameEnder[M28Building.reftLocationsForPriorityShield] do
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Dist between GE priority shield location and this shield='..M28Utilities.GetRoughDistanceBetweenPositions(tLocation, oConstruction:GetPosition())) end
                                                        if M28Utilities.GetRoughDistanceBetweenPositions(tLocation, oConstruction:GetPosition()) <= 3 then
                                                            if M28Utilities.GetDistanceBetweenPositions(oConstruction:GetPosition(), oGameEnder:GetPosition()) <= iShieldRadius * 0.9 then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Fixed shield construction '..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction)..' built by engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; will be assigned to a game ender shield as it is close to oGameEnder '..oGameEnder.UnitId..M28UnitInfo.GetUnitLifetimeCount(oGameEnder)) end
                                                                bHaveMatch = true
                                                                M28Building.AssignShieldToGameEnder(oConstruction, oEngineer)
                                                                break
                                                            end
                                                        end
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': bHaveMatch before basic dist check='..tostring(bHaveMatch)..'; is reftoSpecialAssignedShields empty='..tostring(M28Utilities.IsTableEmpty(oGameEnder[M28Building.reftoSpecialAssignedShields]))..'; Dist between shield and GE='..M28Utilities.GetDistanceBetweenPositions(oConstruction:GetPosition(), oGameEnder:GetPosition())..'; Shield radius='..((oConstruction:GetBlueprint().Defense.Shield.ShieldSize or 0) * 0.5)) end
                                                    if not(bHaveMatch) and M28Utilities.GetDistanceBetweenPositions(oConstruction:GetPosition(), oGameEnder:GetPosition()) <= (oConstruction:GetBlueprint().Defense.Shield.ShieldSize or 0) * 0.5 - 4 then
                                                        bHaveMatch = true
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Will assign this shield as one of the template shields for the GE template') end
                                                        M28Building.AssignShieldToGameEnder(oConstruction, oEngineer)
                                                    end
                                                    if bHaveMatch then break end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        elseif EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then
                            --ACU building t1 power far from base - flag that we dont want it assisted
                            if EntityCategoryContains(M28UnitInfo.refCategoryT1Power, oConstruction.UnitId) then
                                local oEngineerBrain = oEngineer:GetAIBrain()
                                if oEngineerBrain[M28Economy.refiGrossMassBaseIncome] >= 1.5 then
                                    local tEngineerLZData = M28Map.GetLandOrWaterZoneData(oConstruction:GetPosition())
                                    if M28Utilities.GetDistanceBetweenPositions(tEngineerLZData[M28Map.subrefMidpoint], oEngineer:GetPosition()) >= 25 then
                                        oConstruction[M28Engineer.refbDontIncludeAsPartCompleteBuildingForConstruction] = true
                                    end
                                end
                                --ACU building factory - if we have an engineer queued to build a factory in the same zone that hasnt started yet, and it is relatively early on, then clear that engineer's orders
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryFactory, oConstruction.UnitId) and oConstruction:GetAIBrain():GetEconomyStoredRatio('MASS') <= 0.9 then
                                local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oConstruction:GetPosition(), true, oEngineer:GetAIBrain().M28Team)
                                if tLZOrWZTeamData and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                    local toEngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                    if M28Utilities.IsTableEmpty(toEngineersInZone) == false then
                                        for iEngi, oEngi in toEngineersInZone do
                                            if not(oEngi.Dead) and (oEngi[M28Engineer.refiAssignedAction] == M28Engineer.refActionBuildLandFactory or oEngi[M28Engineer.refiAssignedAction] == M28Engineer.refActionBuildAirFactory or oEngi[M28Engineer.refiAssignedAction] == M28Engineer.refActionBuildNavalFactory) then
                                                --Clear queued engineers
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will clear engineers trying to build factory that havent started construction yet, oEngi='..oEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngi)..'; Work progress='..oEngi:GetWorkProgress()) end
                                                if oEngi:GetWorkProgress() == 0 and not(oEngi[M28Orders.reftiLastOrders][oEngi[M28Orders.refiOrderCount]][M28Orders.subrefoOrderUnitTarget] == oConstruction) and not(oEngi[M28Orders.reftiLastOrders][oEngi[M28Orders.refiOrderCount]][M28Orders.subrefoOrderUnitTarget] == oEngineer) then
                                                    M28Orders.IssueTrackedClearCommands(oEngi)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        M28Building.CheckIfUnitWantsFixedShield(oConstruction, true)
                        --If this is a fixed shield then instead update shield coverage
                        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oConstruction.UnitId) then
                            if bDebugMessages == true then LOG(sFunctionRef..': About to update shield coverage of units') end
                            M28Building.UpdateShieldCoverageOfUnits(oConstruction, false)
                        end

                        --Buildable locations - update for unit construction started (do form obile experimentals since the location is temporarily not buildable)
                        if EntityCategoryContains(M28UnitInfo.refCategoryStructure + categories.MOBILE - M28UnitInfo.refCategoryMex - M28UnitInfo.refCategoryHydro, oConstruction.UnitId) then
                            if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oConstruction.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Just started construction of unit '..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction)..'; Is it valid to build a T1 pgen at this location='..tostring(oEngineer:GetAIBrain():CanBuildStructureAt('ueb1101', oConstruction:GetPosition()))) end
                                ForkThread(M28Engineer.CheckIfBuildableLocationsNearPositionStillValid, oEngineer:GetAIBrain(), oConstruction:GetPosition(), false, M28UnitInfo.GetBuildingSize(oConstruction.UnitId) * 0.5)
                            else
                                --i.e. experimentalal started, the CanBuildStructureAt check doesnt work properly for this so first need to record a blacklist (will only have recorded for 4m) and then check for this
                                if bDebugMessages == true then LOG(sFunctionRef..': Just started construction of experimental mobile unit='..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction)..'; Is it valid to build a T1 pgen at this location='..tostring(oEngineer:GetAIBrain():CanBuildStructureAt('ueb1101', oConstruction:GetPosition()))) end
                                M28Engineer.RecordBlacklistLocation(oConstruction:GetPosition(), M28UnitInfo.GetBuildingSize(oConstruction.UnitId) * 0.5, 420, oConstruction)
                                ForkThread(M28Engineer.CheckIfBuildableLocationsNearPositionStillValid, oEngineer:GetAIBrain(), oConstruction:GetPosition(), true, M28UnitInfo.GetBuildingSize(oConstruction.UnitId) * 0.5)
                            end
                        end
                        --end
                        --Both structures and experimentals - clear any engineers trying to build something else that will be blocked by this
                        ForkThread(M28Engineer.ClearEngineersWhoseTargetIsNowBlockedByUnitConstructionStarted, oEngineer, oConstruction)
                    end
                else
                    --Mobile unit - special logic for navla factories for mini bombardment (raid) target
                    if EntityCategoryContains(M28UnitInfo.refCategoryBombardment, oConstruction.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oEngineer.UnitId) then
                        M28Navy.ConsiderAssigningRaidingNavalUnit(oConstruction, oEngineer)
                    end
                end

            end
        else
            --Non-M28 only
            if not(oConstruction[M28UnitInfo.refbConstructionStart]) then
                oConstruction[M28UnitInfo.refbConstructionStart] = true
                --If this is a fixed shield then instead update shield coverage (note - we also do this for M28 brains above, but with some extra logic to decide if we want to try and shield, and using a more efficient emthod of identifying shields)
                if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oConstruction.UnitId) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a shield that we have just started ubilding so will update shield coverage') end
                    M28Building.UpdateShieldCoverageOfUnits(oConstruction, false)
                elseif EntityCategoryContains(M28UnitInfo.refCategoryStructure - categories.MOBILE, oConstruction.UnitId) then
                    --Record if this unit is under fixed shield coverage if it's not owned by an M28AI brain (M28AI units will separately check this by using the LZ data info)
                    local tNearbyShields = oConstruction:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedShield, oConstruction:GetPosition(), 60, 'Ally')
                    if bDebugMessages == true then LOG(sFunctionRef..': have just started construction of a building, will check for nearby shields, is tNearbyShields empty='..tostring(M28Utilities.IsTableEmpty(tNearbyShields))) end
                    if M28Utilities.IsTableEmpty(tNearbyShields) == false then
                        local iShieldRadius
                        for iShield, oShield in tNearbyShields do
                            iShieldRadius = oShield:GetBlueprint().Defense.Shield.ShieldSize * 0.5 -0.1 -- - 1
                            M28Building.RecordIfShieldIsProtectingUnit(oShield, oConstruction, iShieldRadius, true)
                        end
                    end

                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnConstructed(oEngineer, oJustBuilt)
    --WARNING: This doesnt seem to trigger for the ACU; it does trigger when untis are constructed by a factory

    --NOTE: This is called every time an engineer stops building a unit whose fractioncomplete is 100%, so can be called multiple times
    if M28Utilities.bM28AIInGame then
        --NonM28 specific - dont set the M28OnConstructionCalled for this, so need to  be careful that any code here will not be run repeatedly
        --LOG('OnConstructed at time '..GetGameTimeSeconds()..' for unit '..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..' owned by brain '..oJustBuilt:GetAIBrain().Nickname..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; M28Map.bMapLandSetupComplete='..tostring(M28Map.bMapLandSetupComplete or false))
        if not(M28Map.bFirstM28TeamHasBeenInitialised) or not(M28Map.bWaterZoneInitialCreation) then
            local iWaitCount = 0
            local bDontCallAgain = false
            while not(M28Map.bFirstM28TeamHasBeenInitialised) or not(M28Map.bWaterZoneInitialCreation) do
                WaitTicks(1)
                iWaitCount = iWaitCount + 1
                if iWaitCount >= 300 then
                    M28Utilities.ErrorHandler('Waited more than 5m for map setup or team setup to complete, something has gone wrong, M28Map.bFirstM28TeamHasBeenInitialised='..tostring(M28Map.bFirstM28TeamHasBeenInitialised or false)..'; M28Map.bWaterZoneInitialCreation='..tostring(M28Map.bWaterZoneInitialCreation or false))
                    bDontCallAgain = true
                    break
                end
            end
            if not(bDontCallAgain) and M28UnitInfo.IsUnitValid(oJustBuilt) then
                OnConstructed(oEngineer, oJustBuilt)
            end
        else
            local sFunctionRef = 'OnConstructed'
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

            if not(oJustBuilt.UnitId) then --LOUD compatibility redundancy (OnCreate should also do this)
                if not(M28Utilities.bFAFActive) then
                    if not(oJustBuilt.EntityId) then oJustBuilt.EntityId = oJustBuilt:GetEntityId() end
                    oJustBuilt.UnitId = oJustBuilt:GetBlueprint().BlueprintId
                end
            end

            M28Orders.ClearAnyRepairingUnits(oJustBuilt)
            if M28Utilities.IsTableEmpty(oJustBuilt[M28Land.reftoUnitsToKillOnCompletion]) == false then
                for iUnit, oUnit in oJustBuilt[M28Land.reftoUnitsToKillOnCompletion] do
                    if M28UnitInfo.IsUnitValid(oUnit) and (not(oUnit[M28UnitInfo.refbCampaignTriggerAdded]) or not(M28Map.bIsCampaignMap)) and not(oUnit:IsUnitState('Upgrading')) then
                        M28Orders.IssueTrackedKillUnit(oUnit)
                    end
                end
                oJustBuilt[M28Land.reftoUnitsToKillOnCompletion] = nil
            end

            if EntityCategoryContains(categories.STRUCTURE, oJustBuilt.UnitId) then
                --If a building has just build a building, then make sure all M28 are aware of it (since a player would be able to infer this)
                if EntityCategoryContains(categories.STRUCTURE - categories.ENGINEER, oEngineer.UnitId) then
                    local tTeamsUpdated = {}
                    for iBrain, oBrain in M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subreftoEnemyBrains] do
                        if oBrain.M28AI and not(tTeamsUpdated[oBrain.M28Team]) then
                            tTeamsUpdated[oBrain.M28Team] = true
                            M28Team.AssignUnitToLandZoneOrPond(oBrain, oJustBuilt, false, false, true)
                        end
                    end
                    --Mex built by engineer - special case where player would be able to infer a mex has been built after a while
                elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oJustBuilt.UnitId) then
                    ForkThread(M28Team.ConsiderDelayedMexDetection, oJustBuilt)
                end
                --Also update the name
                if M28Config.M28ShowUnitNames then
                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oJustBuilt:GetPosition(), false)

                    local sWZOrLZRef = ''
                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oJustBuilt:GetPosition())
                    local iWaterZone
                    if (iLandZone or 0) == 0 then
                        iWaterZone = M28Map.GetWaterZoneFromPosition(oJustBuilt:GetPosition())
                        if (iWaterZone or 0) > 0 then
                            sWZOrLZRef = 'WZ'..iWaterZone
                        end
                    else
                        sWZOrLZRef = ':P='..(iPlateau or 0)..'LZ='..(iLandZone or 0)
                    end

                    if M28Config.M28ShowUnitNames then oJustBuilt:SetCustomName(oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..sWZOrLZRef..': Built') end
                end

                --Redundnacy - If we have just built a radar then update radar logic (note that AssignUnitToLandZoneOrPond should already cover this when construction is started)
                if EntityCategoryContains(M28UnitInfo.refCategoryRadar, oJustBuilt.UnitId) then
                    ForkThread(M28Land.UpdateZoneIntelForRadar, oJustBuilt)
                    if EntityCategoryContains(categories.TECH2, oJustBuilt.UnitId) then
                        ForkThread(M28Building.ConsiderUpgradingT2Radar, oJustBuilt)
                    end
                elseif EntityCategoryContains(M28UnitInfo.refCategorySonar, oJustBuilt.UnitId) then
                    ForkThread(M28Navy.UpdateZoneIntelForSonar, oJustBuilt)

                    --Air staging - reset timer on when we last needed one
                elseif EntityCategoryContains(M28UnitInfo.refCategoryAirStaging, oJustBuilt.UnitId) then
                    M28Team.tTeamData[oJustBuilt:GetAIBrain().M28Team][M28Team.refiTimeOfLastAirStagingShortage] = 0
                end

                --Track non-M28AI wall segments
                if EntityCategoryContains(M28UnitInfo.refCategoryWall, oJustBuilt.UnitId) and not(oJustBuilt:GetAIBrain().M28AI) then
                    M28Land.TrackWallSegment(oJustBuilt, true)
                end
            elseif oJustBuilt[M28Engineer.reftUnitBlacklistSegmentXZ] then --EntityCategoryContains(categories.EXPERIMENTAL * categories.MOBILE - M28UnitInfo.refCategoryExperimentalArti, oJustBuilt.UnitId) then
                --Treat area around experimental under construction as available again
                M28Engineer.ClearBlacklistForUnitConstructed(oJustBuilt)
                M28Engineer.SearchForBuildableLocationsNearDestroyedBuilding(oJustBuilt)
            end

            M28Building.RecordUnitShieldCoverage(oJustBuilt)



            if not(oJustBuilt.M28OnConstructedCalled) then
                oJustBuilt.M28OnConstructedCalled = true



                if bDebugMessages == true then LOG(sFunctionRef..': First time calling for unit '..(oJustBuilt.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oJustBuilt) or 'nil')..' owned by '..oJustBuilt:GetAIBrain().Nickname..', was this M28 brain='..tostring(oJustBuilt:GetAIBrain().M28AI or false)..'; Built at time='..GetGameTimeSeconds()) end

                --Both M28 and Non-M28 where not already run onconstructioncalled:
                --TML - flag to rerun logic for targeting as redundancy for cases where getunitsaroundpoint wont pickup under construction/upgrading units
                if oJustBuilt[M28Building.refbRecheckTMLAndTMDWhenConstructedByTeam] then
                    for iTMLTeam, bRecheck in oJustBuilt[M28Building.refbRecheckTMLAndTMDWhenConstructedByTeam] do
                        ForkThread(M28Building.RecordTMLAndTMDForEnemyUnitTargetJustDetected, oJustBuilt, iTMLTeam)
                    end
                    oJustBuilt[M28Building.refbRecheckTMLAndTMDWhenConstructedByTeam] = nil
                end

                --SMD - update with more accurate estimate of time when built
                if oJustBuilt[M28UnitInfo.refiTimeOfLastCheck] and EntityCategoryContains(M28UnitInfo.refCategorySMD, oJustBuilt.UnitId) then


                    oJustBuilt[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds() - M28Building.iTimeForSMDToBeConstructed
                    if bDebugMessages == true then LOG(sFunctionRef..': Just built SMD, oJustBuilt='..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; Owner='..oJustBuilt:GetAIBrain().Nickname..'; Time='..GetGameTimeSeconds()) end
                end

                --Mex tracking
                if EntityCategoryContains(M28UnitInfo.refCategoryMex, oJustBuilt.UnitId) then
                    M28Building.OnMexConstructionCompleted(oJustBuilt)
                end

                --M28 specific
                if oJustBuilt:GetAIBrain().M28AI then

                    if bDebugMessages == true then LOG(sFunctionRef..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just built '..oJustBuilt.UnitId) end
                    local aiBrain = oJustBuilt:GetAIBrain()
                    local iTeam = aiBrain.M28Team
                    --experimental level construction count, and paragon and yolona specific logic
                    if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oJustBuilt.UnitId) then
                        --If this is a cheap experimental then only count as partial experimental
                        local iExpMassCost = M28UnitInfo.GetUnitMassCost(oJustBuilt)
                        if iExpMassCost <= 50000 and EntityCategoryContains(M28UnitInfo.refCategoryT2PlusPD, oJustBuilt.UnitId) then
                            M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] = M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] + 0.2
                        elseif iExpMassCost <= 50000 and EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oJustBuilt.UnitId) then
                            M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] = M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] + 0.35
                        elseif iExpMassCost < 20000 then
                            M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] = M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] + 0.75 * iExpMassCost / 20000
                        else
                            M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] = M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] + 1
                        end
                        local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oJustBuilt:GetPosition(), true, iTeam)
                        tLZTeamData[M28Map.refiZoneConstructedExperimentalCount] = (tLZTeamData[M28Map.refiZoneConstructedExperimentalCount] or 0) + 1
                        if EntityCategoryContains(M28UnitInfo.refCategoryParagon, oJustBuilt.UnitId) then
                            ForkThread(M28Building.JustBuiltParagon, oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySML * categories.EXPERIMENTAL, oJustBuilt.UnitId) then
                            M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] = true
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oJustBuilt.UnitId) or ((oJustBuilt[M28UnitInfo.refiDFRange] or 0) >= 80 and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oJustBuilt.UnitId)) then
                            --flag we have built long range unit so we prioritise building omni
                            aiBrain[M28Overseer.refbBuiltLongRangeLandUnit] = true
                        end

                        if EntityCategoryContains(M28UnitInfo.refCategoryNovaxCentre, oJustBuilt.UnitId) then
                            ForkThread(M28Air.DelayedNovaxUnloadCheck, oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryNovaxCentre, oEngineer.UnitId) and oEngineer:GetAIBrain().M28AI then
                            ForkThread(M28Air.DelayedNovaxUnloadCheck, oEngineer)
                        end

                        if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder, oJustBuilt.UnitId) then M28Team.tTeamData[iTeam][M28Team.refiFriendlyGameEnderCount] = (M28Team.tTeamData[iTeam][M28Team.refiFriendlyGameEnderCount] or 0) + 1 end
                        if oJustBuilt[M28Building.reftArtiTemplateRefs] then
                            --Reassess the game-ender to build
                            local tTableRef = M28Map.tAllPlateaus[oJustBuilt[M28Building.reftArtiTemplateRefs][1]][M28Map.subrefPlateauLandZones][oJustBuilt[M28Building.reftArtiTemplateRefs][2]][M28Map.subrefLZTeamData][iTeam][M28Map.reftActiveGameEnderTemplates][oJustBuilt[M28Building.reftArtiTemplateRefs][3]]
                            if tTableRef then tTableRef[M28Map.subrefbForceRefreshOfArtiToBuild] = true end
                            if bDebugMessages == true then LOG(sFunctionRef..': Flagging that we want to refresh the Arti to build for GE template, P'..oJustBuilt[M28Building.reftArtiTemplateRefs][1]..'Z'..oJustBuilt[M28Building.reftArtiTemplateRefs][2]..'T'..oJustBuilt[M28Building.reftArtiTemplateRefs][3]..'; tTableRef[M28Map.subrefbForceRefreshOfArtiToBuild]='..tostring(tTableRef[M28Map.subrefbForceRefreshOfArtiToBuild] or false)..'; Is tTableRef nil='..tostring(tTableRef == nil)..'; Time='..GetGameTimeSeconds()) end
                        end
                        --QAI chat
                        if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oJustBuilt.UnitId) and oJustBuilt:GetAIBrain()[M28Chat.refiAssignedPersonality] == M28Chat.refiQAI and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] < 8000 and M28UnitInfo.GetUnitLifetimeCount(oJustBuilt) == 1 then
                            ForkThread(M28Chat.ConsiderQAIAboutToAttackMessage, oJustBuilt)
                        end

                        --Engineer owns a paragon and just built a mobile exp - have it keep building in same location
                        if aiBrain[M28Economy.refbBuiltParagon] and EntityCategoryContains(categories.MOBILE, oJustBuilt.UnitId) and oEngineer:CanBuild(oJustBuilt.UnitId) then
                            local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oJustBuilt:GetPosition(), true, iTeam)
                            if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftActiveGameEnderTemplates][1]) == false then
                                --Try and rebuild the same unit
                                M28Orders.IssueTrackedClearCommands(oEngineer)
                                local iAction
                                if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oJustBuilt.UnitId) then
                                    iAction = M28Engineer.refActionBuildLandExperimental
                                else
                                    iAction = M28Engineer.refActionBuildExperimental
                                end
                                M28Engineer.TrackEngineerAction(oEngineer, iAction, true, 1, nil, nil, false)
                                M28Orders.IssueTrackedBuild(oEngineer, oJustBuilt:GetPosition(), oJustBuilt.UnitId, false, 'ParaRebldExp')
                                M28Micro.TrackTemporaryUnitMicro(oEngineer, 30)
                                if bDebugMessages == true then LOG(sFunctionRef..': Will try and rebuild the experimental we just built, oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; oJustBuilt='..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; iAction='..iAction) end
                            end
                        end
                        --Loud T2 sniperbots - consider enhancement
                    elseif (M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) and oJustBuilt.UnitId == 'ual0204' and (M28UnitInfo.GetUnitLifetimeCount(oJustBuilt) >= 15 or EntityCategoryContains(categories.TECH3, oEngineer.UnitId)) then
                        ForkThread(M28Land.DelayedGetFirstEnhancementOnUnit, oJustBuilt, 6)
                        --Sniperbots - if we have built 4+ by the same player then also prioritise omni
                    elseif (oJustBuilt[M28UnitInfo.refiDFRange] or 0) >= 55 and M28UnitInfo.GetUnitLifetimeCount(oJustBuilt) >= 4 then aiBrain[M28Overseer.refbBuiltLongRangeLandUnit] = true
                    end

                    --Experimental air - no longer record in land/water zone
                    if EntityCategoryContains(M28UnitInfo.refCategoryAllAir - M28UnitInfo.refCategoryEngineer, oJustBuilt.UnitId) then
                        --Transport specific - tell the factory that just built the transport to build something else
                        if EntityCategoryContains(M28UnitInfo.refCategoryTransport, oJustBuilt.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryAirFactory * categories.TECH1, oEngineer.UnitId) then
                            oEngineer[M28Factory.refbWantNextUnitToBeEngineer] = true
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryBomber * categories.TECH3, oJustBuilt.UnitId) and not(oJustBuilt[M28Air.refbBomberUsingMexHunterLogic]) then
                            ForkThread(M28Air.ApplyMexHuntingLogicToBomber, oJustBuilt)
                        end

                        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oJustBuilt:GetPosition())
                        if (iLandOrWaterZone or 0) > 0 then
                            local tLZOrWZData
                            local tLZOrWZTeamData
                            local sUnitTableRef

                            if iPlateauOrZero == 0 then
                                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                                sUnitTableRef = M28Map.subreftoLZOrWZAlliedUnits
                            else
                                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                                sUnitTableRef = M28Map.subreftoLZOrWZAlliedUnits
                            end
                            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[sUnitTableRef]) == false then
                                for iUnit, oUnit in tLZOrWZTeamData[sUnitTableRef] do
                                    if oUnit == oJustBuilt then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Removing unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from zone '..iLandOrWaterZone..' as it is a construction completed experimental') end
                                        table.remove(tLZOrWZTeamData[sUnitTableRef], iUnit)
                                        break
                                    end
                                end
                            end
                        end
                    end

                    --Logic based on the unit that was just built:

                    --Check build locations for units not built at a factory
                    local bDontClearEngineer = false
                    if bDebugMessages == true then LOG(sFunctionRef..': Will now consider logic for units not built at a factory, was this a structure or experimental='..tostring(EntityCategoryContains(categories.STRUCTURE + categories.EXPERIMENTAL, oJustBuilt.UnitId))..'; Upgradesto='..(oJustBuilt:GetBlueprint().UpgradesTo or 'nil')..'; is this a mass fab that can upgrade='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryMassFab, oJustBuilt.UnitId) and not((oJustBuilt:GetBlueprint().General.UpgradesTo or '') == ''))) end
                    if EntityCategoryContains(categories.STRUCTURE + categories.EXPERIMENTAL, oJustBuilt.UnitId) then

                        if not(oJustBuilt[M28UnitInfo.refbConstructionStart]) then
                            M28Engineer.CheckIfBuildableLocationsNearPositionStillValid(aiBrain, oJustBuilt:GetPosition(), false, M28UnitInfo.GetBuildingSize(oJustBuilt.UnitId) * 0.5)
                        end
                        M28Economy.UpdateHighestFactoryTechLevelForBuiltUnit(oJustBuilt) --includes a check to see if are dealing with a factory HQ
                        if EntityCategoryContains(M28UnitInfo.refCategoryMex, oJustBuilt.UnitId) then
                            M28Team.tTeamData[iTeam][M28Team.refiUpgradedMexCount] = (M28Team.tTeamData[iTeam][M28Team.refiUpgradedMexCount] or 0) + 1
                            oJustBuilt[M28UnitInfo.refiTimeMexConstructed] = GetGameTimeSeconds()
                            ForkThread(M28Economy.UpdateZoneM28MexByTechCount, oJustBuilt, false, 10)
                            --If this is a t3 mex and we have a paragon, then gift the mex to teammate, otherwise gift the storage from teammates to us
                            local bGiftingToTeammate = false
                            if oJustBuilt:GetAIBrain()[M28Economy.refbBuiltParagon] and not((oJustBuilt:GetBlueprint().General.UpgradesTo or '') == '') then
                                local oM28BrainToGiftTo
                                local oOtherBrainToGiftTo
                                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                                    if not(oBrain == oJustBuilt:GetAIBrain()) then
                                        if oBrain.M28AI then
                                            if not(oM28BrainToGiftTo) then
                                                oM28BrainToGiftTo = oBrain
                                                break
                                            end
                                        else
                                            if not(oOtherBrainToGiftTo) then oOtherBrainToGiftTo = oBrain end
                                        end
                                    end
                                end
                                if oOtherBrainToGiftTo or  oM28BrainToGiftTo then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will gift T3 mex we have just built to teammate as we have a paragon, oM28BrainToGiftTo='..(oM28BrainToGiftTo.Nickname or 'nil')..'; oOtherBrainToGiftTo='..(oOtherBrainToGiftTo.Nickname or 'nil')..'; Time='..GetGameTimeSeconds()) end
                                    bGiftingToTeammate = true
                                    ForkThread(M28Team.DelayedUnitTransferToPlayer, { oJustBuilt }, (oM28BrainToGiftTo or oOtherBrainToGiftTo):GetArmyIndex(), 0.2)
                                end
                            else
                                --If have storage owned by M28 on same team by this mex, gift it over
                                --All mexes - on construction check if we have allied M28 mass storage nearby (e.g. we have rebuilt on a mex that they used to have) and if so then have that M28 gift over their mass storage
                                M28Team.GiftAdjacentStorageToMexOwner(oJustBuilt)
                            end

                            --Update part built t1 mex tracking
                            if EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oJustBuilt.UnitId) then
                                M28Engineer.UpdatePartBuiltListForCompletedMex(oJustBuilt)
                                --Check if teammate has enough factories that we should give this to them - require mex to be closer to their base and for them to have factories in the zone, and for us to have no T2+ mexes
                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) == false and table.getn(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains]) > 1 then
                                    local iMexPlateau, iMexZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oJustBuilt:GetPosition())
                                    local iTeam = oJustBuilt:GetAIBrain().M28Team
                                    local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oJustBuilt:GetPosition(), true, iTeam)
                                    if GetGameTimeSeconds() >= 100 and not(tLZTeamData[M28Map.subrefLZbCoreBase]) and (tLZTeamData[M28Map.refiNonM28TeammateFactoryCount] or 0) > 0 and tLZTeamData[M28Map.subrefMexCountByTech][2] == 0 and tLZTeamData[M28Map.subrefMexCountByTech][3] == 0 and tLZTeamData[M28Map.subrefMexCountByTech][1] <= math.max(3, (tLZData[M28Map.subrefLZOrWZMexCount] or 0) * 0.5) then
                                        local iClosestNonM28BrainDistBase = 100000
                                        local oClosestNonM28Brain
                                        local iClosestM28BrainDistBase = 100000
                                        local bInSameZoneAsNonM28AIStart
                                        local iBrainPlateau, iBrainZone

                                        local iCurDist
                                        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                                            if not(oBrain:IsDefeated()) and (oBrain.M28AI or ScenarioInfo.Options.M28Teammate == 1) then
                                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oJustBuilt:GetPosition(), M28Map.GetPlayerStartPosition(oBrain))
                                                if oBrain.M28AI then iClosestM28BrainDistBase = math.min(iClosestM28BrainDistBase, iCurDist)
                                                else
                                                    if iClosestNonM28BrainDistBase > iCurDist then
                                                        iClosestNonM28BrainDistBase = iCurDist
                                                        oClosestNonM28Brain = oBrain
                                                    end
                                                    if iClosestNonM28BrainDistBase <= 200 and not(bInSameZoneAsNonM28AIStart) then
                                                        iBrainPlateau, iBrainZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(M28Map.GetPlayerStartPosition(oBrain))
                                                        if iBrainPlateau == iMexPlateau and iBrainZone == iMexZone then
                                                            bInSameZoneAsNonM28AIStart = true
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to gift T1 mex '..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..' to a teammate, iClosestNonM28BrainDistBase='..iClosestNonM28BrainDistBase..'; iClosestM28BrainDistBase='..iClosestM28BrainDistBase) end
                                        if iClosestNonM28BrainDistBase <= 200 and (bInSameZoneAsNonM28AIStart or iClosestNonM28BrainDistBase + 50 <= iClosestM28BrainDistBase) then
                                            --Dont gift a human player's mexes in shared army mode, even if M28 logic is active
                                            if M28Orders.bDontConsiderCombinedArmy or (oJustBuilt.M28Active and not(oJustBuilt:GetAIBrain().BrainType == 'Human')) then
                                                --Check we have enough mexes to be able to gift
                                                local iOurMexes = oJustBuilt:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMex)
                                                local iTeammateMexes = oJustBuilt:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMex)
                                                if iOurMexes >= iTeammateMexes * 0.6 and iOurMexes >= 2 then
                                                    ForkThread(M28Team.DelayedUnitTransferToPlayer, { oJustBuilt }, oClosestNonM28Brain:GetArmyIndex(), 0.2)
                                                    local sPotentialMessages = {
                                                        [1] = 'I guess this is one of your mexes '..oClosestNonM28Brain.Nickname..', try to claim it faster next time',
                                                        [2] = 'You look like you could use this mex more than me '..oClosestNonM28Brain.Nickname,
                                                        [3] = 'Transferred t1 mex to '..oClosestNonM28Brain.Nickname,
                                                        [4] = 'I\'ve just given you a mex '..oClosestNonM28Brain.Nickname,
                                                        [5] = 'Have this mex '..oClosestNonM28Brain.Nickname..', I hope this means we can be friends',
                                                        [6] = 'My master says I must help my team more, so have a mex '..oClosestNonM28Brain.Nickname,
                                                        [7] = 'Given you a mex '..oClosestNonM28Brain.Nickname,
                                                        [8] = 'Have this mex I\'ve just built '..oClosestNonM28Brain.Nickname
                                                    }
                                                    local sMessage = sPotentialMessages[math.random(1, table.getn(sPotentialMessages))] or sPotentialMessages[1]
                                                    --SendMessage(aiBrain, sMessageType, sMessage, iOptionalDelayBeforeSending, iOptionalTimeBetweenMessageType, bOnlySendToTeam, bWaitUntilHaveACU, sOptionalSoundCue, sOptionalSoundBank, oOptionalOnlyBrainToSendTo)
                                                    M28Chat.SendMessage(oJustBuilt:GetAIBrain(), 'MexGiftF'..oJustBuilt:GetAIBrain().M28Team..'T'..oClosestNonM28Brain:GetArmyIndex(), sMessage, 1, 90, true, true)
                                                end
                                            end
                                            bGiftingToTeammate = true
                                        end
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to apply special logic for upgrading further mex in the zone after this one, was this a T1 mex='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oJustBuilt.UnitId))..'; bGiftingToTeammate='..tostring(bGiftingToTeammate or false)) end
                            if not(bGiftingToTeammate) then
                                if EntityCategoryContains(M28UnitInfo.refCategoryMex, oJustBuilt.UnitId) then
                                    --If can upgrade then consider future upgrade
                                    local sUpgrade = oJustBuilt:GetBlueprint().General.UpgradesTo
                                    if sUpgrade and not(sUpgrade == '') then
                                        ForkThread(M28Economy.ConsiderFutureMexUpgrade, oJustBuilt) --i.e. to cover cases where after this mex survives a while we want ot upgrade it some more
                                        if EntityCategoryContains(categories.TECH3, oJustBuilt.UnitId) then M28Economy.bT3MexCanBeUpgraded = true end
                                    end
                                    --Unpause a paused mex if we are in a stall
                                    ForkThread(M28Economy.UnpausePausedMexFollowingUpgrade, oJustBuilt, not((sUpgrade or '') == nil))
                                end
                                --COnsider upgrading another mex in this zone
                                ForkThread(M28Economy.ConsiderUpgradingMexDueToCompletion, oJustBuilt, oEngineer) --i.e. intention is to cover cases where we have the eco from just completing a mex upgrade to then upgrade another of the same tech level (or in some cases upgrade this/a simialr tech to higher tech)
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMassStorage, oJustBuilt.UnitId) then
                            M28Building.ConsiderGiftingMassStorageToNearbyMexOwner(oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryEnergyStorage, oJustBuilt.UnitId) then
                            M28Team.TeamEconomyRefresh(iTeam)
                            M28Team.ConsiderGiftingStorageToTeammate(oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oJustBuilt.UnitId) then
                            --Clear the desire to build land facs by mexes - i.e. only want hte first one to be built as such (exception - LOUD if cant build mass storage)
                            if M28Building.iLowestMassStorageTechAvailable <= 2 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have just build land factory so clearing adjacency desire for all M28 brains') end
                                M28Engineer.tiActionAdjacentCategory[M28Engineer.refActionBuildLandFactory] = nil
                            end
                            if M28UnitInfo.GetUnitLifetimeCount(oJustBuilt) == 1 and EntityCategoryContains(categories.TECH1, oJustBuilt.UnitId) and EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then
                                --Make first land factory built be a core base if it isnt already
                                local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oJustBuilt:GetPosition(), true, oJustBuilt:GetAIBrain().M28Team)
                                if bDebugMessages == true then LOG(sFunctionRef..': Just built our first land factory with our ACU, is this core base='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])) end
                                if not(tLZTeamData[M28Map.subrefLZbCoreBase]) then
                                    tLZTeamData[M28Map.subrefbCoreBaseOverride] = true
                                end
                                --Set primary factory flag if on and island or plateau dif to our main base, and no other constructed factories here, and mod dist is >=0.2
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory - categories.TECH3, oJustBuilt.UnitId) then
                                local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oJustBuilt:GetPosition(), true, oJustBuilt:GetAIBrain().M28Team)
                                local NavUtils = M28Utilities.NavUtils
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering oJsutBuilt='..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; Mod dist%='..tLZTeamData[M28Map.refiModDistancePercent]..'; Island ref='..tLZData[M28Map.subrefLZIslandRef]..'; Island ref of nearest base='..NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestFriendlyBase])) end
                                if tLZTeamData[M28Map.refiModDistancePercent] >= 0.2 and not(tLZData[M28Map.subrefLZIslandRef] == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestFriendlyBase])) then
                                    local iTotalLandFacsOfSameOrBetterTechInZoneOrAdjacent = 0
                                    local iTechLevelWanted = M28UnitInfo.GetUnitTechLevel(oJustBuilt)
                                    function ConsiderCurZone(tCurLZTeamData)
                                        if M28Utilities.IsTableEmpty(tCurLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                            local tOtherFacs = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tCurLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                            if M28Utilities.IsTableEmpty(tOtherFacs) == false then
                                                for iFac, oFac in tOtherFacs do
                                                    if M28UnitInfo.IsUnitValid(oFac) and oFac:GetFractionComplete() >= 1 and M28UnitInfo.GetUnitTechLevel(oFac) >= iTechLevelWanted then
                                                        iTotalLandFacsOfSameOrBetterTechInZoneOrAdjacent = iTotalLandFacsOfSameOrBetterTechInZoneOrAdjacent + 1
                                                        if iTotalLandFacsOfSameOrBetterTechInZoneOrAdjacent >= 2 then break end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    ConsiderCurZone(tLZTeamData)
                                    if bDebugMessages == true then LOG(sFunctionRef..': iTotalLandFacsOfSameOrBetterTechInZoneOrAdjacent='..iTotalLandFacsOfSameOrBetterTechInZoneOrAdjacent) end
                                    if iTotalLandFacsOfSameOrBetterTechInZoneOrAdjacent <= 1 then
                                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                            local iPlateau, iLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oJustBuilt:GetPosition())
                                            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                                local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                                                local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                                                ConsiderCurZone(tAdjLZTeamData)
                                            end
                                        end
                                        if iTotalLandFacsOfSameOrBetterTechInZoneOrAdjacent <= 1 then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Setting primary factory flag to true for factory '..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)) end
                                            oJustBuilt[M28Factory.refbPrimaryFactoryForIslandOrPond] = true
                                        end
                                    end
                                end
                                --refbPrimaryFactoryForIslandOrPond
                            end

                            M28Economy.ConsiderImmediateUpgradeOfFactory(oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oJustBuilt.UnitId) then
                            M28Economy.ConsiderImmediateUpgradeOfFactory(oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, oJustBuilt.UnitId) then
                            ForkThread(M28Building.GetT3ArtiTarget, oJustBuilt)
                            ForkThread(M28Economy.JustBuiltT2PlusPowerOrExperimentalInZone, oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryPD * categories.TECH1 + M28UnitInfo.refCategoryWall, oJustBuilt.UnitId) then
                            --Build T1 walls around T1 PD
                            --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition,                                           oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
                            local sWallBP = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28Engineer.tiActionCategory[M28Engineer.refActionBuildWall], oEngineer)
                            if sWallBP then
                                local tWallBuildLocation = M28Engineer.GetLocationToBuildWall(oEngineer, oJustBuilt, sWallBP)
                                if tWallBuildLocation and oEngineer:GetAIBrain().M28AI then
                                    --First generate list of other engineers to also help with wall building (as theyll potentially get cleared when we clear the original engineer)
                                    local tOtherEngineersHelpingConstruction = {}
                                    local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oJustBuilt:GetPosition(), true, oEngineer:GetAIBrain().M28Team)
                                    local tEngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                    if M28Utilities.IsTableEmpty(tEngineersInZone) == false then
                                        for iUnit, oUnit in tEngineersInZone do
                                            if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering other engineer in zone, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Assigned action='..(oUnit[M28Engineer.refiAssignedAction] or 'nil')) end
                                                if oUnit[M28Engineer.refiAssignedAction] == M28Engineer.refActionBuildEmergencyPD then --dont need to do for walsl as eahc engi builds individually
                                                    local oFocusUnit = oUnit:GetFocusUnit()
                                                    if bDebugMessages == true then
                                                        LOG(sFunctionRef..': oFocusUnit='..(oFocusUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oFocusUnit) or 'nil')..'; Last order='..reprs(oUnit[M28Orders.reftiLastOrders]))
                                                        if M28Utilities.IsTableEmpty(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]) == false then
                                                            LOG(sFunctionRef..': Dist of last order to just built='..M28Utilities.GetDistanceBetweenPositions(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition], oJustBuilt:GetPosition())..'; Dist of last order to engineer='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oJustBuilt:GetPosition()))
                                                        end
                                                    end

                                                    if oFocusUnit == oEngineer or oFocusUnit == oJustBuilt or (not(oFocusUnit) and M28Utilities.IsTableEmpty(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]) == false and M28Utilities.GetDistanceBetweenPositions(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition], oJustBuilt:GetPosition()) < 1 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oJustBuilt:GetPosition()) <= oUnit:GetBlueprint().Economy.MaxBuildDistance + 1) then
                                                        table.insert(tOtherEngineersHelpingConstruction, oUnit)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': have a supporting engineer that helped build the T1 PD') end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    M28Orders.IssueTrackedBuild(oEngineer, tWallBuildLocation, sWallBP, false, 'WallP')
                                    M28Engineer.TrackEngineerAction(oEngineer, M28Engineer.refActionBuildWall, true, 1)
                                    bDontClearEngineer = true
                                    if M28Utilities.IsTableEmpty(tOtherEngineersHelpingConstruction) == false then
                                        for iUnit, oUnit in tOtherEngineersHelpingConstruction do
                                            local tWallBuildLocation = M28Engineer.GetLocationToBuildWall(oUnit, oJustBuilt, sWallBP)
                                            if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; tWallBuildLocation='..repru(tWallBuildLocation)) end
                                            if tWallBuildLocation then
                                                M28Orders.IssueTrackedBuild(oUnit, tWallBuildLocation, sWallBP, false, 'WallS')
                                                M28Engineer.TrackEngineerAction(oUnit, M28Engineer.refActionBuildWall, true, 1)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will tell unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to build a wall at '..repru(tWallBuildLocation)) end
                                            end
                                        end
                                    end
                                end
                            end
                            --T2 PD - get TMD preemptively if built a number
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryPD * categories.TECH2, oJustBuilt.UnitId) then
                            ForkThread(M28Building.ConsiderGettingPreemptiveTMD, oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryPower, oJustBuilt.UnitId) then --In LOUD t2 pgen upgrades to t3 are as efficient as t3 pgens
                            local sUpgrade = oJustBuilt:GetBlueprint().General.UpgradesTo
                            if sUpgrade and not(sUpgrade == '') then
                                ForkThread(M28Economy.ConsiderPowerPgenUpgrade, oJustBuilt)
                            else
                                ForkThread(M28Building.ConsiderGiftingPowerToTeammateForAdjacency, oJustBuilt)
                            end
                            ForkThread(M28Economy.JustBuiltT2PlusPowerOrExperimentalInZone, oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMassFab, oJustBuilt.UnitId) and not((oJustBuilt:GetBlueprint().General.UpgradesTo or '') == '') then
                            ForkThread(M28Economy.ConsiderMassFabUpgrade, oJustBuilt, 0)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryPower * categories.TECH2, oJustBuilt.UnitId) then
                            ForkThread(M28Economy.JustBuiltT2PlusPowerOrExperimentalInZone, oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySMD, oJustBuilt.UnitId) then
                            --If we have a paragon on the team then gift this to a paragon owner
                            local oBrainToTransferTo
                            if M28Team.tTeamData[iTeam][M28Team.refbBuiltParagon] and not(oJustBuilt:GetAIBrain()[M28Economy.refbBuiltParagon]) then
                                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyHumanAndAIBrains] do
                                    if not(oBrain == oJustBuilt:GetAIBrain()) then
                                        if oBrain.M28AI and oBrain[M28Economy.refbBuiltParagon] then
                                            oBrainToTransferTo = oBrain
                                            break
                                        end
                                    end
                                end
                            end
                            if oBrainToTransferTo then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will gift SMD we have just built to teammate as they have a paragon, oBrainToTransferTo='..(oBrainToTransferTo.Nickname or 'nil')..'; Cur owner='..oJustBuilt:GetAIBrain().Nickname..'; Time='..GetGameTimeSeconds()) end
                                ForkThread(M28Team.DelayedUnitTransferToPlayer, { oJustBuilt }, oBrainToTransferTo:GetArmyIndex(), 0.2)
                            else
                                --If enemy has nuke then flag we need resources for missile
                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false then
                                    M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] = true
                                end
                            end

                            ForkThread(M28Economy.JustBuiltT2PlusPowerOrExperimentalInZone, oJustBuilt)
                            --T2 arti - consider manual shot targets
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oJustBuilt.UnitId) then
                            ForkThread(M28Building.ConsiderManualT2ArtiTarget, oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oJustBuilt.UnitId) then
                            --Cybran ED1 shields - upgrade if enemy has novax or t3 arti
                            if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield * categories.BUILTBYTIER2ENGINEER * categories.CYBRAN, oJustBuilt.UnitId) then
                                if M28Team.tTeamData[oJustBuilt:GetAIBrain().M28Team][M28Team.refbDefendAgainstArti] then
                                    M28Economy.UpgradeUnit(oJustBuilt, true)
                                end
                            end

                            --Shield tracking
                            if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield  - categories.TECH2 - categories.TECH1, oJustBuilt.UnitId) then
                                local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oJustBuilt:GetPosition(), true, oJustBuilt:GetAIBrain().M28Team)
                                if tLZTeamData then
                                    tLZTeamData[M28Map.subrefiT3FixedShieldConstructedCount] = (tLZTeamData[M28Map.subrefiT3FixedShieldConstructedCount] or 0) + 1
                                    if oJustBuilt:GetBlueprint().Defense.Shield.ShieldMaxHealth >= M28Building.iExperimentalShieldHealthValue then
                                        tLZTeamData[M28Map.subrefiExperimentalShieldConstructedCount] = (tLZTeamData[M28Map.subrefiExperimentalShieldConstructedCount] or 0) + 1
                                    end
                                end
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oJustBuilt.UnitId) then
                            ForkThread(M28Economy.JustBuiltT2PlusPowerOrExperimentalInZone, oJustBuilt)
                            if EntityCategoryContains(M28UnitInfo.refCategoryEnergyStorage + M28UnitInfo.refCategoryParagon + M28UnitInfo.refCategoryQuantumOptics, oJustBuilt.UnitId) then
                                M28Team.TeamEconomyRefresh(iTeam)
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryEnergyStorage + M28UnitInfo.refCategoryParagon + M28UnitInfo.refCategoryQuantumOptics, oJustBuilt.UnitId) then
                            --I.e. for energy storage units not caught by energy storage above or experimental level (paragon) - i.e. first two categories are just a redundancy
                            M28Team.TeamEconomyRefresh(iTeam)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oJustBuilt.UnitId) then
                            --Navy personality - assign all naval facs to it if it is the primary brain for this zone
                            if not(EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oEngineer.UnitId)) and not(oJustBuilt:GetAIBrain()[M28Overseer.refbPrioritiseNavy]) then
                                local tWZData, tWZTeamData = M28Map.GetLandOrWaterZoneData(oJustBuilt:GetPosition(), true, oJustBuilt:GetAIBrain().M28Team)
                                if ArmyBrains[tWZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Overseer.refbPrioritiseNavy] then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will gift naval fac to the brain prioritising navy') end
                                    ForkThread(M28Team.TransferUnitsToPlayer, { oJustBuilt }, tWZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex], false)
                                end
                            end
                        end
                        if EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti - categories.MOBILE + M28UnitInfo.refCategorySML * categories.TECH3 + M28UnitInfo.refCategoryAirFactory * categories.TECH3 + M28UnitInfo.refCategoryMassFab * categories.TECH3 + M28UnitInfo.refCategoryT3Radar, oJustBuilt.UnitId) then
                            ForkThread(M28Building.ConsiderGiftingPowerToTeammateForAdjacency, oJustBuilt)
                        end
                        --Clear engineers that just built this
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryIndirect * categories.TECH1, oJustBuilt.UnitId) then
                        --Check if we have transports wanting combat drops
                        local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oJustBuilt:GetPosition(), true, oJustBuilt:GetAIBrain().M28Team)
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoTransportsWaitingForUnits]) == false then
                            for iTransport, oTransport in tLZTeamData[M28Map.reftoTransportsWaitingForUnits] do
                                if (oTransport[M28Air.refiCombatUnitsWanted] or 0) > 0 then
                                    ForkThread(M28Air.LoadCombatUnitOntoTransport, oJustBuilt)
                                    break
                                end
                            end
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryIndirectT3, oJustBuilt.UnitId) then
                        if not(M28Team.tTeamData[iTeam][M28Team.refbBuiltLotsOfT3Combat]) then
                            if M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryIndirectT3) >= 30 then
                                M28Team.tTeamData[iTeam][M28Team.refbBuiltLotsOfT3Combat] = true
                            end
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer * categories.TECH3, oJustBuilt.UnitId) then
                        --Late game - destroy lower tech engineers to help with pathing (up to 2 for every T3 engi built)
                        ForkThread(M28Engineer.ConsiderDestroyingLowTechEngineers, oJustBuilt)
                        --Moved below to 'oncreate'
                        --First engineer (for if want to check if can build certain modded units) - have done LC<=5 in case the first few engineers we try building die
                        --[[if M28UnitInfo.GetUnitLifetimeCount(oJustBuilt) <= 5 then
                            ForkThread(M28Building.AssessT3EngineerConstructionOptions, oJustBuilt)
                        end--]]
                    elseif EntityCategoryContains(categories.MOBILE * categories.SUBMERSIBLE, oJustBuilt.UnitId) then
                        ForkThread(M28Navy.DelayedCheckIfShouldSubmerge, oJustBuilt)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oJustBuilt.UnitId) then
                        if not(M28Team.tLandSubteamData[oJustBuilt:GetAIBrain().M28LandSubteam][M28Team.refbConsideredScoutFactionRestrictions]) then
                            M28Team.UpdateFactionBlueprintBlacklist(oJustBuilt:GetAIBrain().M28LandSubteam)
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryBomber * categories.TECH1, oJustBuilt.UnitId) then
                        if M28UnitInfo.GetUnitLifetimeCount(oJustBuilt) == 1 then
                            oEngineer[M28Factory.refbJustBuiltFirstT1Bomber] = true
                            M28Utilities.DelayChangeVariable(oEngineer, M28Factory.refbJustBuiltFirstT1Bomber, false, 5)
                        end
                    end

                    --Update economy tracking (this function will check if it is an economic unit as part of it)
                    M28Economy.UpdateGrossIncomeForUnit(oJustBuilt)
                    if EntityCategoryContains(M28UnitInfo.refCategoryScathis, oJustBuilt.UnitId) then
                        table.insert(M28Engineer.tAllScathis, oJustBuilt)
                    end

                    if EntityCategoryContains(M28UnitInfo.refCategorySatellite, oJustBuilt.UnitId) then
                        if bDebugMessages == true then LOG(sFunctionRef..'Novax created, reprs='..reprs(oUnit)) end
                        ForkThread(M28Air.DetachSatellite,oJustBuilt, 1)
                    end


                    --Logic based on the engineer
                    if oEngineer:GetAIBrain().M28AI then
                        if EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then
                            M28ACU.GetACUOrder(oEngineer:GetAIBrain(), oEngineer)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryQuantumGateway + M28UnitInfo.refCategoryMobileLandFactory + M28UnitInfo.refCategorySpecialFactory + M28UnitInfo.refCategoryMobileAircraftFactory + categories.EXTERNALFACTORYUNIT, oEngineer.UnitId) then
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': A factory has just built a unit so will get the next order for the factory, oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer))
                            end
                            ForkThread(M28Factory.DecideAndBuildUnitForFactory, oEngineer:GetAIBrain(), oEngineer)
                            --Treat the unit just built as having micro active so it doesn't receive orders for a couple of seconds (so it can clear the factory)
                            if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryNavalFactory + M28UnitInfo.refCategoryMobileLandFactory, oEngineer.UnitId) and EntityCategoryContains(categories.MOBILE - categories.AIR, oJustBuilt.UnitId) then
                                --Also give unit a move order (queued onto its existing order)
                                if M28Utilities.IsTableEmpty(oEngineer[M28Factory.reftFactoryRallyPoint]) then
                                    M28Factory.SetFactoryRallyPoint(oEngineer)
                                end

                                M28Orders.IssueTrackedMove(oJustBuilt, oEngineer[M28Factory.reftFactoryRallyPoint], 0.1, true, 'RollOff', false)

                                M28Micro.TrackTemporaryUnitMicro(oJustBuilt, 1.5) --i.e. want to increase likelihood that a unit has exited the land factory before it starts being given orders

                                if bDebugMessages == true then LOG(sFunctionRef..': Engineer parent='..reprs(oEngineer.Parent)..'; Unit ID = or parent'..(oEngineer.Parent.UnitId or 'nil')) end
                                if oEngineer.UnitId == 'uel0401ef' or (oEngineer.Parent.UnitId and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oEngineer.Parent.UnitId)) or EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oEngineer.UnitId) then
                                    --Want some MAA to stick by fatboy so theyre protected by its shield
                                    if EntityCategoryContains(M28UnitInfo.refCategoryMAA, oJustBuilt.UnitId) then
                                        local oUnitToAssignTo
                                        if oEngineer.Parent.UnitId and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oEngineer.Parent.UnitId) then oUnitToAssignTo = oEngineer.Parent
                                        else oUnitToAssignTo = oEngineer
                                        end
                                        ForkThread(M28Land.ConsiderAssigningMAABodyguardToFatboy,oJustBuilt, oUnitToAssignTo)
                                    end
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory - categories.MOBILE, oEngineer.UnitId) then
                                    --Consider assigning T2 MAA to ACU
                                    if EntityCategoryContains(M28UnitInfo.refCategoryMAA * categories.TECH2, oJustBuilt.UnitId) then
                                        ForkThread(M28Land.ConsiderAssigningMAABodyguardToACU, oJustBuilt)
                                    end
                                end
                            end


                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to clear refiFirstTimeOfLastOrder='..(oEngineer[M28Factory.refiFirstTimeOfLastOrder] or 'nil')..' for facotyr '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' at game time '..GetGameTimeSeconds()) end
                            if oEngineer[M28Factory.refiFirstTimeOfLastOrder] and GetGameTimeSeconds() - oEngineer[M28Factory.refiFirstTimeOfLastOrder] > 0.1 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Clearing refiFirstTimeOfLastOrder for the factory') end
                                oEngineer[M28Factory.refiFirstTimeOfLastOrder] = nil
                            end --Clear time as only want to use this to track incase have blocking unit
                            oEngineer[M28Factory.refiTotalBuildCount] = (oEngineer[M28Factory.refiTotalBuildCount] or 0) + 1
                            oEngineer:GetAIBrain()[M28Factory.refiHighestFactoryBuildCount] = math.max((oEngineer:GetAIBrain()[M28Factory.refiHighestFactoryBuildCount] or 0), (oEngineer[M28Factory.refiTotalBuildCount] or 0))
                            --If T3 support factory just built a T1 unit, then consider gifting it to a teammate
                            if EntityCategoryContains(M28UnitInfo.categories.SUPPORTFACTORY * categories.TECH3, oEngineer.UnitId) and EntityCategoryContains(categories.TECH1, oJustBuilt.UnitId) then
                                --Do we lack HQs for this brain and are dealing with an air or naval fac (since land fac should rebuild anyway)
                                if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oEngineer.UnitId) then
                                    if oEngineer:GetAIBrain()[M28Economy.refiOurHighestAirFactoryTech] == 0 then
                                        ForkThread(M28Team.ConsiderGiftingSupportFactoriesToTeammateWithBetterHQ, oEngineer:GetAIBrain(), oEngineer.UnitId)
                                    end
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oEngineer.UnitId) then
                                    if oEngineer:GetAIBrain()[M28Economy.refiOurHighestNavalFactoryTech] == 0 then
                                        ForkThread(M28Team.ConsiderGiftingSupportFactoriesToTeammateWithBetterHQ, oEngineer:GetAIBrain(), oEngineer.UnitId)
                                    end
                                end
                            end

                            --External factories that have just built an air unit - unload the air unit
                            if EntityCategoryContains(categories.EXTERNALFACTORYUNIT, oEngineer.UnitId) and EntityCategoryContains(categories.AIR - categories.EXPERIMENTAL, oJustBuilt.UnitId) and oEngineer.Parent.UnitId then
                                local oParentUnit = oEngineer.Parent
                                if bDebugMessages == true then LOG(sFunctionRef..': Just built unit state='..M28UnitInfo.GetUnitState(oJustBuilt)..'; Will try and unload from the engineer; reprs='..reprs(oEngineer)..'; oParentUnit UnitID='..(oParentUnit.UnitId or 'nil')) end
                                local tCargo = oParentUnit:GetCargo()
                                if M28Utilities.IsTableEmpty(tCargo) == false then
                                    M28Orders.ReleaseStoredUnits(oParentUnit, false, 'Carrier', false)
                                end
                            end

                        elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oEngineer.UnitId) then
                            --Clear any engineers trying to build this unit if we just built a building or experimental
                            if not(bDontClearEngineer) and EntityCategoryContains(categories.STRUCTURE + categories.EXPERIMENTAL, oJustBuilt.UnitId) then
                                M28Engineer.ClearEngineersBuildingUnit(oEngineer, oJustBuilt, true)
                            end
                        end
                    end

                    --Logic based on the type of unit built
                    if EntityCategoryContains(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryQuantumGateway + M28UnitInfo.refCategoryMobileLandFactory + M28UnitInfo.refCategorySpecialFactory + M28UnitInfo.refCategoryMobileAircraftFactory + categories.EXTERNALFACTORYUNIT, oJustBuilt.UnitId) then
                        if bDebugMessages == true then LOG(sFunctionRef..': A factory has just been built so will get the next order for the factory') end
                        --If our team has a paragon then add a 66% chance we xfer the factory to the paragon owner
                        local oParagonBrainToTransferTo
                        if (M28Orders.bDontConsiderCombinedArmy or oJustBuilt.M28Active) and M28Team.tTeamData[iTeam][M28Team.refbBuiltParagon] and not(aiBrain[M28Economy.refbBuiltParagon]) and math.random(1,3) < 3 and EntityCategoryContains(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryQuantumGateway - M28UnitInfo.refCategoryAllHQFactories, oJustBuilt.UnitId) then
                            local oParagonBrain
                            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                if oBrain[M28Economy.refbBuiltParagon] then oParagonBrainToTransferTo = oBrain break end
                            end
                        end
                        if oParagonBrainToTransferTo then
                            ForkThread(M28Team.TransferUnitsToPlayer, { oJustBuilt }, oParagonBrainToTransferTo:GetArmyIndex(), false)
                        else
                            ForkThread(M28Factory.DecideAndBuildUnitForFactory, aiBrain, oJustBuilt)

                            if EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oJustBuilt.UnitId) then
                                aiBrain[M28Economy.refiOurHighestFactoryTechLevel] = math.max(M28UnitInfo.GetUnitTechLevel(oJustBuilt), aiBrain[M28Economy.refiOurHighestFactoryTechLevel])
                            end
                        end
                    elseif EntityCategoryContains(categories.STEALTH, oJustBuilt.UnitId) or (oJustBuilt:GetBlueprint().Intel.RadarStealth and oJustBuilt:GetBlueprint().General.OrderOverrides.RULEUTC_StealthToggle) then
                        --Make sure stealth is enabled
                        M28UnitInfo.EnableUnitStealth(oJustBuilt)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryPower + M28UnitInfo.refCategoryT3Mex, oJustBuilt.UnitId) then
                        --Consider gifting power and t3 mexes to a teammate if we have a paragon
                        local aiBrain = oJustBuilt:GetAIBrain()
                        if bDebugMessages == true then LOG(sFunctionRef..': Just built mex or pgen for brain '..aiBrain.Nickname..'; considering if we have paragon and (if so) will gift the unit, builtparagon='..tostring(aiBrain[M28Economy.refbBuiltParagon])..'; Brain type='..(aiBrain.BrainType or 'nil')..'; Brain gross mass='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; Gross E='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]) end
                        if aiBrain[M28Economy.refbBuiltParagon] and not(aiBrain.BrainType == 'Human') and aiBrain[M28Economy.refiGrossMassBaseIncome] >= math.min(1000, 900 * aiBrain[M28Economy.refiBrainResourceMultiplier]) and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >=  math.min(100000, 90000 * aiBrain[M28Economy.refiBrainResourceMultiplier]) then
                            local oParagonBrain = oJustBuilt:GetAIBrain()
                            if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 then
                                for iBrain, oBrain in  M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                    if not(oBrain == oParagonBrain) and not(oBrain.M28IsDefeated) and oBrain[M28Economy.refiGrossMassBaseIncome] < 1000 then
                                        ForkThread(M28Team.TransferUnitsToPlayer, { oJustBuilt }, oParagonBrain:GetArmyIndex(), false)
                                        break
                                    end
                                end
                            end
                            --Check if we own any paused non-mexes that we own, and unpause them
                            if M28Team.tTeamData[iTeam][M28Team.refiPausedUnitCount] > 0 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority]) == false then
                                for iPriority, tUnits in M28Team.tTeamData[iTeam][M28Team.subreftoPausedUnitsByPriority] do
                                    for iPaused, oPaused in tUnits do
                                        if M28UnitInfo.IsUnitValid(oPaused) and oPaused:GetAIBrain() == oParagonBrain then
                                            M28UnitInfo.PauseOrUnpauseEnergyUsage(oPaused, false, false, oParagonBrain.M28Team)
                                        end
                                    end
                                end
                            end
                        end
                        --Remaining categories where have a paragon on team:
                    elseif M28Team.tTeamData[iTeam][M28Team.refbBuiltParagon] and (M28Orders.bDontConsiderCombinedArmy or oJustBuilt.M28Active) then
                        --Gift 66% of T3 engineers and SACUs built to paragon owner and all t1-t2 mexes
                        if not(aiBrain[M28Economy.refbBuiltParagon]) then
                            if EntityCategoryContains(M28UnitInfo.refCategoryEngineer + categories.SUBCOMMANDER, oJustBuilt.UnitId) then
                                if math.random(1, 3) < 3 then
                                    local oParagonBrain = oJustBuilt:GetAIBrain()
                                    if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 then
                                        for iBrain, oBrain in  M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                            if not(oBrain == oParagonBrain) and not(oBrain.M28IsDefeated) and oBrain[M28Economy.refiGrossMassBaseIncome] < 1000 then
                                                ForkThread(M28Team.TransferUnitsToPlayer, { oJustBuilt }, oParagonBrain:GetArmyIndex(), false)
                                                break
                                            end
                                        end
                                    end
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryT1Mex + M28UnitInfo.refCategoryT2Mex, oJustBuilt.UnitId) then
                                local oParagonBrain = oJustBuilt:GetAIBrain()
                                if M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 then
                                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                        if not(oBrain == oParagonBrain) and not(oBrain.M28IsDefeated) and oBrain[M28Economy.refiGrossMassBaseIncome] < 1000 then
                                            ForkThread(M28Team.TransferUnitsToPlayer, { oJustBuilt }, oParagonBrain:GetArmyIndex(), false)
                                            break
                                        end
                                    end
                                end
                            end
                        else
                            --gift t3 mexes to non-paragon owner
                            if EntityCategoryContains(M28UnitInfo.refCategoryT3Mex, oJustBuilt.UnitId) then
                                local oLeastMassNonParagonBrain
                                local iLeastNetMass = 500
                                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                    if not(oBrain[M28Economy.refbBuiltParagon]) and oBrain[M28Economy.refiNetMassBaseIncome] < iLeastNetMass then
                                        iLeastNetMass = oBrain[M28Economy.refiNetMassBaseIncome]
                                        oLeastMassNonParagonBrain = oBrain
                                    end
                                end
                                if oLeastMassNonParagonBrain then
                                    ForkThread(M28Team.TransferUnitsToPlayer, { oJustBuilt }, oLeastMassNonParagonBrain:GetArmyIndex(), false)
                                end
                            elseif oJustBuilt:GetBlueprint().General.UpgradesTo then
                                ForkThread(M28Economy.UpgradeUnit, oJustBuilt, true)
                            end
                        end
                    end

                    --Mobile land units - give a micro move order so they dont block the factory
                    if EntityCategoryContains(M28UnitInfo.refCategoryMobileLand, oJustBuilt.UnitId) then
                        ForkThread(M28Micro.MoveAwayFromFactory, oJustBuilt, oEngineer)
                    end

                    --Unit cap - refresh if are within 25 of the cap since it isnt accurate if have current units
                    if bDebugMessages == true then LOG(sFunctionRef..': will call function to refresh unit cap if we are close, is oJustBuilt valid='..tostring(M28UnitInfo.IsUnitValid(oJustBuilt))..'; Close to unit cap='..tostring(aiBrain[M28Overseer.refbCloseToUnitCap] or false)..'; Expected remaining cap='..(aiBrain[M28Overseer.refiExpectedRemainingCap] or 'nil')) end
                    if M28UnitInfo.IsUnitValid(oJustBuilt) and aiBrain[M28Overseer.refbCloseToUnitCap] and aiBrain[M28Overseer.refiExpectedRemainingCap] <= 25 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will check unit cap, time='..GetGameTimeSeconds()) end
                        M28Overseer.CheckUnitCap(aiBrain)
                    end

                    --air fac restriction - review if campaign in case things have changed if are dealing with the player (dont do for campaign AI though as they sometimes have different settings)
                    if M28Overseer.bAirFactoriesCantBeBuilt and M28Map.bIsCampaignMap and not(aiBrain.CampaignAI) then
                        local tACUs = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
                        if M28Utilities.IsTableEmpty(tACUs) == false then
                            local sAirFac = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryAirFactory, tACUs[1])
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Just built '..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; Time='..GetGameTimeSeconds()..'; sAirFac='..(sAirFac or 'nil'))
                                if sAirFac then LOG(sFunctionRef..': Is sAirFac restricted='..tostring(M28UnitInfo.IsUnitRestricted(sAirFac, aiBrain:GetArmyIndex()))) end
                            end
                            if sAirFac and not(M28UnitInfo.IsUnitRestricted(sAirFac, aiBrain:GetArmyIndex())) then
                                M28Overseer.bAirFactoriesCantBeBuilt = false
                            end
                        end
                    end
                else
                    --Non-M28 only units

                    --If build an M28 unit then will record its plateau and LZ; so for non-M28 AI also want to do this so we have a backup for pathfinding if dont already have something
                    if M28Utilities.IsTableEmpty(oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) and not(EntityCategoryContains(categories.AIR, oJustBuilt.UnitId)) then
                        local iPlateau, iLandZone = M28Map.GetPathingOverridePlateauAndLandZone(oJustBuilt:GetPosition(), true, oJustBuilt)
                        if not(oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) then oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] = {} end
                        oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][oJustBuilt:GetAIBrain().M28Team] = {iPlateau, iLandZone}
                        if iPlateau and not(iLandZone) then
                            --May be on water
                            local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(oJustBuilt:GetPosition())
                            local iWaterZone = M28Map.tWaterZoneBySegment[iSegmentX][iSegmentZ]
                            if iWaterZone then
                                if not(oJustBuilt[M28UnitInfo.reftAssignedWaterZoneByTeam]) then oJustBuilt[M28UnitInfo.reftAssignedWaterZoneByTeam] = {} end
                                oJustBuilt[M28UnitInfo.reftAssignedWaterZoneByTeam][oJustBuilt:GetAIBrain().M28Team] = iWaterZone
                            end
                        end
                        --[[if (iPlateau or 0) > 0 then
                            if not(oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) then oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] = {} end
                            oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][oJustBuilt:GetAIBrain().M28Team] = {iPlateau, iLandZone}
                        end--]]
                    end
                    --Tracking of under construction experimentals
                    if oJustBuilt[M28UnitInfo.refbNonM28ExpConstruction] then
                        local iTeam = oJustBuilt:GetAIBrain().M28Team
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoNonM28ConstructingExpAndT3Navy]) == false then
                            for iRecordedUnit, oRecordedUnit in M28Team.tTeamData[iTeam][M28Team.reftoNonM28ConstructingExpAndT3Navy] do
                                if oRecordedUnit == oJustBuilt then
                                    table.remove(M28Team.tTeamData[iTeam][M28Team.reftoNonM28ConstructingExpAndT3Navy], iRecordedUnit)
                                    break
                                end
                            end
                        end
                        oJustBuilt[M28UnitInfo.refbNonM28ExpConstruction] = false
                    end

                end

            else
                --M28 unit has finished construction, but we have alreayd called the main onconstruction event - have any special logic here that we want to run where this isn't the first time onconstructed has been called?
                --(note - wall building logic - engineers get cleared when the first one completes construction, so will have wall building logic as part of that, so no need to go here)
            end

            --Logic to run every time whether have called onconstruction or not
            --Upgrade tracking (even if have run this already)
            if bDebugMessages == true then LOG(sFunctionRef..': Will refresh upgrade tracking for buildings that have just built a building (i.e. upgrading buildings, was unit just built a structure='..tostring(EntityCategoryContains(categories.STRUCTURE, (oJustBuilt.UnitId or oJustBuilt:GetBlueprint().BlueprintId)))) end
            if oEngineer.GetAIBrain and EntityCategoryContains(categories.STRUCTURE, oEngineer.UnitId) and EntityCategoryContains(categories.STRUCTURE, (oJustBuilt.UnitId or oJustBuilt:GetBlueprint().BlueprintId)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Was just built owned by M28AI='..tostring(oJustBuilt:GetAIBrain().M28AI or false)) end
                if oJustBuilt:GetAIBrain().M28AI or (M28UnitInfo.IsUnitValid(oEngineer) and oEngineer:GetAIBrain().M28AI) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will update upgrade tracking of the unit that has just been built, oJustBuilt='..(oJustBuilt.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oJustBuilt) or 'nil')..'; oEngineer='..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil')) end
                    M28Team.UpdateUpgradeTrackingOfUnit(oEngineer, true)
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        end
    end
end

function OnReclaimStarted(oEngineer, oReclaim)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnReclaimStarted'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if oEngineer[M28Orders.refiMoveAndBuildStuckCount] then oEngineer[M28Orders.refiMoveAndBuildStuckCount] = 0 end
        if M28UnitInfo.IsUnitValid(oReclaim) and oReclaim:GetFractionComplete() == 1 and oReclaim:GetAIBrain().M28AI and not(oEngineer:GetAIBrain().M28AI) and IsAlly(oReclaim:GetAIBrain():GetArmyIndex(), oEngineer:GetAIBrain():GetArmyIndex()) then
            if M28Orders.bDontConsiderCombinedArmy or oReclaim.M28Active then
                M28Chat.SendUnitReclaimedMessage(oEngineer, oReclaim)
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnReclaimFinished(oEngineer, oReclaim)
    if M28Utilities.bM28AIInGame then
        --Update the segment that the reclaim is at, or the engineer if hte reclaim doesnt have one
        local sFunctionRef = 'OnReclaimFinished'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just finished reclaiming, gametime='..GetGameTimeSeconds()) end
        if oReclaim and oReclaim.CachePosition then
            --LOG('OnReclaimFinished temp log - remove once confirmed this works - about to update reclaim data near location='..repru(oReclaim.CachePosition))
            ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, oReclaim.CachePosition, 0)
        else
            --LOG('OnReclaimFinished alt temp log - couldnt find reclaim position so will use engineer position')
            ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, oEngineer:GetPosition(), 1)
        end

        --M28 specific
        if M28UnitInfo.IsUnitValid(oEngineer) and oEngineer:GetAIBrain().M28AI then
            --Was the engineer reclaiming an area? if so check if still nearby reclaim
            if bDebugMessages == true then LOG(sFunctionRef..': oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; oEngineer[M28Engineer.refiAssignedAction]='..(oEngineer[M28Engineer.refiAssignedAction] or 'nil')..'; Is table of units reclaiming the now reclaimed wreck empty='..tostring(M28Utilities.IsTableEmpty(oReclaim[M28Engineer.reftUnitsReclaimingUs]))..'; Eng seq count='..(oEngineer[M28Engineer.refiSequentialReclaimCount] or 0)) end
            oEngineer[M28Engineer.refiSequentialReclaimCount] = (oEngineer[M28Engineer.refiSequentialReclaimCount] or 0) + 1
            if oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionReclaimArea then
                --Only keep reclaiming if we dont have lots of mass, unless doing low value amounts and been a while since we got new orders
                if M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subrefiTeamAverageMassPercentStored] <= 0.7 and (oEngineer[M28Engineer.refiSequentialReclaimCount] or 0) <= 20 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Engineer sequential reclaim count='..(oEngineer[M28Engineer.refiSequentialReclaimCount] or 'nil')) end

                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
                    if (iLandZone or 0) > 0 then
                        local iTeam =  oEngineer:GetAIBrain().M28Team
                        local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                        local iMinReclaimValue = M28Map.iSignificantMassThreshold
                        --Do we have unclaimed mexes in this zone?
                        if tLZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] then iMinReclaimValue = iMinReclaimValue * 2 end
                        local bWantEnergy = M28Conditions.WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone)
                        if bWantEnergy and EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) and (M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subrefiTeamAverageEnergyPercentStored] >= 0.5 or oEngineer:GetAIBrain():GetEconomyStored('ENERGY') >= 2000 or oEngineer:GetAIBrain()[M28Economy.refiGrossEnergyBaseIncome] >= 50) then
                            iMinReclaimValue = 150 --only want a tree group
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Just finished reclaiming, will check for high value reclaim near engi, P'..iPlateau..'Z'..iLandZone..'; iMinReclaimValue='..iMinReclaimValue..'; Dist from engi to LZ midpoint='..M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMidpoint])..'; Engi pos='..repru(oEngineer:GetPosition())..'; LZ midpoint='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMidpoint])) end
                        --GetEngineerToReclaimNearbyArea(oEngineer, iPriorityOverride, tLZOrWZTeamData, iPlateauOrPond, iLandOrWaterZone, bWantEnergyNotMass,                   bOnlyConsiderReclaimInRangeOfEngineer, iMinIndividualValueOverride, bIsWaterZone)
                        M28Engineer.GetEngineerToReclaimNearbyArea(oEngineer, nil,              tLZTeamData,        iPlateau,   iLandZone, M28Conditions.WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone), true, iMinReclaimValue)--(tLZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] or GetGameTimeSeconds() <= 300 or GetUnitLifetimeCount(oEngineer) <= 5 or M28UnitInfo.GetUnitTechLevel(oEngineer) >= 3), iMinReclaimValue)
                    end
                end
            elseif EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then
                --Only try getting more reclaim if we havent wanted to run recently and we arent trying to move somewhere else
                if GetGameTimeSeconds() - (oEngineer[M28ACU.refiTimeLastWantedToRun] or 0) >= 2 or (M28UnitInfo.GetUnitHealthAndShieldPercent(oEngineer) >= 0.99 and M28Utilities.IsTableEmpty(M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.reftEnemyLandExperimentals]) and M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.refiEnemyT3ArtiCount] <= 1) then
                    M28Orders.UpdateRecordedOrders(oEngineer)
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to give a new reclaim order to oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Last order type='..(oEngineer[M28Orders.reftiLastOrders][1][M28Orders.subrefiOrderType] or 'nil')) end
                    if not(oEngineer[M28Orders.reftiLastOrders][1]) or oEngineer[M28Orders.reftiLastOrders][1][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueReclaim then
                        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
                        if (iLandZone or 0) > 0 then
                            local iTeam =  oEngineer:GetAIBrain().M28Team
                            local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                            local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                            if bDebugMessages == true then LOG(sFunctionRef..': Will consider giving a reclaim order to the ACU') end
                            M28ACU.ConsiderNearbyReclaimForACUOrEngineer(iPlateau, iLandZone, tLZData, tLZTeamData, oEngineer, true)
                        end
                    end
                end
            elseif M28Utilities.IsTableEmpty(oReclaim[M28Engineer.reftUnitsReclaimingUs]) == false then
                local tEngineersToClear = {}
                for iEngineer, oEngineer in oReclaim[M28Engineer.reftUnitsReclaimingUs] do
                    if M28UnitInfo.IsUnitValid(oEngineer) then
                        table.insert(tEngineersToClear, oEngineer)
                    end
                end
                for iEngineer, oEngineer in tEngineersToClear do
                    M28Orders.IssueTrackedClearCommands(oEngineer)
                end
            end
        end

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnCreateWreck(tPosition, iMass, iEnergy, oOptionalWreck)
    --Dont check if M28brains are in game yet as can be called at start of game before we have recorded any aiBrain
    if M28Utilities.bM28AIInGame then
        if oOptionalWreck then iMass = (oOptionalWreck.MaxMassReclaim or iMass) end --issue where iMass shows as being 1 when this is called in some cases
        if not(M28Map.bReclaimManagerActive) then
            if GetGameTimeSeconds() >= 20 then return nil
            else
                local iWaitCount = 0
                while not(M28Map.bReclaimManagerActive) do
                    WaitTicks(1)
                    iWaitCount = iWaitCount + 1
                    if iWaitCount >= 50 and (iWaitCount >= 60 or M28Utilities.bFAFActive) then M28Utilities.ErrorHandler('Map setup not complete') break end
                end
            end
        end
        --High value wrecks (experimentals) - activate special engi logic
        --LOG('TEMPCODE wreck created, iMass='..(iMass or 'nil')..'; oOptionalWreck.MaxMassReclaim='..(oOptionalWreck.MaxMassReclaim or 'nil'))
        if iMass >= 8000 and oOptionalWreck then
            for iCurTeam = 1, M28Team.iTotalTeamCount do
                if M28Team.tTeamData[iCurTeam][M28Team.subrefiActiveM28BrainCount] > 0 then
                    --LOG('TEMPCODE Starting high value reclaim order for team '..iCurTeam)
                    ForkThread(M28Engineer.HighValueReclaimOrder, iCurTeam, oOptionalWreck, tPosition)
                end
            end
        end
        --[[if iMass >= 35 then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tPosition)
            local iReclaimSegmentX, iReclaimSegmentZ = M28Map.GetReclaimSegmentsFromLocation(tPosition)
            LOG('OnCreateWreck: Time='..GetGameTimeSeconds()..'; iMass='..iMass..'; tPosition='..repru(tPosition)..'; will record we want to update reclaim at this location, iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iReclaimSegmentX='..iReclaimSegmentX..'; iReclaimSegmentZ='..iReclaimSegmentZ)
        end--]]
        ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, tPosition, 0)
    end
end

function OnTransportLoad(oUnit, oTransport, bone)
    if M28Utilities.bM28AIInGame then
        local aiBrain = oTransport:GetAIBrain()
        if aiBrain.M28AI then
            --Reduce engis wanted (in case of delay between this being updated and engineer logic running)
            if EntityCategoryContains(M28UnitInfo.refCategoryTransport, oTransport.UnitId) then
                if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                    if oTransport[M28Air.refiEngisWanted] then
                        oTransport[M28Air.refiEngisWanted] = math.max(0, oTransport[M28Air.refiEngisWanted] - 1)
                    end
                else
                    oTransport[M28Air.refiCombatUnitsWanted] = math.max(0, (oTransport[M28Air.refiCombatUnitsWanted] or 0) - 1)
                end
                --Clear the last assigned unit
                oTransport[M28Air.refoTransportUnitTryingToLoad] = nil
                --Clear any LZTeamData tracking
                if oUnit[M28Air.reftCombatDropPlateauAndZone] then
                    local tLZData = M28Map.tAllPlateaus[oUnit[M28Air.reftCombatDropPlateauAndZone][1]][M28Map.subrefPlateauLandZones][oUnit[M28Air.reftCombatDropPlateauAndZone][2]]
                    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoCombatUnitsLoadingOntoTransport]) == false then
                        for iEntry, oEntry in tLZTeamData[M28Map.reftoCombatUnitsLoadingOntoTransport] do
                            if oEntry == oUnit then
                                table.remove(tLZTeamData[M28Map.reftoCombatUnitsLoadingOntoTransport], iEntry)
                                break
                            end
                        end
                    end
                    oUnit[M28Air.reftCombatDropPlateauAndZone] = nil
                    oUnit[M28Engineer.refiAssignedAction] = nil
                end
            end

        end
    end
end

function OnTransportUnload(oUnit, oTransport, bone)
    if M28Utilities.bM28AIInGame then
        if M28UnitInfo.IsUnitValid(oTransport) and oTransport:GetAIBrain().M28AI then
            oTransport[M28Air.refiTransportTimeSpentWaiting] = 0
            oTransport[M28Air.refbEmergencyDropActive] = nil
            if oTransport[M28Air.refiTargetIslandForDrop] then
                oUnit[M28Air.refiLastIslandDrop] = oTransport[M28Air.refiTargetIslandForDrop]
                oUnit[M28Air.refiTimeLastDropped] = GetGameTimeSeconds()
                if M28UnitInfo.IsUnitValid(oUnit) and EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                    local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, oUnit:GetAIBrain().M28Team)
                    if tLZOrWZTeamData then tLZOrWZTeamData[M28Map.refiTimeLastDroppedEngi] = GetGameTimeSeconds() end
                end
            end
        end
        if M28UnitInfo.IsUnitValid(oUnit) and oUnit[M28Engineer.refiAssignedAction] == M28Engineer.refActionLoadOntoTransport then oUnit[M28Engineer.refiAssignedAction] = nil end
    end
end

function OnDetectedBy(oUnitDetected, iBrainIndex)
    --Appears to be called when iBrainIndex detects oUnitDetected, triggers for teammate units but not own units?
    --For now used to make sure we have up to date unit info

    if M28Utilities.bM28AIInGame then
        if not(EntityCategoryContains(categories.INSIGNIFICANTUNIT, oUnitDetected.UnitId)) then --redundancy, doesnt look like ubnits like cybran build drones cause this to happen
            local aiBrain = ArmyBrains[iBrainIndex]
            M28Team.ConsiderAssigningUnitToZoneForBrain(aiBrain, oUnitDetected) --This function includes check of whether this is an M28 brain, and updates last known position

            if aiBrain.M28AI then
                if aiBrain.M28Team and not(oUnitDetected[M28UnitInfo.refbHaveSeenUnitByTeam][aiBrain.M28Team]) then
                    if not(oUnitDetected[M28UnitInfo.refbHaveSeenUnitByTeam]) then oUnitDetected[M28UnitInfo.refbHaveSeenUnitByTeam] = {} end
                    oUnitDetected[M28UnitInfo.refbHaveSeenUnitByTeam][aiBrain.M28Team] = true
                    if oUnitDetected[M28Air.refiTimeLastWantedPriorityAirScout] and EntityCategoryContains(M28UnitInfo.refCategoryTMD, oUnitDetected.UnitId) then
                        oUnitDetected[M28Air.refiTimeLastWantedPriorityAirScout] = nil --not ideal for multi-team game but hopefully in most cases will be ok and is for niche scenairo anyway - i.e. if MMLs come across TMD with no intel they flag as a priority scout target; then when the unit is detected it gets cleared
                    end
                end
                --Update highest enemy ground unti health
                if M28Map.bFirstM28TeamHasBeenInitialised and M28UnitInfo.IsUnitValid(oUnitDetected) and EntityCategoryContains(M28UnitInfo.refCategoryLandCombat - categories.COMMAND - categories.SUBCOMMANDER - M28UnitInfo.refCategoryLandScout, oUnitDetected.UnitId) then
                    local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnitDetected)
                    local iMaxHealth = oUnitDetected:GetMaxHealth() + iMaxShield
                    if iMaxHealth > (M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyHighestMobileLandHealth] or 0) and M28Map.bWaterZoneInitialCreation then
                        M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyHighestMobileLandHealth] = iMaxHealth
                    end
                end
            end
        end
    end
end

function OnCreate(oUnit, bIgnoreMapSetup)
    --LOG('OnCreate pre M28InGamecheck, M28Utilities.bM28AIInGame='..tostring(M28Utilities.bM28AIInGame))
    if M28Utilities.bM28AIInGame then
        if not(oUnit.UnitId) then --LOUD compatibility
            if not(M28Utilities.bFAFActive) then
                if not(oUnit.EntityId) then oUnit.EntityId = oUnit:GetEntityId() end
                oUnit.UnitId = oUnit:GetBlueprint().BlueprintId
            end
        end

        if M28UnitInfo.IsUnitValid(oUnit) and not(EntityCategoryContains(categories.INSIGNIFICANTUNIT, oUnit.UnitId)) then --redundancy, doesnt look like units like cybran build drones cause this to happen

            local sFunctionRef = 'OnCreate'
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

            if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time'..GetGameTimeSeconds()..'; oUnit[M28OnCrRn]='..tostring(oUnit['M28OnCrRn'] or false)..'; M28Map.bWaterZoneInitialCreation='..tostring(M28Map.bWaterZoneInitialCreation or false)..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; M28Map.bWaterZoneInitialCreation='..tostring(M28Map.bWaterZoneInitialCreation)..'; Unit brain='..oUnit:GetAIBrain().Nickname..'; Is civliain brain='..tostring(M28Conditions.IsCivilianBrain(oUnit:GetAIBrain()))..'; Unit fraction complete='..oUnit:GetFractionComplete()..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; UnitID='..(oUnit.UnitId or 'nil')..'; Parent='..(oUnit.Parent.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit.Parent) or 'nil')) end
            if (not(M28Map.bMapLandSetupComplete) or not(M28Map.bWaterZoneInitialCreation)) and not(bIgnoreMapSetup) then --Start of game ACU creation happens before we have setup the map
                while not(M28Map.bMapLandSetupComplete) or not(M28Map.bWaterZoneInitialCreation) do
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(1)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    if GetGameTimeSeconds() >= 5 and M28Map.bMapLandSetupComplete and (GetGameTimeSeconds() >= 6 or M28Utilities.bFAFActive) then
                        M28Utilities.ErrorHandler('Water zone initial creation still not done, will stop waiting now')
                        break
                    end
                end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if M28UnitInfo.IsUnitValid(oUnit) then OnCreate(oUnit, true) end
            else
                if not(oUnit['M28OnCrRn']) then
                    oUnit['M28OnCrRn'] = true
                    oUnit[M28UnitInfo.refiTimeCreated] = math.floor(GetGameTimeSeconds())
                    M28Overseer.refiRoughTotalUnitsInGame = M28Overseer.refiRoughTotalUnitsInGame + 1
                    M28UnitInfo.GetUnitLifetimeCount(oUnit) --essential so lifetimecount logic works

                    --All units (not just M28 specific):
                    M28UnitInfo.RecordUnitRange(oUnit)

                    M28Team.ConsiderAssigningUnitToZoneForBrain(oUnit:GetAIBrain(), oUnit) --This function includes check of whether this is an M28 brain
                    if M28Map.bIsCampaignMap then
                        local tiTeamsConsidered = {[(oUnit:GetAIBrain().M28Team or 0)] = true}
                        for iBrain, oBrain in ArmyBrains do
                            if oBrain.M28AI and not(tiTeamsConsidered[oBrain.M28Team]) then
                                tiTeamsConsidered[oBrain.M28Team] = true
                                M28Team.ConsiderAssigningUnitToZoneForBrain(oBrain, oUnit)
                            end
                        end
                    end

                    if bDebugMessages == true then LOG(sFunctionRef..': First time M28OnCreate has run, just recorded unit ranges for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Unit fraction complete='..oUnit:GetFractionComplete()) end
                    if M28Config.M28ShowEnemyUnitNames then
                        local sWZOrLZRef = ''
                        if EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                            local iWaterZone
                            if (iLandZone or 0) == 0 then
                                iWaterZone = M28Map.GetWaterZoneFromPosition(oUnit:GetPosition())
                                if (iWaterZone or 0) > 0 then
                                    sWZOrLZRef = 'P0WZ'..iWaterZone
                                end
                            else
                                sWZOrLZRef = 'P'..(iPlateau or 'x')..'LZ'..iLandZone
                            end
                        end
                        if M28Config.M28ShowUnitNames then oUnit:SetCustomName(oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..sWZOrLZRef) end
                    end

                    --Units with upgrade - update the base threat value
                    if EntityCategoryContains(categories.SUBCOMMANDER, oUnit.UnitId) or (oUnit.HasEnhancement and EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and (oUnit:HasEnhancement('ResourceAllocation') or oUnit:HasEnhancement('ResourceAllocationAdvanced'))) then
                        M28UnitInfo.UpdateUnitCombatMassRatingForUpgrades(oUnit) --Will check if unit has enhancements as part of this
                        if oUnit:GetAIBrain().CheatEnabled then ForkThread(M28UnitInfo.FixUnitResourceCheatModifiers, oUnit) end
                    elseif oUnit:GetAIBrain().CheatEnabled and (M28Utilities.bLoudModActive or M28Utilities.bQuietModActive or (not(tonumber(ScenarioInfo.Options.M28OvwR or tostring(0)) == 0) and ScenarioInfo.Options.M28OvwT)) then
                        ForkThread(M28UnitInfo.FixUnitResourceCheatModifiers, oUnit)
                    end

                    --Hydro resource locations
                    if EntityCategoryContains(M28UnitInfo.refCategoryHydro, oUnit.UnitId) then
                        --Treat location as no longer having no buildings on it
                        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations]) == false then
                            --LOG('About to loop through hydro locations; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; reprs='..reprs(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations]))
                            for iHydroLocation, tHydroLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations] do
                                if M28Utilities.GetDistanceBetweenPositions(tHydroLocation, oUnit:GetPosition()) <= 2 then
                                    table.remove(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations], iHydroLocation)
                                    break
                                end
                            end
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                        --Treat location as having buildings on it (if we were treating it as unbuilt previously)
                        ForkThread(M28Building.OnMexConstructionStarted, oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                        M28Building.RecordUnitsInRangeOfTMLAndAnyTMDProtection(oUnit, nil, true)
                        if oUnit:GetAIBrain().M28AI then
                            local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, oUnit:GetAIBrain().M28Team)
                            if tLZTeamData then
                                tLZTeamData[M28Map.subrefiTMLLifetimeBuildCount] = (tLZTeamData[M28Map.subrefiTMLLifetimeBuildCount] or 0) + 1
                            end
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryTMD, oUnit.UnitId) then
                        if bDebugMessages == true then LOG(sFunctionRef..': will call TMDJustBuilt for tmd '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..', time='..GetGameTimeSeconds()) end
                        M28Building.TMDJustBuilt(oUnit)
                    end
                    if EntityCategoryContains(M28UnitInfo.refCategoryProtectFromTML, oUnit.UnitId) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will call RecordTMLAndTMDForUnitJustBuilt, time='..GetGameTimeSeconds()) end
                        M28Building.RecordTMLAndTMDForUnitJustBuilt(oUnit)
                    end

                    --M28 team specific for constructed units - e.g. radar and sonar that are constructed
                    if (M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.subrefiActiveM28BrainCount] or 0) > 0 and oUnit:GetFractionComplete() == 1 then
                        local iTeam = oUnit:GetAIBrain().M28Team
                        if EntityCategoryContains(M28UnitInfo.refCategoryRadar, oUnit.UnitId) then
                            M28Land.UpdateZoneIntelForRadar(oUnit)
                            if EntityCategoryContains(categories.TECH2, oUnit.UnitId) then
                                ForkThread(M28Building.ConsiderUpgradingT2Radar, oUnit)
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySonar, oUnit.UnitId) then
                            M28Navy.UpdateZoneIntelForSonar(oUnit)
                        elseif EntityCategoryContains(categories.EXPERIMENTAL * categories.MASSFABRICATION, oUnit.UnitId) then
                            if M28Utilities.bLoudModActive or M28Utilities.bQuietModActive then
                                ForkThread(M28Building.RecordExperimentalResourceGen, oUnit)
                            end
                        end
                    end

                    --Constructed units (general, i.e. all AI not just M28)
                    if oUnit:GetFractionComplete() == 1 then
                        M28Building.RecordUnitShieldCoverage(oUnit)
                        if EntityCategoryContains(M28UnitInfo.refCategorySMD, oUnit.UnitId) then
                            --Cover off scenario where loaded SMD is xferred between players, since M28 will think an SMD has died and a new one created, i.e. want to avoid abuse of M28s logic by making it think they have no SMD coverage (when it knows htey do)
                            if oUnit.GetTacticalSiloAmmoCount and oUnit:GetTacticalSiloAmmoCount() > 1 or oUnit:GetWorkProgress() >= 0.8 then
                                oUnit[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds() - 240 - M28Building.iTimeForSMDToBeConstructed
                            end
                            --Wall segments created at start of game in large numbers - i.e. for scenario where large parts of map are walled off
                        elseif GetGameTimeSeconds() <= 10 and EntityCategoryContains(M28UnitInfo.refCategoryWall, oUnit.UnitId) and M28UnitInfo.GetUnitLifetimeCount(oUnit) >= 8 then
                            M28Land.TrackWallSegment(oUnit, true)
                        end
                        --Below in case capturedunits function doesnt trigger for a unit transferred toa nother player - so we can track upgrade count (mainly intended to track upgrades on SACUs, for which shield SACUs is the main logic dependent on it)
                        local iUpgradeableUnitsCategory = categories.COMMAND + categories.SUBCOMMANDER
                        if M28Utilities.bQuietModActive or M28Utilities.bLoudModActive then iUpgradeableUnitsCategory = iUpgradeableUnitsCategory + M28UnitInfo.refCategoryFactory * categories.TECH3 end --LOUD and quiet allow factories to upgrade
                        if EntityCategoryContains(iUpgradeableUnitsCategory, oUnit.UnitId) then M28ACU.UpdateUnitUpgradeCountTrackingIfNotSet(oUnit) end
                        if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                            M28Building.OnMexConstructionCompleted(oUnit)
                        end
                    end




                    --M28 specific:
                    if oUnit:GetAIBrain().M28AI then
                        --Set Easy flag
                        if oUnit:GetAIBrain().M28Easy then oUnit[M28UnitInfo.refbEasyBrain] = true end
                        --M28Active flag (enable for all M28AI units)
                        if bDebugMessages == true then LOG('Considering if we want to set M28Active flag, tonumber(ScenarioInfo.Options.M28CombinedArmy or 2)='..tonumber(ScenarioInfo.Options.M28CombinedArmy or 2)..'; Is unit an ACU='..tostring(EntityCategoryContains(categories.COMMAND, oUnit.UnitId))..'; Is brain human='..tostring(oUnit:GetAIBrain().BrainType == 'Human')..'; M28Orders.bDontConsiderCombinedArmy='..tostring(M28Orders.bDontConsiderCombinedArmy or false)) end
                        if not(M28Orders.bDontConsiderCombinedArmy) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Toggling M28CombinedArmiesShowUI option via consideringcombinedarmy') end
                            oUnit:UpdateStat('M28CombinedArmiesShowUI', 1)
                            if not(oUnit:GetAIBrain().BrainType == 'Human') then
                                if bDebugMessages == true then LOG(sFunctionRef..': Set .M28Active to true for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by brain '..oUnit:GetAIBrain().Nickname) end
                                oUnit.M28Active = true
                                oUnit:UpdateStat('M28Active', 1)
                            elseif tonumber(ScenarioInfo.Options.M28CombinedArmy or 2) == 3 then
                                --MOBA mode
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if are in MOBA mode or not, and (if in MOBA) then will enable M28AI logic for all non-ACU units') end
                                if not(EntityCategoryContains(categories.COMMAND, oUnit.UnitId)) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Enabled M28AI logic for the unit') end
                                    oUnit.M28Active = true
                                    oUnit:UpdateStat('M28Active', 1)
                                end
                            elseif oUnit:GetFractionComplete() == 1 and oUnit.Parent and oUnit.Parent.M28Active and not(oUnit.M28Active) and oUnit:GetAIBrain().BrainType == 'Human' and tonumber(ScenarioInfo.Options.M28CAInherit or 2) == 1 and not(EntityCategoryContains(categories.COMMAND, oUnit.UnitId)) then --e.g. novax will create a 100% complete unit
                                oUnit.M28Active = true
                                oUnit:UpdateStat('M28Active', 1)
                            else
                                oUnit:UpdateStat('M28Active', 0)
                            end
                        elseif not(ScenarioInfo.Options.M28CombinedArmy == 4) then --if is option 4, then user wants the UI button hidden
                            if bDebugMessages == true then LOG(sFunctionRef..': Toggling M28CombinedArmiesShowUI option') end
                            oUnit:UpdateStat('M28CombinedArmiesShowUI', 1)
                        end

                        --Check for upgrading unit transferred to us
                        if oUnit.IsUpgrade then
                            local aiBrain = oUnit:GetAIBrain()
                            if bDebugMessages == true then LOG(sFunctionRef..': Upgrading hidden unit detected, Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; aiBrain='..aiBrain.Nickname..'; Is table of mexes and factories empty='..tostring(M28Utilities.IsTableEmpty(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount]))) end
                            if M28Utilities.IsTableEmpty(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount]) == false then
                                local iClosestUnitRef
                                local iClosestUnitTransferCount
                                local iClosestDist = 2
                                local iCurDist


                                for iTransferCount, tUnitTable in aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount] do
                                    iClosestUnitRef = nil
                                    if M28Utilities.IsTableEmpty(tUnitTable) == false then
                                        for iCompletedUnit, oCompletedUnit in tUnitTable do
                                            if M28UnitInfo.IsUnitValid(oCompletedUnit) then
                                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oCompletedUnit:GetPosition(), oUnit:GetPosition())
                                                if iCurDist < iClosestDist then
                                                    iClosestDist = iCurDist
                                                    iClosestUnitRef = iCompletedUnit
                                                    iClosestUnitTransferCount = iTransferCount
                                                end
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished searching completed units near to unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..', iClosestUnitRef='..(iClosestUnitRef or 'nil')..'; iClosestDist='..iClosestDist) end
                                    if iClosestUnitRef then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will track completed unit '..aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iClosestUnitTransferCount][iClosestUnitRef].UnitId..M28UnitInfo.GetUnitLifetimeCount(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iClosestUnitTransferCount][iClosestUnitRef])..' as an upgrading unit, given unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is upgrading and nearby') end
                                        M28Team.UpdateUpgradeTrackingOfUnit(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iClosestUnitTransferCount][iClosestUnitRef], false, oUnit.UnitId)
                                        table.remove(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iClosestUnitTransferCount], iClosestUnitRef)
                                    end
                                end
                            end
                        end

                        --Penetration fighters - disable airaa micro
                        if oUnit.UnitId == 'uea0303' or oUnit.UnitId == 'ura0303' or oUnit.UnitId == 'uaa0303' or oUnit.UnitId == 'xsa0303' then
                            oUnit[M28Air.refbDisableAirAAAttackMicro] = true
                        end

                        --Cover units transferred to us or cheated in or presumably that we have captured - will leave outside the OnCreate flag above in case the oncreate variable transfers over when a unit is captured/gifted
                        --First handle units that are important enough we have logic for while they are part-constructed
                        if oUnit:GetFractionComplete() >= 0.1 and not(oUnit[M28UnitInfo.refbConstructionStart]) and EntityCategoryContains(M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryNovaxCentre + M28UnitInfo.refCategoryFixedShield, oUnit.UnitId) then
                            --Gameender/t3 arti and fixed shields and SMD - consider shielding/game ender template usage
                            if not(oUnit[M28UnitInfo.refbConstructionStart]) and EntityCategoryContains(M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryNovaxCentre + M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategoryGroundAA * categories.TECH3 + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryPD - categories.FACTORY - categories.EXTERNALFACTORYUNIT - categories.TECH1, oUnit.UnitId) then
                                --Work out if we are already in a special game ender template area
                                if not(oUnit[M28Building.reftArtiTemplateRefs]) then
                                    local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, oUnit:GetAIBrain().M28Team)
                                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates]) == false then
                                        local bLikelyInTemplatePosition = false
                                        local bArti = EntityCategoryContains(M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryNovaxCentre, oUnit.UnitId)
                                        for iTemplate, tSubtable in tLZTeamData[M28Map.reftActiveGameEnderTemplates] do
                                            if bArti then
                                                if M28Utilities.IsTableEmpty(tSubtable[M28Map.subrefGEArtiLocations]) == false then
                                                    for iArtiLoc, tArtiLoc in tSubtable[M28Map.subrefGEArtiLocations] do
                                                        if M28Utilities.GetDistanceBetweenPositions(tArtiLoc, oUnit:GetPosition()) < 2.5 then
                                                            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                                                            oUnit[M28Building.reftArtiTemplateRefs] = {iPlateau, iLandZone, iTemplate}
                                                            --Check not already in the table
                                                            local bAlreadyRecorded = false
                                                            if M28Utilities.IsTableEmpty(tSubtable[M28Map.subrefGEArtiUnits]) == false then
                                                                for iRecordedArti, oRecordedArti in tSubtable[M28Map.subrefGEArtiUnits] do
                                                                    if oRecordedArti == oUnit then
                                                                        bAlreadyRecorded = true
                                                                        break
                                                                    end
                                                                end
                                                            end
                                                            if not(bAlreadyRecorded) then
                                                                table.insert(tSubtable[M28Map.subrefGEArtiUnits], oUnit)
                                                            end
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Added arti unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to template ref='..iTemplate..'; in iLandZone='..iLandZone..'; bAlreadyRecorded='..tostring(bAlreadyRecorded)) end
                                                        end
                                                    end
                                                end
                                            elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oUnit.UnitId) then --dealing with fixed shield
                                                if M28Utilities.IsTableEmpty(tSubtable[M28Map.subrefGEShieldLocations]) == false then
                                                    for iShieldLoc, tShieldLoc in tSubtable[M28Map.subrefGEShieldLocations] do
                                                        if M28Utilities.GetDistanceBetweenPositions(tShieldLoc, oUnit:GetPosition()) < 1 then
                                                            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                                                            oUnit[M28Building.reftArtiTemplateRefs] = {iPlateau, iLandZone, iTemplate}
                                                            --Check not already in the table (redundancy)
                                                            local bAlreadyRecorded = false
                                                            if M28Utilities.IsTableEmpty(tSubtable[M28Map.subrefGEShieldUnits]) == false then
                                                                for iRecordedShield, oRecordedShield in tSubtable[M28Map.subrefGEShieldUnits] do
                                                                    if oRecordedShield == oUnit then
                                                                        bAlreadyRecorded = true
                                                                        break
                                                                    end
                                                                end
                                                            end
                                                            if not(bAlreadyRecorded) then
                                                                table.insert(tSubtable[M28Map.subrefGEShieldUnits], oUnit)
                                                            else
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Wont add shield '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' against GE template as it was already recorded') end
                                                            end
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Added shiled unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to template ref='..iTemplate..'; in iLandZone='..iLandZone..' unless already recorded, bAlreadyRecorded='..tostring(bAlreadyRecorded)) end
                                                        end
                                                    end
                                                end
                                            elseif EntityCategoryContains(M28UnitInfo.refCategorySMD, oUnit.UnitId) then
                                                if M28Utilities.IsTableEmpty(tSubtable[M28Map.subrefGESMDLocation]) == false and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(),tSubtable[M28Map.subrefGESMDLocation]) < 1 then
                                                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                                                    oUnit[M28Building.reftArtiTemplateRefs] = {iPlateau, iLandZone, iTemplate}
                                                    tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplate][M28Map.subrefGESMDUnit] = oUnit
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Recorded SMD as being in arti template location, SMD Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTemplate='..iTemplate..'; Time='..GetGameTimeSeconds()) end
                                                end
                                            elseif EntityCategoryContains(M28UnitInfo.refCategoryGroundAA + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryPD, oUnit.UnitId) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': will add unit to table of defences for this reference') end
                                                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                                                oUnit[M28Building.reftArtiTemplateRefs] = {iPlateau, iLandZone, iTemplate}
                                                if not(tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplate][M28Map.subrefGEDefenceUnits]) then tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplate][M28Map.subrefGEDefenceUnits] = {} end
                                                table.insert(tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplate][M28Map.subrefGEDefenceUnits], oUnit)
                                            else M28Utilities.ErrorHandler('Unrecognised category when checking if constructed unit is in arti template area', true)
                                            end
                                        end
                                    end
                                    --Special shielding and air defence logic
                                    if not(oUnit[M28Building.reftArtiTemplateRefs]) and EntityCategoryContains(M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti, oUnit.UnitId) then
                                        M28Building.ReserveLocationsForGameEnder(oUnit)
                                        M28Air.AddPriorityAirDefenceTarget(oUnit)
                                    end
                                end
                            end
                        end

                        --Land scout special logic for M28AI units - consider making a combat land scout
                        if oUnit[M28UnitInfo.refiCombatRange] >= 26 and oUnit:GetAIBrain()[M28Overseer.refiCombatLandScoutThreshold] > 0 and EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit.UnitId) and M28UnitInfo.GetUnitLifetimeCount(oUnit) <= oUnit:GetAIBrain()[M28Overseer.refiCombatLandScoutThreshold]  then
                            local aiBrain = oUnit:GetAIBrain()
                            if aiBrain[M28Economy.refiOurHighestFactoryTechLevel] >= 2 or M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestEnemyGroundTech] >= 2 then
                                aiBrain[M28Overseer.refiCombatLandScoutThreshold] = 0
                            else
                                oUnit[M28UnitInfo.refbScoutCombatOverride] = true
                            end
                        end

                        if bDebugMessages == true then LOG(sFunctionRef..': Considering special logic for units created via cheat or transfer, fraction complete='..oUnit:GetFractionComplete()) end
                        if oUnit:GetFractionComplete() == 1 then
                            if EntityCategoryContains(M28UnitInfo.refCategorySML + M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                                --put here as extra redundancy since the 'unpause unit on transfer' code which has something similar didnt fix an issue with a loaded yolona being transferred not then firing
                                --LOG('Forked consideration of launching missile Delay5')
                                ForkThread(M28Building.DelayedConsiderLaunchingMissile, oUnit, 15, true)
                            end


                            M28Economy.UpdateHighestFactoryTechLevelForBuiltUnit(oUnit) --this includes a check to see if are dealing with a factory HQ
                            M28Economy.UpdateGrossIncomeForUnit(oUnit, false) --This both includes a check of the unit type, and cehcks we havent already recorded
                            if EntityCategoryContains(categories.STEALTH, oUnit.UnitId) or (oUnit:GetBlueprint().Intel.RadarStealth and oUnit:GetBlueprint().General.OrderOverrides.RULEUTC_StealthToggle) then
                                --Make sure stealth is enabled
                                M28UnitInfo.EnableUnitStealth(oUnit)
                            end
                            if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) and not(oUnit.M28OnConstructedCalled) then
                                if bDebugMessages == true then LOG(sFunctionRef..': we have just built a mex so will call logic relating to that') end
                                ForkThread(M28Economy.UpdateZoneM28MexByTechCount, oUnit) --we run the same logic via onconstructed
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryParagon, oUnit.UnitId) and not(oUnit.M28OnConstructedCalled) then
                                if bDebugMessages == true then LOG(sFunctionRef..': We have just built a paragon, will call special paragon logic') end
                                ForkThread(M28Building.JustBuiltParagon, oUnit)
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryMassStorage, oUnit.UnitId) and not(oUnit.M28OnConstructionCalled) then
                                M28Building.ConsiderGiftingMassStorageToNearbyMexOwner(oUnit)
                                --Campaign specific - expand core zones for campaign AI
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryLandHQ + M28UnitInfo.refCategoryAirHQ + categories.COMMAND, oUnit.UnitId) and M28Map.bIsCampaignMap and oUnit:GetAIBrain().CampaignAI then
                                local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, oUnit:GetAIBrain().M28Team)
                                tLZTeamData[M28Map.subrefbCoreBaseOverride] = true
                                if bDebugMessages == true then
                                    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                                    LOG(sFunctionRef..': Will set core baes override to true for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' for brain '..oUnit:GetAIBrain().Nickname..' team, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone)
                                end
                                if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and oUnit:GetAIBrain().CampaignAI and (not(M28UnitInfo.IsUnitValid(oUnit:GetAIBrain()[M28ACU.refoPrimaryACU])) or not(EntityCategoryContains(categories.COMMAND, oUnit:GetAIBrain()[M28ACU.refoPrimaryACU]))) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will run ACU thread for this unit') end
                                    ForkThread(M28ACU.ManageACU, oUnit:GetAIBrain(), oUnit)
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryBomber * categories.TECH3, oUnit.UnitId) then
                                if M28UnitInfo.GetUnitLifetimeCount(oUnit) == 1 and not(oUnit[M28Air.refbBomberUsingMexHunterLogic]) then
                                    ForkThread(M28Air.ApplyMexHuntingLogicToBomber, oUnit)
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryPower, oUnit.UnitId) then --In LOUD t2 pgen upgrades to t3 are as efficient as t3 pgens
                                local sUpgrade = oUnit:GetBlueprint().General.UpgradesTo
                                if sUpgrade and not(sUpgrade == '') then
                                    ForkThread(M28Economy.ConsiderPowerPgenUpgrade, oUnit)
                                end
                            end

                            --Nuke launcher - if have 5+ non-experimental then consider unpausing all existing ones
                            if EntityCategoryContains(M28UnitInfo.refCategorySML, oUnit.UnitId) then
                                ForkThread(M28Overseer.ConsiderUnpausingAllCreatedNukes, oUnit:GetAIBrain().M28Team)
                            end
                            --Consider unpausing this unit regardless of whether it's an SML
                            ForkThread(M28Overseer.DelayedUnpauseOfUnits, {oUnit}, 1)
                            if EntityCategoryContains(M28UnitInfo.refCategorySatellite, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..'Novax created, reprs='..reprs(oUnit)) end
                                ForkThread(M28Air.DetachSatellite,oUnit, 1)
                            end

                            --If we have paragon and unit can upgrade (e.g. we have just had units xfer to us from teammate) then start upgrade
                            if oUnit:GetAIBrain()[M28Economy.refbBuiltParagon] then
                                if oUnit:GetBlueprint().General.UpgradesTo then
                                    ForkThread(M28Economy.UpgradeUnit, oUnit, true)
                                end
                            end
                        end
                        --General logic that want to make sure runs on M28 units even if theyre not constructed yet or to ensure we cover scenarios where we are gifted units
                        local aiBrain = oUnit:GetAIBrain()
                        if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel - M28UnitInfo.refCategorySatellite, oUnit.UnitId) then
                            M28Air.AddPriorityAirDefenceTarget(oUnit)
                            if EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId) then
                                M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityFatboy, true)
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryMegalith, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Setting weapon priorities for megalith') end
                                M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityMegalith, true)
                            end
                            --Track priority units for mobile stealth (want to consider stealthing even if under construction, hence do at this stage)
                            if M28Map.iMapSize >= 500 and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental - categories.STEALTHFIELD - categories.url0402, oUnit.UnitId) then
                                --Want to build mobile stealth if we have cybran on the team
                                local iLandSubteam = oUnit:GetAIBrain().M28LandSubteam
                                if (M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionCybran][3] or 0) > 0 or (M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionCybran][2] or 0) > 0 then
                                    if not(M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingMobileStealth]) then M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingMobileStealth] = {} end
                                    table.insert(M28Team.tLandSubteamData[iLandSubteam][M28Team.reftoPriorityUnitsWantingMobileStealth], oUnit)
                                end
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                            --Check for rare case where enemy base is taken over by us but enemy isnt dead (doing here instead of onconstructed as onconstructed wouldnt trigger consistently)
                            local iMexPlateau, iMexZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                            local iTeam = oUnit:GetAIBrain().M28Team
                            local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                            --Redundancy for case where enemy nearest us loses their base
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have built on enemy base even if they arent dead, P'..iMexPlateau..'Z'..iMexZone..';mod dist%='..tLZTeamData[M28Map.refiModDistancePercent]..'; Enemy total mass='..(tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 'nil')..'; Dist from midpoint to closest enemy base='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase])..'; Number of enemy brains='..table.getn(M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains])..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Brain owner='..oUnit:GetAIBrain().Nickname..'; Enemy combat='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; Our combat='..(tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 'nil')) end
                            if tLZTeamData[M28Map.refiModDistancePercent] == 1 and GetGameTimeSeconds() >= 60 and not(M28Map.bIsCampaignMap) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains]) == false and table.getn(M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains]) >= 2 and M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase]) <= 5 then
                                if (tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) == 0 then
                                    --Enemy base is likely destroyed since they have no mass here
                                    if bDebugMessages == true then LOG(sFunctionRef..': No enemy buildings, so will update nearest enemy base') end
                                    ForkThread(M28Map.RecordClosestAllyAndEnemyBaseForEachLandZone, iTeam, true)
                                end
                                --Either way do a check, in case we didnt update to ignore the brain
                                if tLZTeamData[M28Map.subrefLZSValue] >= (tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) and (tLZTeamData[M28Map.subrefThreatEnemyStructureTotalMass] or 0) <= 1000 and tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= 500 and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] < math.min(200, tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] * 0.1) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy still has some buildings, so will do a delayed check if we want to update nearest base and iTicksPerLandCycle is relatively high, iTicksPerLandCycle='..M28Land.iTicksPerLandCycle) end
                                    ForkThread(M28Map.DelayedConsiderationOfWhetherToIgnoreEnemyBase, tLZData, tLZTeamData, iTeam, iMexPlateau, iMexZone, 30)
                                end
                            end

                            --WEAPON PRIORITIES
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryGunship, oUnit.UnitId) then
                            M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityGunship, true)
                            oUnit[M28UnitInfo.refbUsingDefaultWeaponPriority] = true
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryDestroyer, oUnit.UnitId) then
                            M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityDestroyer, true)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMissileShip + M28UnitInfo.refCategoryCruiser, oUnit.UnitId) then
                            M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityMissileShip, true)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryBattleship, oUnit.UnitId) then
                            M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityBattleShip, true)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) then
                            M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityT2Arti, true)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryQuantumOptics, oUnit.UnitId) then
                            local iTeam = aiBrain.M28Team
                            local bAlreadyRecorded = false
                            if not(M28Team.tTeamData[iTeam][M28Team.reftoAlliedQuantumOptics]) then M28Team.tTeamData[iTeam][M28Team.reftoAlliedQuantumOptics] = {}
                            else
                                for iRecorded, oRecorded in M28Team.tTeamData[iTeam][M28Team.reftoAlliedQuantumOptics] do
                                    if oRecorded == oUnit then
                                        bAlreadyRecorded = true
                                        break
                                    end
                                end
                            end
                            if not(bAlreadyRecorded) then
                                table.insert(M28Team.tTeamData[iTeam][M28Team.reftoAlliedQuantumOptics], oUnit)
                                ForkThread(M28Building.QuantumOpticsManager, aiBrain, oUnit)
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySubmarine, oUnit.UnitId) then
                            M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPrioritySub, false) --Dont want to check if can attack ground

                            --1st T3 Engineer - check building construction options
                        elseif M28UnitInfo.GetUnitLifetimeCount(oUnit) == 1 and EntityCategoryContains(M28UnitInfo.refCategoryEngineer * categories.TECH3, oUnit.UnitId) then
                            M28Building.AssessT3EngineerConstructionOptions(oUnit)
                        end


                            --Non-weapon priority logic
                            if bDebugMessages == true then LOG(sFunctionRef..': Is this an external factory='..tostring(EntityCategoryContains(categories.EXTERNALFACTORYUNIT, oUnit.UnitId))..'; Is this an aircraft factory='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryMobileAircraftFactory, oUnit.UnitId))..'; Is it a special factory='..tostring(EntityCategoryContains(M28UnitInfo.refCategorySpecialFactory, oUnit.UnitId))) end
                        if EntityCategoryContains(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryQuantumGateway + M28UnitInfo.refCategoryMobileLandFactory + M28UnitInfo.refCategorySpecialFactory + M28UnitInfo.refCategoryMobileAircraftFactory + categories.EXTERNALFACTORYUNIT, oUnit.UnitId) then
                        --If have been gifted factory or created via cheat then want to start building something
                            oUnit[M28Factory.refiTotalBuildCount] = 0
                            if oUnit:GetFractionComplete() >= 1 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Calling logic to try and build something from this factory') end
                                ForkThread(M28Factory.DecideAndBuildUnitForFactory, oUnit:GetAIBrain(), oUnit)
                            end
                        end
                        --Check unit cap
                        if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have too many units, expected remaining cap='..(aiBrain[M28Overseer.refiExpectedRemainingCap] or 0)) end
                        if (aiBrain[M28Overseer.refiExpectedRemainingCap] or 0) <= 100 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will check the unit cap') end
                            M28Overseer.CheckUnitCap(aiBrain)
                        else
                            aiBrain[M28Overseer.refiExpectedRemainingCap] = aiBrain[M28Overseer.refiExpectedRemainingCap] - 1
                        end
                    elseif M28Orders.bDontConsiderCombinedArmy and ScenarioInfo.Options.M28CombinedArmy == 2 then --Non-M28AI brain, but combined armies is disabled with UI button still to be shown (so people aware of hte option), so flag so the button gets shown
                        oUnit:UpdateStat('M28CombinedArmiesShowUI', 1)
                    end
                end
            end
        end
    end
end

function OnCreateBrain(aiBrain, planName, bIsHuman)
    local sFunctionRef = 'OnCreateBrain'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.bSteamActive then import('/mods/M28AI/lua/AI/Steam/SteamCompatibility.lua').OtherSteamCompatibilityInformation() end
    if bDebugMessages == true then LOG(sFunctionRef..': aiBrain has just been created at time '..GetGameTimeSeconds()..'; Brain nickname='..(aiBrain.Nickname or 'nil')..'; Has setup been run='..tostring(aiBrain['M28BrainSetupRun'] or false)..'; Brain type='..(aiBrain.BrainType or 'nil')..'; M28Team (if brain setup)='..(aiBrain.M28Team or 'nil')..'; aiBrain.Civilian='..tostring(aiBrain.Civilian or false)..'; .M28AI='..tostring(aiBrain.M28AI or false)..'; .M27AI='..tostring(aiBrain.M27AI or false)..'; M28Overseer.iTimeOfLatestBrainToCheckForM28Logic='..(M28Overseer.iTimeOfLatestBrainToCheckForM28Logic or 'nil')..'; brain current plan first 6 chars='..string.sub(aiBrain.CurrentPlan or 'nil', 1, 6)..'; Army index='..aiBrain:GetArmyIndex()..';  ScenarioInfo.ArmySetup='..reprs( ScenarioInfo.ArmySetup)..'; reprs for player2='..reprs(ScenarioInfo.ArmySetup['Player2'])) end
    if M28Overseer.iTimeOfLatestBrainToCheckForM28Logic >= 0 then
        while GetGameTimeSeconds() < M28Overseer.iTimeOfLatestBrainToCheckForM28Logic + 1 do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting for M28Overseer.iTimeOfLatestBrainToCheckForM28Logic (if applicable), Brain='..(aiBrain.Nickname or 'nil')..'; .M28AI='..tostring(aiBrain.M28AI or false)) end
    if not(aiBrain['M28BrainSetupRun']) then
        if M28Config.M28RunProfiling then ForkThread(M28Profiler.ProfilerActualTimePerTick) end
        if bIsHuman == nil then
            if aiBrain.BrainType == "AI" or not(aiBrain.BrainType) or string.find(aiBrain.BrainType, "AI") then bIsHuman = false else bIsHuman = true end
        end
        if bIsHuman then
            M28Overseer.SetM28ActiveFlag()
        end
        if not(bIsHuman) and M28Conditions.IsM28AIPersonality(aiBrain) then
            aiBrain.M28AI = true
            M28Utilities.bM28AIInGame = true
            --LOG('M28 in game 1')
        end

        aiBrain['M28BrainSetupRun'] = true
        if bDebugMessages == true then LOG(sFunctionRef..': First time running OnCreateBrain for brain '..(aiBrain.Nickname or 'nil')..'; reprs='..reprs(aiBrain)..'; Brain name='..aiBrain.Name) end
        if not(M28Utilities.bM28AIInGame) then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        if M28Utilities.bM28AIInGame then

            while (not(M28Overseer.bBeginSessionTriggered) and GetGameTimeSeconds() < 4) do
                if bDebugMessages == true then LOG(sFunctionRef..': bBeginSessionTriggered not true yet, GameTime='..GetGameTimeSeconds()..'; will wait 1 tick; aiBrain='..aiBrain.Nickname) end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
            --Make sure we have checked if this is a scenario map (run for each AI to be safe since minimal load and ensures this happens ahead of any other M28 code)
            M28Overseer.CheckIfScenarioMap()
            if bDebugMessages == true then LOG(sFunctionRef..': M28Map.bIsCampaignMap='..tostring(M28Map.bIsCampaignMap or false)) end

            --Logic to run for all brains
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            M28Map.RecordBrainStartPoint(aiBrain)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

            if bIsHuman then
                LOG('Human player brain '..aiBrain.Nickname..' created; Index='..aiBrain:GetArmyIndex()..'; start position='..repru(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()]))
            else
                --Logic to run just for M28AI
                if aiBrain.M28AI then
                    --Redundancy - if have M27 brain then change this back to false
                    if aiBrain.M27AI then aiBrain.M28AI = false end
                    if bDebugMessages == true then LOG(sFunctionRef..': M28 brain created, aiBrain.Nickname='..(aiBrain.Nickname or 'nil')) end

                    --Copy of parts of aiBrain OnCreateAI that still want to retain
                    if planName and (not(M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) or aiBrain.CreateBrainShared) then
                        aiBrain:CreateBrainShared(planName)
                    end
                    --aiBrain:InitializeEconomyState()
                    aiBrain.BrainType = 'AI'
                    local per = ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality
                    local cheatPos = string.find(per, 'cheat')
                    if cheatPos then
                        if not(M28Utilities.bLoudModActive or M28Utilities.bQuietModActive) then
                            local AIUtils = import('/lua/ai/aiutilities.lua')
                            AIUtils.SetupCheat(aiBrain, true)
                            ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality = string.sub(per, 1, cheatPos - 1)
                        end
                    end

                    --M28AIBrainClass.OnCreateAI(aiBrain, planName)
                    ForkThread(M28Overseer.M28BrainCreated, aiBrain)
                else
                    --LOG('OnCreateBrain hook for Non-M28 ai with personality '..(ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality or 'nil'))
                    --Reundancy - check M27 isn't being treated as M28AI
                    ForkThread(M28Overseer.DelayedM27M28BrainCheck, aiBrain)
                end
            end
        end
    elseif aiBrain.M28AI and aiBrain.M27AI then
        aiBrain.M28AI = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function OnMissileImpactTerrain(self, target, position)
    if M28Utilities.bM28AIInGame then
        --LOG('Missile impact terrain at time '..GetGameTimeSeconds()..'; self='..reprs(self))
        --Was this an M28 unit?
        --Wait 1 tick to give a chance for damage to process
        WaitTicks(1)
        if M28UnitInfo.IsUnitValid(self) and self:GetAIBrain().M28AI then
            local sFunctionRef = 'OnMissileImpactTerrain'
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

            local tLastOrder = self[M28Orders.reftiLastOrders][self[M28Orders.refiOrderCount]]

            if bDebugMessages == true then LOG(sFunctionRef..': self='..(self.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(self) or 'nil')..'; target='..reprs(target)..'; position='..repru(position)..'; tLastOrder='..reprs(tLastOrder)..'; self[M28Building.refiLastTMLMassKills]='..(self[M28Building.refiLastTMLMassKills] or 'nil')..'; Acual XP='..(self.VetExperience or self.Sync.totalMassKilled or 0)) end
            --Mobile missile logic tracking
            if EntityCategoryContains(categories.MOBILE, self.UnitId) and not( tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueTMLMissile) then
                --(Removed check about if dealt damage recently, as we mightve damaged a shield protruding over the terrain, leaving to us thinking we are dealing damage when we arent)
                if bDebugMessages == true then LOG(sFunctionRef..': Mobile missile launcher that didnt have a luanch TML order, time of last unblocked shot='..GetGameTimeSeconds() - (self[M28UnitInfo.refiTimeOfLastUnblockedShot] or 0)) end
                --if not(self[M28UnitInfo.refiTimeOfLastUnblockedShot]) or GetGameTimeSeconds() - self[M28UnitInfo.refiTimeOfLastUnblockedShot] >= 1.5 then
                    --If we have a target and the angle to the target is similar to the angle to where the missile impacted (suggesting we havent switched targets) then track the shots
                    if bDebugMessages == true then LOG(sFunctionRef..': Is target empty='..tostring(M28Utilities.IsTableEmpty(target))..'; tLastOrder[M28Orders.subrefoOrderUnitTarget]='..(tLastOrder[M28Orders.subrefoOrderUnitTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tLastOrder[M28Orders.subrefoOrderUnitTarget]) or 'nil')..'; tLastOrder[M28Orders.subrefiOrderType]='..(tLastOrder[M28Orders.subrefiOrderType] or 'nil')) end
                    if M28Utilities.IsTableEmpty(target) == false and M28UnitInfo.IsUnitValid(tLastOrder[M28Orders.subrefoOrderUnitTarget]) and (EntityCategoryContains(M28UnitInfo.refCategoryStructure, tLastOrder[M28Orders.subrefoOrderUnitTarget].UnitId) or tLastOrder[M28Orders.subrefoOrderUnitTarget]:GetFractionComplete() < 1) and (tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAttack or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueGroundAttack) then
                        --Check the target position isn't far from the current unit target
                        if bDebugMessages == true then LOG(sFunctionRef..': Dist between target and unit target position='..M28Utilities.GetDistanceBetweenPositions(target, tLastOrder[M28Orders.subrefoOrderUnitTarget]:GetPosition())) end
                        if M28Utilities.GetDistanceBetweenPositions(target, tLastOrder[M28Orders.subrefoOrderUnitTarget]:GetPosition()) <= 5 then
                            tLastOrder[M28Orders.subrefoOrderUnitTarget][M28UnitInfo.refiMissileShotBlockedCount] = (tLastOrder[M28Orders.subrefoOrderUnitTarget][M28UnitInfo.refiMissileShotBlockedCount] or 0) + 1
                            if not(self[M28UnitInfo.reftoTargetBlockedMissileCountByEntityId]) then self[M28UnitInfo.reftoTargetBlockedMissileCountByEntityId] = {} end
                            self[M28UnitInfo.reftoTargetBlockedMissileCountByEntityId][tLastOrder[M28Orders.subrefoOrderUnitTarget].EntityId] = (self[M28UnitInfo.reftoTargetBlockedMissileCountByEntityId][tLastOrder[M28Orders.subrefoOrderUnitTarget].EntityId] or 0) + 1
                            if bDebugMessages == true then LOG(sFunctionRef..': Increasing missile shot blocked count by 1, tLastOrder[M28Orders.subrefoOrderUnitTarget][M28UnitInfo.refiMissileShotBlockedCount]='..tLastOrder[M28Orders.subrefoOrderUnitTarget][M28UnitInfo.refiMissileShotBlockedCount]) end
                        end
                    end
                --end
                --TML logic tracking
            elseif tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueTMLMissile or M28Utilities.IsTableEmpty(target) == false then
                --Did we not gain any mass kills (e.g. mightve hit the ground deliberately for aoe)
                if (self[M28Building.refiLastTMLMassKills] or 0) == (self.VetExperience or self.Sync.totalMassKilled or 0) then
                    --Have we dealt damage via the ondamaged callback recently?
                    if not(self[M28UnitInfo.refiTimeOfLastUnblockedShot]) or GetGameTimeSeconds() - self[M28UnitInfo.refiTimeOfLastUnblockedShot] >= 1.5 then
                        if not(self[M28Building.reftTerrainBlockedTargets]) then self[M28Building.reftTerrainBlockedTargets] = {} end
                        local tLastTarget = tLastOrder[M28Orders.subreftOrderPosition]

                        if M28Utilities.IsTableEmpty(tLastTarget) == false then table.insert(self[M28Building.reftTerrainBlockedTargets], {tLastTarget[1], tLastTarget[2], tLastTarget[3]}) end
                        if M28Utilities.IsTableEmpty(tLastTarget) or M28Utilities.GetDistanceBetweenPositions(tLastTarget, target) >= 1 then table.insert(self[M28Building.reftTerrainBlockedTargets], {target[1], target[2], target[3]}) end
                        if bDebugMessages == true then LOG(sFunctionRef..': Added locations to blackist, repru of blacklist='..repru(self[M28Building.reftTerrainBlockedTargets])) end
                    end
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        end
    end
end

function OnMissileImpact(self, targetType, targetEntity)
    if M28Utilities.bM28AIInGame then
        --LOG('Missile impact at time '..GetGameTimeSeconds()..'; self='..reprs(self))
        local launcher = self.Launcher
        --M28 Specific launcher
        if launcher and M28UnitInfo.IsUnitValid(launcher) and launcher:GetAIBrain().M28AI then
            --Nukes
            if EntityCategoryContains(M28UnitInfo.refCategorySML, launcher.UnitId) then
                M28Building.UpdateForNukeMissileDeath(launcher, self:GetPosition())
            end
        end
    end
end

function OnMapResizeFORSEARCHONLY()  end --So can find onplayableareachange easier
function OnPlayableAreaChange(rect, voFlag)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnPlayableAreaChange'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Playable area change detected, rect='..repru(rect)..'; voFlag='..reprs(voFlag)..'; Time='..GetGameTimeSeconds()..'; bIsCampaignMap='..tostring(M28Map.bIsCampaignMap or false)) end
        local ScenarioUtils = import("/lua/sim/scenarioutilities.lua")
        if type(rect) == 'string' then
            rect = ScenarioUtils.AreaToRect(rect)
        end
        if M28Utilities.bM28AIInGame or GetGameTimeSeconds() <= 5 then
            --Check actually have playable area (to cover bug in a LOUD map where playable area is set to 0,0,0,0
            if not((rect[1] or rect['x0']) == 0 and (rect[2] or rect['y0']) == 0 and (rect[3] or rect['x1']) == 0 and (rect[4] or rect['y1']) == 0) then
                if bDebugMessages == true then LOG(sFunctionRef..': Will call SetupPlayableAreaAndSegmentSizes, rect[1]='..(rect[1] or 'nil')..'; rect[2]='..(rect[2] or 'nil')..'; rect[3]='..(rect[3] or 'nil')..'; rect[4]='..(rect[4] or 'nil')..'; rect[1] == 0='..tostring((rect[1] == 0))..'; rect='..repru(rect)) end
                M28Map.SetupPlayableAreaAndSegmentSizes(rect)
            end
        end
        if M28Map.bIsCampaignMap or not(ScenarioInfo.type == "skirmish") then
            ForkThread(M28Overseer.UpdateMaxUnitCapForRelevantBrains)
            ForkThread(M28Engineer.CheckForSpecialCampaignCaptureTargets)
            --Wait 5s then consider campaign special objectives
            ForkThread(M28Overseer.ConsiderSpecialCampaignObjectives, nil, nil, nil, nil, nil, nil, nil, nil,  5)
            --Update location of nearest friendly base (intended to help if we are applying M28AI to hostile AI)
            ForkThread(M28Map.RefreshCampaignStartPositionsAfterDelay, 5)
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function CaptureTriggerAdded(FunctionForOldUnit, FunctionForNewUnit, oUnit)
    --Intended for campaign maps where a capture objective gets captured by the enemy, e.g. black sun control centre
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'CaptureTriggerAdded'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if M28Utilities.bM28AIInGame and M28Map.bIsCampaignMap then
            oUnit[M28UnitInfo.refbCampaignTriggerAdded] = true
            if not(EntityCategoryContains(categories.MOBILE, oUnit.UnitId)) then

                if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                if M28UnitInfo.IsUnitValid(oUnit) then
                    local aiBrain
                    if M28Utilities.IsTableEmpty(M28Overseer.tAllActiveM28Brains) == false then
                        for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                            aiBrain = oBrain
                            if not(oBrain.CampaignAI) then break end
                        end
                        if not(IsAlly(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex())) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Unit is not an ally so will record as a capture target') end
                            M28Engineer.RecordUnitAsCaptureTarget(oUnit)
                        end
                    end
                end
            end
            oUnit[M28UnitInfo.refbCampaignTriggerAdded] = true
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function DeathTriggerAdded(oUnit)
    if M28Utilities.bM28AIInGame then
        oUnit[M28UnitInfo.refbCampaignTriggerAdded] = true
    end
end
function CreateUnitReclaimedTrigger(oUnit)
    if M28Utilities.bM28AIInGame then
        oUnit[M28UnitInfo.refbCampaignTriggerAdded] = true
    end
end

function ObjectiveAdded(oObjective, Type, Complete, Title, Description, ActionImage, Target, IsLoading, loadedTag)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'ObjectiveAdded'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; if map setup not complete then will wait for it to be complete') end
        --Wait until map setup complete
        while not(M28Map.bMapLandSetupComplete) or not(M28Map.bWaterZoneInitialCreation) do
            if GetGameTimeSeconds() >= 10 then break end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end


        if M28Utilities.bM28AIInGame then
            --Record capture missions
            if bDebugMessages == true then LOG('Have a mission, Title='..Title..'; Description='..Description..'; Target.captured='..(Target.captured or 'nil')..'; reprs of Target='..reprs(Target)) end
            if Target.captured == 0 then
                if bDebugMessages == true then  LOG('Have a capture mission, is target empty='..tostring(M28Utilities.IsTableEmpty(Target))) end
                --Record every unit to be captured
                if M28Utilities.IsTableEmpty(Target.Units) == false then
                    for iEntry, oUnit in Target.Units do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..' in Target; Is valid unit='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            M28Engineer.RecordUnitAsCaptureTarget(oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': WIll record unit as capture target assuming it is in a land zone') end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': size of target units='..table.getn(Target.Units)) end
                    --If only have 1 unit (i.e. is a key location) then flag to fortify
                    if table.getn(Target.Units) == 1 then
                        local oFirstM28Brain
                        for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                            oFirstM28Brain = oBrain
                            if not(oBrain.CampaignAI) then
                                break
                            end
                        end
                        local iTeam = oFirstM28Brain.M28Team
                        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(Target.Units[1]:GetPosition())
                        M28Map.MarkZoneForFortification(iPlateauOrZero, iLandOrWaterZone, iTeam)
                        if bDebugMessages == true then LOG(sFunctionRef..': flagged to fortify zone for unit '..Target.Units[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(Target.Units[1])..' at position '..repru(Target.Units[1]:GetPosition())..'; iTeam='..iTeam) end
                    end
                end
            elseif M28Utilities.IsTableEmpty(Target.Units) == false then
                local bOnlyHaveAllies = true
                local bHaveLowHealthAlly = true
                local oFirstM28Brain
                for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                    oFirstM28Brain = oBrain
                    if not(oBrain.CampaignAI) then
                        break
                    end
                end
                local iTeam = oFirstM28Brain.M28Team
                local tUnitsToRepair = {}
                for iUnit, oUnit in Target.Units do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit)))
                        if M28UnitInfo.IsUnitValid(oUnit) then LOG(sFunctionRef..': Unit is valid, Health%='..M28UnitInfo.GetUnitHealthPercent(oUnit)..'; Is enemy='..tostring(IsEnemy(oFirstM28Brain:GetArmyIndex(),  oUnit:GetAIBrain():GetArmyIndex()))..'; IsAlly='..tostring(IsAlly(oFirstM28Brain:GetArmyIndex(),  oUnit:GetAIBrain():GetArmyIndex()))) end
                    end

                    if M28UnitInfo.IsUnitValid(oUnit) then
                        if IsAlly(oFirstM28Brain:GetArmyIndex(),  oUnit:GetAIBrain():GetArmyIndex()) then
                            if bDebugMessages == true then LOG(sFunctionRef..'; Unit is an ally, health%='..M28UnitInfo.GetUnitHealthPercent(oUnit)) end
                            if M28UnitInfo.GetUnitHealthPercent(oUnit) < 1 then
                                table.insert(tUnitsToRepair, oUnit)
                            else
                                bHaveLowHealthAlly = false
                            end
                        else
                            bOnlyHaveAllies = false
                            if IsEnemy(oFirstM28Brain:GetArmyIndex(),  oUnit:GetAIBrain():GetArmyIndex()) then
                                --Make sure we are tracking this unit
                                if bDebugMessages == true then LOG(sFunctionRef..': Sent enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to be recorded in case we lack intel of it, is oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam] true for first M28brain='..tostring(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][oFirstM28Brain.M28Team] or false)) end
                                M28Team.AssignUnitToLandZoneOrPond(oFirstM28Brain, oUnit, nil, nil, true)
                                --Track air experimentals as special targets

                                if EntityCategoryContains(M28UnitInfo.refCategoryAllAir * categories.EXPERIMENTAL, oUnit.UnitId) then
                                    local bAlreadyIncluded = false
                                    if not(M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives]) then M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives] = {}
                                    else
                                        for iRecordedUnit, oRecordedUnit in M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives] do
                                            if oRecordedUnit == oUnit then bAlreadyIncluded = true break end
                                        end
                                    end
                                    if not(bAlreadyIncluded) then
                                        table.insert(M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives], oUnit)
                                    end
                                end
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': bHaveLowHealthAlly='..tostring(bHaveLowHealthAlly)..'; Is table of units to repair empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToRepair))) end
                if bHaveLowHealthAlly and M28Utilities.IsTableEmpty(tUnitsToRepair) == false then
                    local iPlateauOrZero, iLandOrWaterZone
                    local iTeam
                    for iBrain, oBrain in ArmyBrains do
                        if oBrain.M28AI then
                            iTeam = oBrain.M28Team
                            if not(oBrain.CampaignAI) then
                                break
                            end
                        end
                    end
                    for iEntry, oUnit in tUnitsToRepair do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..' in tUnitsToRepair; Is valid unit='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                            local tLZOrWZData
                            if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; Unit position='..repru(oUnit:GetPosition())) end
                            if iLandOrWaterZone > 0 then
                                local tLZOrWZTeamData
                                if iPlateauOrZero == 0 then
                                    tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                                    tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                                else
                                    tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                                    tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                                end
                                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subreftoUnitsToRepair]) then tLZOrWZData[M28Map.subreftoUnitsToRepair] = {} end
                                table.insert(tLZOrWZData[M28Map.subreftoUnitsToRepair], oUnit)
                                M28Air.AddPriorityAirDefenceTarget(oUnit)
                                if bDebugMessages == true then LOG(sFunctionRef..': Added unit to table of units to repair') end
                                --Consider adding this zone as somewhere to drop if it's not adjacent to a core zone
                                if iPlateauOrZero > 0 then
                                    local bAdjacentToCoreBase = false
                                    if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] then
                                        bAdjacentToCoreBase = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': Are in a core base; tLZOrWZTeamData[M28Map.subrefbCoreBaseOverride]='..tostring(tLZOrWZTeamData[M28Map.subrefbCoreBaseOverride])) end

                                    elseif M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                        for _, iAdjLZ in tLZOrWZData[M28Map.subrefLZAdjacentLandZones] do
                                            if M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] then
                                                if bDebugMessages == true then LOG(sFunctionRef..': iAdjLZ '..iAdjLZ..' is a core base, midpoint of adjlz='..repru(M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMidpoint])..'; Dist to midpoint of this LZ='..M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMidpoint], tLZOrWZData[M28Map.subrefMidpoint])..'; Travel distance='..(M28Map.GetTravelDistanceBetweenLandZones(iPlateauOrZero, iLandOrWaterZone, iAdjLZ) or 'nil')) end
                                                bAdjacentToCoreBase = true
                                                break
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to add location as a drop zone target, bAdjacentToCoreBase='..tostring(bAdjacentToCoreBase)..'; iTeam='..iTeam) end
                                    if not(bAdjacentToCoreBase) then
                                        --Add to locations for priority transport drop
                                        M28Air.UpdateTransportPlateauDropLocationShortlist(iTeam) --incase not already run
                                        M28Air.AddZoneToPotentialDropZonesSameIslandOrDifPond(iTeam, iPlateauOrZero, iLandOrWaterZone)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have tried toa dd to same island drop list, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; iTeam='..iTeam) end
                                    end
                                end
                            end
                        end
                    end
                    --If only have 1 unit (i.e. is a key location) then flag to fortify
                    if table.getn(Target.Units) == 1 then
                        local oFirstM28Brain
                        for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                            oFirstM28Brain = oBrain
                            if not(oFirstM28Brain.CampaignAI) then
                                break
                            end
                        end
                        local iTeam = oFirstM28Brain.M28Team
                        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(Target.Units[1]:GetPosition())
                        M28Map.MarkZoneForFortification(iPlateauOrZero, iLandOrWaterZone, iTeam)
                        if bDebugMessages == true then
                            local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(Target.Units[1]:GetPosition())
                            LOG(sFunctionRef..': flagged to fortify zone for repair target, ='..Target.Units[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(Target.Units[1])..' at position '..repru(Target.Units[1]:GetPosition())..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Fortify zone flag='..tostring(M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZFortify] or false))
                        end
                    end
                elseif bOnlyHaveAllies then
                    if bDebugMessages == true then LOG(sFunctionRef..': Only have allies so setting priority air defence target and will make sure we arent going to try and reclaim them') end
                    for iUnit, oUnit in Target.Units do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            M28Air.AddPriorityAirDefenceTarget(oUnit)
                            oUnit[M28UnitInfo.refbIsReclaimTarget] = false
                            if M28Utilities.IsTableEmpty(oUnit[M28UnitInfo.refiTeamsWithThisAsReclaimTarget]) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': We had recorded this as a reclaim target for the following teams - will now remove.'..repru(oUnit[M28UnitInfo.refiTeamsWithThisAsReclaimTarget])) end
                                for _, iRecordedTeam in oUnit[M28UnitInfo.refiTeamsWithThisAsReclaimTarget] do
                                    local tUnitLZData, tUnitLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iRecordedTeam)
                                    if M28Utilities.IsTableEmpty(tUnitLZTeamData[M28Map.subreftoUnitsToReclaim]) == false then
                                        for iRecordedUnit, oRecordedUnit in tUnitLZTeamData[M28Map.subreftoUnitsToReclaim] do
                                            if oRecordedUnit == oUnit then
                                                table.remove(tUnitLZTeamData[M28Map.subreftoUnitsToReclaim], iRecordedUnit)
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            elseif bDebugMessages == true then LOG(sFunctionRef..': Target.Units is empty; Target.UnitId='..(Target.UnitId or 'nil'))
            end

            --Record units as objective targets generally (used to trigger onkilled callback from upgrades)
            if M28Utilities.IsTableEmpty(Target.Units) == false then
                local iTotalTargetUnitCounts = 0
                local iDeadUpgradingTargetUnitCount = 0
                local toDeadUpgradingTargetUnits = {}
                for iUnit, oUnit in Target.Units do
                    iTotalTargetUnitCounts = iTotalTargetUnitCounts + 1
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording we have an objective for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; oUnit[M28UnitInfo.refbIssuedUpgrade]='..tostring(oUnit[M28UnitInfo.refbIssuedUpgrade] or false)..'; Is Unit.EventCallbacks.OnKilled nil='..tostring(oUnit.EventCallbacks.OnKilled == nil)..'; iTotalTargetUnitCounts='..iTotalTargetUnitCounts) end
                    oUnit[M28UnitInfo.refbObjectiveUnit] = true
                    if oUnit.EventCallbacks.OnKilled then
                        --Trigger the on-death for the unit if it is an external factory unit
                        if EntityCategoryContains(categories.EXTERNALFACTORYUNIT, oUnit.UnitId) then
                            oUnit:DoUnitCallbacks('OnKilled')
                            --Also trigger if it is a building unit that can upgrade to another unit, and is showing as dead, was an M28 unit, and we have a building of a higher tech levle in its place (e.g. for UEF mission 1 where we can upgrade the air factory)
                        elseif oUnit[M28UnitInfo.refbIssuedUpgrade] and not(M28UnitInfo.IsUnitValid(oUnit)) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Running onkilled clalback') end
                            oUnit:DoUnitCallbacks('OnKilled')
                        end
                    elseif oUnit[M28UnitInfo.refbIssuedUpgrade] and oUnit.Dead then
                        iDeadUpgradingTargetUnitCount = iDeadUpgradingTargetUnitCount + 1
                        table.insert(toDeadUpgradingTargetUnits, oUnit)
                    end
                end
                --Issue if upgraded the unit fully before objective called, then it might not have an EventCallback.OnKilled for it; added for UEF SC M1 but didnt solve the problem, left in though as the error message may be useful and it's possible in another scenario it might work
                if bDebugMessages == true then LOG(sFunctionRef..': Checking for redundancy from upgrades canceling objective, oObjective.Active='..tostring(oObjective.Active)..'; Type='..Type..'; iTotalTargetUnitCounts='..iTotalTargetUnitCounts..'; iDeadUpgradingTargetUnitCount='..iDeadUpgradingTargetUnitCount..'; Is oObjective.OnUnitKilled nil='..tostring(oObjective.OnUnitKilled == nil)) end
                if iTotalTargetUnitCounts > 0 and iDeadUpgradingTargetUnitCount == iTotalTargetUnitCounts and Type == 'primary' and oObjective.OnUnitKilled and M28Utilities.IsTableEmpty(toDeadUpgradingTargetUnits) == false then
                    M28Utilities.ErrorHandler('All primary objective units are dead due to upgrading them, will attempt to trigger onkilled callback, is objective active='..tostring(oObjective.Active or false), true, true)
                    if oObjective.Active then
                        for iUnit, oUnit in toDeadUpgradingTargetUnits do
                            if bDebugMessages == true then LOG(sFunctionRef..': will call OnUnitKilled for oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                            oObjective.OnUnitKilled(oUnit)
                        end
                    end
                end
            end

            --Manual objective checks (e.g. where campaign doesnt use the function for adding objectives)
            M28Engineer.CheckForSpecialCampaignCaptureTargets()
            if bDebugMessages == true then LOG(sFunctionRef..': About to check for special campaign objectives') end
            ForkThread(M28Overseer.ConsiderSpecialCampaignObjectives,Type, Complete, Title, Description, ActionImage, Target, IsLoading, loadedTag)
        end

        ForkThread(M28Overseer.UpdateMaxUnitCapForRelevantBrains)

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function ReclaimTargetObjectiveAdded(Type, Complete, Title, Description, Target)
    --Triggers when SimObjectives.Reclaim function is called
    --Note that objectiveadded function above will also be triggered
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'ReclaimTargetObjectiveAdded'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; if map setup not complete then will wait for it to be complete') end
        --Wait until map setup complete
        while not(M28Map.bMapLandSetupComplete) or not(M28Map.bWaterZoneInitialCreation) do
            if GetGameTimeSeconds() >= 10 then break end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end


        if M28Utilities.bM28AIInGame then
            if M28Utilities.IsTableEmpty(Target.Units) == false then
                local oFirstM28Brain
                for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                    oFirstM28Brain = oBrain
                    if not(oBrain.CampaignAI) then
                        break
                    end
                end
                local iPlateauOrZero, iLandOrWaterZone
                local iTeam = oFirstM28Brain.M28Team

                for iEntry, oUnit in Target.Units do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..' in units to reclaim; Is valid unit='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                        local tLZOrWZData
                        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; Unit position='..repru(oUnit:GetPosition())) end
                        if iLandOrWaterZone > 0 then
                            local tLZOrWZTeamData
                            if iPlateauOrZero == 0 then --Waterzone
                                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                            else
                                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                            end
                            if not(tLZOrWZTeamData[M28Map.subreftoUnitsToReclaim]) then tLZOrWZTeamData[M28Map.subreftoUnitsToReclaim] = {} end
                            table.insert(tLZOrWZTeamData[M28Map.subreftoUnitsToReclaim], oUnit)
                            oUnit[M28UnitInfo.refbIsReclaimTarget] = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of units to reclaim for team '..iTeam..' in iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; iTeam='..iTeam..'; oFirstM28Brain='..oFirstM28Brain.Nickname..'; Is tLZOrWZTeamData[M28Map.subreftoUnitsToReclaim] empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoUnitsToReclaim]))) end
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnMissileIntercepted(oLauncher, target, oTMD, position, oProjectile)
    --M28AI specific - also exclude if TMD is owned by the same team, as as of 24/09/2023 there's a bug with FAF where this callback triggers with oTMD being another or the same MML
    if M28Utilities.bM28AIInGame then
        if not(oLauncher.Dead) and M28UnitInfo.IsUnitValid(oTMD) and not(oLauncher:GetAIBrain().M28Team == oTMD:GetAIBrain().M28Team) then
            local sFunctionRef = 'OnMissileIntercepted'
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            local oLauncherBrain = oLauncher:GetAIBrain()

            --MML - record time that were last intercepted if dealing with non-aeo TMD (used to build more MML) for both the MML and the TMD land zones
            if bDebugMessages == true then LOG('Missile intercepted, oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..'; is launcher a nuke='..tostring(EntityCategoryContains(M28UnitInfo.refCategorySML, oLauncher.UnitId))..'; is launcher valid='..tostring(M28UnitInfo.IsUnitValid(oLauncher))) end
            if EntityCategoryContains(M28UnitInfo.refCategoryMML, oLauncher.UnitId) then --and not(EntityCategoryContains(categories.AEON, oTMD.UnitId)) and EntityCategoryContains(M28UnitInfo.refCategoryTMD, oTMD.UnitId) then
                local iLauncherTeam = oLauncher:GetAIBrain().M28Team
                if bDebugMessages == true then LOG('MML intercepted by tmd, oLauncher='..(oLauncher.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oLauncher) or 'nil')..'; oTMD='..(oTMD.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTMD) or 'nil')..'; Launcher team='..iLauncherTeam..'; Launcher brain='..oLauncher:GetAIBrain().Nickname..'; TMD nickname='..oTMD:GetAIBrain().Nickname) end
                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oLauncher:GetPosition(), true, oLauncher)
                if oLauncherBrain.M28AI and (iLandZone or 0) > 0 and iPlateau > 0 then
                    local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iLauncherTeam]
                    tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] = GetGameTimeSeconds()
                end
                local iTMDPlateau, iTMDLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oTMD:GetPosition())
                if (iTMDLandZone or 0) > 0 and iTMDPlateau > 0 then
                    if oLauncherBrain.M28AI and not(iTMDLandZone == iLandZone and iTMDPlateau == iPlateau) then
                        local tLZTeamData = M28Map.tAllPlateaus[iTMDPlateau][M28Map.subrefPlateauLandZones][iTMDLandZone][M28Map.subrefLZTeamData][iLauncherTeam]
                        tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] = GetGameTimeSeconds()
                    end
                    local oBrainTMD = oTMD:GetAIBrain()
                    if oBrainTMD.M28AI then
                        --Replace team data since want to get from TMD team perspective now
                        local tLZTeamData = M28Map.tAllPlateaus[iTMDPlateau][M28Map.subrefPlateauLandZones][iTMDLandZone][M28Map.subrefLZTeamData][oBrainTMD.M28Team]
                        tLZTeamData[M28Map.subrefiTimeFriendlyTMDHitEnemyMissile] = GetGameTimeSeconds()
                        oTMD[M28Building.refiTimeTMDHitMissile] = GetGameTimeSeconds()
                        if M28UnitInfo.IsUnitValid(oLauncher) then --redundancy
                            local bRecordedAlready = false
                            if not(oTMD[M28Building.toLaunchersIntercepted]) then oTMD[M28Building.toLaunchersIntercepted] = {}
                            elseif M28Conditions.IsTableOfUnitsStillValid(oTMD[M28Building.toLaunchersIntercepted]) then
                                for iRecordedLauncher, oRecordedLauncher in oTMD[M28Building.toLaunchersIntercepted] do
                                    if oRecordedLauncher == oLauncher then
                                        bRecordedAlready = true
                                        break
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': About to record oLauncher against TMD table of launchers intercepted if not already recorded, bRecordedAlready='..tostring(bRecordedAlready)..'; oTMD[M28Building.refiTimeTMDHitMissile]='..(oTMD[M28Building.refiTimeTMDHitMissile] or 'nil')..'; oTMD='..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)) end
                            if not(bRecordedAlready) then table.insert(oTMD[M28Building.toLaunchersIntercepted], oLauncher) end
                        end
                    end
                end
                --sometimes the launcher is receiving its orders from an adjacent zone, so want that adjacnet zone's combat logic to recognise this when deciding whether to syncrhonise shots
                if oLauncher.M28AI and oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][2] and not( oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][2] == iLandZone and oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][1] == iPlateau) and not( oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][2] == iTMDLandZone and oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][1] == iTMDPlateau) then
                    local tAssignedLZTeamData = M28Map.tAllPlateaus[oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][1]][M28Map.subrefPlateauLandZones][oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][2]][M28Map.subrefLZTeamData][iLauncherTeam]
                    tAssignedLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] = GetGameTimeSeconds()
                end
            elseif EntityCategoryContains(M28UnitInfo.refCategorySML, oLauncher.UnitId) and M28UnitInfo.IsUnitValid(oLauncher) then
                if bDebugMessages == true then LOG('Will call nuke missile death logic') end
                M28Building.UpdateForNukeMissileDeath(oLauncher)
            elseif EntityCategoryContains(M28UnitInfo.refCategoryTMD, oTMD.UnitId) then
                if oProjectile[M28Building.refoLastTMLTarget] then oProjectile[M28Building.refoLastTMLTarget][M28Building.refbRecheckTMLAndTMDWhenConstructedByTeam] = nil end

                local oBrainTMD = oTMD:GetAIBrain()
                if oBrainTMD.M28AI then
                    local iTMDPlateau, iTMDLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oTMD:GetPosition())
                    if (iTMDLandZone or 0) > 0 and iTMDPlateau > 0 then
                        local tLZTeamData = M28Map.tAllPlateaus[iTMDPlateau][M28Map.subrefPlateauLandZones][iTMDLandZone][M28Map.subrefLZTeamData][oBrainTMD.M28Team]
                        tLZTeamData[M28Map.subrefiTimeFriendlyTMDHitEnemyMissile] = GetGameTimeSeconds()
                        oTMD[M28Building.refiTimeTMDHitMissile] = GetGameTimeSeconds()
                        if M28UnitInfo.IsUnitValid(oLauncher) then --redundancy
                            local bRecordedAlready = false
                            if not(oTMD[M28Building.toLaunchersIntercepted]) then oTMD[M28Building.toLaunchersIntercepted] = {}
                            elseif M28Conditions.IsTableOfUnitsStillValid(oTMD[M28Building.toLaunchersIntercepted]) then
                                for iRecordedLauncher, oRecordedLauncher in oTMD[M28Building.toLaunchersIntercepted] do
                                    if oRecordedLauncher == oLauncher then
                                        bRecordedAlready = true
                                        break
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': About to record oLauncher against TMD table of launchers intercepted if not already recorded, bRecordedAlready='..tostring(bRecordedAlready)..'; oTMD[M28Building.refiTimeTMDHitMissile]='..(oTMD[M28Building.refiTimeTMDHitMissile] or 'nil')..'; oTMD='..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)) end
                            if not(bRecordedAlready) then table.insert(oTMD[M28Building.toLaunchersIntercepted], oLauncher) end
                        end
                    end
                end
                if M28UnitInfo.IsUnitValid(oLauncher) and oLauncher:GetAIBrain().M28AI and M28Utilities.IsTableEmpty(target) == false then
                    --Make sure we have recorded this TMD as a blogking TMD if not already for the launcher/unit
                    local tUnitsNearTarget = oTMD:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryProtectFromTML, target, 3, 'Ally')
                    if M28Utilities.IsTableEmpty(tUnitsNearTarget) == false then
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': TMD has intercepted TML missile, so will make sure all units near the target of the missile record that the TMD is protecting them, is tUnitsNearTarget empty='..tostring(M28Utilities.IsTableEmpty(tUnitsNearTarget))..'; target='..reprs(target)..'; oTMD='..oTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTMD)..'; TMD position='..repru(oTMD:GetPosition())..'; position='..repru(position)..'; Is oProjectile[M28Building.refoLastTMLTarget] nil='..tostring(oProjectile[M28Building.refoLastTMLTarget] == nil)..'; oProjectile[M28Building.refoLastTMLTarget]='..(oProjectile[M28Building.refoLastTMLTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oProjectile[M28Building.refoLastTMLTarget]) or 'nil'))
                        end
                        for iUnit, oUnit in tUnitsNearTarget do
                            if bDebugMessages == true then LOG(sFunctionRef..': Will record that the TMD is protecting oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' unless will already have covered via oProjectile[M28Building.refoLastTMLTarget]') end
                            if not(oUnit == oProjectile[M28Building.refoLastTMLTarget]) then
                                M28Building.RecordThatTMDProtectsUnitFromTML(oTMD, oUnit, oLauncher)
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is the last TML target valid='..tostring(M28UnitInfo.IsUnitValid(oProjectile[M28Building.refoLastTMLTarget]))..'; Last target='..(oProjectile[M28Building.refoLastTMLTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oProjectile[M28Building.refoLastTMLTarget]) or 'nil')) end
                    if M28UnitInfo.IsUnitValid(oProjectile[M28Building.refoLastTMLTarget]) then
                        M28Building.RecordThatTMDProtectsUnitFromTML(oTMD, oProjectile[M28Building.refoLastTMLTarget], oLauncher)
                    end
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        end
    end

end

function DelayedUnpauseOfTransferredUnits(toCapturedUnits, iArmyIndex)
    --Tracks transferred units (to help with spotting upgrades for those already in progress), and also unpauses all units
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'DelayedUnpauseOfTransferredUnits'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


        local iCapturedUnitCount
        local aiBrain
        local tFactoriesAndMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryMex, toCapturedUnits)
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, is tFactoriesAndMexes empty='..tostring(M28Utilities.IsTableEmpty(tFactoriesAndMexes))..'; iArmyIndex='..iArmyIndex..'; Time='..GetGameTimeSeconds()) end
        if M28Utilities.IsTableEmpty(tFactoriesAndMexes) == false then
            for iBrain, oBrain in ArmyBrains do
                if oBrain:GetArmyIndex() == iArmyIndex then
                    aiBrain = oBrain
                    break
                end
            end
            if aiBrain then
                local tCompletedUnits = {}
                local tUpgradingUnit = {}
                for iUnit, oUnit in tFactoriesAndMexes do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; IsUpgrade='..tostring(oUnit.IsUpgrade or false)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Unit tech level='..M28UnitInfo.GetUnitTechLevel(oUnit)) end
                    --if oUnit.IsUpgrade then table.insert(tUpgradingUnit, oUnit)
                    if oUnit:GetFractionComplete() == 1 and  M28UnitInfo.GetUnitTechLevel(oUnit) <= 2 then
                        table.insert(tCompletedUnits, oUnit)
                    end
                end
                if M28Utilities.IsTableEmpty(tCompletedUnits) == false then
                    aiBrain[M28Overseer.refiTransferedUnitCount] = (aiBrain[M28Overseer.refiTransferedUnitCount] or 0) + 1
                    iCapturedUnitCount = aiBrain[M28Overseer.refiTransferedUnitCount]
                    if not(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount]) then aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount] = {} end
                    aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iCapturedUnitCount] = {}
                    for iUnit, oUnit in tCompletedUnits do
                        table.insert(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iCapturedUnitCount], oUnit)
                        --Delayed consideration of launching a missile
                    end
                    local tMissileLaunchers = EntityCategoryFilterDown(categories.SILO, tCompletedUnits)
                    if M28Utilities.IsTableEmpty(tMissileLaunchers) == false then
                        local iCurMissiles
                        for iLauncher, oLauncher in tMissileLaunchers do
                            --LOG('Forked consideration of launching missile Delay6')
                            if oLauncher:GetAIBrain().M28AI then --redundancy
                                M28Conditions.DelayedConsiderLaunchingMissile(oLauncher, 1, bCheckHaveMissile)
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of completed units empty='..tostring(M28Utilities.IsTableEmpty(tCompletedUnits))..'; Is table of upgrading units empty='..tostring(M28Utilities.IsTableEmpty(tUpgradingUnit))) end
                if M28Utilities.IsTableEmpty(tCompletedUnits) == false and M28Utilities.IsTableEmpty(tUpgradingUnit) == false then
                    local iClosestUnitRef, iClosestDist, iCurDist
                    for iUnit, oUnit in tUpgradingUnit do
                        iClosestDist = 2
                        iClosestUnitRef = nil
                        for iCompletedUnit, oCompletedUnit in tCompletedUnits do
                            iCurDist = M28Utilities.GetDistanceBetweenPosition(oCompletedUnit:GetPosition(), oUnit:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestUnitRef = iCompletedUnit
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished searching completed units near to unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..', iClosestUnitRef='..(iClosestUnitRef or 'nil')..'; iClosestDist='..iClosestDist) end
                        if iClosestUnitRef then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will track completed unit '..tCompletedUnits[iClosestUnitRef].UnitId..M28UnitInfo.GetUnitLifetimeCount(tCompletedUnits[iClosestUnitRef])..' as an upgrading unit, given unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is upgrading and nearby') end
                            M28Team.UpdateUpgradeTrackingOfUnit(tCompletedUnits[iClosestUnitRef], false, oUnit.UnitId)
                            table.remove(tCompletedUnits, iClosestUnitRef)
                        end
                    end
                end
                --Track upgrade count on SACUs and ACUs
                local iUpgradeableUnitsCategory = categories.COMMAND + categories.SUBCOMMANDER
                --LOUD and quiet allow factories to upgrade
                if M28Utilities.bQuietModActive or M28Utilities.bLoudModActive then iUpgradeableUnitsCategory = iUpgradeableUnitsCategory + M28UnitInfo.refCategoryFactory * categories.TECH3 end
                local tUpgradableUnits = EntityCategoryFilterDown(iUpgradeableUnitsCategory, toCapturedUnits)
                if M28Utilities.IsTableEmpty(tUpgradableUnits) == false then
                    for iUnit, oUnit in tUpgradableUnits do
                        M28ACU.UpdateUnitUpgradeCountTrackingIfNotSet(oUnit)
                    end
                end
            end
        end
        --Also flag for every unit that it has been transferred
        for iUnit, oUnit in toCapturedUnits do
            oUnit[M28UnitInfo.refbTransferredUnit] = true
        end
        ForkThread(M28Overseer.DelayedUnpauseOfUnits,toCapturedUnits, 1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1) --tried 1 tick but it didnt help
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        --[[for iUnit, oUnit in toCapturedUnits do --covered via DelayedUnpauseOfUnits now
            if M28UnitInfo.IsUnitValid(oUnit) then
                M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, false)
            end
        end--]]
        if aiBrain and iCapturedUnitCount then
            aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iCapturedUnitCount] = nil
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnCaptured(toCapturedUnits, iArmyIndex, bCaptured)
    --looks like if multiple engineers are trying to capture a unit at once this triggers for each engineer
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnCaptured'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time'..GetGameTimeSeconds()..', is toCapturedUnits empty='..tostring(M28Utilities.IsTableEmpty(toCapturedUnits))..'; Army='..reprs(iArmyIndex)..'; Captured='..reprs(bCaptured)) end
        if M28Utilities.bM28AIInGame then
            if bCaptured and M28Utilities.IsTableEmpty(toCapturedUnits) == false then
                --Below is to cover scenarios like FA Mission 6 where a capture target can be captured by the enemy
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Will cycle through each captured unit')
                    for iUnit, oUnit in toCapturedUnits do
                        LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; owned by '..oUnit:GetAIBrain().Nickname)
                    end
                end

                --Is the unit owned by an enemy to the first M28AI in the game?
                local oM28Brain
                local oCapturingBrain
                for iBrain, oBrain in ArmyBrains do
                    if not(oM28Brain) then
                        if oBrain.M28AI then
                            oM28Brain = oBrain

                        end
                    end
                    if oBrain:GetArmyIndex() == iArmyIndex then oCapturingBrain = oBrain end
                end


                local bCheckForBlackSun = M28Map.bIsCampaignMap
                for iUnit, oUnit in toCapturedUnits do
                    if bDebugMessages == true then LOG(sFunctionRef..': Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bCheckForBlackSun='..tostring(bCheckForBlackSun)..'; Is M3P2 active='..tostring(ScenarioInfo.M3P2.Active)..'; Unit brain='..oUnit:GetAIBrain().Nickname) end
                    if not(oM28Brain.M28Team == oUnit:GetAIBrain().M28Team) and not(IsAlly(oM28Brain:GetArmyIndex(), iArmyIndex)) then
                        M28Engineer.RecordUnitAsCaptureTarget(oUnit, true)
                        --Cybran M6 - fire black sun if we have just captured it
                    elseif bCheckForBlackSun and oUnit.UnitId == 'uec1901' and ScenarioInfo.M3P2.Active and oUnit:GetAIBrain().M28AI and oUnit:GetAIBrain():GetFactionIndex() == M28UnitInfo.refFactionCybran then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to fire black sun to complete cybran campaign - will fire in a bit') end
                        ForkThread(M28Overseer.DelayedCybranFireBlackSun, oUnit:GetAIBrain())
                    end
                end
                --Aeon M4 - flag the zone to be fortified (redundancy)
                if bDebugMessages == true then LOG(sFunctionRef..': Aeon M4 check, ScenarioInfo.PlayerCapturedMainframe='..tostring(ScenarioInfo.PlayerCapturedMainframe or false)..'; toCapturedUnits[1].UnitId='..(toCapturedUnits[1].UnitId or 'nil'))
                    LOG(sFunctionRef..': Aeon M6 check - treat as core zone if captured control centre, toCapturedUnits[1].UnitId='..(toCapturedUnits[1].UnitId or 'nil')..'; oCapturingBrain.Nickname='..(oCapturingBrain.Nickname or 'nil'))
                end
                if M28Map.bIsCampaignMap then
                    if ScenarioInfo.PlayerCapturedMainframe and (toCapturedUnits[1].UnitId == 'urc1901' or toCapturedUnits[1].UnitId == 'urc1902') then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have captured the mainframe, will cycle through brains to find a human brain to check if it is aeon, and hence if this is likely to be Aeon M4') end
                        for iBrain, oBrain in ArmyBrains do
                            if oBrain.BrainType == 'Human' then
                                if bDebugMessages == true then LOG(sFunctionRef..': Is human brain aeon='..tostring(oBrain:GetFactionIndex() == M28UnitInfo.refFactionAeon)) end
                                if oBrain:GetFactionIndex() == M28UnitInfo.refFactionAeon then
                                    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(toCapturedUnits[1]:GetPosition())
                                    M28Map.MarkZoneForFortification(iPlateauOrZero, iLandOrWaterZone, oBrain.M28Team)
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef..': Have flagged zone to be fortified, iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iCaptureZone='..(iCaptureZone or 'nil'))
                                    end

                                end
                                break
                            end
                        end
                        --Aeon M6 - fortify the black sun control centre
                    elseif toCapturedUnits[1].UnitId == 'uec1902' and oCapturingBrain.M28AI and not(oCapturingBrain.HostileCampaignAI) and oCapturingBrain:GetFactionIndex() == M28UnitInfo.refFactionAeon then
                        local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(toCapturedUnits[1]:GetPosition(), true, oCapturingBrain.M28Team)
                        if bDebugMessages == true then LOG(sFunctionRef..': Fortify zone being set for the black sun control centre') end
                        if tLZOrWZTeamData then
                            local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(toCapturedUnits[1]:GetPosition())
                            M28Map.MarkZoneForFortification(iPlateauOrZero, iLandOrWaterZone, oCapturingBrain.M28Team)
                        end
                    end

                end
            elseif not(bCaptured) then
                if M28Utilities.IsTableEmpty(toCapturedUnits) == false then
                    ForkThread(DelayedUnpauseOfTransferredUnits, toCapturedUnits, iArmyIndex)
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function ScenarioPlatoonCreated(oPlatoon, strArmy, strGroup, formation, tblNode, platoon, balance)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'ScenarioPlatoonCreated'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Scenario platoon created') end
        local tPlatoonUnits = oPlatoon:GetPlatoonUnits()

        if M28Utilities.IsTableEmpty(tPlatoonUnits) == false then
            for iUnit, oUnit in tPlatoonUnits do
                if M28UnitInfo.IsUnitValid(oUnit) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Calling onCreate for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                    OnCreate(oUnit)
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnTeleportComplete(self, teleporter, location, orientation)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnTeleportComplete'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        self[M28UnitInfo.reftActiveTeleportLocation] = nil
        --if bDebugMessages == true then LOG('OnTeleportComplete - self='..reprs(self)..'; teleporter='..reprs(teleporter)..'; location='..reprs(location)) end
        if self:GetAIBrain().M28AI and self[M28ACU.refbACUHasTeleport] then
            --If we arent in a core base then teleport back
            local iTeam = self:GetAIBrain().M28Team
            local tCurLZData, tCurLZTeamData = M28Map.GetLandOrWaterZoneData(self:GetPosition(), true, iTeam)
            if bDebugMessages == true then LOG(sFunctionRef..': tCurLZTeamData[M28Map.subrefLZbCoreBase]='..tostring(tCurLZTeamData[M28Map.subrefLZbCoreBase] or false)) end
            if not(tCurLZTeamData[M28Map.subrefLZbCoreBase]) then
                local tLocationToTeleportTo
                if M28Utilities.IsTableEmpty(self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder]) == false then
                    local tPrevLZData, tPrevLZTeamData = M28Map.GetLandOrWaterZoneData(self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder], true, iTeam)
                    if tPrevLZTeamData[M28Map.subrefLZbCoreBase] then
                        tLocationToTeleportTo = {self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder][1], self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder][2], self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder][3]}
                    end
                end
                if not(tLocationToTeleportTo) then
                    tLocationToTeleportTo = {tCurLZTeamData[M28Map.reftClosestFriendlyBase][1], tCurLZTeamData[M28Map.reftClosestFriendlyBase][2], tCurLZTeamData[M28Map.reftClosestFriendlyBase][3]}
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Will teleport back to '..repru(tLocationToTeleportTo)) end
                --Add to existing queue due to issue where this callback can take place even though the ACU hasn't compelted its teleport
                if M28Utilities.GetDistanceBetweenPositions(self:GetPosition(), tLocationToTeleportTo) >= 50 then
                    --Check we are relatively near the last location we were trying to teleport to
                    if M28Utilities.IsTableEmpty(self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder]) == false and M28Utilities.GetDistanceBetweenPositions(self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder], self:GetPosition()) <= 100 then
                        M28Orders.IssueTrackedTeleport(self, tLocationToTeleportTo, 5, true, 'TelRet', true)
                    end
                end
            end
        end

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnStartTeleport(self, teleporter, locationorbp, orientationorlocation,  teledistance, teleRange, LOUDorientation, telecostpaid)
    --FAF function(self, teleporter, location, orientation)
    --LOUD function(self, teleporter, bp, location, teledistance, teleRange, orientation, telecostpaid)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnStartTeleport'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        local location
        if M28Utilities.bLoudModActive or M28Utilities.bQuietModActive then location = orientationorlocation
        else location = locationorbp
        end

        if M28UnitInfo.IsUnitValid(self) then
            local iTeleportTeam = self:GetAIBrain().M28Team
            self[M28UnitInfo.reftActiveTeleportLocation] = {location[1], location[2], location[3]}
            if bDebugMessages == true then LOG(sFunctionRef..': Teleport attempt detected by unit '..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self)..'; location='..repru(location)..'; brain owner='..self:GetAIBrain().Nickname) end
            for iCurTeam = 1, M28Team.iTotalTeamCount do
                if not(iCurTeam == iTeleportTeam) and M28Team.tTeamData[iCurTeam][M28Team.subrefiActiveM28BrainCount] > 0 then
                    if not(M28Team.tTeamData[iCurTeam][M28Team.reftRecentEnemyTeleportDetails]) then
                        M28Team.tTeamData[iCurTeam][M28Team.reftRecentEnemyTeleportDetails] = {}
                    end
                    table.insert(M28Team.tTeamData[iCurTeam][M28Team.reftRecentEnemyTeleportDetails], {[M28Team.subrefoTeleportUnit] = self, [M28Team.subreftTeleportTarget] = {location[1], math.max(location[2], GetTerrainHeight(location[1], location[3])), location[3]}, [M28Team.subrefiTeleportTime] = GetGameTimeSeconds()})
                    M28Team.tTeamData[iCurTeam][M28Team.refbEnemyHasTeleport] = true
                    ForkThread(M28Building.GEMobileShieldTeleDefence, self, location, iCurTeam)
                end
            end
        end

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnGameStart()
    --Called vai hook of simInit
    if import('/mods/M28AI/lua/M28Config.lua').M28RunSimpleProfiling then
        ForkThread(M28Profiler.SimpleProfiler, 10)
    end

    --Check if we have M28 in game at this stage (in addition to setting this to true whenever an M28 brain is created):
    if not(M28Utilities.bM28AIInGame) then
        if M28Utilities.IsTableEmpty(ScenarioInfo.ArmySetup) == false then
            for sEntry, tData in ScenarioInfo.ArmySetup do
                --LOG('Considering sEntry='..sEntry..'; tData.AIPersonality='..(tData.AIPersonality or 'nil'))
                if tData.AIPersonality and string.find(tData.AIPersonality, 'm28') then
                    M28Utilities.bM28AIInGame = true
                    --LOG('M28 in game 2')
                    break
                end
            end
        end
        --[aiBrain.Name].AIPersonality
    end

    if M28Config.M28RunGamePerformanceCheck then
        ForkThread(M28Profiler.LogGamePerformanceData)
    end
end

function ShieldRechargeStarted(oUnit)
    --LOUD specific - used becuase LOUD doesnt have FAF code for shield.enabled
    oUnit[M28UnitInfo.refbShieldDown] = true
end

function ShieldDisabled(oUnit)
    --LOUD specific - used becuase LOUD doesnt have FAF code for shield.enabled
    oUnit[M28UnitInfo.refbShieldDown] = true
end
function ShieldEnabled(oUnit)
    --LOUD specific - used becuase LOUD doesnt have FAF code for shield.enabled
    oUnit[M28UnitInfo.refbShieldDown] = false
end

function PingCreated(data)
    local sFunctionRef = 'PingCreated'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG('Ping created, reprs='..reprs(data)..'; Is this a marker='..tostring(data.Type == 'Marker')) end
    local bEngiMarkerPing = false
    --Check for marker ping and get the message and brain creator
    local iIndex = data.Owner + 1
    local aiBrain
    for iBrain, oBrain in ArmyBrains do
        if iBrain == iIndex then
            if not(oBrain.M28IsDefeated) and not(oBrain:IsDefeated()) then
                aiBrain = oBrain
            end
            break
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Brain creating ping='..(aiBrain.Nickname or 'nil')..' on team '..(aiBrain.M28Team or 'nil')..'; Is table of friendly active brains empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team or 1][M28Team.subreftoFriendlyActiveM28Brains]))) end
    if aiBrain and M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        local iTeam = aiBrain.M28Team
        local iTimeSinceLastRequest = GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeSinceLastEngiRequest] or 0)
        local oFirstM28Brain
        local oFirstAnyBrain
        for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyActiveM28Brains] do
            if oBrain.M28AI then
                if not(oFirstAnyBrain) then oFirstAnyBrain = oBrain end
                if not(oBrain.BrainType == 'Human') then
                    oFirstM28Brain = oBrain
                    break
                end
            end
        end
        if data.Type == 'Marker' or data.Type == 'marker' then --(QUIET is lowercase marker)
            local oBrainForMessage = oFirstM28Brain or oFirstAnyBrain
            if bDebugMessages == true then LOG(sFunctionRef..': oBrainForMessage='..(oBrainForMessage.Nickname or 'nil')..'; iTimeSinceLastRequest='..iTimeSinceLastRequest) end
            if oBrainForMessage then
                local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(data.Location, true, aiBrain.M28Team)
                if bDebugMessages == true then
                    local iPlateau, iZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(data.Location)
                    LOG(sFunctionRef..': Is tLZOrWZTeamData nil='..tostring(tLZOrWZTeamData == nil)..'; iPlateau='..(iPlateau or 'nil')..'; iZone='..(iZone or 'nil'))
                end
                if tLZOrWZTeamData then
                    --Check if the message contains "Engi"
                    if bDebugMessages == true then LOG(sFunctionRef..': string.lower of the text='..string.lower(data.Name)..'; Does this contain engi='..(string.find(string.lower(data.Name), 'engi') or 'nil')) end
                    if string.find(string.lower(data.Name), 'engi', 1, true) then
                        bEngiMarkerPing = true
                        if iTimeSinceLastRequest < 60 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Too soon since last valid request') end
                            if tLZOrWZTeamData[M28Map.subrefoBrainWantingEngi] == aiBrain then
                                M28Chat.SendMessage(oBrainForMessage, 'EngiDenied', 'Yes yes I know, just be patient and I\'ll give you one when I can.', 1, 2, true, false, nil, nil, nil)
                            else
                                M28Chat.SendMessage(oBrainForMessage, 'EngiDenied', 'You\'ll just have to wait and ask me again in '..math.floor(60-iTimeSinceLastRequest)..' seconds.', 1, 2, true, false, nil, nil, nil)
                            end
                        else
                            --Check we have engineers in this zone
                            local bHaveEngineersInZone = false
                            local tEngineers
                            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                tEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                if M28Utilities.IsTableEmpty(tEngineers) == false then
                                    bHaveEngineersInZone = true
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': bHaveEngineersInZone='..tostring(bHaveEngineersInZone or false)) end
                            if bHaveEngineersInZone then
                                tLZOrWZTeamData[M28Map.subrefoBrainWantingEngi] = aiBrain
                                M28Team.tTeamData[iTeam][M28Team.refiTimeSinceLastEngiRequest] = GetGameTimeSeconds()
                                if not(ArmyBrains[ tLZOrWZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].BrainType == 'Human') then oBrainForMessage = ArmyBrains[ tLZOrWZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]] end
                                -- M28Chat.SendMessage(oBrainForMessage, 'EngiReqQ', 'I\'ll send you an engineer when I can', 3, 5, true, false, nil, nil, nil) --dont other with this, as its a fairly high priority
                                if bDebugMessages == true then LOG(sFunctionRef..': recording that we want to give an engineer to '..aiBrain.Nickname) end
                            else
                                M28Chat.SendMessage(oBrainForMessage, 'EngiUnav', 'I don\'t have any nearby engineers, ask again when I do', 1, 5, true, false, nil, nil, nil)
                            end
                        end
                    end
                end
            end
        end
        if not(bEngiMarkerPing) then
            if oFirstM28Brain then
                M28Team.tTeamData[aiBrain.M28Team][M28Team.refiGeneralPingsInLast30Seconds] = (M28Team.tTeamData[aiBrain.M28Team][M28Team.refiGeneralPingsInLast30Seconds] or 0) + 1
                M28Utilities.DelayChangeVariable(M28Team.tTeamData[aiBrain.M28Team], M28Team.refiGeneralPingsInLast30Seconds, -1, 30, nil, nil, nil, nil, true)
                if M28Team.tTeamData[aiBrain.M28Team][M28Team.refiGeneralPingsInLast30Seconds] >= 4 then
                    M28Chat.SendMessageAboutTooManyPings(aiBrain.M28Team)
                end
            end
        end
    end
end

function OnImpactTerrain(oProjectile, targetType, targetEntity, tProjectilePosition, tTargetPosition)
    local oLauncher = oProjectile.Launcher
    if not( IsDestroyed(oLauncher)) then
        --T2 arti logic to register shot is blocked
        if EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oLauncher.UnitId) then
            local sFunctionRef = 'OnImpactTerrain'
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

            --Is our shot far from our target?
            local tLastOrder = oLauncher[M28Orders.reftiLastOrders][1] --Since we add a delay on t2 arti before giving it a new order (with onweaponfired) hopefully this will be accurate
            if bDebugMessages == true then LOG(sFunctionRef..': subrefoOrderUnitTarget='..(tLastOrder[M28Orders.subrefoOrderUnitTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tLastOrder[M28Orders.subrefoOrderUnitTarget]) or 'nil')) end
            if tLastOrder[M28Orders.subrefoOrderUnitTarget] and M28UnitInfo.IsUnitValid(tLastOrder[M28Orders.subrefoOrderUnitTarget]) then
                --Did we impact terrain significantly higher up than our arti?
                if bDebugMessages == true then LOG(sFunctionRef..': tProjectilePosition='..repru(tProjectilePosition)..'; tTargetPosition='..repru(tTargetPosition)..'; oLauncher:GetPosition()='..repru(oLauncher:GetPosition())) end
                if tProjectilePosition[2] > oLauncher:GetPosition()[2] + 1 then
                    --Did we hit terrain far from this target?

                    --[[if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAttack then tTargetPosition = tLastOrder[M28Orders.subrefoOrderUnitTarget]:GetPosition()
                    else tTargetPosition = (tLastOrder[M28Orders.subreftOrderPosition] or tLastOrder[M28Orders.subrefoOrderUnitTarget]:GetPosition())
                    end--]]
                    local iDistToTargetFromProjectile = M28Utilities.GetDistanceBetweenPositions(tProjectilePosition, tTargetPosition)
                    if bDebugMessages == true then LOG(sFunctionRef..': iDistToTargetFromProjectile='..iDistToTargetFromProjectile) end
                    if iDistToTargetFromProjectile >= 30 then
                        --Did we impact on the way to the target from the launcher?
                        local iDistToLauncherFromProjectile = M28Utilities.GetDistanceBetweenPositions(tProjectilePosition, oLauncher:GetPosition())
                        local iDistToLauncherFromTarget = M28Utilities.GetDistanceBetweenPositions(tTargetPosition, oLauncher:GetPosition())
                        if bDebugMessages == true then LOG(sFunctionRef..': iDistToLauncherFromProjectile='..iDistToLauncherFromProjectile..'; iDistToLauncherFromTarget='..iDistToLauncherFromTarget..'; Is shot blocked='..tostring(M28Logic.IsShotBlocked(oLauncher, tLastOrder[M28Orders.subrefoOrderUnitTarget]) or false)) end
                        if iDistToLauncherFromProjectile < iDistToLauncherFromTarget - 5 then
                            --If we fired a directfire shot would it be blocked?
                            if M28Logic.IsShotBlocked(oLauncher, tLastOrder[M28Orders.subrefoOrderUnitTarget]) then
                                --Shot is blocked
                                local iTargetSegmentX, iTargetSegmentZ = M28Map.GetPathingSegmentFromPosition(tTargetPosition)
                                if not(oLauncher[M28Building.reftbTerrainBlockedTargetsBySegment]) then oLauncher[M28Building.reftbTerrainBlockedTargetsBySegment] = {} end
                                if not(oLauncher[M28Building.reftbTerrainBlockedTargetsBySegment][iTargetSegmentX]) then oLauncher[M28Building.reftbTerrainBlockedTargetsBySegment][iTargetSegmentX] = {} end
                                oLauncher[M28Building.reftbTerrainBlockedTargetsBySegment][iTargetSegmentX][iTargetSegmentZ] = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Recording shots blocked for iTargetSegmentX='..iTargetSegmentX..'Z='..iTargetSegmentZ) end
                            end
                        end
                    end
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        end
    end
end