---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 09:03
---



local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Config = import('/mods/M28AI/lua/M28Config.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
local M28Chat = import('/mods/M28AI/lua/AI/M28Chat.lua')

refiLastWeaponEvent = 'M28LastWep' --Gametimeseconds that last updated onweapon


function OnPlayerDefeated(aiBrain)
    if M28Utilities.bM28AIInGame then
        aiBrain.M28IsDefeated = true

        --Was it an M28AI?
        if aiBrain.M28AI then
            --Give resources to teammates
            local bHaveTeammates = false
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyActiveBrains]) == false then
                for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyActiveBrains] do
                    if not(oBrain == aiBrain) and not(oBrain.M28IsDefeated) and not(oBrain:IsDefeated()) then
                        bHaveTeammates = true
                        break
                    end
                end
            end
            if bHaveTeammates then
                ForkThread(M28Team.GiveAllResourcesToAllies, aiBrain)
            else
                --Send end of game message
                local iRand = math.random(1,3)
                local sEndOfGameMessage
                if iRand == 1 then
                    sEndOfGameMessage = 'gg'
                elseif iRand == 2 then
                    sEndOfGameMessage = 'You may have defeated me, but my older brother M27 will crush you like an insect'
                elseif iRand == 3 then
                    sEndOfGameMessage = ':( Time for me to go back to fighting other bots'
                end
                M28Chat.SendMessage(aiBrain, 'Our ACU Died', sEndOfGameMessage, 3, 60)
            end
        end

        --Update tables tracking the various brains
        ForkThread(M28Team.RefreshActiveBrainListForBrainDeath, aiBrain)
    end
end

function OnACUKilled(oUnit)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnACUKilled'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then
            local oKilledBrain = oUnit:GetAIBrain()
            if oKilledBrain then
                LOG(sFunctionRef..': ACU '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has just died, and its brain is '..oKilledBrain.Nickname)
            else
                LOG(sFunctionRef..': ACU '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has just died, and it doesnt have a brain')
            end
        end
        if ScenarioInfo.Options.Victory == "demoralization" then
            if oUnit:GetAIBrain() then
                if not(oUnit:GetAIBrain().M28IsDefeated) then
                    OnPlayerDefeated(oUnit:GetAIBrain())
                end
            else
                --Possibility that we have already recorded the unit death, so wait 1 second and then if any brains show as defeated but not M28Defeated then run the function
                ForkThread(M28Team.DelayedPlayerDeathCheck)
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnKilled(oUnitKilled, instigator, type, overkillRatio)
    --WARNING: Doesnt trigger when an ACU is killed
    --Will make sure the OnUnitDeath event is called, i.e. this function should only be used where we only want something to run when we killed something, or an enemy killed something of ours

    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnKilled'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        local refbAlreadyRun = 'M28EventsOnKilledRun'
        if not(oUnitKilled[refbAlreadyRun]) then
            oUnitKilled[refbAlreadyRun] = true
            if bDebugMessages == true then LOG(sFunctionRef..': oUnitKilled='..oUnitKilled.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitKilled)..'; Is unit killed an ACU='..tostring(M28Utilities.IsACU(oUnitKilled))..'; GameTime='..GetGameTimeSeconds()) end
            if oUnitKilled.GetAIBrain then
                OnUnitDeath(oUnitKilled) --Ensure this is run when a unit dies

                --were we killed by something?
                local oKillerUnit

                if instigator and not(instigator:BeenDestroyed()) and not(instigator.Dead) then
                    if instigator.GetLauncher and instigator:GetLauncher() then
                        oKillerUnit = instigator:GetLauncher()
                    elseif instigator.DamageData and not(instigator.unit) and not(instigator.UnitId) then
                        --Can get errors for artillery shells when running IsProjectile
                    elseif IsProjectile(instigator) or IsCollisionBeam(instigator) then
                        if instigator.unit then
                            oKillerUnit = instigator.unit
                        end
                    elseif IsUnit(instigator) then
                        oKillerUnit = instigator
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Have an instigator, checking if have valid killer unit. Is valid='..tostring(M28UnitInfo.IsUnitValid(oKillerUnit))) end
                    if oKillerUnit and oKillerUnit.GetAIBrain then

                        --Non-M28 specific killer logic:
                        --T2 arti firebase tracking if they get lots of kills:
                        if oUnitKilled:GetAIBrain().M28AI then
                            if EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oKillerUnit.UnitId) then M28Land.ConsiderIfHaveEnemyFirebase(oUnitKilled:GetAIBrain().M28Team, oKillerUnit) end
                        end

                        --M28 specific killer logic
                        local oKillerBrain = oKillerUnit:GetAIBrain()
                        if oKillerBrain.M28AI then
                            if EntityCategoryContains(M28UnitInfo.refCategorySatellite, instigator.UnitId) and M28UnitInfo.IsUnitValid(oKillerUnit) then
                                ForkThread(M28Air.NovaxCoreTargetLoop, oKillerBrain, instigator, true)
                            end
                        end
                    end
                end
            elseif bDebugMessages == true then LOG(sFunctionRef..': Unit killed doesnt have a brain')
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnPropDestroyed(oProp)
    --Confirmed manually this triggers e.g. if a bomber destroys a rock, and if a tree is reclaimed
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnPropDestroyed'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnYthothaDeath(oUnit)
    --Called when a ythotha (oUnit) is flagged as dying or being killed
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnYthothaDeath'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        local refbYthothaDeath = 'M28EventYthothaDeath'

        if not(oUnit[refbYthothaDeath]) then
            oUnit[refbYthothaDeath] = true
            local tNearbyUnits
            if bDebugMessages == true then LOG(sFunctionRef..': Ythotha has just died, will look for nearby units and tell them to run away') end
            local iTimeToRun
            local iSearchRange = 70
            for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                tNearbyUnits = oBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand, oUnit:GetPosition(), 50, 'Ally')
                if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                    for iFriendlyUnit, oFriendlyUnit in tNearbyUnits do
                        if bDebugMessages == true then LOG(sFunctionRef..': oFriendlyUnit='..oFriendlyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFriendlyUnit)..'; if we own it then will make it run away') end
                        if oFriendlyUnit:GetAIBrain() == oBrain then --Only do this for M28 units
                            if M28UnitInfo.IsUnitValid(oFriendlyUnit, true) then
                                iTimeToRun = math.min(32, math.max(10, 18 + (50 - M28Utilities.GetDistanceBetweenPositions(oFriendlyUnit:GetPosition(), oUnit:GetPosition()) / (oFriendlyUnit:GetBlueprint().Physics.MaxSpeed or 1))))
                                if bDebugMessages == true then LOG(sFunctionRef..': Telling friendly unit '..oFriendlyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFriendlyUnit)..' to move away for 18s via moveawayfromtarget order') end
                                ForkThread(M28Micro.MoveAwayFromTargetTemporarily, oFriendlyUnit, iTimeToRun, oUnit:GetPosition())
                            end
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end


function OnUnitDeath(oUnit)
    --NOTE: This is called by the death of any unit of any player, so careful with what commands are given
        --Some callbacks line onkilled will call this as well to make sure it is run (since for some things like when an ACU is killed it doesnt trigger directly)
    if M28Utilities.bM28AIInGame and M28Map.bMapLandSetupComplete then --No point running on death logic for units at start of the game
        local sFunctionRef = 'OnUnitDeath'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



        if bDebugMessages == true then
            LOG(sFunctionRef..'Hook successful. oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; GameTime='..GetGameTimeSeconds())
            if oUnit.GetAIBrain then LOG(sFunctionRef..': Unit owner='..oUnit:GetAIBrain().Nickname) end
        end
        --Is it an ACU?
        if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
            OnACUKilled(oUnit)
        else
            if oUnit.CachePosition then --Redundancy to check not dealing with a unit, not sure this will actually trigger as looks like wreck deaths are picked up by the prop logic above
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Unit killed has a cache position, will draw in blue around it')
                    M28Utilities.DrawLocation(oUnit.CachePosition, nil, 1, 100, nil)
                end
                ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, oUnit.CachePosition, 0)
            else
                if oUnit.GetAIBrain then
                    --------Non-M28 Specific logic------

                    --TMD protection logic - refresh land zone TMD entries
                    if oUnit[M28Building.refbUnitWantsMoreTMD] then M28Building.UpdateLZUnitsWantingTMDForUnitDeath(oUnit) end

                    --Big threat global team table update
                    if M28Utilities.IsTableEmpty(oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable]) == false then
                        M28Team.RemoveUnitFromBigThreatTable(oUnit)
                    end


                    M28Orders.ClearAnyRepairingUnits(oUnit)

                    --Hydro resource location made available again
                    if EntityCategoryContains(M28UnitInfo.refCategoryHydro, oUnit.UnitId) then
                        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroLocations]) == false then
                            for iHydroLocation, tHydroLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroLocations] do
                                if M28Utilities.GetDistanceBetweenPositions(tHydroLocation, oUnit:GetPosition()) <= 2 then
                                    table.insert(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations], tHydroLocation)
                                    break
                                end
                            end
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                        --Record mex position first as it is a forked thread so may lose position if the unit dies; however ignore if looks like an upgrading mex unit
                        if not(oUnit.CanTakeDamage == false and oUnit.IsUpgrade == true) then
                            local tMexPosition = {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]}
                            if bDebugMessages == true then LOG(sFunctionRef..': About to call OnMexDeath via fork, tMexPosition='..repru(tMexPosition)) end
                            if tMexPosition[1] == 0 and tMexPosition[2] == 0 then M28Utilities.ErrorHandler('Dont have a valid mex position - mex is showing as 0,0,0') end
                            ForkThread(M28Building.OnMexDeath, tMexPosition) --Need to fork thread or else get an error when try to wait in the building logic
                        end
                        --[[local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]) == false then
                            for iMexLocation, tMexLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations] do
                                --Prev line - redid at same time as changing approach for removing an unbuilt location to try and be more accurate
                                --if M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition()) <= 0.9 then
                                --Revised line:
                                if math.abs(tMexLocation[1] - oUnit:GetPosition()[1]) < 0.9 and math.abs(tMexLocation[3] - oUnit:GetPosition()[3]) < 0.9 then
                                    table.insert(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations], tMexLocation)
                                    break
                                end
                            end
                        end--]]
                        --Radar intel coverage update
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryRadar, oUnit.UnitId) then
                        ForkThread(M28Land.UpdateRadarCoverageForDestroyedRadar, oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategorySonar, oUnit.UnitId) then
                        ForkThread(M28Navy.UpdateSonarCoverageForDestroyedSonar, oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryWall, oUnit.UnitId) and not(oUnit:GetAIBrain().M28AI) then
                        M28Land.TrackWallSegment(oUnit, false)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) then
                        --For each M28 team with active M28AI consider if we have a firebase
                        M28Land.ConsiderIfAnyEnemyTeamsStillHaveFirebaseOnT2ArtiDeath(oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryTMD + M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                        if EntityCategoryContains(M28UnitInfo.refCategoryTMD, oUnit.UnitId) then
                            M28Building.TMDDied(oUnit)
                        else
                            M28Building.TMLDied(oUnit)
                        end
                    end
                    --Ythotha deathball avoidance
                    --Note -seraphimunits.lua contains SEnergyBallUnit which looks like it is for when the death ball is spawned; ID is XSL0402; SpawnElectroStorm is in the ythotha script
                    --Sandbox test - have c.36s from ythotha dying to energy ball dying, so want to run away for half of this (18s) plus extra time based on how far away we already were
                    if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental * categories.SERAPHIM, oUnit.UnitId) then
                        OnYthothaDeath(oUnit)
                    end
                    if EntityCategoryContains(categories.STRUCTURE + categories.EXPERIMENTAL, oUnit.UnitId) and (EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) or oUnit:GetFractionComplete() < 1) then
                        M28Engineer.SearchForBuildableLocationsNearDestroyedBuilding(oUnit)
                    end




                    -------M28 specific logic---------
                    --Is the unit owned by M28AI?
                    if oUnit:GetAIBrain().M28AI then
                        --Air units - remove any assigned strike damage
                        if oUnit[M28Air.refoStrikeDamageAssigned] then
                            M28Air.RemoveAssignedAttacker(oUnit[M28Air.refoStrikeDamageAssigned], oUnit)
                        end
                        --Air scout death - record the target zone as dangerous
                        if oUnit[M28Air.reftScoutAssignedPlateauAndZoneRef] then
                            M28Air.OnAirScoutDeath(oUnit)
                        end
                        --Transport death - record target island as dangerous
                        if oUnit[M28Air.refiTargetIslandForDrop] then
                            M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.refiLastFailedIslandDropTime][oUnit[M28Air.refiTargetIslandForDrop]] = GetGameTimeSeconds()
                        end
                        --Logic that doesnt require the unit to ahve finished construction:

                        --Fixed shielding
                        if oUnit[M28Building.refbUnitWantsShielding] or oUnit[M28Building.reftoUnitsCoveredByShield] or oUnit[M28Building.reftoShieldsProvidingCoverage] then
                            if oUnit[M28Building.reftoUnitsCoveredByShield] then
                                M28Building.UpdateShieldCoverageOfUnits(oUnit, true)
                            else
                                M28Building.CheckIfUnitWantsFixedShield(oUnit)
                            end
                        end

                        --Run unit type specific on death logic where the unit is completed
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if need to run certain M28AI on death logic, unit fraction ocmplete='..oUnit:GetFractionComplete()) end
                        if oUnit:GetFractionComplete() == 1 then
                            M28Economy.UpdateGrossIncomeForUnit(oUnit, true)
                            if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                                M28Engineer.ClearEngineerTracking(oUnit)
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryScathis, oUnit.UnitId) then
                                if M28Utilities.IsTableEmpty(M28Engineer.tAllScathis) == false then
                                    for iScathis, oScathis in M28Engineer.tAllScathis do
                                        if oScathis == oUnit then
                                            table.remove(M28Engineer.tAllScathis, iScathis) --Only doing this once so can get away with using table.remove, otherwise would want to use M28Utilities.ArrayRemove
                                            break
                                        end
                                    end
                                end
                            elseif EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                                --Check for upgrades
                                --Upgrade tracking (even if have run this already)
                                if bDebugMessages == true then LOG(sFunctionRef..': Will check if upgrade tracking needs updating, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                M28Team.UpdateUpgradeTrackingOfUnit(oUnit, true)
                                if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                                    M28Economy.UpdateLandZoneM28MexByTechCount(oUnit, true)
                                    --Update upgrading mexes
                                    M28Economy.UpdateTableOfUpgradingMexesForTeam(oUnit:GetAIBrain().M28Team)
                                end
                                M28Economy.UpdateHighestFactoryTechLevelForDestroyedUnit(oUnit) --checks if it was a factory as part of this function
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryMobileLand, oUnit.UnitId) then
                                --If unit was traveling to another land zone, then update that land zone so it no longer things the unit is traveling here
                                M28Land.RemoveUnitFromListOfUnitsTravelingToLandZone(oUnit) --(this will check if it was or not)
                            end

                            --Mobile shield update
                            if oUnit[M28Land.refoAssignedMobileShield] then
                                oUnit[M28Land.refoAssignedMobileShield][M28Land.refoMobileShieldTarget] = nil
                            end
                            if oUnit[M28Land.refoMobileShieldTarget] then
                                oUnit[M28Land.refoMobileShieldTarget][M28Land.refoAssignedMobileShield] = nil
                            end
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnWorkEnd(self, work)
    --Not sure when/if this even triggers - would need to review if plan to use
    --LOG('WOrk end has finished for self='..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self)..'; work reprs='..reprs(work))
end

function OnEnhancementComplete(oUnit, sEnhancement)
    if M28Utilities.bM28AIInGame then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnEnhancementComplete'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': Enhancement completed for self='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; sEnhancement='..reprs(sEnhancement)) end
        M28UnitInfo.UpdateUnitCombatMassRatingForUpgrades(oUnit)
        M28UnitInfo.RecordUnitRange(oUnit) --Refresh the range incase enhancement has increased anything
        --Update ACU upgrade count
        if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
            oUnit[M28ACU.refiUpgradeCount] = (oUnit[M28ACU.refiUpgradeCount] or 0) + 1
        end
        if oUnit:GetAIBrain().M28AI then
            if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                M28ACU.GetUpgradePathForACU(oUnit)
            end
            --Remove any upgrade tracking
            M28Team.UpdateUpgradeTrackingOfUnit(oUnit, true, sEnhancement)
        end
        M28UnitInfo.RecordUnitRange(oUnit)
        if bDebugMessages == true then LOG(sFunctionRef..': Unit DF range after updating recorded range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnShieldBubbleDamaged(self, instigator)
    
end

function OnDamaged(self, instigator) --This doesnt trigger when a shield bubble is damaged - see OnShieldBubbleDamaged for this
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnDamaged'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if self.IsWreckage then
            --Will only update when props and wrecks are destroyed for performance reasons
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Non-wreck damaged') end
            if self.GetUnitId then
                local oUnitCausingDamage
                if instigator and not(instigator:BeenDestroyed()) then
                    if instigator.GetLauncher and instigator:GetLauncher() then
                        oUnitCausingDamage = instigator:GetLauncher()
                    elseif instigator.DamageData and not(instigator.unit) and not(instigator.UnitId) then
                        --Can get errors for artillery shells when running IsProjectile
                    elseif IsProjectile(instigator) or IsCollisionBeam(instigator) then
                        if instigator.unit then
                            oUnitCausingDamage = instigator.unit
                        end
                    elseif IsUnit(instigator) then
                        oUnitCausingDamage = instigator
                    end
                    if bDebugMessages == true then
                        if not(oUnitCausingDamage) then LOG(sFunctionRef..': Dont ahve a valid unit as instigator')
                        else LOG(sFunctionRef..': Have a unit causing damage='..oUnitCausingDamage.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitCausingDamage)) end
                    end
                end

                --Logic specific to M28 units dealing damage
                if M28UnitInfo.IsUnitValid(oUnitCausingDamage) and oUnitCausingDamage:GetAIBrain().M28AI then
                    --T3/experimental arti specific
                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, oUnitCausingDamage.UnitId) then
                        --Reset the arti shot count if damaged a high value unit
                        if M28UnitInfo.IsUnitValid(self) then
                            if bDebugMessages == true then LOG(sFunctionRef..': T3/Exp arti owned by M28 brain '..oUnitCausingDamage:GetAIBrain().Nickname..', arti unit='..oUnitCausingDamage.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitCausingDamage)..' has just damaged unit '..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self)..' which is valid') end
                            local iUnitDamagedMassValue = self:GetBlueprint().Economy.BuildCostMass * self:GetFractionComplete()
                            if iUnitDamagedMassValue >= 700 then
                                --Reduce the ineffective arti shot count
                                local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(self:GetPosition())
                                local tLZOrWZTeamData
                                if iPlateauOrZero > 0 then
                                    tLZOrWZTeamData  = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][oUnitCausingDamage:GetAIBrain().M28Team]
                                else
                                    --Water zone
                                    tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][oUnitCausingDamage:GetAIBrain().M28Team]
                                end
                                local iReductionValue
                                if iUnitDamagedMassValue >= 10000 then
                                    iReductionValue = 50
                                elseif iUnitDamagedMassValue >= 3000 then
                                    iReductionValue = 12
                                else
                                    iReductionValue = 6
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Changing ineffective shot count, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWateZone='..iLandOrWaterZone..'; tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount]='..(tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 'nil')..'; iReductionValue='..iReductionValue) end
                                tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] = math.max(0, (tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 0) - iReductionValue)
                            end
                        end
                    end
                end
            end

        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnBombFired(oWeapon, projectile)
    if M28Utilities.bM28AIInGame then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnBombFired'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
        local oUnit = oWeapon.unit
        if oUnit and oUnit.GetUnitId then
            local sUnitID = oUnit.UnitId
            if bDebugMessages == true then LOG(sFunctionRef..': bomber position when firing bomb='..repru(oUnit:GetPosition())) end
            if EntityCategoryContains(M28UnitInfo.refCategoryBomber + M28UnitInfo.refCategoryTorpBomber, sUnitID) then
                --Try to dodge non-experimental bombs
                if not(EntityCategoryContains(categories.EXPERIMENTAL, sUnitID)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and dodge the bomb fired by unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                    M28Micro.DodgeBomb(oUnit, oWeapon, projectile)
                else
                    --Experimental bomber - micro to turn around and go to rally point
                    if oUnit:GetAIBrain().M28AI then
                        ForkThread(M28Micro.TurnAirUnitAndMoveToTarget, oUnit:GetAIBrain(), oUnit, M28Team.tAirSubteamData[oUnit:GetAIBrain().M28AirSubteam][M28Team.reftAirSubRallyPoint], 15)
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

--WARNING: OnWeaponFired and/or OnProjectilfeFired - one of these (probably the latter) resulted in error messages when t1 arti fired, disabled both of them as dont use now

function OnWeaponFired(oWeapon)
    if M28Utilities.bM28AIInGame then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnWeaponFired'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code; does the weapon have a valid unit='..tostring(M28UnitInfo.IsUnitValid(oWeapon.unit))..'; Weapon unitID='..(oWeapon.unit.UnitId or 'nil')..'; oWeapon[refiLastWeaponEvent]='..(oWeapon[refiLastWeaponEvent] or 'nil')) end

        local oUnit = oWeapon.unit
        if oUnit and oUnit.GetUnitId and oUnit.GetAIBrain then
            if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..' has just fired a shot, Time='..GetGameTimeSeconds()..'; oWeapon[refiLastWeaponEvent]='..(oWeapon[refiLastWeaponEvent] or 'nil')) end
            if not(oWeapon[refiLastWeaponEvent]) or GetGameTimeSeconds() - (oWeapon[refiLastWeaponEvent] or -1) >= 0.5 then
                oWeapon[refiLastWeaponEvent] = GetGameTimeSeconds()
                oUnit[refiLastWeaponEvent] = GetGameTimeSeconds()
                --Update unit last known position/record it
                local oParentBrain = oUnit:GetAIBrain()
                for iTeam, tTeam in M28Team.tTeamData do
                    if not(iTeam == oParentBrain.M28Team) then
                        if M28Utilities.IsTableEmpty(tTeam[M28Team.subreftoFriendlyActiveM28Brains]) == false then
                            for iBrain, oBrain in tTeam[M28Team.subreftoFriendlyActiveM28Brains] do
                                M28Team.ConsiderAssigningUnitToZoneForBrain(oBrain, oUnit) --This function includes check of whether this is an M28 brain, and updates last known position
                                break
                            end
                        end
                    end
                end

                --Consider dodging
                if EntityCategoryContains(M28UnitInfo.refCategoryBomber, oUnit.UnitId) and oWeapon.Label == 'GroundMissile' then
                    --Corsairs dont trigger the onbombfired event normally
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Weapon fired by corsair, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
                        if oWeapon:GetCurrentTarget().GetPosition then LOG(sFunctionRef..': Target of weapon='..repru(oWeapon:GetCurrentTarget():GetPosition())) end
                    end

                    ForkThread(M28Micro.DodgeBomb, oUnit, oWeapon, nil)
                else
                    --Dodge logic for certain other attacks (conditions for this are in considerdodgingshot)
                    if bDebugMessages == true then LOG(sFunctionRef..': Will consider whether we want to dodge the shot') end
                    ForkThread(M28Micro.ConsiderDodgingShot, oUnit, oWeapon)
                end

                --Update overcharge tracking
                if oWeapon.GetBlueprint and oWeapon:GetBlueprint().Overcharge then
                    oUnit[M28UnitInfo.refiTimeOfLastOverchargeShot] = GetGameTimeSeconds()
                    if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and oUnit:GetAIBrain().M28AI then
                        --Get another order immediately rather than waiting (means we dont have to try and queue orders up for ACU logic)
                        M28ACU.GetACUOrder(oUnit:GetAIBrain(), oUnit)
                    end
                end

                --M28 owned unit specific logic
                if oUnit:GetAIBrain().M28AI then
                    --Shot is blocked logic
                    if bDebugMessages == true then LOG(sFunctionRef..': COnsidering if unit shot is blocked Time='..GetGameTimeSeconds()..', range category='..(oWeapon.Blueprint.RangeCategory or 'nil')..'; Is unit a relevant DF category='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE + M28UnitInfo.refCategorySeraphimDestroyer - M28UnitInfo.refCategoryMissileShip, oUnit.UnitId))) end
                    if oWeapon.Blueprint.RangeCategory == 'UWRC_DirectFire' and EntityCategoryContains(M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE + M28UnitInfo.refCategorySeraphimDestroyer - M28UnitInfo.refCategoryMissileShip, oUnit.UnitId) then
                        --Get weapon target if it is a DF weapon
                        local oTarget = oWeapon:GetCurrentTarget()
                        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has just fired a shot. Do we have a valid target for our weapon='..tostring(M28UnitInfo.IsUnitValid(oTarget))..'; time last shot was blocked='..(oUnit[M28UnitInfo.refiTimeOfLastCheck] or 'nil')) end
                        if M28UnitInfo.IsUnitValid(oTarget) then

                            oUnit[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds()
                            oUnit[M28UnitInfo.refbLastShotBlocked] = M28Logic.IsShotBlocked(oUnit, oTarget)
                            if bDebugMessages == true then LOG(sFunctionRef..': oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Is shot blocked='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked])..'; built in blocking terrain result for low profile='..tostring(oUnit:GetAIBrain():CheckBlockingTerrain(oUnit:GetPosition(), oTarget:GetPosition(), 'Low'))..'; High profile='..tostring(oUnit:GetAIBrain():CheckBlockingTerrain(oUnit:GetPosition(), oTarget:GetPosition(), 'High'))) end

                            if oUnit[M28UnitInfo.refbLastShotBlocked] then
                                --Reset after 20s if we havent fired any more shots at the target
                                --function DelayChangeVariable(oVariableOwner, sVariableName, vVariableValue, iDelayInSeconds, sOptionalOwnerConditionRef, iMustBeLessThanThisTimeValue, iMustBeMoreThanThisTimeValue, vMustNotEqualThisValue)
                                M28Utilities.DelayChangeVariable(oUnit, M28UnitInfo.refbLastShotBlocked, false, 20, M28UnitInfo.refiTimeOfLastCheck, GetGameTimeSeconds() + 0.01)
                            end
                        end
                    end
                    --T3 arti targeting logic; TML missile tracking
                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, oUnit.UnitId) then
                        ForkThread(M28Building.GetT3ArtiTarget, oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                        if M28UnitInfo.IsUnitValid(oUnit[M28Building.refoLastTMLTarget]) then
                            oUnit[M28Building.refoLastTMLTarget][M28Building.refiTimeOfLastLaunch] = GetGameTimeSeconds()
                            if bDebugMessages == true then LOG(sFunctionRef..': have set time of last launch to '..oUnit[M28Building.refoLastTMLTarget][M28Building.refiTimeOfLastLaunch]..' for target '..oUnit[M28Building.refoLastTMLTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28Building.refoLastTMLTarget])) end
                        end
                    end
                    --SML, TML and SMD - unpause (if paused)
                    if EntityCategoryContains(M28UnitInfo.refCategorySML + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                        M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, false)
                        --TML and nuke - consider launching missile if have any remaining
                        ForkThread(M28Building.JustFiredMissile, oUnit)
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

    end
end

function OnMissileBuilt(self, weapon)
    if M28Utilities.bM28AIInGame then
        if self.GetAIBrain and self:GetAIBrain().M28AI then
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            local sFunctionRef = 'OnMissileBuilt'
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


            self[M28Building.refbMissileRecentlyBuilt] = true
            M28Utilities.DelayChangeVariable(self, M28Building.refbMissileRecentlyBuilt, false, 5)


            --Pause if we already have 2 missiles
            if bDebugMessages == true then
                if M28UnitInfo.IsUnitValid(self) then
                    LOG(sFunctionRef..': Have valid unit='..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self))
                else
                    LOG(sFunctionRef..': self='..reprs(self))
                end
            end

            local iMissiles = 1 --For some reason the count is off by 1, presumably a slight delay between the event being called and the below ammo counts working
            if self.GetTacticalSiloAmmoCount then iMissiles = iMissiles + self:GetTacticalSiloAmmoCount() end
            if bDebugMessages == true then LOG(sFunctionRef..': iMissiles based on tactical silo ammo='..iMissiles) end
            if self.GetNukeSiloAmmoCount then iMissiles = iMissiles + self:GetNukeSiloAmmoCount() end
            if bDebugMessages == true then LOG(sFunctionRef..': iMissiles after Nuke silo ammo='..iMissiles) end
            if iMissiles >= 1 then
                --Stop assisting units (so can reassess if we still want to assist)
                if M28Utilities.IsTableEmpty(self[M28UnitInfo.reftoUnitsAssistingThis]) == false then
                    local tEngineersToStop = {}
                    for iEngineer, oEngineer in self[M28UnitInfo.reftoUnitsAssistingThis] do
                        table.insert(tEngineersToStop, oEngineer)
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to make engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to stop assisting') end
                    end
                    for iEngineer, oEngineer in tEngineersToStop do
                        if M28UnitInfo.IsUnitValid(oEngineer) then
                            M28Orders.IssueTrackedClearCommands(oEngineer)
                            if bDebugMessages == true then LOG(sFunctionRef..': Just sent a clear order to '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to stop assisting') end
                        end
                    end
                end

                --If 2+ missiles then pause, and consider unpausing later
                if iMissiles >= 2 and not(EntityCategoryContains(categories.EXPERIMENTAL, self.UnitId)) then

                    if bDebugMessages == true then LOG(sFunctionRef..': Have at least 2 missiles so will set paused to true on unit '..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self)) end
                    self:SetPaused(true)
                    if self.SetAutoMode then self:SetAutoMode(false) end

                    --Recheck every minute
                    ForkThread(M28Building.CheckIfWantToBuildAnotherMissile, self)
                end
            end

            if not(EntityCategoryContains(M28UnitInfo.refCategorySMD, self.UnitId)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Calling logic to consider launching a missile') end
                ForkThread(M28Building.ConsiderLaunchingMissile, self, weapon)
            end
        end

    end
end

--[[
function OnProjectileFired(oWeapon, oMuzzle)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OnProjectileFired'
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
    if oWeapon.GetBlueprint then
        LOG('OnWeaponFired hook for blueprint='..repru(oWeapon:GetBlueprint()))
    end
    if oWeapon.unit then
        LOG('Have a unit; unit position='..repru(oWeapon.unit:GetPosition()))
    end
end--]]

function OnConstructionStarted(oEngineer, oConstruction, sOrder)
    if M28Utilities.bM28AIInGame then
        --Update land zone queued orders
        if M28Utilities.IsTableEmpty(oEngineer[M28Engineer.reftQueuedBuildings]) == false then
            M28Engineer.RemoveBuildingFromQueuedBuildings(oEngineer, oConstruction)
        end

        --Record any mexes so we can repair them if construction gets interrupted
        if oEngineer:GetAIBrain().M28AI then
            --Track experimental construction and other special on construction logic
            if oConstruction.GetUnitId and not(oConstruction[M28UnitInfo.refbConstructionStart]) then
                local sFunctionRef = 'OnConstructionStarted'
                local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

                oConstruction[M28UnitInfo.refbConstructionStart] = true
                if EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oConstruction.UnitId) then
                    M28Engineer.RecordPartBuiltMex(oEngineer, oConstruction)
                end

                --Decide if want to shield this construction and update buildable location
                if EntityCategoryContains(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryExperimentalStructure, oConstruction.UnitId) then
                    M28Building.CheckIfUnitWantsFixedShield(oConstruction, true)
                    --If this is a fixed shield then instead update shield coverage
                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oConstruction.UnitId) then
                        M28Building.UpdateShieldCoverageOfUnits(oConstruction, false)
                    end

                    --Buildable locations - update for unit construction started
                    if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oConstruction.UnitId) then
                        ForkThread(M28Engineer.CheckIfBuildableLocationsNearPositionStillValid, oEngineer:GetAIBrain(), oConstruction:GetPosition())
                    end
                    --Both structures and experimentals - clear any engineers trying to build something else that will be blocked by this
                    ForkThread(M28Engineer.ClearEngineersWhoseTargetIsNowBlockedByUnitConstructionStarted, oEngineer, oConstruction)
                end

                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            end
        end
    end
end

function OnConstructed(oEngineer, oJustBuilt)
    --WARNING: This doesnt seem to trigger for the ACU; it does trigger when untis are constructed by a factory

    --NOTE: This is called every time an engineer stops building a unit whose fractioncomplete is 100%, so can be called multiple times
    if M28Utilities.bM28AIInGame then
        --NonM28 specific - dont set the M28OnConstructionCalled for this, so need to  be careful that any code here will not be run repeatedly
        --LOG('OnConstructed at time '..GetGameTimeSeconds()..' for unit '..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..' owned by brain '..oJustBuilt:GetAIBrain().Nickname..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; M28Map.bMapLandSetupComplete='..tostring(M28Map.bMapLandSetupComplete or false))
        if not(M28Map.bMapLandSetupComplete) then
            local iWaitCount = 0
            local bDontCallAgain = false
            while not(M28Map.bMapLandSetupComplete) do
                WaitTicks(1)
                iWaitCount = iWaitCount + 1
                if iWaitCount >= 300 then
                    M28Utilities.ErrorHandler('Waited more than 5m for map setup to complete, something has gone wrong')
                    bDontCallAgain = true
                    break
                end
            end
            if not(bDontCallAgain) and M28UnitInfo.IsUnitalid(oJustBuilt) then
                OnConstructed(oEngineer, oJustBuilt)
            end
        else
            M28Orders.ClearAnyRepairingUnits(oJustBuilt)

            if EntityCategoryContains(categories.STRUCTURE, oJustBuilt.UnitId) then
                --If a building has just build a building, then make sure all M28 are aware of it (since a player would be)
                if EntityCategoryContains(categories.STRUCTURE, oEngineer.UnitId) then
                    local tTeamsUpdated = {}
                    for iBrain, oBrain in M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subreftoEnemyBrains] do
                        if oBrain.M28AI and not(tTeamsUpdated[oBrain.M28Team]) then
                            tTeamsUpdated[oBrain.M28Team] = true
                            M28Team.AssignUnitToLandZoneOrPond(oBrain, oJustBuilt, false, false, true)
                        end
                    end
                end
                --Also update the name
                if M28Config.M28ShowUnitNames then
                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oJustBuilt:GetPosition(), false)

                    local sWZOrLZRef = ''
                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oJustBuilt:GetPosition())
                    local iWaterZone
                    if (iLandZone or 0) == 0 then
                        iWaterZone = M28Map.GetWaterZoneFromPosition(oJustBuilt:GetPosition())
                        if (iWaterZone or 0) > 0 then
                            sWZOrLZRef = 'WZ'..iWaterZone
                        end
                    else
                        sWZOrLZRef = ':P='..(iPlateau or 0)..'LZ='..(iLandZone or 0)
                    end

                    if M28Config.M28ShowUnitNames then oJustBuilt:SetCustomName(oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..sWZOrLZRef..': Built') end
                end

                --If we have just built a radar then update radar logic
                if EntityCategoryContains(M28UnitInfo.refCategoryRadar, oJustBuilt.UnitId) then
                    ForkThread(M28Land.UpdateZoneIntelForRadar, oJustBuilt)
                elseif EntityCategoryContains(M28UnitInfo.refCategorySonar, oJustBuilt.UnitId) then
                    ForkThread(M28Navy.UpdateZoneIntelForSonar, oJustBuilt)
                end

                --Track non-M28AI wall segments
                if EntityCategoryContains(M28UnitInfo.refCategoryWall, oJustBuilt.UnitId) and not(oJustBuilt:GetAIBrain().M28AI) then
                    M28Land.TrackWallSegment(oJustBuilt, true)
                end


            end

            --M28 specific
            if oJustBuilt:GetAIBrain().M28AI and not(oJustBuilt.M28OnConstructedCalled) then
                local sFunctionRef = 'OnConstructed'
                local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                oJustBuilt.M28OnConstructedCalled = true
                if bDebugMessages == true then LOG(sFunctionRef..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just built '..oJustBuilt.UnitId) end

                --Logic based on the unit that was just built:

                --Check build locations for units not built at a factory
                if EntityCategoryContains(categories.STRUCTURE + categories.EXPERIMENTAL, oJustBuilt.UnitId) then
                    M28Engineer.CheckIfBuildableLocationsNearPositionStillValid(oJustBuilt:GetAIBrain(), oJustBuilt:GetPosition())
                    M28Economy.UpdateHighestFactoryTechLevelForBuiltUnit(oJustBuilt) --includes a check to see if are dealing with a factory HQ
                    if EntityCategoryContains(M28UnitInfo.refCategoryMex, oJustBuilt.UnitId) then
                        M28Team.tTeamData[oJustBuilt:GetAIBrain().M28Team][M28Team.refiUpgradedMexCount] = (M28Team.tTeamData[oJustBuilt:GetAIBrain().M28Team][M28Team.refiUpgradedMexCount] or 0) + 1
                        ForkThread(M28Economy.UpdateLandZoneM28MexByTechCount, oJustBuilt, false, 10)
                        --If have storage owned by M28 on same team by this mex, gift it over
                        --All mexes - on construction check if we have allied M28 mass storage nearby (e.g. we have rebuilt on a mex that they used to have) and if so then have that M28 gift over their mass storage
                        local tMexLocation = oJustBuilt:GetPosition()
                        local rSearchRectangle = M28Utilities.GetRectAroundLocation(tMexLocation, 2.749)
                        local tNearbyUnits = GetUnitsInRect(rSearchRectangle) --at 1.5 end up with storage thats not adjacent being gifted in some cases but not in others; at 1 none of it gets gifted; the mass storage should be exactly 2 from the mex; however even at 2.1, 2.25 and 2.499 had cases where the mex wasnt identified so will try 2.75 since distances can vary/be snapped to the nearest 0.5 I think
                        if bDebugMessages == true then LOG(sFunctionRef..': Storage gifting where built mex - oJustBuilt='..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; owner='..oJustBuilt:GetAIBrain().Nickname..'; is tNearbyUnits empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnits))) end
                        if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                            local tNearbyStorage = EntityCategoryFilterDown(M28UnitInfo.refCategoryMassStorage, tNearbyUnits)
                            if M28Utilities.IsTableEmpty(tNearbyStorage) == false then
                                for iUnit, oUnit in tNearbyStorage do
                                    if bDebugMessages == true then LOG(sFunctionRef..': About to transfer '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from brain '..oUnit:GetAIBrain().Nickname..' to '..oJustBuilt:GetAIBrain().Nickname..'; Dist from unit to tMexLocation='..M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition())) end
                                    if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMexLocation) <= 2.25 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and gift the storage to the player that built the mex') end
                                        M28Team.TransferUnitsToPlayer({oUnit}, oJustBuilt:GetAIBrain():GetArmyIndex(), false)
                                    end
                                end
                            end
                        end
                        --Update part built t1 mex tracking
                        if EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oJustBuilt.UnitId) then
                            M28Engineer.UpdatePartBuiltListForCompletedMex(oJustBuilt)
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMassStorage, oJustBuilt.UnitId) then
                        --If just built a mass storage but we dont own the mex it is adjacent to, then gift the storage
                        local rSearchRectangle = M28Utilities.GetRectAroundLocation(oJustBuilt:GetPosition(), 2.749)
                        local tNearbyUnits = GetUnitsInRect(rSearchRectangle) --at 1.5 end up with storage thats not adjacent being gifted in some cases but not in others; at 1 none of it gets gifted; the mass storage should be exactly 2 from the mex; however even at 2.1, 2.25 and 2.499 had cases where the mex wasnt identified so will try 2.75 since distances can vary/be snapped to the nearest 0.5 I think
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Storage gifting where built storage - oJustBuilt='..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; owner='..oJustBuilt:GetAIBrain().Nickname..'; is tNearbyUnits empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnits)))
                            if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                                for iUnit, oUnit in tNearbyUnits do
                                    LOG(sFunctionRef..': iUnit '..iUnit..' in tNearbyUnits='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; owner='..oUnit:GetAIBrain().Nickname)
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                            local tNearbyMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tNearbyUnits)
                            if M28Utilities.IsTableEmpty(tNearbyMexes) == false then
                                local bHaveMexWeOwnNearby = false
                                local oBrainToTransferToIfWeOwnNoMexes
                                for iUnit, oUnit in tNearbyMexes do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering nearby unit oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname) end
                                    if oUnit:GetAIBrain() == oJustBuilt:GetAIBrain() then
                                        bHaveMexWeOwnNearby = true
                                    elseif oUnit:GetAIBrain().M28Team == oJustBuilt:GetAIBrain().M28Team then
                                        oBrainToTransferToIfWeOwnNoMexes = oUnit:GetAIBrain()
                                    end
                                end
                                if not(bHaveMexWeOwnNearby) and oBrainToTransferToIfWeOwnNoMexes then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and gift the storage to the player who owns the mex already there') end
                                    M28Team.TransferUnitsToPlayer({oJustBuilt}, oBrainToTransferToIfWeOwnNoMexes:GetArmyIndex(), false)
                                end
                            end
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryEnergyStorage, oJustBuilt.UnitId) then
                        M28Team.TeamEconomyRefresh(oJustBuilt:GetAIBrain().M28Team)
                        M28Team.ConsiderGiftingStorageToTeammate(oJustBuilt)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oJustBuilt.UnitId) then
                        --Clear the desire to build land facs by mexes - i.e. only want hte first one to be built as such
                        if bDebugMessages == true then LOG(sFunctionRef..': Have just build land factory so clearing adjacency desire for all M28 brains') end
                        M28Engineer.tiActionAdjacentCategory[M28Engineer.refActionBuildLandFactory] = nil
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, oJustBuilt.UnitId) then
                        ForkThread(M28Building.GetT3ArtiTarget, oJustBuilt)
                    end
                    --Clear engineers that just built this

                elseif EntityCategoryContains(M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryIndirectT3, oJustBuilt.UnitId) then
                    if not(M28Team.tTeamData[oJustBuilt:GetAIBrain().M28Team][M28Team.refbBuiltLotsOfT3Combat]) then
                        if M28Conditions.GetTeamLifetimeBuildCount(oJustBuilt:GetAIBrain().M28Team, M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryIndirectT3) >= 30 then
                            M28Team.tTeamData[oJustBuilt:GetAIBrain().M28Team][M28Team.refbBuiltLotsOfT3Combat] = true
                        end
                    end
                elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer * categories.TECH3, oJustBuilt.UnitId) then
                    --Late game - destroy lower tech engineers to help with pathing (up to 2 for every T3 engi built)
                    ForkThread(M28Engineer.ConsiderDestroyingLowTechEngineers, oJustBuilt)
                elseif EntityCategoryContains(categories.MOBILE * categories.SUBMERSIBLE, oJustBuilt.UnitId) then
                    ForkThread(M28Navy.DelayedCheckIfShouldSubmerge, oJustBuilt)
                end

                --Update economy tracking (this function will check if it is an economic unit as part of it)
                M28Economy.UpdateGrossIncomeForUnit(oJustBuilt)
                if EntityCategoryContains(M28UnitInfo.refCategoryScathis, oJustBuilt.UnitId) then
                    table.insert(M28Engineer.tAllScathis, oJustBuilt)
                end

                --Logic based on the engineer
                if EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then
                    M28ACU.GetACUOrder(oEngineer:GetAIBrain(), oEngineer)
                elseif EntityCategoryContains(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryQuantumGateway, oEngineer.UnitId) then
                    if bDebugMessages == true then LOG(sFunctionRef..': A factory has just built a unit so will get the next order for the factory') end
                    ForkThread(M28Factory.DecideAndBuildUnitForFactory, oEngineer:GetAIBrain(), oEngineer)
                elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oEngineer.UnitId) then
                    --Clear any engineers trying to build this unit if we just built a building or experimental
                    if EntityCategoryContains(categories.STRUCTURE + categories.EXPERIMENTAL, oJustBuilt.UnitId) then
                        M28Engineer.ClearEngineersForUnitJustBuilt(oEngineer, oJustBuilt)
                    end
                end

                --Logic based on the type of unit built
                if EntityCategoryContains(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryQuantumGateway, oJustBuilt.UnitId) then
                    if bDebugMessages == true then LOG(sFunctionRef..': A factory has just been built so will get the next order for the factory') end
                    ForkThread(M28Factory.DecideAndBuildUnitForFactory, oJustBuilt:GetAIBrain(), oJustBuilt)
                    if EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oJustBuilt.UnitId) then
                        oJustBuilt:GetAIBrain()[M28Economy.refiOurHighestFactoryTechLevel] = math.max(M28UnitInfo.GetUnitTechLevel(oJustBuilt), oJustBuilt:GetAIBrain()[M28Economy.refiOurHighestFactoryTechLevel])
                    end
                elseif EntityCategoryContains(categories.STEALTH, oJustBuilt.UnitId) then
                    --Make sure stealth is enabled
                    M28UnitInfo.EnableUnitStealth(oJustBuilt)
                end

                --Mobile land units - give a micro move order so they dont block the factory
                if EntityCategoryContains(M28UnitInfo.refCategoryMobileLand, oJustBuilt.UnitId) then
                    ForkThread(M28Micro.MoveAwayFromFactory, oJustBuilt, oEngineer)
                end

                --Unit cap - refresh if are within 25 of the cap since it isnt accurate if have current units
                if M28UnitInfo.IsUnitValid(oJustBuilt) and oJustBuilt:GetAIBrain()[M28Overseer.refbCloseToUnitCap] and oJustBuilt:GetAIBrain()[M28Overseer.refiExpectedRemainingCap] <= 25 then
                    M28Overseer.CheckUnitCap(oJustBuilt:GetAIBrain())
                end

                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            elseif not(oJustBuilt:GetAIBrain().M28AI) then
                --If build an M28 unit then will record its plateau and LZ; so for non-M28 AI also want to do this so we have a backup for pathfinding if dont already have something
                if M28Utilities.IsTableEmpty(oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) and not(EntityCategoryContains(categories.AIR, oJustBuilt.UnitId)) then
                    local iPlateau, iLandZone = M28Map.GetPathingOverridePlateauAndLandZone(oJustBuilt:GetPosition(), true, oJustBuilt)
                    if not(oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) then oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] = {} end
                    oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][oJustBuilt:GetAIBrain().M28Team] = {iPlateau, iLandZone}
                    if iPlateau and not(iLandZone) then
                        --May be on water
                        local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(oJustBuilt:GetPosition())
                        local iWaterZone = M28Map.tWaterZoneBySegment[iSegmentX][iSegmentZ]
                        if iWaterZone then
                            if not(oJustBuilt[M28UnitInfo.reftAssignedWaterZoneByTeam]) then oJustBuilt[M28UnitInfo.reftAssignedWaterZoneByTeam] = {} end
                            oJustBuilt[M28UnitInfo.reftAssignedWaterZoneByTeam][oJustBuilt:GetAIBrain().M28Team] = iWaterZone
                        end
                    end
                    --[[if (iPlateau or 0) > 0 then
                        if not(oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) then oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] = {} end
                        oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][oJustBuilt:GetAIBrain().M28Team] = {iPlateau, iLandZone}
                    end--]]
                end

            end
            --Upgrade tracking (even if have run this already)
            if oEngineer.GetAIBrain and EntityCategoryContains(categories.STRUCTURE, oEngineer.UnitId) and EntityCategoryContains(categories.STRUCTURE, oJustBuilt.UnitId) then
                if oJustBuilt:GetAIBrain().M28AI or (M28UnitInfo.IsUnitValid(oEngineer) and oEngineer:GetAIBrain().M28AI) then
                    M28Team.UpdateUpgradeTrackingOfUnit(oJustBuilt, true)
                end
            end
        end
    end
end

function OnReclaimStarted(oEngineer, oReclaim)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnReclaimStarted'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnReclaimFinished(oEngineer, oReclaim)
    if M28Utilities.bM28AIInGame then
        --Update the segment that the reclaim is at, or the engineer if hte reclaim doesnt have one
        local sFunctionRef = 'OnReclaimFinished'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just finished reclaiming, gametime='..GetGameTimeSeconds()) end
        if oReclaim and oReclaim.CachePosition then
            --LOG('OnReclaimFinished temp log - remove once confirmed this works - about to update reclaim data near location='..repru(oReclaim.CachePosition))
            ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, oReclaim.CachePosition, 0)
        else
            --LOG('OnReclaimFinished alt temp log - couldnt find reclaim position so will use engineer position')
            ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, oEngineer:GetPosition(), 1)
        end

        --Was the engineer reclaiming an area? if so check if still nearby reclaim
        if oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionReclaimArea then
            --Only keep reclaiming if we dont have lots of mass
            if M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subrefiTeamLowestMassPercentStored] <= 0.7 then
                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
                if (iLandZone or 0) > 0 then
                    local iTeam =  oEngineer:GetAIBrain().M28Team
                    local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                    M28Engineer.GetEngineerToReclaimNearbyArea(oEngineer, nil, tLZTeamData, iPlateau, iLandZone, M28Conditions.WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone), false)
                end
            end
        elseif M28Utilities.IsTableEmpty(oReclaim[M28Engineer.reftUnitsReclaimingUs]) == false then
            local tEngineersToClear = {}
            for iEngineer, oEngineer in oReclaim[M28Engineer.reftUnitsReclaimingUs] do
                if M28UnitInfo.IsUnitValid(oEngineer) then
                    table.insert(tEngineersToClear, oEngineer)
                end
            end
            for iEngineer, oEngineer in tEngineersToClear do
                M28Orders.IssueTrackedClearCommands(oEngineer)
            end
        end

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnCreateWreck(tPosition, iMass, iEnergy)
    --Dont check if M28brains are in game yet as can be called at start of game before we have recorded any aiBrain
    if M28Utilities.bM28AIInGame then
        if not(M28Map.bReclaimManagerActive) then
            if GetGameTimeSeconds() >= 20 then return nil
            else
                local iWaitCount = 0
                while not(M28Map.bReclaimManagerActive) do
                    WaitTicks(1)
                    iWaitCount = iWaitCount + 1
                    if iWaitCount >= 20 then M28Utilities.ErrorHandler('Map setup not complete') break end
                end
            end
        end
        --[[if iMass >= 35 then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tPosition)
            local iReclaimSegmentX, iReclaimSegmentZ = M28Map.GetReclaimSegmentsFromLocation(tPosition)
            LOG('OnCreateWreck: Time='..GetGameTimeSeconds()..'; iMass='..iMass..'; tPosition='..repru(tPosition)..'; will record we want to update reclaim at this location, iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iReclaimSegmentX='..iReclaimSegmentX..'; iReclaimSegmentZ='..iReclaimSegmentZ)
        end--]]
        ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, tPosition, 0)
    end
end

function OnTransportLoad(oUnit, oTransport, bone)
    if M28Utilities.bM28AIInGame then
        local aiBrain = oTransport:GetAIBrain()
        if aiBrain.M28AI then
            --Reduce engis wanted (in case of delay between this being updated and engineer logic running)
            if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryTransport, oTransport.UnitId) then
                if oTransport[M28Air.refiEngisWanted] then
                    oTransport[M28Air.refiEngisWanted] = math.max(0, oTransport[M28Air.refiEngisWanted] - 1)
                end
            end
        end
    end
end

function OnTransportUnload(oUnit, oTransport, bone)

end

function OnDetectedBy(oUnitDetected, iBrainIndex)
    --Appears to be called when iBrainIndex detects oUnitDetected, triggers for teammate units but not own units?

    --For now used to make sure we have up to date unit info
    if M28Utilities.bM28AIInGame then
        local aiBrain = ArmyBrains[iBrainIndex]
        --LOG('OnDetectedBy: UnitID='..oUnitDetected.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitDetected)..'; tAllAIBrainsByArmyIndex[iBrainIndex] name='..M28Overseer.tAllAIBrainsByArmyIndex[iBrainIndex].Nickname..'; ArmyBrains nickname='..ArmyBrains[iBrainIndex].Nickname..'; Does entity contain navy='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnitDetected.UnitId))..'; aiBrain.M28AI='..tostring((aiBrain.M28AI or false)))
        M28Team.ConsiderAssigningUnitToZoneForBrain(aiBrain, oUnitDetected) --This function includes check of whether this is an M28 brain, and updates last known position
        if aiBrain.M28AI then
            --Update highest enemy ground unti health
            if EntityCategoryContains(M28UnitInfo.refCategoryLandCombat - categories.COMMAND - categories.SUBCOMMANDER - M28UnitInfo.refCategoryLandScout, oUnitDetected.UnitId) then
                local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnitDetected)
                local iMaxHealth = oUnitDetected:GetMaxHealth() + iMaxShield
                if iMaxHealth > (M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyHighestMobileLandHealth] or 0) and M28Map.bMapLandSetupComplete then
                    M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyHighestMobileLandHealth] = iMaxHealth
                end
            end
        end
    end
end

function OnCreate(oUnit)
    if M28Utilities.bM28AIInGame and M28UnitInfo.IsUnitValid(oUnit) then
        local sFunctionRef = 'OnCreate'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time'..GetGameTimeSeconds()..'; oUnit[M28OnCrRn]='..tostring(oUnit['M28OnCrRn'] or false)..'; M28Map.bMapLandSetupComplete='..tostring(M28Map.bMapLandSetupComplete or false)..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
        if not(M28Map.bMapLandSetupComplete) then --Start of game ACU creation happens before we have setup the map
            while not(M28Map.bMapLandSetupComplete) do
                WaitTicks(1)
            end
            WaitTicks(1)
            if M28UnitInfo.IsUnitValid(oUnit) then OnCreate(oUnit) end
        else
            if not(oUnit['M28OnCrRn']) then
                oUnit['M28OnCrRn'] = true
                M28UnitInfo.GetUnitLifetimeCount(oUnit) --essential so lifetimecount logic works

                M28Team.ConsiderAssigningUnitToZoneForBrain(oUnit:GetAIBrain(), oUnit) --This function includes check of whether this is an M28 brain

                --All units (not just M28 specific):
                M28UnitInfo.RecordUnitRange(oUnit)
                if bDebugMessages == true then LOG(sFunctionRef..': Just recorded unit ranges for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')) end
                if M28Config.M28ShowEnemyUnitNames then
                    local sWZOrLZRef = ''
                    if EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                        local iWaterZone
                        if (iLandZone or 0) == 0 then
                            iWaterZone = M28Map.GetWaterZoneFromPosition(oUnit:GetPosition())
                            if (iWaterZone or 0) > 0 then
                                sWZOrLZRef = 'WZ'..iWaterZone
                            end
                        else
                            sWZOrLZRef = 'LZ'..iLandZone
                        end
                    end
                    if M28Config.M28ShowUnitNames then oUnit:SetCustomName(oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..sWZOrLZRef) end
                end
                --Units with upgrade - update the base threat value
                if EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oUnit.UnitId) then M28UnitInfo.UpdateUnitCombatMassRatingForUpgrades(oUnit) end --Will check if unit has enhancements as part of this

                --Hydro resource locations
                if EntityCategoryContains(M28UnitInfo.refCategoryHydro, oUnit.UnitId) then
                    --Treat location as no longer having no buildings on it
                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations]) == false then
                        --LOG('About to loop through hydro locations; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; reprs='..reprs(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations]))
                        for iHydroLocation, tHydroLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations] do
                            if M28Utilities.GetDistanceBetweenPositions(tHydroLocation, oUnit:GetPosition()) <= 2 then
                                table.remove(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations], iHydroLocation)
                                break
                            end
                        end
                    end
                elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                    --Treat location as having buildings on it (if we were treating it as unbuilt previously)
                    ForkThread(M28Building.OnMexConstructionStarted, oUnit)
                elseif EntityCategoryContains(M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                    M28Building.RecordUnitsInRangeOfTMLAndAnyTMDProtection(oUnit, nil)
                elseif EntityCategoryContains(M28UnitInfo.refCategoryTMD, oUnit.UnitId) then
                    M28Building.TMDJustBuilt(oUnit)
                end
                if EntityCategoryContains(M28UnitInfo.refCategoryProtectFromTML, oUnit.UnitId) then
                    M28Building.RecordTMLAndTMDForUnitJustBuilt(oUnit)
                end
            end

            --M28 specific:


            if oUnit:GetAIBrain().M28AI then
                --Cover units transferred to us or cheated in or presumably that we have captured - will leave outside the OnCreate flag above in case the oncreate variable transfers over when a unit is captured/gifted
                if oUnit:GetFractionComplete() == 1 then
                    M28Economy.UpdateHighestFactoryTechLevelForBuiltUnit(oUnit) --this includes a check to see if are dealing with a factory HQ
                    M28Economy.UpdateGrossIncomeForUnit(oUnit, false) --This both includes a check of the unit type, and cehcks we havent already recorded
                    if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) and not(oUnit.M28OnConstructedCalled) then
                        ForkThread(M28Economy.UpdateLandZoneM28MexByTechCount, oUnit) --we run the same logic via onconstructed
                    end
                end
                --General logic that want to make sure runs on M28 units even if theyre not constructed yet or to ensure we cover scenarios where we are gifted units
                local aiBrain = oUnit:GetAIBrain()
                if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnit.UnitId) then
                    M28Air.AddPriorityAirDefenceTarget(oUnit)
                    --WEAPON PRIORITIES
                elseif EntityCategoryContains(M28UnitInfo.refCategoryGunship, oUnit.UnitId) then
                    M28UnitInfo.SetUnitTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityGunship, true)
                elseif EntityCategoryContains(M28UnitInfo.refCategoryDestroyer, oUnit.UnitId) then
                    M28UnitInfo.SetUnitTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityDestroyer, true)
                elseif EntityCategoryContains(M28UnitInfo.refCategoryMissileShip + M28UnitInfo.refCategoryCruiser, oUnit.UnitId) then
                    M28UnitInfo.SetUnitTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityMissileShip, true)
                elseif EntityCategoryContains(M28UnitInfo.refCategoryBattleship, oUnit.UnitId) then
                    M28UnitInfo.SetUnitTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityBattleShip, true)
                elseif EntityCategoryContains(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryQuantumGateway, oUnit.UnitId) then
                    --If have been gifted factory or created via cheat then want to start building something
                    if oUnit:GetFractionComplete() >= 1 then
                        ForkThread(M28Factory.DecideAndBuildUnitForFactory, oUnit:GetAIBrain(), oUnit)
                    end

                end
                --Check unit cap
                if (oUnit[M28Overseer.refiExpectedRemainingCap] or 0) <= 100 then
                    M28Overseer.CheckUnitCap(aiBrain)
                else
                    oUnit[M28Overseer.refiExpectedRemainingCap] = oUnit[M28Overseer.refiExpectedRemainingCap] - 1
                end
            end
        end
    end
end

function OnCreateBrain(aiBrain, planName, bIsHuman)
    local sFunctionRef = 'OnCreateBrain'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': aiBrain has just been created at time '..GetGameTimeSeconds()..'; Brain nickname='..(aiBrain.Nickname or 'nil')..'; Has setup been run='..tostring(aiBrain['M28BrainSetupRun'] or false)..'; Brain type='..(aiBrain.BrainType or 'nil')..'; M28Team (if brain setup)='..(aiBrain.M28Team or 'nil')..'; aiBrain.Civilian='..tostring(aiBrain.Civilian or false)) end
    if not(aiBrain['M28BrainSetupRun']) then
        if M28Config.M28RunProfiling then ForkThread(M28Profiler.ProfilerActualTimePerTick) end
        if bIsHuman == nil then
            if aiBrain.BrainType == "AI" or not(aiBrain.BrainType) or string.find(aiBrain.BrainType, "AI") then bIsHuman = false else bIsHuman = true end
        end
        if not(bIsHuman) and (ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28ai' or ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28aicheat') then
            aiBrain.M28AI = true
            M28Utilities.bM28AIInGame = true
        end

        aiBrain['M28BrainSetupRun'] = true
        --Make sure we have checked if this is a scenario map (run for each AI to be safe since minimal load and ensures this happens ahead of any other M28 code)
        M28Overseer.CheckIfScenarioMap()
        if bDebugMessages == true then LOG(sFunctionRef..': M28Map.bIsCampaignMap='..tostring(M28Map.bIsCampaignMap or false)) end

        --Logic to run for all brains
        local iStartPositionX, iStartPositionZ = aiBrain:GetArmyStartPos()
        M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()] = {iStartPositionX, GetSurfaceHeight(iStartPositionX, iStartPositionZ), iStartPositionZ}
        M28Overseer.tAllAIBrainsByArmyIndex[aiBrain:GetArmyIndex()] = aiBrain

        if bIsHuman then
            LOG('Human player brain '..aiBrain.Nickname..' created; Index='..aiBrain:GetArmyIndex()..'; start position='..repru(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()]))
        else
            --Logic to run just for M28AI
            LOG('OnCreateBrain hook for ai with personality '..ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality)

            if aiBrain.M28AI then
                LOG('M28 brain created')

                --Copy of parts of aiBrain OnCreateAI that still want to retain
                aiBrain:CreateBrainShared(planName)
                --aiBrain:InitializeEconomyState()
                aiBrain.BrainType = 'AI'
                local per = ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality
                local cheatPos = string.find(per, 'cheat')
                if cheatPos then

                    local AIUtils = import('/lua/ai/aiutilities.lua')
                    AIUtils.SetupCheat(aiBrain, true)
                    ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality = string.sub(per, 1, cheatPos - 1)
                end

                --M28AIBrainClass.OnCreateAI(aiBrain, planName)
                ForkThread(M28Overseer.M28BrainCreated, aiBrain)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function OnMissileImpactTerrain(self, target, position)
    --Was this an M28 unit?
    if M28UnitInfo.IsUnitValid(self) and self:GetAIBrain().M28AI then
        local sFunctionRef = 'OnMissileImpactTerrain'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        local tLastOrder = self[M28Orders.reftiLastOrders][self[M28Orders.refiOrderCount]]
        if bDebugMessages == true then LOG(sFunctionRef..': self='..(self.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(self) or 'nil')..'; target='..reprs(target)..'; position='..repru(position)..'; tLastOrder='..reprs(tLastOrder)..'; self[M28Building.refiLastTMLMassKills]='..(self[M28Building.refiLastTMLMassKills] or 'nil')..'; Acual XP='..(self.VetExperience or self.Sync.totalMassKilled or 0)) end
        if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueTMLMissile or M28Utilities.IsTableEmpty(target) == false then
            --Did we not gain any mass kills (e.g. mightve hit the ground deliberately for aoe)
            if (self[M28Building.refiLastTMLMassKills] or 0) == (self.VetExperience or self.Sync.totalMassKilled or 0) then
                if not(self[M28Building.reftTerrainBlockedTargets]) then self[M28Building.reftTerrainBlockedTargets] = {} end
                local tLastTarget = tLastOrder[M28Orders.subreftOrderPosition]

                if M28Utilities.IsTableEmpty(tLastTarget) == false then table.insert(self[M28Building.reftTerrainBlockedTargets], {tLastTarget[1], tLastTarget[2], tLastTarget[3]}) end
                if M28Utilities.IsTableEmpty(tLastTarget) or M28Utilities.GetDistanceBetweenPositions(tLastTarget, target) >= 1 then table.insert(self[M28Building.reftTerrainBlockedTargets], {target[1], target[2], target[3]}) end
                if bDebugMessages == true then LOG(sFunctionRef..': Added locations to blackist, repru of blacklist='..repru(self[M28Building.reftTerrainBlockedTargets])) end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnPlayableAreaChange(rect, voFlag)
    M28Map.SetupPlayableAreaAndSegmentSizes()
end

function ObjectiveAdded(Type, Complete, Title, Description, ActionImage, Target, IsLoading, loadedTag)
    local sFunctionRef = 'ObjectiveAdded'
    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Wait until map setup complete
    if false then
        while not(M28Map.bMapLandSetupComplete) or not(M28Map.bWaterZoneInitialCreation) do
            if GetGameTimeSeconds() >= 10 then break end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end



        --Record capture missions
        if bDebugMessages == true then LOG('Have a mission, Title='..Title..'; Description='..Description..'; Target.captured='..(Target.captured or 'nil')) end
        if Target.captured == 0 then
            if bDebugMessages == true then  LOG('Have a capture mission, is target empty='..tostring(M28Utilities.IsTableEmpty(Target))) end
            --Record every unit to be captured
            if M28Utilities.IsTableEmpty(Target.Units) == false then
                local iPlateauOrZero, iLandOrWaterZone
                for iEntry, oUnit in Target.Units do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..' in Target; Is valid unit='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                        local tLZOrWZData
                        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; Unit position='..repru(oUnit)) end
                        if iLandOrWaterZone > 0 then
                            if iPlateauOrZero == 0 then
                                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                            else
                                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                            end
                            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subreftoUnitsToCapture]) then tLZOrWZData[M28Map.subreftoUnitsToCapture] = {} end
                            table.insert(tLZOrWZData[M28Map.subreftoUnitsToCapture], oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Added unit to table of units to capture') end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end