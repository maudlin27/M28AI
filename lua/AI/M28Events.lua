---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 09:03
---



local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Config = import('/mods/M28AI/lua/M28Config.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
local M28Chat = import('/mods/M28AI/lua/AI/M28Chat.lua')

refiLastWeaponEvent = 'M28LastWep' --Gametimeseconds that last updated onweapon
refbAlreadyRunUnitKilled = 'M28EventsOnKilledRun'


function OnPlayerDefeated(aiBrain)
    if M28Utilities.bM28AIInGame then
        aiBrain.M28IsDefeated = true

        --Was it an M28AI?
        if aiBrain.M28AI then
            --Give resources to teammates
            local bHaveTeammates = false
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyHumanAndAIBrains]) == false then
                for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyHumanAndAIBrains] do
                    if not(oBrain == aiBrain) and not(oBrain.M28IsDefeated) and not(oBrain:IsDefeated()) then
                        bHaveTeammates = true
                        break
                    end
                end
            end
            if bHaveTeammates then
                ForkThread(M28Team.GiveAllResourcesToAllies, aiBrain)
            else
                --Send end of game message
                local iRand = math.random(1,3)
                local sEndOfGameMessage
                if iRand == 1 then
                    sEndOfGameMessage = 'gg'
                elseif iRand == 2 then
                    sEndOfGameMessage = 'You may have defeated me, but my older brother M27 will crush you like an insect'
                elseif iRand == 3 then
                    sEndOfGameMessage = ':( Time for me to go back to fighting other bots'
                end
                M28Chat.SendMessage(aiBrain, 'Our ACU Died', sEndOfGameMessage, 3, 60)
            end
        end

        --Update tables tracking the various brains
        ForkThread(M28Team.RefreshActiveBrainListForBrainDeath, aiBrain)
    end
end

function OnACUKilled(oUnit)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnACUKilled'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then
            local oKilledBrain = oUnit:GetAIBrain()
            if oKilledBrain then
                LOG(sFunctionRef..': ACU '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has just died, and its brain is '..oKilledBrain.Nickname)
            else
                LOG(sFunctionRef..': ACU '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has just died, and it doesnt have a brain')
            end
        end
        if ScenarioInfo.Options.Victory == "demoralization" then
            if oUnit:GetAIBrain() then
                if not(oUnit:GetAIBrain().M28IsDefeated) then
                    OnPlayerDefeated(oUnit:GetAIBrain())
                end
            else
                --Possibility that we have already recorded the unit death, so wait 1 second and then if any brains show as defeated but not M28Defeated then run the function
                ForkThread(M28Team.DelayedPlayerDeathCheck)
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnKilled(oUnitKilled, instigator, type, overkillRatio)
    --WARNING: Doesnt trigger when an ACU is killed
    --Will make sure the OnUnitDeath event is called, i.e. this function should only be used where we only want something to run when we killed something, or an enemy killed something of ours

    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnKilled'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


        if bDebugMessages == true then LOG(sFunctionRef..': event triggered for unit '..oUnitKilled.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitKilled)..' owned by brain '..oUnitKilled:GetAIBrain().Nickname..'; Have already run='..tostring(oUnitKilled[refbAlreadyRunUnitKilled] or false)) end

        if not(oUnitKilled[refbAlreadyRunUnitKilled]) then
            oUnitKilled[refbAlreadyRunUnitKilled] = true
            if bDebugMessages == true then LOG(sFunctionRef..': oUnitKilled='..oUnitKilled.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitKilled)..'; GameTime='..GetGameTimeSeconds()) end
            if oUnitKilled.GetAIBrain then
                OnUnitDeath(oUnitKilled) --Ensure this is run when a unit dies

                --were we killed by something?
                local oKillerUnit

                if instigator and not(instigator:BeenDestroyed()) and not(instigator.Dead) then
                    if instigator.GetLauncher and instigator:GetLauncher() then
                        oKillerUnit = instigator:GetLauncher()
                    elseif instigator.DamageData and not(instigator.unit) and not(instigator.UnitId) then
                        --Can get errors for artillery shells when running IsProjectile
                    elseif IsProjectile(instigator) or IsCollisionBeam(instigator) then
                        if instigator.unit then
                            oKillerUnit = instigator.unit
                        end
                    elseif IsUnit(instigator) then
                        oKillerUnit = instigator
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Have an instigator, checking if have valid killer unit. Is valid='..tostring(M28UnitInfo.IsUnitValid(oKillerUnit))) end
                    if oKillerUnit and oKillerUnit.GetAIBrain then

                        --Non-M28 specific killer logic:

                        if EntityCategoryContains(M28UnitInfo.refCategoryBomber * categories.TECH3, oKillerUnit.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryT3Power + M28UnitInfo.refCategoryT2Power, oKillerUnit.UnitId) then
                            ForkThread(ConsiderRecordingStratBomberToSuicideInto, oKillerUnit, true)
                        end

                        --T2 arti firebase tracking if they get lots of kills:
                        if oUnitKilled:GetAIBrain().M28AI then
                            if EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oKillerUnit.UnitId) then M28Land.ConsiderIfHaveEnemyFirebase(oUnitKilled:GetAIBrain().M28Team, oKillerUnit) end
                        end

                        --M28 specific killer logic
                        local oKillerBrain = oKillerUnit:GetAIBrain()
                        if oKillerBrain.M28AI then
                            if EntityCategoryContains(M28UnitInfo.refCategorySatellite, instigator.UnitId) and M28UnitInfo.IsUnitValid(oKillerUnit) then
                                ForkThread(M28Air.NovaxCoreTargetLoop, oKillerBrain, instigator, true)
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oKillerUnit.UnitId) and not(type) and not(overkillRatio) and not(oKillerBrain.M28Team == oUnitKilled:GetAIBrain().M28Team) then
                                --We have reclaimed an enemy - if there arent many enemies in this zone then update the zone; also check for enemy targets within build range to reclaim
                                local tNearbyReclaimableEnemies = oKillerBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryReclaimable, oKillerUnit:GetPosition(), oKillerUnit:GetBlueprint().Economy.MaxBuildDistance, 'Enemy')
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby reclaimable enemies empty='..tostring( M28Utilities.IsTableEmpty(tNearbyReclaimableEnemies))) end
                                local bNotGivenReclaimOrder = true
                                if M28Utilities.IsTableEmpty(tNearbyReclaimableEnemies) == false then
                                    for iPotentialEnemy, oPotentialEnemy in tNearbyReclaimableEnemies do
                                        if not(oPotentialEnemy == oUnitKilled) and M28UnitInfo.IsUnitValid(oPotentialEnemy) and oPotentialEnemy:GetHealth() > 0 then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will issue new reclaim order for oKillerUnit='..(oKillerUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oKillerUnit) or 'nil')..' owend by brain'..oKillerUnit:GetAIBrain().Nickname..' to target enemy unit '..(oPotentialEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oPotentialEnemy) or 'nil')..'; Time='..GetGameTimeSeconds()..'; Enemy unit health='..oPotentialEnemy:GetHealth()..'; Enemy unit brain owner='..oPotentialEnemy:GetAIBrain().Nickname) end

                                            ForkThread(M28Orders.IssueTrackedReclaim, oKillerUnit, oPotentialEnemy, false, 'FollowRec', false) --WHen tried doing but not via forked thread ended up with game crashing
                                            bNotGivenReclaimOrder = false
                                            break
                                        end
                                    end
                                end
                                if bNotGivenReclaimOrder then
                                    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnitKilled:GetPosition())
                                    if (iPlateauOrZero or 0) > 0 and (iLandOrWaterZone or 0) > 0 then
                                        local tLZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][oKillerBrain.M28Team]
                                        --if we reclaimed an enemy unit, then update units in that zone if arent many units left
                                        if not(tLZTeamData[M28Map.subrefTEnemyUnits][2]) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                                            if bDebugMessages == true then LOG(sFunctionRef..': have just killed a unit so will update the position of all enemy units in the zone, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; Time='..GetGameTimeSeconds()) end
                                            --UpdateUnitPositionsAndLandZone(aiBrain,   tUnits,                                 iTeam,              iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits, tLZTeamData, bUpdateTimeOfLastEnemyPositionCheck, bAreEnemyUnits)
                                            M28Land.UpdateUnitPositionsAndLandZone(oKillerBrain, tLZTeamData[M28Map.subrefTEnemyUnits], oKillerBrain.M28Team, iPlateauOrZero, iLandOrWaterZone, true,                   false,          tLZTeamData, true,                                  true)
                                        end
                                    end

                                end
                            end
                        end
                    end
                end
            elseif bDebugMessages == true then LOG(sFunctionRef..': Unit killed doesnt have a brain')
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnPropDestroyed(oProp)
    --Confirmed manually this triggers e.g. if a bomber destroys a rock, and if a tree is reclaimed
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnPropDestroyed'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnYthothaDeath(oUnit)
    --Called when a ythotha (oUnit) is flagged as dying or being killed
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnYthothaDeath'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        local refbYthothaDeath = 'M28EventYthothaDeath'

        if not(oUnit[refbYthothaDeath]) then
            oUnit[refbYthothaDeath] = true
            local tNearbyUnits
            if bDebugMessages == true then LOG(sFunctionRef..': Ythotha has just died, will look for nearby units and tell them to run away') end
            local iTimeToRun
            local iSearchRange = 70
            for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                tNearbyUnits = oBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand, oUnit:GetPosition(), 50, 'Ally')
                if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                    for iFriendlyUnit, oFriendlyUnit in tNearbyUnits do
                        if bDebugMessages == true then LOG(sFunctionRef..': oFriendlyUnit='..oFriendlyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFriendlyUnit)..'; if we own it then will make it run away') end
                        if oFriendlyUnit:GetAIBrain() == oBrain then --Only do this for M28 units
                            if M28UnitInfo.IsUnitValid(oFriendlyUnit, true) then
                                iTimeToRun = math.min(32, math.max(10, 18 + (50 - M28Utilities.GetDistanceBetweenPositions(oFriendlyUnit:GetPosition(), oUnit:GetPosition()) / (oFriendlyUnit:GetBlueprint().Physics.MaxSpeed or 1))))
                                if bDebugMessages == true then LOG(sFunctionRef..': Telling friendly unit '..oFriendlyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFriendlyUnit)..' to move away for 18s via moveawayfromtarget order') end
                                ForkThread(M28Micro.MoveAwayFromTargetTemporarily, oFriendlyUnit, iTimeToRun, oUnit:GetPosition())
                            end
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnUnitDeath(oUnit)
    --NOTE: This is called by the death of any unit of any player, so careful with what commands are given
        --Some callbacks line onkilled will call this as well to make sure it is run (since for some things like when an ACU is killed it doesnt trigger directly)
    if M28Utilities.bM28AIInGame and M28Map.bMapLandSetupComplete then --No point running on death logic for units at start of the game
        local sFunctionRef = 'OnUnitDeath'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



        if bDebugMessages == true then
            LOG(sFunctionRef..'Hook successful. oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; GameTime='..GetGameTimeSeconds()..'; oUnit[refbAlreadyRunUnitKilled]='..tostring(oUnit[refbAlreadyRunUnitKilled] or false))
            if oUnit.GetAIBrain then LOG(sFunctionRef..': Unit owner='..oUnit:GetAIBrain().Nickname) end
        end
        --Is it an ACU?
        if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
            OnACUKilled(oUnit)
        else
            if oUnit.CachePosition then --Redundancy to check not dealing with a unit, not sure this will actually trigger as looks like wreck deaths are picked up by the prop logic above
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Unit killed has a cache position, will draw in blue around it')
                    M28Utilities.DrawLocation(oUnit.CachePosition, nil, 1, 100, nil)
                end
                ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, oUnit.CachePosition, 0)
            else
                if oUnit.GetAIBrain then
                    --------Non-M28 Specific logic------
                    --Rough unit count
                    if not(oUnit['M28Dead']) then
                        oUnit['M28Dead'] = true
                        M28Overseer.refiRoughTotalUnitsInGame = M28Overseer.refiRoughTotalUnitsInGame - 1


                        --TMD protection logic - refresh land zone TMD entries
                        if oUnit[M28Building.refbUnitWantsMoreTMD] then M28Building.UpdateLZUnitsWantingTMDForUnitDeath(oUnit) end

                        --Big threat global team table update
                        if M28Utilities.IsTableEmpty(oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable]) == false then
                            M28Team.RemoveUnitFromBigThreatTable(oUnit)
                        end


                        M28Orders.ClearAnyRepairingUnits(oUnit)

                        --Hydro resource location made available again
                        if EntityCategoryContains(M28UnitInfo.refCategoryHydro, oUnit.UnitId) then
                            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroLocations]) == false then
                                for iHydroLocation, tHydroLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroLocations] do
                                    if M28Utilities.GetDistanceBetweenPositions(tHydroLocation, oUnit:GetPosition()) <= 2 then
                                        table.insert(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations], tHydroLocation)
                                        break
                                    end
                                end
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                            --Record mex position first as it is a forked thread so may lose position if the unit dies; however ignore if looks like an upgrading mex unit
                            if not(oUnit.CanTakeDamage == false and oUnit.IsUpgrade == true) then
                                local tMexPosition = {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]}
                                if bDebugMessages == true then LOG(sFunctionRef..': About to call OnMexDeath via fork, tMexPosition='..repru(tMexPosition)) end
                                if tMexPosition[1] == 0 and tMexPosition[2] == 0 then M28Utilities.ErrorHandler('Dont have a valid mex position - mex is showing as 0,0,0') end
                                ForkThread(M28Building.OnMexDeath, tMexPosition, (oUnit.UnitId or 'nil'), (M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil'), oUnit:GetAIBrain():GetArmyIndex()) --Need to fork thread or else get an error when try to wait in the building logic
                            end
                            --[[local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]) == false then
                                for iMexLocation, tMexLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations] do
                                    --Prev line - redid at same time as changing approach for removing an unbuilt location to try and be more accurate
                                    --if M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition()) <= 0.9 then
                                    --Revised line:
                                    if math.abs(tMexLocation[1] - oUnit:GetPosition()[1]) < 0.9 and math.abs(tMexLocation[3] - oUnit:GetPosition()[3]) < 0.9 then
                                        table.insert(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations], tMexLocation)
                                        break
                                    end
                                end
                            end--]]
                            --Radar intel coverage update
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryRadar, oUnit.UnitId) then
                            ForkThread(M28Land.UpdateRadarCoverageForDestroyedRadar, oUnit)
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySonar, oUnit.UnitId) then
                            ForkThread(M28Navy.UpdateSonarCoverageForDestroyedSonar, oUnit)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryWall, oUnit.UnitId) and not(oUnit:GetAIBrain().M28AI) then
                            M28Land.TrackWallSegment(oUnit, false)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) then
                            --For each M28 team with active M28AI consider if we have a firebase
                            M28Land.ConsiderIfAnyEnemyTeamsStillHaveFirebaseOnT2ArtiDeath(oUnit)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryTMD + M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                            if EntityCategoryContains(M28UnitInfo.refCategoryTMD, oUnit.UnitId) then
                                M28Building.TMDDied(oUnit)
                            else
                                M28Building.TMLDied(oUnit)
                            end
                        end

                        --Fixed shields
                        if M28Utilities.IsTableEmpty(oUnit[M28Building.reftoUnitsCoveredByShield]) == false then
                            M28Building.UpdateShieldCoverageOfUnits(oUnit, true)
                        end

                        --Ythotha deathball avoidance
                        --Note -seraphimunits.lua contains SEnergyBallUnit which looks like it is for when the death ball is spawned; ID is XSL0402; SpawnElectroStorm is in the ythotha script
                        --Sandbox test - have c.36s from ythotha dying to energy ball dying, so want to run away for half of this (18s) plus extra time based on how far away we already were
                        if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental * categories.SERAPHIM, oUnit.UnitId) then
                            OnYthothaDeath(oUnit)
                        end
                        if EntityCategoryContains(categories.STRUCTURE + categories.EXPERIMENTAL -M28UnitInfo.refCategoryMex -M28UnitInfo.refCategoryHydro, oUnit.UnitId) and (EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) or oUnit:GetFractionComplete() < 1) then
                            if oUnit[M28Engineer.reftUnitBlacklistSegmentXZ] then --EntityCategoryContains(categories.EXPERIMENTAL * categories.MOBILE - M28UnitInfo.refCategoryExperimentalArti, oJustBuilt.UnitId) then
                                --Treat area around experimental under construction as available again
                                M28Engineer.ClearBlacklistForUnitConstructed(oUnit)
                            end
                            M28Engineer.SearchForBuildableLocationsNearDestroyedBuilding(oUnit)
                        end

                        --Campaign specific - upgrading structure that isn't yet complete
                        if M28Map.bIsCampaignMap and oUnit[M28UnitInfo.refbObjectiveUnit] and not(oUnit[refbAlreadyRunUnitKilled]) and oUnit:GetFractionComplete() < 1 and oUnit:GetAIBrain().CampaignAI and oUnit.DoUnitCallbacks and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnit.UnitId) then
                            oUnit:DoUnitCallbacks('OnKilled')
                        end

                        -------M28 specific logic---------
                        --Is the unit owned by M28AI?
                        if oUnit:GetAIBrain().M28AI then
                            --Air units - remove any assigned strike damage
                            if oUnit[M28Air.refoStrikeDamageAssigned] then
                                M28Air.RemoveAssignedAttacker(oUnit[M28Air.refoStrikeDamageAssigned], oUnit)
                            end
                            --Air scout death - record the target zone as dangerous
                            if oUnit[M28Air.reftScoutAssignedPlateauAndZoneRef] then
                                M28Air.OnAirScoutDeath(oUnit)
                            end
                            --Transport death - record target island as dangerous
                            if oUnit[M28Air.refiTargetIslandForDrop] then
                                local iTeam = oUnit:GetAIBrain().M28Team
                                local iTargetIsland = oUnit[M28Air.refiTargetIslandForDrop]
                                M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandDropTime][iTargetIsland] = GetGameTimeSeconds()
                                if oUnit[M28Air.refiTargetZoneForDrop] then
                                    if not(M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime][iTargetIsland]) then
                                        if not(M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime]) then M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime] = {} end
                                        M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime][iTargetIsland] = {}
                                    end
                                    M28Team.tTeamData[iTeam][M28Team.refiLastFailedIslandAndZoneDropTime][iTargetIsland][oUnit[M28Air.refiTargetZoneForDrop]] = GetGameTimeSeconds()
                                end
                            elseif oUnit[M28Air.refiTargetZoneForDrop] then --presumably a water zone if it has no island ref
                                local iTeam = oUnit:GetAIBrain().M28Team
                                if not(M28Team.tTeamData[iTeam][M28Team.refiLastFailedWaterZoneDropTime]) then M28Team.tTeamData[iTeam][M28Team.refiLastFailedWaterZoneDropTime] = {} end
                                M28Team.tTeamData[iTeam][M28Team.refiLastFailedWaterZoneDropTime][oUnit[M28Air.refiTargetZoneForDrop]] = GetGameTimeSeconds()
                            end

                            --Logic that doesnt require the unit to ahve finished construction:

                            --Fixed shielding
                            if oUnit[M28Building.refbUnitWantsShielding] or oUnit[M28Building.reftoUnitsCoveredByShield] or oUnit[M28Building.reftoShieldsProvidingCoverage] then
                                if oUnit[M28Building.reftoUnitsCoveredByShield] then
                                    --M28Building.UpdateShieldCoverageOfUnits(oUnit, true) --Already done above for all ai now
                                else
                                    M28Building.CheckIfUnitWantsFixedShield(oUnit)
                                end
                            end

                            --Special tracking e.g. for factions and shields and game enders - update
                            if oUnit[M28Building.refoNearbyFactoryOfFaction] then --i.e. gameender that wants a factory's engineers - the gameender is dead so want to clear entries for it
                                M28Building.ClearTrackingOfDeadUnitWantingFactoryEngineers(oUnit)
                            end
                            if oUnit[M28Building.reftoUnitsWantingFactoryEngineers] then --i.e. a factory that was down as the one providing engineers to a gameender - want to find a new factory
                                M28Building.UpdateTrackingOfDeadFactoryProvidingEngineers(oUnit)
                            end

                            --PD specific - stop trying to build here (in case we have far away engineers still trying to build at this location for this unit)
                            if EntityCategoryContains(M28UnitInfo.refCategoryPD, oUnit.UnitId) then
                                M28Engineer.ConsiderClearingEngineersForUnitJustDamagedOrDestroyed(oUnit, M28Engineer.refActionBuildEmergencyPD)
                            end

                            --Run unit type specific on death logic where the unit is completed
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if need to run certain M28AI on death logic, unit fraction ocmplete='..oUnit:GetFractionComplete()) end
                            if oUnit:GetFractionComplete() == 1 then
                                M28Economy.UpdateGrossIncomeForUnit(oUnit, true) --Dont fork thread
                                if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                                    M28Engineer.ClearEngineerTracking(oUnit)
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryScathis, oUnit.UnitId) then
                                    if M28Utilities.IsTableEmpty(M28Engineer.tAllScathis) == false then
                                        for iScathis, oScathis in M28Engineer.tAllScathis do
                                            if oScathis == oUnit then
                                                table.remove(M28Engineer.tAllScathis, iScathis) --Only doing this once so can get away with using table.remove, otherwise would want to use M28Utilities.ArrayRemove
                                                break
                                            end
                                        end
                                    end
                                elseif EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                                    --Check for upgrades
                                    --Upgrade tracking (even if have run this already)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will check if upgrade tracking needs updating, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                    M28Team.UpdateUpgradeTrackingOfUnit(oUnit, true)
                                    if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                                        M28Economy.UpdateZoneM28MexByTechCount(oUnit, true)
                                        --Update upgrading mexes
                                        M28Economy.UpdateTableOfUpgradingMexesForTeam(oUnit:GetAIBrain().M28Team)
                                    end
                                    M28Economy.UpdateHighestFactoryTechLevelForDestroyedUnit(oUnit) --checks if it was a factory as part of this function

                                elseif EntityCategoryContains(M28UnitInfo.refCategoryMobileLand, oUnit.UnitId) then
                                    --If unit was traveling to another land zone, then update that land zone so it no longer things the unit is traveling here
                                    M28Land.RemoveUnitFromListOfUnitsTravelingToLandZone(oUnit) --(this will check if it was or not)
                                end

                                --Mobile shield update
                                if oUnit[M28Land.refoAssignedMobileShield] then
                                    oUnit[M28Land.refoAssignedMobileShield][M28Land.refoMobileShieldTarget] = nil
                                end
                                if oUnit[M28Land.refoMobileShieldTarget] then
                                    oUnit[M28Land.refoMobileShieldTarget][M28Land.refoAssignedMobileShield] = nil
                                end
                            end
                            --Update record of units with disabled weapons
                            if oUnit[M28UnitInfo.refbWeaponDisabled] then
                                local iTeam = oUnit:GetAIBrain().M28Team
                                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons]) == false then
                                    for iRecorded, oRecorded in M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons] do
                                        if oRecorded == oUnit then
                                            table.remove(M28Team.tTeamData[iTeam][M28Team.reftoUnitsWithDisabledWeapons], iRecorded)
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnWorkEnd(self, work)
    --Not sure when/if this even triggers - would need to review if plan to use
    --LOG('WOrk end has finished for self='..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self)..'; work reprs='..reprs(work))
end

function OnEnhancementComplete(oUnit, sEnhancement)
    if M28Utilities.bM28AIInGame then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnEnhancementComplete'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        --Check we haven't just run this
        if GetGameTimeSeconds() - (oUnit[M28UnitInfo.reftiTimeOfLastEnhancementComplete][sEnhancement] or -100) >= 0.5 then
            if not(oUnit[M28UnitInfo.reftiTimeOfLastEnhancementComplete]) then oUnit[M28UnitInfo.reftiTimeOfLastEnhancementComplete] = {} end
            oUnit[M28UnitInfo.reftiTimeOfLastEnhancementComplete][sEnhancement] = GetGameTimeSeconds()
            if bDebugMessages == true then LOG(sFunctionRef..': Enhancement completed for self='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..'; sEnhancement='..reprs(sEnhancement)..'; Has enhancement for this='..tostring(oUnit:HasEnhancement(sEnhancement))) end
            M28UnitInfo.UpdateUnitCombatMassRatingForUpgrades(oUnit)
            M28UnitInfo.RecordUnitRange(oUnit) --Refresh the range incase enhancement has increased anything

            --Mobile TML logic (e.g. ACU and SACU, and billy nuke) - note some manual ranges are e.g. for overcharge
            if (oUnit[M28UnitInfo.refiManualRange] or 0) > 50 then
                --Record this against every opposing M28 Team
                if bDebugMessages == true then LOG(sFunctionRef..': have unit with tml upgrade, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                ForkThread(M28Team.RecordMobileTMLThreatForAllEnemyTeams, oUnit)
            end

            --Update ACU upgrade count
            if EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oUnit.UnitId) then
                oUnit[M28ACU.refiUpgradeCount] = (oUnit[M28ACU.refiUpgradeCount] or 0) + 1
                if sEnhancement == 'Teleporter' then
                    if bDebugMessages == true then LOG(sFunctionRef..': Flagging that unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has got teleporter upgrade and setting weapon prioritisation accordingly') end
                    oUnit[M28ACU.refbACUHasTeleport] = true
                    if ScenarioInfo.Options.Victory == "demoralization" then
                        M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityTeleSnipeInclACU, false)
                    else
                        M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityTeleSnipeExclACU, false)
                    end
                end
                if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                    --Consider being more aggressive with ACU again (mainly relevant for team games)
                    oUnit[M28ACU.refbUseACUAggressively] = M28ACU.DoWeStillWantToBeAggressiveWithACU(oUnit)
                end
            end
            --Fix AiX modifier
            if oUnit:GetAIBrain().CheatEnabled then
                M28UnitInfo.FixUnitResourceCheatModifiers(oUnit)
            end
            if oUnit:GetAIBrain().M28AI then
                if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                    M28ACU.GetUpgradePathForACU(oUnit)
                end
                --Remove any upgrade tracking
                M28Team.UpdateUpgradeTrackingOfUnit(oUnit, true, sEnhancement)
            end
            M28UnitInfo.RecordUnitRange(oUnit)
            if sEnhancement == 'CloakingGenerator' then
                --Record in table for enemy teams
                CloakedUnitIdentified(oUnit)
            end
            --Update eco for RAS
            local tEnhancement = oUnit:GetBlueprint().Enhancements[sEnhancement]
            if bDebugMessages == true then LOG(sFunctionRef..': tEnhancement='..reprs(tEnhancement)) end
            if tEnhancement then
                if tEnhancement.ProductionPerSecondEnergy or tEnhancement.ProductionperSecondMass then
                    --Remove existing entries for unit then create new ones
                    M28Economy.UpdateGrossIncomeForUnit(oUnit, true, true)
                    M28Economy.UpdateGrossIncomeForUnit(oUnit, false, false)
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Unit DF range after updating recorded range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')) end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function CloakedUnitIdentified(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CloakedUnitIdentified'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iUnitBrainIndex = oUnit:GetAIBrain():GetArmyIndex()
    local tbTeamsConsidered = {}
    for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
        if IsEnemy(oBrain:GetArmyIndex(), iUnitBrainIndex) and not(tbTeamsConsidered[oBrain.M28Team]) then
            local iTeam = oBrain.M28Team
            tbTeamsConsidered[iTeam] = true
            local bAddToTable = true
            if not(M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits]) then
                M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits] = {}
            else
                for iRecorded, oRecorded in M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits] do
                    if oRecorded == oUnit then
                        bAddToTable = false
                        break
                    end
                end
            end
            if bAddToTable then
                table.insert(M28Team.tTeamData[iTeam][M28Team.reftCloakedEnemyUnits], oUnit)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Added unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by brain '..oUnit:GetAIBrain().Nickname..' to table of cloaked units for iTeam='..iTeam..' unless was already recorded, bAddToTable='..tostring(bAddToTable)..'; Time='..GetGameTimeSeconds()) end
        end
    end
    oUnit[M28UnitInfo.refbUnitIsCloaked] = true
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function OnShieldBubbleDamaged(self, instigator)
    local oShield = self.Owner
    --LOG('Shield damaged, self='..reprs(self)..'; owner='..reprs(self.Owner))
    if not(oShield.Dead) then
        if oShield:GetAIBrain().M28AI then
            oShield[M28UnitInfo.refiTimeLastDamaged] = GetGameTimeSeconds()
        end
        --LOG('instigator='..reprs(instigator))
        if M28UnitInfo.IsUnitValid(instigator) and instigator:GetAIBrain().M28AI and EntityCategoryContains(M28UnitInfo.refCategoryMML, instigator.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oShield.UnitId) and IsEnemy(oShield:GetAIBrain():GetArmyIndex(), instigator:GetAIBrain():GetArmyIndex()) then
            local iShieldPlateau, iShieldLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oShield:GetPosition())
            if (iShieldLandZone or 0) > 0 and iShieldPlateau > 0 then
                local tLZTeamData = M28Map.tAllPlateaus[iShieldPlateau][M28Map.subrefPlateauLandZones][iShieldLandZone][M28Map.subrefLZTeamData][instigator:GetAIBrain().M28Team]
                tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] = GetGameTimeSeconds()
                local iMMLPlateau, iMMLZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(instigator:GetPosition())
                if (iMMLPlateau or 0) > 0 and (iMMLZone or 0) > 0 and not(iMMLZone == iShieldLandZone and iMMLPlateau == iShieldPlateau) then
                    local tMMLLZTeamData = M28Map.tAllPlateaus[iMMLPlateau][M28Map.subrefPlateauLandZones][iMMLZone][M28Map.subrefLZTeamData][instigator:GetAIBrain().M28Team]
                    tMMLLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] = GetGameTimeSeconds()
                end
                --LOG('Flagging that we have had missiles intercepted by TMD or shield for iShieldLandZone and MML zone, iShieldLandZone='..(iShieldLandZone or 'nil')..'; iMMLZone='..(iMMLZone or 'nil')..'; iMMLPlateau='..(iMMLPlateau or 'nil'))
            end
        end
    end
end

function OnDamaged(self, instigator) --This doesnt trigger when a shield bubble is damaged - see OnShieldBubbleDamaged for this
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnDamaged'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if self.IsWreckage then
            --Will only update when props and wrecks are destroyed for performance reasons
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Non-wreck damaged') end
            if self.GetUnitId then
                local oUnitCausingDamage
                if instigator and not(instigator:BeenDestroyed()) then
                    if instigator.GetLauncher and instigator:GetLauncher() then
                        oUnitCausingDamage = instigator:GetLauncher()
                    elseif instigator.DamageData and not(instigator.unit) and not(instigator.UnitId) then
                        --Can get errors for artillery shells when running IsProjectile
                    elseif IsProjectile(instigator) or IsCollisionBeam(instigator) then
                        if instigator.unit then
                            oUnitCausingDamage = instigator.unit
                        end
                    elseif IsUnit(instigator) then
                        oUnitCausingDamage = instigator
                    end
                    if bDebugMessages == true then
                        if not(oUnitCausingDamage) then LOG(sFunctionRef..': Dont ahve a valid unit as instigator')
                        else LOG(sFunctionRef..': Have a unit causing damage='..oUnitCausingDamage.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitCausingDamage)) end
                    end
                end

                --Logic specific to M28 units dealing damage
                if M28UnitInfo.IsUnitValid(oUnitCausingDamage) and oUnitCausingDamage:GetAIBrain().M28AI then
                    --Update so unit isnt treated as having shot blocked
                    oUnitCausingDamage[M28UnitInfo.refbLastShotBlocked] = false
                    oUnitCausingDamage[M28UnitInfo.refiTimeOfLastUnblockedShot] = GetGameTimeSeconds()
                    if M28UnitInfo.IsUnitValid(self) and (self[M28UnitInfo.refiTargetShotBlockedCount] or 0) > 0 then self[M28UnitInfo.refiTargetShotBlockedCount] = self[M28UnitInfo.refiTargetShotBlockedCount] - 10 end

                    --T3/experimental arti specific
                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, oUnitCausingDamage.UnitId) then
                        --Reset the arti shot count if damaged a high value unit
                        if M28UnitInfo.IsUnitValid(self) then
                            if bDebugMessages == true then LOG(sFunctionRef..': T3/Exp arti owned by M28 brain '..oUnitCausingDamage:GetAIBrain().Nickname..', arti unit='..oUnitCausingDamage.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitCausingDamage)..' has just damaged unit '..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self)..' which is valid') end
                            local iUnitDamagedMassValue = self:GetBlueprint().Economy.BuildCostMass * self:GetFractionComplete()
                            if iUnitDamagedMassValue >= 700 then
                                --Reduce the ineffective arti shot count
                                local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(self:GetPosition())
                                local tLZOrWZTeamData
                                if iPlateauOrZero > 0 then
                                    tLZOrWZTeamData  = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][oUnitCausingDamage:GetAIBrain().M28Team]
                                else
                                    --Water zone
                                    tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][oUnitCausingDamage:GetAIBrain().M28Team]
                                end
                                local iReductionValue
                                if iUnitDamagedMassValue >= 10000 then
                                    iReductionValue = 50
                                elseif iUnitDamagedMassValue >= 3000 then
                                    iReductionValue = 12
                                else
                                    iReductionValue = 6
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Changing ineffective shot count, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWateZone='..iLandOrWaterZone..'; tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount]='..(tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 'nil')..'; iReductionValue='..iReductionValue) end
                                tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] = math.max(0, (tLZOrWZTeamData[M28Map.subrefiIneffectiveArtiShotCount] or 0) - iReductionValue)
                            end
                        end
                    end
                end

                --Logic specific to M28 units dealt damage
                if self:GetAIBrain().M28AI then
                    if EntityCategoryContains(categories.COMMAND, self.UnitId) then
                        if self:IsUnitState('Upgrading') then
                            --Do we want to cancel the upgrade? If were hit by a TML then want to
                            if M28UnitInfo.IsUnitValid(oUnitCausingDamage) and EntityCategoryContains(M28UnitInfo.refCategoryTML, oUnitCausingDamage.UnitId) then
                                M28Micro.MoveAwayFromTargetTemporarily(self, 5, oUnitCausingDamage:GetPosition())
                            end
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryPD, self.UnitId) and M28UnitInfo.IsUnitValid(self) and (self:GetFractionComplete() <= 0.7 or (self:GetFractionComplete() <= 0.85 and M28UnitInfo.GetUnitHealthPercent(self) <= 0.5)) and EntityCategoryContains(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryIndirect, oUnitCausingDamage.UnitId) then
                        M28Engineer.ConsiderClearingEngineersForUnitJustDamagedOrDestroyed(self,  M28Engineer.refActionBuildEmergencyPD)
                    end
                    --General - if enemy has non-long range direct fire structure that hit an M28 unit, then check if it is in the same or adjacen tzone, so can record if it isnt
                    if oUnitCausingDamage.GetPosition and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnitCausingDamage.UnitId) and oUnitCausingDamage[M28UnitInfo.refiDFRange] and oUnitCausingDamage[M28UnitInfo.refiDFRange] < 100 and oUnitCausingDamage[M28UnitInfo.refiDFRange] > 0 and self.GetPosition then
                        if oUnitCausingDamage[M28UnitInfo.refiDFRange] < 60 or M28Utilities.GetDistanceBetweenPositions(oUnitCausingDamage:GetPosition(), self:GetPosition()) < 60 then
                            local iPDPlateauOrZero, iPDZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnitCausingDamage:GetPosition())
                            local iDamagedPlateauOrZero, iDamagedZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(self:GetPosition())
                            if not(iPDPlateauOrZero == iDamagedPlateauOrZero and iPDZone == iDamagedZone) and (iPDPlateauOrZero or 0) > 0 and iDamagedPlateauOrZero > 0 then
                                --Arent in the same zone, but are both in land zones are we in an adjacent zone?
                                local tDamagedLZData = M28Map.tAllPlateaus[iDamagedPlateauOrZero][M28Map.subrefPlateauLandZones][iDamagedZone]
                                local bPDIsInAdjacentZone = false
                                if iDamagedPlateauOrZero == iPDPlateauOrZero and M28Utilities.IsTableEmpty(tDamagedLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                    for _, iAdjLZ in tDamagedLZData[M28Map.subrefLZAdjacentLandZones] do
                                        if iAdjLZ == iPDZone then
                                            bPDIsInAdjacentZone = true
                                            break
                                        end
                                    end
                                end
                                if not(bPDIsInAdjacentZone) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have PD in a nearby non-adjacent zone, oUnitCausingDamage='..oUnitCausingDamage.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitCausingDamage)..'; iPDPlateauOrZero='..iPDPlateauOrZero..'; iPDZone='..iPDZone..'; iDamagedPlateauOrZero='..iDamagedPlateauOrZero..'; iDamagedZone='..iDamagedZone..'; Time='..GetGameTimeSeconds()) end
                                    local bAlreadyRecorded = false
                                    if not(tDamagedLZData[M28Map.subrefDangerousNearbyPlateauAndZones]) then
                                        tDamagedLZData[M28Map.subrefDangerousNearbyPlateauAndZones] = {}
                                    else
                                        for iEntry, tPlateauAndZone in tDamagedLZData[M28Map.subrefDangerousNearbyPlateauAndZones] do
                                            if tPlateauAndZone[2] == iPDZone and tPlateauAndZone[1] == iPDPlateauOrZero then
                                                bAlreadyRecorded = true
                                                break
                                            end
                                        end
                                    end
                                    if not(bAlreadyRecorded) then
                                        table.insert(tDamagedLZData[M28Map.subrefDangerousNearbyPlateauAndZones], {iPDPlateauOrZero, iPDZone})
                                        local tPDLZData = M28Map.tAllPlateaus[iPDPlateauOrZero][M28Map.subrefPlateauLandZones][iPDZone]
                                        if not(tPDLZData[M28Map.subrefDangerousNearbyPlateauAndZones]) then tPDLZData[M28Map.subrefDangerousNearbyPlateauAndZones] = {} end
                                        table.insert(tPDLZData[M28Map.subrefDangerousNearbyPlateauAndZones], {iDamagedPlateauOrZero, iDamagedZone})
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': tDamagedLZData[M28Map.subrefDangerousNearbyPlateauAndZones]='..reprs(tDamagedLZData[M28Map.subrefDangerousNearbyPlateauAndZones])) end
                                end
                            end
                        end
                    end
                end

            end

        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnBombFired(oWeapon, projectile)
    if M28Utilities.bM28AIInGame then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnBombFired'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
        local oUnit = oWeapon.unit
        if oUnit and oUnit.GetUnitId then
            local sUnitID = oUnit.UnitId
            if bDebugMessages == true then LOG(sFunctionRef..': bomber position when firing bomb='..repru(oUnit:GetPosition())) end
            if EntityCategoryContains(M28UnitInfo.refCategoryBomber + M28UnitInfo.refCategoryTorpBomber, sUnitID) then
                --if not(EntityCategoryContains(categories.EXPERIMENTAL, sUnitID)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and dodge the bomb fired by unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                    M28Micro.DodgeBomb(oUnit, oWeapon, projectile)

                    --Ahwassa - micro the bomber
                if EntityCategoryContains(categories.EXPERIMENTAL, sUnitID) then
                    --Experimental bomber - micro to turn around and go to rally point
                    if oUnit:GetAIBrain().M28AI then
                        ForkThread(M28Micro.TurnAirUnitAndMoveToTarget, oUnit, M28Team.tAirSubteamData[oUnit:GetAIBrain().M28AirSubteam][M28Team.reftAirSubRallyPoint], 15, 3)

                        --Have friendly gunships dodge
                        M28Micro.FriendlyGunshipsAvoidBomb(oUnit, oWeapon, projectile)
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

--WARNING: OnWeaponFired and/or OnProjectilfeFired - one of these (probably the latter) resulted in error messages when t1 arti fired, disabled both of them as dont use now

function OnWeaponFired(oWeapon)
    if M28Utilities.bM28AIInGame then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnWeaponFired'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if not(M28Map.bWaterZoneInitialCreation) then
            while GetGameTimeSeconds() < 5 do
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if M28Map.bWaterZoneInitialCreation then break end
            end
        end



        if bDebugMessages == true then LOG(sFunctionRef..': Start of code; does the weapon have a valid unit='..tostring(M28UnitInfo.IsUnitValid(oWeapon.unit))..'; Weapon unitID='..(oWeapon.unit.UnitId or 'nil')..'; oWeapon[M28UnitInfo.refiLastWeaponEvent]='..(oWeapon[M28UnitInfo.refiLastWeaponEvent] or 'nil')) end
        local oUnit = oWeapon.unit
        if oUnit and oUnit.GetUnitId and oUnit.GetAIBrain then

            local oParentBrain = oUnit:GetAIBrain()
            --M28 torp bomber micro (done here as want to make sure we pick up the last weapon event)
            if oParentBrain.M28AI then
                if EntityCategoryContains(M28UnitInfo.refCategoryTorpBomber, oUnit.UnitId) and not(oUnit[M28UnitInfo.refbSpecialMicroActive]) then
                    --Micro torp bombers if this is the last shot and torp only has 1 rack
                    if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname..' has just fired a shot, Time='..GetGameTimeSeconds()..'; oWeapon[M28UnitInfo.refiLastWeaponEvent]='..(oWeapon[M28UnitInfo.refiLastWeaponEvent] or 'nil')..'; is salvo data nil='..tostring(oUnit.CurrentSalvoData == nil)..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; Is unit state attacking='..tostring(oUnit:IsUnitState('Attacking'))..'; reprs of Weapon salvo data='..reprs(oWeapon.CurrentSalvoData)..'; reprs of weapon='..reprs(oWeapon)..'; Weapon blueprint='..reprs(oWeapon.Blueprint)..'; Is rack size highest value='..tostring((oWeapon.CurrentRackSalvoNumber or 0) >= (oWeapon.Blueprint.RackSalvoSize or 0))..'; Is salvo size highest value='..tostring((oWeapon.CurrentSalvoNumber or 0) >= (oWeapon.Blueprint.MuzzleSalvoSize or 0))..'; oWeapon.CurrentRackSalvoNumber='..(oWeapon.CurrentRackSalvoNumber or 'nil')..'; oWeapon.Blueprint.RackSalvoSize='..oWeapon.Blueprint.RackSalvoSize..';oWeapon.CurrentSalvoNumber='..(oWeapon.CurrentSalvoNumber or 'nil')..'; Muzzle salvo size='..(oWeapon.Blueprint.MuzzleSalvoSize or 0)) end
                    if (oWeapon.CurrentRackSalvoNumber or 0) >= (oWeapon.Blueprint.RackSalvoSize or 0) and (oWeapon.CurrentSalvoNumber or 0) >= (oWeapon.Blueprint.MuzzleSalvoSize or 0) then

                        ForkThread(M28Micro.TurnAirUnitAndMoveToTarget, oUnit, M28Team.tAirSubteamData[oParentBrain.M28AirSubteam][M28Team.reftAirSubRallyPoint], 25, 1)
                    end
                elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) then
                    ForkThread(M28Building.ConsiderManualT2ArtiTarget, oUnit, oWeapon)
                end


            end

            if not(oWeapon[M28UnitInfo.refiLastWeaponEvent]) or GetGameTimeSeconds() - (oWeapon[M28UnitInfo.refiLastWeaponEvent] or -1) >= 0.5 then
                oWeapon[M28UnitInfo.refiLastWeaponEvent] = GetGameTimeSeconds()
                oUnit[M28UnitInfo.refiLastWeaponEvent] = GetGameTimeSeconds()
                --Update unit last known position/record it
                for iTeam, tTeam in M28Team.tTeamData do
                    if not(iTeam == oParentBrain.M28Team) then
                        if M28Utilities.IsTableEmpty(tTeam[M28Team.subreftoFriendlyActiveM28Brains]) == false then
                            for iBrain, oBrain in tTeam[M28Team.subreftoFriendlyActiveM28Brains] do
                                M28Team.ConsiderAssigningUnitToZoneForBrain(oBrain, oUnit) --This function includes check of whether this is an M28 brain, and updates last known position
                                break
                            end
                        end
                    end
                end

                --Consider dodging
                if EntityCategoryContains(M28UnitInfo.refCategoryBomber, oUnit.UnitId) and (oWeapon.Label == 'GroundMissile') then
                    --Corsairs dont trigger the onbombfired event normally hence why we have this
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Weapon fired by corsair, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
                        if oWeapon:GetCurrentTarget().GetPosition then LOG(sFunctionRef..': Target of weapon='..repru(oWeapon:GetCurrentTarget():GetPosition())) end
                    end

                    ForkThread(M28Micro.DodgeBomb, oUnit, oWeapon, nil)
                else
                    --Dodge logic for certain other attacks (conditions for this are in considerdodgingshot)
                    if bDebugMessages == true then LOG(sFunctionRef..': Will consider whether we want to dodge the shot') end
                    ForkThread(M28Micro.ConsiderDodgingShot, oUnit, oWeapon)
                end

                --Update overcharge tracking
                if oWeapon.GetBlueprint and oWeapon.GetBlueprint and not(oWeapon:BeenDestroyed()) and oWeapon:GetBlueprint().Overcharge then
                    oUnit[M28UnitInfo.refiTimeOfLastOverchargeShot] = GetGameTimeSeconds()
                    if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and oUnit:GetAIBrain().M28AI then
                        --Get another order immediately rather than waiting (means we dont have to try and queue orders up for ACU logic)
                        M28ACU.GetACUOrder(oUnit:GetAIBrain(), oUnit)
                    end
                end

                --M28 owned unit specific logic
                if oUnit:GetAIBrain().M28AI then
                    --Shot is blocked logic

                    if bDebugMessages == true then LOG(sFunctionRef..': COnsidering if unit shot is blocked Time='..GetGameTimeSeconds()..', range category='..(oWeapon.Blueprint.RangeCategory or 'nil')..'; Is unit a relevant DF category='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE + M28UnitInfo.refCategorySeraphimDestroyer - M28UnitInfo.refCategoryMissileShip, oUnit.UnitId))) end
                    if (oWeapon.Blueprint.RangeCategory == 'UWRC_DirectFire' and EntityCategoryContains(M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE + M28UnitInfo.refCategorySeraphimDestroyer - M28UnitInfo.refCategoryMissileShip, oUnit.UnitId)) or (oWeapon.Blueprint.RangeCategory == 'UWRC_AntiNavy' and EntityCategoryContains(M28UnitInfo.refCategorySubmarine, oUnit.UnitId)) then
                        --Get weapon target if it is a DF weapon or sub torpedo
                        local oTarget
                        if oWeapon.GetCurrentTarget and not(oWeapon:BeenDestroyed()) then oTarget = oWeapon:GetCurrentTarget() end
                        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has just fired a shot. Do we have a valid target for our weapon='..tostring(M28UnitInfo.IsUnitValid(oTarget))..'; time last shot was blocked='..(oUnit[M28UnitInfo.refiTimeOfLastCheck] or 'nil')) end
                        if M28UnitInfo.IsUnitValid(oTarget) then
                            if not(oUnit[M28UnitInfo.refbLastShotBlocked]) then oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] = math.max((oUnit[M28UnitInfo.refiTimeOfLastCheck] or -100), (oUnit[M28UnitInfo.refiTimeOfLastUnblockedShot] or -100)) end
                            oUnit[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds()
                            oUnit[M28UnitInfo.refbLastShotBlocked] = M28Logic.IsShotBlocked(oUnit, oTarget, EntityCategoryContains(M28UnitInfo.refCategorySubmarine, oUnit.UnitId))
                            if bDebugMessages == true then LOG(sFunctionRef..': oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Is shot blocked='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked])..'; built in blocking terrain result for low profile='..tostring(oUnit:GetAIBrain():CheckBlockingTerrain(oUnit:GetPosition(), oTarget:GetPosition(), 'Low'))..'; High profile='..tostring(oUnit:GetAIBrain():CheckBlockingTerrain(oUnit:GetPosition(), oTarget:GetPosition(), 'High'))) end

                            if oUnit[M28UnitInfo.refbLastShotBlocked] then
                                --Reset after 20s if we havent fired any more shots at the target
                                --function DelayChangeVariable(oVariableOwner, sVariableName, vVariableValue, iDelayInSeconds, sOptionalOwnerConditionRef, iMustBeLessThanThisTimeValue, iMustBeMoreThanThisTimeValue, vMustNotEqualThisValue)
                                M28Utilities.DelayChangeVariable(oUnit, M28UnitInfo.refbLastShotBlocked, false, 20, M28UnitInfo.refiTimeOfLastCheck, GetGameTimeSeconds() + 0.01)
                                --Increase shot blocked count if this is a longer ranged naval unit firing at a structure
                                if oUnit[M28UnitInfo.refiCombatRange] > 50 and EntityCategoryContains(M28UnitInfo.refCategoryNavalSurface, oUnit.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oTarget.UnitId) then
                                    oTarget[M28UnitInfo.refiTargetShotBlockedCount] = (oTarget[M28UnitInfo.refiTargetShotBlockedCount] or 0) + 1
                                end
                            elseif oUnit[M28UnitInfo.refiCombatRange] > 50 and EntityCategoryContains(M28UnitInfo.refCategoryNavalSurface, oUnit.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oTarget.UnitId) then
                                oTarget[M28UnitInfo.refiTargetShotBlockedCount] = 0
                            end
                        end
                    end
                    --T3 arti targeting logic; TML missile tracking
                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, oUnit.UnitId) then
                        ForkThread(M28Building.GetT3ArtiTarget, oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                        if M28UnitInfo.IsUnitValid(oUnit[M28Building.refoLastTMLTarget]) then
                            oUnit[M28Building.refoLastTMLTarget][M28Building.refiTimeOfLastLaunch] = GetGameTimeSeconds()
                            if bDebugMessages == true then LOG(sFunctionRef..': have set time of last launch to '..oUnit[M28Building.refoLastTMLTarget][M28Building.refiTimeOfLastLaunch]..' for target '..oUnit[M28Building.refoLastTMLTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit[M28Building.refoLastTMLTarget])) end
                        end
                    end
                    --SML, TML and SMD - unpause (if paused)
                    if EntityCategoryContains(M28UnitInfo.refCategorySML + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                        M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, false)
                        --TML and nuke - consider launching missile if have any remaining
                        ForkThread(M28Building.JustFiredMissile, oUnit)
                    end
                end
            end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

        end
    end

--[[function ProjectileFiredAtGround(oProjectile)
    if oProjectile.GetCurrentTargetPosition then
        LOG('TEMP TEST will draw projectile targeting ground target')
        M28Utilities.DrawLocation(oProjectile:GetCurrentTargetPosition(), 2)
    end
end--]]

--[[function ProjectileCreated(oProjectile, inWater)
    if oProjectile.GetCurrentTargetPosition then
        LOG('TEMP TEST will draw projectile created target')
        M28Utilities.DrawLocation(oProjectile:GetCurrentTargetPosition(), 2)
    end
end--]]

--[[function ProjectileFiredFromWeapon(oProjectile)
    if oProjectile.GetCurrentTargetPosition then
        LOG('TEMP TEST will draw projectile created from firing weapon, oProjectile.UnitId='..(oProjectile.Unitid or 'nil')..'; launcher unit id='..(oProjectile.Launcher.UnitId or 'nil')..'; drawing projectile target='..repru(oProjectile:GetCurrentTargetPosition())..'; reprs of projectile='..reprs(oProjectile))
        for iEntry, tTable in oProjectile do
            LOG('reprs of iEntry='..iEntry..'='..reprs(tTable))
        end
        M28Utilities.DrawLocation(oProjectile:GetCurrentTargetPosition(), 3)
    else
        LOG('Projectyile fired but doesnt have a target position')
    end
end--]]

function OnMissileBuilt(self, weapon)
    if M28Utilities.bM28AIInGame then
        if self.GetAIBrain and self:GetAIBrain().M28AI then
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            local sFunctionRef = 'OnMissileBuilt'
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


            self[M28Building.refbMissileRecentlyBuilt] = true
            M28Utilities.DelayChangeVariable(self, M28Building.refbMissileRecentlyBuilt, false, 5)


            --Pause if we already have 2 missiles (mroe if smd and enemy has nukes)
            if bDebugMessages == true then
                if M28UnitInfo.IsUnitValid(self) then
                    LOG(sFunctionRef..': Have valid unit='..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self))
                else
                    LOG(sFunctionRef..': self='..reprs(self))
                end
            end

            local iMissiles = 1 --For some reason the count is off by 1, presumably a slight delay between the event being called and the below ammo counts working
            if self.GetTacticalSiloAmmoCount then iMissiles = iMissiles + self:GetTacticalSiloAmmoCount() end
            if bDebugMessages == true then LOG(sFunctionRef..': iMissiles based on tactical silo ammo='..iMissiles) end
            if self.GetNukeSiloAmmoCount then iMissiles = iMissiles + self:GetNukeSiloAmmoCount() end
            if bDebugMessages == true then LOG(sFunctionRef..': iMissiles after Nuke silo ammo='..iMissiles) end
            if iMissiles >= 1 then
                --Stop assisting units (so can reassess if we still want to assist)
                if M28Utilities.IsTableEmpty(self[M28UnitInfo.reftoUnitsAssistingThis]) == false then
                    local tEngineersToStop = {}
                    for iEngineer, oEngineer in self[M28UnitInfo.reftoUnitsAssistingThis] do
                        table.insert(tEngineersToStop, oEngineer)
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to make engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to stop assisting') end
                    end
                    for iEngineer, oEngineer in tEngineersToStop do
                        if M28UnitInfo.IsUnitValid(oEngineer) then
                            M28Orders.IssueTrackedClearCommands(oEngineer)
                            if bDebugMessages == true then LOG(sFunctionRef..': Just sent a clear order to '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to stop assisting') end
                        end
                    end
                end

                --If 2+ missiles then pause, and consider unpausing later
                if iMissiles >= 2 and not(EntityCategoryContains(categories.EXPERIMENTAL, self.UnitId)) then
                    if not(EntityCategoryContains(M28UnitInfo.refCategorySMD, self.UnitId)) or
                            --SMD specific
                            (iMissiles >= 4 or M28Utilities.IsTableEmpty(M28Team.tTeamData[self:GetAIBrain().M28Team][M28Team.reftEnemyNukeLaunchers]) or iMissiles >= 2 + table.getn(M28Team.tTeamData[self:GetAIBrain().M28Team][M28Team.reftEnemyNukeLaunchers])) then
                        local iTeam = self:GetAIBrain().M28Team
                        --Dont pause if overflowing
                        if M28Conditions.HaveLowPower(iTeam) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 400 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.8 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 30 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 25 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.99))) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have at least 2 missiles so will set paused to true on unit '..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self)) end
                            self:SetPaused(true)
                            if self.SetAutoMode then self:SetAutoMode(false) end

                            --Recheck every minute
                            ForkThread(M28Building.CheckIfWantToBuildAnotherMissile, self)
                        end
                    end
                end
                if EntityCategoryContains(M28UnitInfo.refCategorySMD, self.UnitId) then
                    --Do we have any SMD without missiles, and no yolona on the team? If so then change the flag about needing resources for missiles
                    local bHaveSMDOrSMLNeedingMissiles = false
                    local iTeam = self:GetAIBrain().M28Team
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        if oBrain:GetCurrentUnits(M28UnitInfo.refCategorySML) > 0 then
                            bHaveSMDOrSMLNeedingMissiles = true
                            break
                        else
                            local tSMD = oBrain:GetListOfUnits(M28UnitInfo.refCategorySMD, false, true)
                            if M28Utilities.IsTableEmpty(tSMD) == false then
                                for iSMD, oSMD in tSMD do
                                    if not(oSMD == self) then
                                        if oSMD:GetFractionComplete() < 1 or oSMD:GetNukeSiloAmmoCount() == 0 then
                                            bHaveSMDOrSMLNeedingMissiles = true
                                            break
                                        end
                                    end
                                end
                                if bHaveSMDOrSMLNeedingMissiles then break end
                            end
                        end
                    end
                    if not(bHaveSMDOrSMLNeedingMissiles) then
                        M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] = false
                    end
                end
            end

            if not(EntityCategoryContains(M28UnitInfo.refCategorySMD, self.UnitId)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Calling logic to consider launching a missile') end
                ForkThread(M28Building.ConsiderLaunchingMissile, self, weapon)
            end
        end

    end
end

--[[
function OnProjectileFired(oWeapon, oMuzzle)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OnProjectileFired'
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
    if oWeapon.GetBlueprint then
        LOG('OnWeaponFired hook for blueprint='..repru(oWeapon:GetBlueprint()))
    end
    if oWeapon.unit then
        LOG('Have a unit; unit position='..repru(oWeapon.unit:GetPosition()))
    end
end--]]

function OnConstructionStarted(oEngineer, oConstruction, sOrder)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnConstructionStarted'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



        --Update land zone queued orders
        if M28Utilities.IsTableEmpty(oEngineer[M28Engineer.reftQueuedBuildings]) == false then
            M28Engineer.RemoveBuildingFromQueuedBuildings(oEngineer, oConstruction)
        end


        --M28 specific
        if oEngineer:GetAIBrain().M28AI then
            if oConstruction.GetUnitId and not(oConstruction[M28UnitInfo.refbConstructionStart]) then

                oConstruction[M28UnitInfo.refbConstructionStart] = true



                if bDebugMessages == true then LOG(sFunctionRef..': Construction just started for oConstruction='..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction)..' at time '..GetGameTimeSeconds()..'; postiion='..repru(oConstruction:GetPosition())) end
                --Record any mexes so we can repair them if construction gets interrupted
                if EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oConstruction.UnitId) then
                    M28Engineer.RecordPartBuiltMex(oEngineer, oConstruction)
                end

                --Decide if want to shield this construction and update buildable location, or (in the case of experimentals) if we want to cancel the construction
                if EntityCategoryContains(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryExperimentalLevel, oConstruction.UnitId) then
                    local bCancelBuilding = false
                    if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti, oConstruction.UnitId) then
                        local iTeam = oEngineer:GetAIBrain().M28Team
                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.9 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] < 3 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] < 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.6)) then
                            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oConstruction:GetPosition())
                            if iPlateau > 0 and (iLandZone or 0) > 0 then
                                --NOTE: If changing above thresholds then consider also changing M28Engineer ConsiderActionToAssign threshold (want above to be less likely to trigger to avoid constant loop of starting and cancelling)
                                local iSearchRange = math.max(175, 450 - M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) --(slightly further search range than the M28Engineer approach)
                                local iSearchCategory = nil --means will search for everything
                                if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder, oConstruction.UnitId) then iSearchCategory = M28UnitInfo.refCategoryGameEnder
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti, oConstruction.UnitId) then iSearchCategory = M28UnitInfo.refCategoryFixedT3Arti
                                else
                                    --Search for all experimentals  (so leave as nil) - however given the above restriction this is more for redundancy as would only expect to be here if are building game ender or t3 arti
                                end
                                local bHaveExperimentalForThisLandZone, iOtherLandZonesWithExperimental, iMassToComplete = M28Engineer.GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateau, iLandZone, true, iSearchRange, iSearchCategory)
                                if iMassToComplete >= math.max(17500, M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] * 1.3) then
                                    --Estimate how long it will take to complete if we manage to spend 40% of gross mass on existing experimentals
                                    if (iMassToComplete - M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]) / M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 0.4 > 40 then
                                        bCancelBuilding = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to cancel construction that we just started, iMassToComplete='..iMassToComplete..'; Mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) end
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': bCancelBuilding='..tostring(bCancelBuilding)) end
                    if bCancelBuilding then
                        --Clear all engineeres trying to build this
                        M28Engineer.ClearEngineersBuildingUnit(oEngineer, oConstruction)
                        --Tell the engi that just constructed to reclaim
                        M28Orders.IssueTrackedReclaim(oEngineer, oConstruction, false, 'AbrtNRec', true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have told engineer to abort consturction of '..oConstruction.UnitId..' and to reclaim it instead') end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Engineer that is starting this construction='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; oEngineer[M28Engineer.refiAssignedAction]='..(oEngineer[M28Engineer.refiAssignedAction] or 'nil')) end
                        --Game ender and T3 arti specific - reserve locations for shields
                        if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti, oConstruction.UnitId) then
                            M28Building.ReserveLocationsForGameEnder(oConstruction)
                            --Record shields against the gameender/T3 arti if they are in the reserved location
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oConstruction.UnitId) then
                            if oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionSpecialShieldDefence then
                                M28Building.AssignShieldToGameEnder(oConstruction, oEngineer)
                            else
                                --Consider adding normal shields to the gameender defence if they are built very near to a game ender location
                                if oConstruction:GetAIBrain().M28AI and oEngineer:GetAIBrain().M28AI then
                                    local iShieldRadius = (oConstruction:GetBlueprint().Defense.Shield.ShieldSize or 0) * 0.5
                                    if iShieldRadius > 10 then --larger than a T2 aeon shield
                                        local iTeam = oEngineer:GetAIBrain().M28Team
                                        local tShieldLZData, tShieldLZTeamData = M28Map.GetLandOrWaterZoneData(oConstruction:GetPosition(), true, iTeam)
                                        local bHaveMatch = false

                                        if M28Utilities.IsTableEmpty(tShieldLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) == false then
                                            for iGameEnder, oGameEnder in tShieldLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
                                                if M28Utilities.IsTableEmpty(oGameEnder[M28Building.reftLocationsForPriorityShield]) == false then
                                                    for iLocation, tLocation in oGameEnder[M28Building.reftLocationsForPriorityShield] do
                                                        if M28Utilities.GetRoughDistanceBetweenPositions(tLocation, oConstruction:GetPosition()) <= 3 then
                                                            if M28Utilities.GetDistanceBetweenPositions(oConstruction:GetPosition(), oGameEnder:GetPosition()) <= iShieldRadius * 0.9 then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Fixed shield construction '..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction)..' built by engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; will be assigned to a game ender shield as it is close to oGameEnder '..oGameEnder.UnitId..M28UnitInfo.GetUnitLifetimeCount(oGameEnder)) end
                                                                bHaveMatch = true
                                                                M28Building.AssignShieldToGameEnder(oConstruction, oEngineer)
                                                                break
                                                            end
                                                        end
                                                    end
                                                    if bHaveMatch then break end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            --ACU building t1 power far from base - flag that we dont want it assisted
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryT1Power, oConstruction.UnitId) and EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then
                            local oEngineerBrain = oEngineer:GetAIBrain()
                            if oEngineerBrain[M28Economy.refiGrossMassBaseIncome] >= 1.5 then
                                local tEngineerLZData = M28Map.GetLandOrWaterZoneData(oConstruction:GetPosition())
                                if M28Utilities.GetDistanceBetweenPositions(tEngineerLZData[M28Map.subrefMidpoint], oEngineer:GetPosition()) >= 25 then
                                    oConstruction[M28Engineer.refbDontIncludeAsPartCompleteBuildingForConstruction] = true
                                end
                            end
                        end
                        M28Building.CheckIfUnitWantsFixedShield(oConstruction, true)
                        --If this is a fixed shield then instead update shield coverage
                        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oConstruction.UnitId) then
                            M28Building.UpdateShieldCoverageOfUnits(oConstruction, false)
                        end

                        --Buildable locations - update for unit construction started (do form obile experimentals since the location is temporarily not buildable)
                        if EntityCategoryContains(M28UnitInfo.refCategoryStructure + categories.MOBILE - M28UnitInfo.refCategoryMex - M28UnitInfo.refCategoryHydro, oConstruction.UnitId) then
                            if EntityCategoryContains(M28UnitInfo.refCategoryStructure, oConstruction.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Just started construction of unit '..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction)..'; Is it valid to build a T1 pgen at this location='..tostring(oEngineer:GetAIBrain():CanBuildStructureAt('ueb1101', oConstruction:GetPosition()))) end
                                ForkThread(M28Engineer.CheckIfBuildableLocationsNearPositionStillValid, oEngineer:GetAIBrain(), oConstruction:GetPosition(), false, M28UnitInfo.GetBuildingSize(oConstruction.UnitId) * 0.5)
                            else
                                --i.e. experimentalal started, the CanBuildStructureAt check doesnt work properly for this so first need to record a blacklist (will only have recorded for 4m) and then check for this
                                if bDebugMessages == true then LOG(sFunctionRef..': Just started construction of experimental mobile unit='..oConstruction.UnitId..M28UnitInfo.GetUnitLifetimeCount(oConstruction)..'; Is it valid to build a T1 pgen at this location='..tostring(oEngineer:GetAIBrain():CanBuildStructureAt('ueb1101', oConstruction:GetPosition()))) end
                                M28Engineer.RecordBlacklistLocation(oConstruction:GetPosition(), M28UnitInfo.GetBuildingSize(oConstruction.UnitId) * 0.5, 420, oConstruction)
                                ForkThread(M28Engineer.CheckIfBuildableLocationsNearPositionStillValid, oEngineer:GetAIBrain(), oConstruction:GetPosition(), true, M28UnitInfo.GetBuildingSize(oConstruction.UnitId) * 0.5)
                            end
                        end
                        --end
                        --Both structures and experimentals - clear any engineers trying to build something else that will be blocked by this
                        ForkThread(M28Engineer.ClearEngineersWhoseTargetIsNowBlockedByUnitConstructionStarted, oEngineer, oConstruction)
                    end
                else
                    --Mobile unit - special logic for navla factories for mini bombardment (raid) target
                    if EntityCategoryContains(M28UnitInfo.refCategoryBombardment, oConstruction.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oEngineer.UnitId) then
                        M28Navy.ConsiderAssigningRaidingNavalUnit(oConstruction, oEngineer)
                    end
                end

            end
        else
            --Non-M28 only
            if not(oConstruction[M28UnitInfo.refbConstructionStart]) then
                oConstruction[M28UnitInfo.refbConstructionStart] = true
                --If this is a fixed shield then instead update shield coverage (note - we also do this for M28 brains above, but with some extra logic to decide if we want to try and shield, and using a more efficient emthod of identifying shields)
                if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oConstruction.UnitId) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a shield that we have just started ubilding so will update shield coverage') end
                    M28Building.UpdateShieldCoverageOfUnits(oConstruction, false)
                elseif EntityCategoryContains(M28UnitInfo.refCategoryStructure - categories.MOBILE, oConstruction.UnitId) then
                    --Record if this unit is under fixed shield coverage if it's not owned by an M28AI brain (M28AI units will separately check this by using the LZ data info)
                    local tNearbyShields = oConstruction:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedShield, oConstruction:GetPosition(), 60, 'Ally')
                    if bDebugMessages == true then LOG(sFunctionRef..': have just started construction of a building, will check for nearby shields, is tNearbyShields empty='..tostring(M28Utilities.IsTableEmpty(tNearbyShields))) end
                    if M28Utilities.IsTableEmpty(tNearbyShields) == false then
                        local iShieldRadius
                        for iShield, oShield in tNearbyShields do
                            iShieldRadius = oShield:GetBlueprint().Defense.Shield.ShieldSize * 0.5 -0.1 -- - 1
                            M28Building.RecordIfShieldIsProtectingUnit(oShield, oConstruction, iShieldRadius, true)
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnConstructed(oEngineer, oJustBuilt)
    --WARNING: This doesnt seem to trigger for the ACU; it does trigger when untis are constructed by a factory

    --NOTE: This is called every time an engineer stops building a unit whose fractioncomplete is 100%, so can be called multiple times
    if M28Utilities.bM28AIInGame then
        --NonM28 specific - dont set the M28OnConstructionCalled for this, so need to  be careful that any code here will not be run repeatedly
        --LOG('OnConstructed at time '..GetGameTimeSeconds()..' for unit '..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..' owned by brain '..oJustBuilt:GetAIBrain().Nickname..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; M28Map.bMapLandSetupComplete='..tostring(M28Map.bMapLandSetupComplete or false))
        if not(M28Map.bMapLandSetupComplete) then
            local iWaitCount = 0
            local bDontCallAgain = false
            while not(M28Map.bMapLandSetupComplete) do
                WaitTicks(1)
                iWaitCount = iWaitCount + 1
                if iWaitCount >= 300 then
                    M28Utilities.ErrorHandler('Waited more than 5m for map setup to complete, something has gone wrong')
                    bDontCallAgain = true
                    break
                end
            end
            if not(bDontCallAgain) and M28UnitInfo.IsUnitalid(oJustBuilt) then
                OnConstructed(oEngineer, oJustBuilt)
            end
        else
            M28Orders.ClearAnyRepairingUnits(oJustBuilt)
            if M28Utilities.IsTableEmpty(oJustBuilt[M28Land.reftoUnitsToKillOnCompletion]) == false then
                for iUnit, oUnit in oJustBuilt[M28Land.reftoUnitsToKillOnCompletion] do
                    if M28UnitInfo.IsUnitValid(oUnit) and (not(oUnit[M28UnitInfo.refbCampaignTriggerAdded]) or not(M28Map.bIsCampaignMap)) then
                        M28Orders.IssueTrackedKillUnit(oUnit)
                    end
                end
                oJustBuilt[M28Land.reftoUnitsToKillOnCompletion] = nil
            end

            if EntityCategoryContains(categories.STRUCTURE, oJustBuilt.UnitId) then
                --If a building has just build a building, then make sure all M28 are aware of it (since a player would be)
                if EntityCategoryContains(categories.STRUCTURE, oEngineer.UnitId) then
                    local tTeamsUpdated = {}
                    for iBrain, oBrain in M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subreftoEnemyBrains] do
                        if oBrain.M28AI and not(tTeamsUpdated[oBrain.M28Team]) then
                            tTeamsUpdated[oBrain.M28Team] = true
                            M28Team.AssignUnitToLandZoneOrPond(oBrain, oJustBuilt, false, false, true)
                        end
                    end
                end
                --Also update the name
                if M28Config.M28ShowUnitNames then
                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oJustBuilt:GetPosition(), false)

                    local sWZOrLZRef = ''
                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oJustBuilt:GetPosition())
                    local iWaterZone
                    if (iLandZone or 0) == 0 then
                        iWaterZone = M28Map.GetWaterZoneFromPosition(oJustBuilt:GetPosition())
                        if (iWaterZone or 0) > 0 then
                            sWZOrLZRef = 'WZ'..iWaterZone
                        end
                    else
                        sWZOrLZRef = ':P='..(iPlateau or 0)..'LZ='..(iLandZone or 0)
                    end

                    if M28Config.M28ShowUnitNames then oJustBuilt:SetCustomName(oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..sWZOrLZRef..': Built') end
                end

                --Redundnacy - If we have just built a radar then update radar logic (note that AssignUnitToLandZoneOrPond should already cover this when construction is started)
                if EntityCategoryContains(M28UnitInfo.refCategoryRadar, oJustBuilt.UnitId) then
                    ForkThread(M28Land.UpdateZoneIntelForRadar, oJustBuilt)
                elseif EntityCategoryContains(M28UnitInfo.refCategorySonar, oJustBuilt.UnitId) then
                    ForkThread(M28Navy.UpdateZoneIntelForSonar, oJustBuilt)

                    --Air staging - reset timer on when we last needed one
                elseif EntityCategoryContains(M28UnitInfo.refCategoryAirStaging, oJustBuilt.UnitId) then
                    M28Team.tTeamData[oJustBuilt:GetAIBrain().M28Team][M28Team.refiTimeOfLastAirStagingShortage] = 0
                end

                --Track non-M28AI wall segments
                if EntityCategoryContains(M28UnitInfo.refCategoryWall, oJustBuilt.UnitId) and not(oJustBuilt:GetAIBrain().M28AI) then
                    M28Land.TrackWallSegment(oJustBuilt, true)
                end
            elseif oJustBuilt[M28Engineer.reftUnitBlacklistSegmentXZ] then --EntityCategoryContains(categories.EXPERIMENTAL * categories.MOBILE - M28UnitInfo.refCategoryExperimentalArti, oJustBuilt.UnitId) then
                --Treat area around experimental under construction as available again
                M28Engineer.ClearBlacklistForUnitConstructed(oJustBuilt)
                M28Engineer.SearchForBuildableLocationsNearDestroyedBuilding(oJustBuilt)
            end

            M28Building.RecordUnitShieldCoverage(oJustBuilt)



            --M28 specific
            if oJustBuilt:GetAIBrain().M28AI then
                if not(oJustBuilt.M28OnConstructedCalled) then
                    local sFunctionRef = 'OnConstructed'
                    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



                    oJustBuilt.M28OnConstructedCalled = true
                    if bDebugMessages == true then LOG(sFunctionRef..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just built '..oJustBuilt.UnitId) end
                    local aiBrain = oJustBuilt:GetAIBrain()
                    local iTeam = aiBrain.M28Team
                    --experimental level construction count, and paragon and yolona specific logic
                    if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oJustBuilt.UnitId) then
                        M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] = M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] + 1
                        local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oJustBuilt:GetPosition(), true, iTeam)
                        tLZTeamData[M28Map.refiZoneConstructedExperimentalCount] = (tLZTeamData[M28Map.refiZoneConstructedExperimentalCount] or 0) + 1
                        if EntityCategoryContains(M28UnitInfo.refCategoryParagon, oJustBuilt.UnitId) then
                            ForkThread(M28Building.JustBuiltParagon, oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySML * categories.EXPERIMENTAL, oJustBuilt.UnitId) then
                            M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] = true
                        end

                        if EntityCategoryContains(M28UnitInfo.refCategoryNovaxCentre, oJustBuilt.UnitId) then
                            ForkThread(M28Air.DelayedNovaxUnloadCheck, oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryNovaxCentre, oEngineer.UnitId) and oEngineer:GetAIBrain().M28AI then
                            ForkThread(M28Air.DelayedNovaxUnloadCheck, oEngineer)
                        end

                    end

                    --Experimental air - no longer record in land/water zone
                    if EntityCategoryContains(M28UnitInfo.refCategoryAllAir, oJustBuilt.UnitId) then
                        --Transport specific - tell the factory that just built the transport to build something else
                        if EntityCategoryContains(M28UnitInfo.refCategoryTransport, oJustBuilt.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryAirFactory * categories.TECH1, oEngineer.UnitId) then
                            oEngineer[M28Factory.refbWantNextUnitToBeEngineer] = true
                        end

                        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oJustBuilt:GetPosition())
                        if (iLandOrWaterZone or 0) > 0 then
                            local tLZOrWZData
                            local tLZOrWZTeamData
                            local sUnitTableRef

                            if iPlateauOrZero == 0 then
                                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                                sUnitTableRef = M28Map.subreftoLZOrWZAlliedUnits
                            else
                                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                                sUnitTableRef = M28Map.subreftoLZOrWZAlliedUnits
                            end
                            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[sUnitTableRef]) == false then
                                for iUnit, oUnit in tLZOrWZTeamData[sUnitTableRef] do
                                    if oUnit == oJustBuilt then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Removing unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from zone '..iLandOrWaterZone..' as it is a construction completed experimental') end
                                        table.remove(tLZOrWZTeamData[sUnitTableRef], iUnit)
                                        break
                                    end
                                end
                            end
                        end
                    end

                    --Logic based on the unit that was just built:

                    --Check build locations for units not built at a factory
                    local bDontClearEngineer = false
                    if EntityCategoryContains(categories.STRUCTURE + categories.EXPERIMENTAL, oJustBuilt.UnitId) then

                        if not(oJustBuilt[M28UnitInfo.refbConstructionStart]) then
                            M28Engineer.CheckIfBuildableLocationsNearPositionStillValid(aiBrain, oJustBuilt:GetPosition(), false, M28UnitInfo.GetBuildingSize(oJustBuilt.UnitId) * 0.5)
                        end
                        M28Economy.UpdateHighestFactoryTechLevelForBuiltUnit(oJustBuilt) --includes a check to see if are dealing with a factory HQ
                        if EntityCategoryContains(M28UnitInfo.refCategoryMex, oJustBuilt.UnitId) then
                            M28Team.tTeamData[iTeam][M28Team.refiUpgradedMexCount] = (M28Team.tTeamData[iTeam][M28Team.refiUpgradedMexCount] or 0) + 1
                            ForkThread(M28Economy.UpdateZoneM28MexByTechCount, oJustBuilt, false, 10)
                            --If have storage owned by M28 on same team by this mex, gift it over
                            --All mexes - on construction check if we have allied M28 mass storage nearby (e.g. we have rebuilt on a mex that they used to have) and if so then have that M28 gift over their mass storage
                            M28Team.GiftAdjacentStorageToMexOwner(oJustBuilt)

                            --Update part built t1 mex tracking
                            if EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oJustBuilt.UnitId) then
                                M28Engineer.UpdatePartBuiltListForCompletedMex(oJustBuilt)
                            end
                            if EntityCategoryContains(M28UnitInfo.refCategoryMex - categories.TECH3 -categories.EXPERIMENTAL, oJustBuilt.UnitId) then
                                ForkThread(M28Economy.ConsiderFutureMexUpgrade, oJustBuilt)
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMassStorage, oJustBuilt.UnitId) then
                            --If just built a mass storage but we dont own the mex it is adjacent to, then gift the storage
                            local rSearchRectangle = M28Utilities.GetRectAroundLocation(oJustBuilt:GetPosition(), 2.749)
                            local tNearbyUnits = GetUnitsInRect(rSearchRectangle) --at 1.5 end up with storage thats not adjacent being gifted in some cases but not in others; at 1 none of it gets gifted; the mass storage should be exactly 2 from the mex; however even at 2.1, 2.25 and 2.499 had cases where the mex wasnt identified so will try 2.75 since distances can vary/be snapped to the nearest 0.5 I think
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Storage gifting where built storage - oJustBuilt='..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; owner='..aiBrain.Nickname..'; is tNearbyUnits empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnits)))
                                if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                                    for iUnit, oUnit in tNearbyUnits do
                                        LOG(sFunctionRef..': iUnit '..iUnit..' in tNearbyUnits='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; owner='..oUnit:GetAIBrain().Nickname)
                                    end
                                end
                            end
                            if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                                local tNearbyMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tNearbyUnits)
                                if M28Utilities.IsTableEmpty(tNearbyMexes) == false then
                                    local bHaveMexWeOwnNearby = false
                                    local oBrainToTransferToIfWeOwnNoMexes
                                    for iUnit, oUnit in tNearbyMexes do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering nearby unit oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname) end
                                        if oUnit:GetAIBrain() == aiBrain then
                                            bHaveMexWeOwnNearby = true
                                        elseif oUnit:GetAIBrain().M28Team == iTeam then
                                            oBrainToTransferToIfWeOwnNoMexes = oUnit:GetAIBrain()
                                        end
                                    end
                                    if not(bHaveMexWeOwnNearby) and oBrainToTransferToIfWeOwnNoMexes then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and gift the storage to the player who owns the mex already there') end
                                        M28Team.TransferUnitsToPlayer({oJustBuilt}, oBrainToTransferToIfWeOwnNoMexes:GetArmyIndex(), false)
                                    end
                                end
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryEnergyStorage, oJustBuilt.UnitId) then
                            M28Team.TeamEconomyRefresh(iTeam)
                            M28Team.ConsiderGiftingStorageToTeammate(oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oJustBuilt.UnitId) then
                            --Clear the desire to build land facs by mexes - i.e. only want hte first one to be built as such
                            if bDebugMessages == true then LOG(sFunctionRef..': Have just build land factory so clearing adjacency desire for all M28 brains') end
                            M28Engineer.tiActionAdjacentCategory[M28Engineer.refActionBuildLandFactory] = nil
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, oJustBuilt.UnitId) then
                            ForkThread(M28Building.GetT3ArtiTarget, oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryPD * categories.TECH1 + M28UnitInfo.refCategoryWall, oJustBuilt.UnitId) then
                            --Build T1 walls around T1 PD
                            --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition,                                           oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
                            local sWallBP = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28Engineer.tiActionCategory[M28Engineer.refActionBuildWall], oEngineer)
                            if sWallBP then
                                local tWallBuildLocation = M28Engineer.GetLocationToBuildWall(oEngineer, oJustBuilt, sWallBP)
                                if tWallBuildLocation then
                                    --First generate list of other engineers to also help with wall building (as theyll potentially get cleared when we clear the original engineer)
                                    local tOtherEngineersHelpingConstruction = {}
                                    local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oJustBuilt:GetPosition(), true, oEngineer:GetAIBrain().M28Team)
                                    local tEngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                    if M28Utilities.IsTableEmpty(tEngineersInZone) == false then
                                        for iUnit, oUnit in tEngineersInZone do
                                            if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering other engineer in zone, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Assigned action='..(oUnit[M28Engineer.refiAssignedAction] or 'nil')) end
                                                if oUnit[M28Engineer.refiAssignedAction] == M28Engineer.refActionBuildEmergencyPD then --dont need to do for walsl as eahc engi builds individually
                                                    local oFocusUnit = oUnit:GetFocusUnit()
                                                    if bDebugMessages == true then
                                                        LOG(sFunctionRef..': oFocusUnit='..(oFocusUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oFocusUnit) or 'nil')..'; Last order='..reprs(oUnit[M28Orders.reftiLastOrders]))
                                                        if M28Utilities.IsTableEmpty(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]) == false then
                                                            LOG(sFunctionRef..': Dist of last order to just built='..M28Utilities.GetDistanceBetweenPositions(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition], oJustBuilt:GetPosition())..'; Dist of last order to engineer='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oJustBuilt:GetPosition()))
                                                        end
                                                    end

                                                    if oFocusUnit == oEngineer or oFocusUnit == oJustBuilt or (not(oFocusUnit) and M28Utilities.IsTableEmpty(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition]) == false and M28Utilities.GetDistanceBetweenPositions(oUnit[M28Orders.reftiLastOrders][1][M28Orders.subreftOrderPosition], oJustBuilt:GetPosition()) < 1 and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oJustBuilt:GetPosition()) <= oUnit:GetBlueprint().Economy.MaxBuildDistance + 1) then
                                                        table.insert(tOtherEngineersHelpingConstruction, oUnit)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': have a supporting engineer that helped build the T1 PD') end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    M28Orders.IssueTrackedBuild(oEngineer, tWallBuildLocation, sWallBP, false, 'WallP')
                                    M28Engineer.TrackEngineerAction(oEngineer, M28Engineer.refActionBuildWall, true, 1)
                                    bDontClearEngineer = true
                                    if M28Utilities.IsTableEmpty(tOtherEngineersHelpingConstruction) == false then
                                        for iUnit, oUnit in tOtherEngineersHelpingConstruction do
                                            local tWallBuildLocation = M28Engineer.GetLocationToBuildWall(oUnit, oJustBuilt, sWallBP)
                                            if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; tWallBuildLocation='..repru(tWallBuildLocation)) end
                                            if tWallBuildLocation then
                                                M28Orders.IssueTrackedBuild(oUnit, tWallBuildLocation, sWallBP, false, 'WallS')
                                                M28Engineer.TrackEngineerAction(oUnit, M28Engineer.refActionBuildWall, true, 1)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will tell unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to build a wall at '..repru(tWallBuildLocation)) end
                                            end
                                        end
                                    end
                                end
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryPower * categories.TECH3, oJustBuilt.UnitId) then
                            ForkThread(M28Building.ConsiderGiftingPowerToTeammateForAdjacency, oJustBuilt)
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySMD, oJustBuilt.UnitId) then
                            --If enemy has nuke then flag we need resources for missile
                            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false then
                                M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] = true
                            end
                            --T2 arti - consider manual shot targets
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oJustBuilt.UnitId) then
                            ForkThread(M28Building.ConsiderManualT2ArtiTarget, oJustBuilt)
                        end
                        if EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti - categories.MOBILE + M28UnitInfo.refCategorySML * categories.TECH3 + M28UnitInfo.refCategoryAirFactory * categories.TECH3 + M28UnitInfo.refCategoryMassFab * categories.TECH3 + M28UnitInfo.refCategoryT3Radar, oJustBuilt.UnitId) then
                            ForkThread(M28Building.ConsiderGiftingPowerToTeammateForAdjacency, oJustBuilt)
                        end
                        --Clear engineers that just built this

                    elseif EntityCategoryContains(M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryIndirectT3, oJustBuilt.UnitId) then
                        if not(M28Team.tTeamData[iTeam][M28Team.refbBuiltLotsOfT3Combat]) then
                            if M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryIndirectT3) >= 30 then
                                M28Team.tTeamData[iTeam][M28Team.refbBuiltLotsOfT3Combat] = true
                            end
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer * categories.TECH3, oJustBuilt.UnitId) then
                        --Late game - destroy lower tech engineers to help with pathing (up to 2 for every T3 engi built)
                        ForkThread(M28Engineer.ConsiderDestroyingLowTechEngineers, oJustBuilt)
                    elseif EntityCategoryContains(categories.MOBILE * categories.SUBMERSIBLE, oJustBuilt.UnitId) then
                        ForkThread(M28Navy.DelayedCheckIfShouldSubmerge, oJustBuilt)
                    end

                    --Update economy tracking (this function will check if it is an economic unit as part of it)
                    M28Economy.UpdateGrossIncomeForUnit(oJustBuilt)
                    if EntityCategoryContains(M28UnitInfo.refCategoryScathis, oJustBuilt.UnitId) then
                        table.insert(M28Engineer.tAllScathis, oJustBuilt)
                    end

                    if EntityCategoryContains(M28UnitInfo.refCategorySatellite, oJustBuilt.UnitId) then
                        if bDebugMessages == true then LOG(sFunctionRef..'Novax created, reprs='..reprs(oUnit)) end
                        ForkThread(M28Air.DetachSatellite,oJustBuilt, 1)
                    end


                    --Logic based on the engineer
                    if EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then
                        M28ACU.GetACUOrder(oEngineer:GetAIBrain(), oEngineer)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryQuantumGateway + M28UnitInfo.refCategoryMobileLandFactory + M28UnitInfo.refCategorySpecialFactory, oEngineer.UnitId) then
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': A factory has just built a unit so will get the next order for the factory, oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer))
                        end
                        ForkThread(M28Factory.DecideAndBuildUnitForFactory, oEngineer:GetAIBrain(), oEngineer)
                        --Treat the unit just built as having micro active so it doesn't receive orders for a couple of seconds (so it can clear the factory)
                        if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryNavalFactory + M28UnitInfo.refCategoryMobileLandFactory, oEngineer.UnitId) and EntityCategoryContains(categories.MOBILE - categories.AIR, oJustBuilt.UnitId) then
                            --Also give unit a move order (queued onto its existing order)
                            if M28Utilities.IsTableEmpty(oEngineer[M28Factory.reftFactoryRallyPoint]) then
                                M28Factory.SetFactoryRallyPoint(oEngineer)
                            end
                            M28Orders.IssueTrackedMove(oJustBuilt, oEngineer[M28Factory.reftFactoryRallyPoint], 0.1, true, 'RollOff', false)
                            M28Micro.TrackTemporaryUnitMicro(oJustBuilt, 1.5) --i.e. want to increase likelihood that a unit has exited the land factory before it starts being given orders
                            if bDebugMessages == true then LOG(sFunctionRef..': Engineer parent='..reprs(oEngineer.Parent)..'; Unit ID = or parent'..(oEngineer.Parent.UnitId or 'nil')) end
                            if oEngineer.UnitId == 'uel0401ef' or (oEngineer.Parent.UnitId and EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oEngineer.Parent.UnitId)) then
                                --Want some MAA to stick by fatboy so theyre protected by its shield
                                if EntityCategoryContains(M28UnitInfo.refCategoryMAA, oJustBuilt.UnitId) then
                                    ForkThread(M28Land.ConsiderAssigningMAABodyguardToFatboy,oJustBuilt, oEngineer)
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory - categories.MOBILE, oEngineer.UnitId) then
                                --Consider assigning T2 MAA to ACU
                                if EntityCategoryContains(M28UnitInfo.refCategoryMAA * categories.TECH2, oJustBuilt.UnitId) then
                                    ForkThread(M28Land.ConsiderAssigningMAABodyguardToACU, oJustBuilt)
                                end
                            end
                        end


                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to clear refiFirstTimeOfLastOrder='..(oEngineer[M28Factory.refiFirstTimeOfLastOrder] or 'nil')..' for facotyr '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' at game time '..GetGameTimeSeconds()) end
                        if oEngineer[M28Factory.refiFirstTimeOfLastOrder] and GetGameTimeSeconds() - oEngineer[M28Factory.refiFirstTimeOfLastOrder] > 0.1 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Clearing refiFirstTimeOfLastOrder for the factory') end
                            oEngineer[M28Factory.refiFirstTimeOfLastOrder] = nil
                        end --Clear time as only want to use this to track incase have blocking unit
                        oEngineer[M28Factory.refiTotalBuildCount] = (oEngineer[M28Factory.refiTotalBuildCount] or 0) + 1
                        oEngineer:GetAIBrain()[M28Factory.refiHighestFactoryBuildCount] = math.max((oEngineer:GetAIBrain()[M28Factory.refiHighestFactoryBuildCount] or 0), (oEngineer[M28Factory.refiTotalBuildCount] or 0))
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oEngineer.UnitId) then
                        --Clear any engineers trying to build this unit if we just built a building or experimental
                        if not(bDontClearEngineer) and EntityCategoryContains(categories.STRUCTURE + categories.EXPERIMENTAL, oJustBuilt.UnitId) then
                            M28Engineer.ClearEngineersBuildingUnit(oEngineer, oJustBuilt, true)
                        end
                    end

                    --Logic based on the type of unit built
                    if EntityCategoryContains(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryQuantumGateway + M28UnitInfo.refCategoryMobileLandFactory + M28UnitInfo.refCategorySpecialFactory, oJustBuilt.UnitId) then
                        if bDebugMessages == true then LOG(sFunctionRef..': A factory has just been built so will get the next order for the factory') end
                        ForkThread(M28Factory.DecideAndBuildUnitForFactory, aiBrain, oJustBuilt)
                        if EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oJustBuilt.UnitId) then
                            aiBrain[M28Economy.refiOurHighestFactoryTechLevel] = math.max(M28UnitInfo.GetUnitTechLevel(oJustBuilt), aiBrain[M28Economy.refiOurHighestFactoryTechLevel])
                        end
                    elseif EntityCategoryContains(categories.STEALTH, oJustBuilt.UnitId) then
                        --Make sure stealth is enabled
                        M28UnitInfo.EnableUnitStealth(oJustBuilt)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryPower + M28UnitInfo.refCategoryMex, oJustBuilt.UnitId) then
                        --Consider gifting power and mexes to a teammate
                        if oJustBuilt:GetAIBrain()[M28Economy.refiGrossMassBaseIncome] >= 1000 and oJustBuilt:GetAIBrain()[M28Economy.refiGrossEnergyBaseIncome] >= 100000 and M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 then
                            local oParagonBrain = oJustBuilt:GetAIBrain()
                            for iBrain, oBrain in  M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                if not(oBrain == oParagonBrain) and not(oBrain.M28IsDefeated) and oBrain[M28Economy.refiGrossMassBaseIncome] < 1000 then
                                    M28Team.TransferUnitsToPlayer({ oJustBuilt }, oBrain:GetArmyIndex(), false)
                                    break
                                end
                            end
                        end
                    end

                    --Mobile land units - give a micro move order so they dont block the factory
                    if EntityCategoryContains(M28UnitInfo.refCategoryMobileLand, oJustBuilt.UnitId) then
                        ForkThread(M28Micro.MoveAwayFromFactory, oJustBuilt, oEngineer)
                    end

                    --Unit cap - refresh if are within 25 of the cap since it isnt accurate if have current units
                    if M28UnitInfo.IsUnitValid(oJustBuilt) and aiBrain[M28Overseer.refbCloseToUnitCap] and aiBrain[M28Overseer.refiExpectedRemainingCap] <= 25 then
                        M28Overseer.CheckUnitCap(aiBrain)
                    end

                    --air fac restriction - review if campaign in case things have changed if are dealing with the player (dont do for campaign AI though as they sometimes have different settings)
                    if M28Overseer.bAirFactoriesCantBeBuilt and M28Map.bIsCampaignMap and not(aiBrain.CampaignAI) then
                        local tACUs = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
                        if M28Utilities.IsTableEmpty(tACUs) == false then
                            local sAirFac = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryAirFactory, tACUs[1])
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Just built '..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; Time='..GetGameTimeSeconds()..'; sAirFac='..(sAirFac or 'nil'))
                                if sAirFac then LOG(sFunctionRef..': Is sAirFac restricted='..tostring(import("/lua/game.lua").IsRestricted(sAirFac, aiBrain:GetArmyIndex()))) end
                            end
                            if sAirFac and not(import("/lua/game.lua").IsRestricted(sAirFac, aiBrain:GetArmyIndex())) then
                                M28Overseer.bAirFactoriesCantBeBuilt = false
                            end
                        end
                    end

                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                else
                    --M28 unit has finished construction, but we have alreayd called the main onconstruction event - have any special logic here that we want to run every time (e.g. for the engineers that have just completed construction)

                    --Commented out below as engineers get cleared when the first one completes construction, so will have wall building logic as part of that
                    --[[if EntityCategoryContains(M28UnitInfo.refCategoryPD * categories.TECH1 + M28UnitInfo.refCategoryWall, oJustBuilt.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oEngineer.UnitId) and oJustBuilt:GetFractionComplete() == 1 and oEngineer:GetAIBrain().M28 then
                        --Build T1 walls around T1 PD
                        local aiBrain = oEngineer:GetAIBrain()
                        local sWallBP = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28Engineer.tiActionCategory[M28Engineer.refActionBuildWall], oEngineer)
                        if sWallBP then
                            local tWallBuildLocation = M28Engineer.GetLocationToBuildWall(oEngineer, oJustBuilt, sWallBP)
                            if tWallBuildLocation then
                                M28Orders.IssueTrackedBuild(oEngineer, tWallBuildLocation, sWallBP, false, 'Wall')
                                M28Engineer.TrackEngineerAction(oEngineer, M28Engineer.refActionBuildWall, true, 1)
                            end
                        end
                    end--]]
                end
            else
                --If build an M28 unit then will record its plateau and LZ; so for non-M28 AI also want to do this so we have a backup for pathfinding if dont already have something
                if M28Utilities.IsTableEmpty(oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) and not(EntityCategoryContains(categories.AIR, oJustBuilt.UnitId)) then
                    local iPlateau, iLandZone = M28Map.GetPathingOverridePlateauAndLandZone(oJustBuilt:GetPosition(), true, oJustBuilt)
                    if not(oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) then oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] = {} end
                    oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][oJustBuilt:GetAIBrain().M28Team] = {iPlateau, iLandZone}
                    if iPlateau and not(iLandZone) then
                        --May be on water
                        local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(oJustBuilt:GetPosition())
                        local iWaterZone = M28Map.tWaterZoneBySegment[iSegmentX][iSegmentZ]
                        if iWaterZone then
                            if not(oJustBuilt[M28UnitInfo.reftAssignedWaterZoneByTeam]) then oJustBuilt[M28UnitInfo.reftAssignedWaterZoneByTeam] = {} end
                            oJustBuilt[M28UnitInfo.reftAssignedWaterZoneByTeam][oJustBuilt:GetAIBrain().M28Team] = iWaterZone
                        end
                    end
                    --[[if (iPlateau or 0) > 0 then
                        if not(oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) then oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] = {} end
                        oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][oJustBuilt:GetAIBrain().M28Team] = {iPlateau, iLandZone}
                    end--]]
                end

            end
            --Upgrade tracking (even if have run this already)
            if oEngineer.GetAIBrain and EntityCategoryContains(categories.STRUCTURE, oEngineer.UnitId) and EntityCategoryContains(categories.STRUCTURE, oJustBuilt.UnitId) then
                if oJustBuilt:GetAIBrain().M28AI or (M28UnitInfo.IsUnitValid(oEngineer) and oEngineer:GetAIBrain().M28AI) then
                    M28Team.UpdateUpgradeTrackingOfUnit(oJustBuilt, true)
                end
            end
        end
    end
end

function OnReclaimStarted(oEngineer, oReclaim)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnReclaimStarted'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnReclaimFinished(oEngineer, oReclaim)
    if M28Utilities.bM28AIInGame then
        --Update the segment that the reclaim is at, or the engineer if hte reclaim doesnt have one
        local sFunctionRef = 'OnReclaimFinished'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just finished reclaiming, gametime='..GetGameTimeSeconds()) end
        if oReclaim and oReclaim.CachePosition then
            --LOG('OnReclaimFinished temp log - remove once confirmed this works - about to update reclaim data near location='..repru(oReclaim.CachePosition))
            ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, oReclaim.CachePosition, 0)
        else
            --LOG('OnReclaimFinished alt temp log - couldnt find reclaim position so will use engineer position')
            ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, oEngineer:GetPosition(), 1)
        end

        --M28 specific
        if M28UnitInfo.IsUnitValid(oEngineer) and oEngineer:GetAIBrain().M28AI then
            --Was the engineer reclaiming an area? if so check if still nearby reclaim
            if oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionReclaimArea then
                --Only keep reclaiming if we dont have lots of mass
                if M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subrefiTeamAverageMassPercentStored] <= 0.7 then
                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
                    if (iLandZone or 0) > 0 then
                        local iTeam =  oEngineer:GetAIBrain().M28Team
                        local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                        local iMinReclaimValue = M28Map.iSignificantMassThreshold
                        --Do we have unclaimed mexes in this zone?
                        if tLZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] then iMinReclaimValue = iMinReclaimValue * 2 end
                        local bWantEnergy = M28Conditions.WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone)
                        if bWantEnergy and EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) and (M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subrefiTeamAverageEnergyPercentStored] >= 0.5 or oEngineer:GetAIBrain():GetEconomyStored('ENERGY') >= 2000 or oUnit:GetAIBrain()[M28Economy.refiGrossEnergyBaseIncome] >= 50) then
                            iMinReclaimValue = 150 --only want a tree group
                        end
                        --GetEngineerToReclaimNearbyArea(oEngineer, iPriorityOverride, tLZOrWZTeamData, iPlateauOrPond, iLandOrWaterZone, bWantEnergyNotMass,                   bOnlyConsiderReclaimInRangeOfEngineer, iMinIndividualValueOverride, bIsWaterZone)
                        M28Engineer.GetEngineerToReclaimNearbyArea(oEngineer, nil,              tLZTeamData,        iPlateau,   iLandZone, M28Conditions.WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone), tLZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex], iMinReclaimValue)
                    end
                end
            elseif EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then
                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
                if (iLandZone or 0) > 0 then
                    local iTeam =  oEngineer:GetAIBrain().M28Team
                    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                    M28ACU.ConsiderNearbyReclaimForACUOrEngineer(iPlateau, iLandZone, tLZData, tLZTeamData, oEngineer, true)
                end
            elseif M28Utilities.IsTableEmpty(oReclaim[M28Engineer.reftUnitsReclaimingUs]) == false then
                local tEngineersToClear = {}
                for iEngineer, oEngineer in oReclaim[M28Engineer.reftUnitsReclaimingUs] do
                    if M28UnitInfo.IsUnitValid(oEngineer) then
                        table.insert(tEngineersToClear, oEngineer)
                    end
                end
                for iEngineer, oEngineer in tEngineersToClear do
                    M28Orders.IssueTrackedClearCommands(oEngineer)
                end
            end
        end

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnCreateWreck(tPosition, iMass, iEnergy)
    --Dont check if M28brains are in game yet as can be called at start of game before we have recorded any aiBrain
    if M28Utilities.bM28AIInGame then
        if not(M28Map.bReclaimManagerActive) then
            if GetGameTimeSeconds() >= 20 then return nil
            else
                local iWaitCount = 0
                while not(M28Map.bReclaimManagerActive) do
                    WaitTicks(1)
                    iWaitCount = iWaitCount + 1
                    if iWaitCount >= 50 then M28Utilities.ErrorHandler('Map setup not complete') break end
                end
            end
        end
        --[[if iMass >= 35 then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tPosition)
            local iReclaimSegmentX, iReclaimSegmentZ = M28Map.GetReclaimSegmentsFromLocation(tPosition)
            LOG('OnCreateWreck: Time='..GetGameTimeSeconds()..'; iMass='..iMass..'; tPosition='..repru(tPosition)..'; will record we want to update reclaim at this location, iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iReclaimSegmentX='..iReclaimSegmentX..'; iReclaimSegmentZ='..iReclaimSegmentZ)
        end--]]
        ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, tPosition, 0)
    end
end

function OnTransportLoad(oUnit, oTransport, bone)
    if M28Utilities.bM28AIInGame then
        local aiBrain = oTransport:GetAIBrain()
        if aiBrain.M28AI then
            --Reduce engis wanted (in case of delay between this being updated and engineer logic running)
            if EntityCategoryContains(M28UnitInfo.refCategoryTransport, oTransport.UnitId) then
                if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                    if oTransport[M28Air.refiEngisWanted] then
                        oTransport[M28Air.refiEngisWanted] = math.max(0, oTransport[M28Air.refiEngisWanted] - 1)
                    end
                end
                --Clear the last assigned unit
                oTransport[M28Air.refoTransportUnitTryingToLoad] = nil
            end

        end
    end
end

function OnTransportUnload(oUnit, oTransport, bone)
    if M28UnitInfo.IsUnitValid(oTransport) and oTransport:GetAIBrain().M28AI then
        oTransport[M28Air.refiTransportTimeSpentWaiting] = 0
    end
end

function OnDetectedBy(oUnitDetected, iBrainIndex)
    --Appears to be called when iBrainIndex detects oUnitDetected, triggers for teammate units but not own units?
    --For now used to make sure we have up to date unit info
    if M28Utilities.bM28AIInGame then
        local aiBrain = ArmyBrains[iBrainIndex]
        --LOG('OnDetectedBy: UnitID='..oUnitDetected.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitDetected)..'; tAllAIBrainsByArmyIndex[iBrainIndex] name='..M28Overseer.tAllAIBrainsByArmyIndex[iBrainIndex].Nickname..'; ArmyBrains nickname='..ArmyBrains[iBrainIndex].Nickname..'; Does entity contain navy='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnitDetected.UnitId))..'; aiBrain.M28AI='..tostring((aiBrain.M28AI or false)))
        M28Team.ConsiderAssigningUnitToZoneForBrain(aiBrain, oUnitDetected) --This function includes check of whether this is an M28 brain, and updates last known position
        if aiBrain.M28AI then
            --Update highest enemy ground unti health
            if M28Map.bFirstM28TeamHasBeenInitialised and M28UnitInfo.IsUnitValid(oUnitDetected) and EntityCategoryContains(M28UnitInfo.refCategoryLandCombat - categories.COMMAND - categories.SUBCOMMANDER - M28UnitInfo.refCategoryLandScout, oUnitDetected.UnitId) then
                local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnitDetected)
                local iMaxHealth = oUnitDetected:GetMaxHealth() + iMaxShield
                if iMaxHealth > (M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyHighestMobileLandHealth] or 0) and M28Map.bMapLandSetupComplete then
                    M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyHighestMobileLandHealth] = iMaxHealth
                end
            end
        end
    end
end

function OnCreate(oUnit, bIgnoreMapSetup)
    if M28Utilities.bM28AIInGame and M28UnitInfo.IsUnitValid(oUnit) then
        local sFunctionRef = 'OnCreate'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



        if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time'..GetGameTimeSeconds()..'; oUnit[M28OnCrRn]='..tostring(oUnit['M28OnCrRn'] or false)..'; M28Map.bMapLandSetupComplete='..tostring(M28Map.bMapLandSetupComplete or false)..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; M28Map.bWaterZoneInitialCreation='..tostring(M28Map.bWaterZoneInitialCreation)..'; Unit brain='..oUnit:GetAIBrain().Nickname..'; Is civliain brain='..tostring(M28Conditions.IsCivilianBrain(oUnit:GetAIBrain()))..'; Unit fraction complete='..oUnit:GetFractionComplete()..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; reprs='..reprs(oUnit)) end
        if (not(M28Map.bMapLandSetupComplete) or not(M28Map.bWaterZoneInitialCreation)) and not(bIgnoreMapSetup) then --Start of game ACU creation happens before we have setup the map
            while not(M28Map.bMapLandSetupComplete) or not(M28Map.bWaterZoneInitialCreation) do
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if GetGameTimeSeconds() >= 5 and M28Map.bMapLandSetupComplete then
                    M28Utilities.ErrorHandler('Water zone initial creation still not done, will stop waiting now')
                    break
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if M28UnitInfo.IsUnitValid(oUnit) then OnCreate(oUnit, true) end
        else
            if not(oUnit['M28OnCrRn']) then
                oUnit['M28OnCrRn'] = true
                oUnit[M28UnitInfo.refiTimeCreated] = math.floor(GetGameTimeSeconds())
                M28Overseer.refiRoughTotalUnitsInGame = M28Overseer.refiRoughTotalUnitsInGame + 1
                M28UnitInfo.GetUnitLifetimeCount(oUnit) --essential so lifetimecount logic works

                M28Team.ConsiderAssigningUnitToZoneForBrain(oUnit:GetAIBrain(), oUnit) --This function includes check of whether this is an M28 brain
                if M28Map.bIsCampaignMap then
                    local tiTeamsConsidered = {[(oUnit:GetAIBrain().M28Team or 0)] = true}
                    for iBrain, oBrain in ArmyBrains do
                        if oBrain.M28AI and not(tiTeamsConsidered[oBrain.M28Team]) then
                            tiTeamsConsidered[oBrain.M28Team] = true
                            M28Team.ConsiderAssigningUnitToZoneForBrain(oBrain, oUnit)
                        end
                    end
                end

                --All units (not just M28 specific):
                M28UnitInfo.RecordUnitRange(oUnit)
                if bDebugMessages == true then LOG(sFunctionRef..': Just recorded unit ranges for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')) end
                if M28Config.M28ShowEnemyUnitNames then
                    local sWZOrLZRef = ''
                    if EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                        local iWaterZone
                        if (iLandZone or 0) == 0 then
                            iWaterZone = M28Map.GetWaterZoneFromPosition(oUnit:GetPosition())
                            if (iWaterZone or 0) > 0 then
                                sWZOrLZRef = 'WZ'..iWaterZone
                            end
                        else
                            sWZOrLZRef = 'LZ'..iLandZone
                        end
                    end
                    if M28Config.M28ShowUnitNames then oUnit:SetCustomName(oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..sWZOrLZRef) end
                end

                --Units with upgrade - update the base threat value
                if EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oUnit.UnitId) then
                    M28UnitInfo.UpdateUnitCombatMassRatingForUpgrades(oUnit) --Will check if unit has enhancements as part of this
                    if oUnit:GetAIBrain().CheatEnabled then ForkThread(M28UnitInfo.FixUnitResourceCheatModifiers, oUnit) end
                end

                --Hydro resource locations
                if EntityCategoryContains(M28UnitInfo.refCategoryHydro, oUnit.UnitId) then
                    --Treat location as no longer having no buildings on it
                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations]) == false then
                        --LOG('About to loop through hydro locations; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; reprs='..reprs(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations]))
                        for iHydroLocation, tHydroLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations] do
                            if M28Utilities.GetDistanceBetweenPositions(tHydroLocation, oUnit:GetPosition()) <= 2 then
                                table.remove(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations], iHydroLocation)
                                break
                            end
                        end
                    end
                elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                    --Treat location as having buildings on it (if we were treating it as unbuilt previously)
                    ForkThread(M28Building.OnMexConstructionStarted, oUnit)
                elseif EntityCategoryContains(M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                    M28Building.RecordUnitsInRangeOfTMLAndAnyTMDProtection(oUnit, nil)
                elseif EntityCategoryContains(M28UnitInfo.refCategoryTMD, oUnit.UnitId) then
                    M28Building.TMDJustBuilt(oUnit)
                end
                if EntityCategoryContains(M28UnitInfo.refCategoryProtectFromTML, oUnit.UnitId) then
                    M28Building.RecordTMLAndTMDForUnitJustBuilt(oUnit)
                end

                --M28 team specific for constructed units - e.g. radar and sonar that are constructed
                if (M28Team.tTeamData[oUnit:GetAIBrain().M28Team][M28Team.subrefiActiveM28BrainCount] or 0) > 0 and oUnit:GetFractionComplete() == 1 then
                    local iTeam = oUnit:GetAIBrain().M28Team
                    if EntityCategoryContains(M28UnitInfo.refCategoryRadar, oUnit.UnitId) then
                        M28Land.UpdateZoneIntelForRadar(oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategorySonar, oUnit.UnitId) then
                        M28Navy.UpdateZoneIntelForSonar(oUnit)
                    end
                end

                --Non-M28 specific for constructed units
                if oUnit:GetFractionComplete() == 1 then
                    M28Building.RecordUnitShieldCoverage(oUnit)
                end
            end

            --M28 specific:


            if oUnit:GetAIBrain().M28AI then
                --Check for upgrading unit transferred to us
                if oUnit.IsUpgrade then
                    local aiBrain = oUnit:GetAIBrain()
                    if bDebugMessages == true then LOG(sFunctionRef..': Upgrading hidden unit detected, Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; aiBrain='..aiBrain.Nickname..'; Is table of mexes and factories empty='..tostring(M28Utilities.IsTableEmpty(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount]))) end
                    if M28Utilities.IsTableEmpty(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount]) == false then
                        local iClosestUnitRef
                        local iClosestUnitTransferCount
                        local iClosestDist = 2
                        local iCurDist


                        for iTransferCount, tUnitTable in aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount] do
                            if M28Utilities.IsTableEmpty(tUnitTable) == false then
                                for iCompletedUnit, oCompletedUnit in tUnitTable do
                                    if M28UnitInfo.IsUnitValid(oCompletedUnit) then
                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oCompletedUnit:GetPosition(), oUnit:GetPosition())
                                        if iCurDist < iClosestDist then
                                            iClosestDist = iCurDist
                                            iClosestUnitRef = iCompletedUnit
                                            iClosestUnitTransferCount = iTransferCount
                                        end
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Finished searching completed units near to unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..', iClosestUnitRef='..(iClosestUnitRef or 'nil')..'; iClosestDist='..iClosestDist) end
                            if iClosestUnitRef then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will track completed unit '..aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iClosestUnitTransferCount][iClosestUnitRef].UnitId..M28UnitInfo.GetUnitLifetimeCount(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iClosestUnitTransferCount][iClosestUnitRef])..' as an upgrading unit, given unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is upgrading and nearby') end
                                M28Team.UpdateUpgradeTrackingOfUnit(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iClosestUnitTransferCount][iClosestUnitRef], false, oUnit.UnitId)
                                table.remove(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iClosestUnitTransferCount], iClosestUnitRef)
                            end
                        end
                    end
                end

                --Cover units transferred to us or cheated in or presumably that we have captured - will leave outside the OnCreate flag above in case the oncreate variable transfers over when a unit is captured/gifted
                if oUnit:GetFractionComplete() == 1 then
                    if EntityCategoryContains(M28UnitInfo.refCategorySML + M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                        --put here as extra redundancy since the 'unpause unit on transfer' code which has something similar didnt fix an issue with a loaded yolona being transferred not then firing
                        ForkThread(M28Building.DelayedConsiderLaunchingMissile, oUnit, 15, true)
                    end
                    if not(oUnit[M28UnitInfo.refbConstructionStart]) and EntityCategoryContains(M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti, oUnit.UnitId) then
                        M28Building.ReserveLocationsForGameEnder(oUnit)
                    end

                    M28Economy.UpdateHighestFactoryTechLevelForBuiltUnit(oUnit) --this includes a check to see if are dealing with a factory HQ
                    M28Economy.UpdateGrossIncomeForUnit(oUnit, false) --This both includes a check of the unit type, and cehcks we havent already recorded
                    if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) and not(oUnit.M28OnConstructedCalled) then
                        ForkThread(M28Economy.UpdateZoneM28MexByTechCount, oUnit) --we run the same logic via onconstructed
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryParagon, oUnit.UnitId) and not(oUnit.M28OnConstructedCalled) then
                        ForkThread(M28Building.JustBuiltParagon, oUnit)
                        --Campaign specific - expand core zones for campaign AI
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryLandHQ + M28UnitInfo.refCategoryAirHQ + categories.COMMAND, oUnit.UnitId) and M28Map.bIsCampaignMap and oUnit:GetAIBrain().CampaignAI then
                        local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, oUnit:GetAIBrain().M28Team)
                        tLZTeamData[M28Map.subrefbCoreBaseOverride] = true
                        if bDebugMessages == true then
                            local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                            LOG(sFunctionRef..': Will set core baes override to true for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' for brain '..oUnit:GetAIBrain().Nickname..' team, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone)
                        end
                        if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and oUnit:GetAIBrain().CampaignAI and (not(M28UnitInfo.IsUnitValid(oUnit:GetAIBrain()[M28ACU.refoPrimaryACU])) or not(EntityCategoryContains(categories.COMMAND, oUnit:GetAIBrain()[M28ACU.refoPrimaryACU]))) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will run ACU thread for this unit') end
                            ForkThread(M28ACU.ManageACU, oUnit:GetAIBrain(), oUnit)
                        end
                    end

                    --Nuke launcher - if have 5+ non-experimental then consider unpausing all existing ones
                    if EntityCategoryContains(M28UnitInfo.refCategorySML, oUnit.UnitId) then
                        ForkThread(M28Overseer.ConsiderUnpausingAllCreatedNukes, oUnit:GetAIBrain().M28Team)
                    end
                    --Consider unpausing this unit regardless of whether it's an SML
                    ForkThread(M28Overseer.DelayedUnpauseOfUnits, {oUnit}, 1)
                    if EntityCategoryContains(M28UnitInfo.refCategorySatellite, oUnit.UnitId) then
                        if bDebugMessages == true then LOG(sFunctionRef..'Novax created, reprs='..reprs(oUnit)) end
                        ForkThread(M28Air.DetachSatellite,oUnit, 1)
                    end
                end
                --General logic that want to make sure runs on M28 units even if theyre not constructed yet or to ensure we cover scenarios where we are gifted units
                local aiBrain = oUnit:GetAIBrain()
                if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnit.UnitId) then
                    M28Air.AddPriorityAirDefenceTarget(oUnit)
                    if EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oUnit.UnitId) then
                        M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityFatboy, true)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMegalith, oUnit.UnitId) then
                        M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityMegalith, true)
                    end
                    --WEAPON PRIORITIES
                elseif EntityCategoryContains(M28UnitInfo.refCategoryGunship, oUnit.UnitId) then
                    M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityGunship, true)
                elseif EntityCategoryContains(M28UnitInfo.refCategoryDestroyer, oUnit.UnitId) then
                    M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityDestroyer, true)
                elseif EntityCategoryContains(M28UnitInfo.refCategoryMissileShip + M28UnitInfo.refCategoryCruiser, oUnit.UnitId) then
                    M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityMissileShip, true)
                elseif EntityCategoryContains(M28UnitInfo.refCategoryBattleship, oUnit.UnitId) then
                    M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityBattleShip, true)
                elseif EntityCategoryContains(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryQuantumGateway + M28UnitInfo.refCategoryMobileLandFactory + M28UnitInfo.refCategorySpecialFactory, oUnit.UnitId) then
                    --If have been gifted factory or created via cheat then want to start building something
                    oUnit[M28Factory.refiTotalBuildCount] = 0
                    if oUnit:GetFractionComplete() >= 1 then
                        ForkThread(M28Factory.DecideAndBuildUnitForFactory, oUnit:GetAIBrain(), oUnit)
                    end
                elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) then
                    M28UnitInfo.SetUnitWeaponTargetPriorities(oUnit, M28UnitInfo.refWeaponPriorityT2Arti, true)
                end
                --Check unit cap
                if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have too many units, expected remaining cap='..(aiBrain[M28Overseer.refiExpectedRemainingCap] or 0)) end
                if (aiBrain[M28Overseer.refiExpectedRemainingCap] or 0) <= 100 then
                    M28Overseer.CheckUnitCap(aiBrain)
                else
                    aiBrain[M28Overseer.refiExpectedRemainingCap] = aiBrain[M28Overseer.refiExpectedRemainingCap] - 1
                end
            end
        end
    end
end

function OnCreateBrain(aiBrain, planName, bIsHuman)
    local sFunctionRef = 'OnCreateBrain'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': aiBrain has just been created at time '..GetGameTimeSeconds()..'; Brain nickname='..(aiBrain.Nickname or 'nil')..'; Has setup been run='..tostring(aiBrain['M28BrainSetupRun'] or false)..'; Brain type='..(aiBrain.BrainType or 'nil')..'; M28Team (if brain setup)='..(aiBrain.M28Team or 'nil')..'; aiBrain.Civilian='..tostring(aiBrain.Civilian or false)..'; .M28AI='..tostring(aiBrain.M28AI or false)..'; .M27AI='..tostring(aiBrain.M27AI or false)..'; M28Overseer.iTimeOfLatestBrainToCheckForM28Logic='..(M28Overseer.iTimeOfLatestBrainToCheckForM28Logic or 'nil')) end
    if M28Overseer.iTimeOfLatestBrainToCheckForM28Logic >= 0 then
        while GetGameTimeSeconds() < M28Overseer.iTimeOfLatestBrainToCheckForM28Logic + 1 do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting for M28Overseer.iTimeOfLatestBrainToCheckForM28Logic (if applicable), Brain='..(aiBrain.Nickname or 'nil')..'; .M28AI='..tostring(aiBrain.M28AI or false)) end
    if not(aiBrain['M28BrainSetupRun']) then
        if M28Config.M28RunProfiling then ForkThread(M28Profiler.ProfilerActualTimePerTick) end
        if bIsHuman == nil then
            if aiBrain.BrainType == "AI" or not(aiBrain.BrainType) or string.find(aiBrain.BrainType, "AI") then bIsHuman = false else bIsHuman = true end
        end
        if not(bIsHuman) and (ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28ai' or ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28aicheat') then
            aiBrain.M28AI = true
            M28Utilities.bM28AIInGame = true
        end

        aiBrain['M28BrainSetupRun'] = true
        while (not(M28Overseer.bBeginSessionTriggered) and GetGameTimeSeconds() < 4) do
            if bDebugMessages == true then LOG(sFunctionRef..': bBeginSessionTriggered not true yet, GameTime='..GetGameTimeSeconds()..'; will wait 1 tick; aiBrain='..aiBrain.Nickname) end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        --Make sure we have checked if this is a scenario map (run for each AI to be safe since minimal load and ensures this happens ahead of any other M28 code)
        M28Overseer.CheckIfScenarioMap()
        if bDebugMessages == true then LOG(sFunctionRef..': M28Map.bIsCampaignMap='..tostring(M28Map.bIsCampaignMap or false)) end

        --Logic to run for all brains
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        M28Map.RecordBrainStartPoint(aiBrain)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bIsHuman then
            LOG('Human player brain '..aiBrain.Nickname..' created; Index='..aiBrain:GetArmyIndex()..'; start position='..repru(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()]))
        else
            --Logic to run just for M28AI
            LOG('OnCreateBrain hook for ai with personality '..ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality)

            if aiBrain.M28AI then
                --Redundancy - if have M27 brain then change this back to false
                if aiBrain.M27AI then aiBrain.M28AI = false end
                LOG('M28 brain created')

                --Copy of parts of aiBrain OnCreateAI that still want to retain
                aiBrain:CreateBrainShared(planName)
                --aiBrain:InitializeEconomyState()
                aiBrain.BrainType = 'AI'
                local per = ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality
                local cheatPos = string.find(per, 'cheat')
                if cheatPos then

                    local AIUtils = import('/lua/ai/aiutilities.lua')
                    AIUtils.SetupCheat(aiBrain, true)
                    ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality = string.sub(per, 1, cheatPos - 1)
                end

                --M28AIBrainClass.OnCreateAI(aiBrain, planName)
                ForkThread(M28Overseer.M28BrainCreated, aiBrain)
            else
                --Reundancy - check M27 isn't being treated as M28AI
                ForkThread(M28Overseer.DelayedM27M28BrainCheck, aiBrain)
            end
        end
    elseif aiBrain.M28AI and aiBrain.M27AI then
        aiBrain.M28AI = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function OnMissileImpactTerrain(self, target, position)
    --LOG('Missile impact terrain at time '..GetGameTimeSeconds()..'; self='..reprs(self))
    --Was this an M28 unit?
    if M28UnitInfo.IsUnitValid(self) and self:GetAIBrain().M28AI then
        local sFunctionRef = 'OnMissileImpactTerrain'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        local tLastOrder = self[M28Orders.reftiLastOrders][self[M28Orders.refiOrderCount]]
        if bDebugMessages == true then LOG(sFunctionRef..': self='..(self.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(self) or 'nil')..'; target='..reprs(target)..'; position='..repru(position)..'; tLastOrder='..reprs(tLastOrder)..'; self[M28Building.refiLastTMLMassKills]='..(self[M28Building.refiLastTMLMassKills] or 'nil')..'; Acual XP='..(self.VetExperience or self.Sync.totalMassKilled or 0)) end
        if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueTMLMissile or M28Utilities.IsTableEmpty(target) == false then
            --Did we not gain any mass kills (e.g. mightve hit the ground deliberately for aoe)
            if (self[M28Building.refiLastTMLMassKills] or 0) == (self.VetExperience or self.Sync.totalMassKilled or 0) then
                if not(self[M28Building.reftTerrainBlockedTargets]) then self[M28Building.reftTerrainBlockedTargets] = {} end
                local tLastTarget = tLastOrder[M28Orders.subreftOrderPosition]

                if M28Utilities.IsTableEmpty(tLastTarget) == false then table.insert(self[M28Building.reftTerrainBlockedTargets], {tLastTarget[1], tLastTarget[2], tLastTarget[3]}) end
                if M28Utilities.IsTableEmpty(tLastTarget) or M28Utilities.GetDistanceBetweenPositions(tLastTarget, target) >= 1 then table.insert(self[M28Building.reftTerrainBlockedTargets], {target[1], target[2], target[3]}) end
                if bDebugMessages == true then LOG(sFunctionRef..': Added locations to blackist, repru of blacklist='..repru(self[M28Building.reftTerrainBlockedTargets])) end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnMissileImpact(self, targetType, targetEntity)
    --LOG('Missile impact at time '..GetGameTimeSeconds()..'; self='..reprs(self))
    local launcher = self.Launcher
    --M28 Specific launcher
    if launcher and M28UnitInfo.IsUnitValid(launcher) and launcher:GetAIBrain().M28AI then
        --Nukes
        if EntityCategoryContains(M28UnitInfo.refCategorySML, launcher.UnitId) then
            M28Building.UpdateForNukeMissileDeath(launcher, self:GetPosition())
        end
    end
end

function OnMapResizeFORSEARCHONLY()  end --So can find onplayableareachange easier
function OnPlayableAreaChange(rect, voFlag)

    local ScenarioUtils = import("/lua/sim/scenarioutilities.lua")
    if type(rect) == 'string' then
        rect = ScenarioUtils.AreaToRect(rect)
    end
    if M28Utilities.bM28AIInGame or GetGameTimeSeconds() <= 5 then M28Map.SetupPlayableAreaAndSegmentSizes(rect) end
    ForkThread(M28Overseer.UpdateMaxUnitCapForRelevantBrains)
    ForkThread(M28Engineer.CheckForSpecialCampaignCaptureTargets)
    --Wait 5s then consider campaign special objectives
    ForkThread(M28Overseer.ConsiderSpecialCampaignObjectives, nil, nil, nil, nil, nil, nil, nil, nil,  5)
    --Update location of nearest friendly base (intended to help if we are applying M28AI to hostile AI)
    ForkThread(M28Map.RefreshCampaignStartPositionsAfterDelay, 5)
end

function CaptureTriggerAdded(FunctionForOldUnit, FunctionForNewUnit, oUnit)
    --Intended for campaign maps where a capture objective gets captured by the enemy, e.g. black sun control centre

    local sFunctionRef = 'CaptureTriggerAdded'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28Utilities.bM28AIInGame and M28Map.bIsCampaignMap then
        oUnit[M28UnitInfo.refbCampaignTriggerAdded] = true
        if not(EntityCategoryContains(categories.MOBILE, oUnit.UnitId)) then

            if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
            if M28UnitInfo.IsUnitValid(oUnit) then
                local aiBrain
                if M28Utilities.IsTableEmpty(M28Overseer.tAllActiveM28Brains) == false then
                    for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                        aiBrain = oBrain
                        if not(oBrain.CampaignAI) then break end
                    end
                    if not(IsAlly(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex())) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Unit is not an ally so will record as a capture target') end
                        M28Engineer.RecordUnitAsCaptureTarget(oUnit)
                    end
                end
            end
        end
        oUnit[M28UnitInfo.refbCampaignTriggerAdded] = true
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DeathTriggerAdded(oUnit)
    oUnit[M28UnitInfo.refbCampaignTriggerAdded] = true
end
function CreateUnitReclaimedTrigger(oUnit)
    oUnit[M28UnitInfo.refbCampaignTriggerAdded] = true
end

function ObjectiveAdded(Type, Complete, Title, Description, ActionImage, Target, IsLoading, loadedTag)
    local sFunctionRef = 'ObjectiveAdded'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; if map setup not complete then will wait for it to be complete') end
    --Wait until map setup complete
    while not(M28Map.bMapLandSetupComplete) or not(M28Map.bWaterZoneInitialCreation) do
        if GetGameTimeSeconds() >= 10 then break end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end


    if M28Utilities.bM28AIInGame then
        --Record capture missions
        if bDebugMessages == true then LOG('Have a mission, Title='..Title..'; Description='..Description..'; Target.captured='..(Target.captured or 'nil')..'; reprs of Target='..reprs(Target)) end
        if Target.captured == 0 then
            if bDebugMessages == true then  LOG('Have a capture mission, is target empty='..tostring(M28Utilities.IsTableEmpty(Target))) end
            --Record every unit to be captured
            if M28Utilities.IsTableEmpty(Target.Units) == false then
                for iEntry, oUnit in Target.Units do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..' in Target; Is valid unit='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        M28Engineer.RecordUnitAsCaptureTarget(oUnit)
                        if bDebugMessages == true then LOG(sFunctionRef..': WIll record unit as capture target assuming it is in a land zone') end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': size of target units='..table.getn(Target.Units)) end
                --If only have 1 unit (i.e. is a key location) then flag to fortify
                if table.getn(Target.Units) == 1 then
                    local oFirstM28Brain
                    for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                        oFirstM28Brain = oBrain
                        if not(oBrain.CampaignAI) then
                            break
                        end
                    end
                    local iTeam = oFirstM28Brain.M28Team
                    local tUnitLZData, tUnitLZTeamData = M28Map.GetLandOrWaterZoneData(Target.Units[1]:GetPosition(), true, iTeam)
                    tUnitLZTeamData[M28Map.subrefLZFortify] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': flagged to fortify zone for unit '..Target.Units[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(Target.Units[1])..' at position '..repru(Target.Units[1]:GetPosition())..'; iTeam='..iTeam) end
                end
            end
        elseif M28Utilities.IsTableEmpty(Target.Units) == false then
            local bOnlyHaveAllies = true
            local bHaveLowHealthAlly = true
            local oFirstM28Brain
            for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                oFirstM28Brain = oBrain
                if not(oBrain.CampaignAI) then
                    break
                end
            end
            local iTeam = oFirstM28Brain.M28Team
            local tUnitsToRepair = {}
            for iUnit, oUnit in Target.Units do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit)))
                    if M28UnitInfo.IsUnitValid(oUnit) then LOG(sFunctionRef..': Unit is valid, Health%='..M28UnitInfo.GetUnitHealthPercent(oUnit)..'; Is enemy='..tostring(IsEnemy(oFirstM28Brain:GetArmyIndex(),  oUnit:GetAIBrain():GetArmyIndex()))..'; IsAlly='..tostring(IsAlly(oFirstM28Brain:GetArmyIndex(),  oUnit:GetAIBrain():GetArmyIndex()))) end
                end

                if M28UnitInfo.IsUnitValid(oUnit) then
                    if IsAlly(oFirstM28Brain:GetArmyIndex(),  oUnit:GetAIBrain():GetArmyIndex()) then
                        if M28UnitInfo.GetUnitHealthPercent(oUnit) < 1 then
                            table.insert(tUnitsToRepair, oUnit)
                        else
                            bHaveLowHealthAlly = false
                        end
                    else
                        bOnlyHaveAllies = false
                        if IsEnemy(oFirstM28Brain:GetArmyIndex(),  oUnit:GetAIBrain():GetArmyIndex()) then
                            --Make sure we are tracking this unit
                            if bDebugMessages == true then LOG(sFunctionRef..': Sent enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to be recorded in case we lack intel of it, is oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam] true for first M28brain='..tostring(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][oFirstM28Brain.M28Team] or false)) end
                            M28Team.AssignUnitToLandZoneOrPond(oFirstM28Brain, oUnit, nil, nil, true)
                            --Track air experimentals as special targets

                            if EntityCategoryContains(M28UnitInfo.refCategoryAllAir * categories.EXPERIMENTAL, oUnit.UnitId) then
                                local bAlreadyIncluded = false
                                if not(M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives]) then M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives] = {}
                                else
                                    for iRecordedUnit, oRecordedUnit in M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives] do
                                        if oRecordedUnit == oUnit then bAlreadyIncluded = true break end
                                    end
                                end
                                if not(bAlreadyIncluded) then
                                    table.insert(M28Team.tTeamData[iTeam][M28Team.reftoEnemyExperimentalAirObjectives], oUnit)
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bHaveLowHealthAlly='..tostring(bHaveLowHealthAlly)..'; Is table of units to repair empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToRepair))) end
            if bHaveLowHealthAlly and M28Utilities.IsTableEmpty(tUnitsToRepair) == false then
                local iPlateauOrZero, iLandOrWaterZone
                local iTeam
                for iBrain, oBrain in ArmyBrains do
                    if oBrain.M28AI then
                        iTeam = oBrain.M28Team
                        if not(oBrain.CampaignAI) then
                            break
                        end
                    end
                end
                for iEntry, oUnit in tUnitsToRepair do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..' in tUnitsToRepair; Is valid unit='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                        local tLZOrWZData
                        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; Unit position='..repru(oUnit:GetPosition())) end
                        if iLandOrWaterZone > 0 then
                            local tLZOrWZTeamData
                            if iPlateauOrZero == 0 then
                                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                            else
                                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                            end
                            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subreftoUnitsToRepair]) then tLZOrWZData[M28Map.subreftoUnitsToRepair] = {} end
                            table.insert(tLZOrWZData[M28Map.subreftoUnitsToRepair], oUnit)
                            M28Air.AddPriorityAirDefenceTarget(oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Added unit to table of units to repair') end
                            --Consider adding this zone as somewhere to drop if it's not adjacent to a core zone
                            if iPlateauOrZero > 0 then
                                local bAdjacentToCoreBase = false
                                if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] then
                                    bAdjacentToCoreBase = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Are in a core base; tLZOrWZTeamData[M28Map.subrefbCoreBaseOverride]='..tostring(tLZOrWZTeamData[M28Map.subrefbCoreBaseOverride])) end

                                elseif M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                    for _, iAdjLZ in tLZOrWZData[M28Map.subrefLZAdjacentLandZones] do
                                        if M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] then
                                            if bDebugMessages == true then LOG(sFunctionRef..': iAdjLZ '..iAdjLZ..' is a core base, midpoint of adjlz='..repru(M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMidpoint])..'; Dist to midpoint of this LZ='..M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefMidpoint], tLZOrWZData[M28Map.subrefMidpoint])..'; Travel distance='..(M28Map.GetTravelDistanceBetweenLandZones(iPlateauOrZero, iLandOrWaterZone, iAdjLZ) or 'nil')) end
                                            bAdjacentToCoreBase = true
                                            break
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to add location as a drop zone target, bAdjacentToCoreBase='..tostring(bAdjacentToCoreBase)..'; iTeam='..iTeam) end
                                if not(bAdjacentToCoreBase) then
                                    --Add to locations for priority transport drop
                                    M28Air.UpdateTransportLocationShortlist(iTeam) --incase not already run
                                    M28Air.AddZoneToPotentialDropZonesSameIslandOrDifPond(iTeam, iPlateauOrZero, iLandOrWaterZone)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have tried toa dd to same island drop list, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; iTeam='..iTeam) end
                                end
                            end
                        end
                    end
                end
                --If only have 1 unit (i.e. is a key location) then flag to fortify
                if table.getn(Target.Units) == 1 then
                    local oFirstM28Brain
                    for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                        oFirstM28Brain = oBrain
                        if not(oFirstM28Brain.CampaignAI) then
                            break
                        end
                    end
                    local iTeam = oFirstM28Brain.M28Team

                    local tUnitLZData, tUnitLZTeamData = M28Map.GetLandOrWaterZoneData(Target.Units[1]:GetPosition(), true, iTeam)
                    tUnitLZTeamData[M28Map.subrefLZFortify] = true
                    if bDebugMessages == true then
                        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(Target.Units[1]:GetPosition())
                        LOG(sFunctionRef..': flagged to fortify zone for repair target, ='..Target.Units[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(Target.Units[1])..' at position '..repru(Target.Units[1]:GetPosition())..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Fortify zone flag='..tostring(M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZFortify] or false))
                    end
                end
            elseif bOnlyHaveAllies then
                if bDebugMessages == true then LOG(sFunctionRef..': Only have allies so setting priority air defence target') end
                for iUnit, oUnit in Target.Units do
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        M28Air.AddPriorityAirDefenceTarget(oUnit)
                    end
                end
            end
        end

        --Record units as objective targets generally (used to trigger onkilled callback from upgrades)
        if M28Utilities.IsTableEmpty(Target.Units) == false then
            for iUnit, oUnit in Target.Units do
                oUnit[M28UnitInfo.refbObjectiveUnit] = true
                --Trigger the on-death for the unit if it is an external factory unit
                if EntityCategoryContains(categories.EXTERNALFACTORYUNIT, oUnit.UnitId) and oUnit.EventCallbacks.OnKilled then
                    oUnit:DoUnitCallbacks('OnKilled')
                end
            end
        end

        --Manual objective checks (e.g. where campaign doesnt use the function for adding objectives)
        M28Engineer.CheckForSpecialCampaignCaptureTargets()
        if bDebugMessages == true then LOG(sFunctionRef..': About to check for special campaign objectives') end
        M28Overseer.ConsiderSpecialCampaignObjectives(Type, Complete, Title, Description, ActionImage, Target, IsLoading, loadedTag)
    end

    ForkThread(M28Overseer.UpdateMaxUnitCapForRelevantBrains)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ReclaimTargetObjectiveAdded(Type, Complete, Title, Description, Target)
    --Triggers when SimObjectives.Reclaim function is called
    --Note that objectiveadded function above will also be triggered
    local sFunctionRef = 'ReclaimTargetObjectiveAdded'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; if map setup not complete then will wait for it to be complete') end
    --Wait until map setup complete
    while not(M28Map.bMapLandSetupComplete) or not(M28Map.bWaterZoneInitialCreation) do
        if GetGameTimeSeconds() >= 10 then break end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end


    if M28Utilities.bM28AIInGame then
        if M28Utilities.IsTableEmpty(Target.Units) == false then
            local oFirstM28Brain
            for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                oFirstM28Brain = oBrain
                if not(oBrain.CampaignAI) then
                    break
                end
            end
            local iPlateauOrZero, iLandOrWaterZone
            local iTeam = oFirstM28Brain.M28Team

            for iEntry, oUnit in Target.Units do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..' in units to reclaim; Is valid unit='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                if M28UnitInfo.IsUnitValid(oUnit) then
                    iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                    local tLZOrWZData
                    if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; Unit position='..repru(oUnit:GetPosition())) end
                    if iLandOrWaterZone > 0 then
                        local tLZOrWZTeamData
                        if iPlateauOrZero == 0 then --Waterzone
                            tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                            tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                        else
                            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                            tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                        end
                        if not(tLZOrWZTeamData[M28Map.subreftoUnitsToReclaim]) then tLZOrWZTeamData[M28Map.subreftoUnitsToReclaim] = {} end
                        table.insert(tLZOrWZTeamData[M28Map.subreftoUnitsToReclaim], oUnit)
                        oUnit[M28UnitInfo.refbIsReclaimTarget] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of units to reclaim in iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; iTeam='..iTeam..'; oFirstM28Brain='..oFirstM28Brain.Nickname..'; Is tLZOrWZTeamData[M28Map.subreftoUnitsToReclaim] empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoUnitsToReclaim]))) end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function OnMissileIntercepted(oLauncher, target, oTMD, position)
    --M28AI specific - also exclude if TMD is owned by the same team, as as of 24/09/2023 there's a bug with FAF where this callback triggers with oTMD being another or the same MML
    if not(oLauncher.Dead) and oLauncher:GetAIBrain().M28AI and M28UnitInfo.IsUnitValid(oTMD) and not(oLauncher:GetAIBrain().M28Team == oTMD:GetAIBrain().M28Team) then
        local sFunctionRef = 'OnMissileIntercepted'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        --MML - record time that were last intercepted if dealing with non-aeo TMD (used to build more MML) for both the MML and the TMD land zones
        if bDebugMessages == true then LOG('Missile intercepted, oLauncher='..oLauncher.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLauncher)..'; is launcher a nuke='..tostring(EntityCategoryContains(M28UnitInfo.refCategorySML, oLauncher.UnitId))..'; is launcher valid='..tostring(M28UnitInfo.IsUnitValid(oLauncher))) end
        if EntityCategoryContains(M28UnitInfo.refCategoryMML, oLauncher.UnitId) then --and not(EntityCategoryContains(categories.AEON, oTMD.UnitId)) and EntityCategoryContains(M28UnitInfo.refCategoryTMD, oTMD.UnitId) then
            local iTeam = oLauncher:GetAIBrain().M28Team
            if bDebugMessages == true then LOG('MML intercepted by tmd, oLauncher='..(oLauncher.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oLauncher) or 'nil')..'; oTMD='..(oTMD.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTMD) or 'nil')..'; Launcher team='..iTeam..'; Launcher brain='..oLauncher:GetAIBrain().Nickname..'; TMD nickname='..oTMD:GetAIBrain().Nickname) end
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oLauncher:GetPosition(), true, oLauncher)
            if (iLandZone or 0) > 0 and iPlateau > 0 then
                local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] = GetGameTimeSeconds()
            end
            local iTMDPlateau, iTMDLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oTMD:GetPosition())
            if (iTMDLandZone or 0) > 0 and iTMDPlateau > 0 and not(iTMDLandZone == iLandZone and iTMDPlateau == iPlateau) then
                local tLZTeamData = M28Map.tAllPlateaus[iTMDPlateau][M28Map.subrefPlateauLandZones][iTMDLandZone][M28Map.subrefLZTeamData][iTeam]
                tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] = GetGameTimeSeconds()
            end
            --sometimes the launcher is receiving its orders from an adjacent zone, so want that adjacnet zone's combat logic to recognise this when deciding whether to syncrhonise shots
            if oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][2] and not( oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][2] == iLandZone and oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][1] == iPlateau) and not( oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][2] == iTMDLandZone and oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][1] == iTMDPlateau) then
                local tAssignedLZTeamData = M28Map.tAllPlateaus[oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][1]][M28Map.subrefPlateauLandZones][oLauncher[M28Land.refiCurrentAssignmentPlateauAndLZ][2]][M28Map.subrefLZTeamData][iTeam]
                tAssignedLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] = GetGameTimeSeconds()
            end
        elseif EntityCategoryContains(M28UnitInfo.refCategorySML, oLauncher.UnitId) and M28UnitInfo.IsUnitValid(oLauncher) then
            if bDebugMessages == true then LOG('Will call nuke missile death logic') end
            M28Building.UpdateForNukeMissileDeath(oLauncher)
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end

end

function DelayedUnpauseOfTransferredUnits(toCapturedUnits, iArmyIndex)
    --Tracks transferred units (to help with spotting upgrades for those already in progress), and also unpauses all units

    local sFunctionRef = 'DelayedUnpauseOfTransferredUnits'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iCapturedUnitCount
    local aiBrain
    local tFactoriesAndMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryMex, toCapturedUnits)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, is tFactoriesAndMexes empty='..tostring(M28Utilities.IsTableEmpty(tFactoriesAndMexes))..'; iArmyIndex='..iArmyIndex..'; Time='..GetGameTimeSeconds()) end
    if M28Utilities.IsTableEmpty(tFactoriesAndMexes) == false then
        for iBrain, oBrain in ArmyBrains do
            if oBrain:GetArmyIndex() == iArmyIndex then
                aiBrain = oBrain
                break
            end
        end
        if aiBrain then
            local tCompletedUnits = {}
            local tUpgradingUnit = {}
            for iUnit, oUnit in tFactoriesAndMexes do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; IsUpgrade='..tostring(oUnit.IsUpgrade or false)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Unit tech level='..M28UnitInfo.GetUnitTechLevel(oUnit)) end
                --if oUnit.IsUpgrade then table.insert(tUpgradingUnit, oUnit)
                if oUnit:GetFractionComplete() == 1 and  M28UnitInfo.GetUnitTechLevel(oUnit) <= 2 then
                    table.insert(tCompletedUnits, oUnit)
                end
            end
            if M28Utilities.IsTableEmpty(tCompletedUnits) == false then
                aiBrain[M28Overseer.refiTransferedUnitCount] = (aiBrain[M28Overseer.refiTransferedUnitCount] or 0) + 1
                iCapturedUnitCount = aiBrain[M28Overseer.refiTransferedUnitCount]
                if not(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount]) then aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount] = {} end
                aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iCapturedUnitCount] = {}
                for iUnit, oUnit in tCompletedUnits do
                    table.insert(aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iCapturedUnitCount], oUnit)
                    --Delayed consideration of launching a missile
                end
                local tMissileLaunchers = EntityCategoryFilterDown(categories.SILO, tCompletedUnits)
                if M28Utilities.IsTableEmpty(tMissileLaunchers) == false then
                    local iCurMissiles
                    for iLauncher, oLauncher in tMissileLaunchers do
                        M28Conditions.DelayedConsiderLaunchingMissile(oLauncher, 1, bCheckHaveMissile)
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of completed units empty='..tostring(M28Utilities.IsTableEmpty(tCompletedUnits))..'; Is table of upgrading units empty='..tostring(M28Utilities.IsTableEmpty(tUpgradingUnit))) end
            if M28Utilities.IsTableEmpty(tCompletedUnits) == false and M28Utilities.IsTableEmpty(tUpgradingUnit) == false then
                local iClosestUnitRef, iClosestDist, iCurDist
                for iUnit, oUnit in tUpgradingUnit do
                    iClosestDist = 2
                    iClosestUnitRef = nil
                    for iCompletedUnit, oCompletedUnit in tCompletedUnits do
                        iCurDist = M28Utilities.GetDistanceBetweenPosition(oCompletedUnit:GetPosition(), oUnit:GetPosition())
                        if iCurDist < iClosestDist then
                            iClosestDist = iCurDist
                            iClosestUnitRef = iCompletedUnit
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished searching completed units near to unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..', iClosestUnitRef='..(iClosestUnitRef or 'nil')..'; iClosestDist='..iClosestDist) end
                    if iClosestUnitRef then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will track completed unit '..tCompletedUnits[iClosestUnitRef].UnitId..M28UnitInfo.GetUnitLifetimeCount(tCompletedUnits[iClosestUnitRef])..' as an upgrading unit, given unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is upgrading and nearby') end
                        M28Team.UpdateUpgradeTrackingOfUnit(tCompletedUnits[iClosestUnitRef], false, oUnit.UnitId)
                        table.remove(tCompletedUnits, iClosestUnitRef)
                    end
                end
            end
        end
    end
    ForkThread(M28Overseer.DelayedUnpauseOfUnits,toCapturedUnits, 1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitSeconds(1) --tried 1 tick but it didnt help
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --[[for iUnit, oUnit in toCapturedUnits do --covered via DelayedUnpauseOfUnits now
        if M28UnitInfo.IsUnitValid(oUnit) then
            M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, false)
        end
    end--]]
    if aiBrain and iCapturedUnitCount then
        aiBrain[M28Overseer.reftoTransferredUnitMexesAndFactoriesByCount][iCapturedUnitCount] = nil
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function OnCaptured(toCapturedUnits, iArmyIndex, bCaptured)
    --looks like if multiple engineers are trying to capture a unit at once this triggers for each engineer
    local sFunctionRef = 'OnCaptured'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time'..GetGameTimeSeconds()..', is toCapturedUnits empty='..tostring(M28Utilities.IsTableEmpty(toCapturedUnits))..'; Army='..reprs(iArmyIndex)..'; Captured='..reprs(bCaptured)) end
    if M28Utilities.bM28AIInGame then
        if bCaptured and M28Utilities.IsTableEmpty(toCapturedUnits) == false then
            --Below is to cover scenarios like FA Mission 6 where a capture target can be captured by the enemy
            if bDebugMessages == true then
                LOG(sFunctionRef..': Will cycle through each captured unit')
                for iUnit, oUnit in toCapturedUnits do
                    LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; owned by '..oUnit:GetAIBrain().Nickname)
                end
            end

            --Is the unit owned by an enemy to the first M28AI in the game?
            local oM28Brain
            for iBrain, oBrain in ArmyBrains do
                if oBrain.M28AI then
                    oM28Brain = oBrain
                    break
                end
            end
            local bCheckForBlackSun = M28Map.bIsCampaignMap
            for iUnit, oUnit in toCapturedUnits do
                if bDebugMessages == true then LOG(sFunctionRef..': Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bCheckForBlackSun='..tostring(bCheckForBlackSun)..'; Is M3P2 active='..tostring(ScenarioInfo.M3P2.Active)..'; Unit brain='..oUnit:GetAIBrain().Nickname) end
                if not(oM28Brain.M28Team == oUnit:GetAIBrain().M28Team) and not(IsAlly(oM28Brain:GetArmyIndex(), iArmyIndex)) then
                    M28Engineer.RecordUnitAsCaptureTarget(oUnit, true)
                    --Cybran M6 - fire black sun if we have just captured it
                elseif bCheckForBlackSun and oUnit.UnitId == 'uec1901' and ScenarioInfo.M3P2.Active and oUnit:GetAIBrain().M28AI and oUnit:GetAIBrain():GetFactionIndex() == M28UnitInfo.refFactionCybran then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to fire black sun to complete cybran campaign - will fire in a bit') end
                    ForkThread(M28Overseer.DelayedCybranFireBlackSun, oUnit:GetAIBrain())
                end
            end
        elseif not(bCaptured) then
            if M28Utilities.IsTableEmpty(toCapturedUnits) == false then
                ForkThread(DelayedUnpauseOfTransferredUnits, toCapturedUnits, iArmyIndex)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ScenarioPlatoonCreated(oPlatoon, strArmy, strGroup, formation, tblNode, platoon, balance)
    local sFunctionRef = 'ScenarioPlatoonCreated'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Scenario platoon created') end
    local tPlatoonUnits = oPlatoon:GetPlatoonUnits()

    if M28Utilities.IsTableEmpty(tPlatoonUnits) == false then
        for iUnit, oUnit in tPlatoonUnits do
            if M28UnitInfo.IsUnitValid(oUnit) then
                if bDebugMessages == true then LOG(sFunctionRef..': Calling onCreate for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                OnCreate(oUnit)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function OnTeleportComplete(self, teleporter, location, orientation)
    local sFunctionRef = 'OnTeleportComplete'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --if bDebugMessages == true then LOG('OnTeleportComplete - self='..reprs(self)..'; teleporter='..reprs(teleporter)..'; location='..reprs(location)) end
    if self:GetAIBrain().M28AI and self[M28ACU.refbACUHasTeleport] then
        --If we arent in a core base then teleport back
        local iTeam = self:GetAIBrain().M28Team
        local tCurLZData, tCurLZTeamData = M28Map.GetLandOrWaterZoneData(self:GetPosition(), true, iTeam)
        if bDebugMessages == true then LOG(sFunctionRef..': tCurLZTeamData[M28Map.subrefLZbCoreBase]='..tostring(tCurLZTeamData[M28Map.subrefLZbCoreBase] or false)) end
        if not(tCurLZTeamData[M28Map.subrefLZbCoreBase]) then
            local tLocationToTeleportTo
            if M28Utilities.IsTableEmpty(self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder]) == false then
                local tPrevLZData, tPrevLZTeamData = M28Map.GetLandOrWaterZoneData(self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder], true, iTeam)
                if tPrevLZTeamData[M28Map.subrefLZbCoreBase] then
                    tLocationToTeleportTo = {self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder][1], self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder][2], self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder][3]}
                end
            end
            if not(tLocationToTeleportTo) then
                tLocationToTeleportTo = {tCurLZTeamData[M28Map.reftClosestFriendlyBase][1], tCurLZTeamData[M28Map.reftClosestFriendlyBase][2], tCurLZTeamData[M28Map.reftClosestFriendlyBase][3]}
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will teleport back to '..repru(tLocationToTeleportTo)) end
            --Add to existing queue due to issue where this callback can take place even though the ACU hasn't compelted its teleport
            if M28Utilities.GetDistanceBetweenPositions(self:GetPosition(), tLocationToTeleportTo) >= 50 then
                --Check we are relatively near the last location we were trying to teleport to
                if M28Utilities.IsTableEmpty(self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder]) == false and M28Utilities.GetDistanceBetweenPositions(self[M28UnitInfo.reftLastLocationWhenGaveTeleportOrder], self:GetPosition()) <= 100 then
                    M28Orders.IssueTrackedTeleport(self, tLocationToTeleportTo, 5, true, 'TelRet', true)
                end
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end