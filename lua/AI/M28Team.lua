---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 07/12/2022 07:50
---

local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Config = import('/mods/M28AI/lua/M28Config.lua')
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')


--Team data variables
bActiveTeamDeathChecker = false
bRecordedAllPlayers = false
iPlayersAtGameStart = 0
iTotalTeamCount = 0 --Increased by 1 each time we create a new team
tTeamData = {} --[x] is the aiBrain.M28Team number - stores certain team-wide information
    --Subteam details
    subrefAirSubteamsInTeam = 'M28AirSubteamInT' --returns table of air subteam numbers in this team
    --Brain details
    subrefbAllEnemiesDefeated = 'M28TeamAllEnemiesDefeated' --true if all enemies of the team have been defeated
    subreftoFriendlyActiveM28Brains = 'M28TeamFriendlyM28Brains' --Stored against tTeamData[brain.M28Team], in sequential order (1,2,3...) rather than the key being any other value (i.e. its not army index), returns table of all M28 brains on the same team (including this one)
    subrefiActiveM28BrainCount = 'ActiveM28Count' --number of active m28 brains we have in the team
    subreftoFriendlyActiveBrains = 'M28TeamFriendlyBrains' --as above, but all friendly brains on this team, tTeamData[brain.M28Team][subreftoFriendlyActiveBrains]
    subreftoEnemyBrains = 'M28TeamEnemyBrains'
    refiHighestBrainResourceMultipler = 'M28HighestMult' --Highest AiX Resource on team (as a number)
    refiHighestBrainBuildMultiplier = 'M28HighestBPMult' --Highest AiX BP modifier on team (as a number)

    --Team economy subrefs
    subrefiTeamGrossEnergy = 'M28TeamGrossEnergy'
    subrefiTeamNetEnergy = 'M28TeamNetEnergy'
    subrefiTeamGrossMass = 'M28TeamGrossMass'
    subrefiTeamNetMass = 'M28TeamNetMass'
    subreftiPrevTeamNetMass = 'M28TeamPrevNetMass' --{[1]=x, [2]=y... up to [5]} -i.e. the net mass value for the prev 5 checks (so can take average)
    subrefiTeamEnergyStored = 'M28TeamEnergyStored'
    subrefiTeamMassStored = 'M28TeamMassStored'
    subrefiTeamLowestEnergyPercentStored = 'M28TeamLowestEnergyPercent'
    subrefiTeamLowestMassPercentStored = 'M28TeamLowestMassPercent'
    subrefbTeamIsStallingEnergy = 'M28TeamStallingEnergy'
    subrefbTeamIsStallingMass = 'M28TeamStallingMass'
    refiTimeOfLastMassStall = 'M28TeamTimeLastMassStall' --Gametimeseconds that we were last stalling mass
    subrefbTooLittleEnergyForUpgrade = 'M28TeamTooLittleEnergyForUpgrade' --true if we havent got an upgrade due to lack of power
    subrefbActiveT1PowerReclaimer = 'M28TeamActiveT1PowerReclaimer'
    subrefbActiveT2PowerReclaimer = 'M28TeamActiveT2PowerReclaimer'
    refbJustBuiltLotsOfPower = 'M28TeamJustBuiltPower' --temporarily set to true after building an early T2/T3 PGen so we dont think for hte few seconds after building it that we are power stalling if we have low % of power
    subrefiLowestEnergyStorageCount = 'M28TeamLowestEStorage' --Lowest number of EStorage owned by an M28 brain on the team
    subrefiGrossEnergyWhenStalled = 'M28TeamGrossEWhenStalled' --Amount of energy team had (gross) when we had a power stall
    refiTimeOfLastEnergyStall = 'M28TeamTimeOfLastEnergyStall'
    refiEnergyWhenAirFactoryLastUnableToBuildAir = 'M28TeamEnergyAirFacUnableToBuildAir' --Team Gross energy when air factory didnt consider building air units due to lack of energy
    refiTimeOfLastEngiSelfDestruct = 'M28TeamTimeOfLastEnegiSelfDestruct'
    refbNeedResourcesForMissile = 'M28TeamNeedResourcesForMissile' --true if are building nuke or smd that needs a missile
    refiTimeOfLastOverflowEngiCheck = 'M28TeamOverflowCheck' --gametimeseconds that we last cleared engineers from recliaming
    refiUpgradedMexCount = 'M28TeamUpgradedMexCount'

    subreftTeamUpgradingHQs = 'M28TeamUpgradingHQs'
    subreftTeamUpgradingMexes = 'M28TeamUpgradingMexes'
    subreftTeamUpgradingACUs = 'M28TeamUpgradingACUs'
    subreftTeamUpgradingOther = 'M28TeamUpgradingOther'
    subrefiMassUpgradesStartedThisCycle = 'M28TeamMassUpgradesThisCycle' --Amount of mass per tick that we have committed in upgrades this cycle
    subrefiEnergyUpgradesStartedThisCycle = 'M28TeamEnergyUpgradesThisCycle' --Amount of energy per tick that we have committed in upgrades this cycle
    subreftTeamEngineersBuildingExperimentals = 'M28TeamEngineersBuildingExperimentals' --table of engineers building an experimental level unit anywhere in our team


    --Tech level and factory details (subteam will track factories in more detail by tech and faction and type)
    subrefiHighestEnemyGroundTech = 'M28TeamHighestEnemyGround'
    subrefiHighestEnemyAirTech = 'M28TeamHighestEnemyAir'
    subrefiHighestEnemyNavyTech = 'M28TeamHighestEnemyNavy'
    subrefiLowestFriendlyLandFactoryTech = 'M28TeamLowestFriendlyGround' --Returns the lowest M28Brain's highest tech of this type, i.e. if an M28 brain has a T1 and T2 land factory, and another has a T3 land factory, then this would return 2.
    subrefiLowestFriendlyAirFactoryTech = 'M28TeamLowestFriendlyAir' --Returns the lowest M28Brain's highest tech of this type, i.e. if an M28 brain has a T1 and T2 air factory, and another has a T3 air factory, then this would return 2.
    subrefiLowestFriendlyNavalFactoryTech = 'M28TeamLowestFriendlyNaval'
    subrefiHighestFriendlyFactoryTech = 'M28TeamHighestFriendlyFactory'
    subrefiHighestFriendlyLandFactoryTech = 'M28TeamHighestFriendlyGround' --Returns the Highest M28Brain's highest tech of this type, i.e. if an M28 brain has a T1 and T2 land factory, and another has a T3 land factory, then this would return 3.
    subrefiHighestFriendlyAirFactoryTech = 'M28TeamHighestFriendlyAir' --Returns the Highest M28Brain's highest tech of this type, i.e. if an M28 brain has a T1 and T2 air factory, and another has a T3 air factory, then this would return 3.
    subrefiHighestFriendlyNavalFactoryTech = 'M28TeamHighestFriendlyNaval'
    --subrefiHighestEnemyMexTech = 'M28TeamHighestEnemyMex' --I.e. 1, 2 or 3
    subrefiTotalFactoryCountByType = 'M28TeamFactoryByType' --[x] is the factory type, returns the number that our team has; factory type per M28Factory.refiFactoryType..., e.g. M28Factory.refiFactoryTypeLand
    refbBuiltLotsOfT3Combat = 'M28TeamBuiltLotsOfT3Combat' --true once we have reached a certain lifetime count of T3 combat units (used e.g. to decide if we want to build an experimental)
    refiTimeLastHadNothingToBuildForAirFactory = 'M28TeamAirFacTimNoBuild' --Gametimeseconds that failed to find something to do with air factory that was our highest tech level
    refiTimeLastHadNothingToBuildForLandFactory = 'M28TeamLandFacTimNoBuild' --Gametimeseconds that failed to find something to do with land fac that was our highest tech level

    --Intel details
    subrefbTeamHasOmni = 'M28TeamHaveOmni' --True if our team has omni vision (i.e. one of our team is an AiX with omni vision)
    subrefbEnemyHasOmni = 'M28EnemyHasOmni' --true if any enemy non-civilian brains have omni vision
    subrefbEnemyBuiltOmni = 'M28EnemyBuiltOmni' --true if any enemy has built omni at any point in the game (used as basic threshold for deciding whether to build things like deceivers)
    subrefiTimeOfScoutingShortlistUpdate = 'M28ScoutShortlistUpd' --Gametimeseconds that last updated the list of scouting locations to update
    subreftLandAndWaterZoneScoutingShortlist = 'M28ScoutShortlistLWZ' --entries 1,2,... (in no particular order) - returns {PlateauOrZero, LandOrWZRef} for any land or water zones where scouting is overdue
    subrefbUseFrigatesAsScoutsByPond = 'M28UseFrgAsScout' --[x] is the pond ref, returns true if frigates should be used as scouts

    --Notable unit count and threat details
    refbDefendAgainstArti = 'M28TeamDefendAgainstArti' --true if enemy has t3 arti or equivelnt
    subreftoT3Arti = 'M28TeamT3Arti' --table of T3 and experimental arti that M28 players on the team have
    reftEnemyTML = 'M28TeamEnTML' --table of enemy TML
    reftEnemyMobileTML = 'M28TeamEnMobTML' --Table of enemy TML, includes cruisers and missile ships
    refbActiveMobileTMLMonitor = 'M28TeamActiveMobTM' --True if have an active monitor for this team
    reftEnemyLandExperimentals = 'M28TeamELandE'
    reftEnemyArtiAndExpStructure = 'M28TeamEArtiExp'
    reftEnemyNukeLaunchers = 'M28TeamENuke'
    reftEnemySMD = 'M28TeamESMD'
    reftEnemyBattleships = 'M28TeamEBS' --table of enemy battleships
    refbEnemySMDBuiltSinceLastNukeCheck = 'M28TeamESMDBuilt' --True when enemy SMD is detected, used to decide to rerun logic for identifying nuke land zone targets for deciding whether to build nuke
    refbEnemySMDDiedSinceLastNukeCheck = 'M28TeamESMDDied' --True when enemy SMD is dies, used to decide to rerun logic for identifying nuke land zone targets for deciding whether to build nuke
    refbEnemyHasSub = 'M28EnemyHasSub' --true if enemy has sub - used to be more cautious with ACU
    reftEnemyACUs = 'M28EnemyACUs' --Table of all enemy ACUs
    refbEnemyHasUpgradedACU = 'M28TeamEnUpgACU' --true if enemy has an ACU that is upgrading or upgraded
    reftCoreLZsTimeOfApproachingACUByPlateauAndZone = 'M28TApprACULZ' --table, entry [iPlateau][iLandZoneRef], returns gametimeseconds that flagged as having an approaching ACU
    reftCloakedEnemyUnits = 'M28CloakedE'
    reftLongRangeEnemyUnits = 'M28LREUn'
    refbStartedOnUnitWantingSpecialShielding = 'M28AGESt' --true if we have sent an order to build a gameender/unit wanting special shielding (currently used to decide if we need to be strict about blacklist locations)

    subrefiAlliedDFThreat = 'M28TeamDFThreat' --Total DF threat
    subrefiAlliedIndirectThreat = 'M28TeamIndirectThreat' --Total indirect threat
    subrefiAlliedGroundAAThreat = 'M28TeamGroundAAThreat' --Total MAA and structure threat
    subrefiAlliedMAAThreat = 'M28TeamMAAThreat' --Total MAA threat only (excludes structure)
    refbEnemyHasPerciesOrBricks = 'M28TeamEnemyHasBrickOrPercy' --true if enemy has percy or brick unit at any time in the game
    refiEnemyHighestMobileLandHealth = 'M28TeamEnemyHighestMobileLandHealth' --Used to calculate storage wanted
    refbDangerousForACUs = 'M28TeamDangerousForACUs' --True if are big threats that mean we should keep ACU at base
    reftEnemyFirebaseByPlateauAndLZ = 'M28TeamEnemyFirebase' --[x] is the plateua, [y] is the LZ, returns the below subrefs
        subrefiNearbyPlateauAndLandZones = 'NrbyPLZ' --ordered 1, 2 etc. in order that added, returning {iPlateau, iLandZone} for any land zone that shoudl consider itself in range of the firebase in question
        subrefbInRangeOfCoreLZ = 'NearCLZ' --true if one of the land zones this firebase is likely in range of is a core land zone

    --Land combat related
    subrefiLandZonesWantingSupportByPlateau = 'M28TeamLZWantingSupport' --[x] is the plateau ref, [y] is the land zone ref, returns true if we want support for the plateau
    subrefiLandZonesWantingMAAByPlateau = 'M28TeamLZWantingMAA' --[x] is the plateau ,ref, [y] is the land zone ref, returns true if we want MAA support for the plateau
    subrefiWaterZonesWantingSignificantMAAByPlateau = 'M28TeamWZWantingMAA' --[x] is the PLATEAU ref, [y] is the wawter zone ref, returns true if want significant MAA support for the plateau
    subrefiRallyPointLandZonesByPlateau = 'M28TeamLZRallyPoint' --[x] is the plateau ref, then returns a table orderd 1, 2... of land zones that are rally points
    refiTimeOfLastRallyPointRefresh = 'M28TeamRallyPointRefreshTime' --Game time in seconds that last refreshed rally points
    refiLastTimeNoShieldTargetsByPlateau = 'M28TeamLastTimeNoShieldTargets' --[x] is the plateau ref, returns gametime seconds
    refiLastTimeNoShieldBoatTargetsByPond = 'M28TeamLastTimeNoShieldBoatTargets' --[x] is the pond ref, returns gametimeseconds
    refiLastTimeNoStealthTargetsByPlateau = 'M28TeamLastTimeNoStealthTargets' --[x] is the plateau ref, returns gametime seconds
    refiLastTimeNoMAATargetsByIsland = 'M28TeamLastTimeNoMAATargets' --[x] is the plateau ref, returns gametimeseconds
    reftoUnitsWithDisabledWeapons = 'M28TeamUnitsDisabledWeap' --[x] = 1,2,...; returns unit with disabled weapon
    --Water related
    subrefiRallyPointWaterZonesByPond = 'M28TeamWZRallyPoint' --[x] is the pond ref, then returns a table orderd 1, 2... of water zones that are rally points
    refiTimeLastNoSurfaceCombatTargetByPond = 'M28TeamLastTimeNoSurfTarget' --[x] is the pond ref, returns gametimeseconds that had surface bomat units with no target
    refiTimeLastNoSubCombatTargetByPond = 'M28TeamLastTimeNoSubTarget' --[x] is the pond ref, returns gametimeseconds that had submersible combat units with no target

    --Air related
    reftoAllEnemyAir = 'M28TeamEnemyAirAll'
    reftoEnemyAirAA = 'M28TeamEnemyAirAAUnits' --Table of enemy AirAA units
    reftoEnemyAirToGround = 'M28TeamEnemyAirToGroundUnits' --Table of enemy air to ground units
    reftoEnemyTorpBombers = 'M28TeamEnemyTorpUnits' --table of enemy units that are torpedo bombers
    reftoEnemyAirOther = 'M28TeamEnemyAirOtherUnits' --AIr scouts and transports
    reftoEnemyUnitsWithNoLZ = 'M28TeamEnemyNoLZAir' --AIr units that arent currently over a land zone
    refiEnemyAirAAThreat = 'M28TeamEnemyAirAAThreat'
    refiEnemyAirToGroundThreat = 'M28TeamEnemyAirToGroundThreat'
    refiEnemyTorpBombersThreat = 'M28TeamEnemyTorpBomberThreat'
    refiEnemyAirOtherThreat = 'M28TeamEnemyAirOtherThreat'
    refiTimeOfLastAirStagingShortage = 'M28TeamTimeAirStagingShortage' --Gametimeseconds that a team member last had units that had nowhere to refuel
    reftoEnemyExperimentalAirObjectives = 'M28TeamEnemyAirExp' --Table of enemy air experimentals that we need to destroy
    --subrefiOurGunshipThreat - uses same ref as air subteam
    --subrefiOurBomberThreat - uses same ref as air subteam

    refiTimeOfLastTransportShortlistUpdate = 'M28TeamAirTimeTransportShortlist' --Gametimeseconds that last updated the list of potential locations to do transport engi drops to
    reftTransportIslandDropShortlist = 'M28TeamAirTransportShortlist' --key is 1,2....x, returns {iPlateau, iIsland} - shortlist of plateau and island references that want to consider a transport drop for
    reftTransportFarAwaySameIslandPlateauLandZoneDropShortlist = 'M28TeamAirTransCurIslShortlist' --key is 1,2,...x, returns {iPlateau, iLandZone}, being locations on the same island as a base that want a drop due to how far away they are
    reftiPotentialDropIslandsByPlateau = 'M28TeamAirPotentialDropIslands' --List of islands by plateau that have mexes in them and no enemy start position
    reftiPotentialDropZonesByPlateau = 'M28TeamAirPotDropZones' --[x] is plateau, [y] = 1,2,...x, returns land zone ref for that plateau that we are happy to try and drop with a transport
    refiLastFailedIslandDropTime = 'M28TeamAirLastFailedDrop' --Gametimeseconds where we last had a transport die while trying to drop this plateau
    refiLastFailedIslandAndZoneDropTime = 'M28TeamTrLstFailDByIZ' --[x] is the island, [y] is the land zone, returns gametimeseconds where we last had a transport die while tryign to drop

    --Misc details
    reftiTeamMessages = 'M28TeamMessages' --against tTeamData[aiBrain.M28Team], [x] is the message type string, returns the gametime that last sent a message of this type to the team
    subrefNukeLaunchLocations = 'M28NukeLocations' --locations that we have nuked recently
    reftoRecentlyFiredAlliedNukeLaunchers = 'M28ANukeLaunchers' --table of M28 owned nuke launchers that have recently fired a missile
    refiTimeLastNearUnitCap = 'M28TimeLastNearUnitCap'
    refiLowestUnitCapAdjustmentLevel = 'M28LowestCapAdj' --i.e. 0 is after ctrlking the most types of units, so lower = closer to cap
    refiPriorityPondValues = 'M28PriorityPonds' --Table of ponds that are considered sufficiently high value for our team, [x] is the pond, returns the value of hte pond
    refbAlreadyCheckedForUnitsToShare = 'M28CheckedUnitsShare' --true if already run logic for campaign to share units at start of game
    refiConstructedExperimentalCount = 'M28ConstructedExpCount' --Total number of experimentals constructed
    --reftoSpecialUnitsToProtect = 'M28SpecialUnitsToProtect' --table of units to protect e.g. for air units - e.g. repair targets for a campaign



--AirSubteam data variables
iTotalAirSubteamCount = 0
tAirSubteamData = {}
    subreftoFriendlyM28Brains = 'M28Brains' --table of friendly M28 brains
    subrefiMaxScoutRadius = 'M28ASTMaxScoutRadius' --Search range for scouts for this AirSubteam
    refbFarBehindOnAir = 'M28ASTFarBehindOnAir' --true if we are far behind on air
    refbHaveAirControl = 'M28ASTHaveAirControl'
    reftACUExpAndPriorityDefenceOnSubteam = 'M28ASTACUExp' --Friendly ACUs and experimentals
    subrefiOurAirAAThreat = 'M28ASTOurAirAA' --Our AirAA threat
    subrefiOurGunshipThreat = 'M28ASTOurGShip' --Our gunship threat; also used as a team variable
    subrefiOurTorpBomberThreat = 'M28ASTOurTBmbT' --Our torp bomber threat
    subrefiOurBomberThreat = 'M28ASTOurBomb' --Our bomber threat; also used as a team variable
    refbTooMuchGroundNavalAAForTorpBombers = 'M28TooMuchAAForTorps' --true if have avoided targeting a water zone with torps due to groundAA threat in a water zone
    refbNoAvailableTorpsForEnemies = 'M28NoAvailTorps' --true if have enemy naval unit in a wz we want to defend, and we lack available torp bombers
    reftAirSubRallyPoint = 'M28ASTRally' --Contains the location of the air subteam's rally point
    reftAirSubSupportPoint = 'M28ASTSuppR' --Contains the location for airaa units to go to support a priority unit
    reftiTorpedoDefenceWaterZones = 'M28ASTTorpDef' --Contains water zones that want torpedo bombers to consider defending
    refoFrontGunship = 'M28ASTFrntGshp' --Front available gunship
    refiTimeLastTriedBuildingTransport = 'M28TimeLastTrns' --Gametimeseconds that someone on air subteam tried building an air transport
    refbGunshipsHadAttackOrderLastCycle = 'M28GunshipAtck' --True if the last time we ran gunship cycle we had a unit to attack (to reduce likelihood gunships appraoch somewhere then upon entering a new zone with slightly different adjacent enemy zones we decide to retreat)
    reftPriorityUnitsWantingScout = 'M28PriUnFrSct' --e.g. if gunship wants an air scout to help reveal cloaked units, this would include the gunship to shadow
    refiLastTorpBomberAdjacencyLevel = 'M28ASTLastTBAdj' --i.e. 3 means we last looked up to 3 adjacency levels out for targets


--Land subteam data varaibles (used for factory production logic)
iTotalLandSubteamCount = 0
tLandSubteamData = {} --tLandSubteamData[oBrain.M28LandSubteam] results in the below subrefs
    subrefiLandCorePlateau = 'M28LSTPlateau' --Plateau number that the land subteam is based on
    subrefiLandCoreIsland = 'M28LSTIsland' --Island number that the land subteam is based on
    --subreftoFriendlyM28Brains = 'M28Brains' --Uses same ref as air subteam
    subrefFactoriesByTypeFactionAndTech = 'M28LSTFactoriesByPlateau' --First value is factory type; secont value is faction (M28UnitInfo.refFactionxxxx), third is tech level
    subrefBlueprintBlacklist = 'M28LSTBlueprintBlacklist' --Check with M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subrefBlueprintBlacklist][sUnitId] - returns true if we have blacklisted the unit


--Other variables dependent on above:
tEnemyBigThreatCategories = { [reftEnemyLandExperimentals] = M28UnitInfo.refCategoryLandExperimental, [reftEnemyArtiAndExpStructure] = M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalStructure, [reftEnemyNukeLaunchers] = M28UnitInfo.refCategorySML, [reftEnemySMD] = M28UnitInfo.refCategorySMD, [reftEnemyBattleships] = M28UnitInfo.refCategoryNavalSurface * categories.BATTLESHIP }


function CreateNewLandSubteam(iPlateau, iIsland, tM28BrainsInSubteam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateNewLandSubteam'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    iTotalLandSubteamCount = iTotalLandSubteamCount + 1
    tLandSubteamData[iTotalLandSubteamCount] = {}
    tLandSubteamData[iTotalLandSubteamCount][subrefiLandCorePlateau] = iPlateau
    tLandSubteamData[iTotalLandSubteamCount][subrefiLandCoreIsland] = iIsland
    tLandSubteamData[iTotalLandSubteamCount][subrefBlueprintBlacklist] = {}

    tLandSubteamData[iTotalLandSubteamCount][subreftoFriendlyM28Brains] = {}
    for iBrain, oBrain in tM28BrainsInSubteam do
        table.insert(tLandSubteamData[iTotalLandSubteamCount][subreftoFriendlyM28Brains], oBrain)
        oBrain.M28LandSubteam = iTotalLandSubteamCount
    end
    tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech] = {[M28Factory.refiFactoryTypeLand] = {},
                                                                                     [M28Factory.refiFactoryTypeAir] = {},
                                                                                     [M28Factory.refiFactoryTypeNaval] = {},
                                                                                     [M28Factory.refiFactoryTypeOther] = {}}
    for iFactoryType, tSubtable in tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech] do
        tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech][iFactoryType] = {[M28UnitInfo.refFactionUEF] = {},
                     [M28UnitInfo.refFactionAeon] = {},
                     [M28UnitInfo.refFactionCybran] = {},
                     [M28UnitInfo.refFactionSeraphim] = {},
                     [M28UnitInfo.refFactionNomads] = {},
                     [M28UnitInfo.refFactionUnrecognised] = {}}
        for iFaction, tSubtable in tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech][iFactoryType] do
            tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFaction] = {[1]=0,[2]=0,[3]=0}
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Finished creating subteam for '..iTotalLandSubteamCount..'; tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech]='..repru(tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech])) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end



function CreateNewAirSubteam(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateNewAirSubteam'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    iTotalAirSubteamCount = iTotalAirSubteamCount + 1
    aiBrain.M28AirSubteam = iTotalAirSubteamCount
    tAirSubteamData[aiBrain.M28AirSubteam] = {}
    tAirSubteamData[aiBrain.M28AirSubteam][subreftoFriendlyM28Brains] = {}
    tAirSubteamData[aiBrain.M28AirSubteam][reftACUExpAndPriorityDefenceOnSubteam] = {}
    if not(tTeamData[aiBrain.M28Team][subrefAirSubteamsInTeam]) then tTeamData[aiBrain.M28Team][subrefAirSubteamsInTeam] = {} end
    table.insert(tTeamData[aiBrain.M28Team][subrefAirSubteamsInTeam], iTotalAirSubteamCount)

    table.insert(tAirSubteamData[aiBrain.M28AirSubteam][subreftoFriendlyM28Brains], aiBrain)
    local tNearestEnemyBase = M28Map.GetPrimaryEnemyBaseLocation(aiBrain)
    if bDebugMessages == true then LOG(sFunctionRef..': aiBrain='..aiBrain.Nickname..'; Index='..aiBrain:GetArmyIndex()..'; tNearestEnemyBase='..repru(tNearestEnemyBase)..'; Our start point='..repru(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()])) end
    local iOurAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()], tNearestEnemyBase)
    local bSameAirSubteam
    --Low threshold - if within this dist will be grouped regardless of angle difference
    --High threshold - if within certain angle differential then will group if satisfy this distance
    local iDistThresholdLow = math.max(math.min(aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.8, 100), aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.3)
    local iDistThresholdHigh = math.max(math.min(aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.9, 130), aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.5)
    if bDebugMessages == true then LOG(sFunctionRef..': Our dist to enemy='..aiBrain[M28Overseer.refiDistanceToNearestEnemyBase]..'; Low threshold='..iDistThresholdLow..'; High threshold='..iDistThresholdHigh..'; Angle to nearest enemy='..iOurAngleToNearestEnemy) end

    --Cycle through each brain in our team without a AirSubteam and consider if they should be in the same AirSubteam as this brain
    for iBrain, oBrain in tTeamData[aiBrain.M28Team][subreftoFriendlyActiveM28Brains] do
        --Make sure we have a primary base and distance to nearest enemy recorded
        M28Map.GetPrimaryEnemyBaseLocation(oBrain)
        if not(oBrain.M28AirSubteam) and not(oBrain == aiBrain) then
            bSameAirSubteam = false
            local iBaseDistDif = M28Utilities.GetDistanceBetweenPositions(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()])
            if bDebugMessages == true then LOG(sFunctionRef..': Considering ally brain '..oBrain.Nickname..'; iBaseDistDif='..iBaseDistDif..'; iAngleDif='..M28Utilities.GetAngleDifference(iOurAngleToNearestEnemy, M28Utilities.GetAngleFromAToB(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], tNearestEnemyBase))) end
            if iBaseDistDif <= iDistThresholdLow then
                bSameAirSubteam = true
            else
                local iAngleDif = M28Utilities.GetAngleDifference(iOurAngleToNearestEnemy, M28Utilities.GetAngleFromAToB(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], tNearestEnemyBase))
                if iAngleDif <= 40 or (iAngleDif <= 60 and iBaseDistDif <= iDistThresholdHigh) then
                    bSameAirSubteam = true
                else
                    --Are we close to the start position of any of the other brains already recorded in this AirSubteam?
                    for iAirSubteamBrain, oAirSubteamBrain in tAirSubteamData[aiBrain.M28AirSubteam][subreftoFriendlyM28Brains] do
                        if not(oAirSubteamBrain == aiBrain) and not(oAirSubteamBrain == oBrain) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Dist to alternative AirSubteam member '..oAirSubteamBrain.Nickname..' = '..M28Utilities.GetDistanceBetweenPositions(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], M28Map.PlayerStartPoints[oAirSubteamBrain:GetArmyIndex()])) end
                            if M28Utilities.GetDistanceBetweenPositions(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], M28Map.PlayerStartPoints[oAirSubteamBrain:GetArmyIndex()]) <= iDistThresholdLow then
                                bSameAirSubteam = true
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': On same AirSubteam='..tostring(bSameAirSubteam)) end
            if bSameAirSubteam then
                oBrain.M28AirSubteam = aiBrain.M28AirSubteam
                table.insert(tAirSubteamData[aiBrain.M28AirSubteam][subreftoFriendlyM28Brains], oBrain)
            end
        end
    end

    M28Air.AirSubteamInitialisation(aiBrain.M28Team, aiBrain.M28AirSubteam) --Dont fork thread
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateUpgradeTrackingOfUnit(oUnitDoingUpgrade, bUnitDeadOrCompletedUpgrade, sUnitUpgradingRef)
    --bUnitDeadOrCompletedUpgrade is true if  a structure has just died or completed building a structure, in which case the unit might not have been upgrading but want to check
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateUpgradeTrackingOfUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oUnitDoingUpgrade reprs='..reprs(oUnitDoingUpgrade)..'; bUnitDeadOrCompletedUpgrade='..tostring(bUnitDeadOrCompletedUpgrade)..'; sUnitUpgradingRef='..(sUnitUpgradingRef or 'nil')) end

    local sUpgradeTableRef
    if EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnitDoingUpgrade.UnitId) then
        sUpgradeTableRef = subreftTeamUpgradingHQs
    elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnitDoingUpgrade.UnitId) then
        sUpgradeTableRef = subreftTeamUpgradingMexes
    elseif EntityCategoryContains(categories.COMMAND, oUnitDoingUpgrade.UnitId) then
        sUpgradeTableRef = subreftTeamUpgradingACUs
    else
        sUpgradeTableRef = subreftTeamUpgradingOther
    end
    local iTableRefOfUnit

    if M28Utilities.IsTableEmpty(tTeamData[oUnitDoingUpgrade:GetAIBrain().M28Team][sUpgradeTableRef]) == false then
        for iUnit, oUnit in tTeamData[oUnitDoingUpgrade:GetAIBrain().M28Team][sUpgradeTableRef] do
            if oUnit == oUnitDoingUpgrade then
                iTableRefOfUnit = iUnit
                break
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': sUpgradeTableRef='..sUpgradeTableRef..'; Is table of upgrading units empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[oUnitDoingUpgrade:GetAIBrain().M28Team][sUpgradeTableRef]))..'; iTableRefOfUnit if already in table='..(iTableRefOfUnit or 'nil')) end
    if iTableRefOfUnit then
        if bUnitDeadOrCompletedUpgrade then
            local iTeam = oUnitDoingUpgrade:GetAIBrain().M28Team
            table.remove(tTeamData[iTeam][sUpgradeTableRef], iTableRefOfUnit)
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnitDoingUpgrade:GetPosition(), true, oUnitDoingUpgrade)
            local iWaterZone, iPond
            local tLZOrWZTeamData
            if (iLandZone or 0) > 0 then tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
            else
                iWaterZone = M28Map.GetWaterZoneFromPosition(oUnitDoingUpgrade:GetPosition())
                iPond = M28Map.tiPondByWaterZone[iWaterZone]
                if iWaterZone > 0 and iPond > 0 then
                    tLZOrWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][iTeam]
                end
            end
            if M28Utilities.IsTableEmpty(tTeamData[iTeam][M28Map.subrefActiveUpgrades]) == false then
                for iUnit, oUnit in tTeamData[iTeam][M28Map.subrefActiveUpgrades] do
                    if oUnit == oUnitDoingUpgrade then
                        if bDebugMessages == true then LOG(sFunctionRef..': About to remove unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from the table of upgrades for the team '..iTeam..'; Unit iPlateau='..iPlateau..'; iLZ='..iLandZone) end
                        table.remove(tTeamData[iTeam][M28Map.subrefActiveUpgrades], iUnit)
                        break
                    end
                end
            end
            --Remove from land zone list of upgrades
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefActiveUpgrades]) == false then
                for iUnit, oUnit in tLZOrWZTeamData[M28Map.subrefActiveUpgrades] do
                    if oUnit == oUnitDoingUpgrade then
                        if bDebugMessages == true then LOG(sFunctionRef..': About to remove unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from the table of upgrades for iPlateau '..iPlateau..'; iLZ='..(iLandZone or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')) end
                        table.remove(tLZOrWZTeamData[M28Map.subrefActiveUpgrades], iUnit)
                    end
                end
            end
        elseif bDebugMessages == true then LOG(sFunctionRef..': Unit already in the table so wont readd it')
        end
    else
        if not(bUnitDeadOrCompletedUpgrade) then
            local iTeam = oUnitDoingUpgrade:GetAIBrain().M28Team
            table.insert(tTeamData[iTeam][sUpgradeTableRef], oUnitDoingUpgrade)
            if sUnitUpgradingRef then
                local oNewUnitBP = __blueprints[sUnitUpgradingRef]
                if bDebugMessages == true then LOG(sFunctionRef..': About to update the energy and mass upgrades started this cycle for the unti energy and amss costs. Mass upgrade before this='..tTeamData[iTeam][subrefiMassUpgradesStartedThisCycle]) end
                if oNewUnitBP then
                    local iOurBuildPower = oUnitDoingUpgrade:GetBlueprint().Economy.BuildRate
                    local iBuildCost = oNewUnitBP.Economy.BuildTime
                    if iBuildCost > 0 and iOurBuildPower > 0 then
                        local iResourceFactor = 0.1 * iOurBuildPower / iBuildCost
                        tTeamData[iTeam][subrefiEnergyUpgradesStartedThisCycle] = (tTeamData[iTeam][subrefiEnergyUpgradesStartedThisCycle] or 0) + (oNewUnitBP.Economy.BuildCostEnergy or 0) * iResourceFactor
                        tTeamData[iTeam][subrefiMassUpgradesStartedThisCycle] = (tTeamData[iTeam][subrefiMassUpgradesStartedThisCycle] or 0) + (oNewUnitBP.Economy.BuildCostMass or 0) * iResourceFactor
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Updated this cycle check, tTeamData[iTeam][subrefiMassUpgradesStartedThisCycle]='..tTeamData[iTeam][subrefiMassUpgradesStartedThisCycle]) end
            end
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnitDoingUpgrade:GetPosition(), true, oUnitDoingUpgrade)
            local iWaterZone, iPond
            local tLZOrWZTeamData
            if (iLandZone or 0) > 0 then tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
            else
                iWaterZone = M28Map.GetWaterZoneFromPosition(oUnitDoingUpgrade:GetPosition())
                iPond = M28Map.tiPondByWaterZone[iWaterZone]
                if iWaterZone > 0 and iPond > 0 then
                    tLZOrWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][iTeam]
                end
            end
            if not(tLZOrWZTeamData) then
                local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnitDoingUpgrade:GetPosition())
                if (iPlateauOrZero or -1) >= 0 then
                    if iPlateauOrZero == 0 then
                        tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
                        iWaterZone = iLandOrWaterZone
                    else
                        iLandZone = iLandOrWaterZone
                        iPlateau = iPlateauOrZero
                        tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': tTeamData[iTeam][M28Map.subrefActiveUpgrades] before adding unit='..reprs(tTeamData[iTeam][M28Map.subrefActiveUpgrades])) end
            if tLZOrWZTeamData then
                if not(tLZOrWZTeamData[M28Map.subrefActiveUpgrades]) then
                    tLZOrWZTeamData[M28Map.subrefActiveUpgrades] = {}
                    if bDebugMessages == true then LOG(sFunctionRef..': LZ Upgrade was nil so making it a table, reprs='..reprs(tLZOrWZTeamData[M28Map.subrefActiveUpgrades])) end
                end
                table.insert(tLZOrWZTeamData[M28Map.subrefActiveUpgrades], oUnitDoingUpgrade)
                if bDebugMessages == true then LOG(sFunctionRef..': Just added unit to the upgrade table for the team '..iTeam..'; Plateau '..iPlateau..'; LZ='..(iLandZone or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'; Is table of active upgrades empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefActiveUpgrades]))..'; Reprs of tLZOrWZTeamData[activeupgrades]='..reprs(tLZOrWZTeamData[M28Map.subrefActiveUpgrades])) end
            end
        elseif bDebugMessages == true then LOG(sFunctionRef..': Unit dead or compelted, but not in the table so no need to remove it')
        end
    end

    --Clear trackers from the unit that was doing the upgrade

    if bUnitDeadOrCompletedUpgrade and oUnitDoingUpgrade.UnitId then
        if bDebugMessages == true then LOG(sFunctionRef..': Just finished upgrading '..(oUnitDoingUpgrade.UnitId or 'nil')..M28UnitInfo.GetUnitLifetimeCount(oUnitDoingUpgrade)..'; is table of units assisting this empty='..tostring(M28Utilities.IsTableEmpty(oUnitDoingUpgrade[M28UnitInfo.reftoUnitsAssistingThis]))) end
        if M28Utilities.IsTableEmpty(oUnitDoingUpgrade[M28UnitInfo.reftoUnitsAssistingThis]) == false then
            local tUnitsToClear = {}
            for iUnit, oUnit in oUnitDoingUpgrade[M28UnitInfo.reftoUnitsAssistingThis] do
                if M28UnitInfo.IsUnitValid(oUnit) and EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) and oUnit[M28Engineer.refiAssignedAction] == M28Engineer.refActionAssistUpgrade then
                    table.insert(tUnitsToClear, oUnit)
                end
            end
            if M28Utilities.IsTableEmpty(tUnitsToClear) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Just finished upgrading '..oUnitDoingUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitDoingUpgrade)..'; will clear assisting engineers, table size='..table.getn(tUnitsToClear)) end
                for iUnit, oUnit in tUnitsToClear do
                    M28Orders.IssueTrackedClearCommands(oUnit)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function InitialTeamInitialisationForReference() end --To help find the below more easily
function CreateNewTeam(aiBrain)
    --See also TeamInitialisation which sets up team variables for zones
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateNewTeam'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    iTotalTeamCount = iTotalTeamCount + 1
    tTeamData[iTotalTeamCount] = {}
    tTeamData[iTotalTeamCount][subreftoFriendlyActiveM28Brains] = {}
    tTeamData[iTotalTeamCount][subreftoFriendlyActiveBrains] = {}
    tTeamData[iTotalTeamCount][subrefbTeamHasOmni] = false
    tTeamData[iTotalTeamCount][subrefbEnemyHasOmni] = false
    tTeamData[iTotalTeamCount][subreftoEnemyBrains] = {}
    tTeamData[iTotalTeamCount][subrefiActiveM28BrainCount] = 0
    tTeamData[iTotalTeamCount][subreftTeamUpgradingOther] = {}
    tTeamData[iTotalTeamCount][subreftTeamUpgradingACUs] = {}
    tTeamData[iTotalTeamCount][subreftTeamUpgradingMexes] = {}
    tTeamData[iTotalTeamCount][subreftTeamUpgradingHQs] = {}
    tTeamData[iTotalTeamCount][subrefiHighestEnemyGroundTech] = 0
    tTeamData[iTotalTeamCount][subrefiHighestEnemyAirTech] = 0
    tTeamData[iTotalTeamCount][subrefiHighestEnemyNavyTech] = 0
    tTeamData[iTotalTeamCount][subrefbTeamIsStallingEnergy] = false
    tTeamData[iTotalTeamCount][subrefbTeamIsStallingMass] = false
    tTeamData[iTotalTeamCount][subreftiPrevTeamNetMass] = {}
    tTeamData[iTotalTeamCount][subrefiGrossEnergyWhenStalled] = 0
    tTeamData[iTotalTeamCount][refiTimeOfLastEnergyStall] = 0
    tTeamData[iTotalTeamCount][refiTimeOfLastEngiSelfDestruct] = 0
    tTeamData[iTotalTeamCount][refbNeedResourcesForMissile] = false
    tTeamData[iTotalTeamCount][subrefiLandZonesWantingSupportByPlateau] = {}
    tTeamData[iTotalTeamCount][subrefiTotalFactoryCountByType] = {[M28Factory.refiFactoryTypeLand] = 0, [M28Factory.refiFactoryTypeAir] = 0, [M28Factory.refiFactoryTypeNaval] = 0, [M28Factory.refiFactoryTypeOther] = 0}
    tTeamData[iTotalTeamCount][subrefiAlliedDFThreat] = 0
    tTeamData[iTotalTeamCount][subrefiAlliedIndirectThreat] = 0
    tTeamData[iTotalTeamCount][subrefiAlliedGroundAAThreat] = 0
    tTeamData[iTotalTeamCount][subrefiAlliedMAAThreat] = 0
    tTeamData[iTotalTeamCount][refiLastTimeNoShieldTargetsByPlateau] = {}
    tTeamData[iTotalTeamCount][refiLastTimeNoShieldBoatTargetsByPond] = {}
    tTeamData[iTotalTeamCount][refiLastTimeNoStealthTargetsByPlateau] = {}
    tTeamData[iTotalTeamCount][refiLastTimeNoMAATargetsByIsland] = {}
    tTeamData[iTotalTeamCount][refiEnemyHighestMobileLandHealth] = 300
    tTeamData[iTotalTeamCount][reftEnemyFirebaseByPlateauAndLZ] = {}
    tTeamData[iTotalTeamCount][reftEnemyTML] = {}
    tTeamData[iTotalTeamCount][reftEnemyLandExperimentals] = {}
    tTeamData[iTotalTeamCount][reftEnemyArtiAndExpStructure] = {}
    tTeamData[iTotalTeamCount][reftEnemyNukeLaunchers] = {}
    tTeamData[iTotalTeamCount][reftEnemySMD] = {}
    tTeamData[iTotalTeamCount][subreftTeamEngineersBuildingExperimentals] = {}
    tTeamData[iTotalTeamCount][refiLastFailedIslandDropTime] = {}
    tTeamData[iTotalTeamCount][refiLastFailedIslandAndZoneDropTime] = {}
    tTeamData[iTotalTeamCount][subrefbUseFrigatesAsScoutsByPond] = {}
    M28Engineer.tiLastBuildingSizeFromActionForTeam[iTotalTeamCount] = {}
    tTeamData[iTotalTeamCount][refiHighestBrainResourceMultipler] = 1
    tTeamData[iTotalTeamCount][refiHighestBrainBuildMultiplier] = 1
    tTeamData[iTotalTeamCount][refiConstructedExperimentalCount] = 0



    local bHaveM28BrainInTeam = false
    local bHaveOmniVision = false
    for iCurBrain, oBrain in ArmyBrains do
        --First make sure we have recorded all brains (redundancy for AI like dillidalli) - the function below will check if we have already recorded the brain
        ForkThread(M28Events.OnCreateBrain, oBrain, nil, nil)
        --[[if not(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()]) then --redundancy
            local iStartPositionX, iStartPositionZ = oBrain:GetArmyStartPos()
            M28Map.PlayerStartPoints[oBrain:GetArmyIndex()] = {iStartPositionX, GetSurfaceHeight(iStartPositionX, iStartPositionZ), iStartPositionZ}
            M28Overseer.tAllAIBrainsByArmyIndex[oBrain:GetArmyIndex()] = oBrain
        end--]]


        if IsAlly(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()) and not(M28Conditions.IsCivilianBrain(oBrain)) then
            oBrain.M28Team = iTotalTeamCount
            table.insert(tTeamData[iTotalTeamCount][subreftoFriendlyActiveBrains], oBrain)
            if oBrain.M28AI then
                table.insert(tTeamData[iTotalTeamCount][subreftoFriendlyActiveM28Brains], oBrain)
                tTeamData[iTotalTeamCount][subrefiActiveM28BrainCount] = tTeamData[iTotalTeamCount][subrefiActiveM28BrainCount] + 1
                if oBrain.CheatEnabled then
                    tTeamData[iTotalTeamCount][refiHighestBrainResourceMultipler] = math.max(tTeamData[iTotalTeamCount][refiHighestBrainResourceMultipler], tonumber(ScenarioInfo.Options.CheatMult or 1.5))
                    tTeamData[iTotalTeamCount][refiHighestBrainBuildMultiplier] = math.max(tTeamData[iTotalTeamCount][refiHighestBrainBuildMultiplier], tonumber(ScenarioInfo.Options.BuildMult or 1.5))
                    oBrain[M28Economy.refiBrainResourceMultiplier] = tonumber(ScenarioInfo.Options.CheatMult or 1.5)
                    oBrain[M28Economy.refiBrainBuildRateMultiplier] = tonumber(ScenarioInfo.Options.BuildMult or 1.5)
                else
                    oBrain[M28Economy.refiBrainResourceMultiplier] = 1
                    oBrain[M28Economy.refiBrainBuildRateMultiplier] = 1
                end
            end
            bHaveM28BrainInTeam = true
            --Check if we have omni vision for the team
            if oBrain.CheatEnabled and ScenarioInfo.Options.OmniCheat == 'on' then
                tTeamData[iTotalTeamCount][subrefbTeamHasOmni] = true
            end
            --Record brain details in log for ease of reference
            local sAiXref = ''
            if bDebugMessages == true then LOG(sFunctionRef..': Brain '..oBrain.Nickname..': .CheatEnabled='..tostring(oBrain.CheatEnabled or false)..'; ScenarioInfo.Options.CheatMult='..(ScenarioInfo.Options.CheatMult or 'nil')..'; reprs of scenario.options='..reprs(ScenarioInfo.Options)) end
            if oBrain.CheatEnabled then
                sAiXref = ' AiX '..tonumber(ScenarioInfo.Options.CheatMult or 1.5)
            end
            LOG(sFunctionRef..': Recorded non-civilian brain '..oBrain.Nickname..' with index '..oBrain:GetArmyIndex()..' for team '..iTotalTeamCount..sAiXref)
        elseif IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()) and not(M28Conditions.IsCivilianBrain(oBrain)) then
            table.insert(tTeamData[iTotalTeamCount][subreftoEnemyBrains], oBrain)
            --Check if anyone on enemy team has omni
            if oBrain.CheatEnabled and ScenarioInfo.Options.OmniCheat == 'on' then
                tTeamData[iTotalTeamCount][subrefbEnemyHasOmni] = true
            end
        end
        end
    if bDebugMessages == true then LOG(sFunctionRef..': Setup a team with team ref/iTotalTeamCount='..iTotalTeamCount..'; do we have M28 brain in this team='..tostring(bHaveM28BrainInTeam)) end
    if bHaveM28BrainInTeam then
        UpdateTeamHighestAndLowestFactories(iTotalTeamCount)

        --Group allies into AirSubteams based on nearest enemy; then split the air subteam between land subteams if they are in different plateaus
        for iBrain, oBrain in tTeamData[iTotalTeamCount][subreftoFriendlyActiveM28Brains] do
            if not(oBrain.M28AirSubteam) then
                CreateNewAirSubteam(oBrain)
                local tiIslandBrainsInSubteam = {}
                local tiPlateauByIslandRefs = {}
                local iStartPlateau, iStartIsland
                for iBrain, oBrain in tAirSubteamData[oBrain.M28AirSubteam][subreftoFriendlyM28Brains] do
                    iStartPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                    iStartIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                    if (iStartIsland or 0) > 0 then
                        if not(tiIslandBrainsInSubteam[iStartIsland]) then tiIslandBrainsInSubteam[iStartIsland] = {} end
                        table.insert(tiIslandBrainsInSubteam[iStartIsland], oBrain)
                        tiPlateauByIslandRefs[iStartIsland] = iStartPlateau
                    end
                end
                if M28Utilities.IsTableEmpty(tiIslandBrainsInSubteam) == false then
                    for iStartIsland, tBrains in tiIslandBrainsInSubteam do
                        CreateNewLandSubteam(tiPlateauByIslandRefs[iStartIsland], iStartIsland, tBrains)
                    end
                end
            end
        end

        ForkThread(TeamInitialisation, iTotalTeamCount)
    end
    ForkThread(TeamDeathChecker)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordAllPlayers()

    --Call via ForkThread from initialisation, so 1 tick after the first brain will have been created
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAllPlayers'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if not(bRecordedAllPlayers) then
        bRecordedAllPlayers = true
        for iBrain, oBrain in ArmyBrains do
            if not(M28Conditions.IsCivilianBrain(oBrain)) then
                iPlayersAtGameStart = iPlayersAtGameStart + 1
                if not(oBrain.M28Team) then
                    CreateNewTeam(oBrain)
                end
            end
        end
    end


    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

--[[function RemoveUnitFromCurrentLandZone(aiBrain, oUnit)
    M28Utilities.ErrorHandler('To add code')
end--]]

function AddUnitToLandZoneForBrain(aiBrain, oUnit, iPlateau, iLandZone, bIsEnemyAirUnit)
    --If unit already has a land zone assigned then remove this
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddUnitToLandZoneForBrain'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if EntityCategoryContains(categories.MOBILE * categories.AIR, oUnit.UnitId) and not(bIsEnemyAirUnit) and not(EntityCategoryContains(M28UnitInfo.refCategoryEngineer + categories.EXPERIMENTAL, oUnit.UnitId)) then M28Utilities.ErrorHandler('Havent flagged that an air unit is an air unit') end


    local bAddToZone = true
    --The function in M28Land, UpdateUnitPositionsAndLandZone, should remove a unit from a zone if it is in the wrong one based on its position, so no need for below - commented out (pre v1) in case change my mind
    --Decided to re-add, as the second issue is duplicate entries, e.g. where an event triggers for a unit to be added to a land zone


    if oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] and oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28Team] then
        --Is the unit already assigned to this zone?
        if oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28Team][1] == iPlateau and oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28LandTeam][2] == iLandZone then
            if bDebugMessages == true then LOG(sFunctionRef..': Unit is already assigned to this plateau and land zone so will abort adding it') end
            bAddToZone = false
            --[[else
                if bDebugMessages == true then LOG(sFunctionRef..': Unit already has a plateau and LZ assigned but is dif from the desired one so will remove from its current zone first') end
                RemoveUnitFromCurrentLandZone(aiBrain, oUnit)--]]
        end
    end--]]
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Considering adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to iPlateau '..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..' for brain '..aiBrain.Nickname..'; bAddToZone='..tostring(bAddToZone)..'; Is enemy='..tostring(IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()))..'; Is ally='..tostring(IsAlly(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()))) end
    if bAddToZone then
        if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) then oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] = {} end
        oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28Team] = {iPlateau, iLandZone}
        if IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()) then
            if bDebugMessages == true then LOG(sFunctionRef..': Is an enemy so will add to list of enemy air units or enemy units depending on if it is air, Is team data for this plateau and land zone empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team]))..'; aiBrain='..aiBrain.Nickname..'; team='..aiBrain.M28Team..'; Unit position='..repru(oUnit:GetPosition())..'; bIsEnemyAirUnit='..tostring(bIsEnemyAirUnit or false)..'; M28Map.bWaterZoneInitialCreation='..tostring(M28Map.bWaterZoneInitialCreation or false)) end
            if bIsEnemyAirUnit then
                table.insert(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.reftLZEnemyAirUnits], oUnit)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': About to add enemy to table of enemy units, iPlateau='..(iPlateau or 'nil')..'; iLandZOne='..(iLandZone or 'nil')..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is this a T2 arti unit='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId))) end
                table.insert(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefTEnemyUnits], oUnit)
                --T2 arti tracking - consider firebase
                if EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) then
                    M28Land.ConsiderIfHaveEnemyFirebase(aiBrain.M28Team, oUnit)
                end
            end
        elseif IsAlly(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()) then
            table.insert(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZTAlliedUnits], oUnit)
            if M28Config.M28ShowUnitNames then oUnit:SetCustomName(oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'New P'..iPlateau..'LZ'..iLandZone) end
            if EntityCategoryContains(M28UnitInfo.refCategoryTMD, oUnit.UnitId) then
                M28Building.AlliedTMDFirstRecorded(aiBrain.M28Team, oUnit)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Add unit as a friendly unit to Plateau-LZ='..iPlateau..'-'..iLandZone..' and team='..aiBrain.M28Team..'; Is table of friendly units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZTAlliedUnits]))) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function AddUnitToWaterZoneForBrain(aiBrain, oUnit, iWaterZone, bIsEnemyAirUnit)
    --If unit already has a land zone assigned then remove this
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddUnitToWaterZoneForBrain'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if not(M28Map.bWaterZoneInitialCreation) or not(M28Map.bWaterZoneFirstTeamInitialisation) then
        if GetGameTimeSeconds() >= 10 then
            M28Utilities.ErrorHandler('Trying to add unit to water zone but we havent setup initial water zone variables yet, will try waiting 1 second, bWaterZoneInitialCreation='..tostring(M28Map.bWaterZoneInitialCreation or false)..'; M28Map.bWaterZoneFirstTeamInitialisation='..tostring(M28Map.bWaterZoneFirstTeamInitialisation or false))
            WaitSeconds(1)
        else

            while not(M28Map.bWaterZoneInitialCreation) or not(M28Map.bWaterZoneFirstTeamInitialisation) do
                WaitTicks(1)
                if GetGameTimeSeconds() >= 11 then break end
            end
        end
    end

    if EntityCategoryContains(categories.MOBILE * categories.AIR, oUnit.UnitId) and not(bIsEnemyAirUnit) then M28Utilities.ErrorHandler('Havent flagged that an air unit is an air unit') end


    local bAddToZone = true
    --The function in M28Navy, UpdateUnitPositionsAndWaterZone, should also remove a unit from a zone if it is in the wrong one based on its position

    if oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam] and oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][aiBrain.M28Team] then
        --Is the unit already assigned to this zone?
        if oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][aiBrain.M28Team] == iWaterZone then
            if bDebugMessages == true then LOG(sFunctionRef..': Unit is already assigned to this water zone so will abort adding it') end
            bAddToZone = false
            --[[else
                if bDebugMessages == true then LOG(sFunctionRef..': Unit already has a plateau and LZ assigned but is dif from the desired one so will remove from its current zone first') end
                RemoveUnitFromCurrentLandZone(aiBrain, oUnit)--]]
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Considering adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to iWaterZone '..(iWaterZone or 'nil')..' for brain '..aiBrain.Nickname..'; bAddToZone='..tostring(bAddToZone)..'; Is enemy='..tostring(IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()))..'; Is ally='..tostring(IsAlly(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()))..'; bWaterZoneFirstTeamInitialisation='..tostring(M28Map.bWaterZoneFirstTeamInitialisation or false)) end
    if bAddToZone then
        if not(oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam]) then oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam] = {} end
        oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][aiBrain.M28Team] = iWaterZone
        local iPond = M28Map.tiPondByWaterZone[iWaterZone]
        local tWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][aiBrain.M28Team]
        if bDebugMessages == true then LOG(sFunctionRef..': iPond='..(iPond or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'; Team='..(aiBrain.M28Team or 'nil')..'; IsEnemy='..tostring(IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()))..'; Is tWZTeamData empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData))) end
        if IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()) then
            if bDebugMessages == true then LOG(sFunctionRef..': Is an enemy so will add to list of enemy air units or enemy units depending on if it is air; aiBrain='..aiBrain.Nickname..'; team='..aiBrain.M28Team..'; Unit position='..repru(oUnit:GetPosition())..'; bIsEnemyAirUnit='..tostring(bIsEnemyAirUnit or false)) end
            if bIsEnemyAirUnit then
                table.insert(tWZTeamData[M28Map.reftWZEnemyAirUnits], oUnit)
            else
                table.insert(tWZTeamData[M28Map.subrefTEnemyUnits], oUnit)
            end
            --Record if enemy has sub
            if EntityCategoryContains(M28UnitInfo.refCategorySubmarine, oUnit.UnitId) then
                tTeamData[aiBrain.M28Team][refbEnemyHasSub] = true
            end
        elseif IsAlly(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()) then
            oUnit[M28Navy.refiCurrentWZAssignmentValue] = 0 --dont want to retain orders in case it was from an adjacent zone
            table.insert(tWZTeamData[M28Map.subrefWZTAlliedUnits], oUnit)
            if M28Config.M28ShowUnitNames then oUnit:SetCustomName(oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'New WZ'..iWaterZone) end

            if EntityCategoryContains(M28UnitInfo.refCategoryTMD, oUnit.UnitId) then
                M28Building.AlliedTMDFirstRecorded(aiBrain.M28Team, oUnit)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Add unit as a friendly unit to iWaterZone='..iWaterZone..' and team='..aiBrain.M28Team..'; Is table of friendly units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTAlliedUnits]))) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateUnitLastKnownPosition(aiBrain, oUnit, bDontCheckIfCanSeeUnit, bInWaterZone)
    --Only updates the position if the unit isnt on the same team as us (to save space), since we can use :GetPosition() for allied units
    --Checks if the unti needs reassigning if it is a land or naval unit
    local oUnitBrain = oUnit:GetAIBrain()

    if not(oUnitBrain == aiBrain or IsAlly(aiBrain:GetArmyIndex(), oUnitBrain:GetArmyIndex())) then
        if bDontCheckIfCanSeeUnit or M28Conditions.CanSeeUnit(aiBrain, oUnit) then
            if not(oUnit[M28UnitInfo.reftLastKnownPositionByTeam]) then oUnit[M28UnitInfo.reftLastKnownPositionByTeam] = {} end
            local tCurPosition = oUnit:GetPosition()
            oUnit[M28UnitInfo.reftLastKnownPositionByTeam][aiBrain.M28Team] = {tCurPosition[1], tCurPosition[2], tCurPosition[3]} --Do a copy of table as :GetPosition() means it will always update for the unit's latest position even when we lack intel of it
        else
            --Below to try and approximate scenarios where enemy retreats temporarily with the unit and we end up with units thinking the enemy is right infront of them (even though they can see the location it used to be to confirm it isnt there); will approximate by saying if we have friendly units in the same land zone as the last known position, then we can refresh its position
            if not(bInWaterZone) then
                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][aiBrain.M28Team])
                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZTAlliedUnits]) == false then
                    local tCurPosition = oUnit:GetPosition()
                    oUnit[M28UnitInfo.reftLastKnownPositionByTeam][aiBrain.M28Team] = {tCurPosition[1], tCurPosition[2], tCurPosition[3]}
                end
            else
                local iLastSegmentX, iLastSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][aiBrain.M28Team])
                local iWaterZone = M28Map.tWaterZoneBySegment[iLastSegmentX][iLastSegmentZ]
                if iWaterZone then
                    local iPond = M28Map.tiPondByWaterZone[iWaterZone]
                    if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefWZTAlliedUnits]) == false then
                        local tCurPosition = oUnit:GetPosition()
                        oUnit[M28UnitInfo.reftLastKnownPositionByTeam][aiBrain.M28Team] = {tCurPosition[1], tCurPosition[2], tCurPosition[3]}
                    end
                end
            end
        end
    end
end

function ConsiderAssigningUnitToZoneForBrain(aiBrain, oUnit)
    --Assumes called from an event that means we will have visibility of the unit (e.g. directly via intel, or indirectly via weapon firing)
    if aiBrain.M28AI and aiBrain.M28Team then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'ConsiderAssigningUnitToZoneForBrain'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



        if bDebugMessages == true then LOG(sFunctionRef..': Checking at time '..GetGameTimeSeconds()..' if should assign unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to a plateau/other table. Considered for assignment repru='..repru(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam])..'; Unit brain team='..(oUnit:GetAIBrain().M28Team or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
        if M28UnitInfo.IsUnitValid(oUnit) then --redundancy
            if (not(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam]) or not(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team])) and M28UnitInfo.IsUnitValid(oUnit) and not(aiBrain.M28IsDefeated) then
                AssignUnitToLandZoneOrPond(aiBrain, oUnit)
            else
                UpdateUnitLastKnownPosition(aiBrain, oUnit, true)
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function DelayedUnitPlateauAssignment(aiBrain, oUnit, iDelayInTicks, bAlreadyUpdatedPosition, bAlreadyTriedReassignment)
    WaitTicks(iDelayInTicks)
    AssignUnitToLandZoneOrPond(aiBrain, oUnit, bAlreadyUpdatedPosition, bAlreadyTriedReassignment)
end

function RemoveUnitFromBigThreatTable(oDeadUnit)
    --Removes all dead units from each team's listings, assuming oDeadUnit is a big threat
    local sTableRef
    local bIsSMD = false
    if EntityCategoryContains(M28UnitInfo.refCategorySMD, oDeadUnit.UnitId) then bIsSMD = true end
    for sReferenceTable, iCategory in tEnemyBigThreatCategories do
        if EntityCategoryContains(iCategory, oDeadUnit.UnitId) then
            sTableRef = sReferenceTable
            break
        end
    end
    for iTeam, bRecorded in oDeadUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable] do
        local iRevisedIndex = 1
        local iTableSize = table.getn(tTeamData[iTeam][sTableRef])

        for iOrigIndex=1, iTableSize do
            if tTeamData[iTeam][sTableRef][iOrigIndex] then
                if M28UnitInfo.IsUnitValid(tTeamData[iTeam][sTableRef][iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                    --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                    if (iOrigIndex ~= iRevisedIndex) then
                        tTeamData[iTeam][sTableRef][iRevisedIndex] = tTeamData[iTeam][sTableRef][iOrigIndex];
                        tTeamData[iTeam][sTableRef][iOrigIndex] = nil;
                    end
                    iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                else
                    if bIsSMD then tTeamData[iTeam][refbEnemySMDDiedSinceLastNukeCheck] = true end --used to refresh nuke target zone logic
                    tTeamData[iTeam][sTableRef][iOrigIndex] = nil;
                end
            end
        end
    end
end
function LongRangeThreatMonitor(iTeam)
    --Call via forkthread
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'LongRangeThreatMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iTableSize
    local sreftiLastPlateauAndZone = 'M28LRLstPZ'
    local iPlateauOrZero, iLandOrWaterZone
    if bDebugMessages == true then LOG(sFunctionRef..': About to start long range enemy unit monitor for team '..iTeam..'; Is table empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iTeam][reftLongRangeEnemyUnits]))) end
    while M28Utilities.IsTableEmpty(tTeamData[iTeam][reftLongRangeEnemyUnits]) == false do
        --Check all units still alive
        iTableSize = table.getn(tTeamData[iTeam][reftLongRangeEnemyUnits])
        if bDebugMessages == true then LOG(sFunctionRef..': Size of table at time '..GetGameTimeSeconds()..'='..iTableSize) end
        for iCurEntry = iTableSize, 1, -1 do
            local oUnit = tTeamData[iTeam][reftLongRangeEnemyUnits][iCurEntry]
            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
            if not(M28UnitInfo.IsUnitValid(oUnit)) then
                table.remove(tTeamData[iTeam][reftLongRangeEnemyUnits], iCurEntry)
            else
                if oUnit:GetFractionComplete() >= 0.95 then
                    iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                    --Has this changed from last time? if so need to refresh
                    if bDebugMessages == true then LOG(sFunctionRef..': iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; sreftiLastPlateauAndZone='..repru( oUnit[sreftiLastPlateauAndZone])) end
                    if iPlateauOrZero == oUnit[sreftiLastPlateauAndZone][1] and iLandOrWaterZone == oUnit[sreftiLastPlateauAndZone][2] then
                        --Do nothing - no change
                    else
                        --has changed - remove from previous entries if it had any
                        if (oUnit[sreftiLastPlateauAndZone][2] or 0) > 0 then
                            --Remove previous entries if was land zone
                            if (oUnit[sreftiLastPlateauAndZone][1] or 0) > 0 then
                                local tLZData = M28Map.tAllPlateaus[oUnit[sreftiLastPlateauAndZone][1]][M28Map.subrefPlateauLandZones][oUnit[sreftiLastPlateauAndZone][2]]
                                subrefLZPathingToOtherLandZones = 'PathLZ' --table containing the land zone ref of some (but not all) other LZs where have recorded the paths and time taken, sorted by closest LZ first
                                subrefLZNumber = 1 --Land zone reference number
                                subrefLZPath = 2 --against subrefLZPathingToOtherLandZones subtable
                                subrefLZTravelDist = 3 --against subrefLZPathingToOtherLandZones subtable
                                local iAdjLZ
                                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                                    for iEntry, tSubtable in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                                        iAdjLZ = tSubtable[M28Map.subrefLZNumber]
                                        local tAdjLZTeamData = M28Map.tAllPlateaus[oUnit[sreftiLastPlateauAndZone][1]][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                        if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats]) == false then
                                            for iRecordedUnit, oRecordedUnit in tAdjLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats] do
                                                if oUnit == oRecordedUnit then
                                                    table.remove(tAdjLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats], iRecordedUnit)
                                                    break
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end

                        --Add to nearby zones
                        oUnit[sreftiLastPlateauAndZone] = {[1]=iPlateauOrZero,[2]=iLandOrWaterZone}
                        local iMaxDist = oUnit[M28UnitInfo.refiDFRange] + 40
                        local iMaxTravelDist = iMaxDist * 2
                        local tLZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                        local iAdjLZ
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                            for iEntry, tSubtable in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                                if tSubtable[M28Map.subrefLZTravelDist] > iMaxTravelDist then break end
                                iAdjLZ = tSubtable[M28Map.subrefLZNumber]
                                local tAdjLZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ]
                                if bDebugMessages == true then LOG(sFunctionRef..': Checking if we are close to zone '..iAdjLZ..'; Dist to this='..M28Utilities.GetDistanceBetweenPositions(tAdjLZData[M28Map.subrefMidpoint], tLZData[M28Map.subrefMidpoint])..'; iMaxDist='..iMaxDist) end
                                if M28Utilities.GetDistanceBetweenPositions(tAdjLZData[M28Map.subrefMidpoint], tLZData[M28Map.subrefMidpoint]) <= iMaxDist then
                                    local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                                    local bInclude = true
                                    if not(tAdjLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats]) then
                                        tAdjLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats] = {}
                                    else
                                        --Redundancy - make sure not already here
                                        if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats]) == false then
                                            for iRecordedUnit, oRecordedUnit in tAdjLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats] do
                                                if oUnit == oRecordedUnit then
                                                    bInclude = false
                                                    break
                                                end
                                            end
                                        end
                                    end
                                    if bInclude then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Just added unit to table of long range threats for zone '..iAdjLZ..' on plateau '..iPlateauOrZero) end
                                        table.insert(tAdjLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats], oUnit)
                                    end
                                end
                            end
                        end

                    end
                end
            end
        end

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    --Reset (so the monitor gets restarted next time there is a long range enemy threat)
    tTeamData[iTeam][reftLongRangeEnemyUnits] = nil
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AddUnitToLongRangeThreatTable(oUnit, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddUnitToLongRangeThreatTable'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(tTeamData[iTeam][reftLongRangeEnemyUnits]) then
        tTeamData[iTeam][reftLongRangeEnemyUnits] = {}
        ForkThread(LongRangeThreatMonitor, iTeam)
    end
    table.insert(tTeamData[iTeam][reftLongRangeEnemyUnits], oUnit)
    if bDebugMessages == true then LOG(sFunctionRef..': End of code at time '..GetGameTimeSeconds()..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Added to table of long range units and started a monitor if one wasnt already started') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AddUnitToBigThreatTable(iTeam, oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddUnitToBigThreatTable'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Considering ouNIt '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' for iTeam='..iTeam..'; oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable][iTeam]='..(oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable][iTeam] or 'nil')) end
    if not(oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable] and oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable][iTeam]) then
        local bAlreadyInTable = false

        for sReferenceTable, iCategory in tEnemyBigThreatCategories do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering sReferenceTable='..sReferenceTable..'; Does unit contain category for this table='..tostring(EntityCategoryContains(iCategory, oUnit.UnitId))) end
            if EntityCategoryContains(iCategory, oUnit.UnitId) then
                if M28Utilities.IsTableEmpty(tTeamData[iTeam][sReferenceTable]) == false then
                    for iExistingUnit, oExistingUnit in tTeamData[iTeam][sReferenceTable] do
                        if oExistingUnit == oUnit then

                            bAlreadyInTable = true --redundancy
                            if not(oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable]) then oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable] = {} end
                            oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable][iTeam] = true
                            break
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': bAlreadyInTable='..tostring(bAlreadyInTable)) end
                if not(bAlreadyInTable) then

                    if bDebugMessages == true then LOG(sFunctionRef..': About to add unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to reference table. Is table empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iTeam][sReferenceTable]))..'; Unit fraction complete='..oUnit:GetFractionComplete()..'; T3 resource generation units held by owner='..oUnit:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryT3Mex + M28UnitInfo.refCategoryRASSACU + M28UnitInfo.refCategoryParagon)) end
                    table.insert(tTeamData[iTeam][sReferenceTable], oUnit)
                    if not(oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable]) then oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable] = {} end
                    oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable][iTeam] = true
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Have some units for experimental threat category sReferenceTable=' .. sReferenceTable .. '; is tReferenceTableEmpty after considering if civilian or pathable to us='..tostring(M28Utilities.IsTableEmpty(tTeamData[iTeam][sReferenceTable]))..'; tTeamData[iTeam][refbDefendAgainstArti]='..tostring(tTeamData[iTeam][refbDefendAgainstArti] or false)..'; iTeam='..iTeam..'; Is this a T3 arti or novax='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryNovaxCentre + M28UnitInfo.refCategoryExperimentalArti, oUnit.UnitId)))
                    end

                    --Flag if SMD built so can update nuke targeting
                    if EntityCategoryContains(M28UnitInfo.refCategorySMD, oUnit.UnitId) then
                        tTeamData[iTeam][refbEnemySMDBuiltSinceLastNukeCheck] = true
                        local iTimeAssumedConstructed
                        if oUnit:GetNukeSiloAmmoCount() >= 1 or oUnit:GetWorkProgress() >= 0.75 then oUnit[M28UnitInfo.refiTimeOfLastCheck] = (oUnit[M28UnitInfo.refiTimeOfLastCheck] or 0) - 240
                        elseif oUnit:GetFractionComplete() == 1 then oUnit[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds() - 180 - 60 * oUnit:GetWorkProgress()
                        else oUnit[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds() - 60 * oUnit:GetFractionComplete()
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategorySML, oUnit.UnitId) then
                        --Unpause any paused SMD
                        for iBrain, oBrain in tTeamData[iTeam][subreftoFriendlyActiveM28Brains] do
                            local tSMD = oBrain:GetListOfUnits(M28UnitInfo.refCategorySMD, false, true)
                            if M28Utilities.IsTableEmpty(tSMD) == false then
                                for iUnit, oUnit in tSMD do
                                    M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, false)
                                    oUnit:SetAutoMode(true)
                                end
                            end
                        end
                    elseif (oUnit[M28UnitInfo.refiDFRange] or 0) >= 80 then
                        AddUnitToLongRangeThreatTable(oUnit, iTeam)
                    end

                    --Track T3 arti
                    if not(tTeamData[iTeam][refbDefendAgainstArti]) and EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryNovaxCentre + M28UnitInfo.refCategoryExperimentalArti, oUnit.UnitId) then
                        tTeamData[iTeam][refbDefendAgainstArti] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': have set flag to defend against T3 arti to true for team '..iTeam..'; tTeamData[iTeam][refbDefendAgainstArti]='..tostring(tTeamData[iTeam][refbDefendAgainstArti])) end
                        --Refresh shielding wanted on existing units
                        local tPotentialUnitsToShield = tTeamData[iTeam][subreftoFriendlyActiveM28Brains][1]:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryFixedShield - categories.TECH1, {0.5*(M28Map.rMapPlayableArea[1] + M28Map.rMapPlayableArea[3]), 0, 0.5*(M28Map.rMapPlayableArea[2] + M28Map.rMapPlayableArea[4])}, 10000, 'Ally')
                        if M28Utilities.IsTableEmpty(tPotentialUnitsToShield) == false then
                            for iPotentialUnit, oPotentialUnit in tPotentialUnitsToShield do
                                if oPotentialUnit:GetAIBrain().M28AI and oPotentialUnit:GetFractionComplete() == 1 then
                                    M28Building.CheckIfUnitWantsFixedShield(oPotentialUnit, true)
                                end
                            end
                        end
                    end
                end
                break
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

--TO HELP WITH LOCATING - use AssignUnitToLandZoneOrPond
function RecordUnitInPlateauLandZoneOrPond()  end
---@param aiBrain userdata
---@param oUnit userdata
function AssignUnitToLandZoneOrPond(aiBrain, oUnit, bAlreadyUpdatedPosition, bAlreadyTriedReassignment, bIgnoreIfAssignedAlready)
    --Assigns oUnit to relevant table for aiBrain; Should be called if we have a unit that hasn't been considered before (check by referencing oUnit[reftbConsideredForAssignmentByTeam][iTeam]) - will decide whether the unit should be assigned to a pond, a land zone, or air units, based partially on the unit category and partially on its current position
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignUnitToLandZoneOrPond'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if M28UnitInfo.IsUnitValid(oUnit) then
        --Campaign specific - dont include units flagged as not being killable
        if not(oUnit.CanBeKilled == false) or not(oUnit.CanTakeDamage == false) or not(EntityCategoryContains(categories.CIVILIAN * categories.STRUCTURE, oUnit.UnitId) or not(M28Map.bIsCampaignMap)) then

            local bPreviouslyConsidered = (oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team] or false)
            local bIgnore = false
            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by brain '..oUnit:GetAIBrain().Nickname..' - are considering the unit from aiBrain perspective of '..aiBrain.Nickname..' at time '..GetGameTimeSeconds()..'; Have we already considered this unit='..tostring(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team] or false)..'; bIgnoreIfAssignedAlready='..tostring(bIgnoreIfAssignedAlready or false)..'; Is enemy='..tostring(IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()))) end
            if not(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam]) then oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam] = {} end
            if bIgnoreIfAssignedAlready and oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team] then
                --Do nothing
            else
                if not(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team]) then
                    oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team] = true

                    --First time considering the unit for this team
                    --Campaign specific - dont record jamming crystals as units without an aoe cant damage them, leading to strange results - e.g. gunships can end up stuck trying to kill them
                    if oUnit.UnitId == 'xsc9002' and M28Map.bIsCampaignMap then
                        if bDebugMessages == true then LOG(sFunctionRef..': Seraphim jamming crystal - want to ignore since it cant be hit by non aoe gunships') end
                        bIgnore = true
                    else


                        --Record if we are at the stage of the game where experimentals/similar high threats for ACU are present
                        if not(tTeamData[aiBrain.M28Team][refbDangerousForACUs]) then
                            if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy experimental level unit detected, dangerous for ACU') end
                                tTeamData[aiBrain.M28Team][refbDangerousForACUs] = true
                            end
                        end
                        --Enemy based logic
                        if IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()) then
                            if EntityCategoryContains(M28UnitInfo.refCategorySniperBot, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy sniper bot detected, dangerous for ACU') end
                                tTeamData[aiBrain.M28Team][refbDangerousForACUs] = true
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAir * categories.TECH3, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy T3 air detected, enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..', owned by '..oUnit:GetAIBrain().Nickname..' dangerous for ACU') end
                                tTeamData[aiBrain.M28Team][refbDangerousForACUs] = true
                            elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                                --check not already in table of enemy aCUs and add to this table
                                local bInTableAlready = false
                                local iTeam = aiBrain.M28Team
                                if M28Utilities.IsTableEmpty(tTeamData[iTeam][reftEnemyACUs]) == false then
                                    for iACU, oACU in tTeamData[iTeam][reftEnemyACUs] do
                                        if oACU == oUnit then bInTableAlready = true break end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Dealing with an ACU, is table of enemy ACUs empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iTeam][reftEnemyACUs]))..'; bInTableAlready='..tostring(bInTableAlready)) end
                                if not(bInTableAlready) then
                                    if not(tTeamData[iTeam][reftEnemyACUs]) then tTeamData[iTeam][reftEnemyACUs] = {} end
                                    table.insert(tTeamData[iTeam][reftEnemyACUs], oUnit)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Added unit to table of enemy ACUs for team '..iTeam) end
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryMissileShip, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have enemy missile ship '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; will record as mobile TML threat') end
                                ForkThread(RecordMobileTMLThreatForAllEnemyTeams, oUnit)
                            end

                            --If enemy hasnt built omni yet check whether this is omni
                            if not(tTeamData[aiBrain.M28Team][subrefbEnemyBuiltOmni]) and EntityCategoryContains(M28UnitInfo.refCategoryT3Radar, oUnit.UnitId) and not(oUnit:GetAIBrain().M28Team == aiBrain.M28Team) then
                                tTeamData[aiBrain.M28Team][subrefbEnemyBuiltOmni] = true
                            end

                            --Track enemy big threats
                            if bDebugMessages == true then LOG(sFunctionRef..': Is unit a big threat category='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryBigThreatCategories, oUnit.UnitId))) end
                            if EntityCategoryContains(M28UnitInfo.refCategoryBigThreatCategories, oUnit.UnitId) then
                                AddUnitToBigThreatTable(aiBrain.M28Team, oUnit)
                            end

                            --Track potential TML targets and TMD for decision on whether to build TML (TML target selection uses more precise approach
                            if EntityCategoryContains(M28UnitInfo.refCategoryTMD * categories.STRUCTURE, oUnit.UnitId) then
                                local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                                if iPlateauOrZero > 0 and iLandOrWaterZone > 0 then
                                    local tLZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][aiBrain.M28Team]
                                    table.insert(tLZTeamData[M28Map.subreftoEnemyTMD], oUnit)
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryProtectFromTML * categories.STRUCTURE, oUnit.UnitId) then
                                local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                                if iPlateauOrZero > 0 and iLandOrWaterZone > 0 then
                                    local tLZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][aiBrain.M28Team]
                                    table.insert(tLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets], oUnit)
                                end
                            end

                            --Cloaked units
                            if EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oUnit.UnitId) then
                                if oUnit:HasEnhancement('CloakingGenerator') then
                                    M28Events.CloakedUnitIdentified(oUnit)
                                else
                                    local oBP = oUnit:GetBlueprint()
                                    if oBP.Enhancements and oBP.EnhancementPresetAssigned.Enhancements then
                                        for iCurUpgrade, sCurUpgrade in oBP.EnhancementPresetAssigned.Enhancements do
                                            if sCurUpgrade == 'CloakingGenerator' then
                                                M28Events.CloakedUnitIdentified(oUnit)
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        else
                            --Allied unit - dont record if it isnt owned by M28AI brain (so we dont control allied non-M28 units)
                            if not(oUnit:GetAIBrain().M28AI) then
                                bIgnore = true
                            end
                            --Update intel coverage for units being constructed and/or allied units (in addition when a radar/sonar is constructed it will also trigger the below if it hasnt already run as a redundancy)
                            if EntityCategoryContains(M28UnitInfo.refCategoryRadar, oUnit.UnitId) then M28Land.UpdateZoneIntelForRadar(oUnit)
                            elseif EntityCategoryContains(M28UnitInfo.refCategorySonar, oUnit.UnitId) then M28Navy.UpdateZoneIntelForSonar(oUnit)
                            end
                        end
                    end
                elseif bDebugMessages == true then
                    LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has already been considered (considered='..tostring(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team] or false)..')')
                    --M28Utilities.ErrorHandler('Audit trail', true, true)
                end


                if bIgnore or EntityCategoryContains(M28UnitInfo.refCategoryWall + categories.UNSELECTABLE + categories.UNTARGETABLE, oUnit.UnitId) then
                    --Do nothing
                    if bDebugMessages == true then LOG(sFunctionRef..': Unit is insignificant so will ignore, Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                else

                    if not(bAlreadyUpdatedPosition) then
                        UpdateUnitLastKnownPosition(aiBrain, oUnit, true)
                        if IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()) and aiBrain.M28AI then UpdateEnemyTechTracking(aiBrain.M28Team, oUnit) end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': aiBrain '..aiBrain.Nickname..' is Considering how to assign unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that is owned by brain '..oUnit:GetAIBrain().Nickname..' at time '..GetGameTimeSeconds()..'; bPreviouslyConsidered='..tostring(bPreviouslyConsidered or false)) end


                    --Air units - always assign to air groups, and also to land zones if in one
                    if EntityCategoryContains(M28UnitInfo.refCategoryAllAir - M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                        if not(bPreviouslyConsidered) then
                            M28Air.RecordNewAirUnitForTeam(aiBrain.M28Team, oUnit)
                        end
                        if bAlreadyUpdatedPosition then
                            --Re-check the plateau and land/water zone
                            local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                            local bIsEnemyAirUnit
                            if aiBrain.M28Team == oUnit:GetAIBrain().M28Team then bIsEnemyAirUnit = false else bIsEnemyAirUnit = true end
                            if  (iLandOrWaterZone or 0) > 0 then
                                if iPlateauOrZero == 0 then
                                    --Water zone
                                    AddUnitToWaterZoneForBrain(aiBrain, oUnit, iLandOrWaterZone, bIsEnemyAirUnit)
                                else
                                    AddUnitToLandZoneForBrain(aiBrain, oUnit, iPlateauOrZero, iLandOrWaterZone, bIsEnemyAirUnit)
                                end

                                --Presumably air unit has fallen out of a land zone - add to table of enemy air without a LZ
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Failed to find a plateau or zone to position '..repru(oUnit:GetPosition())..' for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                if not(aiBrain.M28Team == oUnit:GetAIBrain().M28Team) then --redundancy, - hopefully shouldnt get to this point if this isnt the case
                                    M28Utilities.ErrorHandler('Obsolete code, wasnt expecting it to be used')
                                    M28Air.RecordEnemyAirUnitWithNoZone(aiBrain.M28Team, oUnit)
                                end
                            end
                        end
                    else
                        if oUnit:IsUnitState('Attached') then
                            --Try reassigning in a bit
                            ForkThread(DelayedUnitPlateauAssignment, aiBrain, oUnit, 5, bAlreadyUpdatedPosition, true)
                        else
                            --Amphibious, hover and naval surface units = check if in water before checking if in land
                            local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnit:GetPosition())
                            local iWaterZone = M28Map.tWaterZoneBySegment[iSegmentX][iSegmentZ]
                            if iWaterZone > 0 and EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will add unit to water zone') end
                                AddUnitToWaterZoneForBrain(aiBrain, oUnit, iWaterZone)
                            else
                                local iPlateau, iLandZone
                                if EntityCategoryContains(categories.LAND * categories.MOBILE, oUnit.UnitId) then
                                    iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                                else
                                    iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                                end
                                if bDebugMessages == true then
                                    LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by brain '..oUnit:GetAIBrain().Nickname..' has iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; Will draw unit position if it has no plateau or zone. Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; iWaterZone='..(iWaterZone or 'nil'))
                                    if not(iPlateau) then
                                        M28Utilities.DrawLocation(oUnit:GetPosition())
                                    end
                                end
                                if (iLandZone or 0) > 0 then
                                    --Unit is in a land zone so assign it to a land zone instead of a pond
                                    if not(iPlateau) then
                                        local iAltLandZone
                                        iPlateau, iAltLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                                        if (iAltLandZone or 0) > 0 then iLandZone = iAltLandZone end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Adding unit to iLandZone '..iLandZone..' for plateau '..iPlateau) end
                                    AddUnitToLandZoneForBrain(aiBrain, oUnit, iPlateau, iLandZone)
                                elseif iPlateau > 0 then
                                    --Is the unit in a water zone?
                                    if iWaterZone > 0 then
                                        AddUnitToWaterZoneForBrain(aiBrain, oUnit, iWaterZone)
                                    else
                                        --Does the unit already have orders, and is a non-naval unit? If so then wait and try to reassign it in a bit, as e.g. may be a land unit that can path across water so has taken a shortcut
                                        if bDebugMessages == true then LOG(sFunctionRef..': Unit doesnt have al and or water zone, is this a non amphibious or hover naval unit='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAllNavy - categories.AMPHIBIOUS - categories.HOVER, oUnit.UnitId))..'; Nav utils naval label for unit position='..(NavUtils.GetLabel(M28Map.refPathingTypeNavy, oUnit:GetPosition()) or 'nil')) end
                                        if EntityCategoryContains(M28UnitInfo.refCategoryAllNavy, oUnit.UnitId) and (EntityCategoryContains(M28UnitInfo.refCategoryAllNavy - categories.AMPHIBIOUS - categories.HOVER, oUnit.UnitId) or (NavUtils.GetLabel(M28Map.refPathingTypeNavy, oUnit:GetPosition()) or 0) > 0) then
                                            local iCurPond = NavUtils.GetLabel(M28Map.refPathingTypeNavy, oUnit:GetPosition())
                                            if bDebugMessages == true then LOG(sFunctionRef..': Unit pond at cur position='..(NavUtils.GetLabel(M28Map.refPathingTypeNavy, oUnit:GetPosition()) or 'nil')) end
                                            if (iCurPond or 0) > 0 then
                                                --Are in valid pond, find nearest valid water zone and add this segment to that water zone
                                                iWaterZone = nil --redundancy
                                                --To find nearby water zone - cycle through a hollow box
                                                --First to the top row and bottom row
                                                for iAdjustBase = 1, 10 do
                                                    for iCurSegmentX = iSegmentX - iAdjustBase, iSegmentX + iAdjustBase, 1 do
                                                        for iCurSegmentZ = iSegmentZ - iAdjustBase, iSegmentZ + iAdjustBase, iAdjustBase * 2 do
                                                            if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                                                                if M28Map.tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] then iWaterZone = M28Map.tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] break end
                                                            end
                                                        end
                                                        if iWaterZone then break end
                                                    end
                                                    if iWaterZone then break end
                                                    --Then do the left and right row (excl corners which ahve already done per the above)
                                                    for iCurSegmentX = iSegmentX - iAdjustBase, iSegmentX + iAdjustBase, iAdjustBase * 2 do
                                                        for iCurSegmentZ = iSegmentZ - iAdjustBase + 1, iSegmentZ + iAdjustBase - 1, 1 do
                                                            if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                                                                if M28Map.tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] then iWaterZone = M28Map.tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] break end
                                                            end
                                                        end
                                                        if iWaterZone then break end
                                                    end
                                                    if iWaterZone then break end
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': Tried searching nearby segments for water zone, iWaterZone='..(iWaterZone or 'nil')) end
                                                if (iWaterZone or 0) > 0 then
                                                    M28Map.AddSegmentToWaterZone(iCurPond, iWaterZone, iSegmentX, iSegmentZ)
                                                    AddUnitToWaterZoneForBrain(aiBrain, oUnit, iWaterZone)
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will add unit to water zone '..iWaterZone) end
                                                else
                                                    M28Map.ConsiderUnitAddingPositionToWaterZone(oUnit)
                                                    M28Utilities.ErrorHandler('Unable to find nearby water zone despite having a valid pond, unitID='..oUnit.UnitId..'; will try reassigning in a bit')
                                                    ForkThread(DelayedUnitPlateauAssignment, aiBrain, oUnit, 10, bAlreadyUpdatedPosition, true)
                                                end
                                            else
                                                --Reassign in a bit
                                                M28Map.ConsiderUnitAddingPositionToWaterZone(oUnit)
                                                ForkThread(DelayedUnitPlateauAssignment, aiBrain, oUnit, 10, bAlreadyUpdatedPosition, true)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have a non amphibious naval unit that isnt in a recognised pond, so will try to reassign in a bit') end
                                            end
                                        else
                                            --Reassign in a bit if we own it
                                            if bDebugMessages == true then LOG(sFunctionRef..': Unit has a plateau but not a LZ, and isnt a naval unit, will wait and try and reassign if this is the first time, bAlreadyTriedReassignment='..tostring(bAlreadyTriedReassignment or false)..'; aiBrain team='..aiBrain.M28Team..'; Units aibrain team='..oUnit:GetAIBrain().M28Team..'; aiBrain.M28AI='..tostring((aiBrain.M28AI or false))) end
                                            if not(bAlreadyTriedReassignment) or not(aiBrain.M28Team == oUnit:GetAIBrain().M28Team) or not(aiBrain.M28AI) or not(oUnit:GetAIBrain().M28AI) then
                                                ForkThread(DelayedUnitPlateauAssignment, aiBrain, oUnit, 20, bAlreadyUpdatedPosition, true)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will retry in a bit') end
                                            else
                                                --Have an M28AI trying to update date for an M28AI owned unit in the same team as it, and we have already tried reassigning it after a 20 tick delay; if the unit has no orders then give it new orders
                                                M28Orders.UpdateRecordedOrders(oUnit)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Refreshed unit orders, order count='..oUnit[M28Orders.refiOrderCount]) end
                                                if oUnit[M28Orders.refiOrderCount] > 0 then
                                                    ForkThread(DelayedUnitPlateauAssignment, aiBrain, oUnit, 20, bAlreadyUpdatedPosition, true)
                                                    --If the unit is underwater and its last order was attack-move and it isnt a skirmisher then switch to being move
                                                    if not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId)) and oUnit[M28UnitInfo.refiDFRange] > 0 then
                                                        local tLastOrder = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]]
                                                        if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAggressiveMove then
                                                            M28Orders.IssueTrackedMove(oUnit, { tLastOrder[M28Orders.subreftOrderPosition][1], tLastOrder[M28Orders.subreftOrderPosition][2], tLastOrder[M28Orders.subreftOrderPosition][3] }, 1, false, 'UWMNA', false)
                                                        end
                                                    end
                                                else
                                                    --Give unit new orders - move to the nearest land zone (this was added as a redundacny before logic for water zones was incorporated - may not be necessary now
                                                    local iNearestLandZone
                                                    local iNearestDist = 100000
                                                    local iCurDist
                                                    for iLandZone, tLZData in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones] do
                                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                                        if iCurDist < iNearestDist then
                                                            iNearestDist = iCurDist
                                                            iNearestLandZone = iLandZone
                                                        end
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Tried looking for a nearby LZ, nearest LZ='..(iNearestLandZone or 'nil')) end
                                                    if iNearestLandZone then
                                                        M28Orders.IssueTrackedMove(oUnit, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iNearestLandZone][M28Map.subrefMidpoint], 1, true, 'StuckMLZ'..iNearestLandZone)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Told unit to move to the midpoint of the nearest LZ after any current orders, will assign to that land zone as well') end
                                                        AddUnitToLandZoneForBrain(aiBrain, oUnit, iPlateau, iNearestLandZone)
                                                    else
                                                        M28Utilities.ErrorHandler('Couldnt find a land zone for plateau '..iPlateau..' and unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
                                                        ForkThread(DelayedUnitPlateauAssignment, aiBrain, oUnit, 20, bAlreadyUpdatedPosition, true)
                                                    end
                                                end
                                            end
                                        end
                                    end

                                else
                                    --No valid plateau or land zone for unit so likely a pathing error; have unit move randomly if we are updating for the owner
                                    ForkThread(HaveGroundUnitWithNoPlateau, aiBrain, oUnit)
                                end
                            end
                        end
                    end
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Have unit that cant take damage or be killed so ignoring, unit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' owned by '..(oUnit:GetAIBrain().Nickname or 'nil')..'; reprs='..reprs(oUnit)) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function HaveGroundUnitWithNoPlateau(oTrackingBrain, oUnit)
    --Give new orders to the unit if it is an M28 unit; aiBrain should be on the same team and is the brain that we will be updating the plateau and LZ tracking for
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'HaveGroundUnitWithNoPlateau'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local refsTrackingVariable = 'M28ActiveNoPlateau'..oTrackingBrain:GetArmyIndex()

    if M28UnitInfo.IsUnitValid(oUnit) and not(oUnit[refsTrackingVariable]) then --Brain check is a redundancy
        if bDebugMessages == true then
            LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' doesnt appear to have a valid location, will monitor until it has a valid location; will draw unit cur position')
            M28Utilities.DrawLocation(oUnit:GetPosition())
        end
        oUnit[refsTrackingVariable] = true
        local iPlateau, iLandZone
        local iBaseAngle, iBaseDistance
        local tPotentialTempMoveLocation
        local iPlateauToTryAndFind
        local sPathing = M28UnitInfo.GetUnitPathingType
        local bConsiderMoving = false
        if oUnit:GetAIBrain().M28AI then bConsiderMoving = true end
        while M28UnitInfo.IsUnitValid(oUnit) do
            iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
            if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' postiion='..repru(oUnit:GetPosition())..'; Unit plateau group='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; Actual plateau group ignoring segment='..(NavUtils.GetLabel(sPathing, tPotentialTempMoveLocation) or 'nil')) end
            if iPlateau > 0 then break end
            if bConsiderMoving then
                M28Orders.UpdateRecordedOrders(oUnit)
                if not(oUnit[M28Orders.reftiLastOrders]) then
                    --Give a move order to a random place
                    iBaseAngle = math.random(1, 360)
                    iBaseDistance = math.random(5, 10)
                    iPlateauToTryAndFind = NavUtils.GetLabel(sPathing, oUnit:GetPosition())
                    if not(iPlateauToTryAndFind > 0) then iPlateauToTryAndFind = nil end
                    for iAngleAdjust = 0, 45, 360 do
                        tPotentialTempMoveLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), iBaseAngle + iAngleAdjust, iBaseDistance, true, false, true)

                        if not(iPlateauToTryAndFind) or NavUtils.GetLabel(sPathing, tPotentialTempMoveLocation) == iPlateauToTryAndFind then
                            break --Use this as the move location
                        end
                    end
                    M28Orders.IssueTrackedMove(oUnit, tPotentialTempMoveLocation, 3, false, 'RandPath')

                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        --Have a valid plateau so stop tracking and send for reassignment
        oUnit[refsTrackingVariable] = false
        AssignUnitToLandZoneOrPond(oTrackingBrain, oUnit)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


--[[function UpdateUnitPond(oUnit, iM28TeamUpdatingFor, bIsEnemy, iPondRefOverride)
    --Check the unit's pond; ignore this for non-M28 friendly units
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateUnitPond'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, bIsEnemy='..tostring((bIsEnemy or false))..'; Unit brain index='..oUnit:GetAIBrain():GetArmyIndex()..'; Unit assigned pond='..(oUnit[refiAssignedPond] or 'nil')..'; Contains fixed pond category='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryPondFixedCategory, oUnit.UnitId))) end

    if bIsEnemy or (oUnit:GetAIBrain().M28AI and (not(oUnit[refiAssignedPond]) or not(EntityCategoryContains(M28UnitInfo.refCategoryPondFixedCategory, oUnit.UnitId)))) then --and not(oUnit[reftisubrefsUpdatedFor][iM28TeamUpdatingFor])) then
        local iCurPond = iPondRefOverride or M28MapInfo.GetSegmentGroupOfLocation(M28Map.refPathingTypeNavy, oUnit:GetPosition())
        if bDebugMessages == true then LOG(sFunctionRef..': bIsEnemy='..tostring(bIsEnemy)..'; Updating for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iPondRefOverride='..(iPondRefOverride or 'nil')..'; iCurPond='..(iCurPond or 'nil')..'; oUnit[refiAssignedPond]='..(oUnit[refiAssignedPond] or 'nil')) end --LOG('iCurPond pre adj='..(iCurPond or 'nil'))
        --if tPondDetails[iCurPond] then LOG('Pond size='..(tPondDetails[iCurPond][subrefiSegmentCount] or 'nil')) end
        if not(tPondDetails[iCurPond]) or (tPondDetails[iCurPond][subrefiSegmentCount] or 0) <= iMinPondSize then
            --If have a naval unit that isnt amphibious then update pathing
            if bDebugMessages == true then LOG(sFunctionRef..': Dont have details for the pond recorded, if its a naval unit then will check for if there is a pond nearby') end
            if EntityCategoryContains(categories.NAVAL * categories.MOBILE - categories.HOVER - categories.AMPHIBIOUS - categories.AIR - categories.LAND, oUnit.UnitId) then
                iCurPond = CheckForPondNearNavalUnit(oUnit)
                if bDebugMessages == true then LOG(sFunctionRef..': iCurPond after checking for pond near naval unit='..iCurPond) end
            else
                iCurPond = 0
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iCurPond after updating for naval unit and min pond size='..(iCurPond or 'nil')..'; oUnit[refiAssignedPond]='..(oUnit[refiAssignedPond] or 'nil')) end
        if iCurPond > 0 then
            oUnit[M28UnitInfo.reftLastKnownPosition] = {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]}
            if bDebugMessages == true then LOG(sFunctionRef..': Updated unit last known position') end
        end
        if oUnit[refiAssignedPond] then
            if not(iCurPond == oUnit[refiAssignedPond]) then
                if bDebugMessages == true then LOG('Removing unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from old pond '..(oUnit[refiAssignedPond] or 'nil')..' and adding to new pond iCurPond='..iCurPond) end
                RemoveUnitFromAssignedPond(oUnit)
                AddUnitToPond(oUnit, iCurPond, iM28TeamUpdatingFor, bIsEnemy)
            elseif not(oUnit[reftisubrefsUpdatedFor][iM28TeamUpdatingFor]) then
                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to pond '..iCurPond) end
                AddUnitToPond(oUnit, iCurPond, iM28TeamUpdatingFor, bIsEnemy)
            end
        else
            if iCurPond > 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to pond '..iCurPond) end
                AddUnitToPond(oUnit, iCurPond, iM28TeamUpdatingFor, bIsEnemy)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end--]]

function UpdateFactionBlueprintBlacklist(iSubteam)
    --Considers any blueprint specific overrides (only supports the 4 core factions and not modded units since blueprint values are hardcoded)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateFactionBlueprintBlacklist'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    tLandSubteamData[iSubteam][subrefBlueprintBlacklist] = {}


    --Land scouts
    if M28Conditions.HaveFactionTech(iSubteam, M28Factory.refiFactoryTypeLand, M28UnitInfo.refFactionAeon, 1) then
        --Only want Aeon land scouts
        tLandSubteamData[iSubteam][subrefBlueprintBlacklist]['uel0101'] = true --UEF land scout
        tLandSubteamData[iSubteam][subrefBlueprintBlacklist]['url0101'] = true --Cybran land scout
        tLandSubteamData[iSubteam][subrefBlueprintBlacklist]['xsl0101'] = true --Seraphim land scout
    elseif M28Conditions.HaveFactionTech(iSubteam, M28Factory.refiFactoryTypeLand, M28UnitInfo.refFactionCybran, 1) then
        --If have cybran tech then prioritise this
        tLandSubteamData[iSubteam][subrefBlueprintBlacklist]['uel0101'] = true --UEF land scout
        tLandSubteamData[iSubteam][subrefBlueprintBlacklist]['xsl0101'] = true --Seraphim land scout
    elseif M28Conditions.HaveFactionTech(iSubteam, M28Factory.refiFactoryTypeLand, M28UnitInfo.refFactionUEF, 1) then
        tLandSubteamData[iSubteam][subrefBlueprintBlacklist]['xsl0101'] = true --Seraphim land scout
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, blacklist for subteam '..iSubteam..' = '..repru(tLandSubteamData[iSubteam][subrefBlueprintBlacklist])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)



end

function CheckForSubteamFactoryChange(oUnit, bJustBuiltNotDied)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckForSubteamFactoryChange'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnit.UnitId) then
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
        local iSubteam = oUnit:GetAIBrain().M28LandSubteam
        if iPlateau == tLandSubteamData[iSubteam][subrefiLandCorePlateau] and NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition()) == tLandSubteamData[iSubteam][subrefiLandCoreIsland] then
            local iFactoryType = M28UnitInfo.GetFactoryType(oUnit)
            local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oUnit)
            local iFactoryFaction = M28UnitInfo.GetUnitFaction(oUnit)


            local bChangedFactoryTech = false
            --Do we have any higher tech than this?
            local bHaveHigherTech = false
            if iFactoryTechLevel < 3 then
                for iHigherTech = iFactoryTechLevel + 1, 2 do
                    if (tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iHigherTech] or 0) > 0 then
                        bHaveHigherTech = true
                        break
                    end
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have had a factory tech change, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bJustBuiltNotDied='..tostring(bJustBuiltNotDied or false)..'; iFactoryType='..iFactoryType..'; iPlateau='..iPlateau..'; IslandRef='..NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition())..'; iFactoryTechLevel='..iFactoryTechLevel..'; iFactoryFaction='..iFactoryFaction..'; iSubteam='..iSubteam..'; tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech]='..repru(tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech])) end

            if bJustBuiltNotDied then
                --Check if need to add the unit to the subteam table
                if (tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] or 0) <= 0 then
                    if not(bHaveHigherTech) then bChangedFactoryTech = true end
                    tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] = 1
                else
                    tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] = tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] + 1
                end
            else
                if tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] == 1 then
                    if not(bHaveHigherTech) then bChangedFactoryTech = true end
                end
                tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] = math.max(0, tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] - 1)
            end

            if bChangedFactoryTech then
                UpdateFactionBlueprintBlacklist(iSubteam)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateTeamHighestAndLowestFactories(iM28Team)
    --Called whenever an M28 brain gains or loses an HQ factory; for convenience will update all factory types (even thoguh marginally more efficient to only update the type in question)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateTeamHighestAndLowestFactories'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] = 3
    tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] = 3
    tTeamData[iM28Team][subrefiLowestFriendlyNavalFactoryTech] = 3
    tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] = 0
    tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] = 0
    tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech] = 0

    if bDebugMessages == true then LOG(sFunctionRef..': Lowest friendly land fac start point (will decrease to lower of this and actual tech)='..tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]) end

    for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
        if not(oBrain[M28Economy.refiOurHighestFactoryTechLevel]) then --saves having to define the variables earlier
            oBrain[M28Economy.refiOurHighestFactoryTechLevel] = 0
            oBrain[M28Economy.refiOurHighestLandFactoryTech] = 0
            oBrain[M28Economy.refiOurHighestAirFactoryTech] = 0
            oBrain[M28Economy.refiOurHighestNavalFactoryTech] = 0
        end
        if bDebugMessages == true then LOG(sFunctionRef..': subrefiLowestFriendlyLandFactoryTech before reducing='..tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]..'; oBrain[M28Economy.refiOurHighestLandFactoryTech]='..oBrain[M28Economy.refiOurHighestLandFactoryTech]..'; lower of these two='..math.min(tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech], oBrain[M28Economy.refiOurHighestLandFactoryTech])) end
        tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] = math.min(3, tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech], oBrain[M28Economy.refiOurHighestLandFactoryTech])
        if bDebugMessages == true then LOG(sFunctionRef..': tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] after update='..tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]) end
        tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] = math.min(3, tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech], oBrain[M28Economy.refiOurHighestAirFactoryTech])
        tTeamData[iM28Team][subrefiLowestFriendlyNavalFactoryTech] = math.min(3, tTeamData[iM28Team][subrefiLowestFriendlyNavalFactoryTech], oBrain[M28Economy.refiOurHighestNavalFactoryTech])

        tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] = math.min(3, math.max(tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech], oBrain[M28Economy.refiOurHighestLandFactoryTech]))
        tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] = math.min(3, math.max(tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech], oBrain[M28Economy.refiOurHighestAirFactoryTech]))
        tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech] = math.min(3, math.max(tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech], oBrain[M28Economy.refiOurHighestNavalFactoryTech]))
        if bDebugMessages == true then LOG(sFunctionRef..': Considering brain '..oBrain.Nickname..'; tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]='..tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]..'; oBrain[M28Economy.refiOurHighestLandFactoryTech]='..oBrain[M28Economy.refiOurHighestLandFactoryTech]) end
    end
    tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] = math.min(3, math.max(1, tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech], tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech], (tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech] or 0)))
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DoesBrainHaveActiveHQUpgradesOfCategory(aiBrain, iFactoryBeingUpgradedCategory)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DoesBrainHaveActiveHQUpgradesOfCategory'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Does our team have an empty table of upgrading HQs='..tostring(M28Utilities.IsTableEmpty(tTeamData[aiBrain.M28Team][subreftTeamUpgradingHQs]))) end
    if M28Utilities.IsTableEmpty(tTeamData[aiBrain.M28Team][subreftTeamUpgradingHQs]) == false then
        for iUpgrading, oUpgrading in tTeamData[aiBrain.M28Team][subreftTeamUpgradingHQs] do
            if EntityCategoryContains(iFactoryBeingUpgradedCategory, oUpgrading.UnitId) then
                if M28UnitInfo.IsUnitValid(oUpgrading) and oUpgrading:GetAIBrain() == aiBrain then
                    if bDebugMessages == true then LOG(sFunctionRef..': The upgrading unit '..oUpgrading.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUpgrading)..' brain is equal to aiBrain '..aiBrain.Nickname) end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function ConsiderPriorityLandFactoryUpgrades(iM28Team)
    --Starts a land factory upgrade if we need one urgently (e.g. we are outteched, or have high gross mass so will want access to T3)
    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderPriorityLandFactoryUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Enemy has better land tech than us, and we have no active land upgrades



    if bDebugMessages == true then LOG(sFunctionRef..': tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech]='..(tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] or 'nil')..'; tTeamData[iM28Team][subrefiHighestEnemyGroundTech]='..(tTeamData[iM28Team][subrefiHighestEnemyGroundTech] or 'nil')..'; Lifetime combat count='..M28Conditions.GetTeamLifetimeBuildCount(iM28Team, (M28UnitInfo.refCategoryLandCombat * M28UnitInfo.ConvertTechLevelToCategory(tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]) + M28UnitInfo.refCategoryIndirect * M28UnitInfo.ConvertTechLevelToCategory(tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech])) ) >= 20 * (2-tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]) + 12) end
    if tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] > 0 and tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] < 3 and (tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] < tTeamData[iM28Team][subrefiHighestEnemyGroundTech] or (tTeamData[iM28Team][subrefiTeamGrossMass] >= 3.5 / tTeamData[iM28Team][subrefiActiveM28BrainCount] and (tTeamData[iM28Team][subrefiTeamMassStored] >= 300 * tTeamData[iM28Team][subrefiActiveM28BrainCount] or tTeamData[iM28Team][subrefiTeamGrossMass] >= 20) and (tTeamData[iM28Team][subrefiTeamGrossMass] >= 8.5 * (1 + (tTeamData[iM28Team][subrefiActiveM28BrainCount] - 1) *0.5) or tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] == 1 or M28Conditions.GetTeamLifetimeBuildCount(iM28Team, (M28UnitInfo.refCategoryLandCombat * M28UnitInfo.ConvertTechLevelToCategory(tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]) + M28UnitInfo.refCategoryIndirect * M28UnitInfo.ConvertTechLevelToCategory(tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech])) ) >= 20 * (2-tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]) + 12 * tTeamData[iM28Team][subrefiActiveM28BrainCount]))) then
        local bWantUpgrade = false
        local iExistingBrainsWithHQUpgrades = 0
        for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
            --Can we path to the nearest enemy with land, and we are behind enemy tech level with land or have lots of mass?
            if bDebugMessages == true then LOG(sFunctionRef..': Considering oBrain '..oBrain.Nickname..'; oBrain[M28Map.refbCanPathToEnemyBaseWithLand]='..tostring(oBrain[M28Map.refbCanPathToEnemyBaseWithLand])..'; oBrain[M28Economy.refiOurHighestLandFactoryTech]='..oBrain[M28Economy.refiOurHighestLandFactoryTech]) end

            if oBrain[M28Map.refbCanPathToEnemyBaseWithLand] and oBrain[M28Economy.refiOurHighestLandFactoryTech] > 0 and (oBrain[M28Economy.refiOurHighestLandFactoryTech] < tTeamData[iM28Team][subrefiHighestEnemyGroundTech] or (tTeamData[iM28Team][subrefiTeamGrossMass] >= 6.5 * (1 + (tTeamData[iM28Team][subrefiActiveM28BrainCount] - 1) * 0.5) and tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 50 * (1 + (tTeamData[iM28Team][subrefiActiveM28BrainCount] - 1)*0.5)) or M28Conditions.GetTeamLifetimeBuildCount(iM28Team, (M28UnitInfo.refCategoryLandCombat * M28UnitInfo.ConvertTechLevelToCategory(tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]) + M28UnitInfo.refCategoryIndirect * M28UnitInfo.ConvertTechLevelToCategory(tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]))) >= 20 * (2-tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]) + 15 * tTeamData[iM28Team][subrefiActiveM28BrainCount]) then
                --Do we have any active land factory upgrades?
                bWantUpgrade = not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ))

                if bWantUpgrade and (iExistingBrainsWithHQUpgrades < tTeamData[iM28Team][subrefiActiveM28BrainCount] * 0.5 or tTeamData[iM28Team][subrefiTeamMassStored] >= 450 * tTeamData[iM28Team][subrefiActiveM28BrainCount]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and upgrade a land factory HQ subject to how many units the factory has built') end
                    M28Economy.FindAndUpgradeUnitOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ * M28UnitInfo.ConvertTechLevelToCategory(oBrain[M28Economy.refiOurHighestLandFactoryTech]), 7)
                elseif not(bWantUpgrade) then
                    iExistingBrainsWithHQUpgrades = iExistingBrainsWithHQUpgrades + 1
                end
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderPriorityAirFactoryUpgrades(iM28Team)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderPriorityAirFactoryUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]..'; tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]) end

    if tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] > 0 and tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] < 3 then
        local bWantUpgrade = false
        --Prioritise air factory if we dont have T2 air and enemy has navy
        local bAirSubteamNeedsTorps = false
        local tiAirSubteams = {}
        for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
            tiAirSubteams[oBrain.M28AirSubteam] = true
        end
        for iAirSubteam, bTrue in tiAirSubteams do
            if tAirSubteamData[iAirSubteam][refbNoAvailableTorpsForEnemies] then
                bAirSubteamNeedsTorps = true
                break
            end
        end

        --Upgrading from T2 to T3 - Do we only have 1 air fac for the brain, and has it not yet built at least 5 units of that tech (or 15 of any tech) yet?
        local bWaitUntilBuiltMoreUnits = false
        if tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] == 2 and tTeamData[iM28Team][subrefiHighestEnemyAirTech] < 3 then
            bWaitUntilBuiltMoreUnits = true
            for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
                local tT2AirFactories = oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirFactory * categories.TECH2, false, true)
                if M28Utilities.IsTableEmpty(tT2AirFactories) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': T2 air fac count for brain '..oBrain.Nickname..'='..table.getn(tT2AirFactories)) end
                    if table.getn(tT2AirFactories) >= 2 then
                        bWaitUntilBuiltMoreUnits = false
                        break
                    else
                        for iUnit, oUnit in tT2AirFactories do
                            if bDebugMessages == true then LOG(sFunctionRef..': Lifetime build count for T2 air for factory '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'='..M28Conditions.GetFactoryLifetimeCount(oUnit, categories.AIR * categories.TECH2)..'; Lifetime T1+T2 count='..M28Conditions.GetFactoryLifetimeCount(oUnit, categories.TECH1 + categories.TECH2)) end
                            if M28Conditions.GetFactoryLifetimeCount(oUnit, categories.AIR * categories.TECH2) >= 5 or M28Conditions.GetFactoryLifetimeCount(oUnit, categories.TECH1 + categories.TECH2) >= 15 then
                                if bDebugMessages == true then LOG(sFunctionRef..': AIr fac has built enough T2 units for us to contemplate T3 upgrade') end
                                bWaitUntilBuiltMoreUnits = false
                                break
                            end
                        end
                    end
                end
                if not(bWaitUntilBuiltMoreUnits) then break end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bWaitUntilBuiltMoreUnits='..tostring(bWaitUntilBuiltMoreUnits)) end
        if not(bWaitUntilBuiltMoreUnits) then
            if tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] < 2 and (bAirSubteamNeedsTorps or tTeamData[iM28Team][subrefiHighestEnemyNavyTech] > 0) then
                for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
                    if oBrain[M28Economy.refiOurHighestAirFactoryTech] > 0 and oBrain[M28Economy.refiOurHighestAirFactoryTech] < 2 then
                        bWantUpgrade = true
                        M28Economy.FindAndUpgradeUnitOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ * categories.TECH1)
                    end
                end
            end
            --Prioritise air factory if enemy has T3 air and we dont
            if not(bWantUpgrade) and tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] < tTeamData[iM28Team][subrefiHighestEnemyAirTech] and tTeamData[iM28Team][subrefiHighestEnemyAirTech] >= 3 then
                for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
                    if oBrain[M28Economy.refiOurHighestAirFactoryTech] > 0 and oBrain[M28Economy.refiOurHighestAirFactoryTech] < 3 then
                        --Do we have any active air factory upgrades?
                        bWantUpgrade = not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ))

                        if bWantUpgrade then
                            M28Economy.FindAndUpgradeUnitOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ * M28UnitInfo.ConvertTechLevelToCategory(oBrain[M28Economy.refiOurHighestAirFactoryTech]))
                        end
                    end
                end
            end
            if not(bWantUpgrade) then
                --Prioritise air fac if we already have T2 land and at least 4 mass per tick and 70 power per tick, or if we have 6 mass and 100 power, provided no current HQ upgrades

                if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) and tTeamData[iM28Team][subrefiTeamGrossMass] >= 4 * tTeamData[iM28Team][subrefiActiveM28BrainCount] and tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 70 * tTeamData[iM28Team][subrefiActiveM28BrainCount] and (tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] >= 2 or (tTeamData[iM28Team][subrefiTeamGrossMass] >= 6 * tTeamData[iM28Team][subrefiActiveM28BrainCount] and tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 100 * tTeamData[iM28Team][subrefiActiveM28BrainCount])) then
                    for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
                        if oBrain[M28Economy.refiOurHighestAirFactoryTech] > 0 and oBrain[M28Economy.refiOurHighestAirFactoryTech] < 3 then
                            --Do we have any active air factory upgrades? (redundancy - should already have excluded via above)
                            bWantUpgrade = not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ))
                            if bWantUpgrade then
                                M28Economy.FindAndUpgradeUnitOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ * M28UnitInfo.ConvertTechLevelToCategory(oBrain[M28Economy.refiOurHighestAirFactoryTech]))
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderPriorityNavalFactoryUpgrades(iM28Team)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderPriorityNavalFactoryUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech]) end

    if tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech] > 0 and tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech] < math.min(3, tTeamData[iM28Team][subrefiHighestEnemyNavyTech]) then
        local bWantUpgrade = false
        for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
            if oBrain[M28Economy.refiOurHighestNavalFactoryTech] > 0 and oBrain[M28Economy.refiOurHighestAirFactoryTech] < math.min(3, tTeamData[iM28Team][subrefiHighestEnemyNavyTech]) then
                --Do we have any active air factory upgrades?
                bWantUpgrade = not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryNavalHQ))

                if bWantUpgrade then
                    --Campaign maps where still relatively early, or games where we have poor gross mass, where considering upgrading to T3
                    if tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech] == 2 then
                        if M28Map.bIsCampaignMap and GetGameTimeSeconds() <= 600 and tTeamData[iM28Team][subrefiTeamGrossMass] <= 20 then
                            bWantUpgrade = false
                        elseif tTeamData[iM28Team][subrefiTeamGrossMass] <= 10 * tTeamData[iM28Team][subrefiActiveM28BrainCount] then
                            --Only upgrade to T3 if we have built a number of T2 units
                            local tNavalFactories = oBrain:GetListOfUnits(M28UnitInfo.refCategoryNavalFactory * categories.TECH2, false, true)
                            local iTotalBuildCount = 0
                            for iFactory, oFactory in tNavalFactories do
                                iTotalBuildCount = iTotalBuildCount + (oFactory[M28Factory.refiTotalBuildCount] or 0)
                            end
                            if iTotalBuildCount <= 8 then
                                bWantUpgrade = false
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': We have lower naval tech than enemy, and dont have an active HQ upgrade, bWantUpgrade after low mass checks='..tostring(bWantUpgrade)) end
                    if bWantUpgrade then
                        M28Economy.FindAndUpgradeUnitOfCategory(oBrain, M28UnitInfo.refCategoryNavalHQ * M28UnitInfo.ConvertTechLevelToCategory(oBrain[M28Economy.refiOurHighestNavalFactoryTech]))
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderPriorityMexUpgrades(iM28Team)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderPriorityMexUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Is table of upgrading mexes empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]))..'; tTeamData[iM28Team][subrefiTeamMassStored]='..tTeamData[iM28Team][subrefiTeamMassStored]..'; tTeamData[iM28Team][subrefiTeamNetMass]='..tTeamData[iM28Team][subrefiTeamNetMass]..'; tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]='..tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]..'; or M28Overseer.bNoRushActive='..tostring(M28Overseer.bNoRushActive or false)) end
    local iExistingT1MexUpgrades = 0
    local iExistingT2MexUpgrades = 0
    if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) == false then
        for iUpgradingMex, oUpgradingMex in tTeamData[iM28Team][subreftTeamUpgradingMexes] do
            if EntityCategoryContains(categories.TECH1, oUpgradingMex.UnitId) then
                iExistingT1MexUpgrades = iExistingT1MexUpgrades + 1
            elseif EntityCategoryContains(categories.TECH2, oUpgradingMex.UnitId) then
                iExistingT2MexUpgrades = iExistingT2MexUpgrades + 1
            else
                M28Utilities.ErrorHandler('Are somehow upgrading a mex  that is neither t1 nor t2')
            end
        end
    end
    --T1 mex upgrading to T2 = c.8 mass per sec; T2 to T3 = c.18 mass per sec; so treat 1 T2 mex upgrading as equiv to 2.5 T1 mex
    --Want to be spending at least 1/3 of gross income on upgrading mexes assuming we have safe mexes to upgrade
    local bHaveSafeMexToUpgrade = GetSafeMexToUpgrade(iM28Team, true)
    local iUpgradingMexValue = iExistingT1MexUpgrades + 2.5 * iExistingT2MexUpgrades
    local iWantedUpgradingMexValue = 0
    if tTeamData[iM28Team][subrefiTeamGrossMass] >= 2.5 * tTeamData[iM28Team][subrefiActiveM28BrainCount] then
        iWantedUpgradingMexValue = 1
        if tTeamData[iM28Team][subrefiTeamGrossMass] >= 12 then iWantedUpgradingMexValue = iWantedUpgradingMexValue + 1 end
    end
    if bHaveSafeMexToUpgrade or M28Overseer.bNoRushActive then
        --if upgrading 1 mex from t1 to t2 costs roughly 0.8 mass per tick, and we want to be spenting 1/3 of mass per tick on this, then want 1/3 of gross mass / 0.8, i.e. 0.4167
        --However, are finding we are spending too much mass with this approach and end up always mass stalling, and only upgrading mexes, meaning HQs dont upgrade (when using a value of 0.4167 * gross mass income)
        iWantedUpgradingMexValue = math.max((tTeamData[iM28Team][subrefiTeamGrossMass] - 2 * tTeamData[iM28Team][subrefiActiveM28BrainCount]) * 0.3, tTeamData[iM28Team][subrefiTeamGrossMass] * 0.125)
        --if are already upgrading 1 mex per brain and are stalling mass, then reduce the amount wanted
        if (tTeamData[iM28Team][subrefiTeamMassStored] < 50 or tTeamData[iM28Team][subrefbTeamIsStallingMass]) and M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) == false and (table.getn(tTeamData[iM28Team][subreftTeamUpgradingMexes]) > 1 + (tTeamData[iM28Team][subrefiActiveM28BrainCount] - 1) * 0.5 and tTeamData[iM28Team][subrefiTeamNetMass] <= -math.max(-0.5, tTeamData[iM28Team][subrefiTeamGrossMass] * 0.08)) then
            iWantedUpgradingMexValue = iWantedUpgradingMexValue * 0.2
        end
        --Adjust maount wanted for any build power modifier
        iWantedUpgradingMexValue = iWantedUpgradingMexValue / tTeamData[iM28Team][refiHighestBrainBuildMultiplier]
    end
    if bDebugMessages == true then LOG(sFunctionRef..': iWantedUpgradingMexValue='..iWantedUpgradingMexValue..'; iUpgradingMexValue='..iUpgradingMexValue..'; bHaveSafeMexToUpgrade='..tostring(bHaveSafeMexToUpgrade)..'; iExistingT1MexUpgrades='..iExistingT1MexUpgrades..'; iExistingT2MexUpgrades='..iExistingT2MexUpgrades..'; Active brain count='..tTeamData[iM28Team][subrefiActiveM28BrainCount]..'; Total mass stored='..tTeamData[iM28Team][subrefiTeamMassStored]) end
    if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) or iWantedUpgradingMexValue > iUpgradingMexValue or (tTeamData[iM28Team][subrefiTeamMassStored] >= 800 and (tTeamData[iM28Team][subrefiTeamNetMass] - tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]) > 0) then
        --Do we have enough energy?
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have enough energy, tTeamData[iM28Team][subrefiTeamNetEnergy]='..tTeamData[iM28Team][subrefiTeamNetEnergy]..'; tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle]='..tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle]..'; tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored]='..tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored]) end
        if (tTeamData[iM28Team][subrefiTeamNetEnergy] - tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle] > 0 or (M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) and tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.98)) and
                (tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.75 or tTeamData[iM28Team][subrefiTeamNetEnergy] - tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle] >= 5) then
            --Do we have mexes in start positions that are lower than the enemy's highest tech, or 2 lower than the highest mex in that LZ? Or are in norush mode? Or just want to be spending more mass on upgrading safe mexes?
            local iTechLevelToUpgrade = math.min(3, (tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] or 1)) - 1 --, (tTeamData[iM28Team][subrefiHighestEnemyMexTech] or 0))) - 1
            if M28Overseer.bNoRushActive then iTechLevelToUpgrade = math.max(1, iTechLevelToUpgrade) end
            --Always be upgrading a mex at higher mass levels
            if iTechLevelToUpgrade <= 1 then
                if iTechLevelToUpgrade == 1 and tTeamData[iM28Team][subrefiTeamGrossMass] > tTeamData[iM28Team][subrefiActiveM28BrainCount] * 6 then
                    iTechLevelToUpgrade = 2
                elseif iTechLevelToUpgrade == 0 and tTeamData[iM28Team][subrefiTeamGrossMass] > tTeamData[iM28Team][subrefiActiveM28BrainCount] * 2.5 then
                    iTechLevelToUpgrade = 1
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iTechLevelToUpgrade='..iTechLevelToUpgrade..'; tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]..'; bHaveSafeMexToUpgrade='..tostring(bHaveSafeMexToUpgrade or false)) end
            if iTechLevelToUpgrade >= 1 then
                if bHaveSafeMexToUpgrade then
                    GetSafeMexToUpgrade(iM28Team)
                else

                    --If dont have safe mex to upgrade - cycle through each brain looking for mex to upgrade
                    local iPlateau, iLandZone, tMexesToConsiderUpgrading
                    local bAbort = false

                    --Want to be upgrading at least 1 mex on our team, or more if we have positive mass income, subject to gross income
                    local tiExtraMassStoredPerUpgrade = {[1] = 300, [2] = 1000}
                    local iMassStoredToKeepUpgrading = 0
                    if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) == false then
                        for iUnit, oUnit in tTeamData[iM28Team][subreftTeamUpgradingMexes] do
                            iMassStoredToKeepUpgrading = iMassStoredToKeepUpgrading + tiExtraMassStoredPerUpgrade[M28UnitInfo.GetUnitTechLevel(oUnit)]
                        end
                    end



                    for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
                        bAbort = false
                        iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                        local tLZOrWZTeamData
                        if (iLandZone or 0) > 0 then
                            tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iM28Team]
                        else
                            local iWaterZone = M28Map.GetWaterZoneFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                            if (iWaterZone or 0) > 0 then
                                tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][iM28Team]
                            end
                        end
                        --Dont do priority upgrade if this location already has an upgrade, unless we have high mass income for this brain and T1 mexes
                        if bDebugMessages == true then LOG(sFunctionRef..': Does brain '..oBrain.Nickname..' have an empty table of active upgrades in its start position LZ/WZ='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefActiveUpgrades]))) end
                        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefActiveUpgrades]) or (oBrain[M28Economy.refiGrossMassBaseIncome] >= 4 and tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] > 0) then
                            for iMexTech = 1, iTechLevelToUpgrade do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering mexes for iMexTech='..iMexTech..'; count='..tLZOrWZTeamData[M28Map.subrefMexCountByTech][iMexTech]) end
                                if tLZOrWZTeamData[M28Map.subrefMexCountByTech][iMexTech] > 0 then
                                    tMexesToConsiderUpgrading = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex * M28UnitInfo.ConvertTechLevelToCategory(iMexTech), tLZOrWZTeamData[M28Map.subrefLZTAlliedUnits])
                                    if M28Utilities.IsTableEmpty(tMexesToConsiderUpgrading) == false then
                                        for iMex, oMex in tMexesToConsiderUpgrading do
                                            if not(oMex:IsUnitState('Upgrading')) and oMex:GetFractionComplete() == 1 then
                                                if oMex:GetAIBrain().M28AI and oMex:GetAIBrain().M28Team == iM28Team then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will try to upgrade mex in starting zone, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Mex='..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)) end
                                                    M28Economy.UpgradeUnit(oMex, true)
                                                    iMassStoredToKeepUpgrading = iMassStoredToKeepUpgrading + tiExtraMassStoredPerUpgrade[iMexTech]
                                                    bAbort = true
                                                    break
                                                end
                                            end
                                        end
                                    end
                                end
                                if bAbort then break end
                            end
                        end
                        if bAbort then
                            --Do we have positive mass income or lots of mass stored? If so then proceed to upgrade for other brains
                            if tTeamData[iM28Team][subrefiTeamNetEnergy] - tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle] > 0 then
                                if (tTeamData[iM28Team][subrefiTeamNetMass] - tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]) > 0 or tTeamData[iM28Team][subrefiTeamMassStored] >= iMassStoredToKeepUpgrading then
                                    bAbort = false
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AddPotentialUnitsToShortlist(toUnitShortlist, tPotentialUnits, bDontCheckIfSafe)
    if M28Utilities.IsTableEmpty(tPotentialUnits) == false then
        for iUnit, oUnit in tPotentialUnits do
            if M28UnitInfo.IsUnitValid(oUnit) and not(oUnit:IsUnitState('Upgrading')) and oUnit:GetFractionComplete() == 1 and (bDontCheckIfSafe or M28Conditions.SafeToUpgradeUnit(oUnit)) then
                table.insert(toUnitShortlist, oUnit)
            end
        end
    end
end

function GetSafeMexToUpgrade(iM28Team, bReturnIfSafeInsteadOfUpgrading)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetSafeMexToUpgrade'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local toSafeUnitsToUpgrade = {}
    local tPotentialUnits
    --First prioritise T1 mexes
    local tiMexCategory = {[1] = M28UnitInfo.refCategoryT1Mex, [2]=M28UnitInfo.refCategoryT2Mex}
    for iTech = 1, 2 do
        for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
            local tPotentialUnits = oBrain:GetListOfUnits(tiMexCategory[iTech], false, true)
            AddPotentialUnitsToShortlist(toSafeUnitsToUpgrade, tPotentialUnits)
        end
        if M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade) == false then
            break
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for units to upgrade at time '..GetGameTimeSeconds()..', is table empty='..tostring(M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade))) end
    if bReturnIfSafeInsteadOfUpgrading then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return not(M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade))
    else
        if M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Have a total of '..table.getn(toSafeUnitsToUpgrade)..' units to upgrade, will pick the best one') end
            local oUnitToUpgrade = M28Economy.GetBestUnitToUpgrade(toSafeUnitsToUpgrade)
            if oUnitToUpgrade then
                if bDebugMessages == true then LOG(sFunctionRef..': Will try to upgrade unit '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)) end
                M28Economy.UpgradeUnit(oUnitToUpgrade, true)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetSafeHQUpgrade(iM28Team, bOnlyConsiderLandFactory)
    --if bRunningThisAsBackupUpgradeOption then wont upgrade T2 land fac that hasnt built much
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetSafeHQUpgrade'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local toSafeUnitsToUpgrade = {}
    local tPotentialUnits

    --First identify any players that have a T1 land or air HQ
    for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
        if bDebugMessages == true then LOG(sFunctionRef..': Considering brain '..oBrain.Nickname..'; Highest air fac tech='..oBrain[M28Economy.refiOurHighestAirFactoryTech]..'; Highest land fac tech='..oBrain[M28Economy.refiOurHighestLandFactoryTech]..'; bOnlyConsiderLandFactory='..tostring(bOnlyConsiderLandFactory or false)) end
        if oBrain[M28Economy.refiOurHighestAirFactoryTech] == 1 and not(bOnlyConsiderLandFactory) then
            if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ)) then
                --Check we dont already have an active upgrade
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirHQ * categories.TECH1, false, true)
                AddPotentialUnitsToShortlist(toSafeUnitsToUpgrade, tPotentialUnits)
            end
        end
        if oBrain[M28Economy.refiOurHighestLandFactoryTech] == 1 then
            if bDebugMessages == true then LOG(sFunctionRef..': Does brain have active Land HQ upgrades='..tostring(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ))) end
            if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ)) then
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandHQ * categories.TECH1, false, true)
                if bDebugMessages == true then LOG(sFunctionRef..': Adding T1 land HQs to shortlist, is tPotentialUnits empty='..tostring(M28Utilities.IsTableEmpty(tPotentialUnits))) end
                AddPotentialUnitsToShortlist(toSafeUnitsToUpgrade, tPotentialUnits)
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for units to upgrade, is table of safe units empty='..tostring(M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade))) end
    if M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade) then
        --Get T2 upgrades if all our land and air are at T2
        for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
            if oBrain[M28Economy.refiOurHighestAirFactoryTech] == 2 and not(bOnlyConsiderLandFactory) then
                if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ)) then
                    tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirHQ * categories.TECH2, false, true)
                    --Dont add factories that havent built much (for air fac will consider T1+ since may be building inties
                    for iFactory, oFactory in tPotentialUnits do
                        if M28Conditions.GetFactoryLifetimeCount(oFactory, categories.MOBILE - M28UnitInfo.refCategoryAirScout) > 5 then
                            AddPotentialUnitsToShortlist(toSafeUnitsToUpgrade, { oFactory })
                        end
                    end
                end
            end
            if oBrain[M28Economy.refiOurHighestLandFactoryTech] == 2 then
                if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ)) then
                    tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandHQ * categories.TECH2, false, true)
                    if M28Utilities.IsTableEmpty(tPotentialUnits) == false then
                        for iFactory, oFactory in tPotentialUnits do
                            --Dont add factories that havent built much
                            if M28Conditions.GetFactoryLifetimeCount(oFactory, categories.MOBILE * categories.TECH2) > 6 then
                                AddPotentialUnitsToShortlist(toSafeUnitsToUpgrade, { oFactory })
                            end
                        end
                    end


                end
            end
        end
    end

    if M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade) == false then
        local oUnitToUpgrade = M28Economy.GetBestUnitToUpgrade(toSafeUnitsToUpgrade)
        if oUnitToUpgrade then
            if bDebugMessages == true then LOG(sFunctionRef..': Will upgrade factory '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)) end
            M28Economy.UpgradeUnit(oUnitToUpgrade, true)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetAnyMexOrFactoryToUpgrade(iM28Team)
    --Backup logic for finding an upgrade if we have failed to find one through previous searches for a mex or factory

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetAnyMexOrFactoryToUpgrade'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local toUnitsThatCouldUpgrade = {}
    local tPotentialUnits
    local bPrioritiseFactory = false
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()) end
    --First consider any t1 factories
    for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
        --if oBrain[M28Economy.refiOurHighestAirFactoryTech] == 1 then
        if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ * categories.TECH1)) then
            tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirHQ * categories.TECH1, false, true)
            AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true)
        end
        --[[elseif oBrain[M28Economy.refiOurHighestAirFactoryTech] == 2 then
            if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ)) then
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirHQ * categories.TECH2, false, true)
                AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true)
            end--]]
        --end
        --if oBrain[M28Economy.refiOurHighestLandFactoryTech] == 1 then
        if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ * categories.TECH1)) then
            tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandHQ * categories.TECH1, false, true)
            AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true)
        end

        if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryNavalHQ * categories.TECH1)) then
            tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryNavalHQ * categories.TECH1, false, true)
            AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true)
        end
        --[[elseif oBrain[M28Economy.refiOurHighestLandFactoryTech] == 2 then
            if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ)) then
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandHQ * categories.TECH2, false, true)
                AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true)
            end --]]
        --end
        tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryT1Mex + M28UnitInfo.refCategoryT2Mex, false, true)
        AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true)
    end
    if M28Utilities.IsTableEmpty(toUnitsThatCouldUpgrade) then
        --If at T3 consider upgrading T2 support factories
        for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
            if oBrain[M28Economy.refiOurHighestAirFactoryTech] >= 3 then
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirFactory - categories.TECH3, false, true)
                if bDebugMessages == true then LOG(sFunctionRef..': We have T3+ air for brain '..oBrian.Nickname..' so will upgrade t2 support factories to T3, oBrain[M28Economy.refiOurHighestAirFactoryTech]='..(oBrain[M28Economy.refiOurHighestAirFactoryTech] or 'nil')..'; Is tPotentialUnits empty='..tostring(M28Utilities.IsTableEmpty(tPotentialUnits))) end
                AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true)
            end
            if oBrain[M28Economy.refiOurHighestLandFactoryTech] >= 3 then
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandFactory - categories.TECH3, false, true)
                if bDebugMessages == true then LOG(sFunctionRef..': We have T3+ land for brain '..oBrain.Nickname..' so will upgrade t2 support factories to T3, oBrain[M28Economy.refiOurHighestLandFactoryTech]='..(oBrain[M28Economy.refiOurHighestLandFactoryTech] or 'nil')..'; Is tPotentialUnits empty='..tostring(M28Utilities.IsTableEmpty(tPotentialUnits))) end
                AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true)
            end
            if oBrain[M28Economy.refiOurHighestNavalFactoryTech] >= 3 then
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryNavalFactory - categories.TECH3, false, true)
                AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true)
            else
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryNavalFactory * categories.TECH1, false, true)
                AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true)
            end
        end

        --If still no units to upgrade, and have positive net mass income and at least 40% mass stored, then consider factory upgrades

    end
    if M28Utilities.IsTableEmpty(toUnitsThatCouldUpgrade) == false then
        local oUnitToUpgrade = M28Economy.GetBestUnitToUpgrade(toUnitsThatCouldUpgrade)
        if bDebugMessages == true then LOG(sFunctionRef..': Have potential units to upgrade, oUnitToUpgrade='..(oUnitToUpgrade.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade) or 'nil')) end
        if oUnitToUpgrade then
            M28Economy.UpgradeUnit(oUnitToUpgrade, true)
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': No potential units to ugprade') end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function HaveEcoToSupportUpgrades(iM28Team)
    --Returns true if we think we can support another upgrade (for normal non-priority logic), but is less likely to return true early game if we want more land factories
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'HaveEcoToSupportUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --Do we have enough energy?
    tTeamData[iM28Team][subrefbTooLittleEnergyForUpgrade] = true --will change to false below if we have enough
    if bDebugMessages == true then LOG(sFunctionRef..': Start, GameTime='..GetGameTimeSeconds()..'; Gross energy='..(tTeamData[iM28Team][subrefiTeamGrossEnergy] or 'nil')..'; % stored='..(tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] or 'nil')..'; Net energy='..(tTeamData[iM28Team][subrefiTeamNetEnergy] or 'nil')..'; tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]='..(tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] or 'nil')..'; Active brain count='..(tTeamData[iM28Team][subrefiActiveM28BrainCount] or 'nil')..'; tTeamData[iM28Team][subrefiTeamGrossEnergy]='..(tTeamData[iM28Team][subrefiTeamGrossEnergy] or 'nil')..'; Net energy='..(tTeamData[iM28Team][subrefiTeamNetEnergy] or 'nil')..'; Min energy per tech='..(M28Economy.tiMinEnergyPerTech[tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]] or 'nil')) end
    if (tTeamData[iM28Team][subrefiTeamGrossEnergy] >= M28Economy.tiMinEnergyPerTech[tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]] * tTeamData[iM28Team][subrefiActiveM28BrainCount] or (tTeamData[iM28Team][subrefiTeamNetEnergy] > 5 * tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] * tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] and tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.98)) and tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.4 and (tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 25 * tTeamData[iM28Team][subrefiActiveM28BrainCount] or tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.9) and tTeamData[iM28Team][subrefiTeamNetEnergy] > 0 then
        --If already have active HQ upgrades, then double min energy wanted if net poweri sn't that high
        if tTeamData[iM28Team][subrefiTeamNetEnergy] > 15 or M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) or tTeamData[iM28Team][subrefiTeamGrossEnergy] >= M28Economy.tiMinEnergyPerTech[tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]] * 2 * tTeamData[iM28Team][subrefiActiveM28BrainCount] then
            local iNetEnergyIncomeWanted
            if tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.99 then iNetEnergyIncomeWanted = math.max(-tTeamData[iM28Team][subrefiTeamGrossEnergy] * 0.03, -25)
            elseif tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.95 then iNetEnergyIncomeWanted = tTeamData[iM28Team][subrefiTeamGrossEnergy] * 0.01
            elseif tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.9 then iNetEnergyIncomeWanted = math.max(4, tTeamData[iM28Team][subrefiTeamGrossEnergy] * 0.03)
            elseif tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.7 then iNetEnergyIncomeWanted = math.max(6, tTeamData[iM28Team][subrefiTeamGrossEnergy] * 0.06)
            else iNetEnergyIncomeWanted = 100
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Have enough gross energy, iNetEnergyIncomeWanted='..iNetEnergyIncomeWanted) end

            if (tTeamData[iM28Team][subrefiTeamNetEnergy] - tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle] > iNetEnergyIncomeWanted) then
                tTeamData[iM28Team][subrefbTooLittleEnergyForUpgrade] = false
                --Do we have enough mass to support the upgrade?
                local iNetMassIncomeWanted
                if tTeamData[iM28Team][subrefiTeamMassStored] >= 4000 then
                    if tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.9 then iNetMassIncomeWanted = math.min(-30, -tTeamData[iM28Team][subrefiTeamGrossMass] * 0.3)
                    elseif tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.7 then iNetMassIncomeWanted = math.min(-15, -tTeamData[iM28Team][subrefiTeamGrossMass] * 0.25)
                    elseif tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.4 then iNetMassIncomeWanted = math.min(-4, -tTeamData[iM28Team][subrefiTeamGrossMass] * 0.2)
                    elseif tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.3 then iNetMassIncomeWanted = math.min(-3, - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.15)
                    elseif tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.2 then iNetMassIncomeWanted = math.min(-2, - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.1)
                    else iNetMassIncomeWanted = math.min(-1, - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.075) end
                else
                    if tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.9 then iNetMassIncomeWanted = math.min(-1.5, -tTeamData[iM28Team][subrefiTeamGrossMass] * 0.3)
                    elseif tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.7 then iNetMassIncomeWanted = math.min(-1.2, -tTeamData[iM28Team][subrefiTeamGrossMass] * 0.25)
                    elseif tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.4 then iNetMassIncomeWanted = math.min(-0.9, -tTeamData[iM28Team][subrefiTeamGrossMass] * 0.2)
                    elseif tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.3 then iNetMassIncomeWanted = math.min(-0.6, - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.15)
                    elseif tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.2 and tTeamData[iM28Team][subrefiTeamMassStored] >= 600 then iNetMassIncomeWanted = math.min(-0.5, - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.1)
                    elseif tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.1 and tTeamData[iM28Team][subrefiTeamMassStored] >= 300 then iNetMassIncomeWanted = math.min(-0.4, - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.075)
                    elseif tTeamData[iM28Team][subrefiTeamMassStored] >= 300 then iNetMassIncomeWanted = - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.05
                    else iNetMassIncomeWanted = 0.1
                    end
                end

                if tTeamData[iM28Team][subrefiTeamMassStored] >= 5000 then iNetMassIncomeWanted = math.min(-5, iNetMassIncomeWanted - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.02) end

                if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) then
                    iNetMassIncomeWanted = iNetMassIncomeWanted - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.05
                    if tTeamData[iM28Team][subrefiTeamMassStored] >= 600 then iNetMassIncomeWanted = iNetMassIncomeWanted - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.05 end
                else
                    --Adjust net mass income wanted if we will use up our stored mass quickly and have active mex upgrades
                    if (iNetMassIncomeWanted < 0 and tTeamData[iM28Team][subrefiTeamNetMass] < 0) or tTeamData[iM28Team][subrefiTeamMassStored] <= 650 then
                        if tTeamData[iM28Team][subrefiTeamMassStored] <= 400 then iNetMassIncomeWanted = math.max(0, iNetMassIncomeWanted)
                        else
                            local iTimeUntilUseUpStoredMass = tTeamData[iM28Team][subrefiTeamMassStored] / -10 * (tTeamData[iM28Team][subrefiTeamNetMass] - tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle])
                            if iTimeUntilUseUpStoredMass <= 80 then
                                iNetMassIncomeWanted = math.max(-0.2, iNetMassIncomeWanted)
                            elseif iTimeUntilUseUpStoredMass <= 150 and (tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] >= 3 or (tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] >= 2 and GetGameTimeSeconds() - (tTeamData[iM28Team][refiTimeOfLastEnergyStall] or -20) < 20)) then
                                iNetMassIncomeWanted = math.max(-0.2, iNetMassIncomeWanted)
                            end
                        end
                        --Early game or low gross mass - restrict number of upgrades further
                        if (tTeamData[iM28Team][subrefiTeamGrossMass] < 2 * tTeamData[iM28Team][subrefiActiveM28BrainCount] or GetGameTimeSeconds() <= 300) and tTeamData[iM28Team][subrefiTeamMassStored] <= 650 then
                            iNetMassIncomeWanted = math.max(0.8, iNetMassIncomeWanted)
                        end
                    end
                end

                --Very high mass storage level adjustments
                if tTeamData[iM28Team][subrefiTeamMassStored] >= 5000 and iNetMassIncomeWanted <= -1 then
                    --Want to be spending mass at a rate taht means in 75 seconds we will have used up all the amount stored
                    iNetMassIncomeWanted = math.min(iNetMassIncomeWanted, -tTeamData[iM28Team][subrefiTeamGrossMass] * 0.3, -tTeamData[iM28Team][subrefiTeamMassStored] / 75)
                end




                --Average out our mass from the last 5 cycles as well
                local iLowestNetMass = tTeamData[iM28Team][subrefiTeamNetMass]
                for iLastEntry = 1, 5 do
                    iLowestNetMass = math.min(iLowestNetMass, (tTeamData[iM28Team][subreftiPrevTeamNetMass][iLastEntry] or tTeamData[iM28Team][subrefiTeamNetMass]))
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Consideringi f have enough mass, tTeamData[iM28Team][subrefiTeamMassStored]='..tTeamData[iM28Team][subrefiTeamMassStored]..'; % mass stored='..tTeamData[iM28Team][subrefiTeamLowestMassPercentStored]..'; Gross mass income='..tTeamData[iM28Team][subrefiTeamGrossMass]..'; Net mass income='..tTeamData[iM28Team][subrefiTeamNetMass]..'; Net mass wanted='..iNetMassIncomeWanted..'; Is table of upgrading mexes empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]))..'; tTeamData[iM28Team][subreftiPrevTeamNetMass]='..repru(tTeamData[iM28Team][subreftiPrevTeamNetMass])..'; iLowestNetMass - tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]='..iLowestNetMass - tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]..'; tTeamData[iM28Team][refiUpgradedMexCount]='..(tTeamData[iM28Team][refiUpgradedMexCount] or 'nil')) end
                if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) and (tTeamData[iM28Team][refiUpgradedMexCount] or 0) > 0 then iNetMassIncomeWanted = math.min(iNetMassIncomeWanted, 0) end

                if (iLowestNetMass - tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]) > iNetMassIncomeWanted then
                    if bDebugMessages == true then LOG(sFunctionRef..': We have enough energy and mass to get an upgrade; will now factor in if we would rather build more factories if are early game and enemy doesnt have T2, Time='..GetGameTimeSeconds()..'; iLowestNetMass='..iLowestNetMass..'; % mass stored='..tTeamData[iM28Team][subrefiTeamLowestMassPercentStored]..'; Gross mass income='..tTeamData[iM28Team][subrefiTeamGrossMass]..'; Highest enemy tech='..tTeamData[iM28Team][subrefiHighestEnemyGroundTech]..'; Map playable area size='..M28Map.rMapPlayableArea[3] - M28Map.rMapPlayableArea[1]) end
                    if tTeamData[iM28Team][subrefiTeamMassStored] <= 450 and GetGameTimeSeconds() <= 600 and tTeamData[iM28Team][subrefiHighestEnemyGroundTech] <= 1 and M28Map.iMapSize <= 512 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Early game on 10km or smaller map so want to only get a mex upgrade if we have loads of mass') end
                        if tTeamData[iM28Team][subrefiTeamMassStored] <= 600 and (M28Map.iMapSize <= 256 or (iLowestNetMass <= 0.6 * tTeamData[iM28Team][subrefiActiveM28BrainCount] and tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] <= 0.6)) then --or (tTeamData[iM28Team][subrefiTeamMassStored] <= 600 and tTeamData[iM28Team][subrefiTeamGrossMass] < 2 * tTeamData[iM28Team][subrefiActiveM28BrainCount]) then
                            if bDebugMessages == true then LOG(sFunctionRef..': We dont actually have eco to support upgrade due to being early game') end
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return false
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': We still have eco to support upgrade despite being early game') end
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Either not early game or we have lots of mass stored so think we have eco to get upgrade') end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': We dont have the eco to get an upgrade') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end


function ConsiderNormalUpgrades(iM28Team)
    --We should have already considered high priority upgrades before, now we want to consider upgrades if we have the eco to support upgrades generally
    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderNormalUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iMassUpgradesAtLoopStart
    local iCycleCount = 0

    local bLookForMexNotHQ

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, HaveEcoToSupportUpgrades for iM28Team '..iM28Team..'='..tostring(HaveEcoToSupportUpgrades(iM28Team))..'; Is table of mex upgrades empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]))..'; Is table of factory upgrades empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]))) end
    while HaveEcoToSupportUpgrades(iM28Team) do
        iCycleCount = iCycleCount + 1
        iMassUpgradesAtLoopStart = tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] --so we can check we actually upgraded something
        if bDebugMessages == true then LOG(sFunctionRef..': We think we have enough eco to support another upgrade, will decide if we want a mex or a factoroy, iCycleCOunt='..iCycleCount) end

        bLookForMexNotHQ = true

        --Get preferred upgrade type - ideally are always improving mass income (if have safe mexes to upgrade)
        if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) == false then
            --Already have mexes upgrading - do we want to also upgrade an HQ instead of a mex?
            if (tTeamData[iM28Team][subrefiTeamGrossMass] >= 2.5 and (tTeamData[iM28Team][subrefiTeamGrossMass] >= 5 and (tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 1 or tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] == 1) or (tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 1 and tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] == 1))) or ((tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 2 or tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] == 2) and tTeamData[iM28Team][subrefiTeamGrossMass] >= 8) then
                --Do we already ahve a factory HQ upgrading? If so then consider income based on player count
                if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) then
                    bLookForMexNotHQ = false
                else
                    if (tTeamData[iM28Team][subrefiTeamGrossMass] >= math.max(1.5, tTeamData[iM28Team][subrefiActiveM28BrainCount]) * 5 and (tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 1 or tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] == 1)) or ((tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 2 or tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] == 2) and tTeamData[iM28Team][subrefiTeamGrossMass] >= math.max(1.5, tTeamData[iM28Team][subrefiActiveM28BrainCount]) * 8) then
                        bLookForMexNotHQ = false
                    end
                end
            end
        else
            --No mex ugprading, but might want factory if we dont have access to T2/T3 yet and have high mass income
            if bDebugMessages == true then LOG(sFunctionRef..': Dont have a mex upgrading, will see if want a factory instead of a mex, tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech='..tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech]..'; tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]..'; tTeamData[iM28Team][subrefiTeamGrossMass]='..tTeamData[iM28Team][subrefiTeamGrossMass]..'; Player count='..tTeamData[iM28Team][subrefiActiveM28BrainCount]..'; tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]) end
            if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) then --since no mex upgrading, dont want to upgrade more than 1 factory at once
                if tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] == 1 then
                    if tTeamData[iM28Team][subrefiTeamGrossMass] >= math.max(1, tTeamData[iM28Team][subrefiActiveM28BrainCount] * 0.7) * 4 and tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 25 * math.max(1, tTeamData[iM28Team][subrefiActiveM28BrainCount] * 0.75) then
                        bLookForMexNotHQ = false
                    end
                elseif tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] == 2 then
                    if tTeamData[iM28Team][subrefiTeamGrossMass] > 8 * math.max(1, tTeamData[iM28Team][subrefiActiveM28BrainCount] * 0.7) and tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 100 then
                        bLookForMexNotHQ = false
                    end
                end
            end

        end
        if bDebugMessages == true then LOG(sFunctionRef..': iCycleCount='..iCycleCount..'; bLookForMexNotHQ='..tostring(bLookForMexNotHQ)..'; Is table of upgrading mexes empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]))..'; Is table of upgrading HQs empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]))..'; Team gross mass='..tTeamData[iM28Team][subrefiTeamGrossMass]..'; Lowest land fac tech='..tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]..'; Lowest air fac tech='..tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech]) end
        if bLookForMexNotHQ then
            GetSafeMexToUpgrade(iM28Team)
            --Backup - if didnt find anything then get a HQ upgrade if we dont already ahve a HQ upgrade active
            if bDebugMessages == true then LOG(sFunctionRef..': Tried to get a mex upgrade, tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]='..tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]..'; iMassUpgradesAtLoopStart='..iMassUpgradesAtLoopStart) end
            if tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] == iMassUpgradesAtLoopStart then
                if tTeamData[iM28Team][subrefiTeamGrossMass] >= 4 and M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Trying backup HQ upgrade as no mexes could be found') end
                    GetSafeHQUpgrade(iM28Team)
                end
            end
        else
            GetSafeHQUpgrade(iM28Team)
            if tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] == iMassUpgradesAtLoopStart then
                GetSafeMexToUpgrade(iM28Team)
            end
        end
        --If failed to find a mex or HQ upgrade from above:
        if tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] == iMassUpgradesAtLoopStart then
            --Only consider upgrading if have lots of mass
            if tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.5 and tTeamData[iM28Team][subrefiTeamMassStored] >= 700 and (tTeamData[iM28Team][subrefiTeamMassStored] >= 7000 or (tTeamData[iM28Team][subrefiTeamMassStored] >= 4000 and tTeamData[iM28Team][subrefiTeamNetMass] > -1) or tTeamData[iM28Team][subrefiTeamNetMass] > 0.5) then
                if bDebugMessages == true then LOG(sFunctionRef..': Will try and get any mex or HQ to upgrade as failed to find something to upgrade and have lots of mass, tTeamData[iM28Team][subrefiTeamNetMass]='..tTeamData[iM28Team][subrefiTeamNetMass]..'; mass stored='..tTeamData[iM28Team][subrefiTeamMassStored]) end
                GetAnyMexOrFactoryToUpgrade(iM28Team)
            end
        end

        --Keep searching for upgrades (if we have the eco to support) if we have just found something to upgrade
        if tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] > iMassUpgradesAtLoopStart then
            if iCycleCount >= 50 then
                M28Utilities.ErrorHandler('Likely infinite loop')
                break
            end
        else
            --Failed ot upgrade anything so abort to avoid risk of infinite loop
            break
        end
    end

    --T2 land factory exception even if dont have eco to support upgrades - if have a lot of mass, then consider upgrading even if lack energy
    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering normal upgrades; will now consider if we want a T2 factory even if we have low energy. tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]..'; tTeamData[iM28Team][subrefiTeamGrossMass]='..tTeamData[iM28Team][subrefiTeamGrossMass]..'; tTeamData[iM28Team][subrefiTeamGrossEnergy]='..tTeamData[iM28Team][subrefiTeamGrossEnergy]..'; tTeamData[iM28Team][subrefiTeamNetEnergy]='..tTeamData[iM28Team][subrefiTeamNetEnergy]..'; Stored mass='..tTeamData[iM28Team][subrefiTeamMassStored]..'; Is table of upgrading HQs empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]))..'; tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]='..tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]..'; tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]='..tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]) end
    if tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] == 1 and tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 1 and tTeamData[iM28Team][subrefiTeamGrossMass] >= 4 and tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 25 and (tTeamData[iM28Team][subrefiTeamNetEnergy] > 0 or tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 40) and tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] == 0 and (M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) or tTeamData[iM28Team][subrefiTeamMassStored] >= 500) and M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) then
        if bDebugMessages == true then LOG(sFunctionRef..': Dont have good eco but will get land fac upgrade anyway to help improve energy long term as are only at T1') end
        GetSafeHQUpgrade(iM28Team, true)
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderGettingUpgrades(iM28Team)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderGettingUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored]='..tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored]..'; Stalling energy='..tostring(tTeamData[iM28Team][subrefbTeamIsStallingEnergy])..'; Stalling mass='..tostring(tTeamData[iM28Team][subrefbTeamIsStallingMass])..'; tTeamData[iM28Team][subrefiTeamGrossMass]='..tTeamData[iM28Team][subrefiTeamGrossMass]..'; tTeamData[iM28Team][subrefiTeamGrossEnergy]='..tTeamData[iM28Team][subrefiTeamGrossEnergy]..'; tTeamData[iM28Team][subrefiTeamMassStored]='..tTeamData[iM28Team][subrefiTeamMassStored]..'; tTeamData[iM28Team][subrefiTeamLowestMassPercentStored]='..tTeamData[iM28Team][subrefiTeamLowestMassPercentStored]..'; tTeamData[iM28Team][subrefiTeamNetEnergy]='..tTeamData[iM28Team][subrefiTeamNetEnergy]) end
    if tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.6 and (GetGameTimeSeconds() >= 150 or (GetGameTimeSeconds() >= 60 and GetGameTimeSeconds() >= 150 / tTeamData[iM28Team][refiHighestBrainResourceMultipler]) or (tTeamData[iM28Team][subrefiTeamGrossMass] >= 3 and tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 50) or (tTeamData[iM28Team][subrefiTeamMassStored] >= 700 and tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.9 and tTeamData[iM28Team][subrefiTeamNetEnergy] >= 3 and tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.95)) and not(tTeamData[iM28Team][subrefbTeamIsStallingEnergy]) then
        if bDebugMessages == true then LOG(sFunctionRef..': Have enough energy that we will check for priority upgrades and then normal upgrades') end
        tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] = 0
        tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle] = 0

        --Priority upgrades even with poor eco:
        if (not(tTeamData[iM28Team][subrefbTeamIsStallingMass]) or (M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) and M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]))) then
            ConsiderPriorityLandFactoryUpgrades(iM28Team)

            ConsiderPriorityAirFactoryUpgrades(iM28Team)

            ConsiderPriorityNavalFactoryUpgrades(iM28Team)

            --Consider priority mex upgrades (e.g. we are falling far behind enemy on eco)
            ConsiderPriorityMexUpgrades(iM28Team)

            ConsiderNormalUpgrades(iM28Team)
        elseif tTeamData[iM28Team][subrefbTeamIsStallingMass] then
            --Want to keep upgrading mexes even if stalling mass
            --Also still consider upgrading HQ if have no upgrading HQs
            if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) and M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) == false and tTeamData[iM28Team][subrefiTeamGrossMass] >= 4 * tTeamData[iM28Team][subrefiActiveM28BrainCount] * tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] then
                if tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] == 1 then ConsiderPriorityLandFactoryUpgrades(iM28Team) else ConsiderPriorityAirFactoryUpgrades(iM28Team) end
                if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) then
                    if tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] == 1 then ConsiderPriorityAirFactoryUpgrades(iM28Team) else ConsiderPriorityLandFactoryUpgrades(iM28Team) end
                    if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) then
                        ConsiderPriorityNavalFactoryUpgrades(iM28Team)
                    end
                end
            end
            ConsiderPriorityMexUpgrades(iM28Team)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TeamEconomyRefresh(iM28Team)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TeamEconomyRefresh'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time='..GetGameTimeSeconds()..'; M28Map.bMapLandSetupComplete='..tostring(M28Map.bMapLandSetupComplete)..'; bWaterZoneInitialCreation='..tostring(M28Map.bWaterZoneInitialCreation)) end
    if M28Map.bMapLandSetupComplete and M28Map.bWaterZoneInitialCreation then
        tTeamData[iM28Team][subrefiTeamGrossEnergy] = 0
        tTeamData[iM28Team][subrefiTeamNetEnergy] = 0
        tTeamData[iM28Team][subrefiTeamGrossMass] = 0
        tTeamData[iM28Team][subrefiTeamNetMass] = 0
        tTeamData[iM28Team][subrefiTeamEnergyStored] = 0
        tTeamData[iM28Team][subrefiTeamMassStored] = 0
        tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] = 1
        tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] = 1
        tTeamData[iM28Team][subrefiLowestEnergyStorageCount] = 100





        for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
            tTeamData[iM28Team][subrefiTeamGrossEnergy] = tTeamData[iM28Team][subrefiTeamGrossEnergy] + oBrain[M28Economy.refiGrossEnergyBaseIncome]
            tTeamData[iM28Team][subrefiTeamGrossMass] = tTeamData[iM28Team][subrefiTeamGrossMass] + oBrain[M28Economy.refiGrossMassBaseIncome]
            --Adjust gross values if the recorded values seem significantly differnet - decided to leave out as there seems to be a 1 tick delay which causes discrepencies
            --[[if math.abs(oBrain[M28Economy.refiGrossEnergyBaseIncome] - oBrain:GetEconomyIncome('ENERGY')) >= math.max(30, oBrain[M28Economy.refiGrossEnergyBaseIncome] * 0.1) then
                M28Utilities.ErrorHandler('We have calculated gross energy income to be '..oBrain[M28Economy.refiGrossEnergyBaseIncome]..'; including reclaim though it appears to be '..oBrain:GetEconomyIncome('ENERGY')..'; will use the system generated value as wouldnt expect reclaim to cause such a big difference', true)
                oBrain[M28Economy.refiGrossEnergyBaseIncome] = oBrain:GetEconomyIncome('ENERGY')
            end--]]

            tTeamData[iM28Team][subrefiTeamNetEnergy] = tTeamData[iM28Team][subrefiTeamNetEnergy] + oBrain[M28Economy.refiNetEnergyBaseIncome]
            tTeamData[iM28Team][subrefiTeamNetMass] = tTeamData[iM28Team][subrefiTeamNetMass] + oBrain[M28Economy.refiNetMassBaseIncome]


            tTeamData[iM28Team][subrefiTeamEnergyStored] = tTeamData[iM28Team][subrefiTeamEnergyStored] + oBrain:GetEconomyStored('ENERGY')
            tTeamData[iM28Team][subrefiTeamMassStored] = tTeamData[iM28Team][subrefiTeamMassStored] + oBrain:GetEconomyStored('MASS')
            tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] = math.min(tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored], oBrain:GetEconomyStoredRatio('ENERGY'))
            tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] = math.min(tTeamData[iM28Team][subrefiTeamLowestMassPercentStored], oBrain:GetEconomyStoredRatio('MASS'))
            tTeamData[iM28Team][subrefiLowestEnergyStorageCount] = math.min(tTeamData[iM28Team][subrefiLowestEnergyStorageCount], oBrain:GetCurrentUnits(M28UnitInfo.refCategoryEnergyStorage))
            if bDebugMessages == true then LOG(sFunctionRef..': Considering brain '..oBrain.Nickname..'; Brain mass stored='..oBrain:GetEconomyStored('MASS')..'; Percent stored='..oBrain:GetEconomyStoredRatio('MASS')) end
        end

        if tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] <= 0.05 and (GetGameTimeSeconds() >= 120 or tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] <= 0.001) then tTeamData[iM28Team][subrefbTeamIsStallingEnergy] = true end
        if tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] == 0 and tTeamData[iM28Team][subrefiTeamMassStored] < tTeamData[iM28Team][subrefiActiveM28BrainCount] * 25 then
            tTeamData[iM28Team][subrefbTeamIsStallingMass] = true
            tTeamData[iM28Team][refiTimeOfLastMassStall] = GetGameTimeSeconds()
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Prev team net mass before update='..repru(tTeamData[iM28Team][subreftiPrevTeamNetMass])) end
        for iLastEntry = 5, 2, -1 do
            tTeamData[iM28Team][subreftiPrevTeamNetMass][iLastEntry] = (tTeamData[iM28Team][subreftiPrevTeamNetMass][iLastEntry-1] or 0)
        end
        tTeamData[iM28Team][subreftiPrevTeamNetMass][1] = tTeamData[iM28Team][subrefiTeamNetMass]
        if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Prev team net mass after update='..repru(tTeamData[iM28Team][subreftiPrevTeamNetMass])..'; team net mass='..tTeamData[iM28Team][subrefiTeamNetMass]..'; Team new gross mass='..tTeamData[iM28Team][subrefiTeamGrossMass]) end

        ForkThread(ConsiderGettingUpgrades, iM28Team)

        ForkThread(M28Economy.ManageEnergyStalls, iM28Team)

        if tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.9 then
            ForkThread(M28Economy.ManageMassOverflow, iM28Team)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckEnemyACUStatus(iTeam)
    if not(tTeamData[iTeam][refbEnemyHasUpgradedACU]) then
        local aiBrain
        for iBrain, oBrain in tTeamData[iTeam][subreftoFriendlyActiveM28Brains] do
            aiBrain = oBrain
            break
        end
        if M28Utilities.IsTableEmpty(tTeamData[iTeam][reftEnemyACUs]) == false then
            for iACU, oACU in  tTeamData[iTeam][reftEnemyACUs] do
                if M28UnitInfo.IsUnitValid(oACU) and (M28Conditions.CanSeeUnit(aiBrain, oACU, false) or GetGameTimeSeconds() >= 600) then --after 10m of gametime a human would assume enemy will have gun anyway
                    if oACU:IsUnitState('Upgrading') or (oACU[M28ACU.refiUpgradeCount] or 0) > 0 then
                        tTeamData[iTeam][refbEnemyHasUpgradedACU] = true
                    end
                end
            end
        end
    end
end
function CheckForUnitsWithDisabledWeapons(iTeam)
    if M28Utilities.IsTableEmpty(tTeamData[iTeam][reftoUnitsWithDisabledWeapons]) == false then
        local iRecordedUnits = table.getn(tTeamData[iTeam][reftoUnitsWithDisabledWeapons])
        for iCurUnit = iRecordedUnits, 1, -1 do
            local oUnit = tTeamData[iTeam][reftoUnitsWithDisabledWeapons][iCurUnit]
            if M28UnitInfo.IsUnitValid(oUnit) then
                --Has it been a while since we last wanted to disable the weapon?
                if GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeLastDisabledWeapon] or 0) >= 2.01 then
                    M28UnitInfo.EnableUnitWeapon(oUnit)
                end
            else
                --Unit not valid, remove from table
                table.remove(tTeamData[iTeam][reftoUnitsWithDisabledWeapons], iCurUnit)
            end
        end
    end
end


function TeamOverseer(iM28Team)
    while tTeamData[iM28Team][subrefiActiveM28BrainCount] > 0 do
        ForkThread(TeamEconomyRefresh, iM28Team)
        ForkThread(CheckEnemyACUStatus, iM28Team)
        ForkThread(CheckForUnitsWithDisabledWeapons, iM28Team)
        WaitTicks(10)
    end
end

function TeamInitialisation(iM28Team)
    --First check if we have any M28 brains in this team (otherwise dont do anything further)
    --NOTE: CreateNewTeam function includes various team setup variables
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TeamInitialisation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Will initialise team based logic for the team '..iM28Team..'; Is the table of friendly active M28 brains empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftoFriendlyActiveM28Brains]))..'; Do we already have an active team cycler='..tostring(tTeamData[iM28Team]['M28TeamActiveTeamCycler'] or false)) end

    M28Map.bFirstM28TeamHasBeenInitialised = true
    if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftoFriendlyActiveM28Brains]) == false then
        if not(tTeamData[iM28Team]['M28TeamActiveTeamCycler']) then
            tTeamData[iM28Team]['M28TeamActiveTeamCycler'] = true
            if bDebugMessages == true then LOG(sFunctionRef..': About to start land zone overseer which carries out main over time loop') end
            ForkThread(M28Land.LandZoneOverseer, iM28Team)
            ForkThread(TeamOverseer, iM28Team)
            ForkThread(M28Economy.TeamResourceSharingMonitor, iM28Team)
            ForkThread(M28Navy.WaterZoneOverseer, iM28Team)
        end
    end

    --Include variables for land zones
    for iPlateau, tPlateauData in M28Map.tAllPlateaus do
        for iLZ, tLZData in tPlateauData[M28Map.subrefPlateauLandZones] do
            if bDebugMessages == true then LOG(sFunctionRef..': Recording team data for iPlateau='..iPlateau..'; iLZ='..iLZ..'; iTeam='..iM28Team) end
            if not(tLZData[M28Map.subrefLZTeamData]) then tLZData[M28Map.subrefLZTeamData] = {} end
            tLZData[M28Map.subrefLZTeamData][iM28Team] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZTAlliedUnits] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefTEnemyUnits] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefMexCountByTech] = {[1]=0,[2]=0,[3]=0}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZTValue] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZSValue] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefAlliedACU] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefTThreatEnemyCombatTotal] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatEnemyBestMobileDFRange] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatEnemyBestStructureDFRange] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatEnemyBestMobileIndirectRange] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZIndirectThreatWanted] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZDFThreatWanted] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.refiRadarCoverage] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.refiOmniCoverage] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.refiRecentlyFailedScoutAttempts] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefQueuedBuildings] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatEnemyMobileDFTotal] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatEnemyMobileIndirectTotal] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatAllyMobileDFTotal] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatAllyMobileIndirectTotal] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatAllyMAA] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatAllyGroundAA] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefThreatEnemyStructureTotalMass] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.reftLZEnemyAirUnits] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.refiEnemyAirToGroundThreat] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.refiEnemyAirAAThreat] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.refiEnemyAirOtherThreat] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZMAAThreatWanted] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.reftoLZUnitsWantingMobileShield] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.reftoLZUnitWantingFixedShield] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.reftPriorityShieldsToAssist] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.reftoLZUnitsWantingMobileStealth] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subreftEnemyFirebasesInRange] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.reftUnitsWantingTMD] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.reftoTransportsWaitingForEngineers] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subreftoEnemyTMD] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subreftoEnemyPotentialTMLTargets] = {}
        end
    end
    --NOTE: Water zone data is handled via RecordClosestAllyAndEnemyBaseForEachWaterZone, to ensure it is run after water zones are created
    if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftoFriendlyActiveM28Brains]) == false then
        TeamEconomyRefresh(iM28Team)
        ForkThread(M28Map.RecordClosestAllyAndEnemyBaseForEachLandZone, iM28Team)
        ForkThread(M28Map.RecordClosestAllyAndEnemyBaseForEachWaterZone, iM28Team)
        M28Air.AirTeamInitialisation(iM28Team)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function WaterZoneTeamInitialisation(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'WaterZoneTeamInitialisation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iCurPlateau
    M28Map.bWaterZoneFirstTeamInitialisation = true
    tTeamData[iTeam][subrefiWaterZonesWantingSignificantMAAByPlateau] = {}
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at gamestime='..GetGameTimeSeconds()..', iTeam='..iTeam) end
    for iPond, tPondSubtable in M28Map.tPondDetails do
        for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
            iCurPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tWZData[M28Map.subrefMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': Setting starting values for iPond='..iPond..'; iWaterZone='..iWaterZone) end
            if not(tWZData[M28Map.subrefWZTeamData]) then tWZData[M28Map.subrefWZTeamData] = {} end
            if not(tWZData[M28Map.subrefWZTeamData][iTeam]) then tWZData[M28Map.subrefWZTeamData][iTeam] = {} end
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefMexCountByTech] = {[1]=0,[2]=0,[3]=0}
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZbCoreBase] = false --true if is a 'core' base (i.e. has a naval factory in)
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZbContainsNavalBuildLocation] = false --true if contains a naval build location for a friendly M28AI
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZTValue] = 0 --Value of the WZ, used to prioritise sending untis to different water zones; likely to be based on distance to core base water zone
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiRadarCoverage] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiSonarCoverage] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiOmniCoverage] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiRecentlyFailedScoutAttempts] = 0
            --tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refoBestRadar] --nil by default
            --tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.reftClosestFriendlyBase] --Updated separately
            --tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.reftClosestEnemyBase] --Updated separately
            --tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiModDistancePercent] --Updated separately
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refbWantLandScout] = false

            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZTAlliedUnits] = {}
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZTAlliedCombatUnits] = {}
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits] = {}
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.reftWZEnemyAirUnits] = {}
            --Threat values
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentWZ] = false

            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatEnemyAntiNavy] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatEnemySubmersible] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatEnemySurface] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatEnemyAA] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZBestEnemyDFRange] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZBestEnemyAntiNavyRange] = 0

            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.reftoNearestCombatEnemies] = {}

            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefThreatEnemyStructureTotalMass] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZTThreatAllyCombatTotal] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatAlliedAntiNavy] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatAlliedSubmersible] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatAlliedSurface] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatAlliedAA] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZBestAlliedDFRange] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZBestAlliedSubmersibleRange] = 0

            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZCombatThreatWanted] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZMAAThreatWanted] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefbWZWantsSupport] = false

            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.reftoWZUnitsWantingMobileShield] = {}
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refbWZWantsMobileShield] = false
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.reftoWZUnitsWantingMobileStealth] = {}
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refbWZWantsMobileStealth] = false

            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefTScoutsTravelingHere] = {}

            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiEnemyAirToGroundThreat] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiEnemyAirAAThreat] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiEnemyAirOtherThreat] = 0
            tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefAlliedACU] = {}

            if not(tTeamData[iTeam][subrefiWaterZonesWantingSignificantMAAByPlateau][iCurPlateau]) then tTeamData[iTeam][subrefiWaterZonesWantingSignificantMAAByPlateau][iCurPlateau] = {} end
        end
    end
    --Record any start positions of friendly M28AI that are on water as waterstartposition for team data
    local tUnderwaterM28StartPoints = {}
    for iBrain, oBrain in tTeamData[iTeam][subreftoFriendlyActiveM28Brains] do
        local iStartPositionX, iStartPositionZ = oBrain:GetArmyStartPos()
        local tStartPoint = {iStartPositionX, GetSurfaceHeight(iStartPositionX, iStartPositionZ), iStartPositionZ}
        if bDebugMessages == true then LOG(sFunctionRef..': tStartPoint='..repru(tStartPoint)..'; iStartPositionX='..iStartPositionX..'; iStartPositionZ='..iStartPositionZ..'; Surface height='..GetSurfaceHeight(iStartPositionX, iStartPositionZ)..'; Terrain height='..GetTerrainHeight(iStartPositionX, iStartPositionZ)) end
        if GetTerrainHeight(iStartPositionX, iStartPositionZ) < tStartPoint[2] then
            table.insert(tUnderwaterM28StartPoints, tStartPoint )
        end
    end
    if M28Utilities.IsTableEmpty(tUnderwaterM28StartPoints) == false then
        for iEntry, tStartPoint in tUnderwaterM28StartPoints do
            local iPlateauOrZero, iWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tStartPoint)
            if iPlateauOrZero == 0 and (iWaterZone or 0) > 0 then
                local tWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][iTeam]
                tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] = true
                if bDebugMessages == true then LOG(sFunctionRef..': Recording that iWaterzone'..iWaterZone..' is underwater for the M28 start position '..repru(tStartPoint)) end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateEnemyTechTracking(iM28Team, oUnit)
    local iUnitTechLevel = M28UnitInfo.GetUnitTechLevel(oUnit)
    if EntityCategoryContains(categories.LAND, oUnit.UnitId) then
        tTeamData[iM28Team][subrefiHighestEnemyGroundTech] = math.max(tTeamData[iM28Team][subrefiHighestEnemyGroundTech], iUnitTechLevel)
        if not(tTeamData[iM28Team][refbEnemyHasPerciesOrBricks]) then
            if oUnit.UnitId == 'xel0305' or oUnit.UnitId == 'xrl0305' then tTeamData[iM28Team][refbEnemyHasPerciesOrBricks] = true end
        end
    elseif EntityCategoryContains(categories.AIR, oUnit.UnitId) then tTeamData[iM28Team][subrefiHighestEnemyAirTech] = math.max(tTeamData[iM28Team][subrefiHighestEnemyAirTech], iUnitTechLevel)
    elseif EntityCategoryContains(categories.NAVAL, oUnit.UnitId) then tTeamData[iM28Team][subrefiHighestEnemyNavyTech] = math.max(tTeamData[iM28Team][subrefiHighestEnemyNavyTech], iUnitTechLevel)
    end
end

function GetCurrentUnitsOfCategory(iM28Team, iCategory)
    local iCurUnits = 0
    for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
        iCurUnits = iCurUnits + oBrain:GetCurrentUnits(iCategory)
    end
    return iCurUnits
end

function TransferUnitsToPlayer(tUnits, iArmyIndex, bCaptured)
    import('/lua/SimUtils.lua').TransferUnitsOwnership(tUnits, iArmyIndex, bCaptured)
end

function GiveAllResourcesToAllies(aiBrain)
    local iMassToGive = aiBrain:GetEconomyStored('MASS')
    local iEnergyToGive = aiBrain:GetEconomyStored('ENERGY')
    local iSpareMassStorage
    local iSpareEnergyStorage
    for iBrain, oBrain in tTeamData[aiBrain.M28Team][subreftoFriendlyActiveBrains] do
        if not(oBrain.M28IsDefeated) then
            iSpareMassStorage = 0
            iSpareEnergyStorage = 0
            if iMassToGive > 0 and aiBrain:GetEconomyStoredRatio('MASS') < 1 then
                iSpareMassStorage = M28Economy.GetMassStorageMaximum(aiBrain) * (1 -aiBrain:GetEconomyStoredRatio('MASS'))
            end
            if iEnergyToGive > 0 and aiBrain:GetEconomyStoredRatio('ENERGY') < 1 then
                iSpareEnergyStorage = M28Economy.GetEnergyStorageMaximum(aiBrain) * (1 -aiBrain:GetEconomyStoredRatio('ENERGY'))
            end

            if iSpareMassStorage + iSpareEnergyStorage > 0 then
                M28Economy.GiveResourcesToPlayer(aiBrain, oBrain, math.min(iMassToGive, iSpareMassStorage), math.min(iEnergyToGive, iSpareEnergyStorage))
            end

        end
        if iMassToGive + iEnergyToGive < 0 then break end
    end
end

function RefreshActiveBrainListForBrainDeath(oDefeatedBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshActiveBrainListForBrainDeath'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; brain '..oDefeatedBrain.Nickname..' has died, will update all teams for this, iTotalTeamCount='..iTotalTeamCount) end
    LOG('Brain death detected for '..oDefeatedBrain.Nickname)
    for iTeam = 1, iTotalTeamCount do
        if oDefeatedBrain.M28Team == iTeam then
            if M28Utilities.IsTableEmpty(tTeamData[iTeam][subreftoFriendlyActiveBrains]) == false then

                for iBrain, oBrain in tTeamData[iTeam][subreftoFriendlyActiveBrains] do
                    if oBrain == oDefeatedBrain then
                        if oBrain.M28AI then
                            for iM28Brain, oM28Brain in tTeamData[iTeam][subreftoFriendlyActiveM28Brains] do
                                if oM28Brain == oBrain then
                                    table.remove(tTeamData[iTeam][subreftoFriendlyActiveM28Brains], iM28Brain)
                                    break
                                end
                            end
                            tTeamData[iTeam][subrefiActiveM28BrainCount] = tTeamData[iTeam][subrefiActiveM28BrainCount] - 1
                        end
                        table.remove(tTeamData[iTeam][subreftoFriendlyActiveBrains], iBrain)
                        break
                    end
                end
            end
        else --Enemy team
            if M28Utilities.IsTableEmpty(tTeamData[iTeam][subreftoEnemyBrains]) == false then
                for iBrain, oBrain in tTeamData[iTeam][subreftoEnemyBrains] do
                    if oBrain == oDefeatedBrain then
                        table.remove(tTeamData[iTeam][subreftoEnemyBrains], iBrain)
                        break
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tTeamData[iTeam][subreftoEnemyBrains]) then
                tTeamData[iTeam][subrefbAllEnemiesDefeated] = true
            end
        end
    end

    --Remove from air subteam
    local iAirSubteam = oDefeatedBrain.M28AirSubteam
    if M28Utilities.IsTableEmpty(tAirSubteamData[iAirSubteam][subreftoFriendlyM28Brains]) == false then
        for iBrain, oBrain in tAirSubteamData[iAirSubteam][subreftoFriendlyM28Brains] do
            if oBrain == oDefeatedBrain then
                table.remove(tAirSubteamData[iAirSubteam][subreftoFriendlyM28Brains], iBrain)
                break
            end
        end
    end

    --Remove from land subteam
    local iLandSubteam = oDefeatedBrain.M28LandSubteam
    if M28Utilities.IsTableEmpty(tLandSubteamData[iLandSubteam][subreftoFriendlyM28Brains]) == false then
        for iBrain, oBrain in tLandSubteamData[iLandSubteam][subreftoFriendlyM28Brains] do
            if oBrain == oDefeatedBrain then
                table.remove(tLandSubteamData[iLandSubteam][subreftoFriendlyM28Brains], iBrain)
                break
            end
        end
    end



    for iArmyIndex, oBrain in M28Overseer.tAllAIBrainsByArmyIndex do
        if oDefeatedBrain == oBrain then
            M28Overseer.tAllAIBrainsByArmyIndex[iArmyIndex] = nil
            M28Overseer.tAllActiveM28Brains[iArmyIndex] = nil --Should only have had a value for m28 brains anyway but this is a redundancy
        end
    end

    --Update primary enemy base locations for M28 brain if their nearest brain is now defeated
    if M28Utilities.IsTableEmpty(M28Overseer.tAllActiveM28Brains) == false then
        for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
            if oBrain[M28Overseer.refoNearestEnemyBrain].M28IsDefeated then
                M28Map.UpdateNewPrimaryBaseLocation(oBrain)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TeamDeathChecker()
    WaitSeconds(1) --Make sure have given time for brains to be setup
    if not(bActiveTeamDeathChecker) and not(ScenarioInfo.Options.Victory == "demoralization") then
        bActiveTeamDeathChecker = true
        while M28Utilities.bM28AIInGame do
            --Treat any players as defeated when they show as defeated
            WaitSeconds(1)
            for iBrain, oBrain in ArmyBrains do
                if oBrain:IsDefeated() and not(oBrain.M28IsDefeated) then
                    ForkThread(M28Events.OnPlayerDefeated, oBrain)
                end
            end
        end
        bActiveTeamDeathChecker = false
    end
end

function DelayedPlayerDeathCheck()
    WaitSeconds(1)
    for iBrain, oBrain in ArmyBrains do
        if oBrain:IsDefeated() and not(oBrain.M28IsDefeated) then
            M28Events.OnPlayerDefeated(oBrain)
        end
    end
end

function ConsiderGiftingStorageToTeammate(oEnergyStorage)
    --If have a teammate with less energy storage then will gift the energy storage to them
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderGiftingStorageToTeammate'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain = oEnergyStorage:GetAIBrain()
    local iTeam = aiBrain.M28Team
    if bDebugMessages == true then LOG(sFunctionRef..': Brain '..aiBrain.Nickname..' has just built energy storage '..oEnergyStorage.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnergyStorage)..'; active M28 brain count for team '..iTeam..' = '..tTeamData[iTeam][subrefiActiveM28BrainCount]..'; Total no. of storage for this brain='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEnergyStorage)..'; lowest storage count for team='..tTeamData[iTeam][subrefiLowestEnergyStorageCount]) end
    if tTeamData[iTeam][subrefiActiveM28BrainCount] > 1 then
        local iOurEnergyStorage = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEnergyStorage)
        if iOurEnergyStorage >= 2 and iOurEnergyStorage > 1 + tTeamData[iTeam][subrefiLowestEnergyStorageCount] then
            for iBrain, oBrain in  tTeamData[iTeam][subreftoFriendlyActiveM28Brains] do
                if not(oBrain == aiBrain) and oBrain:GetCurrentUnits(M28UnitInfo.refCategoryEnergyStorage) + 1 < iOurEnergyStorage then
                    --We have 2 less energy storage so want to give this storage to them
                    if bDebugMessages == true then LOG(sFunctionRef..': Brain '..oBrain.Nickname..' only has '..oBrain:GetCurrentUnits(M28UnitInfo.refCategoryEnergyStorage)..' energy storage so will gift this storage to them') end
                    TransferUnitsToPlayer({ oEnergyStorage }, oBrain:GetArmyIndex(), false)
                    ForkThread(TeamEconomyRefresh, iTeam)
                    break
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetFirstActiveM28Brain(iTeam)
    if M28Utilities.IsTableEmpty(tTeamData[iTeam][subreftoFriendlyActiveM28Brains]) == false then
        for iBrain, oBrain in tTeamData[iTeam][subreftoFriendlyActiveM28Brains] do
            if not(oBrain.M28IsDefeated) then
                return oBrain
            end
        end
    end
end

function GiftAdjacentStorageToMexOwner(oJustBuilt, oOptionalBrainToGiftTo)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GiftAdjacentStorageToMexOwner'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tMexLocation = oJustBuilt:GetPosition()
    local rSearchRectangle = M28Utilities.GetRectAroundLocation(tMexLocation, 2.749) --If changing this also change M28Economy and M28Engineer similar value
    local tNearbyUnits = GetUnitsInRect(rSearchRectangle) --at 1.5 end up with storage thats not adjacent being gifted in some cases but not in others; at 1 none of it gets gifted; the mass storage should be exactly 2 from the mex; however even at 2.1, 2.25 and 2.499 had cases where the mex wasnt identified so will try 2.75 since distances can vary/be snapped to the nearest 0.5 I think
    local iBrainIndexToGiftTo
    if oOptionalBrainToGiftTo then iBrainIndexToGiftTo = oOptionalBrainToGiftTo:GetArmyIndex()
    else iBrainIndexToGiftTo = oJustBuilt:GetAIBrain():GetArmyIndex()
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Storage gifting where built mex - oJustBuilt='..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; owner='..oJustBuilt:GetAIBrain().Nickname..'; is tNearbyUnits empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnits))) end
    if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
        local tNearbyStorage = EntityCategoryFilterDown(M28UnitInfo.refCategoryMassStorage, tNearbyUnits)
        if M28Utilities.IsTableEmpty(tNearbyStorage) == false then
            for iUnit, oUnit in tNearbyStorage do
                if IsAlly(iBrainIndexToGiftTo, oUnit:GetAIBrain():GetArmyIndex()) then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to transfer '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from brain '..oUnit:GetAIBrain().Nickname..' to '..oJustBuilt:GetAIBrain().Nickname..'; Dist from unit to tMexLocation='..M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition())) end
                    if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMexLocation) <= 2.25 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and gift the storage to the player that built the mex') end
                        TransferUnitsToPlayer({oUnit}, iBrainIndexToGiftTo, false)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordMobileEnemyTMLForTeam(oTML, iTeam)
    local bAlreadyIncluded = false
    if not(tTeamData[iTeam][reftEnemyMobileTML]) then
        tTeamData[iTeam][reftEnemyMobileTML] = {}
    elseif M28Utilities.IsTableEmpty(tTeamData[iTeam][reftEnemyMobileTML]) == false then
        for iUnit, oUnit in tTeamData[iTeam][reftEnemyMobileTML] do
            if oUnit == oTML then bAlreadyIncluded = true end
        end
    end
    if not(bAlreadyIncluded) then
        table.insert(tTeamData[iTeam][reftEnemyMobileTML], oTML)
        oTML[M28Building.reftMobileTMLLastLocationChecked] = nil
        ForkThread(MonitorEnemyMobileTMLThreats, iTeam)
    end
end

function RecordMobileTMLThreatForAllEnemyTeams(oTML)
    --Intended for ACUs, SACUs, and potentially UEF/Sera cruisers and Aeon missile ship
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordMobileTMLThreatForAllEnemyTeams'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    while not(M28Map.bMapLandSetupComplete) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if GetGameTimeSeconds() >= 10 then break end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for oTML='..(oTML.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTML) or 'nil')) end
    if M28UnitInfo.IsUnitValid(oTML) then
        if M28Utilities.IsTableEmpty(M28Overseer.tAllActiveM28Brains) == false then
            local tiTeamsToUpdate = {}
            local iTMLArmyIndex = oTML:GetAIBrain():GetArmyIndex()
            local bUnitIsValid = true
            for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                if not(tiTeamsToUpdate[oBrain.M28Team]) and IsEnemy(oBrain:GetArmyIndex(), iTMLArmyIndex) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oBrain='..oBrain.Nickname..'; Team='..(oBrain.M28Team or 'nil')) end
                    while not(oBrain.M28Team) do --Cybran mission 4 causes lua error due to this triggering before teams have been assigned
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        bUnitIsValid = false
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        if GetGameTimeSeconds() >= 10 then break end
                    end
                    if not(bUnitIsValid) then bUnitIsValid = M28UnitInfo.IsUnitValid(oTML) end
                    if bUnitIsValid then
                        tiTeamsToUpdate[oBrain.M28Team] = true
                    end
                end
                if M28Utilities.IsTableEmpty(tiTeamsToUpdate) == false and bUnitIsValid then
                    for iTeam, bUpdate in tiTeamsToUpdate do
                        RecordMobileEnemyTMLForTeam(oTML, iTeam)
                    end
                end
            end
        end
    end
end

function MonitorEnemyMobileTMLThreats(iTeam)
    --Whenever an enemy mobile TML threat has moved by more than 15 from its last recorded postiion, update its targets
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MonitorEnemyMobileTMLThreats'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, activem TML monitor='..tostring(tTeamData[iTeam][refbActiveMobileTMLMonitor] or false)..'; Gametime='..GetGameTimeSeconds()) end
    if not(tTeamData[iTeam][refbActiveMobileTMLMonitor]) then
        tTeamData[iTeam][refbActiveMobileTMLMonitor] = true
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy mobile TML empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iTeam][reftEnemyMobileTML]))) end
        while M28Utilities.IsTableEmpty(tTeamData[iTeam][reftEnemyMobileTML]) == false do
            local iTicksWaitedThisCycle = 0
            if M28Conditions.IsTableOfUnitsStillValid(tTeamData[iTeam][reftEnemyMobileTML]) then
                for iUnit, oUnit in tTeamData[iTeam][reftEnemyMobileTML] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to update oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Cur position='..repru(oUnit:GetPosition())..'; Last location checked='..repru(oUnit[M28Building.reftMobileTMLLastLocationChecked])..'; Time since last hceck='..GetGameTimeSeconds() - (oUnit[M28Building.refiTimeMobileTMLLastChecked] or -1000)) end
                    if not(oUnit[M28Building.reftMobileTMLLastLocationChecked]) or GetGameTimeSeconds() - (oUnit[M28Building.refiTimeMobileTMLLastChecked] or -100) >= 60 or M28Utilities.GetDistanceBetweenPositions(oUnit[M28Building.reftMobileTMLLastLocationChecked], oUnit:GetPosition()) >= 10 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will record units in range of TML now') end
                        M28Building.RecordUnitsInRangeOfTMLAndAnyTMDProtection(oUnit)
                        oUnit[M28Building.reftMobileTMLLastLocationChecked] = {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]}
                        oUnit[M28Building.refiTimeMobileTMLLastChecked] = GetGameTimeSeconds()
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        iTicksWaitedThisCycle = iTicksWaitedThisCycle + 1
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    end
                end
            else
                break
            end
            if iTicksWaitedThisCycle < 50 then --Want to refresh no more quickly than once every 5s
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(50 - iTicksWaitedThisCycle)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
        end
        tTeamData[iTeam][refbActiveMobileTMLMonitor] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end