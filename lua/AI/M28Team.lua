---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 07/12/2022 07:50
---

local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local NavUtils = M28Utilities.NavUtils
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Events = import('/mods/M28AI/lua/AI/M28Events.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Config = import('/mods/M28AI/lua/M28Config.lua')
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')


--Team data variables
bActiveTeamDeathChecker = false
bRecordedAllPlayers = false
iPlayersAtGameStart = 0
iTotalTeamCount = 0 --Increased by 1 each time we create a new team
tBrainIndexesRecordedAsEnemies = {} --[x] is the armyindex, returns true if we have recorded as an enemy for a team
tTeamData = {} --[x] is the aiBrain.M28Team number - stores certain team-wide information
    --Subteam details
    subrefAirSubteamsInTeam = 'M28AirSubteamInT' --returns table of air subteam numbers in this team
    --Brain details
    subrefbAllEnemiesDefeated = 'M28TeamAllEnemiesDefeated' --true if all enemies of the team have been defeated
    subreftoFriendlyActiveM28Brains = 'M28TeamFriendlyM28Brains' --Stored against tTeamData[brain.M28Team], in sequential order (1,2,3...) rather than the key being any other value (i.e. its not army index), returns table of all M28 brains on the same team (including this one)
    subrefiActiveM28BrainCount = 'ActiveM28Count' --number of active m28 brains we have in the team
    subrefiOrigM28BrainCount = 'OrigM28Count' --number of M28 brains on the team (ignoring any that have died)
    subreftoFriendlyHumanAndAIBrains = 'M28TeamFriendlyBrains' --as above, but all friendly brains on this team, tTeamData[brain.M28Team][subreftoFriendlyHumanAndAIBrains]
    subreftoEnemyBrains = 'M28TeamEnemyBrains'
    rebTeamOnlyHasCampaignAI = 'M28TeamOnlyCampAI' --True if team only has campaign AI on it (so can e.g. disable the 'check playable area' tests in some scenarios
    refiHighestBrainResourceMultiplier = 'M28HighestMult' --Highest AIx Resource on team (as a number)
    refiHighestBrainBuildMultiplier = 'M28HighestBPMult' --Highest AIx BP modifier on team (as a number)
    refbFocusOnT1Spam = 'M28TeamAvdT2Mx' --if true will try and avoid t2 mex and spam land
    refbActiveT1SpamMonitor = 'M28TeamAcTSpM' --true if have active t1 spam monitor
    refiTimeOfLastTeammateDeath = 'M28TeamLstTmD' --gametimeseconds that a teammate last died (based on ACU dying in demoralisation)

    --Team economy subrefs
    refiPausedUnitCount = 'M28TeamPausTo' --total number of paused units
    subreftoPausedUnitsByPriority = 'M28TeamPausByPr' --[x] is the priority (e.g. 1 = first things to be paused, 2 = 2nd etc.), returns table of paused units for that priority
    subrefiTeamGrossEnergy = 'M28TeamGrossEnergy'
    subrefiTeamNetEnergy = 'M28TeamNetEnergy'
    subrefiTeamGrossMass = 'M28TeamGrossMass'
    subrefiTeamNetMass = 'M28TeamNetMass'
    subreftiPrevTeamNetMass = 'M28TeamPrevNetMass' --{[1]=x, [2]=y... up to [5]} -i.e. the net mass value for the prev 5 checks (so can take average)
    subrefiTeamEnergyStored = 'M28TeamEnergyStored'
    subrefiTeamMassStored = 'M28TeamMassStored'
    subrefiTeamAverageEnergyPercentStored = 'M28TeamAvEnergyPercent' --dont want lowest, as have an issue in campaign or sandbox if one player loses almost all units
    subrefiTeamAverageMassPercentStored = 'M28TeamAvMassPercent' --dont want lowest, as have an issue in campaign or sandbox if one player loses almost all units
    subrefbTeamIsStallingEnergy = 'M28TeamStallingEnergy'
    subrefbTeamIsStallingMass = 'M28TeamStallingMass'
    subrefbStallingMassFlaggedFromTeamEconomy = 'M28TmStlFrE' --If our economy refresh flags we are stalling this is true, meaning we will then realise change is required for the mass stall
    refiTimeOfLastMassStall = 'M28TeamTimeLastMassStall' --Gametimeseconds that we were last stalling mass
    subrefbTooLittleEnergyForUpgrade = 'M28TeamTooLittleEnergyForUpgrade' --true if we havent got an upgrade due to lack of power
    subrefbActiveT1PowerReclaimer = 'M28TeamActiveT1PowerReclaimer'
    subrefbActiveT2PowerReclaimer = 'M28TeamActiveT2PowerReclaimer'
    refbJustBuiltLotsOfPower = 'M28TeamJustBuiltPower' --temporarily set to true after building an early T2/T3 PGen so we dont think for hte few seconds after building it that we are power stalling if we have low % of power
    subrefiLowestEnergyStorageCount = 'M28TeamLowestEStorage' --Lowest number of EStorage owned by an M28 brain on the team
    subrefiGrossEnergyWhenStalled = 'M28TeamGrossEWhenStalled' --Amount of energy team had (gross) when we had a power stall
    refiTimeOfLastEnergyStall = 'M28TeamTimeOfLastEnergyStall'
    refiTimeLastConsideredEnergyStall = 'M28TeamTimeConsStall' --Used so in easymode can ensure a c.2s gap
    refiTimeLastNeededEnergyForOvercharge = 'M28TeamTimeLastNeedEForOC' --Gametimeseconds that an ACU oculdnt afford to overcharge despite having enough energy storage capacity, and having its weapon cooled down, with significant enemies in range
    refiLastMassStallCategoryAndEngineerTables = 'M28TeamMssStlCatTbl' --the category and engineer tables for pausing in a mass stall
    refiLastEnergyStallCategoryAndEngineerTables = 'M28TeamEneStlCatTbl' --the category and engineer tables for pausing in an energy stall
    refiEnergyWhenAirFactoryLastUnableToBuildAir = 'M28TeamEnergyAirFacUnableToBuildAir' --Team Gross energy when air factory didnt consider building air units due to lack of energy
    refiTimeOfLastEngiSelfDestruct = 'M28TeamTimeOfLastEnegiSelfDestruct'
    refbNeedResourcesForMissile = 'M28TeamNeedResourcesForMissile' --true if are building nuke or smd that needs a missile
    refiTimeOfLastOverflowEngiCheck = 'M28TeamOverflowCheck' --gametimeseconds that we last cleared engineers from recliaming
    refiUpgradedMexCount = 'M28TeamUpgradedMexCount'
    refiMexCountByTech = 'M28TeamMexByTech' --for all brains, not just M28 brains, treats a 1% complete mex as being completed for these purposes (to simplify code)
    refbBuiltParagon = 'M28TeamBltPa' --true if an M28 brain on the team has a paragon
    refiTimeLastIssuedACUEnhancementOrder = 'M28TeamTimLstAU' --Gametimeseconds that we last started an ACU upgrade (used to try and avoid getting multiple upgrades within 2s of each other)

    subreftTeamUpgradingHQs = 'M28TeamUpgradingHQs'
    subreftTeamUpgradingMexes = 'M28TeamUpgradingMexes'
    subreftTeamUpgradingACUs = 'M28TeamUpgradingACUs'
    subreftTeamUpgradingOther = 'M28TeamUpgradingOther'
    subrefiMassUpgradesStartedThisCycle = 'M28TeamMassUpgradesThisCycle' --Amount of mass per tick that we have committed in upgrades this cycle
    subrefiEnergyUpgradesStartedThisCycle = 'M28TeamEnergyUpgradesThisCycle' --Amount of energy per tick that we have committed in upgrades this cycle
    subreftTeamEngineersBuildingExperimentals = 'M28TeamEngineersBuildingExperimentals' --table of engineers building an experimental level unit anywhere in our team
    reftoNonM28ConstructingExpAndT3Navy = 'M28TeamNonM28ExpC' --table of experimental level units being built by non-M28 teammates


    --Tech level and factory details (subteam will track factories in more detail by tech and faction and type)
    subrefiHighestEnemyGroundTech = 'M28TeamHighestEnemyGround'
    subrefiHighestEnemyAirTech = 'M28TeamHighestEnemyAir'
    subrefiHighestEnemyNavyTech = 'M28TeamHighestEnemyNavy'
    subrefiLowestFriendlyLandFactoryTech = 'M28TeamLowestFriendlyGround' --Returns the lowest M28Brain's highest tech of this type, i.e. if an M28 brain has a T1 and T2 land factory, and another has a T3 land factory, then this would return 2.
    subrefiLowestFriendlyAirFactoryTech = 'M28TeamLowestFriendlyAir' --Returns the lowest M28Brain's highest tech of this type, i.e. if an M28 brain has a T1 and T2 air factory, and another has a T3 air factory, then this would return 2.
    subrefiLowestFriendlyNavalFactoryTech = 'M28TeamLowestFriendlyNaval'
    subrefiHighestFriendlyFactoryTech = 'M28TeamHighestFriendlyFactory'
    subrefiHighestFriendlyLandFactoryTech = 'M28TeamHighestFriendlyGround' --Returns the Highest M28Brain's highest tech of this type, i.e. if an M28 brain has a T1 and T2 land factory, and another has a T3 land factory, then this would return 3.
    subrefiHighestFriendlyAirFactoryTech = 'M28TeamHighestFriendlyAir' --Returns the Highest M28Brain's highest tech of this type, i.e. if an M28 brain has a T1 and T2 air factory, and another has a T3 air factory, then this would return 3.
    subrefiHighestFriendlyNavalFactoryTech = 'M28TeamHighestFriendlyNaval'
    --subrefiHighestEnemyMexTech = 'M28TeamHighestEnemyMex' --I.e. 1, 2 or 3
    subrefiTotalFactoryCountByType = 'M28TeamFactoryByType' --[x] is the factory type, returns the number that our team has; factory type per M28Factory.refiFactoryType..., e.g. M28Factory.refiFactoryTypeLand
    refbBuiltLotsOfT3Combat = 'M28TeamBuiltLotsOfT3Combat' --true once we have reached a certain lifetime count of T3 combat units (used e.g. to decide if we want to build an experimental)
    refiTimeLastHadNothingToBuildForAirFactory = 'M28TeamAirFacTimNoBuild' --Gametimeseconds that failed to find something to do with air factory that was our highest tech level
    refiTimeLastHadNothingToBuildForLandFactory = 'M28TeamLandFacTimNoBuild' --Gametimeseconds that failed to find something to do with land fac that was our highest tech level

    --Intel details
    subrefbTeamHasOmniVision = 'M28TeamHaveOmni' --True if our team has omni vision (i.e. one of our team is an AIx with omni vision)
    subrefbEnemyHasOmni = 'M28EnemyHasOmni' --true if any enemy non-civilian brains have omni vision
    subrefbEnemyBuiltOmni = 'M28EnemyBuiltOmni' --true if any enemy has built omni at any point in the game (used as basic threshold for deciding whether to build things like deceivers)
    subrefiTimeOfScoutingShortlistUpdate = 'M28ScoutShortlistUpd' --Gametimeseconds that last updated the list of scouting locations to update
    subreftLandAndWaterZoneScoutingShortlist = 'M28ScoutShortlistLWZ' --entries 1,2,... (in no particular order) - returns {PlateauOrZero, LandOrWZRef} for any land or water zones where scouting is overdue
    subrefiLongestOverdueScoutingTarget = 'M28TmLngSct' --Longest overdue scouting target in seconds
    subrefbUseFrigatesAsScoutsByPond = 'M28UseFrgAsScout' --[x] is the pond ref, returns true if frigates should be used as scouts
    iEnemyT3MAAActiveCount = 'M28EnT3MAACn' --Number of enemy T3 MAA (approximate measure)
    reftRecentEnemyTeleportDetails = 'M28EnTelD' --contains subtables for recent enemy teleports, [x] = 1,2,3,...; returns {oUnitTeleporting, tTeleportDestination, iTimeOfTeleport}
        subrefoTeleportUnit = 1
        subreftTeleportTarget = 2
        subrefiTeleportTime = 3
    subrefbEnemyGettingFabsOrRAS = 'M28TeamEnRASFab' --true if enemy has been detected building mass fabs or RAS SACUs


    --Notable unit count and threat details
    refbDefendAgainstArti = 'M28TeamDefendAgainstArti' --true if enemy has t3 arti or equivelnt
    refiEnemyT3ArtiCount = 'M28TeamT3ArtC' --Number of enemy t3 arti and exp arti (exp arti count as 3)
    refiEnemyNovaxCount = 'M28TeamNovC' --Number of enemy novax
    reftEnemyTML = 'M28TeamEnTML' --table of enemy TML
    reftEnemyMobileTML = 'M28TeamEnMobTML' --Table of enemy TML, includes cruisers and missile ships
    refbActiveMobileTMLMonitor = 'M28TeamActiveMobTM' --True if have an active monitor for this team
    reftEnemyLandExperimentals = 'M28TeamELandE'
    reftEnemyAirExperimentals = 'M28AirExp'
    reftEnemyArtiAndExpStructure = 'M28TeamEArtiExp'
    reftEnemyNukeLaunchers = 'M28TeamENuke'
    reftEnemySMD = 'M28TeamESMD'
    reftEnemyBattleships = 'M28TeamEBS' --table of enemy battleships
    reftEnemyMobileSatellites = 'M28TeamESat' --table of novax satellites; done to avoid double-counting threat if include in reftEnemyArtiAndExpStructure (which has the centre)
    refbEnemySMDBuiltSinceLastNukeCheck = 'M28TeamESMDBuilt' --True when enemy SMD is detected, used to decide to rerun logic for identifying nuke land zone targets for deciding whether to build nuke
    refbEnemySMDDiedSinceLastNukeCheck = 'M28TeamESMDDied' --True when enemy SMD is dies, used to decide to rerun logic for identifying nuke land zone targets for deciding whether to build nuke
    refbEnemyHasSub = 'M28EnemyHasSub' --true if enemy has sub - used to be more cautious with ACU
    reftEnemyACUs = 'M28EnemyACUs' --Table of all enemy ACUs
    reftM28ACUs = 'M28FriendlyACUs' --table of M28 ACUs on the team
    refbEnemyHasUpgradedACU = 'M28TeamEnUpgACU' --true if enemy has an ACU that is upgrading or upgraded
    reftCoreLZsTimeOfApproachingACUByPlateauAndZone = 'M28TApprACULZ' --table, entry [iPlateau][iLandZoneRef], returns gametimeseconds that flagged as having an approaching ACU
    reftCloakedEnemyUnits = 'M28CloakedE' --long range mobile units like fatboy, and long ranged PD like ravagers
    reftLongRangeEnemyDFUnits = 'M28LREUn'
    reftoEnemyT2Arti = 'M28LRArt' --Table of all enemy T2 arti (regardless of kills) - note firebase adj is used for those that are more dangerous
    refbStartedOnUnitWantingSpecialShielding = 'M28AGESt' --true if we have sent an order to build a gameender/unit wanting special shielding (currently used to decide if we need to be strict about blacklist locations)
    reftoAlliedQuantumOptics = 'M28QOU' --Table of M28 allied quanutm optics units

    subrefiAlliedDFThreat = 'M28TeamDFThreat' --Total DF threat
    subrefiAlliedIndirectThreat = 'M28TeamIndirectThreat' --Total indirect threat
    subrefiAlliedGroundAAThreat = 'M28TeamGroundAAThreat' --Total MAA and structure threat
    subrefiAlliedMAAThreat = 'M28TeamMAAThreat' --Total MAA threat only (excludes structure)
    refbEnemyHasPerciesOrBricks = 'M28TeamEnemyHasBrickOrPercy' --true if enemy has percy or brick unit at any time in the game
    refiEnemyHighestMobileLandHealth = 'M28TeamEnemyHighestMobileLandHealth' --Used to calculate storage wanted
    refiHighestEnemyDFRangeByPlateau = 'M28TeamHighestDFRgbp' --[x] is plareau, returns highest detected df range, eg so we stop building mml when enemy has ravager
    refbDangerousForACUs = 'M28TeamDangerousForACUs' --True if are big threats that mean we should keep ACU at base
    reftEnemyFirebaseByPlateauAndLZ = 'M28TeamEnemyFirebase' --[x] is the plateua, [y] is the LZ, returns the below subrefs
        subrefiNearbyPlateauAndLandZones = 'NrbyPLZ' --ordered 1, 2 etc. in order that added, returning {iPlateau, iLandZone} for any land zone that shoudl consider itself in range of the firebase in question
        subrefbInRangeOfCoreLZ = 'NearCLZ' --true if one of the land zones this firebase is likely in range of is a core land zone

    --Land combat related
    subrefiLandZonesWantingSupportByPlateau = 'M28TeamLZWantingSupport' --[x] is the plateau ref, [y] is the land zone ref, returns true if we want support for the plateau
    subrefiLandZonesWantingMAAByPlateau = 'M28TeamLZWantingMAA' --[x] is the plateau ,ref, [y] is the land zone ref, returns true if we want MAA support for the plateau
    subrefiWaterZonesWantingSignificantMAAByPlateau = 'M28TeamWZWantingMAA' --[x] is the PLATEAU ref, [y] is the wawter zone ref, returns true if want significant MAA support for the plateau
    subrefiRallyPointLandZonesByPlateau = 'M28TeamLZRallyPoint' --[x] is the plateau ref, then returns a table orderd 1, 2... of land zones that are rally points
    refiLastTimeNoShieldTargetsByIsland = 'M28TeamLastTimeNoShieldTargets' --[x] is the island ref (i.e. navutils.getlabel(M28Map.refPathingTypeLand...), returns gametime seconds
    refiLastTimeNoShieldBoatTargetsByPond = 'M28TeamLastTimeNoShieldBoatTargets' --[x] is the pond ref, returns gametimeseconds
    refiLastTimeNoStealthTargetsByPlateau = 'M28TeamLastTimeNoStealthTargets' --[x] is the plateau ref, returns gametime seconds
    refiLastTimeNoStealthBoatTargetsByPond = 'M28TeamLastTimeNoStealthBoatTargets' --[x] is the pond ref, returns gametimeseconds
    refiLastTimeNoMAATargetsByIsland = 'M28TeamLastTimeNoMAATargets' --[x] is the plateau ref, returns gametimeseconds
    reftoUnitsWithDisabledWeapons = 'M28TeamUnitsDisabledWeap' --[x] = 1,2,...; returns unit with disabled weapon
    --Water related
    subrefiRallyPointWaterZonesByPond = 'M28TeamWZRallyPoint' --[x] is the pond ref, then returns a table orderd 1, 2... of water zones that are rally points
    refiTimeLastNoSurfaceCombatTargetByPond = 'M28TeamLastTimeNoSurfTarget' --[x] is the pond ref, returns gametimeseconds that had surface bomat units with no target
    refiTimeLastNoSubCombatTargetByPond = 'M28TeamLastTimeNoSubTarget' --[x] is the pond ref, returns gametimeseconds that had submersible combat units with no target
    refiTimeLastHadBombardmentModeByPond = 'M28TeamLastTimeBombardment' --[x] is the pond ref, returns gametimeseconds that had a bombardment target activate (that wasnt for raiders)
    refiTimeLastHadBattleshipBombardmentByPond = 'M28TeamLastTimeBSBomb' --[x] is the pond ref, returns gametimeseconds if had a battleship firing shots, that wasnt blocked, and had nearby structures, when in bombardment mode

    --Air related
    reftoAllEnemyAir = 'M28TeamEnemyAirAll'
    reftoEnemyAirAA = 'M28TeamEnemyAirAAUnits' --Table of enemy AirAA units
    reftoEnemyAirToGround = 'M28TeamEnemyAirToGroundUnits' --Table of enemy air to ground units
    reftoEnemyTorpBombers = 'M28TeamEnemyTorpUnits' --table of enemy units that are torpedo bombers
    reftoEnemyAirOther = 'M28TeamEnemyAirOtherUnits' --AIr scouts and transports
    reftoEnemyUnitsWithNoLZ = 'M28TeamEnemyNoLZAir' --AIr units that arent currently over a land zone
    refiEnemyAirAAThreat = 'M28TeamEnemyAirAAThreat' --For entire team
    refiEnemyAirToGroundThreat = 'M28TeamEnemyAirToGroundThreat'
    refiEnemyTorpBombersThreat = 'M28TeamEnemyTorpBomberThreat'
    refiEnemyAirOtherThreat = 'M28TeamEnemyAirOtherThreat'
    refiTimeOfLastAirStagingShortage = 'M28TeamTimeAirStagingShortage' --Gametimeseconds that a team member last had units that had nowhere to refuel
    reftoEnemyExperimentalAirObjectives = 'M28TeamEnemyAirExp' --Table of enemy air experimentals that we need to destroy
    toBomberSuicideTargets = 'M28TeamStratSuic' --Table of enemy strat bombers that we want to suicide ASFs into
    --subrefiOurGunshipThreat - uses same ref as air subteam
    --subrefiOurBomberThreat - uses same ref as air subteam
    --subrefiOurAirAAThreat - uses same ref as air subteam

    refiTimeOfLastTransportShortlistUpdate = 'M28TeamAirTimeTransportShortlist' --Gametimeseconds that last updated the list of potential locations to do transport engi drops to
    refiTimeOfLastTransportCombatShortlistUpdate = 'M28TmAirCmTrSL' --Gametimeseconds we last updated list of potential combat drop locations
    reftTransportIslandDropShortlist = 'M28TeamAirTransportShortlist' --key is 1,2....x, returns {iPlateau, iIsland} - shortlist of plateau and island references that want to consider a transport drop for
    reftTransportFarAwaySameIslandPlateauLandZoneDropShortlist = 'M28TeamAirTransCurIslShortlist' --key is 1,2,...x, returns {iPlateau, iLandZone}, being locations on the same island as a base that want a drop due to how far away they are
    reftiPotentialDropIslandsByPlateau = 'M28TeamAirPotentialDropIslands' --List of islands by plateau that have mexes in them and no enemy start position
    reftiPotentialDropZonesByPlateau = 'M28TeamAirPotDropZones' --[x] is plateau, [y] = 1,2,...x, returns land zone ref for that plateau that we are happy to try and drop with a transport
    reftiPotentialCombatDropZonesByPlateau = 'M28TeamATrCmDZ' --[x] is plateau, [y]=1,2,...x, returns LZ ref for plateau to consider dropping if enemy has vulnerable mexes
    reftTransportCombatPlateauLandZoneDropShortlist = 'M28TeamATCurCmbShlst' --key is 1,2,...x, returns {iPlateau, iLandZone}, being locations where after evaluating enemy threat we want to send a combat drop
    reftiPotentialPondDropZones = 'M28TeamAirPotPondDrop' --[x] = 1,2,...x, returns the water zone
    refiLastFailedIslandDropTime = 'M28TeamAirLastFailedDrop' --Gametimeseconds where we last had a transport die while trying to drop this plateau
    refiLastFailedIslandAndZoneDropTime = 'M28TeamTrLstFailDByIZ' --[x] is the island, [y] is the land zone, returns gametimeseconds where we last had a transport die while tryign to drop
    refiLastFailedWaterZoneDropTime = 'M28TeamTrLstFailWZ' --[x] is the water zone, returns gametimeseconds where we last had a transport die while traveling here

    --Misc details
    reftiTeamMessages = 'M28TeamMessages' --against tTeamData[aiBrain.M28Team], [x] is the message type string, returns the gametime that last sent a message of this type to the team
    subrefNukeLaunchLocations = 'M28NukeLocations' --locations that we have nuked recently
    reftoRecentlyFiredAlliedNukeLaunchers = 'M28ANukeLaunchers' --table of M28 owned nuke launchers that have recently fired a missile
    refiTimeLastNearUnitCap = 'M28TimeLastNearUnitCap'
    refiLowestUnitCapAdjustmentLevel = 'M28LowestCapAdj' --i.e. 0 is after ctrlking the most types of units, so lower = closer to cap
    refiPriorityPondValues = 'M28PriorityPonds' --Table of ponds that are considered sufficiently high value for our team, [x] is the pond, returns the value of hte pond
    refbAlreadyCheckedForUnitsToShare = 'M28CheckedUnitsShare' --true if already run logic for campaign to share units at start of game
    refiConstructedExperimentalCount = 'M28ConstructedExpCount' --Total number of experimentals constructed
    reftoPotentialTeleSnipeTargets = 'M28TeamTeleSnipe' --Table of locations we think woudl be good to teleport to
    refiTimeOfLastTeleSnipeRefresh = 'M28TeamTeleTime' --Gametimeseconds that we last updated potential telesnipe locations
    --reftoSpecialUnitsToProtect = 'M28SpecialUnitsToProtect' --table of units to protect e.g. for air units - e.g. repair targets for a campaign
    refbDontHaveBuildingsOrACUInPlayableArea = 'M28BldInA' --for campaign AI, true if dont have buildings or ACU in the playable area, so can decide how aggressive to be with units
    reftEnemyCampaignMainBase = 'M28CampMB' --midpoint of the zone containing the enemy main base provided it is in the playable area
    refiLastUpdatedMainBase = 'M28TimCamp' -- used when getting enemy main base location for campaign map
    refbUnableToBuildArtiOrGameEnders = 'M28GERest' --true if gameenders and t3 arti are restricted
    reftoCampaignNeutralUnitsNotRecorded = 'M28CamU' --If have a campaign map, and we choose not to record a unit as an ally or an enemy, then it should be recorded here, so if there is a faction change these units can be reassessed
    toActiveSnipeTargets = 'M28ActSnT' --E.g. if want to go all-out on attacking enemy ACU then the ACU would be added here
    refiTimeOfLastM28PlayerDefeat = 'M28TLstDth' --Gametimeseconds of the last M28 player defat (used to check if shield cycling should be paused)
    tPotentiallyActiveGETemplates = 'M28TGETA' --when a gameender template is created, it gets added to this table, to allow quick referencing of other templates
    reftiCoreZonesByPlateau = 'M28CZBPl' --[x] = plateau ref, [y] = LZ ref, returns true
    reftiFortifyZonesByPlateau = 'M28CZBFPl' --[x] = plateau ref, [y] = LZ ref, returns true
    reftEnemyShieldsFailedToArti = 'M28SFlArt' --[x] = 1,2,3...x; returns the fixed shield unit
    reftoVulnerableFatboys = 'M28FatB' --[x] = 1,2,3; returns the fatboy unit; fatboy gets recorded when it gets low on shields
    refbActiveVulnerableFatboyMonitor = 'M28FatVMon' --true if have active thread for the team for vulnerable fatboys

--AirSubteam data variables
iTotalAirSubteamCount = 0
tAirSubteamData = {}
    subreftoFriendlyM28Brains = 'M28Brains' --table of friendly M28 brains
    subrefiMaxScoutRadius = 'M28ASTMaxScoutRadius' --Search range for scouts for this AirSubteam
    refbFarBehindOnAir = 'M28ASTFarBehindOnAir' --true if we are far behind on air
    refbHaveAirControl = 'M28ASTHaveAirControl'
    reftACUExpAndPriorityDefenceOnSubteam = 'M28ASTACUExp' --Friendly ACUs and experimentals

    --NOTE: Some of below are used for team as well (AirAA, Gunship, and Bomber (non-torp) threats)
    subrefiOurAirAAThreat = 'M28ASTOurAirAA' --Our AirAA threat; also used as a team variable
    subrefiOurGunshipThreat = 'M28ASTOurGShip' --Our gunship threat; also used as a team variable
    subrefiOurTorpBomberThreat = 'M28ASTOurTBmbT' --Our torp bomber threat
    subrefiOurBomberThreat = 'M28ASTOurBomb' --Our bomber threat; also used as a team variable

    refbTooMuchGroundNavalAAForTorpBombers = 'M28TooMuchAAForTorps' --true if have avoided targeting a water zone with torps due to groundAA threat in a water zone
    refbNoAvailableTorpsForEnemies = 'M28NoAvailTorps' --true if have enemy naval unit in a wz we want to defend, and we lack available torp bombers
    reftAirSubRallyPoint = 'M28ASTRally' --Contains the location of the air subteam's rally point
    refbOrigRallyOutsidePlayableArea = 'M28AROPa' --true if are outside playable area for air rally point
    reftAirSubSupportPoint = 'M28ASTSuppR' --Contains the location for airaa units to go to support a priority unit
    reftiTorpedoDefenceWaterZones = 'M28ASTTorpDef' --Contains water zones that want torpedo bombers to consider defending
    refoFrontGunship = 'M28ASTFrntGshp' --Front available gunship
    reftFrontGunshipPosition = 'M28AFGPs' --position of front gunship last cycle
    refiTimeLastTriedBuildingTransport = 'M28TimeLastTrns' --Gametimeseconds that someone on air subteam tried building an air transport
    refbGunshipsHadAttackOrderLastCycle = 'M28GunshipAtck' --True if the last time we ran gunship cycle we had a unit to attack (to reduce likelihood gunships appraoch somewhere then upon entering a new zone with slightly different adjacent enemy zones we decide to retreat)
    reftPriorityUnitsWantingScout = 'M28PriUnFrSct' --e.g. if gunship wants an air scout to help reveal cloaked units, this would include the gunship to shadow
    refiLastTorpBomberAdjacencyLevel = 'M28ASTLastTBAdj' --i.e. 3 means we last looked up to 3 adjacency levels out for targets
    refbOnlyGetASFs = 'M28OnlyGetASFs' --true if we should only get asfs now
    reftWaterZonesHasFriendlyTorps = 'M28WZWiTor' --[x] is the water zone, returns true if we have torpedo bombers in it
    refiTimeLastConsideredGiftingASFToAlly = 'M28ATimLstGift' --Gametimeseconds that we last considered gifting asfs for this subteam
    refoLastHumanGiftedASFs = 'M28ALstHumGifASF' --last human brain we gave asfs to
    reftiLastTransportDropByPlateauAndZone = 'M28TeamTrLstDpPZ' --[x] is the plateau (0 if water), [y] is the land/water zone; returns gametimeseconds that we last issued an unload order for that zone
    reftiTimeOfLastEngiHunterBomberOrder = 'M28ASTEHn' --Gametimeseconds that last sent a bomber for engi hunter assignment


--Land subteam data varaibles (used for factory production logic)
iTotalLandSubteamCount = 0
tLandSubteamData = {} --tLandSubteamData[oBrain.M28LandSubteam] results in the below subrefs
    subrefiLandCorePlateau = 'M28LSTPlateau' --Plateau number that the land subteam is based on
    subrefiLandCoreIsland = 'M28LSTIsland' --Island number that the land subteam is based on
    --subreftoFriendlyM28Brains = 'M28Brains' --Uses same ref as air subteam
    subrefFactoriesByTypeFactionAndTech = 'M28LSTFactoriesByPlateau' --LAND SUBTEAM data table; First value is factory type; secont value is faction (M28UnitInfo.refFactionxxxx), third is tech level
    subrefBlueprintBlacklist = 'M28LSTBlueprintBlacklist' --Check with M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subrefBlueprintBlacklist][sUnitId] - returns true if we have blacklisted the unit
    refbConsideredScoutFactionRestrictions = 'M28LSTSctRest' --true if we have applied subrefBlueprintBlacklist for land scouts yet


--Other variables dependent on above:
tEnemyBigThreatCategories = { [reftEnemyLandExperimentals] = M28UnitInfo.refCategoryLandExperimental, [reftEnemyArtiAndExpStructure] = M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalStructure, [reftEnemyNukeLaunchers] = M28UnitInfo.refCategorySML, [reftEnemySMD] = M28UnitInfo.refCategorySMD, [reftEnemyBattleships] = M28UnitInfo.refCategoryNavalSurface * categories.BATTLESHIP, [reftEnemyMobileSatellites] = M28UnitInfo.refCategorySatellite, [reftEnemyAirExperimentals] = M28UnitInfo.refCategoryGunship * categories.EXPERIMENTAL + M28UnitInfo.refCategoryCzar + M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL }



function CreateNewLandSubteam(iPlateau, iIsland, tM28BrainsInSubteam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateNewLandSubteam'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    iTotalLandSubteamCount = iTotalLandSubteamCount + 1
    tLandSubteamData[iTotalLandSubteamCount] = {}
    tLandSubteamData[iTotalLandSubteamCount][subrefiLandCorePlateau] = iPlateau
    tLandSubteamData[iTotalLandSubteamCount][subrefiLandCoreIsland] = iIsland
    tLandSubteamData[iTotalLandSubteamCount][subrefBlueprintBlacklist] = {}

    tLandSubteamData[iTotalLandSubteamCount][subreftoFriendlyM28Brains] = {}
    for iBrain, oBrain in tM28BrainsInSubteam do
        table.insert(tLandSubteamData[iTotalLandSubteamCount][subreftoFriendlyM28Brains], oBrain)
        oBrain.M28LandSubteam = iTotalLandSubteamCount
    end
    tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech] = {[M28Factory.refiFactoryTypeLand] = {},
                                                                                     [M28Factory.refiFactoryTypeAir] = {},
                                                                                     [M28Factory.refiFactoryTypeNaval] = {},
                                                                                     [M28Factory.refiFactoryTypeOther] = {}}
    for iFactoryType, tSubtable in tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech] do
        tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech][iFactoryType] = {[M28UnitInfo.refFactionUEF] = {},
                     [M28UnitInfo.refFactionAeon] = {},
                     [M28UnitInfo.refFactionCybran] = {},
                     [M28UnitInfo.refFactionSeraphim] = {},
                     [M28UnitInfo.refFactionNomads] = {},
                     [M28UnitInfo.refFactionUnrecognised] = {}}
        for iFaction, tSubtable in tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech][iFactoryType] do
            tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFaction] = {[1]=0,[2]=0,[3]=0}
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Finished creating subteam for '..iTotalLandSubteamCount..'; tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech]='..repru(tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech])) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end



function CreateNewAirSubteam(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateNewAirSubteam'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    iTotalAirSubteamCount = iTotalAirSubteamCount + 1
    aiBrain.M28AirSubteam = iTotalAirSubteamCount
    tAirSubteamData[aiBrain.M28AirSubteam] = {}
    tAirSubteamData[aiBrain.M28AirSubteam][subreftoFriendlyM28Brains] = {}
    tAirSubteamData[aiBrain.M28AirSubteam][reftACUExpAndPriorityDefenceOnSubteam] = {}
    tAirSubteamData[iTotalAirSubteamCount][reftWaterZonesHasFriendlyTorps] = {}
    if not(tTeamData[aiBrain.M28Team][subrefAirSubteamsInTeam]) then tTeamData[aiBrain.M28Team][subrefAirSubteamsInTeam] = {} end
    table.insert(tTeamData[aiBrain.M28Team][subrefAirSubteamsInTeam], iTotalAirSubteamCount)
    table.insert(tAirSubteamData[aiBrain.M28AirSubteam][subreftoFriendlyM28Brains], aiBrain)


    local tNearestEnemyBase = M28Map.GetPrimaryEnemyBaseLocation(aiBrain)
    if bDebugMessages == true then LOG(sFunctionRef..': aiBrain='..aiBrain.Nickname..'; Index='..aiBrain:GetArmyIndex()..'; tNearestEnemyBase='..repru(tNearestEnemyBase)..'; Our start point='..repru(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()])) end
    local iOurAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()], tNearestEnemyBase)
    local bSameAirSubteam
    --Low threshold - if within this dist will be grouped regardless of angle difference
    --High threshold - if within certain angle differential then will group if satisfy this distance
    local iDistThresholdLow = math.max(math.min(aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.8, 100), aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.3)
    local iDistThresholdHigh = math.max(math.min(aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.9, 130), aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.5)
    if bDebugMessages == true then LOG(sFunctionRef..': Our dist to enemy='..aiBrain[M28Overseer.refiDistanceToNearestEnemyBase]..'; Low threshold='..iDistThresholdLow..'; High threshold='..iDistThresholdHigh..'; Angle to nearest enemy='..iOurAngleToNearestEnemy) end

    --Cycle through each brain in our team without a AirSubteam and consider if they should be in the same AirSubteam as this brain
    for iBrain, oBrain in tTeamData[aiBrain.M28Team][subreftoFriendlyActiveM28Brains] do
        --Make sure we have a primary base and distance to nearest enemy recorded
        M28Map.GetPrimaryEnemyBaseLocation(oBrain)
        if not(oBrain.M28AirSubteam) and not(oBrain == aiBrain) then
            bSameAirSubteam = false
            local iBaseDistDif = M28Utilities.GetDistanceBetweenPositions(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()])
            if bDebugMessages == true then LOG(sFunctionRef..': Considering ally brain '..oBrain.Nickname..'; iBaseDistDif='..iBaseDistDif..'; iAngleDif='..M28Utilities.GetAngleDifference(iOurAngleToNearestEnemy, M28Utilities.GetAngleFromAToB(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], tNearestEnemyBase))) end
            if iBaseDistDif <= iDistThresholdLow then
                bSameAirSubteam = true
            else
                local iAngleDif = M28Utilities.GetAngleDifference(iOurAngleToNearestEnemy, M28Utilities.GetAngleFromAToB(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], tNearestEnemyBase))
                if iAngleDif <= 40 or (iAngleDif <= 60 and iBaseDistDif <= iDistThresholdHigh) then
                    bSameAirSubteam = true
                else
                    --Are we close to the start position of any of the other brains already recorded in this AirSubteam?
                    for iAirSubteamBrain, oAirSubteamBrain in tAirSubteamData[aiBrain.M28AirSubteam][subreftoFriendlyM28Brains] do
                        if not(oAirSubteamBrain == aiBrain) and not(oAirSubteamBrain == oBrain) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Dist to alternative AirSubteam member '..oAirSubteamBrain.Nickname..' = '..M28Utilities.GetDistanceBetweenPositions(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], M28Map.PlayerStartPoints[oAirSubteamBrain:GetArmyIndex()])) end
                            if M28Utilities.GetDistanceBetweenPositions(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], M28Map.PlayerStartPoints[oAirSubteamBrain:GetArmyIndex()]) <= iDistThresholdLow then
                                bSameAirSubteam = true
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': On same AirSubteam='..tostring(bSameAirSubteam)) end
            if bSameAirSubteam then
                oBrain.M28AirSubteam = aiBrain.M28AirSubteam
                table.insert(tAirSubteamData[aiBrain.M28AirSubteam][subreftoFriendlyM28Brains], oBrain)
            end
        end
    end

    M28Air.AirSubteamInitialisation(aiBrain.M28Team, aiBrain.M28AirSubteam) --Dont fork thread
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateUpgradeTrackingOfUnit(oUnitDoingUpgrade, bUnitDeadOrCompletedUpgrade, sUnitUpgradingRef)
    --bUnitDeadOrCompletedUpgrade is true if  a structure has just died or completed building a structure, in which case the unit might not have been upgrading but want to check
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateUpgradeTrackingOfUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oUnitDoingUpgrade='..(oUnitDoingUpgrade.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitDoingUpgrade) or 'nil')..' owned by brain '..oUnitDoingUpgrade:GetAIBrain().Nickname..' at time '..GetGameTimeSeconds()..'; bUnitDeadOrCompletedUpgrade='..tostring(bUnitDeadOrCompletedUpgrade)..'; sUnitUpgradingRef='..(sUnitUpgradingRef or 'nil')) M28Utilities.ErrorHandler('Audit trail', true, true) end

    local sUpgradeTableRef
    if EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnitDoingUpgrade.UnitId) then
        sUpgradeTableRef = subreftTeamUpgradingHQs
    elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnitDoingUpgrade.UnitId) then
        sUpgradeTableRef = subreftTeamUpgradingMexes
    elseif EntityCategoryContains(categories.COMMAND, oUnitDoingUpgrade.UnitId) then
        sUpgradeTableRef = subreftTeamUpgradingACUs
    else
        sUpgradeTableRef = subreftTeamUpgradingOther
    end
    local iTableRefOfUnit

    if M28Utilities.IsTableEmpty(tTeamData[oUnitDoingUpgrade:GetAIBrain().M28Team][sUpgradeTableRef]) == false then
        for iUnit, oUnit in tTeamData[oUnitDoingUpgrade:GetAIBrain().M28Team][sUpgradeTableRef] do
            if oUnit == oUnitDoingUpgrade then
                iTableRefOfUnit = iUnit
                break
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': sUpgradeTableRef='..sUpgradeTableRef..'; Is table of upgrading units empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[oUnitDoingUpgrade:GetAIBrain().M28Team][sUpgradeTableRef]))..'; iTableRefOfUnit if already in table='..(iTableRefOfUnit or 'nil')) end
    if iTableRefOfUnit then
        if bUnitDeadOrCompletedUpgrade then
            local iTeam = oUnitDoingUpgrade:GetAIBrain().M28Team
            table.remove(tTeamData[iTeam][sUpgradeTableRef], iTableRefOfUnit)
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnitDoingUpgrade:GetPosition(), true, oUnitDoingUpgrade)
            local iWaterZone, iPond
            local tBackupLZData, tLZOrWZTeamData
            if (iLandZone or 0) > 0 then tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
            else
                iWaterZone = M28Map.GetWaterZoneFromPosition(oUnitDoingUpgrade:GetPosition())
                iPond = M28Map.tiPondByWaterZone[iWaterZone]
                if iWaterZone > 0 and iPond > 0 then
                    tLZOrWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][iTeam]
                end
            end
            if not(tLZOrWZTeamData) then
                tBackupLZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnitDoingUpgrade:GetPosition(), true, iTeam)
                if bDebugMessages == true then LOG(sFunctionRef..': Activated backup logic for locating zone, is tLZOrWZTeamData empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData))) end
                if not(tLZOrWZTeamData) then
                    M28Utilities.ErrorHandler('Unable to find a land zone for unit doing upgrade='..(oUnitDoingUpgrade.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitDoingUpgrade) or 'nil'))
                    if bDebugMessages == true then LOG(sFunctionRef..': Error further details: reftAssignedPlateauAndLandZoneByTeam='..repru(oUnitDoingUpgrade[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam])) end
                end
            end
            if M28Utilities.IsTableEmpty(tTeamData[iTeam][M28Map.subreftoActiveUpgrades]) == false then
                for iUnit, oUnit in tTeamData[iTeam][M28Map.subreftoActiveUpgrades] do
                    if oUnit == oUnitDoingUpgrade then
                        if bDebugMessages == true then LOG(sFunctionRef..': About to remove unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from the table of upgrades for the team '..iTeam..'; Unit iPlateau='..iPlateau..'; iLZ='..iLandZone) end
                        table.remove(tTeamData[iTeam][M28Map.subreftoActiveUpgrades], iUnit)
                        break
                    end
                end
            end
            --Remove from land zone list of upgrades
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoActiveUpgrades]) == false then
                for iUnit, oUnit in tLZOrWZTeamData[M28Map.subreftoActiveUpgrades] do
                    if oUnit == oUnitDoingUpgrade then
                        if bDebugMessages == true then LOG(sFunctionRef..': About to remove unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from the table of upgrades for iPlateau '..iPlateau..'; iLZ='..(iLandZone or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')) end
                        table.remove(tLZOrWZTeamData[M28Map.subreftoActiveUpgrades], iUnit)
                    end
                end
            end
            local iActiveMexUpgrades = 0
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoActiveUpgrades]) == false then
                for iUnit, oUnit in tLZOrWZTeamData[M28Map.subreftoActiveUpgrades] do
                    if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then iActiveMexUpgrades = iActiveMexUpgrades + 1 end
                end
            end
            if tLZOrWZTeamData then
                tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] = iActiveMexUpgrades
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Failed ot have valid team data so wont update number of active mex upgrades') end
            end
            if M28Map.bIsCampaignMap then
                --Trigger on death callback if relevant

                if bDebugMessages == true then LOG(sFunctionRef..': Finished upgrading oUnitDoingUpgrade='..oUnitDoingUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitDoingUpgrade)..'; Have we run unit killed event='..tostring(oUnitDoingUpgrade[M28Events.refbAlreadyRunUnitKilled] or false)..'; Brain='..oUnitDoingUpgrade:GetAIBrain().Nickname..'; Objective unit='..tostring(oUnitDoingUpgrade[M28UnitInfo.refbObjectiveUnit] or false)) end
                if oUnitDoingUpgrade[M28UnitInfo.refbObjectiveUnit] and not(oUnitDoingUpgrade[M28Events.refbAlreadyRunUnitKilled]) and oUnitDoingUpgrade:GetAIBrain().CampaignAI and oUnitDoingUpgrade.DoUnitCallbacks and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oUnitDoingUpgrade.UnitId) then
                    --local ScenarioFramework = import('/lua/ScenarioFramework.lua')
                    oUnitDoingUpgrade:DoUnitCallbacks('OnKilled')
                    if bDebugMessages == true then LOG(sFunctionRef..': Have manually run an onkilled callback for the objective unit') end
                end

            end
        elseif bDebugMessages == true then LOG(sFunctionRef..': Unit already in the table so wont readd it')
        end
    else
        if not(bUnitDeadOrCompletedUpgrade) then
            local iTeam = oUnitDoingUpgrade:GetAIBrain().M28Team
            table.insert(tTeamData[iTeam][sUpgradeTableRef], oUnitDoingUpgrade)
            if sUnitUpgradingRef then
                local oNewUnitBP = __blueprints[sUnitUpgradingRef]
                if bDebugMessages == true then LOG(sFunctionRef..': About to update the energy and mass upgrades started this cycle for the unti energy and amss costs. Mass upgrade before this='..tTeamData[iTeam][subrefiMassUpgradesStartedThisCycle]) end
                if oNewUnitBP then
                    local iOurBuildPower = oUnitDoingUpgrade:GetBlueprint().Economy.BuildRate
                    local iBuildCost = oNewUnitBP.Economy.BuildTime
                    if iBuildCost > 0 and iOurBuildPower > 0 then
                        local iResourceFactor = 0.1 * iOurBuildPower / iBuildCost
                        tTeamData[iTeam][subrefiEnergyUpgradesStartedThisCycle] = (tTeamData[iTeam][subrefiEnergyUpgradesStartedThisCycle] or 0) + (oNewUnitBP.Economy.BuildCostEnergy or 0) * iResourceFactor
                        tTeamData[iTeam][subrefiMassUpgradesStartedThisCycle] = (tTeamData[iTeam][subrefiMassUpgradesStartedThisCycle] or 0) + (oNewUnitBP.Economy.BuildCostMass or 0) * iResourceFactor
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Updated this cycle check, tTeamData[iTeam][subrefiMassUpgradesStartedThisCycle]='..tTeamData[iTeam][subrefiMassUpgradesStartedThisCycle]) end
            end
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnitDoingUpgrade:GetPosition(), true, oUnitDoingUpgrade)
            local iWaterZone, iPond
            local tLZOrWZTeamData
            if (iLandZone or 0) > 0 then tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
            else
                iWaterZone = M28Map.GetWaterZoneFromPosition(oUnitDoingUpgrade:GetPosition())
                iPond = M28Map.tiPondByWaterZone[iWaterZone]
                if iWaterZone > 0 and iPond > 0 then
                    tLZOrWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][iTeam]
                end
            end
            if not(tLZOrWZTeamData) then
                local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnitDoingUpgrade:GetPosition())
                if (iPlateauOrZero or -1) >= 0 then
                    if iPlateauOrZero == 0 then
                        tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
                        iWaterZone = iLandOrWaterZone
                    else
                        iLandZone = iLandOrWaterZone
                        iPlateau = iPlateauOrZero
                        tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': tTeamData[iTeam][M28Map.subreftoActiveUpgrades] before adding unit='..reprs(tTeamData[iTeam][M28Map.subreftoActiveUpgrades])) end
            if tLZOrWZTeamData then
                if not(tLZOrWZTeamData[M28Map.subreftoActiveUpgrades]) then
                    tLZOrWZTeamData[M28Map.subreftoActiveUpgrades] = {}
                    if bDebugMessages == true then LOG(sFunctionRef..': LZ Upgrade was nil so making it a table, reprs='..reprs(tLZOrWZTeamData[M28Map.subreftoActiveUpgrades])) end
                end
                table.insert(tLZOrWZTeamData[M28Map.subreftoActiveUpgrades], oUnitDoingUpgrade)
                local iActiveMexUpgrades = 0
                for iUnit, oUnit in tLZOrWZTeamData[M28Map.subreftoActiveUpgrades] do
                    if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then iActiveMexUpgrades = iActiveMexUpgrades + 1 end
                end
                tLZOrWZTeamData[M28Map.subrefiActiveMexUpgrades] = iActiveMexUpgrades
                if bDebugMessages == true then LOG(sFunctionRef..': Just added unit to the upgrade table for the team '..iTeam..'; Plateau '..iPlateau..'; LZ='..(iLandZone or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'; Is table of active upgrades empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoActiveUpgrades]))..'; Reprs of tLZOrWZTeamData[activeupgrades]='..reprs(tLZOrWZTeamData[M28Map.subreftoActiveUpgrades])) end
            end
        elseif bDebugMessages == true then LOG(sFunctionRef..': Unit dead or compelted, but not in the table so no need to remove it')
        end
    end

    --Clear trackers from the unit that was doing the upgrade

    if bUnitDeadOrCompletedUpgrade and oUnitDoingUpgrade.UnitId then
        if bDebugMessages == true then LOG(sFunctionRef..': Just finished upgrading '..(oUnitDoingUpgrade.UnitId or 'nil')..M28UnitInfo.GetUnitLifetimeCount(oUnitDoingUpgrade)..'; is table of units assisting this empty='..tostring(M28Utilities.IsTableEmpty(oUnitDoingUpgrade[M28UnitInfo.reftoUnitsAssistingThis]))) end
        if M28Utilities.IsTableEmpty(oUnitDoingUpgrade[M28UnitInfo.reftoUnitsAssistingThis]) == false then
            local tUnitsToClear = {}
            for iUnit, oUnit in oUnitDoingUpgrade[M28UnitInfo.reftoUnitsAssistingThis] do
                if M28UnitInfo.IsUnitValid(oUnit) and EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) and oUnit[M28Engineer.refiAssignedAction] == M28Engineer.refActionAssistUpgrade then
                    table.insert(tUnitsToClear, oUnit)
                end
            end
            if M28Utilities.IsTableEmpty(tUnitsToClear) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Just finished upgrading '..oUnitDoingUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitDoingUpgrade)..'; will clear assisting engineers, table size='..table.getn(tUnitsToClear)) end
                for iUnit, oUnit in tUnitsToClear do
                    M28Orders.IssueTrackedClearCommands(oUnit)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function InitialTeamInitialisationForReference() end --To help find the below more easily
function CreateNewTeam(aiBrain)
    --See also TeamInitialisation which sets up team variables for zones
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateNewTeam'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    iTotalTeamCount = iTotalTeamCount + 1
    tTeamData[iTotalTeamCount] = {}
    tTeamData[iTotalTeamCount][subreftoFriendlyActiveM28Brains] = {}
    tTeamData[iTotalTeamCount][subreftoFriendlyHumanAndAIBrains] = {}
    tTeamData[iTotalTeamCount][subrefbTeamHasOmniVision] = false
    tTeamData[iTotalTeamCount][subrefbEnemyHasOmni] = false
    tTeamData[iTotalTeamCount][subreftoEnemyBrains] = {}
    tTeamData[iTotalTeamCount][subrefiActiveM28BrainCount] = 0
    tTeamData[iTotalTeamCount][subreftTeamUpgradingOther] = {}
    tTeamData[iTotalTeamCount][subreftTeamUpgradingACUs] = {}
    tTeamData[iTotalTeamCount][subreftTeamUpgradingMexes] = {}
    tTeamData[iTotalTeamCount][subreftTeamUpgradingHQs] = {}
    tTeamData[iTotalTeamCount][subrefiHighestEnemyGroundTech] = 0
    tTeamData[iTotalTeamCount][subrefiHighestEnemyAirTech] = 0
    tTeamData[iTotalTeamCount][subrefiHighestEnemyNavyTech] = 0
    tTeamData[iTotalTeamCount][subrefbTeamIsStallingEnergy] = false
    tTeamData[iTotalTeamCount][subrefbTeamIsStallingMass] = false
    tTeamData[iTotalTeamCount][subreftiPrevTeamNetMass] = {}
    tTeamData[iTotalTeamCount][subrefiGrossEnergyWhenStalled] = 0
    tTeamData[iTotalTeamCount][refiTimeOfLastEnergyStall] = 0
    tTeamData[iTotalTeamCount][refiTimeOfLastEngiSelfDestruct] = 0
    tTeamData[iTotalTeamCount][refbNeedResourcesForMissile] = false
    tTeamData[iTotalTeamCount][subrefiLandZonesWantingSupportByPlateau] = {}
    tTeamData[iTotalTeamCount][subrefiTotalFactoryCountByType] = {[M28Factory.refiFactoryTypeLand] = 0, [M28Factory.refiFactoryTypeAir] = 0, [M28Factory.refiFactoryTypeNaval] = 0, [M28Factory.refiFactoryTypeOther] = 0}
    tTeamData[iTotalTeamCount][subrefiAlliedDFThreat] = 0
    tTeamData[iTotalTeamCount][subrefiAlliedIndirectThreat] = 0
    tTeamData[iTotalTeamCount][subrefiAlliedGroundAAThreat] = 0
    tTeamData[iTotalTeamCount][subrefiAlliedMAAThreat] = 0
    tTeamData[iTotalTeamCount][refiLastTimeNoShieldTargetsByIsland] = {}
    tTeamData[iTotalTeamCount][refiLastTimeNoShieldBoatTargetsByPond] = {}
    tTeamData[iTotalTeamCount][refiLastTimeNoStealthTargetsByPlateau] = {}
    tTeamData[iTotalTeamCount][refiLastTimeNoStealthBoatTargetsByPond] = {}
    tTeamData[iTotalTeamCount][refiLastTimeNoMAATargetsByIsland] = {}
    tTeamData[iTotalTeamCount][refiEnemyHighestMobileLandHealth] = 300
    tTeamData[iTotalTeamCount][reftEnemyFirebaseByPlateauAndLZ] = {}
    tTeamData[iTotalTeamCount][reftEnemyTML] = {}
    tTeamData[iTotalTeamCount][reftEnemyLandExperimentals] = {}
    tTeamData[iTotalTeamCount][reftEnemyArtiAndExpStructure] = {}
    tTeamData[iTotalTeamCount][reftEnemyNukeLaunchers] = {}
    tTeamData[iTotalTeamCount][reftEnemySMD] = {}
    tTeamData[iTotalTeamCount][reftEnemyMobileSatellites] = {}
    tTeamData[iTotalTeamCount][reftEnemyAirExperimentals] = {}
    tTeamData[iTotalTeamCount][subreftTeamEngineersBuildingExperimentals] = {}
    tTeamData[iTotalTeamCount][refiLastFailedIslandDropTime] = {}
    tTeamData[iTotalTeamCount][refiLastFailedIslandAndZoneDropTime] = {}
    tTeamData[iTotalTeamCount][subrefbUseFrigatesAsScoutsByPond] = {}
    M28Engineer.tiLastBuildingSizeFromActionForTeam[iTotalTeamCount] = {}
    tTeamData[iTotalTeamCount][refiHighestBrainResourceMultiplier] = 1
    tTeamData[iTotalTeamCount][refiHighestBrainBuildMultiplier] = 1
    tTeamData[iTotalTeamCount][refiConstructedExperimentalCount] = 0
    tTeamData[iTotalTeamCount][refiMexCountByTech] = {[1]=0,[2]=0,[3]=0,[4]=0}
    tTeamData[iTotalTeamCount][refiEnemyT3ArtiCount] = 0
    tTeamData[iTotalTeamCount][refiEnemyNovaxCount] = 0
    tTeamData[iTotalTeamCount][reftoCampaignNeutralUnitsNotRecorded] = {}
    tTeamData[iTotalTeamCount][iEnemyT3MAAActiveCount] = 0
    tTeamData[iTotalTeamCount][toActiveSnipeTargets] = {}
    tTeamData[iTotalTeamCount][reftM28ACUs] = {}
    tTeamData[iTotalTeamCount][tPotentiallyActiveGETemplates] = {}
    tTeamData[iTotalTeamCount][subrefiLongestOverdueScoutingTarget] = 0
    tTeamData[iTotalTeamCount][refiPausedUnitCount] = 0
    tTeamData[iTotalTeamCount][subreftoPausedUnitsByPriority] = {}
    tTeamData[iTotalTeamCount][refiLastMassStallCategoryAndEngineerTables] = {}
    tTeamData[iTotalTeamCount][refiLastEnergyStallCategoryAndEngineerTables] = {}


    local bHaveCampaignM28AI = false
    if aiBrain.M28AI and aiBrain.CampaignAI then bHaveCampaignM28AI = true end
    local bHaveM28BrainInTeam = false

    local tbBrainsWithLandSubteam = {}
    local bAlreadyRecordedBrain

    for iCurBrain, oBrain in ArmyBrains do
        if bDebugMessages == true then LOG(sFunctionRef..': Doing setup for team '..iTotalTeamCount..'; Considering brain '..oBrain.Nickname..'; oBrain.M28Team='..(oBrain.M28Team or 'nil')) end
        --First make sure we have recorded all brains (redundancy for AI like dillidalli) - the function below will check if we have already recorded the brain
        ForkThread(M28Events.OnCreateBrain, oBrain, nil, nil)
        --[[if not(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()]) then --redundancy
            local iStartPositionX, iStartPositionZ = oBrain:GetArmyStartPos()
            M28Map.PlayerStartPoints[oBrain:GetArmyIndex()] = {iStartPositionX, GetSurfaceHeight(iStartPositionX, iStartPositionZ), iStartPositionZ}
            M28Overseer.tAllAIBrainsByArmyIndex[oBrain:GetArmyIndex()] = oBrain
        end--]]

        --if not(oBrain.M28Team) then
        bAlreadyRecordedBrain = false
        if oBrain == aiBrain or (IsAlly(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()) and not(M28Conditions.IsCivilianBrain(oBrain))) then
            --Have we already recorded this as an ally?
            if M28Utilities.IsTableEmpty(tTeamData[iTotalTeamCount][subreftoFriendlyHumanAndAIBrains]) == false then
                for iRecorded, oRecorded in tTeamData[iTotalTeamCount][subreftoFriendlyHumanAndAIBrains] do
                    if oRecorded == oBrain then bAlreadyRecordedBrain = true break end
                end
            end
            if not(bAlreadyRecordedBrain) then

                --Check we have the same enemies if this is a campaign AI
                if oBrain.M28AI and oBrain.CampaignAI then bHaveCampaignM28AI = true end
                local bHaveSameEnemies = true
                if bHaveCampaignM28AI and not(oBrain == aiBrain) then
                    --Check if we have the same enemies
                    local iIndexOrigBrain = aiBrain:GetArmyIndex()
                    local iIndexoBrain = oBrain:GetArmyIndex()
                    for iAltBrain, oAltBrain in ArmyBrains do
                        if not(oAltBrain == oBrain) and not(oAltBrain == aiBrain) then
                            if not(IsAlly(iIndexOrigBrain, oAltBrain:GetArmyIndex()) == IsAlly(iIndexoBrain, oAltBrain:GetArmyIndex())) then
                                bHaveSameEnemies = false
                                break
                            end
                            if not(IsEnemy(iIndexOrigBrain, oAltBrain:GetArmyIndex()) == IsEnemy(iIndexoBrain, oAltBrain:GetArmyIndex())) then
                                bHaveSameEnemies = false
                                break
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering aiBrain '..aiBrain.Nickname..'; oBrain='..oBrain.Nickname..'; iTotalTeamCount='..iTotalTeamCount..'; bHaveSameEnemies='..tostring(bHaveSameEnemies)) end
                --Special excemptions for certain campaign maps where the AI will change teams part-way through
                if bHaveSameEnemies and M28Map.bIsCampaignMap and not(oBrain == aiBrain) then
                    --FA Mission 2 - want QAI and Order to be on different teams
                    if (oBrain.Nickname == 'QAI' or oBrain.Nickname == 'Order') and (aiBrain.Nickname == 'QAI' or aiBrain.Nickname == 'Order') and ScenarioInfo.QAI and ScenarioInfo.Order then
                        bHaveSameEnemies = false
                    end
                end
                if bHaveSameEnemies then
                    oBrain.M28Team = iTotalTeamCount
                    table.insert(tTeamData[iTotalTeamCount][subreftoFriendlyHumanAndAIBrains], oBrain)
                    if oBrain.M28AI then
                        table.insert(tTeamData[iTotalTeamCount][subreftoFriendlyActiveM28Brains], oBrain)
                        tTeamData[iTotalTeamCount][subrefiActiveM28BrainCount] = tTeamData[iTotalTeamCount][subrefiActiveM28BrainCount] + 1
                    end
                    if oBrain.CheatEnabled then
                        tTeamData[iTotalTeamCount][refiHighestBrainResourceMultiplier] = math.max(tTeamData[iTotalTeamCount][refiHighestBrainResourceMultiplier], tonumber(ScenarioInfo.Options.CheatMult or 1.5))
                        tTeamData[iTotalTeamCount][refiHighestBrainBuildMultiplier] = math.max(tTeamData[iTotalTeamCount][refiHighestBrainBuildMultiplier], tonumber(ScenarioInfo.Options.BuildMult or 1.5))
                        oBrain[M28Economy.refiBrainResourceMultiplier] = tonumber(ScenarioInfo.Options.CheatMult or 1.5)
                        oBrain[M28Economy.refiBrainBuildRateMultiplier] = tonumber(ScenarioInfo.Options.BuildMult or 1.5)
                    else
                        oBrain[M28Economy.refiBrainResourceMultiplier] = 1
                        oBrain[M28Economy.refiBrainBuildRateMultiplier] = 1
                    end
                    bHaveM28BrainInTeam = true
                    --Check if we have omni vision for the team
                    if oBrain.CheatEnabled and ScenarioInfo.Options.OmniCheat == 'on' then
                        tTeamData[iTotalTeamCount][subrefbTeamHasOmniVision] = true
                    end
                    --Record brain details in log for ease of reference
                    local sAIxref = ''
                    if bDebugMessages == true then LOG(sFunctionRef..': Brain '..oBrain.Nickname..': .CheatEnabled='..tostring(oBrain.CheatEnabled or false)..'; ScenarioInfo.Options.CheatMult='..(ScenarioInfo.Options.CheatMult or 'nil')..'; reprs of scenario.options='..reprs(ScenarioInfo.Options)) end
                    if oBrain.CheatEnabled then
                        sAIxref = ' AIx Res '..tonumber(ScenarioInfo.Options.CheatMult or -1)..'; BP '..tonumber(ScenarioInfo.Options.BuildMult or -1)
                    end
                    LOG(sFunctionRef..': Recorded non-civilian brain '..oBrain.Nickname..' with index '..oBrain:GetArmyIndex()..' for team '..iTotalTeamCount..sAIxref..'; M28Easy='..tostring(oBrain.M28Easy or false)) --Dont know the land and air subteams yet
                end
            end
        elseif IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()) and not(M28Conditions.IsCivilianBrain(oBrain)) then
            if M28Utilities.IsTableEmpty(tTeamData[iTotalTeamCount][subreftoEnemyBrains]) == false then
                for iRecorded, oRecorded in tTeamData[iTotalTeamCount][subreftoEnemyBrains] do
                    if oRecorded == oBrain then
                        bAlreadyRecordedBrain = true break
                    end
                end
            end
            if not(bAlreadyRecordedBrain) then
                if bDebugMessages == true then LOG(sFunctionRef..': Recording enemy brain '..oBrain.Nickname..' for team '..iTotalTeamCount..' at time='..GetGameTimeSeconds()) end
                table.insert(tTeamData[iTotalTeamCount][subreftoEnemyBrains], oBrain)
                tBrainIndexesRecordedAsEnemies[oBrain:GetArmyIndex()] = true
                --Check if anyone on enemy team has omni
                if oBrain.CheatEnabled and ScenarioInfo.Options.OmniCheat == 'on' then
                    tTeamData[iTotalTeamCount][subrefbEnemyHasOmni] = true
                end
            end
        end
        --end
    end
    if not(bHaveM28BrainInTeam) and aiBrain.M28AI then bHaveM28BrainInTeam = true end
    if bDebugMessages == true then LOG(sFunctionRef..': Setup a team with team ref/iTotalTeamCount='..iTotalTeamCount..'; do we have M28 brain in this team='..tostring(bHaveM28BrainInTeam)) end
    if bHaveM28BrainInTeam then
        UpdateTeamHighestAndLowestFactories(iTotalTeamCount)

        --Group allies into AirSubteams based on nearest enemy; then split the air subteam between land subteams if they are in different plateaus
        for iBrain, oBrain in tTeamData[iTotalTeamCount][subreftoFriendlyActiveM28Brains] do
            if not(oBrain.M28AirSubteam) then
                CreateNewAirSubteam(oBrain)
                local tiIslandBrainsInSubteam = {}
                local tiPlateauByIslandRefs = {}
                local iStartPlateau, iStartIsland
                for iBrain, oBrain in tAirSubteamData[oBrain.M28AirSubteam][subreftoFriendlyM28Brains] do
                    iStartPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                    iStartIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                    if (iStartIsland or 0) > 0 then
                        if not(tiIslandBrainsInSubteam[iStartIsland]) then tiIslandBrainsInSubteam[iStartIsland] = {} end
                        table.insert(tiIslandBrainsInSubteam[iStartIsland], oBrain)
                        tbBrainsWithLandSubteam[oBrain:GetArmyIndex()] = true
                        tiPlateauByIslandRefs[iStartIsland] = iStartPlateau
                    end
                end
                if M28Utilities.IsTableEmpty(tiIslandBrainsInSubteam) == false then
                    for iStartIsland, tBrains in tiIslandBrainsInSubteam do
                        CreateNewLandSubteam(tiPlateauByIslandRefs[iStartIsland], iStartIsland, tBrains)
                    end
                end
            end
        end
        ForkThread(TeamInitialisation, iTotalTeamCount)
        M28Air.UpdateTeamAirThreats(iTotalTeamCount)
    end
    ForkThread(TeamDeathChecker)
    if bHaveCampaignM28AI then
        local bTeamHasPlayerM28AI = false
        for iBrain, oBrain in tTeamData[iTotalTeamCount][subreftoFriendlyActiveM28Brains] do
            if not(oBrain.CampaignAI) then
                bTeamHasPlayerM28AI = true
                break
            end
        end
        if not(bTeamHasPlayerM28AI) then
            tTeamData[iTotalTeamCount][rebTeamOnlyHasCampaignAI] = true
        end
        ForkThread(CheckIfCampaignTeamHasBuildings, iTotalTeamCount)
    end

    --Check every brain is on a land subteam (even if have a water start)
    ForkThread(CheckForBrainsWithoutLandSubteam, iTotalTeamCount, tbBrainsWithLandSubteam)

    --List out every M28 brain on this team by subteam
    if bHaveM28BrainInTeam then
        for iBrain, oBrain in tTeamData[iTotalTeamCount][subreftoFriendlyActiveM28Brains] do
            LOG('M28 brain '..oBrain.Nickname..' land subteam='..(oBrain.M28LandSubteam or 'nil')..'; Air subteam='..(oBrain.M28AirSubteam or 'nil'))
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckForBrainsWithoutLandSubteam(iTeam, tbBrainsWithLandSubteam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckForBrainsWithoutLandSubteam'

    while not(M28Map.bWaterZoneInitialCreation) do
        WaitTicks(1)
    end
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': About to check if any brains in team '..iTeam..'; are missing a land subteam, tbBrainsWithLandSubteam='..repru(tbBrainsWithLandSubteam)) end
    if M28Utilities.IsTableEmpty(tTeamData[iTeam][subreftoFriendlyActiveM28Brains]) == false then
        for iBrain, oBrain in tTeamData[iTeam][subreftoFriendlyActiveM28Brains] do
            if not(tbBrainsWithLandSubteam[oBrain:GetArmyIndex()]) and not(oBrain.M28LandSubteam) and oBrain.M28AI then
                if bDebugMessages == true then LOG(sFunctionRef..': No land subteam recorded yet for brain '..oBrain.Nickname..'; will try and search for one, Index='..oBrain:GetArmyIndex()..'; Start point='..repru(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])..'; Time='..GetGameTimeSeconds()) end
                --Campaign map - find hte closest factory to the player start, if we have one
                local tStartPoint = M28Map.PlayerStartPoints[oBrain:GetArmyIndex()]
                local iStartIsland
                local tFriendlyFactories = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandHQ + M28UnitInfo.refCategoryAirHQ, false, true)
                local iStartPlateau
                if M28Utilities.IsTableEmpty(tFriendlyFactories) == false then
                    local iCurDist
                    local iClosestDist = 100000
                    for iFactory, oFactory in tFriendlyFactories do
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(tStartPoint, oFactory:GetPosition())
                        if iCurDist < iClosestDist then
                            iClosestDist = iCurDist
                            iStartIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, oFactory:GetPosition())
                            iStartPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, oFactory:GetPosition())
                        end
                    end
                end
                if not(iStartIsland) or not(iStartPlateau) then
                    --Non-campaign map, or campaign map where no factories - Find the nearest land area to the brain's start position
                    local tStartLZOrWZData = M28Map.GetLandOrWaterZoneData(tStartPoint)
                    if bDebugMessages == true then LOG(sFunctionRef..': tStartPoint='..repru(tStartPoint)..'; Is LZOrWZData empty='..tostring(M28Utilities.IsTableEmpty(tStartLZOrWZData))..'; Water zone setup started='..tostring(M28Map.bWaterZoneInitialCreation)) end
                    M28Air.RecordOtherLandAndWaterZonesByDistance(tStartLZOrWZData, tStartPoint)
                    if M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                        for iEntry, tSubtable in tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                            if not(tSubtable[M28Map.subrefbIsWaterZone]) then
                                local tCurLZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                iStartIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tCurLZData[M28Map.subrefMidpoint])
                                iStartPlateau =  NavUtils.GetLabel(M28Map.refPathingTypeHover, tCurLZData[M28Map.subrefMidpoint])
                                if iStartIsland and iStartPlateau then break end
                            end
                        end
                    end
                end
                if not(iStartIsland) or not(iStartPlateau) then
                    M28Utilities.ErrorHandler('Unable to find a starting island for brain nickname '..(oBrain.Nickname or 'nil')..' so wont have a land subteam created for it with a valid island')
                    --Basic values so wont completely error out:
                    iStartPlateau = 1
                    iStartIsland = 1
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Will create a backup land subteam for oBrain='..oBrain.Nickname..'; iStartPlateau='..(iStartPlateau or 'nil')..'; iStartIsland='..(iStartIsland or 'nil')) end
                CreateNewLandSubteam(iStartPlateau, iStartIsland, { oBrain})
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordAllPlayers()

    --Call via ForkThread from initialisation, so 1 tick after the first brain will have been created
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAllPlayers'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if not(bRecordedAllPlayers) then
        bRecordedAllPlayers = true
        for iBrain, oBrain in ArmyBrains do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iBrain '..iBrain..'; oBrain.Nickname='..(oBrain.Nickname or 'nil')..'; Is civilian='..tostring(M28Conditions.IsCivilianBrain(oBrain))..'; Is M28AI='..tostring(oBrain.M28AI or false)..'; Time='..GetGameTimeSeconds()..'; M28Team value='..(oBrain.M28Team or 'nil')) end
            if not(M28Conditions.IsCivilianBrain(oBrain)) then --Compatibility with making civilian brains use M28 logic - means they need to be part of a team
                iPlayersAtGameStart = iPlayersAtGameStart + 1
                if not(oBrain.M28Team) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will create a new team for brain '..oBrain.Nickname) end
                    CreateNewTeam(oBrain)
                end
            end
        end
    end


    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

--[[function RemoveUnitFromCurrentLandZone(aiBrain, oUnit)
    M28Utilities.ErrorHandler('To add code')
end--]]

function UpdateUnitPreviousZones(oUnit, iPlateau, iLandZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateUnitPreviousZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    oUnit[M28UnitInfo.refbUnitStuckAlternating] = false
    if not(oUnit[M28UnitInfo.reftRecentPlateauAndZoneByTeam]) then
        oUnit[M28UnitInfo.reftRecentPlateauAndZoneByTeam] = {}
    end
    table.insert(oUnit[M28UnitInfo.reftRecentPlateauAndZoneByTeam], 1, {iPlateau, iLandZone})
    if oUnit[M28UnitInfo.reftRecentPlateauAndZoneByTeam][8] then
        if oUnit[M28UnitInfo.reftRecentPlateauAndZoneByTeam][9] then
            table.remove(oUnit[M28UnitInfo.reftRecentPlateauAndZoneByTeam], 9)
        end

        --Check if we have been alternating between the same two zones
        local tiPlateauOrZeroAndZones = {}
        local iUniqueCount = 0
        for iEntry, tPlateauOrZeroAndZone in  oUnit[M28UnitInfo.reftRecentPlateauAndZoneByTeam] do
            if not(tiPlateauOrZeroAndZones[tPlateauOrZeroAndZone[1]]) then
                tiPlateauOrZeroAndZones[tPlateauOrZeroAndZone[1]] = {}
            end
            if not(tiPlateauOrZeroAndZones[tPlateauOrZeroAndZone[1]][tPlateauOrZeroAndZone[2]]) then
                tiPlateauOrZeroAndZones[tPlateauOrZeroAndZone[1]][tPlateauOrZeroAndZone[2]] = 0
                iUniqueCount = iUniqueCount + 1
            else
                tiPlateauOrZeroAndZones[tPlateauOrZeroAndZone[1]][tPlateauOrZeroAndZone[2]] = tiPlateauOrZeroAndZones[tPlateauOrZeroAndZone[1]][tPlateauOrZeroAndZone[2]] + 1
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iUniqueCount='..iUniqueCount..'; tiPlateauOrZeroAndZones='..repru(tiPlateauOrZeroAndZones)..'; oUnit[M28UnitInfo.reftRecentPlateauAndZoneByTeam]='..repru(oUnit[M28UnitInfo.reftRecentPlateauAndZoneByTeam])..'; Time since unit last retreated='..GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeLastTriedRetreating] or -100)..'; Time='..GetGameTimeSeconds()) end
        if iUniqueCount <= 3 then --if only 3 dif zones then chances are we have been alternating
            if GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeLastTriedRetreating] or -100) >= 30 then
                if bDebugMessages == true then LOG(sFunctionRef..': Unit is stuck alternating between zones so will flag accordingly') end
                oUnit[M28UnitInfo.refbUnitStuckAlternating] = true
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordUnitInLandZone()  end --DONE TO HELP LOCATE
function AddUnitToLandZoneForBrain(aiBrain, oUnit, iPlateau, iLandZone, bIsEnemyAirUnit)
    --If unit already has a land zone assigned then remove this
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddUnitToLandZoneForBrain'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if EntityCategoryContains(categories.MOBILE * categories.AIR, oUnit.UnitId) and not(bIsEnemyAirUnit) and oUnit:GetFractionComplete() == 1 and not(EntityCategoryContains(M28UnitInfo.refCategoryEngineer + categories.EXPERIMENTAL, oUnit.UnitId)) then
        M28Utilities.ErrorHandler('Havent flagged that a constructed air unit is an air unit, UnitId='..oUnit.UnitId)
    end


    local bAddToZone = true
    --The function in M28Land, UpdateUnitPositionsAndLandZone, should remove a unit from a zone if it is in the wrong one based on its position, so no need for below - commented out (pre v1) in case change my mind
    --Decided to re-add, as the second issue is duplicate entries, e.g. where an event triggers for a unit to be added to a land zone


    if oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] and oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28Team] then
        --Is the unit already assigned to this zone?
        if oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28Team][1] == iPlateau and oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28LandTeam][2] == iLandZone then
            if bDebugMessages == true then LOG(sFunctionRef..': Unit is already assigned to this plateau and land zone so will abort adding it') end
            bAddToZone = false
            --[[else
                if bDebugMessages == true then LOG(sFunctionRef..': Unit already has a plateau and LZ assigned but is dif from the desired one so will remove from its current zone first') end
                RemoveUnitFromCurrentLandZone(aiBrain, oUnit)--]]
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Considering adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to iPlateau '..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..' for brain '..aiBrain.Nickname..'; team='..aiBrain.M28Team..'; bAddToZone='..tostring(bAddToZone)..'; Is enemy='..tostring(IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()))..'; Is ally='..tostring(IsAlly(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()))) end
    if bAddToZone then
        local iPlateauRef = iPlateau
        local iLandZoneRef = iLandZone
        local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData]
        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to add unit to zone, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; is LZTeamData nil='..tostring(tLZTeamData == nil)..'; is oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] nil='..tostring(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] == nil)..'; Unit position='..repru(oUnit:GetPosition())) end
        if M28Utilities.IsTableEmpty(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) then
            oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] = {}
            if M28Utilities.IsTableEmpty(tLZTeamData) then
                iPlateauRef, iLandZoneRef = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                tLZTeamData = M28Map.tAllPlateaus[iPlateauRef][M28Map.subrefPlateauLandZones][iLandZoneRef][M28Map.subrefLZTeamData]
                if bDebugMessages == true then LOG(sFunctionRef..': Got the closest plateau and zone to position, iPlateauRef='..(iPlateauRef or 'nil')..'; iLandZoneRef='..(iLandZoneRef or 'nil')..'; is tLZTeamData empty='..tostring(tLZTeamData == nil)) end
            end
        else
            --Backup - sometimes if an enemy unit goes over a cliff on larger maps there can be an inconsistency where the plateau is different to the land zone; in such cases the land zone logic should update the unit position, but also want to avoid an unhandled error here
            if M28Utilities.IsTableEmpty(tLZTeamData) then
                iPlateauRef = oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28Team][1]
                iLandZoneRef = oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28Team][2]
                tLZTeamData = M28Map.tAllPlateaus[iPlateauRef][M28Map.subrefPlateauLandZones][iLandZoneRef][M28Map.subrefLZTeamData]
            end
        end

        if tLZTeamData then
            oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28Team] = {iPlateauRef, iLandZoneRef}
            local iUnitArmyIndex = oUnit:GetAIBrain():GetArmyIndex()
            local bIsEnemy = IsEnemy(aiBrain:GetArmyIndex(), iUnitArmyIndex)
            local bIsAlly = IsAlly(aiBrain:GetArmyIndex(), iUnitArmyIndex)
            if not(bIsEnemy) and not(bIsAlly) and M28Map.bIsCampaignMap and aiBrain.CampaignAI and tTeamData[aiBrain.M28Team][subrefiActiveM28BrainCount] > 1 and M28Utilities.IsTableEmpty(tTeamData[aiBrain.M28Team][subreftoFriendlyActiveM28Brains]) == false then
                --Consider switching brain if any other aibrain members of this team are an enemy to this unit
                for iBrain, oBrain in tTeamData[aiBrain.M28Team][subreftoFriendlyActiveM28Brains] do
                    if not(oBrain == aiBrain) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have unit that is neither an enemy nor an ally in campaign, check if other brains on the team have it as an enemy, IsEnemy='..tostring(IsEnemy(oBrain:GetArmyIndex(), iUnitArmyIndex))..'; IsAlly='..tostring(IsAlly(oBrain:GetArmyIndex(), iUnitArmyIndex))) end
                        if IsEnemy(oBrain:GetArmyIndex(), iUnitArmyIndex) then
                            bIsEnemy = true
                            aiBrain = oBrain
                            break
                        elseif IsAlly(oBrain:GetArmyIndex(), iUnitArmyIndex) then
                            bIsAlly = true
                            aiBrain = oBrain
                            break
                        end
                    end
                end
            end
            if bIsEnemy then
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Is an enemy so will add to list of enemy air units or enemy units depending on if it is air, Is team data for this plateau and land zone empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauRef][M28Map.subrefPlateauLandZones][iLandZoneRef][M28Map.subrefLZTeamData][aiBrain.M28Team]))..'; aiBrain='..aiBrain.Nickname..'; team='..aiBrain.M28Team..'; Unit position='..repru(oUnit:GetPosition())..'; bIsEnemyAirUnit='..tostring(bIsEnemyAirUnit or false)..'; M28Map.bWaterZoneInitialCreation='..tostring(M28Map.bWaterZoneInitialCreation or false))
                    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauRef][M28Map.subrefPlateauLandZones][iLandZoneRef][M28Map.subrefLZTeamData][aiBrain.M28Team]) then
                        M28Utilities.DrawLocation(oUnit:GetPosition(), 2)
                    end
                end
                if bIsEnemyAirUnit then
                    table.insert(M28Map.tAllPlateaus[iPlateauRef][M28Map.subrefPlateauLandZones][iLandZoneRef][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.reftLZEnemyAirUnits], oUnit)
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': About to add enemy to table of enemy units, iPlateauRef='..(iPlateauRef or 'nil')..'; iLandZoneRef='..(iLandZoneRef or 'nil')..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is this a T2 arti unit='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId))) end
                    table.insert(M28Map.tAllPlateaus[iPlateauRef][M28Map.subrefPlateauLandZones][iLandZoneRef][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefTEnemyUnits], oUnit)
                    --T2 arti tracking - consider firebase
                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) then
                        M28Land.ConsiderIfHaveEnemyFirebase(aiBrain.M28Team, oUnit)
                    end
                end
            elseif bIsAlly then
                --Dont add allied air units, or units from a different (allied) team
                if oUnit:GetAIBrain().M28Team == aiBrain.M28Team and (not(EntityCategoryContains(M28UnitInfo.refCategoryAllAir - M28UnitInfo.refCategoryEngineer, oUnit.UnitId)) or oUnit:GetFractionComplete() < 1) then
                    local tLZData = M28Map.tAllPlateaus[iPlateauRef][M28Map.subrefPlateauLandZones][iLandZoneRef]
                    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
                    table.insert(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits], oUnit)
                    if oUnit[M28UnitInfo.refiCombatRange] > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId)) then
                        if not(tLZTeamData[M28Map.subrefLZTAlliedCombatUnits]) then tLZTeamData[M28Map.subrefLZTAlliedCombatUnits] = {} end --redundancy for campaign scenarios with a delayed start where a unit might have moved to a zone that hasnt been setup yet
                        table.insert(tLZTeamData[M28Map.subrefLZTAlliedCombatUnits], oUnit)
                    end
                    if M28Config.M28ShowUnitNames then oUnit:SetCustomName(oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'New P'..iPlateauRef..'LZ'..iLandZoneRef) end
                    --Reset assigned value (if it has one) if the zone it last had orders from is no longer adjacent
                    if oUnit[M28Land.refiCurrentAssignmentValue] then
                        local iLastOrderZone = oUnit[M28Land.refiCurrentAssignmentPlateauAndLZ][2]
                        local bOrderZoneAdjacent = false
                        if iLastOrderZone == iLandZoneRef then
                            bOrderZoneAdjacent = true
                        elseif M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                if iAdjLZ == iLastOrderZone then
                                    bOrderZoneAdjacent = true
                                    break
                                end
                            end
                        end
                        if not(bOrderZoneAdjacent) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Units assigned zone isnt adjacent to its current zone, so will reset its assignment value, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                            oUnit[M28Land.refiCurrentAssignmentValue] = 0 --reset so unit should get new orders from the current zone or an adjacent zone
                        end
                    end
                    --Update table of previous entries
                    UpdateUnitPreviousZones(oUnit, iPlateau, iLandZone)
                    if EntityCategoryContains(M28UnitInfo.refCategoryTMD, oUnit.UnitId) then
                        M28Building.AlliedTMDFirstRecorded(aiBrain.M28Team, oUnit)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Add unit as a friendly unit to Plateau-LZ='..iPlateauRef..'-'..iLandZoneRef..' and team='..aiBrain.M28Team..'; Is table of friendly units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauRef][M28Map.subrefPlateauLandZones][iLandZoneRef][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subreftoLZOrWZAlliedUnits]))) end
                elseif bDebugMessages == true then LOG(sFunctionRef..': have a complete allied air unit so wont record as a land unit')
                end
            end
        elseif iPlateauRef == 0 and iLandZoneRef then
            if bDebugMessages == true then LOG(sFunctionRef..': Will try adding to water zone instead') end
            if (GetGameTimeSeconds() - (oUnit['BackupZoneAssignmentTime'] or -1)) >= 1 then
                oUnit['BackupZoneAssignmentTime'] = GetGameTimeSeconds() --Preemptive to stop potential infinite loop if we call addunittolandzone from addunittowaterzone
                AddUnitToWaterZoneForBrain(aiBrain, oUnit, iLandZoneRef, bIsEnemyAirUnit)
            end
        else
            M28Utilities.ErrorHandler('Still dont have valid plateau and land zone combination for air unit')
            if bDebugMessages == true then LOG(sFunctionRef..': oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]='..repru(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam])..'; unit pos='..repru(oUnit:GetPosition())) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function AddUnitToWaterZoneForBrain(aiBrain, oUnit, iWaterZone, bIsEnemyAirUnit)
    --If unit already has a land zone assigned then remove this
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddUnitToWaterZoneForBrain'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if not(M28Map.bWaterZoneInitialCreation) or not(M28Map.bWaterZoneFirstTeamInitialisation) then
        if GetGameTimeSeconds() >= 10 then
            M28Utilities.ErrorHandler('Trying to add unit to water zone but we havent setup initial water zone variables yet, will try waiting 1 second, bWaterZoneInitialCreation='..tostring(M28Map.bWaterZoneInitialCreation or false)..'; M28Map.bWaterZoneFirstTeamInitialisation='..tostring(M28Map.bWaterZoneFirstTeamInitialisation or false))
            WaitSeconds(1)
        else

            while not(M28Map.bWaterZoneInitialCreation) or not(M28Map.bWaterZoneFirstTeamInitialisation) do
                WaitTicks(1)
                if GetGameTimeSeconds() >= 11 then break end
            end
        end
    end

    if EntityCategoryContains(categories.MOBILE * categories.AIR, oUnit.UnitId) and not(bIsEnemyAirUnit) and oUnit:GetFractionComplete() == 1 then M28Utilities.ErrorHandler('Havent flagged that a constructed air unit is an air unit') end


    local bAddToZone = true
    --The function in M28Navy, UpdateUnitPositionsAndWaterZone, should also remove a unit from a zone if it is in the wrong one based on its position

    if oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam] and oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][aiBrain.M28Team] then
        --Is the unit already assigned to this zone?
        if oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][aiBrain.M28Team] == iWaterZone then
            if bDebugMessages == true then LOG(sFunctionRef..': Unit is already assigned to this water zone so will abort adding it') end
            bAddToZone = false
            --[[else
                if bDebugMessages == true then LOG(sFunctionRef..': Unit already has a plateau and LZ assigned but is dif from the desired one so will remove from its current zone first') end
                RemoveUnitFromCurrentLandZone(aiBrain, oUnit)--]]
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Considering adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to iWaterZone '..(iWaterZone or 'nil')..' for brain '..aiBrain.Nickname..'; bAddToZone='..tostring(bAddToZone)..'; Is enemy='..tostring(IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()))..'; Is ally='..tostring(IsAlly(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()))..'; bWaterZoneFirstTeamInitialisation='..tostring(M28Map.bWaterZoneFirstTeamInitialisation or false)) end
    if bAddToZone then
        if not(oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam]) then oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam] = {} end
        oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][aiBrain.M28Team] = iWaterZone
        local iPond = M28Map.tiPondByWaterZone[iWaterZone]
        local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
        local tWZTeamData = tWZData[M28Map.subrefWZTeamData][aiBrain.M28Team]
        --NOTE: If run into same issue that had with land zones (of not having valid plateau/land zone combination), DO NOT call the 'addunittolandzone' function from here, or else will create an infinite loop
        if bDebugMessages == true then LOG(sFunctionRef..': iPond='..(iPond or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'; Team='..(aiBrain.M28Team or 'nil')..'; IsEnemy='..tostring(IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()))..'; Is tWZTeamData empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData))) end
        if IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()) then
            if bDebugMessages == true then LOG(sFunctionRef..': Is an enemy so will add to list of enemy air units or enemy units depending on if it is air; aiBrain='..aiBrain.Nickname..'; team='..aiBrain.M28Team..'; Unit position='..repru(oUnit:GetPosition())..'; bIsEnemyAirUnit='..tostring(bIsEnemyAirUnit or false)) end
            if bIsEnemyAirUnit then
                table.insert(tWZTeamData[M28Map.reftWZEnemyAirUnits], oUnit)
            else
                table.insert(tWZTeamData[M28Map.subrefTEnemyUnits], oUnit)
            end
            --Record if enemy has sub
            if EntityCategoryContains(M28UnitInfo.refCategorySubmarine, oUnit.UnitId) then
                tTeamData[aiBrain.M28Team][refbEnemyHasSub] = true
            end
        elseif IsAlly(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()) then
            oUnit[M28Navy.refiCurrentWZAssignmentValue] = 0 --dont want to retain orders in case it was from an adjacent zone
            table.insert(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits], oUnit)
            if M28Config.M28ShowUnitNames then oUnit:SetCustomName(oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'New WZ'..iWaterZone) end




            if oUnit[M28Navy.refiCurrentWZAssignmentValue] then
                local iLastOrderZone = oUnit[M28Navy.refiCurrentAssignmentWaterZone]
                local bOrderZoneAdjacent = false
                if iLastOrderZone == iWaterZone then
                    bOrderZoneAdjacent = true
                elseif M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                    for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                        if iAdjWZ == iLastOrderZone then
                            bOrderZoneAdjacent = true
                            break
                        end
                    end
                end
                if not(bOrderZoneAdjacent) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Units assigned water zone isnt adjacent to its current zone, so will reset its assignment value, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                    oUnit[M28Navy.refiCurrentWZAssignmentValue] = 0 --reset so unit should get new orders from the current zone or an adjacent zone
                end
            end
            UpdateUnitPreviousZones(oUnit, 0, iWaterZone)

            if EntityCategoryContains(M28UnitInfo.refCategoryTMD, oUnit.UnitId) then
                M28Building.AlliedTMDFirstRecorded(aiBrain.M28Team, oUnit)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Add unit as a friendly unit to iWaterZone='..iWaterZone..' and team='..aiBrain.M28Team..'; Is table of friendly units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateUnitLastKnownPosition(aiBrain, oUnit, bDontCheckIfCanSeeUnit, bInWaterZone)
    --Only updates the position if the unit isnt on the same team as us (to save space), since we can use :GetPosition() for allied units
    --Checks if the unti needs reassigning if it is a land or naval unit
    local oUnitBrain = oUnit:GetAIBrain()

    if not(oUnitBrain == aiBrain or IsAlly(aiBrain:GetArmyIndex(), oUnitBrain:GetArmyIndex())) then
        if bDontCheckIfCanSeeUnit or M28UnitInfo.CanSeeUnit(aiBrain, oUnit) then
            if not(oUnit[M28UnitInfo.reftLastKnownPositionByTeam]) then oUnit[M28UnitInfo.reftLastKnownPositionByTeam] = {} end
            local tCurPosition = oUnit:GetPosition()
            oUnit[M28UnitInfo.reftLastKnownPositionByTeam][aiBrain.M28Team] = {tCurPosition[1], tCurPosition[2], tCurPosition[3]} --Do a copy of table as :GetPosition() means it will always update for the unit's latest position even when we lack intel of it
        else
            --Below to try and approximate scenarios where enemy retreats temporarily with the unit and we end up with units thinking the enemy is right infront of them (even though they can see the location it used to be to confirm it isnt there); will approximate by saying if we have friendly units in the same land zone as the last known position, then we can refresh its position
            if not(bInWaterZone) then
                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][aiBrain.M28Team])
                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subreftoLZOrWZAlliedUnits]) == false then
                    local tCurPosition = oUnit:GetPosition()
                    oUnit[M28UnitInfo.reftLastKnownPositionByTeam][aiBrain.M28Team] = {tCurPosition[1], tCurPosition[2], tCurPosition[3]}
                end
            else
                local iLastSegmentX, iLastSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][aiBrain.M28Team])
                local iWaterZone = M28Map.tWaterZoneBySegment[iLastSegmentX][iLastSegmentZ]
                if iWaterZone then
                    local iPond = M28Map.tiPondByWaterZone[iWaterZone]
                    if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subreftoLZOrWZAlliedUnits]) == false then
                        local tCurPosition = oUnit:GetPosition()
                        oUnit[M28UnitInfo.reftLastKnownPositionByTeam][aiBrain.M28Team] = {tCurPosition[1], tCurPosition[2], tCurPosition[3]}
                    end
                end
            end
        end
    end
end

function DelayedUnitAssignmentForTeamSetup(aiBrain, oUnit)
    while not(M28Map.bFirstM28TeamHasBeenInitialised) or not(M28Map.bMapLandSetupComplete) or not(M28Map.bWaterZoneInitialCreation) do
        WaitTicks(1)
        if GetGameTimeSeconds() >= 120 then
            M28Utilities.ErrorHandler('Still dont have a team setup after waiting a long time so will abort')
            break
        end
    end
    WaitTicks(1)
    if M28UnitInfo.IsUnitValid(oUnit) then
        ConsiderAssigningUnitToZoneForBrain(aiBrain, oUnit)
    end
end

function ConsiderAssigningUnitToZoneForBrain(aiBrain, oUnit)
    --Assumes called from an event that means we will have visibility of the unit (e.g. directly via intel, or indirectly via weapon firing)
    if aiBrain.M28AI and not(aiBrain.M28IsDefeated) then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'ConsiderAssigningUnitToZoneForBrain'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if not(aiBrain.M28Team) and not(M28Map.bFirstM28TeamHasBeenInitialised) then ForkThread(DelayedUnitAssignmentForTeamSetup, aiBrain, oUnit)
        else


            if bDebugMessages == true then LOG(sFunctionRef..': Checking at time '..GetGameTimeSeconds()..' if should assign unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to a plateau/other table. Considered for assignment repru='..repru(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam])..'; Unit brain team='..(oUnit:GetAIBrain().M28Team or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; aiBrain.M28IsDefeated='..tostring(aiBrain.M28IsDefeated or false)) end
            if M28UnitInfo.IsUnitValid(oUnit) then --redundancy
                if (not(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam]) or not(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team])) and M28UnitInfo.IsUnitValid(oUnit) and not(aiBrain.M28IsDefeated) then
                    AssignUnitToLandZoneOrPond(aiBrain, oUnit)
                else
                    UpdateUnitLastKnownPosition(aiBrain, oUnit, true)
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function DelayedUnitPlateauAssignment(aiBrain, oUnit, iDelayInTicks, bAlreadyUpdatedPosition, bAlreadyTriedReassignment)
    WaitTicks(iDelayInTicks)
    AssignUnitToLandZoneOrPond(aiBrain, oUnit, bAlreadyUpdatedPosition, bAlreadyTriedReassignment)
end

function RemoveUnitFromBigThreatTable(oDeadUnit)
    --Removes all dead units from each team's listings, assuming oDeadUnit is a big threat
    local sTableRef
    local bIsSMD = false
    if EntityCategoryContains(M28UnitInfo.refCategorySMD, oDeadUnit.UnitId) then bIsSMD = true end
    for sReferenceTable, iCategory in tEnemyBigThreatCategories do
        if EntityCategoryContains(iCategory, oDeadUnit.UnitId) then
            sTableRef = sReferenceTable
            break
        end
    end
    for iTeam, bRecorded in oDeadUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable] do
        local iRevisedIndex = 1
        local iTableSize = table.getn(tTeamData[iTeam][sTableRef])

        for iOrigIndex=1, iTableSize do
            if tTeamData[iTeam][sTableRef][iOrigIndex] then
                if M28UnitInfo.IsUnitValid(tTeamData[iTeam][sTableRef][iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                    --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                    if (iOrigIndex ~= iRevisedIndex) then
                        tTeamData[iTeam][sTableRef][iRevisedIndex] = tTeamData[iTeam][sTableRef][iOrigIndex];
                        tTeamData[iTeam][sTableRef][iOrigIndex] = nil;
                    end
                    iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                else
                    if bIsSMD then tTeamData[iTeam][refbEnemySMDDiedSinceLastNukeCheck] = true end --used to refresh nuke target zone logic
                    tTeamData[iTeam][sTableRef][iOrigIndex] = nil;
                end
                if EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti + M28UnitInfo.refCategorySatellite + M28UnitInfo.refCategoryNovaxCentre, oDeadUnit.UnitId) then
                    RefreshArtiAndNovaxCount(iTeam)
                end
            end
        end
        if iRevisedIndex < iTableSize then
            --table.setn(tTeamData[iTeam][sTableRef], iRevisedIndex - 1)
            for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
                table.remove(tTeamData[iTeam][sTableRef], iRemovalEntry)
            end
        end
    end
end
function LongRangeThreatMonitor(iTeam)
    --Call via forkthread
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'LongRangeThreatMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iTableSize
    local sreftiLastPlateauAndZone = 'M28LRLstPZ'
    local iPlateauOrZero, iLandOrWaterZone

    if bDebugMessages == true then LOG(sFunctionRef..': About to start long range enemy unit monitor for team '..iTeam..'; Is table empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iTeam][reftLongRangeEnemyDFUnits]))) end
    while M28Utilities.IsTableEmpty(tTeamData[iTeam][reftLongRangeEnemyDFUnits]) == false do
        --Check all units still alive
        iTableSize = table.getn(tTeamData[iTeam][reftLongRangeEnemyDFUnits])
        if bDebugMessages == true then LOG(sFunctionRef..': Size of table at time '..GetGameTimeSeconds()..'='..iTableSize) end
        for iCurEntry = iTableSize, 1, -1 do
            local oUnit = tTeamData[iTeam][reftLongRangeEnemyDFUnits][iCurEntry]
            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
            if not(M28UnitInfo.IsUnitValid(oUnit)) then
                table.remove(tTeamData[iTeam][reftLongRangeEnemyDFUnits], iCurEntry)
            else
                if oUnit:GetFractionComplete() >= 0.95 then
                    iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                    --Has this changed from last time? if so need to refresh
                    if bDebugMessages == true then LOG(sFunctionRef..': iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; sreftiLastPlateauAndZone='..repru( oUnit[sreftiLastPlateauAndZone])) end
                    if iPlateauOrZero == oUnit[sreftiLastPlateauAndZone][1] and iLandOrWaterZone == oUnit[sreftiLastPlateauAndZone][2] then
                        --Do nothing - no change
                        if bDebugMessages == true then LOG(sFunctionRef..': No change in units zone from last time we ran so dont need to do anything further') end
                    else
                        --has changed - remove from previous entries if it had any
                        if (oUnit[sreftiLastPlateauAndZone][2] or 0) > 0 then
                            --Remove previous entries if was land zone
                            if (oUnit[sreftiLastPlateauAndZone][1] or 0) > 0 then
                                local tLZData = M28Map.tAllPlateaus[oUnit[sreftiLastPlateauAndZone][1]][M28Map.subrefPlateauLandZones][oUnit[sreftiLastPlateauAndZone][2]]
                                local iAdjLZ
                                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                                    for iEntry, tSubtable in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                                        iAdjLZ = tSubtable[M28Map.subrefLZNumber]
                                        local tAdjLZTeamData = M28Map.tAllPlateaus[oUnit[sreftiLastPlateauAndZone][1]][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                        if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats]) == false then
                                            for iRecordedUnit, oRecordedUnit in tAdjLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats] do
                                                if oUnit == oRecordedUnit then
                                                    table.remove(tAdjLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats], iRecordedUnit)
                                                    break
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end

                        --Add to nearby zones
                        oUnit[sreftiLastPlateauAndZone] = {[1]=iPlateauOrZero,[2]=iLandOrWaterZone}
                        local iMaxDist = oUnit[M28UnitInfo.refiDFRange] + 120 --tried +40 (meaning 140 range on fatboy) but led to fatboy getting free hits on units with the dist between zones being 195; have therefore increased the dist threshold, and added in a distance check into the zone itself which will go with a slightly lower distance
                        local iMaxTravelDist = iMaxDist * 2
                        local tLZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                        local iAdjLZ
                        if bDebugMessages == true then LOG(sFunctionRef..': Unit has changed zones, is table of pathing to other zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]))) end
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                            for iEntry, tSubtable in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                                if tSubtable[M28Map.subrefLZTravelDist] > iMaxTravelDist then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Are too far from the other zone so will stop searching, travel dist='..tSubtable[M28Map.subrefLZTravelDist]..'; iMaxTravelDist='..iMaxTravelDist..'; Zone='..tSubtable[M28Map.subrefLZNumber]) end
                                    break
                                end
                                iAdjLZ = tSubtable[M28Map.subrefLZNumber]
                                local tAdjLZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ]
                                if bDebugMessages == true then LOG(sFunctionRef..': Checking if we are close to zone '..iAdjLZ..'; Dist to this='..M28Utilities.GetDistanceBetweenPositions(tAdjLZData[M28Map.subrefMidpoint], tLZData[M28Map.subrefMidpoint])..'; iMaxDist='..iMaxDist) end
                                if M28Utilities.GetDistanceBetweenPositions(tAdjLZData[M28Map.subrefMidpoint], tLZData[M28Map.subrefMidpoint]) <= iMaxDist then
                                    local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                                    local bInclude = true
                                    if not(tAdjLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats]) then
                                        tAdjLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats] = {}
                                    else
                                        --Redundancy - make sure not already here
                                        if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats]) == false then
                                            for iRecordedUnit, oRecordedUnit in tAdjLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats] do
                                                if oUnit == oRecordedUnit then
                                                    bInclude = false
                                                    break
                                                end
                                            end
                                        end
                                    end
                                    if bInclude then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Just added unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of long range threats for zone '..iAdjLZ..' on plateau '..iPlateauOrZero..'; Dist between midpoints='.. M28Utilities.GetDistanceBetweenPositions(tAdjLZData[M28Map.subrefMidpoint], tLZData[M28Map.subrefMidpoint])..'; Unit dist to adjLZData midpoint='.. M28Utilities.GetDistanceBetweenPositions(tAdjLZData[M28Map.subrefMidpoint], oUnit:GetPosition())..'; Dist to closest friendly base='.. M28Utilities.GetDistanceBetweenPositions(tAdjLZTeamData[M28Map.reftClosestFriendlyBase], oUnit:GetPosition())) end
                                        table.insert(tAdjLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats], oUnit)
                                    end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': straight line dist is too far away so wont record') end
                                end
                            end
                        end

                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': End of loop, gametime='..GetGameTimeSeconds()) end

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    --Reset (so the monitor gets restarted next time there is a long range enemy threat)
    tTeamData[iTeam][reftLongRangeEnemyDFUnits] = nil
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AddUnitToLongRangeThreatTable(oUnit, iTeam, bCheckifAlreadyInTable)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddUnitToLongRangeThreatTable'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bNotInTable = not(bCheckifAlreadyInTable)
    if not(tTeamData[iTeam][reftLongRangeEnemyDFUnits]) then
        tTeamData[iTeam][reftLongRangeEnemyDFUnits] = {}
        bNotInTable = true
        ForkThread(LongRangeThreatMonitor, iTeam)
    end
    if not(bNotInTable) then
        bNotInTable = true
        for iEntry, oExistingUnit in tTeamData[iTeam][reftLongRangeEnemyDFUnits] do
            if oUnit == oExistingUnit then
                bNotInTable = false
                break
            end
        end
    end
    if bNotInTable then
        table.insert(tTeamData[iTeam][reftLongRangeEnemyDFUnits], oUnit)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code at time '..GetGameTimeSeconds()..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Added to table of long range units and started a monitor if one wasnt already started. Unit DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AddUnitToBigThreatTable(iTeam, oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddUnitToBigThreatTable'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Considering ouNIt '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' for iTeam='..iTeam..'; oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable][iTeam]='..(oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable][iTeam] or 'nil')) end
    if not(oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable] and oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable][iTeam]) then
        local bAlreadyInTable = false

        for sReferenceTable, iCategory in tEnemyBigThreatCategories do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering sReferenceTable='..sReferenceTable..'; Does unit contain category for this table='..tostring(EntityCategoryContains(iCategory, oUnit.UnitId))) end
            if EntityCategoryContains(iCategory, oUnit.UnitId) then
                if M28Utilities.IsTableEmpty(tTeamData[iTeam][sReferenceTable]) == false then
                    for iExistingUnit, oExistingUnit in tTeamData[iTeam][sReferenceTable] do
                        if oExistingUnit == oUnit then

                            bAlreadyInTable = true --redundancy
                            if not(oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable]) then oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable] = {} end
                            oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable][iTeam] = true
                            break
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': bAlreadyInTable='..tostring(bAlreadyInTable)) end
                if not(bAlreadyInTable) then

                    if bDebugMessages == true then LOG(sFunctionRef..': About to add unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to reference table. Is table empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iTeam][sReferenceTable]))..'; Unit fraction complete='..oUnit:GetFractionComplete()..'; T3 resource generation units held by owner='..oUnit:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryT3Mex + M28UnitInfo.refCategoryRASSACU + M28UnitInfo.refCategoryParagon)) end
                    if not(tTeamData[iTeam][sReferenceTable]) then tTeamData[iTeam][sReferenceTable] = {} end
                    table.insert(tTeamData[iTeam][sReferenceTable], oUnit)
                    if not(oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable]) then oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable] = {} end
                    oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable][iTeam] = true
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Have some units for experimental threat category sReferenceTable=' .. sReferenceTable .. '; is tReferenceTableEmpty after considering if civilian or pathable to us='..tostring(M28Utilities.IsTableEmpty(tTeamData[iTeam][sReferenceTable]))..'; tTeamData[iTeam][refbDefendAgainstArti]='..tostring(tTeamData[iTeam][refbDefendAgainstArti] or false)..'; iTeam='..iTeam..'; Is this a T3 arti or novax='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryNovaxCentre + M28UnitInfo.refCategoryExperimentalArti, oUnit.UnitId)))
                    end

                    --Flag if SMD built so can update nuke targeting; refiTimeOfLastCheck is used to hold the estimated time that the smd was built (which then informs whether the smd is assumed to be able to block a nuke)
                    if EntityCategoryContains(M28UnitInfo.refCategorySMD, oUnit.UnitId) then
                        tTeamData[iTeam][refbEnemySMDBuiltSinceLastNukeCheck] = true
                        local iTimeAssumedConstructed
                        if oUnit:GetNukeSiloAmmoCount() >= 1 or oUnit:GetWorkProgress() >= 0.8 then oUnit[M28UnitInfo.refiTimeOfLastCheck] = (oUnit[M28UnitInfo.refiTimeOfLastCheck] or 0) - 240 - M28Building.iTimeForSMDToBeConstructed
                            --Rough approximation of when SMD was built (ideally in future would work out the time we last scouted this area and then to be prudent assume the SMD got built 30s after that)
                        elseif oUnit:GetFractionComplete() == 1 then
                            oUnit[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds() - M28Building.iTimeForSMDToBeConstructed - 240 * oUnit:GetWorkProgress()
                            if bDebugMessages == true then LOG(sFunctionRef..': Are recording a constructed SMD so estimating when it was constructed,  oSMD='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Owner='..oUnit:GetAIBrain().Nickname..'; Time='..GetGameTimeSeconds()) end
                        else
                            oUnit[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds() - M28Building.iTimeForSMDToBeConstructed * oUnit:GetFractionComplete() --I.e. assume enemy will be able to build SMD missile c.45s sooner than would expect if it's at 99% complete
                            if bDebugMessages == true then LOG(sFunctionRef..': Are recording an underconstruction SMD so estimating when it was constructed,  oSMD='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Owner='..oUnit:GetAIBrain().Nickname..'; Fraction complete='..oUnit:GetFractionComplete()..'; Time='..GetGameTimeSeconds()) end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Just registered oSMD='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' for team '..iTeam..' at time='..GetGameTimeSeconds()..'; SMD fraction complete='..oUnit:GetFractionComplete()..'; oUnit[M28UnitInfo.refiTimeOfLastCheck]='..(oUnit[M28UnitInfo.refiTimeOfLastCheck] or 'nil')) end
                    elseif EntityCategoryContains(M28UnitInfo.refCategorySML, oUnit.UnitId) then
                        --Unpause any paused SMD
                        for iBrain, oBrain in tTeamData[iTeam][subreftoFriendlyActiveM28Brains] do
                            local tSMD = oBrain:GetListOfUnits(M28UnitInfo.refCategorySMD, false, true)
                            if M28Utilities.IsTableEmpty(tSMD) == false then
                                for iUnit, oUnit in tSMD do
                                    M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, false, nil, iTeam)
                                    oUnit:SetAutoMode(true)
                                end
                            end
                        end
                    elseif (oUnit[M28UnitInfo.refiDFRange] or 0) >= 80 then
                        AddUnitToLongRangeThreatTable(oUnit, iTeam)
                    end

                    --Track T3 arti
                    if not(tTeamData[iTeam][refbDefendAgainstArti]) and EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryNovaxCentre + M28UnitInfo.refCategoryExperimentalArti + M28UnitInfo.refCategorySatellite, oUnit.UnitId) then
                        tTeamData[iTeam][refbDefendAgainstArti] = true
                        if EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti, oUnit.UnitId) then tTeamData[iTeam][refiEnemyT3ArtiCount] = 1
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryExperimentalArti, oUnit.UnitId) then tTeamData[iTeam][refiEnemyT3ArtiCount] = 2
                        else tTeamData[iTeam][refiEnemyNovaxCount] = 1
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': have set flag to defend against T3 arti to true for team '..iTeam..'; tTeamData[iTeam][refbDefendAgainstArti]='..tostring(tTeamData[iTeam][refbDefendAgainstArti])) end
                        --Refresh shielding wanted on existing units
                        local tPotentialUnitsToShield = tTeamData[iTeam][subreftoFriendlyActiveM28Brains][1]:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryFixedShield - categories.TECH1, {0.5*(M28Map.rMapPlayableArea[1] + M28Map.rMapPlayableArea[3]), 0, 0.5*(M28Map.rMapPlayableArea[2] + M28Map.rMapPlayableArea[4])}, 10000, 'Ally')
                        if M28Utilities.IsTableEmpty(tPotentialUnitsToShield) == false then
                            for iPotentialUnit, oPotentialUnit in tPotentialUnitsToShield do
                                if oPotentialUnit:GetAIBrain().M28AI and oPotentialUnit:GetFractionComplete() == 1 then
                                    M28Building.CheckIfUnitWantsFixedShield(oPotentialUnit, true)
                                end
                            end
                        end
                        --Upgrade ED1 shields
                        for iBrain, oBrain in tTeamData[iTeam][subreftoFriendlyActiveM28Brains] do
                            local tED1Shields = oBrain:GetListOfUnits(M28UnitInfo.refCategoryFixedShield * categories.BUILTBYTIER2ENGINEER * categories.CYBRAN, false, true)
                            if M28Utilities.IsTableEmpty(tED1Shields) == false then
                                for iShield, oShield in tED1Shields do
                                    if oShield:GetFractionComplete() == 1 then
                                        M28Economy.UpgradeUnit(oShield, true)
                                    end
                                end
                            end
                        end
                    end
                end
                break
            end
        end
        if EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti + M28UnitInfo.refCategorySatellite + M28UnitInfo.refCategoryNovaxCentre, oUnit.UnitId) then
            RefreshArtiAndNovaxCount(iTeam)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function RecordEnemyT2ArtiAgainstNearbyZones(iTeam, oUnit, bUnitIsDead)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordEnemyT2ArtiAgainstNearbyZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(tTeamData[iTeam][reftoEnemyT2Arti]) then tTeamData[iTeam][reftoEnemyT2Arti] = {} end
    if not(bUnitIsDead) then
        table.insert(tTeamData[iTeam][reftoEnemyT2Arti], oUnit)
    else
        M28Conditions.IsTableOfUnitsStillValid(tTeamData[iTeam][reftoEnemyT2Arti], false)
    end
    local tStartLZOrWZData, tStartLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
    if tStartLZOrWZData then
        if not(tStartLZOrWZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) then tStartLZOrWZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits] = {} end
        if not(bUnitIsDead) then
            table.insert(tStartLZOrWZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits], oUnit)
        else
            M28Conditions.IsTableOfUnitsStillValid(tStartLZOrWZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits], false)
        end
        M28Air.RecordOtherLandAndWaterZonesByDistance(tStartLZOrWZData, oUnit:GetPosition())
        if M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
            if oUnit[M28UnitInfo.refiCombatRange] then
                local iDistanceThreshold = oUnit[M28UnitInfo.refiCombatRange] + 80
                for iEntry, tSubtable in tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                    if tSubtable[M28Map.subrefiDistance] > iDistanceThreshold then break end
                    local tAltLZOrWZData
                    local tAltLZOrWZTeamData
                    local iCurPlateauOrPond
                    local iCurLZOrWZRef = tSubtable[M28Map.subrefiLandOrWaterZoneRef]
                    if tSubtable[M28Map.subrefbIsWaterZone] then
                        tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurLZOrWZRef]][M28Map.subrefPondWaterZones][iCurLZOrWZRef]
                        iCurPlateauOrPond = 0
                        tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                    else
                        iCurPlateauOrPond = tSubtable[M28Map.subrefiPlateauOrPond]
                        tAltLZOrWZData = M28Map.tAllPlateaus[iCurPlateauOrPond][M28Map.subrefPlateauLandZones][iCurLZOrWZRef]
                        tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                    end
                    if not(tAltLZOrWZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) then tAltLZOrWZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits] = {} end
                    if not(bUnitIsDead) then
                        table.insert(tAltLZOrWZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits], oUnit)
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding arti as a unit against iPlateau'..iCurPlateauOrPond..'; iCurLZOrWZRef='..iCurLZOrWZRef) end
                    else
                        M28Conditions.IsTableOfUnitsStillValid(tAltLZOrWZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits], false)
                    end
                end
            elseif M28Map.bMapLandSetupComplete and M28Map.bFirstM28TeamHasBeenInitialised and GetGameTimeSeconds() >= 5 then
                M28Utilities.ErrorHandler('Dont have recorded range for T2 arti despite teams being setup now')
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTeam='..iTeam..'; Time='..GetGameTimeSeconds()..'; Is tTeamData[iTeam][reftoEnemyT2Arti] empty='..M28Utiliites.IsTableEmpty(tTeamData[iTeam][reftoEnemyT2Arti])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordNearbyEnemyLandFactory(oUnit, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordNearbyEnemyLandFactory'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iPlateau, iZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iPlateau='..(iPlateau or 'nil')..'; iZone='..(iZone or 'nil')) end
    if (iPlateau or 0) > 0 and (iZone or 0) > 0 then
        local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iZone]
        local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
        --Update adjacent zones to record this as being nearby
        --How close is this to our base, and is it on the same plateau?
        if bDebugMessages == true then LOG(sFunctionRef..': tLZTeamData[M28Map.refiModDistancePercent]='..tLZTeamData[M28Map.refiModDistancePercent]..'; Dist to closest friendly base='..M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], tLZData[M28Map.subrefMidpoint])) end
        if tLZTeamData[M28Map.refiModDistancePercent] <= 0.4 and M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestFriendlyBase], tLZData[M28Map.subrefMidpoint]) <= 275 then
            if not(tLZTeamData[M28Map.subrefoNearbyEnemyLandFacs]) then tLZTeamData[M28Map.subrefoNearbyEnemyLandFacs] = {} end
            table.insert(tLZTeamData[M28Map.subrefoNearbyEnemyLandFacs], oUnit)
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of adj land zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]))) end
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                local tbZonesConsidered = {}
                tbZonesConsidered[iZone] = true
                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    if not(tbZonesConsidered[iAdjLZ]) then
                        tbZonesConsidered[iAdjLZ] = true
                        local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                        local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                        if not(tAdjLZTeamData[M28Map.subrefoNearbyEnemyLandFacs]) then tAdjLZTeamData[M28Map.subrefoNearbyEnemyLandFacs] = {} end
                        table.insert(tAdjLZTeamData[M28Map.subrefoNearbyEnemyLandFacs], oUnit)
                        if M28Utilities.IsTableEmpty(tAdjLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                            for _, iSecondAdjLZ in tAdjLZData[M28Map.subrefLZAdjacentLandZones] do
                                if not(tbZonesConsidered[iSecondAdjLZ]) then
                                    tbZonesConsidered[iSecondAdjLZ] = true
                                    local tSecondAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iSecondAdjLZ]
                                    local tSecondAdjLZTeamData = tSecondAdjLZData[M28Map.subrefLZTeamData][iTeam]
                                    if not(tSecondAdjLZTeamData[M28Map.subrefoNearbyEnemyLandFacs]) then tSecondAdjLZTeamData[M28Map.subrefoNearbyEnemyLandFacs] = {} end
                                    table.insert(tSecondAdjLZTeamData[M28Map.subrefoNearbyEnemyLandFacs], oUnit)
                                end
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished recording factory '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' against nearby zones, tbZonesConsidered='..repru(tbZonesConsidered)..'; iPlateau='..iPlateau..'; Time='..GetGameTimeSeconds()) end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


--TO HELP WITH LOCATING - use AssignUnitToLandZoneOrPond instead
function RecordUnitInPlateauLandZoneOrPond()  end
---@param aiBrain userdata
---@param oUnit userdata
function AssignUnitToLandZoneOrPond(aiBrain, oUnit, bAlreadyUpdatedPosition, bAlreadyTriedReassignment, bIgnoreIfAssignedAlready)
    --Assigns oUnit to relevant table for aiBrain; Should be called if we have a unit that hasn't been considered before (check by referencing oUnit[reftbConsideredForAssignmentByTeam][iTeam]) - will decide whether the unit should be assigned to a pond, a land zone, or air units, based partially on the unit category and partially on its current position
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignUnitToLandZoneOrPond'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if M28UnitInfo.IsUnitValid(oUnit) then
        --Campaign specific - dont include units flagged as not being killable
        if not(oUnit.CanBeKilled == false) or not(oUnit.CanTakeDamage == false) or not(EntityCategoryContains(categories.CIVILIAN * categories.STRUCTURE, oUnit.UnitId) or not(M28Map.bIsCampaignMap)) then

            local bPreviouslyConsidered = (oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team] or false)
            local bIgnore = false
            if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by brain '..oUnit:GetAIBrain().Nickname..' - are considering the unit from aiBrain perspective of '..aiBrain.Nickname..' at time '..GetGameTimeSeconds()..'; Have we already considered this unit='..tostring(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team] or false)..'; bIgnoreIfAssignedAlready='..tostring(bIgnoreIfAssignedAlready or false)..'; Is enemy='..tostring(IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()))) end
            if not(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam]) then oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam] = {} end
            if bIgnoreIfAssignedAlready and oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team] then
                --Do nothing
            else
                if not(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team]) then
                    oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team] = true

                    --First time considering the unit for this team
                    --Campaign specific - dont record jamming crystals as units without an aoe cant damage them, leading to strange results - e.g. gunships can end up stuck trying to kill them
                    --Also record any units that we arent recording (due to not being an enemy or an ally) in a separate table
                    if oUnit.UnitId == 'xsc9002' and M28Map.bIsCampaignMap then
                        if bDebugMessages == true then LOG(sFunctionRef..': Seraphim jamming crystal - want to ignore since it cant be hit by non aoe gunships') end
                        bIgnore = true
                    else


                        --Record if we are at the stage of the game where experimentals/similar high threats for ACU are present
                        if not(tTeamData[aiBrain.M28Team][refbDangerousForACUs]) then
                            if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy experimental level unit detected, dangerous for ACU') end
                                tTeamData[aiBrain.M28Team][refbDangerousForACUs] = true
                            end
                        end
                        --Enemy based logic (first time considering)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to apply enemy based logic to the unit for the first time it is recognised, IsEnemy='..tostring(IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()))) end
                        if IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()) then
                            if EntityCategoryContains(M28UnitInfo.refCategorySniperBot, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy sniper bot detected, dangerous for ACU') end
                                --Exception if this is only the first sniperbot and we have multiple friendly ACUs
                                if not(tTeamData[aiBrain.M28Team][refbDangerousForACUs]) then
                                    if M28UnitInfo.GetUnitLifetimeCount(oUnit) == 1 and tTeamData[aiBrain.M28Team][subrefiActiveM28BrainCount] >= 2 and (not(ScenarioInfo.Options.Victory == "demoralization") or ScenarioInfo.Options.Share == 'FullShare') then
                                        if bDebugMessages == true then LOG(sFunctionRef..': enemy only has 1 sniperbot, since we have multiple ACUs will risk staying out a little bit longer') end
                                    else
                                        tTeamData[aiBrain.M28Team][refbDangerousForACUs] = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': Sniperbot causing dangerous flag to true') end
                                    end
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAir * categories.TECH3, oUnit.UnitId) and not(tTeamData[aiBrain.M28Team][refbDangerousForACUs]) and (not(M28Map.bIsCampaignMap) or tTeamData[aiBrain.M28Team][subrefiHighestFriendlyFactoryTech] >= 3) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy T3 air detected, enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..', owned by '..oUnit:GetAIBrain().Nickname..' dangerous for ACU') end
                                --Dont set flag to true if we have 2+ ACUs, are in full share, and it isn't a gunship
                                local iTeam = aiBrain.M28Team
                                if tTeamData[iTeam][subrefiActiveM28BrainCount] >= 2 and (not(ScenarioInfo.Options.Victory == "demoralization") or ScenarioInfo.Options.Share == 'FullShare') and not(EntityCategoryContains(M28UnitInfo.refCategoryGunship + M28UnitInfo.refCategoryBomber, oUnit.UnitId)) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Wont flag that it is dangerous for ACUs yet just because enemy has t3 air fac') end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': enemy T3 air to ground unit so no longer safe for ACUs') end
                                    tTeamData[iTeam][refbDangerousForACUs] = true
                                end
                            elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                                --check not already in table of enemy aCUs and add to this table
                                local bInTableAlready = false
                                local iTeam = aiBrain.M28Team
                                if M28Utilities.IsTableEmpty(tTeamData[iTeam][reftEnemyACUs]) == false then
                                    for iACU, oACU in tTeamData[iTeam][reftEnemyACUs] do
                                        if oACU == oUnit then bInTableAlready = true break end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Dealing with an ACU, is table of enemy ACUs empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iTeam][reftEnemyACUs]))..'; bInTableAlready='..tostring(bInTableAlready)) end
                                if not(bInTableAlready) then
                                    if not(tTeamData[iTeam][reftEnemyACUs]) then tTeamData[iTeam][reftEnemyACUs] = {} end
                                    table.insert(tTeamData[iTeam][reftEnemyACUs], oUnit)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Added unit to table of enemy ACUs for team '..iTeam) end
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryMissileShip, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have enemy missile ship '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; will record as mobile TML threat') end
                                ForkThread(RecordMobileTMLThreatForAllEnemyTeams, oUnit)

                            elseif EntityCategoryContains(M28UnitInfo.refCategoryMML, oUnit.UnitId) then
                                --Experiment with recording MMLs of all types with a LC of <=10 (not more for performance reasons)
                                if M28UnitInfo.GetUnitLifetimeCount(oUnit) <= 10 then
                                    ForkThread(RecordMobileTMLThreatForAllEnemyTeams, oUnit)
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA * categories.TECH3, oUnit.UnitId) then
                                tTeamData[aiBrain.M28Team][iEnemyT3MAAActiveCount] = (tTeamData[aiBrain.M28Team][iEnemyT3MAAActiveCount] or 0) + 1
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': About to record enemy land factory against nearby zones depending on if it is close to a friendly base') end
                                RecordNearbyEnemyLandFactory(oUnit, aiBrain.M28Team)
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryBomber * categories.TECH1, oUnit.UnitId) then
                                --UEF and Cybran bombers - activate special tracking if low lifetime count (will also do aeon and seraphim since if engineer is stationery e.g. building something it cant reliably dodge them either)
                                if M28UnitInfo.GetUnitLifetimeCount(oUnit) <= 4 then --and EntityCategoryContains(categories.UEF + categories.CYBRAN, oUnit.UnitId) then
                                    ForkThread(M28Air.EnemyT1BomberTracker, oUnit, aiBrain.M28Team)
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryMassFab + M28UnitInfo.refCategoryRASSACU, oUnit.UnitId) then
                                tTeamData[aiBrain.M28Team][subrefbEnemyGettingFabsOrRAS] = true
                            elseif EntityCategoryContains(M28UnitInfo.refCategorySatellite, oUnit.UnitId) then
                                ForkThread(EnemyNovaxSatelliteMonitor, oUnit, aiBrain.M28Team)
                            end

                            --If enemy hasnt built omni yet check whether this is omni
                            if not(tTeamData[aiBrain.M28Team][subrefbEnemyBuiltOmni]) and EntityCategoryContains(M28UnitInfo.refCategoryT3Radar, oUnit.UnitId) and not(oUnit:GetAIBrain().M28Team == aiBrain.M28Team) then
                                tTeamData[aiBrain.M28Team][subrefbEnemyBuiltOmni] = true
                            end


                            --Track enemy big threats
                            if bDebugMessages == true then LOG(sFunctionRef..': Is unit a big threat category='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryBigThreatCategories, oUnit.UnitId))..'; Unit DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Unit indirect range='..(oUnit[M28UnitInfo.refiIndirectRange] or 'nil')..'; Is unit PD or land combat='..tostring(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryPD)..'; Unit build cost mass='..oUnit[M28UnitInfo.refiUnitMassCost]) end
                            if EntityCategoryContains(M28UnitInfo.refCategoryBigThreatCategories, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will try and add unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to big threat table, aiBrain='..(aiBrain.Nickname or 'nil')..' team='..(aiBrain.M28Team or 'nil')) end
                                AddUnitToBigThreatTable(aiBrain.M28Team, oUnit)
                            elseif (oUnit[M28UnitInfo.refiDFRange] or 0) > 50 and ((oUnit[M28UnitInfo.refiDFRange] or 0) > 80 or EntityCategoryContains(M28UnitInfo.refCategoryPD, oUnit.UnitId)) and EntityCategoryContains(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryPD, oUnit.UnitId) and (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) >= 600 then
                                AddUnitToLongRangeThreatTable(oUnit, aiBrain.M28Team, true)
                            end

                            --Add long range enemy T2 arti
                            if oUnit[M28UnitInfo.refiCombatRange] > 100 and EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) then
                                RecordEnemyT2ArtiAgainstNearbyZones(aiBrain.M28Team, oUnit)
                            end

                            --Track potential TML targets and TMD for decision on whether to build TML (TML target selection uses more precise approach
                            if EntityCategoryContains(M28UnitInfo.refCategoryTMD * categories.STRUCTURE, oUnit.UnitId) then
                                local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                                if iPlateauOrZero > 0 and iLandOrWaterZone > 0 then
                                    local tLZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][aiBrain.M28Team]
                                    table.insert(tLZTeamData[M28Map.subreftoEnemyTMD], oUnit)
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryProtectFromTML * categories.STRUCTURE, oUnit.UnitId) then
                                local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                                if iPlateauOrZero > 0 and iLandOrWaterZone > 0 then
                                    local tLZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][aiBrain.M28Team]
                                    table.insert(tLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets], oUnit)
                                    M28Building.RecordTMLAndTMDForEnemyUnitTargetJustDetected(oUnit, aiBrain.M28Team)
                                end
                            end

                            --Cloaked units
                            if EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oUnit.UnitId) then
                                if oUnit:HasEnhancement('CloakingGenerator') then
                                    M28Events.CloakedUnitIdentified(oUnit)
                                else
                                    local oBP = oUnit:GetBlueprint()
                                    if oBP.Enhancements and oBP.EnhancementPresetAssigned.Enhancements then
                                        for iCurUpgrade, sCurUpgrade in oBP.EnhancementPresetAssigned.Enhancements do
                                            if sCurUpgrade == 'CloakingGenerator' then
                                                M28Events.CloakedUnitIdentified(oUnit)
                                                break
                                            end
                                        end
                                    end
                                end
                            end

                            --best enemy df range
                            local iPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, oUnit:GetPosition())
                            if iPlateau then
                                local iTeam = aiBrain.M28Team
                                if not(tTeamData[iTeam][refiHighestEnemyDFRangeByPlateau]) then tTeamData[iTeam][refiHighestEnemyDFRangeByPlateau] = {} end
                                tTeamData[iTeam][refiHighestEnemyDFRangeByPlateau][iPlateau] = math.max((tTeamData[iTeam][refiHighestEnemyDFRangeByPlateau][iPlateau] or 0), (oUnit[M28UnitInfo.refiDFRange] or 0))
                            end

                        else
                            --Campaign neutral units
                            --Allied unit - dont record if it isnt owned by M28AI brain (so we dont control allied non-M28 units) or is owned by a different team
                            if not(oUnit:GetAIBrain().M28AI) or not(oUnit:GetAIBrain().M28Team == aiBrain.M28Team) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Unit belongs to a non-M28 ally or non-hostile brain so wont record, with some exceptions; iTeam='..(aiBrain.M28Team or 'nil')) end
                                bIgnore = true
                                if M28Map.bIsCampaignMap then
                                    local bAddToNeutralTable = true
                                    if M28Utilities.IsTableEmpty(tTeamData[aiBrain.M28Team][reftoCampaignNeutralUnitsNotRecorded]) == false then
                                        for iRecorded, oRecorded in tTeamData[aiBrain.M28Team][reftoCampaignNeutralUnitsNotRecorded] do
                                            if oRecorded == oUnit then
                                                bAddToNeutralTable = false
                                                break
                                            end
                                        end
                                    end
                                    if bAddToNeutralTable then
                                        table.insert(tTeamData[aiBrain.M28Team][reftoCampaignNeutralUnitsNotRecorded], oUnit)
                                    end
                                end
                                --Track non-M28 teammate units
                                if EntityCategoryContains(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                                    local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, aiBrain.M28Team)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Is tLZOrWZTeamData nil='..tostring(tLZOrWZTeamData == nil)..'; refiNonM28TeammateMexCount='..(tLZOrWZTeamData[M28Map.refiNonM28TeammateMexCount] or 'nil')) end
                                    if tLZOrWZTeamData then
                                        if not(oUnit[M28UnitInfo.reftiTeamsRecordedAsNonM28Ally]) then oUnit[M28UnitInfo.reftiTeamsRecordedAsNonM28Ally] = {} end
                                        table.insert(oUnit[M28UnitInfo.reftiTeamsRecordedAsNonM28Ally], aiBrain.M28Team)
                                        if EntityCategoryContains(M28UnitInfo.refCategoryFactory, oUnit.UnitId) then
                                            tLZOrWZTeamData[M28Map.refiNonM28TeammateFactoryCount] = (tLZOrWZTeamData[M28Map.refiNonM28TeammateFactoryCount] or 0) + 1
                                        elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                                            tLZOrWZTeamData[M28Map.refiNonM28TeammateMexCount] = (tLZOrWZTeamData[M28Map.refiNonM28TeammateMexCount] or 0) + 1

                                            if bDebugMessages == true then
                                                local iPlateau, iZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                                                LOG(sFunctionRef..': Recorded teammate as having a mex in this LZ, tLZTeamData[M28Map.refiNonM28TeammateMexCount] after update='..tLZOrWZTeamData[M28Map.refiNonM28TeammateMexCount]..'; iPlateau='..iPlateau..'; iZone='..iZone)
                                            end
                                        end
                                    end
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryPD, oUnit.UnitId) then
                                    local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, aiBrain.M28Team)
                                    if not(tLZOrWZTeamData[M28Map.subreftoTeammateFixedDF]) then tLZOrWZTeamData[M28Map.subreftoTeammateFixedDF] = {} end
                                    table.insert(tLZOrWZTeamData[M28Map.subreftoTeammateFixedDF], oUnit)
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryStructureAA, oUnit.UnitId) then
                                    local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, aiBrain.M28Team)
                                    if not(tLZOrWZTeamData[M28Map.subreftoTeammateFixedAA]) then tLZOrWZTeamData[M28Map.subreftoTeammateFixedAA] = {} end
                                    table.insert(tLZOrWZTeamData[M28Map.subreftoTeammateFixedAA], oUnit)
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel + categories.TECH3 * M28UnitInfo.refCategoryNavalSurface, oUnit.UnitId) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will record experimental level or T3 navy unit if it isnt compelte yet, Fraction complete='..oUnit:GetFractionComplete()) end
                                    if oUnit:GetFractionComplete() < 1 then
                                        local bAlreadyRecorded = false
                                        local iTeam = aiBrain.M28Team
                                        if M28Utilities.IsTableEmpty(tTeamData[iTeam][reftoNonM28ConstructingExpAndT3Navy]) == false then
                                        elseif not(tTeamData[iTeam][reftoNonM28ConstructingExpAndT3Navy]) then tTeamData[iTeam][reftoNonM28ConstructingExpAndT3Navy] = {}
                                        end
                                        if not(bAlreadyRecorded) then
                                            table.insert(tTeamData[iTeam][reftoNonM28ConstructingExpAndT3Navy], oUnit)
                                            oUnit[M28UnitInfo.refbNonM28ExpConstruction] = true
                                        end
                                    end
                                end


                            else
                                --M28 ally specific

                                --Air staging - clear any engineers in other zones constructing them if we dont ahve T3 air
                                if EntityCategoryContains(M28UnitInfo.refCategoryAirStaging, oUnit.UnitId) and tTeamData[oUnit:GetAIBrain().M28Team][subrefiHighestFriendlyAirFactoryTech] < 3 then
                                    local iTeam = oUnit:GetAIBrain().M28Team
                                    if bDebugMessages == true then LOG(sFunctionRef..': Building air staging, and dont ahve T3 air, brain count='..tTeamData[iTeam][subrefiActiveM28BrainCount]..'; iTeam='..iTeam) end
                                    if tTeamData[iTeam][subrefiActiveM28BrainCount] > 1 then
                                        local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                                        for iBrain, oBrain in tTeamData[iTeam][subreftoFriendlyActiveM28Brains] do
                                            local tStartLZData, tStartLZTeamData = M28Map.GetLandOrWaterZoneData(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], true, iTeam)
                                            if not(tStartLZTeamData == tLZTeamData) then
                                                if M28Utilities.IsTableEmpty(tStartLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                                                    local bHaveAirStagingUnderConstruction = false
                                                    local tAirStaging = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirStaging, tStartLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                                    if M28Utilities.IsTableEmpty(tAirStaging) == false then
                                                        for iAirStaging, oAirStaging in tAirStaging do
                                                            if M28UnitInfo.IsUnitValid(oAirStaging) and oAirStaging:GetFractionComplete() < 1 then
                                                                bHaveAirStagingUnderConstruction = true
                                                                break
                                                            end
                                                        end
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': oBrain='..oBrain.Nickname..'; bHaveAirStagingUnderConstruction='..tostring(bHaveAirStagingUnderConstruction)) end
                                                    if not(bHaveAirStagingUnderConstruction) then
                                                        local tEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tStartLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of units of cateogyr empty for brain '..oBrain.Nickname..'='..tostring(M28Utilities.IsTableEmpty(tEngineers))..'; oUnit fraction complete='..oUnit:GetFractionComplete()) end
                                                        if M28Utilities.IsTableEmpty(tEngineers) == false then
                                                            local toEngineersToClear = {}
                                                            for iEngineer, oEngineer in tEngineers do
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Engineer action='..(oEngineer[M28Engineer.refiAssignedAction] or 'nil')..'; Engineer state='..M28UnitInfo.GetUnitState(oEngineer)) end
                                                                if M28UnitInfo.IsUnitValid(oEngineer) and oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionBuildAirStaging then
                                                                    if not(oEngineer:IsUnitState('Building')) and not(oEngineer:IsUnitState('Repairing')) then
                                                                        table.insert(toEngineersToClear, oEngineer)
                                                                    else
                                                                        local oFocus = oEngineer:GetFocusUnit()
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Focus unit is '..(oFocus.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oFocus) or 'nil')) end
                                                                        if bDebugMessages == true and oFocus then LOG(sFunctionRef..': oFocus fraction complete='..oFocus:GetFractionComplete()) end
                                                                        if not(M28UnitInfo.IsUnitValid(oFocus)) or oFocus:GetFractionComplete() == 0 then
                                                                            table.insert(toEngineersToClear, oEngineer)
                                                                        end

                                                                    end
                                                                end
                                                            end
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of engineers to clear empty='..tostring(M28Utilities.IsTableEmpty(toEngineersToClear))) end
                                                            if M28Utilities.IsTableEmpty(toEngineersToClear) == false then
                                                                for iEngineer, oEngineer in toEngineersToClear do
                                                                    M28Orders.IssueTrackedClearCommands(oEngineer)
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            --Update intel coverage for units being constructed and/or allied units (in addition when a radar/sonar is constructed it will also trigger the below if it hasnt already run as a redundancy)
                            if EntityCategoryContains(M28UnitInfo.refCategoryRadar, oUnit.UnitId) then M28Land.UpdateZoneIntelForRadar(oUnit)
                            elseif EntityCategoryContains(M28UnitInfo.refCategorySonar, oUnit.UnitId) then M28Navy.UpdateZoneIntelForSonar(oUnit)
                            end
                        end
                    end
                elseif bDebugMessages == true then
                    LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has already been considered (considered='..tostring(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team] or false)..')')
                end


                if bIgnore or EntityCategoryContains(M28UnitInfo.refCategoryWall + categories.UNSELECTABLE + categories.UNTARGETABLE + categories.BENIGN, oUnit.UnitId) then
                    --Do nothing
                    if bDebugMessages == true then LOG(sFunctionRef..': Unit is insignificant so will ignore, Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is civilian brain='..tostring(M28Conditions.IsCivilianBrain(oUnit:GetAIBrain()))..'; Build cost mass='..oUnit[M28UnitInfo.refiUnitMassCost]) end
                    --Civilian units hopefully show up here - consider adding to table of units to reclaim; owever dont reclaim if can build from a factory as we might want to capture it instead
                    if M28Conditions.IsCivilianBrain(oUnit:GetAIBrain()) and EntityCategoryContains(categories.RECLAIMABLE + categories.SELECTABLE - categories.BUILTBYTIER3FACTORY, oUnit.UnitId) and (oUnit[M28UnitInfo.refiUnitMassCost] or M28UnitInfo.GetUnitMassCost(oUnit)) >= 25 then
                        if not(M28Map.bIsCampaignMap) or (not(tTeamData[aiBrain.M28Team][rebTeamOnlyHasCampaignAI]) and not(oUnit[M28UnitInfo.refbIsReclaimTarget] == false)) then
                            local tUnitLZData, tUnitLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, aiBrain.M28Team)
                            local bIncluded = false
                            if not(tUnitLZTeamData[M28Map.subreftoUnitsToReclaim]) then tUnitLZTeamData[M28Map.subreftoUnitsToReclaim] = {}
                            else
                                for iReclaimUnit, oReclaimUnit in tUnitLZTeamData[M28Map.subreftoUnitsToReclaim] do
                                    if oReclaimUnit == oUnit then bIncluded = true break end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to include unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' in table of units to reclaim for team '..aiBrain.M28Team) end
                            if not(bIncluded) then
                                table.insert(tUnitLZTeamData[M28Map.subreftoUnitsToReclaim], oUnit)
                                local bTeamRecorded = false
                                if not(oUnit[M28UnitInfo.refiTeamsWithThisAsReclaimTarget]) then oUnit[M28UnitInfo.refiTeamsWithThisAsReclaimTarget] = {}
                                else
                                    for iEntry, iRecordedTeam in oUnit[M28UnitInfo.refiTeamsWithThisAsReclaimTarget] do
                                        if iRecordedTeam == aiBrain.M28Team then
                                            bTeamRecorded = true
                                            break
                                        end
                                    end
                                end
                                if not(bTeamRecorded) then
                                    table.insert(oUnit[M28UnitInfo.refiTeamsWithThisAsReclaimTarget], aiBrain.M28Team)
                                end

                            end
                        end
                    end
                else

                    if not(bAlreadyUpdatedPosition) then
                        UpdateUnitLastKnownPosition(aiBrain, oUnit, true)
                        if IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()) and aiBrain.M28AI then UpdateEnemyTechTracking(aiBrain.M28Team, oUnit) end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': aiBrain '..aiBrain.Nickname..' is Considering how to assign unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that is owned by brain '..oUnit:GetAIBrain().Nickname..' at time '..GetGameTimeSeconds()..'; bPreviouslyConsidered='..tostring(bPreviouslyConsidered or false)) end


                    --Air units - always assign to air groups, and also to land zones if in one
                    if EntityCategoryContains(M28UnitInfo.refCategoryAllAir - M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                        if not(bPreviouslyConsidered) then
                            M28Air.RecordNewAirUnitForTeam(aiBrain.M28Team, oUnit)
                        end
                        if bAlreadyUpdatedPosition then
                            --Re-check the plateau and land/water zone
                            local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                            local bIsEnemyAirUnit
                            if aiBrain.M28Team == oUnit:GetAIBrain().M28Team then bIsEnemyAirUnit = false else bIsEnemyAirUnit = true end
                            if  (iLandOrWaterZone or 0) > 0 then
                                if iPlateauOrZero == 0 then
                                    --Water zone
                                    AddUnitToWaterZoneForBrain(aiBrain, oUnit, iLandOrWaterZone, bIsEnemyAirUnit)
                                else
                                    AddUnitToLandZoneForBrain(aiBrain, oUnit, iPlateauOrZero, iLandOrWaterZone, bIsEnemyAirUnit)
                                end

                                --Presumably air unit has fallen out of a land zone - add to table of enemy air without a LZ
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Failed to find a plateau or zone to position '..repru(oUnit:GetPosition())..' for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                if not(aiBrain.M28Team == oUnit:GetAIBrain().M28Team) then --redundancy, - hopefully shouldnt get to this point if this isnt the case
                                    M28Utilities.ErrorHandler('Obsolete code, wasnt expecting it to be used, unless fighting RNG and they have offmap units')
                                    M28Air.RecordEnemyAirUnitWithNoZone(aiBrain.M28Team, oUnit)
                                end
                            end
                        end
                    else
                        if oUnit:IsUnitState('Attached') then
                            --Try reassigning in a bit
                            ForkThread(DelayedUnitPlateauAssignment, aiBrain, oUnit, 5, bAlreadyUpdatedPosition, true)
                        else
                            --Amphibious, hover and naval surface units = check if in water before checking if in land
                            local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnit:GetPosition())
                            local iWaterZone = M28Map.tWaterZoneBySegment[iSegmentX][iSegmentZ]
                            if iWaterZone > 0 and EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will add unit to water zone') end
                                AddUnitToWaterZoneForBrain(aiBrain, oUnit, iWaterZone)
                            else
                                local iPlateau, iLandZone
                                if EntityCategoryContains(categories.LAND * categories.MOBILE, oUnit.UnitId) then
                                    iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                                else
                                    iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                                end
                                if bDebugMessages == true then
                                    LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by brain '..oUnit:GetAIBrain().Nickname..' has iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; Will draw unit position if it has no plateau or zone. Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; iWaterZone='..(iWaterZone or 'nil'))
                                    if not(iPlateau) then
                                        M28Utilities.DrawLocation(oUnit:GetPosition())
                                    end
                                end
                                if (iLandZone or 0) > 0 then
                                    --Unit is in a land zone so assign it to a land zone instead of a pond
                                    if not(iPlateau) then
                                        local iAltLandZone
                                        iPlateau, iAltLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                                        if (iAltLandZone or 0) > 0 then iLandZone = iAltLandZone end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Adding unit to iLandZone '..iLandZone..' for plateau '..iPlateau..' and team '..aiBrain.M28Team) end
                                    AddUnitToLandZoneForBrain(aiBrain, oUnit, iPlateau, iLandZone)
                                elseif iPlateau > 0 then
                                    --Is the unit in a water zone?
                                    if iWaterZone > 0 then
                                        AddUnitToWaterZoneForBrain(aiBrain, oUnit, iWaterZone)
                                    else
                                        --Does the unit already have orders, and is a non-naval unit? If so then wait and try to reassign it in a bit, as e.g. may be a land unit that can path across water so has taken a shortcut
                                        if bDebugMessages == true then LOG(sFunctionRef..': Unit doesnt have al and or water zone, is this a non amphibious or hover naval unit='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAllNavy - categories.AMPHIBIOUS - categories.HOVER, oUnit.UnitId))..'; Nav utils naval label for unit position='..(NavUtils.GetLabel(M28Map.refPathingTypeNavy, oUnit:GetPosition()) or 'nil')) end
                                        if EntityCategoryContains(M28UnitInfo.refCategoryAllNavy, oUnit.UnitId) and (EntityCategoryContains(M28UnitInfo.refCategoryAllNavy - categories.AMPHIBIOUS - categories.HOVER, oUnit.UnitId) or (NavUtils.GetLabel(M28Map.refPathingTypeNavy, oUnit:GetPosition()) or 0) > 0) then
                                            local iCurPond = NavUtils.GetLabel(M28Map.refPathingTypeNavy, oUnit:GetPosition())
                                            if bDebugMessages == true then LOG(sFunctionRef..': Unit pond at cur position='..(NavUtils.GetLabel(M28Map.refPathingTypeNavy, oUnit:GetPosition()) or 'nil')) end
                                            if (iCurPond or 0) > 0 then
                                                --Are in valid pond, find nearest valid water zone and add this segment to that water zone
                                                iWaterZone = nil --redundancy
                                                --To find nearby water zone - cycle through a hollow box
                                                --First to the top row and bottom row
                                                for iAdjustBase = 1, 10 do
                                                    for iCurSegmentX = iSegmentX - iAdjustBase, iSegmentX + iAdjustBase, 1 do
                                                        for iCurSegmentZ = iSegmentZ - iAdjustBase, iSegmentZ + iAdjustBase, iAdjustBase * 2 do
                                                            if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                                                                if M28Map.tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] then iWaterZone = M28Map.tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] break end
                                                            end
                                                        end
                                                        if iWaterZone then break end
                                                    end
                                                    if iWaterZone then break end
                                                    --Then do the left and right row (excl corners which ahve already done per the above)
                                                    for iCurSegmentX = iSegmentX - iAdjustBase, iSegmentX + iAdjustBase, iAdjustBase * 2 do
                                                        for iCurSegmentZ = iSegmentZ - iAdjustBase + 1, iSegmentZ + iAdjustBase - 1, 1 do
                                                            if iCurSegmentX >= 0 and iCurSegmentZ >= 0 then
                                                                if M28Map.tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] then iWaterZone = M28Map.tWaterZoneBySegment[iCurSegmentX][iCurSegmentZ] break end
                                                            end
                                                        end
                                                        if iWaterZone then break end
                                                    end
                                                    if iWaterZone then break end
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': Tried searching nearby segments for water zone, iWaterZone='..(iWaterZone or 'nil')) end
                                                if (iWaterZone or 0) > 0 then
                                                    M28Map.AddSegmentToWaterZone(iCurPond, iWaterZone, iSegmentX, iSegmentZ)
                                                    AddUnitToWaterZoneForBrain(aiBrain, oUnit, iWaterZone)
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will add unit to water zone '..iWaterZone) end
                                                else
                                                    M28Map.ConsiderUnitAddingPositionToWaterZone(oUnit)
                                                    M28Utilities.ErrorHandler('Unable to find nearby water zone despite having a valid pond, unitID='..oUnit.UnitId..'; will try reassigning in a bit')
                                                    ForkThread(DelayedUnitPlateauAssignment, aiBrain, oUnit, 10, bAlreadyUpdatedPosition, true)
                                                end
                                            else
                                                --Reassign in a bit
                                                M28Map.ConsiderUnitAddingPositionToWaterZone(oUnit)
                                                ForkThread(DelayedUnitPlateauAssignment, aiBrain, oUnit, 10, bAlreadyUpdatedPosition, true)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have a non amphibious naval unit that isnt in a recognised pond, so will try to reassign in a bit') end
                                            end
                                        else
                                            --Reassign in a bit if we own it
                                            if bDebugMessages == true then LOG(sFunctionRef..': Unit has a plateau but not a LZ, and isnt a naval unit, will wait and try and reassign if this is the first time, bAlreadyTriedReassignment='..tostring(bAlreadyTriedReassignment or false)..'; aiBrain team='..aiBrain.M28Team..'; Units aibrain team='..oUnit:GetAIBrain().M28Team..'; aiBrain.M28AI='..tostring((aiBrain.M28AI or false))) end
                                            if not(bAlreadyTriedReassignment) or not(aiBrain.M28Team == oUnit:GetAIBrain().M28Team) or not(aiBrain.M28AI) or not(oUnit:GetAIBrain().M28AI) then
                                                ForkThread(DelayedUnitPlateauAssignment, aiBrain, oUnit, 20, bAlreadyUpdatedPosition, true)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will retry in a bit') end
                                            else
                                                --Have an M28AI trying to update date for an M28AI owned unit in the same team as it, and we have already tried reassigning it after a 20 tick delay; if the unit has no orders then give it new orders
                                                M28Orders.UpdateRecordedOrders(oUnit)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Refreshed unit orders, order count='..oUnit[M28Orders.refiOrderCount]) end
                                                if oUnit[M28Orders.refiOrderCount] > 0 then
                                                    ForkThread(DelayedUnitPlateauAssignment, aiBrain, oUnit, 20, bAlreadyUpdatedPosition, true)
                                                    --If the unit is underwater and its last order was attack-move and it isnt a skirmisher then switch to being move
                                                    if not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId)) and oUnit[M28UnitInfo.refiDFRange] > 0 then
                                                        local tLastOrder = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]]
                                                        if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAggressiveMove then
                                                            M28Orders.IssueTrackedMove(oUnit, { tLastOrder[M28Orders.subreftOrderPosition][1], tLastOrder[M28Orders.subreftOrderPosition][2], tLastOrder[M28Orders.subreftOrderPosition][3] }, 1, false, 'UWMNA', false)
                                                        end
                                                    end
                                                else
                                                    --Give unit new orders - move to the nearest land zone (this was added as a redundacny before logic for water zones was incorporated - may not be necessary now
                                                    local iNearestLandZone
                                                    local iNearestDist = 100000
                                                    local iCurDist
                                                    for iLandZone, tLZData in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones] do
                                                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                                                        if iCurDist < iNearestDist then
                                                            iNearestDist = iCurDist
                                                            iNearestLandZone = iLandZone
                                                        end
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Tried looking for a nearby LZ, nearest LZ='..(iNearestLandZone or 'nil')) end
                                                    if iNearestLandZone then
                                                        M28Orders.IssueTrackedMove(oUnit, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iNearestLandZone][M28Map.subrefMidpoint], 1, true, 'StuckMLZ'..iNearestLandZone)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Told unit to move to the midpoint of the nearest LZ after any current orders, will assign to that land zone as well') end
                                                        AddUnitToLandZoneForBrain(aiBrain, oUnit, iPlateau, iNearestLandZone)
                                                    else
                                                        M28Utilities.ErrorHandler('Couldnt find a land zone for plateau '..iPlateau..' and unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
                                                        ForkThread(DelayedUnitPlateauAssignment, aiBrain, oUnit, 20, bAlreadyUpdatedPosition, true)
                                                    end
                                                end
                                            end
                                        end
                                    end

                                else
                                    --No valid plateau or land zone for unit so likely a pathing error; have unit move randomly if we are updating for the owner
                                    ForkThread(HaveGroundUnitWithNoPlateau, aiBrain, oUnit)
                                end
                            end
                        end
                    end
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Have unit that cant take damage or be killed so ignoring, unit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' owned by '..(oUnit:GetAIBrain().Nickname or 'nil')..'; reprs='..reprs(oUnit)) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function HaveGroundUnitWithNoPlateau(oTrackingBrain, oUnit)
    --Give new orders to the unit if it is an M28 unit; aiBrain should be on the same team and is the brain that we will be updating the plateau and LZ tracking for
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'HaveGroundUnitWithNoPlateau'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local refsTrackingVariable = 'M28ActiveNoPlateau'..oTrackingBrain:GetArmyIndex()
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28UnitInfo.IsUnitValid(oUnit) and not(oUnit[refsTrackingVariable]) then --Brain check is a redundancy
        if bDebugMessages == true then
            LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' doesnt appear to have a valid location, will monitor until it has a valid location; will draw unit cur position')
            M28Utilities.DrawLocation(oUnit:GetPosition())
        end
        oUnit[refsTrackingVariable] = true
        local iBaseAngle, iBaseDistance
        local tPotentialTempMoveLocation
        local iPlateauToTryAndFind
        local sPathing = M28UnitInfo.GetUnitPathingType
        local bConsiderMoving = false
        local iTeam = oTrackingBrain.M28Team
        if oUnit:GetAIBrain().M28AI then bConsiderMoving = true end
        while M28UnitInfo.IsUnitValid(oUnit) do
            if (NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oUnit:GetPosition()) or 0) > 0 then
                --Check we will get either al and or water zone if using the same approach that assignunittolandzoneorpond uses:
                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                if iPlateau and iLandZone and iLandZone > 0 then
                    break
                else
                    --Do we have a water zone?
                    local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnit:GetPosition())
                    local iWaterZone = M28Map.tWaterZoneBySegment[iSegmentX][iSegmentZ]
                    if iWaterZone then
                        break
                    end
                end
            end
            --iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
            if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' postiion='..repru(oUnit:GetPosition())..'; Plateau label='..NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oUnit:GetPosition()) or 0) end
            --if iPlateau > 0 then break end
            if bConsiderMoving then
                M28Orders.UpdateRecordedOrders(oUnit)
                if not(oUnit[M28Orders.reftiLastOrders]) then
                    --Give a move order to a random place
                    iBaseAngle = math.random(1, 360)
                    iBaseDistance = math.random(5, 10)
                    iPlateauToTryAndFind = (NavUtils.GetLabel(sPathing, oUnit:GetPosition()) or oUnit[M28Land.refiCurrentAssignmentPlateauAndLZ][1] or oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1]) --not as restrictive as terrain label
                    if not((iPlateauToTryAndFind or 0) > 0) then iPlateauToTryAndFind = nil end
                    for iAngleAdjust = 0, 45, 360 do
                        tPotentialTempMoveLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), iBaseAngle + iAngleAdjust, iBaseDistance, true, false, true)

                        if (iPlateauToTryAndFind and NavUtils.GetLabel(sPathing, tPotentialTempMoveLocation) == iPlateauToTryAndFind) or (not(iPlateauToTryAndFind) and NavUtils.GetLabel(sPathing, tPotentialTempMoveLocation)) then
                            break --Use this as the move location
                        end
                    end
                    M28Orders.IssueTrackedMove(oUnit, tPotentialTempMoveLocation, 3, false, 'RandPath')

                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        --Have a valid plateau so stop tracking and send for reassignment
        oUnit[refsTrackingVariable] = false
        AssignUnitToLandZoneOrPond(oTrackingBrain, oUnit)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


--[[function UpdateUnitPond(oUnit, iM28TeamUpdatingFor, bIsEnemy, iPondRefOverride)
    --Check the unit's pond; ignore this for non-M28 friendly units
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateUnitPond'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, bIsEnemy='..tostring((bIsEnemy or false))..'; Unit brain index='..oUnit:GetAIBrain():GetArmyIndex()..'; Unit assigned pond='..(oUnit[refiAssignedPond] or 'nil')..'; Contains fixed pond category='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryPondFixedCategory, oUnit.UnitId))) end

    if bIsEnemy or (oUnit:GetAIBrain().M28AI and (not(oUnit[refiAssignedPond]) or not(EntityCategoryContains(M28UnitInfo.refCategoryPondFixedCategory, oUnit.UnitId)))) then --and not(oUnit[reftisubrefsUpdatedFor][iM28TeamUpdatingFor])) then
        local iCurPond = iPondRefOverride or M28MapInfo.GetSegmentGroupOfLocation(M28Map.refPathingTypeNavy, oUnit:GetPosition())
        if bDebugMessages == true then LOG(sFunctionRef..': bIsEnemy='..tostring(bIsEnemy)..'; Updating for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iPondRefOverride='..(iPondRefOverride or 'nil')..'; iCurPond='..(iCurPond or 'nil')..'; oUnit[refiAssignedPond]='..(oUnit[refiAssignedPond] or 'nil')) end --LOG('iCurPond pre adj='..(iCurPond or 'nil'))
        --if tPondDetails[iCurPond] then LOG('Pond size='..(tPondDetails[iCurPond][subrefiSegmentCount] or 'nil')) end
        if not(tPondDetails[iCurPond]) or (tPondDetails[iCurPond][subrefiSegmentCount] or 0) <= iMinPondSize then
            --If have a naval unit that isnt amphibious then update pathing
            if bDebugMessages == true then LOG(sFunctionRef..': Dont have details for the pond recorded, if its a naval unit then will check for if there is a pond nearby') end
            if EntityCategoryContains(categories.NAVAL * categories.MOBILE - categories.HOVER - categories.AMPHIBIOUS - categories.AIR - categories.LAND, oUnit.UnitId) then
                iCurPond = CheckForPondNearNavalUnit(oUnit)
                if bDebugMessages == true then LOG(sFunctionRef..': iCurPond after checking for pond near naval unit='..iCurPond) end
            else
                iCurPond = 0
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iCurPond after updating for naval unit and min pond size='..(iCurPond or 'nil')..'; oUnit[refiAssignedPond]='..(oUnit[refiAssignedPond] or 'nil')) end
        if iCurPond > 0 then
            oUnit[M28UnitInfo.reftLastKnownPosition] = {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]}
            if bDebugMessages == true then LOG(sFunctionRef..': Updated unit last known position') end
        end
        if oUnit[refiAssignedPond] then
            if not(iCurPond == oUnit[refiAssignedPond]) then
                if bDebugMessages == true then LOG('Removing unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from old pond '..(oUnit[refiAssignedPond] or 'nil')..' and adding to new pond iCurPond='..iCurPond) end
                RemoveUnitFromAssignedPond(oUnit)
                AddUnitToPond(oUnit, iCurPond, iM28TeamUpdatingFor, bIsEnemy)
            elseif not(oUnit[reftisubrefsUpdatedFor][iM28TeamUpdatingFor]) then
                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to pond '..iCurPond) end
                AddUnitToPond(oUnit, iCurPond, iM28TeamUpdatingFor, bIsEnemy)
            end
        else
            if iCurPond > 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to pond '..iCurPond) end
                AddUnitToPond(oUnit, iCurPond, iM28TeamUpdatingFor, bIsEnemy)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end--]]

function UpdateFactionBlueprintBlacklist(iLandSubteam)
    --Considers any blueprint specific overrides (only supports the 4 core factions and not modded units since blueprint values are hardcoded)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateFactionBlueprintBlacklist'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    tLandSubteamData[iLandSubteam][subrefBlueprintBlacklist] = {}
    local bConsiderScoutRestrictions = false
    if tLandSubteamData[iLandSubteam][refbConsideredScoutFactionRestrictions] then bConsiderScoutRestrictions = true
    else
        local iLandScoutCount = 0
        local iBrainCount = 0
        for iBrain, oBrain in tLandSubteamData[iLandSubteam][subreftoFriendlyM28Brains] do
            iLandScoutCount = iLandScoutCount + M28Conditions.GetLifetimeBuildCount(oBrain, M28UnitInfo.refCategoryLandScout)
            iBrainCount = iBrainCount + 1
        end
        if iLandScoutCount > iBrainCount * 4 then
            bConsiderScoutRestrictions = true
        end
    end
    if bConsiderScoutRestrictions then
        --Land scouts
        if M28Conditions.HaveFactionTech(iLandSubteam, M28Factory.refiFactoryTypeLand, M28UnitInfo.refFactionAeon, 1) then
            --Only want Aeon land scouts
            tLandSubteamData[iLandSubteam][subrefBlueprintBlacklist]['uel0101'] = true --UEF land scout
            tLandSubteamData[iLandSubteam][subrefBlueprintBlacklist]['url0101'] = true --Cybran land scout
            tLandSubteamData[iLandSubteam][subrefBlueprintBlacklist]['xsl0101'] = true --Seraphim land scout
        elseif M28Conditions.HaveFactionTech(iLandSubteam, M28Factory.refiFactoryTypeLand, M28UnitInfo.refFactionCybran, 1) then
            --If have cybran tech then prioritise this
            tLandSubteamData[iLandSubteam][subrefBlueprintBlacklist]['uel0101'] = true --UEF land scout
            tLandSubteamData[iLandSubteam][subrefBlueprintBlacklist]['xsl0101'] = true --Seraphim land scout
        elseif M28Conditions.HaveFactionTech(iLandSubteam, M28Factory.refiFactoryTypeLand, M28UnitInfo.refFactionUEF, 1) then
            tLandSubteamData[iLandSubteam][subrefBlueprintBlacklist]['xsl0101'] = true --Seraphim land scout
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, blacklist for subteam '..iLandSubteam..' = '..repru(tLandSubteamData[iLandSubteam][subrefBlueprintBlacklist])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckForSubteamFactoryChange(oUnit, bJustBuiltNotDied)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckForSubteamFactoryChange'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bJustBuiltNotDied='..tostring(bJustBuiltNotDied or false)..'; Time='..GetGameTimeSeconds()) end
    if EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories + M28UnitInfo.refCategoryQuantumGateway, oUnit.UnitId) then
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
        local iSubteam = oUnit:GetAIBrain().M28LandSubteam
        if iPlateau == tLandSubteamData[iSubteam][subrefiLandCorePlateau] and NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition()) == tLandSubteamData[iSubteam][subrefiLandCoreIsland] then
            local iFactoryType = M28UnitInfo.GetFactoryType(oUnit)
            local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oUnit)
            local iFactoryFaction = M28UnitInfo.GetUnitFaction(oUnit)


            local bChangedFactoryTech = false
            --Do we have any higher tech than this?
            local bHaveHigherTech = false
            if iFactoryTechLevel < 3 then
                for iHigherTech = iFactoryTechLevel + 1, 2 do
                    if (tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iHigherTech] or 0) > 0 then
                        bHaveHigherTech = true
                        break
                    end
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have had a factory tech change, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bJustBuiltNotDied='..tostring(bJustBuiltNotDied or false)..'; iFactoryType='..iFactoryType..'; iPlateau='..iPlateau..'; IslandRef='..NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition())..'; iFactoryTechLevel='..iFactoryTechLevel..'; iFactoryFaction='..iFactoryFaction..'; iSubteam='..iSubteam..'; tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech]='..repru(tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech])) end

            if bJustBuiltNotDied then
                --Check if need to add the unit to the subteam table
                if (tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] or 0) <= 0 then
                    if not(bHaveHigherTech) then bChangedFactoryTech = true end
                    tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] = 1
                else
                    tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] = tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] + 1
                end
            else
                if tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] == 1 then
                    if not(bHaveHigherTech) then bChangedFactoryTech = true end
                end
                tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] = math.max(0, tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] - 1)
            end

            if bChangedFactoryTech then
                UpdateFactionBlueprintBlacklist(iSubteam)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateTeamHighestAndLowestFactories(iM28Team)
    --Called whenever an M28 brain gains or loses an HQ factory; for convenience will update all factory types (even thoguh marginally more efficient to only update the type in question)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateTeamHighestAndLowestFactories'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] = 3
    tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] = 3
    tTeamData[iM28Team][subrefiLowestFriendlyNavalFactoryTech] = 3
    tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] = 0
    tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] = 0
    tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech] = 0

    if bDebugMessages == true then LOG(sFunctionRef..': Lowest friendly land fac start point (will decrease to lower of this and actual tech)='..tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]) end

    for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
        if not(oBrain[M28Economy.refiOurHighestFactoryTechLevel]) then --saves having to define the variables earlier
            oBrain[M28Economy.refiOurHighestFactoryTechLevel] = 0
            oBrain[M28Economy.refiOurHighestLandFactoryTech] = 0
            oBrain[M28Economy.refiOurHighestAirFactoryTech] = 0
            oBrain[M28Economy.refiOurHighestNavalFactoryTech] = 0
        end
        if bDebugMessages == true then LOG(sFunctionRef..': subrefiLowestFriendlyLandFactoryTech before reducing='..tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]..'; oBrain[M28Economy.refiOurHighestLandFactoryTech]='..oBrain[M28Economy.refiOurHighestLandFactoryTech]..'; lower of these two='..math.min(tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech], oBrain[M28Economy.refiOurHighestLandFactoryTech])) end
        tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] = math.min(3, tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech], oBrain[M28Economy.refiOurHighestLandFactoryTech])
        if bDebugMessages == true then LOG(sFunctionRef..': tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] after update='..tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]) end
        tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] = math.min(3, tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech], oBrain[M28Economy.refiOurHighestAirFactoryTech])
        tTeamData[iM28Team][subrefiLowestFriendlyNavalFactoryTech] = math.min(3, tTeamData[iM28Team][subrefiLowestFriendlyNavalFactoryTech], oBrain[M28Economy.refiOurHighestNavalFactoryTech])

        tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] = math.min(3, math.max(tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech], oBrain[M28Economy.refiOurHighestLandFactoryTech]))
        tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] = math.min(3, math.max(tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech], oBrain[M28Economy.refiOurHighestAirFactoryTech]))
        tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech] = math.min(3, math.max(tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech], oBrain[M28Economy.refiOurHighestNavalFactoryTech]))
        if bDebugMessages == true then LOG(sFunctionRef..': Considering brain '..oBrain.Nickname..'; tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]='..tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]..'; oBrain[M28Economy.refiOurHighestLandFactoryTech]='..oBrain[M28Economy.refiOurHighestLandFactoryTech]) end
    end
    tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] = math.min(3, math.max(1, tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech], tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech], (tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech] or 0)))
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DoesBrainHaveActiveHQUpgradesOfCategory(aiBrain, iFactoryBeingUpgradedCategory)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DoesBrainHaveActiveHQUpgradesOfCategory'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Does our team have an empty table of upgrading HQs='..tostring(M28Utilities.IsTableEmpty(tTeamData[aiBrain.M28Team][subreftTeamUpgradingHQs]))) end
    if M28Utilities.IsTableEmpty(tTeamData[aiBrain.M28Team][subreftTeamUpgradingHQs]) == false then
        for iUpgrading, oUpgrading in tTeamData[aiBrain.M28Team][subreftTeamUpgradingHQs] do
            if EntityCategoryContains(iFactoryBeingUpgradedCategory, oUpgrading.UnitId) then
                if M28UnitInfo.IsUnitValid(oUpgrading) and oUpgrading:GetAIBrain() == aiBrain then
                    if bDebugMessages == true then LOG(sFunctionRef..': The upgrading unit '..oUpgrading.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUpgrading)..' brain is equal to aiBrain '..aiBrain.Nickname) end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function ConsiderPriorityLandFactoryUpgrades(iM28Team)
    --Starts a land factory upgrade if we need one urgently (e.g. we are outteched, or have high gross mass so will want access to T3)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderPriorityLandFactoryUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Enemy has better land tech than us, and we have no active land upgrades



    if bDebugMessages == true then
        LOG(sFunctionRef..': Highest land tech='..tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech]..'; Highest enemy tech='..tTeamData[iM28Team][subrefiHighestEnemyGroundTech]..'; Gross mass='..tTeamData[iM28Team][subrefiTeamGrossMass]..'; Mass stored='..tTeamData[iM28Team][subrefiTeamMassStored])
    end
    if tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] > 0 and tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] < 3 and (tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] < 2 or not(tTeamData[iM28Team][refbFocusOnT1Spam])) then
        local bInitiallyWantUpgrade = false
        local bNearbyUpgradedEnemyACU = false
        if tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] < tTeamData[iM28Team][subrefiHighestEnemyGroundTech]
                or (tTeamData[iM28Team][subrefiTeamGrossMass] >= 3.5 * tTeamData[iM28Team][subrefiActiveM28BrainCount] * tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] and (tTeamData[iM28Team][subrefiTeamMassStored] >= 300 * math.min(2, tTeamData[iM28Team][subrefiActiveM28BrainCount]) * tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] or tTeamData[iM28Team][subrefiTeamGrossMass] >= 7 * tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] * tTeamData[iM28Team][subrefiActiveM28BrainCount]) and (tTeamData[iM28Team][subrefiTeamGrossMass] >= 8.5 * (1 + (tTeamData[iM28Team][subrefiActiveM28BrainCount] - 1) *0.5) or tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] == 1 or M28Conditions.GetTeamLifetimeBuildCount(iM28Team, (M28UnitInfo.refCategoryLandCombat * M28UnitInfo.ConvertTechLevelToCategory(tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]) + M28UnitInfo.refCategoryIndirect * M28UnitInfo.ConvertTechLevelToCategory(tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech])) ) >= (20 * (2.5-tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]) + 12 * tTeamData[iM28Team][subrefiActiveM28BrainCount]) * tTeamData[iM28Team][subrefiActiveM28BrainCount])) then
            if bDebugMessages == true then LOG(sFunctionRef..': Want to get upgrade as have high eco or enemy outtechs us; however will make exception if are at T3 air and low mass') end
            bInitiallyWantUpgrade = true
            if tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] <= 0.05 and tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] >= 3 and GetGameTimeSeconds() - (tTeamData[iM28Team][refiTimeOfLastMassStall] or -100) <= 45 and tTeamData[iM28Team][refiConstructedExperimentalCount] == 0 then
                bInitiallyWantUpgrade = false
                if bDebugMessages == true then LOG(sFunctionRef..': Changed mind, dont want to upgrade yet as a priority due to low mass and having T3 air') end
            end
        end
        --Does enemy have a nearby upgraded or upgrading AUC and we lack T2 land for a brain?
        if tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 1 and M28Conditions.IsTableOfUnitsStillValid(tTeamData[iM28Team][reftEnemyACUs]) then
            for iACU, oACU in tTeamData[iM28Team][reftEnemyACUs] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if enemy ACU owned by brain '..oACU:GetAIBrain().Nickname..' is upgrading or has an upgrade, upgrade count='..(oACU[M28ACU.refiUpgradeCount] or 0)..'; Unit state='..M28UnitInfo.GetUnitState(oACU)) end
                if (oACU[M28ACU.refiUpgradeCount] or 0) > 0 or oACU:IsUnitState('Upgrading') then
                    --Is the ACU close to a friendly base?
                    local tLZOrWZData, tLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oACU:GetPosition(), true, iM28Team)
                    if M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tLZOrWZTeamData[M28Map.reftClosestFriendlyBase]) <= math.min(250, math.max(175, M28Map.iMapSize * 0.5)) then
                        bNearbyUpgradedEnemyACU = true
                        bInitiallyWantUpgrade = true
                        break
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bInitiallyWantUpgrade='..tostring(bInitiallyWantUpgrade)) end
        if bInitiallyWantUpgrade then
            if not(M28Map.bIsCampaignMap) or tTeamData[iM28Team][subrefiTeamGrossMass] >= 4 * tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] * tTeamData[iM28Team][subrefiActiveM28BrainCount] then

                local bWantUpgrade = false
                local iExistingBrainsWithHQUpgrades = 0
                local tbBrainsWithActiveUpgradeByIndex = {}
                if M28Conditions.IsTableOfUnitsStillValid(tTeamData[iM28Team][subreftTeamUpgradingHQs]) then
                    for iHQ, oHQ in tTeamData[iM28Team][subreftTeamUpgradingHQs] do
                        if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oHQ.UnitId) then
                            if not(oHQ:GetAIBrain():IsDefeated()) then
                                tbBrainsWithActiveUpgradeByIndex[oHQ:GetAIBrain():GetArmyIndex()] = true
                            end
                        end
                    end
                end

                for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
                    --Can we path to the nearest enemy with land, and we are behind enemy tech level with land or have lots of mass?
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oBrain '..oBrain.Nickname..'; oBrain[M28Map.refbCanPathToEnemyBaseWithLand]='..tostring(oBrain[M28Map.refbCanPathToEnemyBaseWithLand])..'; oBrain[M28Economy.refiOurHighestLandFactoryTech]='..oBrain[M28Economy.refiOurHighestLandFactoryTech]..'; tbBrainsWithActiveUpgradeByIndex='..tostring(tbBrainsWithActiveUpgradeByIndex[oBrain:GetArmyIndex()] or false)) end
                    if not(tbBrainsWithActiveUpgradeByIndex[oBrain:GetArmyIndex()]) then

                        if oBrain[M28Map.refbCanPathToEnemyBaseWithLand] and oBrain[M28Economy.refiOurHighestLandFactoryTech] > 0 and (oBrain[M28Economy.refiOurHighestLandFactoryTech] < tTeamData[iM28Team][subrefiHighestEnemyGroundTech] or (bNearbyUpgradedEnemyACU and oBrain[M28Economy.refiOurHighestLandFactoryTech] == 1) or (tTeamData[iM28Team][subrefiTeamGrossMass] >= 6.5 * (1 + (tTeamData[iM28Team][subrefiActiveM28BrainCount] - 1) * 0.5) and tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 50 * (1 + (tTeamData[iM28Team][subrefiActiveM28BrainCount] - 1)*0.5)) or M28Conditions.GetTeamLifetimeBuildCount(iM28Team, (M28UnitInfo.refCategoryLandCombat * M28UnitInfo.ConvertTechLevelToCategory(tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]) + M28UnitInfo.refCategoryIndirect * M28UnitInfo.ConvertTechLevelToCategory(tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]))) >= 20 * (2-tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]) + 15 * tTeamData[iM28Team][subrefiActiveM28BrainCount]) then
                            --Do we have any active land factory upgrades?
                            bWantUpgrade = not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ))
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to hold off so we can get air instead, oBrain[M28Economy.refiOurHighestLandFactoryTech]='..oBrain[M28Economy.refiOurHighestLandFactoryTech]..'; oBrain[M28Economy.refiOurHighestAirFactoryTech]='..oBrain[M28Economy.refiOurHighestAirFactoryTech]..'; Map size='..M28Map.iMapSize) end
                            if bWantUpgrade and oBrain[M28Economy.refiOurHighestLandFactoryTech] >= 2 and oBrain[M28Economy.refiOurHighestAirFactoryTech] <= 2 and M28Map.iMapSize >= 512 then
                                --Check if we are in a 'safe' start position, in which case want to not get land and instead will get air
                                local tBrainStartZoneData, tBrainStartZoneTeamData = M28Map.GetLandOrWaterZoneData(M28Map.GetPlayerStartPosition(oBrain, false), true, oBrain.M28Team)
                                if tBrainStartZoneTeamData[M28Map.refbBaseInSafePosition] and M28Utilities.GetDistanceBetweenPositions(tBrainStartZoneData[M28Map.subrefMidpoint], tBrainStartZoneTeamData[M28Map.reftClosestEnemyBase]) >= 300 then bWantUpgrade = false end
                                if bDebugMessages == true then LOG(sFunctionRef..': tBrainStartZoneTeamData[M28Map.refbBaseInSafePosition]='..tostring(tBrainStartZoneTeamData[M28Map.refbBaseInSafePosition] or false)..'; Dist to closest enemy base='..M28Utilities.GetDistanceBetweenPositions(tBrainStartZoneData[M28Map.subrefMidpoint], tBrainStartZoneTeamData[M28Map.reftClosestEnemyBase])) end
                            end

                            if bWantUpgrade and (iExistingBrainsWithHQUpgrades < tTeamData[iM28Team][subrefiActiveM28BrainCount] * 0.5 or tTeamData[iM28Team][subrefiTeamMassStored] >= 450 * tTeamData[iM28Team][subrefiActiveM28BrainCount]) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will try and upgrade a land factory HQ subject to how many units the factory has built') end
                                M28Economy.FindAndUpgradeUnitOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ * M28UnitInfo.ConvertTechLevelToCategory(oBrain[M28Economy.refiOurHighestLandFactoryTech]), 7)
                            elseif not(bWantUpgrade) then
                                iExistingBrainsWithHQUpgrades = iExistingBrainsWithHQUpgrades + 1
                            end
                        end
                    end
                end
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderPriorityAirFactoryUpgrades(iM28Team)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderPriorityAirFactoryUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]..'; tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]) end

    if tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] > 0 and tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] < 3 and not(tTeamData[iM28Team][refbFocusOnT1Spam]) then
        --Campaign specific - dont be as keen to urgently upgrade air (as it may be enemy starts at t3 air while we start at t1)
        if not(M28Map.bIsCampaignMap) or tTeamData[iM28Team][subrefiTeamGrossMass] >= 4 * tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] * tTeamData[iM28Team][subrefiActiveM28BrainCount] then
            local bWantUpgrade = false
            --Prioritise air factory if we dont have T2 air and enemy has navy
            local bAirSubteamNeedsTorps = false
            local tiAirSubteams = {}
            for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
                tiAirSubteams[oBrain.M28AirSubteam] = true
            end
            for iAirSubteam, bTrue in tiAirSubteams do
                if tAirSubteamData[iAirSubteam][refbNoAvailableTorpsForEnemies] then
                    bAirSubteamNeedsTorps = true
                    break
                end
            end

            --Upgrading from T2 to T3 - Do we only have 1 air fac for the brain, and has it not yet built at least 5 units of that tech (or 15 of any tech) yet?
            local bWaitUntilBuiltMoreUnits = false
            if tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] == 2 and tTeamData[iM28Team][subrefiHighestEnemyAirTech] < 3 then
                bWaitUntilBuiltMoreUnits = true
                for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
                    local tT2AirFactories = oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirFactory * categories.TECH2, false, true)
                    if M28Utilities.IsTableEmpty(tT2AirFactories) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': T2 air fac count for brain '..oBrain.Nickname..'='..table.getn(tT2AirFactories)) end
                        if table.getn(tT2AirFactories) >= 2 then
                            bWaitUntilBuiltMoreUnits = false
                            break
                        else
                            for iUnit, oUnit in tT2AirFactories do
                                if bDebugMessages == true then LOG(sFunctionRef..': Lifetime build count for T2 air for factory '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'='..M28Conditions.GetFactoryLifetimeCount(oUnit, categories.AIR * categories.TECH2)..'; Lifetime T1+T2 count='..M28Conditions.GetFactoryLifetimeCount(oUnit, categories.TECH1 + categories.TECH2)) end
                                if M28Conditions.GetFactoryLifetimeCount(oUnit, categories.AIR * categories.TECH2) >= 5 or M28Conditions.GetFactoryLifetimeCount(oUnit, categories.TECH1 + categories.TECH2) >= 15 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': AIr fac has built enough T2 units for us to contemplate T3 upgrade') end
                                    bWaitUntilBuiltMoreUnits = false
                                    break
                                end
                            end
                        end
                    end
                    if not(bWaitUntilBuiltMoreUnits) then break end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bWaitUntilBuiltMoreUnits='..tostring(bWaitUntilBuiltMoreUnits)) end
            if not(bWaitUntilBuiltMoreUnits) then
                if tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] < 2 and (bAirSubteamNeedsTorps or tTeamData[iM28Team][subrefiHighestEnemyNavyTech] > 0) then
                    local tbBrainsWithActiveUpgradeByIndex = {}
                    if M28Conditions.IsTableOfUnitsStillValid(tTeamData[iM28Team][subreftTeamUpgradingHQs]) then
                        for iHQ, oHQ in tTeamData[iM28Team][subreftTeamUpgradingHQs] do
                            if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oHQ.UnitId) then
                                if not(oHQ:GetAIBrain():IsDefeated()) then
                                    tbBrainsWithActiveUpgradeByIndex[oHQ:GetAIBrain():GetArmyIndex()] = true
                                end
                            end
                        end
                    end
                    for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
                        if not(tbBrainsWithActiveUpgradeByIndex[oBrain:GetArmyIndex()]) and oBrain[M28Economy.refiOurHighestAirFactoryTech] > 0 and oBrain[M28Economy.refiOurHighestAirFactoryTech] < 2 then
                            bWantUpgrade = true
                            M28Economy.FindAndUpgradeUnitOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ * categories.TECH1)
                        end
                    end
                end
                --Prioritise air factory if enemy has T3 air and we dont
                if not(bWantUpgrade) and tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] < tTeamData[iM28Team][subrefiHighestEnemyAirTech] and tTeamData[iM28Team][subrefiHighestEnemyAirTech] >= 3 then
                    for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
                        if oBrain[M28Economy.refiOurHighestAirFactoryTech] > 0 and oBrain[M28Economy.refiOurHighestAirFactoryTech] < 3 then
                            --Do we have any active air factory upgrades?
                            bWantUpgrade = not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ))

                            if bWantUpgrade then
                                M28Economy.FindAndUpgradeUnitOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ * M28UnitInfo.ConvertTechLevelToCategory(oBrain[M28Economy.refiOurHighestAirFactoryTech]))
                            end
                        end
                    end
                end
                if not(bWantUpgrade) then
                    --Prioritise air fac if we already have T2 land and at least 4 mass per tick and 70 power per tick, or if we have 6 mass and 100 power, provided no current HQ upgrades
                    if bDebugMessages == true then LOG(sFunctionRef..': Our highest tech level='..tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]..'; Enemy highest tech='..tTeamData[iM28Team][subrefiHighestEnemyAirTech]..'; Gross energy='..tTeamData[iM28Team][subrefiTeamGrossEnergy]..'; Highest resource mult='.. tTeamData[iM28Team][refiHighestBrainResourceMultiplier]..'; Team T2+ engi lifetime count='..M28Conditions.GetTeamLifetimeBuildCount(iM28Team, M28UnitInfo.refCategoryEngineer - categories.TECH1)) end

                    if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) and tTeamData[iM28Team][subrefiTeamGrossMass] >= 4 * tTeamData[iM28Team][subrefiActiveM28BrainCount] and tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 70 * tTeamData[iM28Team][subrefiActiveM28BrainCount] and (tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] >= 2 or (tTeamData[iM28Team][subrefiTeamGrossMass] >= 6 * tTeamData[iM28Team][subrefiActiveM28BrainCount] and tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 102 * tTeamData[iM28Team][subrefiActiveM28BrainCount] * tTeamData[iM28Team][refiHighestBrainResourceMultiplier]))
                            and (tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] <= tTeamData[iM28Team][subrefiHighestEnemyAirTech] or (tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 70 * tTeamData[iM28Team][subrefiActiveM28BrainCount] * tTeamData[iM28Team][refiHighestBrainResourceMultiplier] and M28Conditions.GetTeamLifetimeBuildCount(iM28Team, M28UnitInfo.refCategoryEngineer - categories.TECH1) >= 3 + 2 * tTeamData[iM28Team][subrefiActiveM28BrainCount]))
                    then
                        for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
                            if oBrain[M28Economy.refiOurHighestAirFactoryTech] > 0 and oBrain[M28Economy.refiOurHighestAirFactoryTech] < 3 then
                                --Do we have any active air factory upgrades? (redundancy - should already have excluded via above)
                                bWantUpgrade = not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ))
                                if bWantUpgrade then
                                    M28Economy.FindAndUpgradeUnitOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ * M28UnitInfo.ConvertTechLevelToCategory(oBrain[M28Economy.refiOurHighestAirFactoryTech]))
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderPriorityNavalFactoryUpgrades(iM28Team)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderPriorityNavalFactoryUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech]) end

    if tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech] > 0 and tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech] < math.min(3, tTeamData[iM28Team][subrefiHighestEnemyNavyTech]) then
        local bWantUpgrade = false
        for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering brain '..oBrain.Nickname..'; Highest naval tech='..oBrain[M28Economy.refiOurHighestNavalFactoryTech]..'; Highest air tech='..oBrain[M28Economy.refiOurHighestAirFactoryTech]..'; Highest enemy naval tech='..tTeamData[iM28Team][subrefiHighestEnemyNavyTech]) end
            if oBrain[M28Economy.refiOurHighestNavalFactoryTech] > 0 and oBrain[M28Economy.refiOurHighestAirFactoryTech] < math.min(3, tTeamData[iM28Team][subrefiHighestEnemyNavyTech]) then
                --Do we have any active air factory upgrades?
                bWantUpgrade = not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryNavalHQ))

                if bWantUpgrade then
                    --First check total build count of naval factories
                    local tNavalFactories
                    if tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech] == 2 then tNavalFactories = oBrain:GetListOfUnits(M28UnitInfo.refCategoryNavalFactory * categories.TECH2, false, true)
                    else tNavalFactories = oBrain:GetListOfUnits(M28UnitInfo.refCategoryNavalFactory, false, true)
                    end
                    local iTotalBuildCount = 0
                    if M28Utilities.IsTableEmpty(tNavalFactories) == false then
                        for iFactory, oFactory in tNavalFactories do
                            iTotalBuildCount = iTotalBuildCount + (oFactory[M28Factory.refiTotalBuildCount] or 0)
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iTotalBuildCount='..iTotalBuildCount..'; tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech]) end

                    --Campaign maps where still relatively early, or games where we have poor gross mass, where considering upgrading to T3 (or T2 if have built fewer than 4 units)
                    if iTotalBuildCount <= 8 and tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech] <= 2 then
                        local iEcoConditionFactor = 1
                        if tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech] == 1 then iEcoConditionFactor = 0.3 end
                        if M28Map.bIsCampaignMap and GetGameTimeSeconds() <= 600 and tTeamData[iM28Team][subrefiTeamGrossMass] <= 20 * iEcoConditionFactor then
                            bWantUpgrade = false
                        elseif tTeamData[iM28Team][subrefiTeamGrossMass] <= 10 * tTeamData[iM28Team][subrefiActiveM28BrainCount] * iEcoConditionFactor then
                            --Only upgrade to T3 if we have built a number of T2 units
                            if iTotalBuildCount <= 8 then
                                bWantUpgrade = false
                            end
                        elseif iTotalBuildCount <= 4 then
                            bWantUpgrade = false
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': We have lower naval tech than enemy, and dont have an active HQ upgrade, bWantUpgrade after low mass checks='..tostring(bWantUpgrade)) end
                    if bWantUpgrade then
                        M28Economy.FindAndUpgradeUnitOfCategory(oBrain, M28UnitInfo.refCategoryNavalHQ * M28UnitInfo.ConvertTechLevelToCategory(oBrain[M28Economy.refiOurHighestNavalFactoryTech]))
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderPriorityMexUpgrades(iM28Team)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderPriorityMexUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Is table of upgrading mexes empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]))..'; tTeamData[iM28Team][subrefiTeamMassStored]='..tTeamData[iM28Team][subrefiTeamMassStored]..'; tTeamData[iM28Team][subrefiTeamNetMass]='..tTeamData[iM28Team][subrefiTeamNetMass]..'; tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]='..tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]..'; or M28Overseer.bNoRushActive='..tostring(M28Overseer.bNoRushActive or false)) end
    local iExistingT1MexUpgrades = 0
    local iExistingT2MexUpgrades = 0
    if not(tTeamData[iM28Team][refbFocusOnT1Spam]) or (tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.95 and tTeamData[iM28Team][subrefiTeamNetEnergy] > 1 and tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] >= 0.98 and M28Conditions.GetCurrentM28UnitsOfCategoryInTeam(M28UnitInfo.refCategoryFactory, iM28Team) >= 4) then
        if M28Conditions.IsTableOfUnitsStillValid(tTeamData[iM28Team][subreftTeamUpgradingMexes])  then
            for iUpgradingMex, oUpgradingMex in tTeamData[iM28Team][subreftTeamUpgradingMexes] do
                if EntityCategoryContains(categories.TECH1, oUpgradingMex.UnitId) then
                    iExistingT1MexUpgrades = iExistingT1MexUpgrades + 1
                elseif EntityCategoryContains(categories.TECH2, oUpgradingMex.UnitId) then
                    iExistingT2MexUpgrades = iExistingT2MexUpgrades + 1
                else
                    M28Utilities.ErrorHandler('Are somehow upgrading a mex  that is neither t1 nor t2')
                end
            end
        end
        --T1 mex upgrading to T2 = c.8 mass per sec; T2 to T3 = c.18 mass per sec; so treat 1 T2 mex upgrading as equiv to 2.5 T1 mex
        --Want to be spending at least 1/3 of gross income on upgrading mexes assuming we have safe mexes to upgrade
        local bHaveSafeMexToUpgrade = GetSafeMexToUpgrade(iM28Team, true)
        local iUpgradingMexValue = iExistingT1MexUpgrades + 2.5 * iExistingT2MexUpgrades
        local iWantedUpgradingMexValue = 0
        local bBehindOnT3OrNotStartedT2Mex = false
        if tTeamData[iM28Team][subrefiTeamGrossMass] >= 2.5 * tTeamData[iM28Team][subrefiActiveM28BrainCount] then
            iWantedUpgradingMexValue = 1
            if tTeamData[iM28Team][subrefiTeamGrossMass] >= 12 then iWantedUpgradingMexValue = iWantedUpgradingMexValue + 1 end
            if tTeamData[iM28Team][refiMexCountByTech] < M28Conditions.GetHighestOtherTeamT3MexCount(iM28Team) then
                bBehindOnT3OrNotStartedT2Mex = true
                iWantedUpgradingMexValue = iWantedUpgradingMexValue * 1.5
            end
        end
        if not(bBehindOnT3OrNotStartedT2Mex) and tTeamData[iM28Team][refiMexCountByTech][3] == 0 then
            local iOurT2MexCount = tTeamData[iM28Team][refiMexCountByTech][2]
            local iEnemyT2AndT3MexCount = M28Conditions.GetHighestOtherTeamT2AndT3MexCount(iM28Team)
            if iEnemyT2AndT3MexCount >= math.max(2, 2 * iOurT2MexCount) then
                bBehindOnT3OrNotStartedT2Mex = true
            end
        end
        if bHaveSafeMexToUpgrade or M28Overseer.bNoRushActive then
            --if upgrading 1 mex from t1 to t2 costs roughly 0.8 mass per tick, and we want to be spenting 1/3 of mass per tick on this, then want 1/3 of gross mass / 0.8, i.e. 0.4167
            --However, are finding we are spending too much mass with this approach and end up always mass stalling, and only upgrading mexes, meaning HQs dont upgrade (when using a value of 0.4167 * gross mass income)
            iWantedUpgradingMexValue = math.max((tTeamData[iM28Team][subrefiTeamGrossMass] - 2 * tTeamData[iM28Team][subrefiActiveM28BrainCount]) * 0.3, tTeamData[iM28Team][subrefiTeamGrossMass] * 0.125)
            --if are already upgrading 1 mex per brain and are stalling mass, then reduce the amount wanted
            if (tTeamData[iM28Team][subrefiTeamMassStored] < 50 or tTeamData[iM28Team][subrefbTeamIsStallingMass]) and M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) == false and (table.getn(tTeamData[iM28Team][subreftTeamUpgradingMexes]) > 1 + (tTeamData[iM28Team][subrefiActiveM28BrainCount] - 1) * 0.5 and tTeamData[iM28Team][subrefiTeamNetMass] <= -math.max(-0.5, tTeamData[iM28Team][subrefiTeamGrossMass] * 0.08)) then
                iWantedUpgradingMexValue = iWantedUpgradingMexValue * 0.2
            end
            --Adjust maount wanted for any build power modifier
            iWantedUpgradingMexValue = iWantedUpgradingMexValue / tTeamData[iM28Team][refiHighestBrainBuildMultiplier]
        end

        local bWantMassForProduction = false
        for _, iAirSubteam in tTeamData[iM28Team][subrefAirSubteamsInTeam] do
            if tAirSubteamData[iAirSubteam][refbNoAvailableTorpsForEnemies] then
                bWantMassForProduction = true
                break
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': bWantMassForProduction='..tostring(bWantMassForProduction)..'; Is table of upgrading mexes empty='..tostring( M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]))..'; Is table of upgrading HQs empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]))) end
        if not(bWantMassForProduction) or M28Overseer.bNoRushActive or (bBehindOnT3OrNotStartedT2Mex and not(tTeamData[iM28Team][subrefbTeamIsStallingMass])) or (M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) and M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs])) then
            if not(tTeamData[iM28Team][refbFocusOnT1Spam]) or M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) or table.getn(tTeamData[iM28Team][subreftTeamUpgradingMexes]) * 2 + 4 <= M28Conditions.GetCurrentM28UnitsOfCategoryInTeam(M28UnitInfo.refCategoryFactory, iM28Team) then
                if bDebugMessages == true then LOG(sFunctionRef..': iWantedUpgradingMexValue='..iWantedUpgradingMexValue..'; iUpgradingMexValue='..iUpgradingMexValue..'; bHaveSafeMexToUpgrade='..tostring(bHaveSafeMexToUpgrade)..'; iExistingT1MexUpgrades='..iExistingT1MexUpgrades..'; iExistingT2MexUpgrades='..iExistingT2MexUpgrades..'; Active brain count='..tTeamData[iM28Team][subrefiActiveM28BrainCount]..'; Total mass stored='..tTeamData[iM28Team][subrefiTeamMassStored]) end
                if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) or iWantedUpgradingMexValue > iUpgradingMexValue or (tTeamData[iM28Team][subrefiTeamMassStored] >= 800 and (tTeamData[iM28Team][subrefiTeamNetMass] - tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]) > 0) then
                    --Do we have enough energy?
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have enough energy, tTeamData[iM28Team][subrefiTeamNetEnergy]='..tTeamData[iM28Team][subrefiTeamNetEnergy]..'; tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle]='..tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle]..'; tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored]='..tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored]) end
                    if (tTeamData[iM28Team][subrefiTeamNetEnergy] - tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle] > 0 or (M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) and tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] >= 0.98)) and
                            (tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] >= 0.75 or tTeamData[iM28Team][subrefiTeamNetEnergy] - tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle] >= 5) then
                        --Do we have mexes in start positions that are lower than the enemy's highest tech, or 2 lower than the highest mex in that LZ? Or are in norush mode? Or just want to be spending more mass on upgrading safe mexes?
                        local iTechLevelToUpgrade = math.min(3, (tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] or 1)) - 1 --, (tTeamData[iM28Team][subrefiHighestEnemyMexTech] or 0))) - 1
                        if M28Overseer.bNoRushActive then iTechLevelToUpgrade = math.max(1, iTechLevelToUpgrade) end
                        --Always be upgrading a mex at higher mass levels
                        if iTechLevelToUpgrade <= 1 then
                            if iTechLevelToUpgrade == 1 and tTeamData[iM28Team][subrefiTeamGrossMass] > tTeamData[iM28Team][subrefiActiveM28BrainCount] * 6 then
                                iTechLevelToUpgrade = 2
                            elseif iTechLevelToUpgrade == 0 and tTeamData[iM28Team][subrefiTeamGrossMass] > tTeamData[iM28Team][subrefiActiveM28BrainCount] * 2.5 then
                                iTechLevelToUpgrade = 1
                            end
                        end
                        if iTechLevelToUpgrade <= 0 and tTeamData[iM28Team][subrefiTeamMassStored] >= 1000 and ( tTeamData[iM28Team][subrefiTeamMassStored] >= 1600 or tTeamData[iM28Team][subrefiTeamNetMass] > 0 or (tTeamData[iM28Team][subrefiTeamMassStored] >= 1250 and tTeamData[iM28Team][subrefiTeamNetMass] > -1)) and tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] >= 0.7 and (tTeamData[iM28Team][subrefiTeamEnergyStored] >= 9000 or tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] >= 0.9) and tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 30 then iTechLevelToUpgrade = 1 end
                        if bDebugMessages == true then LOG(sFunctionRef..': iTechLevelToUpgrade='..iTechLevelToUpgrade..'; tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]..'; bHaveSafeMexToUpgrade='..tostring(bHaveSafeMexToUpgrade or false)) end
                        if iTechLevelToUpgrade >= 1 then
                            if bHaveSafeMexToUpgrade then
                                GetSafeMexToUpgrade(iM28Team)
                            else

                                --If dont have safe mex to upgrade - cycle through each brain looking for mex to upgrade
                                local iPlateau, iLandZone, tMexesToConsiderUpgrading
                                local bAbort = false

                                --Want to be upgrading at least 1 mex on our team, or more if we have positive mass income, subject to gross income
                                local tiExtraMassStoredPerUpgrade = {[1] = 300, [2] = 1000}
                                local iMassStoredToKeepUpgrading = 0
                                if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) == false then
                                    for iUnit, oUnit in tTeamData[iM28Team][subreftTeamUpgradingMexes] do
                                        iMassStoredToKeepUpgrading = iMassStoredToKeepUpgrading + tiExtraMassStoredPerUpgrade[M28UnitInfo.GetUnitTechLevel(oUnit)]
                                    end
                                end



                                for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
                                    bAbort = false
                                    iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                                    local tLZOrWZTeamData
                                    if (iLandZone or 0) > 0 then
                                        tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iM28Team]
                                    else
                                        local iWaterZone = M28Map.GetWaterZoneFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                                        if (iWaterZone or 0) > 0 then
                                            tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][iM28Team]
                                        end
                                    end
                                    --Dont do priority upgrade if this location already has an upgrade, unless we have high mass income for this brain and T1 mexes
                                    if bDebugMessages == true then LOG(sFunctionRef..': Does brain '..oBrain.Nickname..' have an empty table of active upgrades in its start position LZ/WZ='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoActiveUpgrades]))) end
                                    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoActiveUpgrades]) or (oBrain[M28Economy.refiGrossMassBaseIncome] >= 4 and tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] > 0) then
                                        for iMexTech = 1, iTechLevelToUpgrade do
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering mexes for iMexTech='..iMexTech..'; count='..tLZOrWZTeamData[M28Map.subrefMexCountByTech][iMexTech]) end
                                            if tLZOrWZTeamData[M28Map.subrefMexCountByTech][iMexTech] > 0 then
                                                tMexesToConsiderUpgrading = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex * M28UnitInfo.ConvertTechLevelToCategory(iMexTech), tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                                if M28Utilities.IsTableEmpty(tMexesToConsiderUpgrading) == false then
                                                    for iMex, oMex in tMexesToConsiderUpgrading do
                                                        if not(oMex:IsUnitState('Upgrading')) and oMex:GetFractionComplete() == 1 then
                                                            if oMex:GetAIBrain().M28AI and oMex:GetAIBrain().M28Team == iM28Team then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Will try to upgrade mex in starting zone, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Mex='..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)) end
                                                                M28Economy.UpgradeUnit(oMex, true)
                                                                iMassStoredToKeepUpgrading = iMassStoredToKeepUpgrading + tiExtraMassStoredPerUpgrade[iMexTech]
                                                                bAbort = true
                                                                break
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                            if bAbort then break end
                                        end
                                    end
                                    if bAbort then
                                        --Do we have positive mass income or lots of mass stored? If so then proceed to upgrade for other brains
                                        if tTeamData[iM28Team][subrefiTeamNetEnergy] - tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle] > 0 then
                                            if (tTeamData[iM28Team][subrefiTeamNetMass] - tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]) > 0 or tTeamData[iM28Team][subrefiTeamMassStored] >= iMassStoredToKeepUpgrading then
                                                bAbort = false
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AddPotentialUnitsToShortlist(toUnitShortlist, tPotentialUnits, bDontCheckIfSafe, iOptionalHighestTechBuildCountRequirement)
    if M28Utilities.IsTableEmpty(tPotentialUnits) == false then
        for iUnit, oUnit in tPotentialUnits do
            if M28UnitInfo.IsUnitValid(oUnit) and not(oUnit:IsUnitState('Upgrading')) and oUnit:GetFractionComplete() == 1 then
                --Extra check for factories
                if not(M28Conditions.CheckIfNeedMoreEngineersOrSnipeUnitsBeforeUpgrading(oUnit)) then
                    local bUnitIsHighestTechFactoryForOptionalCount = false
                    if not(iOptionalHighestTechBuildCountRequirement) then bUnitIsHighestTechFactoryForOptionalCount = true
                    else
                        local iUnitTechLevel = M28UnitInfo.GetUnitTechLevel(oUnit)
                        if iUnitTechLevel >= 3 then bUnitIsHighestTechFactoryForOptionalCount = true
                        else
                            if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) then
                                if iUnitTechLevel >= oUnit:GetAIBrain()[M28Economy.refiOurHighestLandFactoryTech] then bUnitIsHighestTechFactoryForOptionalCount = true end

                            elseif EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oUnit.UnitId) then
                                if iUnitTechLevel >= oUnit:GetAIBrain()[M28Economy.refiOurHighestAirFactoryTech] then bUnitIsHighestTechFactoryForOptionalCount = true end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oUnit.UnitId) then
                                if iUnitTechLevel >= oUnit:GetAIBrain()[M28Economy.refiOurHighestNavalFactoryTech] then bUnitIsHighestTechFactoryForOptionalCount = true end
                            end
                        end
                    end
                    if (not(bUnitIsHighestTechFactoryForOptionalCount) or iOptionalHighestTechBuildCountRequirement <= (oUnit[M28Factory.refiTotalBuildCount] or 0)) and (bDontCheckIfSafe or M28Conditions.SafeToUpgradeUnit(oUnit)) then
                        table.insert(toUnitShortlist, oUnit)
                    end
                end
            end
        end
    end
end

function GetSafeMexToUpgrade(iM28Team, bReturnIfSafeInsteadOfUpgrading)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetSafeMexToUpgrade'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local toSafeUnitsToUpgrade = {}
    local tPotentialUnits
    --First prioritise T1 mexes
    local tiMexCategory = {[1] = M28UnitInfo.refCategoryT1Mex, [2]=M28UnitInfo.refCategoryT2Mex}
    for iTech = 1, 2 do
        for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
            local tPotentialUnits = oBrain:GetListOfUnits(tiMexCategory[iTech], false, true)
            AddPotentialUnitsToShortlist(toSafeUnitsToUpgrade, tPotentialUnits)
        end
        if M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade) == false then
            break
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for units to upgrade at time '..GetGameTimeSeconds()..', is table empty='..tostring(M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade))) end
    if bReturnIfSafeInsteadOfUpgrading then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return not(M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade))
    else
        if M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Have a total of '..table.getn(toSafeUnitsToUpgrade)..' units to upgrade, will pick the best one') end
            local oUnitToUpgrade = M28Economy.GetBestUnitToUpgrade(toSafeUnitsToUpgrade)
            if oUnitToUpgrade then
                if bDebugMessages == true then LOG(sFunctionRef..': Will try to upgrade unit '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)) end
                M28Economy.UpgradeUnit(oUnitToUpgrade, true)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetSafeHQUpgrade(iM28Team, bOnlyConsiderLandFactory)
    --if bRunningThisAsBackupUpgradeOption then wont upgrade T2 land fac that hasnt built much
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetSafeHQUpgrade'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local toSafeUnitsToUpgrade = {}
    local tPotentialUnits

    --First identify any players that have a T1 land or air HQ
    for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
        if bDebugMessages == true then LOG(sFunctionRef..': Considering brain '..oBrain.Nickname..'; Highest air fac tech='..oBrain[M28Economy.refiOurHighestAirFactoryTech]..'; Highest land fac tech='..oBrain[M28Economy.refiOurHighestLandFactoryTech]..'; bOnlyConsiderLandFactory='..tostring(bOnlyConsiderLandFactory or false)) end
        if oBrain[M28Economy.refiOurHighestAirFactoryTech] == 1 and not(bOnlyConsiderLandFactory) then
            if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ)) then
                --Check we dont already have an active upgrade
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirHQ * categories.TECH1, false, true)
                AddPotentialUnitsToShortlist(toSafeUnitsToUpgrade, tPotentialUnits)
            end
        end
        if oBrain[M28Economy.refiOurHighestLandFactoryTech] == 1 then
            if bDebugMessages == true then LOG(sFunctionRef..': Does brain have active Land HQ upgrades='..tostring(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ))) end
            if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ)) then
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandHQ * categories.TECH1, false, true)
                if bDebugMessages == true then LOG(sFunctionRef..': Adding T1 land HQs to shortlist, is tPotentialUnits empty='..tostring(M28Utilities.IsTableEmpty(tPotentialUnits))) end
                AddPotentialUnitsToShortlist(toSafeUnitsToUpgrade, tPotentialUnits)
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for units to upgrade, is table of safe units empty='..tostring(M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade))) end
    if M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade) then
        --Get T2 upgrades if all our land and air are at T2
        if not(tTeamData[iM28Team][refbFocusOnT1Spam]) then
            for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
                if oBrain[M28Economy.refiOurHighestAirFactoryTech] == 2 and not(bOnlyConsiderLandFactory) then
                    if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ)) then
                        tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirHQ * categories.TECH2, false, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Added table of air facs for brain '..oBrain.Nickname..'; is tPotentialUnits empty='..tostring(M28Utilities.IsTableEmpty(tPotentialUnits))) end
                        --Dont add factories that havent built much (for air fac will consider T1+ since may be building inties
                        for iFactory, oFactory in tPotentialUnits do
                            if M28Conditions.GetFactoryLifetimeCount(oFactory, categories.MOBILE - M28UnitInfo.refCategoryAirScout) > 5 or (oBrain[M28Economy.refiOurHighestAirFactoryTech] <= oBrain[M28Economy.refiOurHighestLandFactoryTech]) then
                                AddPotentialUnitsToShortlist(toSafeUnitsToUpgrade, { oFactory })
                            end
                        end
                    end
                end
                if oBrain[M28Economy.refiOurHighestLandFactoryTech] == 2 then
                    if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ)) then
                        tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandHQ * categories.TECH2, false, true)
                        if M28Utilities.IsTableEmpty(tPotentialUnits) == false then
                            for iFactory, oFactory in tPotentialUnits do
                                --Dont add factories that havent built much
                                if M28Conditions.GetFactoryLifetimeCount(oFactory, categories.MOBILE * categories.TECH2) > 6 then
                                    AddPotentialUnitsToShortlist(toSafeUnitsToUpgrade, { oFactory })
                                end
                            end
                        end


                    end
                end
            end
        end
    end

    if M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade) == false then
        local oUnitToUpgrade = M28Economy.GetBestUnitToUpgrade(toSafeUnitsToUpgrade)
        if oUnitToUpgrade then
            if bDebugMessages == true then LOG(sFunctionRef..': Will upgrade factory '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)) end
            M28Economy.UpgradeUnit(oUnitToUpgrade, true)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetAnyMexOrFactoryToUpgrade(iM28Team)
    --Backup logic for finding an upgrade if we have failed to find one through previous searches for a mex or factory; requires the factory to have built something though

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetAnyMexOrFactoryToUpgrade'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local toUnitsThatCouldUpgrade = {}
    local tPotentialUnits
    local bPrioritiseFactory = false
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()) end

    --First consider any t1 factories
    for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
        --if oBrain[M28Economy.refiOurHighestAirFactoryTech] == 1 then
        if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ * categories.TECH1)) then
            tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirHQ * categories.TECH1, false, true)
            AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true, 1)
        end
        --[[elseif oBrain[M28Economy.refiOurHighestAirFactoryTech] == 2 then
            if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ)) then
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirHQ * categories.TECH2, false, true)
                AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true)
            end--]]
        --end
        --if oBrain[M28Economy.refiOurHighestLandFactoryTech] == 1 then
        if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ * categories.TECH1)) then
            tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandHQ * categories.TECH1, false, true)
            AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true, 4)
        end

        if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryNavalHQ * categories.TECH1)) then
            tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryNavalHQ * categories.TECH1, false, true)
            AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true, 4)
        end
        --[[elseif oBrain[M28Economy.refiOurHighestLandFactoryTech] == 2 then
            if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ)) then
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandHQ * categories.TECH2, false, true)
                AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true)
            end --]]
        --end
        tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryT1Mex + M28UnitInfo.refCategoryT2Mex, false, true)
        AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true)
    end
    if M28Utilities.IsTableEmpty(toUnitsThatCouldUpgrade) then
        --If at T3 consider upgrading T2 support factories
        for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
            if oBrain[M28Economy.refiOurHighestAirFactoryTech] >= 3 then
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirFactory - categories.TECH3, false, true)
                if bDebugMessages == true then LOG(sFunctionRef..': We have T3+ air for brain '..oBrian.Nickname..' so will upgrade t2 support factories to T3, oBrain[M28Economy.refiOurHighestAirFactoryTech]='..(oBrain[M28Economy.refiOurHighestAirFactoryTech] or 'nil')..'; Is tPotentialUnits empty='..tostring(M28Utilities.IsTableEmpty(tPotentialUnits))) end
                AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true, 1)
            end
            if oBrain[M28Economy.refiOurHighestLandFactoryTech] >= 3 then
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandFactory - categories.TECH3, false, true)
                if bDebugMessages == true then LOG(sFunctionRef..': We have T3+ land for brain '..oBrain.Nickname..' so will upgrade t2 support factories to T3, oBrain[M28Economy.refiOurHighestLandFactoryTech]='..(oBrain[M28Economy.refiOurHighestLandFactoryTech] or 'nil')..'; Is tPotentialUnits empty='..tostring(M28Utilities.IsTableEmpty(tPotentialUnits))) end
                AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true, 4)
            end
            if oBrain[M28Economy.refiOurHighestNavalFactoryTech] >= 3 then
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryNavalFactory - categories.TECH3, false, true)
                AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true, 4)
            else
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryNavalFactory * categories.TECH1, false, true)
                AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true, 4)
            end
        end

        --If still no units to upgrade, and have positive net mass income and at least 40% mass stored, then consider factory upgrades

    end
    if M28Utilities.IsTableEmpty(toUnitsThatCouldUpgrade) == false then
        local oUnitToUpgrade = M28Economy.GetBestUnitToUpgrade(toUnitsThatCouldUpgrade)
        if bDebugMessages == true then LOG(sFunctionRef..': Have potential units to upgrade, oUnitToUpgrade='..(oUnitToUpgrade.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade) or 'nil')) end
        if oUnitToUpgrade then
            M28Economy.UpgradeUnit(oUnitToUpgrade, true)
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': No potential units to ugprade') end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function HaveEcoToSupportUpgrades(iM28Team)
    --Returns true if we think we can support another upgrade (for normal non-priority logic), but is less likely to return true early game if we want more land factories
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'HaveEcoToSupportUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --Do we have enough energy?
    tTeamData[iM28Team][subrefbTooLittleEnergyForUpgrade] = true --will change to false below if we have enough
    if bDebugMessages == true then LOG(sFunctionRef..': Start, GameTime='..GetGameTimeSeconds()..'; Gross energy='..(tTeamData[iM28Team][subrefiTeamGrossEnergy] or 'nil')..'; % stored='..(tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] or 'nil')..'; Net energy='..(tTeamData[iM28Team][subrefiTeamNetEnergy] or 'nil')..'; tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]='..(tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] or 'nil')..'; Active brain count='..(tTeamData[iM28Team][subrefiActiveM28BrainCount] or 'nil')..'; tTeamData[iM28Team][subrefiTeamGrossEnergy]='..(tTeamData[iM28Team][subrefiTeamGrossEnergy] or 'nil')..'; Net energy='..(tTeamData[iM28Team][subrefiTeamNetEnergy] or 'nil')..'; Min energy per tech='..(M28Economy.tiMinEnergyPerTech[tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]] or 'nil')) end
    if (tTeamData[iM28Team][subrefiTeamGrossEnergy] >= M28Economy.tiMinEnergyPerTech[tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]] * tTeamData[iM28Team][subrefiActiveM28BrainCount] * (1 + (tTeamData[iM28Team][refiHighestBrainResourceMultiplier] - 1)*0.5) or (tTeamData[iM28Team][subrefiTeamNetEnergy] > 5 * tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] * tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] and tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] >= 0.98)) and tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] >= 0.4 and (tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 25 * tTeamData[iM28Team][subrefiActiveM28BrainCount] or tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] >= 0.9) and tTeamData[iM28Team][subrefiTeamNetEnergy] > 0 then
        --If already have active HQ upgrades, then double min energy wanted if net poweri sn't that high
        if tTeamData[iM28Team][subrefiTeamNetEnergy] > 15 or M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) or tTeamData[iM28Team][subrefiTeamGrossEnergy] >= M28Economy.tiMinEnergyPerTech[tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]] * 2 * tTeamData[iM28Team][subrefiActiveM28BrainCount] then
            local iNetEnergyIncomeWanted
            if tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] >= 0.99 then iNetEnergyIncomeWanted = math.max(-tTeamData[iM28Team][subrefiTeamGrossEnergy] * 0.03, -25)
            elseif tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] >= 0.95 then iNetEnergyIncomeWanted = tTeamData[iM28Team][subrefiTeamGrossEnergy] * 0.01
            elseif tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] >= 0.9 then iNetEnergyIncomeWanted = math.max(4, tTeamData[iM28Team][subrefiTeamGrossEnergy] * 0.03)
            elseif tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] >= 0.7 then iNetEnergyIncomeWanted = math.max(6, tTeamData[iM28Team][subrefiTeamGrossEnergy] * 0.06)
            else iNetEnergyIncomeWanted = 100
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Have enough gross energy, iNetEnergyIncomeWanted='..iNetEnergyIncomeWanted) end

            if (tTeamData[iM28Team][subrefiTeamNetEnergy] - tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle] > iNetEnergyIncomeWanted) then
                tTeamData[iM28Team][subrefbTooLittleEnergyForUpgrade] = false
                --Do we have enough mass to support the upgrade?
                local iNetMassIncomeWanted
                if tTeamData[iM28Team][subrefiTeamMassStored] >= 4000 then
                    if tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.9 then iNetMassIncomeWanted = math.min(-30, -tTeamData[iM28Team][subrefiTeamGrossMass] * 0.3)
                    elseif tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.7 then iNetMassIncomeWanted = math.min(-15, -tTeamData[iM28Team][subrefiTeamGrossMass] * 0.25)
                    elseif tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.4 then iNetMassIncomeWanted = math.min(-4, -tTeamData[iM28Team][subrefiTeamGrossMass] * 0.2)
                    elseif tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.3 then iNetMassIncomeWanted = math.min(-3, - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.15)
                    elseif tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.2 then iNetMassIncomeWanted = math.min(-2, - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.1)
                    else iNetMassIncomeWanted = math.min(-1, - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.075) end
                else
                    if tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.9 then iNetMassIncomeWanted = math.min(-1.5, -tTeamData[iM28Team][subrefiTeamGrossMass] * 0.3)
                    elseif tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.7 then iNetMassIncomeWanted = math.min(-1.2, -tTeamData[iM28Team][subrefiTeamGrossMass] * 0.25)
                    elseif tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.4 then iNetMassIncomeWanted = math.min(-0.9, -tTeamData[iM28Team][subrefiTeamGrossMass] * 0.2)
                    elseif tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.3 then iNetMassIncomeWanted = math.min(-0.6, - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.15)
                    elseif tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.2 and tTeamData[iM28Team][subrefiTeamMassStored] >= 600 then iNetMassIncomeWanted = math.min(-0.5, - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.1)
                    elseif tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.1 and tTeamData[iM28Team][subrefiTeamMassStored] >= 325 then iNetMassIncomeWanted = math.min(-0.4, - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.075)
                    elseif tTeamData[iM28Team][subrefiTeamMassStored] >= 325 then iNetMassIncomeWanted = - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.05
                    else iNetMassIncomeWanted = 0.1
                    end
                    --Early game exception - if dont have many land factories then increase net mass income wanted
                    if GetGameTimeSeconds() <= 300 and tTeamData[iM28Team][subrefiTeamMassStored] <= 500 * (1 + (tTeamData[iM28Team][subrefiActiveM28BrainCount] - 1) * 0.5)  and tTeamData[iM28Team][subrefiTeamGrossMass] <= 2 * tTeamData[iM28Team][subrefiActiveM28BrainCount] * tTeamData[iM28Team][refiHighestBrainResourceMultiplier] and M28Conditions.GetTeamLifetimeBuildCount(iM28Team, M28UnitInfo.refCategoryFactory) <= 3 * tTeamData[iM28Team][subrefiActiveM28BrainCount] then
                        iNetMassIncomeWanted = math.max(iNetMassIncomeWanted, 0.05)
                        --Early to t2 stage of the game with a negative net mass income wanted - increase net mass requirements if we have lots of active upgrades
                    elseif iNetMassIncomeWanted < 0 and GetGameTimeSeconds() <= 1200 and tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] <= 2 and tTeamData[iM28Team][subrefiTeamMassStored] <= 2000 and M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) == false then
                        local iActiveUpgradingMexes = table.getn( tTeamData[iM28Team][subreftTeamUpgradingMexes])
                        if iActiveUpgradingMexes >= 2 * tTeamData[iM28Team][subrefiActiveM28BrainCount] then
                            if iActiveUpgradingMexes >= 4 * tTeamData[iM28Team][subrefiActiveM28BrainCount] then
                                iNetMassIncomeWanted = 0
                            else
                                iNetMassIncomeWanted = iNetMassIncomeWanted * 0.5 --we are negative, so this should reduce it
                            end
                        end

                    end
                end

                if tTeamData[iM28Team][subrefiTeamMassStored] >= 5000 then iNetMassIncomeWanted = math.min(-5, iNetMassIncomeWanted - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.02) end

                if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) then
                    iNetMassIncomeWanted = iNetMassIncomeWanted - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.05
                    if tTeamData[iM28Team][subrefiTeamMassStored] >= 600 then iNetMassIncomeWanted = iNetMassIncomeWanted - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.05 end
                else
                    --Adjust net mass income wanted if we will use up our stored mass quickly and have active mex upgrades
                    if (iNetMassIncomeWanted < 0 and tTeamData[iM28Team][subrefiTeamNetMass] < 0) or tTeamData[iM28Team][subrefiTeamMassStored] <= 650 then
                        if tTeamData[iM28Team][subrefiTeamMassStored] <= 400 then iNetMassIncomeWanted = math.max(0, iNetMassIncomeWanted)
                        else
                            local iTimeUntilUseUpStoredMass = tTeamData[iM28Team][subrefiTeamMassStored] / -10 * (tTeamData[iM28Team][subrefiTeamNetMass] - tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle])
                            if iTimeUntilUseUpStoredMass <= 80 then
                                iNetMassIncomeWanted = math.max(-0.2, iNetMassIncomeWanted)
                            elseif iTimeUntilUseUpStoredMass <= 150 and (tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] >= 3 or (tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] >= 2 and GetGameTimeSeconds() - (tTeamData[iM28Team][refiTimeOfLastEnergyStall] or -20) < 20)) then
                                iNetMassIncomeWanted = math.max(-0.2, iNetMassIncomeWanted)
                            end
                        end
                        --Early game or low gross mass - restrict number of upgrades further
                        if (tTeamData[iM28Team][subrefiTeamGrossMass] < 2 * tTeamData[iM28Team][subrefiActiveM28BrainCount] or GetGameTimeSeconds() <= 300) and tTeamData[iM28Team][subrefiTeamMassStored] <= 650 then
                            iNetMassIncomeWanted = math.max(0.8, iNetMassIncomeWanted)
                        end
                    end
                end

                --Very high mass storage level adjustments
                if tTeamData[iM28Team][subrefiTeamMassStored] >= 5000 and iNetMassIncomeWanted <= -1 then
                    --Want to be spending mass at a rate taht means in 75 seconds we will have used up all the amount stored
                    iNetMassIncomeWanted = math.min(iNetMassIncomeWanted, -tTeamData[iM28Team][subrefiTeamGrossMass] * 0.3, -tTeamData[iM28Team][subrefiTeamMassStored] / 75)
                end




                --Average out our mass from the last 5 cycles as well
                local iLowestNetMass = tTeamData[iM28Team][subrefiTeamNetMass]
                for iLastEntry = 1, 5 do
                    iLowestNetMass = math.min(iLowestNetMass, (tTeamData[iM28Team][subreftiPrevTeamNetMass][iLastEntry] or tTeamData[iM28Team][subrefiTeamNetMass]))
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Consideringi f have enough mass, tTeamData[iM28Team][subrefiTeamMassStored]='..tTeamData[iM28Team][subrefiTeamMassStored]..'; % mass stored='..tTeamData[iM28Team][subrefiTeamAverageMassPercentStored]..'; Gross mass income='..tTeamData[iM28Team][subrefiTeamGrossMass]..'; Net mass income='..tTeamData[iM28Team][subrefiTeamNetMass]..'; Net mass wanted='..iNetMassIncomeWanted..'; Is table of upgrading mexes empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]))..'; tTeamData[iM28Team][subreftiPrevTeamNetMass]='..repru(tTeamData[iM28Team][subreftiPrevTeamNetMass])..'; iLowestNetMass - tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]='..iLowestNetMass - tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]..'; tTeamData[iM28Team][refiUpgradedMexCount]='..(tTeamData[iM28Team][refiUpgradedMexCount] or 'nil')) end
                if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) and (tTeamData[iM28Team][refiUpgradedMexCount] or 0) > 0 then iNetMassIncomeWanted = math.min(iNetMassIncomeWanted, 0) end

                if (iLowestNetMass - tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]) > iNetMassIncomeWanted then
                    if bDebugMessages == true then LOG(sFunctionRef..': We have enough energy and mass to get an upgrade; will now factor in if we would rather build more factories if are early game and enemy doesnt have T2, Time='..GetGameTimeSeconds()..'; iLowestNetMass='..iLowestNetMass..'; % mass stored='..tTeamData[iM28Team][subrefiTeamAverageMassPercentStored]..'; Gross mass income='..tTeamData[iM28Team][subrefiTeamGrossMass]..'; Highest enemy tech='..tTeamData[iM28Team][subrefiHighestEnemyGroundTech]..'; Map playable area size='..M28Map.rMapPlayableArea[3] - M28Map.rMapPlayableArea[1]) end
                    if tTeamData[iM28Team][subrefiTeamMassStored] <= 450 and GetGameTimeSeconds() <= 600 and tTeamData[iM28Team][subrefiHighestEnemyGroundTech] <= 1 and M28Map.iMapSize <= 512 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Early game on 10km or smaller map so want to only get a mex upgrade if we have loads of mass') end
                        if tTeamData[iM28Team][subrefiTeamMassStored] <= 600 and (M28Map.iMapSize <= 256 or (iLowestNetMass <= 0.6 * tTeamData[iM28Team][subrefiActiveM28BrainCount] and tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] <= 0.6)) then --or (tTeamData[iM28Team][subrefiTeamMassStored] <= 600 and tTeamData[iM28Team][subrefiTeamGrossMass] < 2 * tTeamData[iM28Team][subrefiActiveM28BrainCount]) then
                            if bDebugMessages == true then LOG(sFunctionRef..': We dont actually have eco to support upgrade due to being early game') end
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return false
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': We still have eco to support upgrade despite being early game') end
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Either not early game or we have lots of mass stored so think we have eco to get upgrade') end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': We dont have the eco to get an upgrade') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end


function ConsiderNormalUpgrades(iM28Team)
    --We should have already considered high priority upgrades before, now we want to consider upgrades if we have the eco to support upgrades generally
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderNormalUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iMassUpgradesAtLoopStart
    local iCycleCount = 0

    local bLookForMexNotHQ

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, HaveEcoToSupportUpgrades for iM28Team '..iM28Team..'='..tostring(HaveEcoToSupportUpgrades(iM28Team))..'; Is table of mex upgrades empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]))..'; Is table of factory upgrades empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]))) end
    --Dont proceed with upgrade even if we have the eco to support it, if we are under a critical threat from navy
    local bWantMassForProduction = false
    for _, iAirSubteam in tTeamData[iM28Team][subrefAirSubteamsInTeam] do
        if tAirSubteamData[iAirSubteam][refbNoAvailableTorpsForEnemies] then
            bWantMassForProduction = true
            break
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': bWantMassForProduction='..tostring(bWantMassForProduction)..'; Is table of upgrading mexes empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]))..'; Is table of upgrading HQs empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]))..'; tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]) end
    if not(bWantMassForProduction) or (M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) and M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs])) or tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.3 or tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] <= 1 then
        --T1 spam mode - be much less likely to get upgrades early game
        if not(tTeamData[iM28Team][refbFocusOnT1Spam]) or (M28Overseer.bLikelyGunUpgrade and (M28Map.iMapSize > 256 or GetGameTimeSeconds() >= 480)) or M28Conditions.GetTeamLifetimeBuildCount(iM28Team, M28UnitInfo.refCategoryFactory) >= 10 or (M28Conditions.GetCurrentM28UnitsOfCategoryInTeam(M28UnitInfo.refCategoryFactory, iM28Team) >= 6 and tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.75 and (tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.95 or GetGameTimeSeconds() >= 300 / math.max(tTeamData[iM28Team][refiHighestBrainResourceMultiplier], tTeamData[iM28Team][refiHighestBrainBuildMultiplier]))) then

            while HaveEcoToSupportUpgrades(iM28Team) do
                iCycleCount = iCycleCount + 1
                iMassUpgradesAtLoopStart = tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] --so we can check we actually upgraded something
                if bDebugMessages == true then LOG(sFunctionRef..': We think we have enough eco to support another upgrade, will decide if we want a mex or a factoroy, iCycleCOunt='..iCycleCount) end

                bLookForMexNotHQ = not(tTeamData[iM28Team][refbFocusOnT1Spam])

                --Get preferred upgrade type - ideally are always improving mass income (if have safe mexes to upgrade)
                if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) == false then
                    --Already have mexes upgrading - do we want to also upgrade an HQ instead of a mex?
                    if (tTeamData[iM28Team][subrefiTeamGrossMass] >= 2.5 and (tTeamData[iM28Team][subrefiTeamGrossMass] >= 5 and (tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 1 or tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] == 1) or (tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 1 and tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] == 1))) or ((tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 2 or tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] == 2) and tTeamData[iM28Team][subrefiTeamGrossMass] >= 8) then
                        --Do we already ahve a factory HQ upgrading? If so then consider income based on player count
                        if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) then
                            bLookForMexNotHQ = false
                        else
                            if (tTeamData[iM28Team][subrefiTeamGrossMass] >= math.max(1.5, tTeamData[iM28Team][subrefiActiveM28BrainCount]) * 5 and (tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 1 or tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] == 1)) or ((tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 2 or tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] == 2) and tTeamData[iM28Team][subrefiTeamGrossMass] >= math.max(1.5, tTeamData[iM28Team][subrefiActiveM28BrainCount]) * 8) then
                                bLookForMexNotHQ = false
                            end
                        end
                    end
                else
                    --No mex ugprading, but might want factory if we dont have access to T2/T3 yet and have high mass income
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have a mex upgrading, will see if want a factory instead of a mex, tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech='..tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech]..'; tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]..'; tTeamData[iM28Team][subrefiTeamGrossMass]='..tTeamData[iM28Team][subrefiTeamGrossMass]..'; Player count='..tTeamData[iM28Team][subrefiActiveM28BrainCount]..'; tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]) end
                    if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) then --since no mex upgrading, dont want to upgrade more than 1 factory at once
                        if tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] == 1 then
                            if tTeamData[iM28Team][subrefiTeamGrossMass] >= math.max(1, tTeamData[iM28Team][subrefiActiveM28BrainCount] * 0.7) * 4 and tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 25 * math.max(1, tTeamData[iM28Team][subrefiActiveM28BrainCount] * 0.75) then
                                bLookForMexNotHQ = false
                            end
                        elseif tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] == 2 then
                            if tTeamData[iM28Team][subrefiTeamGrossMass] > 8 * math.max(1, tTeamData[iM28Team][subrefiActiveM28BrainCount] * 0.7) and tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 100 then
                                bLookForMexNotHQ = false
                            end
                        end
                    end

                end
                if bDebugMessages == true then LOG(sFunctionRef..': iCycleCount='..iCycleCount..'; bLookForMexNotHQ='..tostring(bLookForMexNotHQ)..'; Is table of upgrading mexes empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]))..'; Is table of upgrading HQs empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]))..'; Team gross mass='..tTeamData[iM28Team][subrefiTeamGrossMass]..'; Lowest land fac tech='..tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]..'; Lowest air fac tech='..tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech]) end
                if bLookForMexNotHQ then
                    GetSafeMexToUpgrade(iM28Team)
                    --Backup - if didnt find anything then get a HQ upgrade if we dont already ahve a HQ upgrade active
                    if bDebugMessages == true then LOG(sFunctionRef..': Tried to get a mex upgrade, tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]='..tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]..'; iMassUpgradesAtLoopStart='..iMassUpgradesAtLoopStart) end
                    if tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] == iMassUpgradesAtLoopStart then
                        if tTeamData[iM28Team][subrefiTeamGrossMass] >= 4 and M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Trying backup HQ upgrade as no mexes could be found') end
                            GetSafeHQUpgrade(iM28Team)
                        end
                    end
                else
                    GetSafeHQUpgrade(iM28Team)
                    if tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] == iMassUpgradesAtLoopStart and (not(tTeamData[iM28Team][refbFocusOnT1Spam]) or tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.8) then
                        GetSafeMexToUpgrade(iM28Team)
                    end
                end
                --If failed to find a mex or HQ upgrade from above:
                if tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] == iMassUpgradesAtLoopStart then
                    --Only consider upgrading if have lots of mass
                    if tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.5 and tTeamData[iM28Team][subrefiTeamMassStored] >= 700 and (tTeamData[iM28Team][subrefiTeamMassStored] >= 7000 or (tTeamData[iM28Team][subrefiTeamMassStored] >= 4000 and tTeamData[iM28Team][subrefiTeamNetMass] > -1) or tTeamData[iM28Team][subrefiTeamNetMass] > 0.5) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and get any mex or HQ to upgrade as failed to find something to upgrade and have lots of mass, tTeamData[iM28Team][subrefiTeamNetMass]='..tTeamData[iM28Team][subrefiTeamNetMass]..'; mass stored='..tTeamData[iM28Team][subrefiTeamMassStored]) end
                        GetAnyMexOrFactoryToUpgrade(iM28Team)
                    end
                end

                --Keep searching for upgrades (if we have the eco to support) if we have just found something to upgrade
                if tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] > iMassUpgradesAtLoopStart then
                    if iCycleCount >= 50 then
                        M28Utilities.ErrorHandler('Likely infinite loop')
                        break
                    end
                else
                    --Failed ot upgrade anything so abort to avoid risk of infinite loop
                    break
                end
                if bWantMassForProduction then break end
            end
        end
    end

    --T2 land factory exception even if dont have eco to support upgrades - if have a lot of mass, then consider upgrading even if lack energy
    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering normal upgrades; will now consider if we want a T2 factory even if we have low energy. tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]..'; tTeamData[iM28Team][subrefiTeamGrossMass]='..tTeamData[iM28Team][subrefiTeamGrossMass]..'; tTeamData[iM28Team][subrefiTeamGrossEnergy]='..tTeamData[iM28Team][subrefiTeamGrossEnergy]..'; tTeamData[iM28Team][subrefiTeamNetEnergy]='..tTeamData[iM28Team][subrefiTeamNetEnergy]..'; Stored mass='..tTeamData[iM28Team][subrefiTeamMassStored]..'; Is table of upgrading HQs empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]))..'; tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]='..tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]..'; tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]='..tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]) end
    if tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] == 1 and tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 1 and tTeamData[iM28Team][subrefiTeamGrossMass] >= 4 and tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 25 and (tTeamData[iM28Team][subrefiTeamNetEnergy] > 0 or tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 40) and tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] == 0 and (M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) or tTeamData[iM28Team][subrefiTeamMassStored] >= 500) and M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) then
        if bDebugMessages == true then LOG(sFunctionRef..': Dont have good eco but will get land fac upgrade anyway to help improve energy long term as are only at T1') end
        GetSafeHQUpgrade(iM28Team, true)
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderGettingUpgrades(iM28Team)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderGettingUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored]='..tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored]..'; Stalling energy='..tostring(tTeamData[iM28Team][subrefbTeamIsStallingEnergy])..'; Stalling mass='..tostring(tTeamData[iM28Team][subrefbTeamIsStallingMass])..'; tTeamData[iM28Team][subrefiTeamGrossMass]='..tTeamData[iM28Team][subrefiTeamGrossMass]..'; tTeamData[iM28Team][subrefiTeamGrossEnergy]='..tTeamData[iM28Team][subrefiTeamGrossEnergy]..'; tTeamData[iM28Team][subrefiTeamMassStored]='..tTeamData[iM28Team][subrefiTeamMassStored]..'; tTeamData[iM28Team][subrefiTeamAverageMassPercentStored]='..tTeamData[iM28Team][subrefiTeamAverageMassPercentStored]..'; tTeamData[iM28Team][subrefiTeamNetEnergy]='..tTeamData[iM28Team][subrefiTeamNetEnergy]) end
    if tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] >= 0.6 and (GetGameTimeSeconds() >= 150 or (GetGameTimeSeconds() >= 60 and GetGameTimeSeconds() >= 150 / tTeamData[iM28Team][refiHighestBrainResourceMultiplier]) or (tTeamData[iM28Team][subrefiTeamGrossMass] >= 3 * tTeamData[iM28Team][subrefiActiveM28BrainCount] and tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 50 * tTeamData[iM28Team][subrefiActiveM28BrainCount]) or (tTeamData[iM28Team][subrefiTeamMassStored] >= 700 and tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.9 and tTeamData[iM28Team][subrefiTeamNetEnergy] >= 3 and tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] >= 0.95) or (M28Map.bIsLowMexMap and tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] >= 0.5 and tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] >= 0.99 or (tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 6 * tTeamData[iM28Team][subrefiActiveM28BrainCount]))) and not(tTeamData[iM28Team][subrefbTeamIsStallingEnergy]) then
        --Further general eco conditions on upgrading early game
        if GetGameTimeSeconds() >= 300 or M28Map.bIsCampaignMap or GetGameTimeSeconds() >= 60 + 240 / (0.5 + tTeamData[iM28Team][refiHighestBrainResourceMultiplier] * 0.5) - 30 * math.min(3, math.max(0, tTeamData[iM28Team][subrefiActiveM28BrainCount] - 1.5)) or tTeamData[iM28Team][subrefiTeamGrossMass] >= 6 * tTeamData[iM28Team][subrefiActiveM28BrainCount] * (0.5 + tTeamData[iM28Team][refiHighestBrainResourceMultiplier] * 0.5) or (tTeamData[iM28Team][subrefiTeamMassStored] >= 700 and tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.4) or M28Map.bIsLowMexMap or M28Overseer.bNoRushActive then
            if bDebugMessages == true then LOG(sFunctionRef..': Have enough energy that we will check for priority upgrades and then normal upgrades') end
            tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] = 0
            tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle] = 0

            --Priority upgrades even with poor eco:
            if (not(tTeamData[iM28Team][subrefbTeamIsStallingMass]) or (M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) and M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]))) then
                ConsiderPriorityLandFactoryUpgrades(iM28Team)

                ConsiderPriorityAirFactoryUpgrades(iM28Team)

                ConsiderPriorityNavalFactoryUpgrades(iM28Team)

                --Consider priority mex upgrades (e.g. we are falling far behind enemy on eco)
                ConsiderPriorityMexUpgrades(iM28Team)

                ConsiderNormalUpgrades(iM28Team)
            elseif tTeamData[iM28Team][subrefbTeamIsStallingMass] then
                --Want to keep upgrading mexes even if stalling mass
                --Also still consider upgrading HQ if have no upgrading HQs
                if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) and M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) == false and tTeamData[iM28Team][subrefiTeamGrossMass] >= 4 * tTeamData[iM28Team][subrefiActiveM28BrainCount] * tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] then
                    if tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] == 1 then ConsiderPriorityLandFactoryUpgrades(iM28Team) else ConsiderPriorityAirFactoryUpgrades(iM28Team) end
                    if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) then
                        if tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] == 1 then ConsiderPriorityAirFactoryUpgrades(iM28Team) else ConsiderPriorityLandFactoryUpgrades(iM28Team) end
                        if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) then
                            ConsiderPriorityNavalFactoryUpgrades(iM28Team)
                        end
                    end
                end
                ConsiderPriorityMexUpgrades(iM28Team)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TeamEconomyRefresh(iM28Team)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TeamEconomyRefresh'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for team '..iM28Team..' at time='..GetGameTimeSeconds()..'; M28Map.bMapLandSetupComplete='..tostring(M28Map.bMapLandSetupComplete)..'; bWaterZoneInitialCreation='..tostring(M28Map.bWaterZoneInitialCreation)) end
    if M28Map.bMapLandSetupComplete and M28Map.bWaterZoneInitialCreation then
        tTeamData[iM28Team][subrefiTeamGrossEnergy] = 0
        tTeamData[iM28Team][subrefiTeamNetEnergy] = 0
        tTeamData[iM28Team][subrefiTeamGrossMass] = 0
        tTeamData[iM28Team][subrefiTeamNetMass] = 0
        tTeamData[iM28Team][subrefiTeamEnergyStored] = 0
        tTeamData[iM28Team][subrefiTeamMassStored] = 0
        tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] = 1
        tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] = 1
        tTeamData[iM28Team][subrefiLowestEnergyStorageCount] = 100

        local iEnergyPercentTotal = 0
        local iMassPercentTotal = 0
        local iEnergyBrainCount = 0
        local iMassBrainCount = 0


        for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
            tTeamData[iM28Team][subrefiTeamGrossEnergy] = tTeamData[iM28Team][subrefiTeamGrossEnergy] + oBrain[M28Economy.refiGrossEnergyBaseIncome]
            tTeamData[iM28Team][subrefiTeamGrossMass] = tTeamData[iM28Team][subrefiTeamGrossMass] + oBrain[M28Economy.refiGrossMassBaseIncome]
            --Adjust gross values if the recorded values seem significantly differnet - decided to leave out as there seems to be a 1 tick delay which causes discrepencies
            --[[if math.abs(oBrain[M28Economy.refiGrossEnergyBaseIncome] - oBrain:GetEconomyIncome('ENERGY')) >= math.max(30, oBrain[M28Economy.refiGrossEnergyBaseIncome] * 0.1) then
                M28Utilities.ErrorHandler('We have calculated gross energy income to be '..oBrain[M28Economy.refiGrossEnergyBaseIncome]..'; including reclaim though it appears to be '..oBrain:GetEconomyIncome('ENERGY')..'; will use the system generated value as wouldnt expect reclaim to cause such a big difference', true)
                oBrain[M28Economy.refiGrossEnergyBaseIncome] = oBrain:GetEconomyIncome('ENERGY')
            end--]]

            tTeamData[iM28Team][subrefiTeamNetEnergy] = tTeamData[iM28Team][subrefiTeamNetEnergy] + oBrain[M28Economy.refiNetEnergyBaseIncome]
            tTeamData[iM28Team][subrefiTeamNetMass] = tTeamData[iM28Team][subrefiTeamNetMass] + oBrain[M28Economy.refiNetMassBaseIncome]


            if oBrain:GetEconomyStored('ENERGY') > 0 then
                iEnergyPercentTotal = iEnergyPercentTotal + oBrain:GetEconomyStoredRatio('ENERGY')
                tTeamData[iM28Team][subrefiTeamEnergyStored] = tTeamData[iM28Team][subrefiTeamEnergyStored] + oBrain:GetEconomyStored('ENERGY')
                iEnergyBrainCount = iEnergyBrainCount + 1
            end

            if oBrain:GetEconomyStored('MASS') > 0 then
                tTeamData[iM28Team][subrefiTeamMassStored] = tTeamData[iM28Team][subrefiTeamMassStored] + oBrain:GetEconomyStored('MASS')
                iMassPercentTotal = iMassPercentTotal + oBrain:GetEconomyStoredRatio('MASS')
                iMassBrainCount = iMassBrainCount + 1
            end

            --tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] = math.min(tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored], oBrain:GetEconomyStoredRatio('ENERGY'))
            --tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] = math.min(tTeamData[iM28Team][subrefiTeamAverageMassPercentStored], oBrain:GetEconomyStoredRatio('MASS'))
            tTeamData[iM28Team][subrefiLowestEnergyStorageCount] = math.min(tTeamData[iM28Team][subrefiLowestEnergyStorageCount], oBrain:GetCurrentUnits(M28UnitInfo.refCategoryEnergyStorage + M28UnitInfo.refCategoryParagon + M28UnitInfo.refCategoryQuantumOptics))
            if bDebugMessages == true then LOG(sFunctionRef..': Considering brain '..oBrain.Nickname..'; Brain mass stored='..oBrain:GetEconomyStored('MASS')..'; Percent stored='..oBrain:GetEconomyStoredRatio('MASS')..'; iMassPercentTotal='..iMassPercentTotal..'; iEnergyPercentTotal='..iEnergyPercentTotal..'; oBrain:IsDefeated()='..tostring(oBrain:IsDefeated())..'; oBrain.M28IsDefeated='..tostring(oBrain.M28IsDefeated or false)) end
        end
        tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] = iMassPercentTotal / math.max(1, iMassBrainCount)
        tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] = iEnergyPercentTotal / math.max(1, iEnergyBrainCount)

        if tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] <= 0.05 and (GetGameTimeSeconds() >= 120 or tTeamData[iM28Team][subrefiTeamAverageEnergyPercentStored] <= 0.001) then tTeamData[iM28Team][subrefbTeamIsStallingEnergy] = true end
        if tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] == 0 and tTeamData[iM28Team][subrefiTeamMassStored] < tTeamData[iM28Team][subrefiActiveM28BrainCount] * 25 then
            if not(tTeamData[iM28Team][subrefbTeamIsStallingMass]) then tTeamData[iM28Team][subrefbStallingMassFlaggedFromTeamEconomy] = true end
            tTeamData[iM28Team][subrefbTeamIsStallingMass] = true
            tTeamData[iM28Team][refiTimeOfLastMassStall] = GetGameTimeSeconds()
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Prev team net mass before update='..repru(tTeamData[iM28Team][subreftiPrevTeamNetMass])) end
        for iLastEntry = 5, 2, -1 do
            tTeamData[iM28Team][subreftiPrevTeamNetMass][iLastEntry] = (tTeamData[iM28Team][subreftiPrevTeamNetMass][iLastEntry-1] or 0)
        end
        tTeamData[iM28Team][subreftiPrevTeamNetMass][1] = tTeamData[iM28Team][subrefiTeamNetMass]
        if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Prev team net mass after update='..repru(tTeamData[iM28Team][subreftiPrevTeamNetMass])..'; team net mass='..tTeamData[iM28Team][subrefiTeamNetMass]..'; Team new gross mass='..tTeamData[iM28Team][subrefiTeamGrossMass]..'; tTeamData[iM28Team][subrefiTeamAverageMassPercentStored]='..tTeamData[iM28Team][subrefiTeamAverageMassPercentStored]) end

        ForkThread(ConsiderGettingUpgrades, iM28Team)

        ForkThread(M28Economy.ManageEnergyStalls, iM28Team)

        if tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] >= 0.9 then
            if bDebugMessages == true then LOG(sFunctionRef..': Are overflowing mass so will try and manage by clearing engineers with reclaim orders') end
            if tTeamData[iM28Team][subrefiTeamMassStored] < 200 then
                local iTeamMaxMassStorage = 0
                for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
                    iTeamMaxMassStorage = iTeamMaxMassStorage + oBrain[M28Economy.refiMaxMassStorage]
                end
                if iTeamMaxMassStorage < 200 then
                    --E.g. sandbox games we might still have units but no storage capacity
                    if tTeamData[iM28Team][subrefiTeamNetMass] < 0 then
                        tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] = 0.2 --Avoids some of the 'we are overflowing mass majorly' logic
                    else
                        tTeamData[iM28Team][subrefiTeamAverageMassPercentStored] = 0.5 --Avoids some of the 'we are overflowing mass majorly' logic
                    end
                else
                    M28Utilities.ErrorHandler('We think we are overflowing mass but we have less than 200 stored; if have engineer in core base we should try and build mass storage soon, iM28Team='..(iM28Team or 'nil')..'; Active M28 on team='..tTeamData[iM28Team][subrefiActiveM28BrainCount]..'; iTeamMaxMassStorage='..iTeamMaxMassStorage)
                    if bDebugMessages == true then
                        for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
                            LOG(sFunctionRef..': oBrain='..oBrain.Nickname..'; Is defeated='..tostring(oBrain:IsDefeated())..'; M28IsDefeated='..tostring(oBrain.M28IsDefeated or false)..'; Cur units='..oBrain:GetCurrentUnits(categories.ALLUNITS)..'; ScenarioInfo.Options.Victory='..(ScenarioInfo.Options.Victory or 'nil'))
                        end
                    end
                end
            end
            ForkThread(M28Economy.ManageMassOverflow, iM28Team)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckEnemyACUStatus(iTeam)
    if not(tTeamData[iTeam][refbEnemyHasUpgradedACU]) then
        local aiBrain
        for iBrain, oBrain in tTeamData[iTeam][subreftoFriendlyActiveM28Brains] do
            aiBrain = oBrain
            break
        end
        if M28Utilities.IsTableEmpty(tTeamData[iTeam][reftEnemyACUs]) == false then
            for iACU, oACU in  tTeamData[iTeam][reftEnemyACUs] do
                if M28UnitInfo.IsUnitValid(oACU) and (GetGameTimeSeconds() >= 600 or (aiBrain.GetArmyIndex and M28UnitInfo.CanSeeUnit(aiBrain, oACU))) then --after 10m of gametime a human would assume enemy will have gun anyway
                    if oACU:IsUnitState('Upgrading') or (oACU[M28ACU.refiUpgradeCount] or 0) > 0 then
                        tTeamData[iTeam][refbEnemyHasUpgradedACU] = true
                    end
                end
            end
        end
    end
end
function CheckForUnitsWithDisabledWeapons(iTeam)
    if M28Utilities.IsTableEmpty(tTeamData[iTeam][reftoUnitsWithDisabledWeapons]) == false then
        local iRecordedUnits = table.getn(tTeamData[iTeam][reftoUnitsWithDisabledWeapons])
        for iCurUnit = iRecordedUnits, 1, -1 do
            local oUnit = tTeamData[iTeam][reftoUnitsWithDisabledWeapons][iCurUnit]
            if M28UnitInfo.IsUnitValid(oUnit) then
                --Has it been a while since we last wanted to disable the weapon?
                if GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeLastDisabledWeapon] or 0) >= 2.01 then
                    M28UnitInfo.EnableUnitWeapon(oUnit)
                end
            else
                --Unit not valid, remove from table
                table.remove(tTeamData[iTeam][reftoUnitsWithDisabledWeapons], iCurUnit)
            end
        end
    end
end

function TeamOverseer(iM28Team)
    while tTeamData[iM28Team][subrefiActiveM28BrainCount] > 0 do
        ForkThread(TeamEconomyRefresh, iM28Team)
        ForkThread(CheckEnemyACUStatus, iM28Team)
        ForkThread(CheckForUnitsWithDisabledWeapons, iM28Team)
        ForkThread(RefreshRecentEnemyTeleportLocations, iM28Team)
        WaitTicks(10)
    end
end

function TeamInitialisation(iM28Team)
    --First check if we have any M28 brains in this team (otherwise dont do anything further)
    --NOTE: CreateNewTeam function includes various team setup variables
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TeamInitialisation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Will initialise team based logic for the team '..iM28Team..'; Is the table of friendly active M28 brains empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftoFriendlyActiveM28Brains]))..'; Do we already have an active team cycler='..tostring(tTeamData[iM28Team]['M28TeamActiveTeamCycler'] or false)) end

    M28Map.bFirstM28TeamHasBeenInitialised = true
    if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftoFriendlyActiveM28Brains]) == false then
        if not(tTeamData[iM28Team]['M28TeamActiveTeamCycler']) then
            tTeamData[iM28Team]['M28TeamActiveTeamCycler'] = true
            if bDebugMessages == true then LOG(sFunctionRef..': About to start land zone overseer which carries out main over time loop') end
            ForkThread(M28Land.LandZoneOverseer, iM28Team)
            ForkThread(TeamOverseer, iM28Team)
            ForkThread(M28Economy.TeamResourceSharingMonitor, iM28Team)
            ForkThread(M28Navy.WaterZoneOverseer, iM28Team)
            ForkThread(SnipeOverseer, iM28Team)
        end
    end

    --Include variables for land zones
    for iPlateau, tPlateauData in M28Map.tAllPlateaus do
        for iLZ, tLZData in tPlateauData[M28Map.subrefPlateauLandZones] do
            if bDebugMessages == true then LOG(sFunctionRef..': Recording team data for iPlateau='..iPlateau..'; iLZ='..iLZ..'; iTeam='..iM28Team) end
            if not(tLZData[M28Map.subrefLZTeamData]) then tLZData[M28Map.subrefLZTeamData] = {} end
            tLZData[M28Map.subrefLZTeamData][iM28Team] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subreftoLZOrWZAlliedUnits] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefTEnemyUnits] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefMexCountByTech] = {[1]=0,[2]=0,[3]=0}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZTValue] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZSValue] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefAlliedACU] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefTThreatEnemyCombatTotal] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatEnemyBestMobileDFRange] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatEnemyBestStructureDFRange] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatEnemyBestMobileIndirectRange] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZIndirectThreatWanted] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZDFThreatWanted] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.refiRadarCoverage] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.refiOmniCoverage] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.refiEnemyOmniCoverage] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.refiRecentlyFailedScoutAttempts] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefQueuedBuildings] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatEnemyMobileDFTotal] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatEnemyMobileIndirectTotal] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatAllyMobileDFTotal] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatAllyMobileIndirectTotal] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatAllyMAA] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatAllyGroundAA] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefThreatEnemyStructureTotalMass] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.reftLZEnemyAirUnits] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.refiEnemyAirToGroundThreat] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.refiEnemyAirAAThreat] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.refiEnemyAirOtherThreat] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZMAAThreatWanted] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.reftoLZUnitsWantingMobileShield] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.reftoLZUnitWantingFixedShield] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.reftPriorityShieldsToAssist] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.reftoLZUnitsWantingMobileStealth] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subreftEnemyFirebasesInRange] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.reftUnitsWantingTMD] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.reftoTransportsWaitingForUnits] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subreftoEnemyTMD] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subreftoEnemyPotentialTMLTargets] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefiAvailableMobileShieldThreat] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.refiNonM28TeammateFactoryCount] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.refiNonM28TeammateMexCount] = 0
        end
    end
    --NOTE: Water zone data is handled via RecordClosestAllyAndEnemyBaseForEachWaterZone, to ensure it is run after water zones are created
    if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftoFriendlyActiveM28Brains]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Team has active M28 brains, iM28Team='..iM28Team..'; Time='..GetGameTimeSeconds()..'; bWaterZoneInitialCreation='..tostring(M28Map.bWaterZoneInitialCreation or false)) end
        TeamEconomyRefresh(iM28Team)
        ForkThread(M28Map.RecordClosestAllyAndEnemyBaseForEachLandZone, iM28Team)
        ForkThread(M28Map.RecordClosestAllyAndEnemyBaseForEachWaterZone, iM28Team)
        M28Air.AirTeamInitialisation(iM28Team)
        local iM28Count = 0
        for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
            iM28Count = iM28Count + 1
        end
        tTeamData[iM28Team][subrefiOrigM28BrainCount] = iM28Count

    else
        tTeamData[iM28Team][subrefiOrigM28BrainCount] = 0
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SetWaterZoneDefaultTeamValues(tWZData, iTeam)
    if not(tWZData[M28Map.subrefWZTeamData]) then tWZData[M28Map.subrefWZTeamData] = {} end
    if not(tWZData[M28Map.subrefWZTeamData][iTeam]) then tWZData[M28Map.subrefWZTeamData][iTeam] = {} end
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefMexCountByTech] = {[1]=0,[2]=0,[3]=0}
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZbCoreBase] = false --true if is a 'core' base (i.e. has a naval factory in)
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZbContainsNavalBuildLocation] = false --true if contains a naval build location for a friendly M28AI
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZTValue] = 0 --Value of the WZ, used to prioritise sending untis to different water zones; likely to be based on distance to core base water zone
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiRadarCoverage] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiSonarCoverage] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiOmniCoverage] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiEnemyOmniCoverage] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiRecentlyFailedScoutAttempts] = 0
    --tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refoBestRadar] --nil by default
    --tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.reftClosestFriendlyBase] --Updated separately
    --tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.reftClosestEnemyBase] --Updated separately
    --tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiModDistancePercent] --Updated separately
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refbWantLandScout] = false

    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subreftoLZOrWZAlliedUnits] = {}
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZTAlliedCombatUnits] = {}
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits] = {}
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.reftWZEnemyAirUnits] = {}
    --Threat values
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentWZ] = false

    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatEnemyAntiNavy] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatEnemySubmersible] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatEnemySurface] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatEnemyAA] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZBestEnemyDFRange] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZBestEnemyAntiNavyRange] = 0

    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.reftoNearestCombatEnemies] = {}

    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefThreatEnemyStructureTotalMass] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZTThreatAllyCombatTotal] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatAlliedAntiNavy] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatAlliedSubmersible] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatAlliedSurface] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatAlliedAA] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatAlliedMAA] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZBestAlliedDFRange] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZBestAlliedSubmersibleRange] = 0

    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZCombatThreatWanted] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZMAAThreatWanted] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefbWZWantsSupport] = false

    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.reftoWZUnitsWantingMobileShield] = {}
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refbWZWantsMobileShield] = false
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.reftoWZUnitsWantingMobileStealth] = {}
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refbWZWantsMobileStealth] = false

    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefTScoutsTravelingHere] = {}

    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiEnemyAirToGroundThreat] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiEnemyAirAAThreat] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.refiEnemyAirOtherThreat] = 0
    tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefAlliedACU] = {}

    iCurPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tWZData[M28Map.subrefMidpoint])
    if iCurPlateau then
        if not(tTeamData[iTeam][subrefiWaterZonesWantingSignificantMAAByPlateau][iCurPlateau]) then tTeamData[iTeam][subrefiWaterZonesWantingSignificantMAAByPlateau][iCurPlateau] = {} end
    end
end

function WaterZoneTeamInitialisation(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'WaterZoneTeamInitialisation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iCurPlateau
    M28Map.bWaterZoneFirstTeamInitialisation = true
    tTeamData[iTeam][subrefiWaterZonesWantingSignificantMAAByPlateau] = {}
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at gamestime='..GetGameTimeSeconds()..', iTeam='..iTeam) end
    for iPond, tPondSubtable in M28Map.tPondDetails do
        for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
            if bDebugMessages == true then LOG(sFunctionRef..': Setting starting values for iPond='..iPond..'; iWaterZone='..iWaterZone) end
            SetWaterZoneDefaultTeamValues(tWZData, iTeam)
        end
    end
    --Record any start positions of friendly M28AI that are on water as waterstartposition for team data
    local tUnderwaterM28StartPoints = {}
    for iBrain, oBrain in tTeamData[iTeam][subreftoFriendlyActiveM28Brains] do
        local iStartPositionX, iStartPositionZ = M28Map.GetPlayerStartPosition(oBrain, true)
        local tStartPoint = {iStartPositionX, GetSurfaceHeight(iStartPositionX, iStartPositionZ), iStartPositionZ}
        if bDebugMessages == true then LOG(sFunctionRef..': tStartPoint='..repru(tStartPoint)..'; iStartPositionX='..iStartPositionX..'; iStartPositionZ='..iStartPositionZ..'; Surface height='..GetSurfaceHeight(iStartPositionX, iStartPositionZ)..'; Terrain height='..GetTerrainHeight(iStartPositionX, iStartPositionZ)) end
        if GetTerrainHeight(iStartPositionX, iStartPositionZ) < tStartPoint[2] then
            table.insert(tUnderwaterM28StartPoints, tStartPoint )
        end
    end
    if M28Utilities.IsTableEmpty(tUnderwaterM28StartPoints) == false then
        for iEntry, tStartPoint in tUnderwaterM28StartPoints do
            local iPlateauOrZero, iWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tStartPoint)
            if iPlateauOrZero == 0 and (iWaterZone or 0) > 0 then
                local tWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][iTeam]
                tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] = true
                if bDebugMessages == true then LOG(sFunctionRef..': Recording that iWaterzone'..iWaterZone..' is underwater for the M28 start position '..repru(tStartPoint)) end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateEnemyTechTracking(iM28Team, oUnit)
    local iUnitTechLevel = M28UnitInfo.GetUnitTechLevel(oUnit)
    if EntityCategoryContains(categories.LAND, oUnit.UnitId) then
        tTeamData[iM28Team][subrefiHighestEnemyGroundTech] = math.max(tTeamData[iM28Team][subrefiHighestEnemyGroundTech], iUnitTechLevel)
        if not(tTeamData[iM28Team][refbEnemyHasPerciesOrBricks]) then
            if oUnit.UnitId == 'xel0305' or oUnit.UnitId == 'xrl0305' then tTeamData[iM28Team][refbEnemyHasPerciesOrBricks] = true end
        end
    elseif EntityCategoryContains(categories.AIR, oUnit.UnitId) then tTeamData[iM28Team][subrefiHighestEnemyAirTech] = math.max(tTeamData[iM28Team][subrefiHighestEnemyAirTech], iUnitTechLevel)
    elseif EntityCategoryContains(categories.NAVAL, oUnit.UnitId) then tTeamData[iM28Team][subrefiHighestEnemyNavyTech] = math.max(tTeamData[iM28Team][subrefiHighestEnemyNavyTech], iUnitTechLevel)
    end
end

function GetCurrentUnitsOfCategory(iM28Team, iCategory)
    local iCurUnits = 0
    for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
        iCurUnits = iCurUnits + oBrain:GetCurrentUnits(iCategory)
    end
    return iCurUnits
end

function TransferUnitsToPlayer(tUnits, iArmyIndex, bCaptured)
    import('/lua/SimUtils.lua').TransferUnitsOwnership(tUnits, iArmyIndex, bCaptured)
end

function DelayedUnitTransferToPlayer(tUnits, iReceivingBrainIndex, iSecondsToWait)
    WaitSeconds(iSecondsToWait)
    TransferUnitsToPlayer(tUnits, iReceivingBrainIndex, false)
end

function GiveAllResourcesToAllies(aiBrain)
    local iMassToGive = aiBrain:GetEconomyStored('MASS')
    local iEnergyToGive = aiBrain:GetEconomyStored('ENERGY')
    local iSpareMassStorage
    local iSpareEnergyStorage
    for iBrain, oBrain in tTeamData[aiBrain.M28Team][subreftoFriendlyHumanAndAIBrains] do
        if not(oBrain.M28IsDefeated) then
            iSpareMassStorage = 0
            iSpareEnergyStorage = 0
            if iMassToGive > 0 and aiBrain:GetEconomyStoredRatio('MASS') < 1 then
                iSpareMassStorage = M28Economy.GetMassStorageMaximum(aiBrain) * (1 -aiBrain:GetEconomyStoredRatio('MASS'))
            end
            if iEnergyToGive > 0 and aiBrain:GetEconomyStoredRatio('ENERGY') < 1 then
                iSpareEnergyStorage = M28Economy.GetEnergyStorageMaximum(aiBrain) * (1 -aiBrain:GetEconomyStoredRatio('ENERGY'))
            end

            if iSpareMassStorage + iSpareEnergyStorage > 0 then
                M28Economy.GiveResourcesToPlayer(aiBrain, oBrain, math.min(iMassToGive, iSpareMassStorage), math.min(iEnergyToGive, iSpareEnergyStorage))
            end

        end
        if iMassToGive + iEnergyToGive < 0 then break end
    end
end

function RefreshActiveBrainListForBrainDeath(oDefeatedBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshActiveBrainListForBrainDeath'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; brain '..oDefeatedBrain.Nickname..' has died, will update all teams for this, iTotalTeamCount='..iTotalTeamCount) end
    LOG('Brain death detected for '..oDefeatedBrain.Nickname)
    for iTeam = 1, iTotalTeamCount do
        if oDefeatedBrain.M28Team == iTeam then
            if M28Utilities.IsTableEmpty(tTeamData[iTeam][subreftoFriendlyHumanAndAIBrains]) == false then

                for iBrain, oBrain in tTeamData[iTeam][subreftoFriendlyHumanAndAIBrains] do
                    if oBrain == oDefeatedBrain then
                        if oBrain.M28AI then
                            for iM28Brain, oM28Brain in tTeamData[iTeam][subreftoFriendlyActiveM28Brains] do
                                if oM28Brain == oBrain then
                                    table.remove(tTeamData[iTeam][subreftoFriendlyActiveM28Brains], iM28Brain)
                                    break
                                end
                            end
                            tTeamData[iTeam][subrefiActiveM28BrainCount] = tTeamData[iTeam][subrefiActiveM28BrainCount] - 1
                        end
                        table.remove(tTeamData[iTeam][subreftoFriendlyHumanAndAIBrains], iBrain)
                        break
                    end
                end
            end
        else --Enemy team
            if M28Utilities.IsTableEmpty(tTeamData[iTeam][subreftoEnemyBrains]) == false then
                for iBrain, oBrain in tTeamData[iTeam][subreftoEnemyBrains] do
                    if oBrain == oDefeatedBrain then
                        table.remove(tTeamData[iTeam][subreftoEnemyBrains], iBrain)
                        break
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tTeamData[iTeam][subreftoEnemyBrains]) then
                tTeamData[iTeam][subrefbAllEnemiesDefeated] = true
            end
        end
    end

    --Remove from air subteam
    local iAirSubteam = oDefeatedBrain.M28AirSubteam
    if M28Utilities.IsTableEmpty(tAirSubteamData[iAirSubteam][subreftoFriendlyM28Brains]) == false then
        for iBrain, oBrain in tAirSubteamData[iAirSubteam][subreftoFriendlyM28Brains] do
            if oBrain == oDefeatedBrain then
                table.remove(tAirSubteamData[iAirSubteam][subreftoFriendlyM28Brains], iBrain)
                break
            end
        end
    end

    --Remove from land subteam
    local iLandSubteam = oDefeatedBrain.M28LandSubteam
    if M28Utilities.IsTableEmpty(tLandSubteamData[iLandSubteam][subreftoFriendlyM28Brains]) == false then
        for iBrain, oBrain in tLandSubteamData[iLandSubteam][subreftoFriendlyM28Brains] do
            if oBrain == oDefeatedBrain then
                table.remove(tLandSubteamData[iLandSubteam][subreftoFriendlyM28Brains], iBrain)
                break
            end
        end
    end



    for iArmyIndex, oBrain in M28Overseer.tAllAIBrainsByArmyIndex do
        if oDefeatedBrain == oBrain then
            if M28Overseer.tAllAIBrainsByArmyIndex[iArmyIndex] == oDefeatedBrain then
                M28Overseer.tAllAIBrainsByArmyIndex[iArmyIndex] = nil
                if bDebugMessages == true then LOG(sFunctionRef..': Removed brain '..oBrain.Nickname..' from table of all AI Brains') end
            else --redundancy (due to issues having with ActiveM28Brains table)
                if bDebugMessages == true then LOG(sFunctionRef..': Activated redundancy for removing brain '..oBrain.Nickname..' from table of all AI Brains') end
                for iRecordedBrain, oRecordedBrain in M28Overseer.tAllAIBrainsByArmyIndex do
                    if oRecordedBrain == oDefeatedBrain then
                        M28Overseer.tAllAIBrainsByArmyIndex[iRecordedBrain] = nil
                        break
                    end
                end
            end
            if oBrain.M28AI then
                if M28Overseer.tAllActiveM28Brains[iArmyIndex] == oDefeatedBrain then
                    M28Overseer.tAllActiveM28Brains[iArmyIndex] = nil
                    if bDebugMessages == true then LOG(sFunctionRef..': Removed brain '..oBrain.Nickname..' from table of active M28 Brains') end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Activated redundancy for removing brain '..oBrain.Nickname..' from table of active M28 brains') end
                    for iM28BrainEntry, oM28Brain in M28Overseer.tAllActiveM28Brains do
                        if oM28Brain == oDefeatedBrain then
                            M28Overseer.tAllActiveM28Brains[iM28BrainEntry] = nil
                            break
                        end
                    end
                end
            end
            break
        end
    end

    --Update primary enemy base locations for M28 brain if their nearest brain is now defeated
    if M28Utilities.IsTableEmpty(M28Overseer.tAllActiveM28Brains) == false then
        for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
            if oBrain[M28Overseer.refoNearestEnemyBrain].M28IsDefeated then
                M28Map.UpdateNewPrimaryBaseLocation(oBrain)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TeamDeathChecker()
    WaitSeconds(1) --Make sure have given time for brains to be setup
    if not(bActiveTeamDeathChecker) and not(ScenarioInfo.Options.Victory == "demoralization") then
        bActiveTeamDeathChecker = true
        while M28Utilities.bM28AIInGame do
            --Treat any players as defeated when they show as defeated
            WaitSeconds(1)
            for iBrain, oBrain in ArmyBrains do
                if oBrain:IsDefeated() and not(oBrain.M28IsDefeated) then
                    ForkThread(M28Events.OnPlayerDefeated, oBrain)
                end
            end
        end
        bActiveTeamDeathChecker = false
    end
end

function DelayedPlayerDeathCheck()
    WaitSeconds(1)
    for iBrain, oBrain in ArmyBrains do
        if oBrain:IsDefeated() and not(oBrain.M28IsDefeated) then
            M28Events.OnPlayerDefeated(oBrain)
        end
    end
end

function ConsiderGiftingStorageToTeammate(oEnergyStorage)
    --If have a teammate with less energy storage then will gift the energy storage to them
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderGiftingStorageToTeammate'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain = oEnergyStorage:GetAIBrain()
    local iTeam = aiBrain.M28Team
    if bDebugMessages == true then LOG(sFunctionRef..': Brain '..aiBrain.Nickname..' has just built energy storage '..oEnergyStorage.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnergyStorage)..'; active M28 brain count for team '..iTeam..' = '..tTeamData[iTeam][subrefiActiveM28BrainCount]..'; Total no. of storage for this brain='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEnergyStorage + M28UnitInfo.refCategoryParagon + M28UnitInfo.refCategoryQuantumOptics)..'; lowest storage count for team='..tTeamData[iTeam][subrefiLowestEnergyStorageCount]) end
    if tTeamData[iTeam][subrefiActiveM28BrainCount] > 1 then
        local iOurEnergyStorage = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEnergyStorage + M28UnitInfo.refCategoryParagon + M28UnitInfo.refCategoryQuantumOptics)
        if iOurEnergyStorage >= 2 and iOurEnergyStorage > 1 + tTeamData[iTeam][subrefiLowestEnergyStorageCount] then
            for iBrain, oBrain in  tTeamData[iTeam][subreftoFriendlyActiveM28Brains] do
                if not(oBrain == aiBrain) and oBrain:GetCurrentUnits(M28UnitInfo.refCategoryEnergyStorage + M28UnitInfo.refCategoryParagon + M28UnitInfo.refCategoryQuantumOptics) + 1 < iOurEnergyStorage then
                    --We have 2 less energy storage so want to give this storage to them
                    if bDebugMessages == true then LOG(sFunctionRef..': Brain '..oBrain.Nickname..' only has '..oBrain:GetCurrentUnits(M28UnitInfo.refCategoryEnergyStorage + M28UnitInfo.refCategoryParagon + M28UnitInfo.refCategoryQuantumOptics)..' energy storage type buildings so will gift this storage to them') end
                    TransferUnitsToPlayer({ oEnergyStorage }, oBrain:GetArmyIndex(), false)
                    ForkThread(TeamEconomyRefresh, iTeam)
                    break
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetFirstActiveM28Brain(iTeam)
    if M28Utilities.IsTableEmpty(tTeamData[iTeam][subreftoFriendlyActiveM28Brains]) == false then
        for iBrain, oBrain in tTeamData[iTeam][subreftoFriendlyActiveM28Brains] do
            if not(oBrain.M28IsDefeated) then
                return oBrain
            end
        end
    end
end

function GiftAdjacentStorageToMexOwner(oJustBuilt, oOptionalBrainToGiftTo)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GiftAdjacentStorageToMexOwner'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tMexLocation = oJustBuilt:GetPosition()
    local rSearchRectangle = M28Utilities.GetRectAroundLocation(tMexLocation, 2.749) --If changing this also change M28Economy and M28Engineer similar value
    local tNearbyUnits = GetUnitsInRect(rSearchRectangle) --at 1.5 end up with storage thats not adjacent being gifted in some cases but not in others; at 1 none of it gets gifted; the mass storage should be exactly 2 from the mex; however even at 2.1, 2.25 and 2.499 had cases where the mex wasnt identified so will try 2.75 since distances can vary/be snapped to the nearest 0.5 I think
    local iBrainIndexToGiftTo
    if oOptionalBrainToGiftTo then iBrainIndexToGiftTo = oOptionalBrainToGiftTo:GetArmyIndex()
    else iBrainIndexToGiftTo = oJustBuilt:GetAIBrain():GetArmyIndex()
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Storage gifting where built mex - oJustBuilt='..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; owner='..oJustBuilt:GetAIBrain().Nickname..'; is tNearbyUnits empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnits))) end
    if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
        local tNearbyStorage = EntityCategoryFilterDown(M28UnitInfo.refCategoryMassStorage, tNearbyUnits)
        if M28Utilities.IsTableEmpty(tNearbyStorage) == false then
            for iUnit, oUnit in tNearbyStorage do
                if IsAlly(iBrainIndexToGiftTo, oUnit:GetAIBrain():GetArmyIndex()) then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to transfer '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from brain '..oUnit:GetAIBrain().Nickname..' to '..oJustBuilt:GetAIBrain().Nickname..'; Dist from unit to tMexLocation='..M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition())) end
                    if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMexLocation) <= 2.25 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and gift the storage to the player that built the mex') end
                        TransferUnitsToPlayer({oUnit}, iBrainIndexToGiftTo, false)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordMobileEnemyTMLForTeam(oTML, iTeam)
    local bAlreadyIncluded = false
    if not(tTeamData[iTeam][reftEnemyMobileTML]) then
        tTeamData[iTeam][reftEnemyMobileTML] = {}
    elseif M28Utilities.IsTableEmpty(tTeamData[iTeam][reftEnemyMobileTML]) == false then
        for iUnit, oUnit in tTeamData[iTeam][reftEnemyMobileTML] do
            if oUnit == oTML then bAlreadyIncluded = true end
        end
    end
    if not(bAlreadyIncluded) then
        table.insert(tTeamData[iTeam][reftEnemyMobileTML], oTML)
        oTML[M28Building.reftMobileTMLLastLocationChecked] = nil
        ForkThread(MonitorEnemyMobileTMLThreats, iTeam)
    end
end

function RecordMobileTMLThreatForAllEnemyTeams(oTML)
    --Intended for ACUs, SACUs, and potentially UEF/Sera cruisers and Aeon missile ship
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordMobileTMLThreatForAllEnemyTeams'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    while not(M28Map.bMapLandSetupComplete) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if GetGameTimeSeconds() >= 10 then break end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for oTML='..(oTML.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oTML) or 'nil')) end
    if M28UnitInfo.IsUnitValid(oTML) then
        if M28Utilities.IsTableEmpty(M28Overseer.tAllActiveM28Brains) == false then
            local tiTeamsToUpdate = {}
            local iTMLArmyIndex = oTML:GetAIBrain():GetArmyIndex()
            local bUnitIsValid = true
            for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                if not(tiTeamsToUpdate[oBrain.M28Team]) and IsEnemy(oBrain:GetArmyIndex(), iTMLArmyIndex) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oBrain='..oBrain.Nickname..'; Team='..(oBrain.M28Team or 'nil')) end
                    while not(oBrain.M28Team) do --Cybran mission 4 causes lua error due to this triggering before teams have been assigned
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        bUnitIsValid = false
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        if GetGameTimeSeconds() >= 10 then break end
                    end
                    if not(bUnitIsValid) then bUnitIsValid = M28UnitInfo.IsUnitValid(oTML) end
                    if bUnitIsValid then
                        tiTeamsToUpdate[oBrain.M28Team] = true
                    end
                end
                if M28Utilities.IsTableEmpty(tiTeamsToUpdate) == false and bUnitIsValid then
                    for iTeam, bUpdate in tiTeamsToUpdate do
                        RecordMobileEnemyTMLForTeam(oTML, iTeam)
                    end
                end
            end
        end
    end
end

function MonitorEnemyMobileTMLThreats(iTeam)
    --Whenever an enemy mobile TML threat has moved by more than 15 from its last recorded postiion, update its targets
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MonitorEnemyMobileTMLThreats'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, activem TML monitor='..tostring(tTeamData[iTeam][refbActiveMobileTMLMonitor] or false)..'; Gametime='..GetGameTimeSeconds()) end
    if not(tTeamData[iTeam][refbActiveMobileTMLMonitor]) then
        tTeamData[iTeam][refbActiveMobileTMLMonitor] = true
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy mobile TML empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iTeam][reftEnemyMobileTML]))) end
        while M28Utilities.IsTableEmpty(tTeamData[iTeam][reftEnemyMobileTML]) == false do
            local iTicksWaitedThisCycle = 0
            if M28Conditions.IsTableOfUnitsStillValid(tTeamData[iTeam][reftEnemyMobileTML]) then
                for iUnit, oUnit in tTeamData[iTeam][reftEnemyMobileTML] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to update oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Cur position='..repru(oUnit:GetPosition())..'; Last location checked='..repru(oUnit[M28Building.reftMobileTMLLastLocationChecked])..'; Time since last hceck='..GetGameTimeSeconds() - (oUnit[M28Building.refiTimeMobileTMLLastChecked] or -1000)) end
                    if not(oUnit[M28Building.reftMobileTMLLastLocationChecked]) or GetGameTimeSeconds() - (oUnit[M28Building.refiTimeMobileTMLLastChecked] or -100) >= 30 or M28Utilities.GetDistanceBetweenPositions(oUnit[M28Building.reftMobileTMLLastLocationChecked], oUnit:GetPosition()) >= 10 or oUnit[M28Building.refbTMDBuiltSinceLastChecked] then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will record units in range of TML now') end
                        M28Building.RecordUnitsInRangeOfTMLAndAnyTMDProtection(oUnit)
                        oUnit[M28Building.refbTMDBuiltSinceLastChecked] = false
                        oUnit[M28Building.reftMobileTMLLastLocationChecked] = {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]}
                        oUnit[M28Building.refiTimeMobileTMLLastChecked] = GetGameTimeSeconds()
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        iTicksWaitedThisCycle = iTicksWaitedThisCycle + 1
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    end
                end
            else
                break
            end
            if iTicksWaitedThisCycle < 50 then --Want to refresh no more quickly than once every 5s
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(50 - iTicksWaitedThisCycle)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
        end
        tTeamData[iTeam][refbActiveMobileTMLMonitor] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshPotentialTeleSnipeTargets(iTeam, iOptionalMaxTimeDelayInSeconds)
    --Refresh every 5s (or iOptionalMaxTimeDelayInSeconds if specified)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshPotentialTeleSnipeTargets'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for iTeam '..iTeam..'; iOptionalMaxTimeDelayInSeconds='..(iOptionalMaxTimeDelayInSeconds or 'nil')..'; Time since last snipe refresh='..GetGameTimeSeconds() - (tTeamData[iTeam][refiTimeOfLastTeleSnipeRefresh] or -100)) end
    if GetGameTimeSeconds() - (tTeamData[iTeam][refiTimeOfLastTeleSnipeRefresh] or -100) >= (iOptionalMaxTimeDelayInSeconds or 5) then
        tTeamData[iTeam][refiTimeOfLastTeleSnipeRefresh] = GetGameTimeSeconds()
        tTeamData[iTeam][reftoPotentialTeleSnipeTargets] = {}
        --Target enemy gameenders, T3 arti, and ACUs (in assassination)
        local tEnemyUnitsToConsider = {}
        local aiBrain = GetFirstActiveM28Brain(iTeam)
        function AddTableOfUnits(sRef, bMobileUnitChecks)
            if M28Utilities.IsTableEmpty(tTeamData[iTeam][sRef]) == false then
                for iUnit, oUnit in tTeamData[iTeam][sRef] do
                    --require unit to be visible so we are more likely to have determined what PD is around it
                    if bDebugMessages == true and M28UnitInfo.IsUnitValid(oUnit) then LOG(sFunctionRef..': Considering whether to add to table of units to consider, sRef='..sRef..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Can see unit='..tostring(M28UnitInfo.CanSeeUnit(aiBrain, oUnit))..'; Fraction complete='..oUnit:GetFractionComplete()..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)) end
                    if M28UnitInfo.IsUnitValid(oUnit) and M28UnitInfo.CanSeeUnit(aiBrain, oUnit) and oUnit:GetFractionComplete() >= 0.5 then
                        if not(bMobileUnitChecks) or (not(M28UnitInfo.IsUnitUnderwater(oUnit)) and not(oUnit:IsUnitState('Moving')) and not(oUnit:IsUnitState('Attached')) and not(oUnit:IsUnitState('Attacking'))) then
                            table.insert(tEnemyUnitsToConsider, oUnit)
                        end
                    end
                end
            end
        end
        AddTableOfUnits(reftEnemyArtiAndExpStructure)
        if ScenarioInfo.Options.Victory == "demoralization" then AddTableOfUnits(reftEnemyACUs, true) end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tEnemyUnitsToConsider))) end
        if M28Utilities.IsTableEmpty(tEnemyUnitsToConsider) == false then
            local iCurPlateauOrZero, iCurLandOrWaterZone
            for iUnit, oUnit in tEnemyUnitsToConsider do
                --Consider the nearby threat at the location
                iCurPlateauOrZero, iCurLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
                if bDebugMessages == true then LOG(sFunctionRef..': Considering ifu nit is a viable target, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurPlateauOrZero='..(iCurPlateauOrZero or 'nil')..'; iCurLandOrWaterZone='..(iCurLandOrWaterZone or 'nil')) end
                if iCurPlateauOrZero > 0 and (iCurLandOrWaterZone or 0) > 0 then
                    local tLZData = M28Map.tAllPlateaus[iCurPlateauOrZero][M28Map.subrefPlateauLandZones][iCurLandOrWaterZone]
                    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                    --Ignore zones with large threat just in the zone itself
                    if bDebugMessages == true then LOG(sFunctionRef..': tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]='..tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal]..'; tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]='..tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]) end
                    if tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] < 10000 and tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 30000 and tLZTeamData[M28Map.refiEnemyAirToGroundThreat] <= 2500 then
                        local tPDInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD, tLZTeamData[M28Map.subrefTEnemyUnits])
                        if not(tPDInZone) then tPDInZone = {} end
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                local tAdjLZData = M28Map.tAllPlateaus[iCurPlateauOrZero][M28Map.subrefPlateauLandZones][iAdjLZ]
                                local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                                if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                                    local tAdjPD = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD, tAdjLZTeamData[M28Map.subrefTEnemyUnits])
                                    if M28Utilities.IsTableEmpty(tAdjPD) == false then
                                        for iPD, oPD in tAdjPD do
                                            table.insert(tPDInZone, tAdjPD)
                                        end
                                    end
                                end
                            end
                            local iNearbyPDThreat = 0
                            if M28Utilities.IsTableEmpty(tPDInZone) == false then
                                local tPDInRange = {}
                                for iPD, oPD in tPDInZone do
                                    if M28UnitInfo.IsUnitValid(oPD) then
                                        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oPD:GetPosition()) <= 5 + oPD[M28UnitInfo.refiDFRange] then
                                            table.insert(tPDInRange, oPD)
                                        end
                                    end
                                end
                                if M28Utilities.IsTableEmpty(tPDInRange) == false then
                                    iNearbyPDThreat = M28UnitInfo.GetMassCostOfUnits(tPDInRange)
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iNearbyPDThreat='..iNearbyPDThreat) end
                            if iNearbyPDThreat <= 2000 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit to table of potential tele snipe targets') end
                                table.insert(tTeamData[iTeam][reftoPotentialTeleSnipeTargets], oUnit)
                            else
                                --Still add if there is al ocation with low PD threat
                                if not(oUnit[M28UnitInfo.refbTooMuchPDForSnipe]) then
                                    if M28ACU.GetBestLocationForTeleSnipeTarget(nil, oUnit, iTeam, true) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': We shoudl be able to teleport out of range of most of the PD so will still add as a telesnipe target') end
                                        table.insert(tTeamData[iTeam][reftoPotentialTeleSnipeTargets], oUnit)
                                    else
                                        oUnit[M28UnitInfo.refbTooMuchPDForSnipe] = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': Unable to find al ocation that puts us out of range of the PD') end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then
        if M28Utilities.IsTableEmpty(tTeamData[iTeam][reftoPotentialTeleSnipeTargets]) then LOG(sFunctionRef..': End of code, no telesnipe targets')
        else LOG(sFunctionRef..': End of code, size of telesnipe targets table='..table.getn(tTeamData[iTeam][reftoPotentialTeleSnipeTargets]))
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckIfCampaignTeamHasBuildings(iTeam)
    --Call via forkthread; will check if the aiBrain in question has any buildings (so can decide if should be very aggressive)
    local sFunctionRef = 'CheckIfCampaignAIHasBuildings'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if not(tTeamData[iTeam]['M28ActiveBuildingChecker']) then
        tTeamData[iTeam]['M28ActiveBuildingChecker'] = true
        tTeamData[iTeam][refbDontHaveBuildingsOrACUInPlayableArea] = false
        --Wait number of ticks based on army index
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(iTeam)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        while tTeamData[iTeam][subrefiActiveM28BrainCount] >= 1 do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(10)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            local bHaveBuildingsInPlayableArea = false

            for iBrain, oBrain in tTeamData[iTeam][subreftoFriendlyActiveM28Brains] do
                local tStructuresOrACU = oBrain:GetListOfUnits(M28UnitInfo.refCategoryStructure + categories.COMMAND, false, true)
                if M28Utilities.IsTableEmpty(tStructuresOrACU) == false then
                    for iUnit, oUnit in tStructuresOrACU do
                        if oUnit:GetFractionComplete() == 1 then
                            if M28Conditions.IsLocationInPlayableArea(oUnit:GetPosition()) then
                                bHaveBuildingsInPlayableArea = true
                                break
                            end
                        end
                    end
                end
                if bHaveBuildingsInPlayableArea then break end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if iTeam='..iTeam..' has any buildings or ACU at time='..GetGameTimeSeconds()..'; bHaveBuildingsInPlayableArea='..tostring(bHaveBuildingsInPlayableArea or false)) end
            tTeamData[iTeam][refbDontHaveBuildingsOrACUInPlayableArea] = not(bHaveBuildingsInPlayableArea)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetEnemyMainCampaignBase(iTeam)
    --Intended fro campaign maps wher the enemy main base location is unreliable - will periodically refresh this and get the zone with the highest enemy structure threat in the playable area; failing that will get the first enemy brain start position in the playable area
    if GetGameTimeSeconds() - (tTeamData[iTeam][refiLastUpdatedMainBase] or -100) >= 60 then
        tTeamData[iTeam][refiLastUpdatedMainBase] = GetGameTimeSeconds()
        local iBestSValue = 0
        local tBestValueMidpoint, iCurSValue
        for iPlateau, tPlateauSubtable in M28Map.tAllPlateaus do
            for iLandZone, tLZData in tPlateauSubtable[M28Map.subrefPlateauLandZones] do
                if M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then
                    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
                        local tBuildings = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tLZTeamData[M28Map.subrefTEnemyUnits])
                        if M28Utilities.IsTableEmpty(tBuildings) == false then
                            iCurSValue = M28UnitInfo.GetMassCostOfUnits(tBuildings)
                            if iCurSValue > iBestSValue then
                                iBestSValue = iCurSValue
                                tBestValueMidpoint = {tLZData[M28Map.subrefMidpoint][1], tLZData[M28Map.subrefMidpoint][2], tLZData[M28Map.subrefMidpoint][3]}
                            end
                        end
                    end
                end
            end
        end
        tTeamData[iTeam][reftEnemyCampaignMainBase] = tBestValueMidpoint
    end
    return tTeamData[iTeam][reftEnemyCampaignMainBase]

end

function ConsiderGiftingSupportFactoriesToTeammateWithBetterHQ(aiBrain, sHQJustDiedOrSupportFacID)
    --Should call vai forkthread so happens after we have updated our highest tech level for the aiBrain
    local sFunctionRef = 'ConsiderGiftingSupportFactoriesToTeammateWithBetterHQ'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, brain='..aiBrain.Nickname..'; sHQJustDiedOrSupportFacID='..sHQJustDiedOrSupportFacID..' time='..GetGameTimeSeconds()) end
    if aiBrain.M28AI then
        local sBrainFactoryTechVaraible
        local iFactoryCategory
        if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, sHQJustDiedOrSupportFacID) then
            sBrainFactoryTechVaraible = M28Economy.refiOurHighestLandFactoryTech
            iFactoryCategory = M28UnitInfo.refCategoryLandFactory
        elseif EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, sHQJustDiedOrSupportFacID) then
            sBrainFactoryTechVaraible = M28Economy.refiOurHighestAirFactoryTech
            iFactoryCategory = M28UnitInfo.refCategoryAirFactory
        elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, sHQJustDiedOrSupportFacID) then
            sBrainFactoryTechVaraible = M28Economy.refiOurHighestNavalFactoryTech
            iFactoryCategory = M28UnitInfo.refCategoryNavalFactory
        end
        if sBrainFactoryTechVaraible then
            local iTeam = aiBrain.M28Team
            local iTechLevelDied = M28UnitInfo.GetBlueprintTechLevel(sHQJustDiedOrSupportFacID)
            local iOurHighestTechLevelOfFactoryType = aiBrain[sBrainFactoryTechVaraible]
            if bDebugMessages == true then LOG(sFunctionRef..': iOurHighestTechLevelOfFactoryType='..iOurHighestTechLevelOfFactoryType..'; iTechLevelDied='..iTechLevelDied) end
            if iOurHighestTechLevelOfFactoryType < iTechLevelDied then
                local iFactionType = M28UnitInfo.GetFactionNumberFromBlueprint(sHQJustDiedOrSupportFacID)
                if bDebugMessages == true then LOG(sFunctionRef..': iFactionType='..iFactionType) end
                local iFactionCategory = M28UnitInfo.ConvertFactionToCategory(iFactionType)
                local iTechCategory
                if iOurHighestTechLevelOfFactoryType <= 1 then
                    iTechCategory = categories.TECH2 + categories.TECH3
                else
                    iTechCategory = categories.TECH3
                end


                --Do we have support factories?
                local toSupportFactoriesToConsiderTransferring = aiBrain:GetListOfUnits(iFactoryCategory * categories.SUPPORTFACTORY * iTechCategory * iFactionCategory)
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of support facs empty='..tostring(M28Utilities.IsTableEmpty(toSupportFactoriesToConsiderTransferring))) end
                if M28Utilities.IsTableEmpty(toSupportFactoriesToConsiderTransferring) == false then
                    local oTeammateToTransferTo
                    for iBrain, oBrain in tTeamData[iTeam][subreftoFriendlyActiveM28Brains] do
                        --Xfer support factories to the first teammate with a better tech level
                        if oBrain[sBrainFactoryTechVaraible] > math.max(1, iOurHighestTechLevelOfFactoryType) then
                            --Check if we have HQ of the right faction
                            local iUnitsOfCategory = oBrain:GetCurrentUnits(iFactionCategory * iTechCategory * M28UnitInfo.refCategoryAllHQFactories)
                            if bDebugMessages == true then LOG(sFunctionRef..': iUnitsOfCategory for brain '..oBrain.Nickname..'='..iUnitsOfCategory) end
                            if iUnitsOfCategory > 0 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will transfer units to this brain') end
                                oTeammateToTransferTo = oBrain
                                break
                            end
                        end
                    end
                    if oTeammateToTransferTo then
                        if bDebugMessages == true then LOG(sFunctionRef..': About to transfer all support factories to teammate '..oTeammateToTransferTo.Nickname..'; will list out toSupportFactoriesToConsiderTransferring')
                            for iUnit, oUnit in toSupportFactoriesToConsiderTransferring do
                                LOG(sFunctionRef..': Will transfer unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
                            end
                        end
                        TransferUnitsToPlayer(toSupportFactoriesToConsiderTransferring, oTeammateToTransferTo:GetArmyIndex(), false)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshArtiAndNovaxCount(iTeam)
    tTeamData[iTeam][refiEnemyNovaxCount] = 0
    tTeamData[iTeam][refiEnemyT3ArtiCount] = 0
    if M28Utilities.IsTableEmpty(tTeamData[iTeam][reftEnemyArtiAndExpStructure]) == false then
        local iSatelliteCount = 0
        local iCentreCount = 0
        local iT3ArtiCount = 0
        for iUnit, oUnit in tTeamData[iTeam][reftEnemyArtiAndExpStructure] do
            if EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti, oUnit.UnitId) then iT3ArtiCount = iT3ArtiCount + 1
            elseif EntityCategoryContains(M28UnitInfo.refCategoryExperimentalArti, oUnit.UnitId) then iT3ArtiCount = iT3ArtiCount + 3
            elseif EntityCategoryContains(M28UnitInfo.refCategoryNovaxCentre, oUnit.UnitId) then iCentreCount = iCentreCount + 1
            elseif EntityCategoryContains(M28UnitInfo.refCategorySatellite, oUnit.UnitId) then iSatelliteCount = iSatelliteCount + 1
            end
        end
        tTeamData[iTeam][refiEnemyNovaxCount] = math.max(iSatelliteCount, iCentreCount)
        tTeamData[iTeam][refiEnemyT3ArtiCount] = iT3ArtiCount
    end
end

function ConsiderAddingUnitAsSnipeTarget(oUnit, iTeam)
    local sFunctionRef = 'ConsiderAddingUnitAsSnipeTarget'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local bAddAsSnipeTarget = false
    --Low health%:
    if not(M28UnitInfo.IsUnitUnderwater(oUnit)) and M28UnitInfo.IsUnitValid(oUnit) then
        local iHealthPercent = M28UnitInfo.GetUnitHealthPercent(oUnit)
        local iBaseHealthThreshold = 0.6
        if oUnit[M28UnitInfo.refbIsSnipeTarget] then iBaseHealthThreshold = iBaseHealthThreshold+ 0.1 end
        if bDebugMessages == true then LOG(sFunctionRef..': Considering health threshold, iHealthPercent='..iHealthPercent..'; iBaseHealthThreshold='..iBaseHealthThreshold) end
        if iHealthPercent < iBaseHealthThreshold then
            --Very low health - attack
            if (iHealthPercent < 0.175 or (iHealthPercent < 0.2 and oUnit[M28UnitInfo.refbIsSnipeTarget])) and (oUnit:GetHealth() <= 2000 or (oUnit[M28UnitInfo.refbIsSnipeTarget] and oUnit:GetHealth() <= 2500)) then
                if bDebugMessages == true then LOG(sFunctionRef..': So low health that we might kill just with air') end
                bAddAsSnipeTarget = true
            else
                --Is there a friendly ACU nearby with more health? Also factor in if that ACU has a better upgrade
                local tNearbyAvailableACUs = {}
                if M28Conditions.IsTableOfUnitsStillValid(tTeamData[iTeam][reftM28ACUs]) then
                    local iPlateauWanted = NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oUnit:GetPosition())
                    local iMaxDistUntilInRange = 15
                    local iFriendlyACUHealthThreshold = math.min(iBaseHealthThreshold * 1.3, 0.95)
                    if iHealthPercent >= 0.5 then iFriendlyACUHealthThreshold = math.min(0.95, iFriendlyACUHealthThreshold * 1.1) end
                    local iFriendlyACUHealthPercent
                    if oUnit[M28UnitInfo.refbIsSnipeTarget] then iFriendlyACUHealthThreshold = iFriendlyACUHealthThreshold * 0.75 end
                    if oUnit[M28UnitInfo.refbIsSnipeTarget] then iMaxDistUntilInRange = iMaxDistUntilInRange + 15 end
                    local iDistAdjustment
                    for iFriendlyACU, oFriendlyACU in tTeamData[iTeam][reftM28ACUs] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Is friendly ACU owend by brain '..oFriendlyACU:GetAIBrain().Nickname..' available to do snipe attakc='..tostring(oFriendlyACU[M28ACU.refbACUAvailableToDoSnipeAttack] or false)) end
                        if oFriendlyACU[M28ACU.refbACUAvailableToDoSnipeAttack] then
                            if NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oFriendlyACU:GetPosition()) == iPlateauWanted then
                                iDistAdjustment = 0
                                if not(tTeamData[iTeam][refbDangerousForACUs]) and (oFriendlyACU[M28UnitInfo.refiDFRange] > oUnit[M28UnitInfo.refiDFRange] or (oFriendlyACU[M28ACU.refiUpgradeCount] >= 2 and (oFriendlyACU[M28ACU.refiUpgradeCount] >= 3 or not(EntityCategoryContains(categories.AEON, oFriendlyACU.UnitId))) and oFriendlyACU[M28ACU.refiUpgradeCount] > (oUnit[M28ACU.refiUpgradeCount] or 0))) then
                                    iDistAdjustment = 30
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Dist to friendly ACU='..M28Utilities.GetDistanceBetweenPositions(oFriendlyACU:GetPosition(), oUnit:GetPosition())..'; DF range='..oFriendlyACU[M28UnitInfo.refiDFRange]..'; iMaxDistUntilInRange='..iMaxDistUntilInRange..'; Friendly ACU health%='.. M28UnitInfo.GetUnitHealthPercent(oFriendlyACU)) end
                                if M28Utilities.GetDistanceBetweenPositions(oFriendlyACU:GetPosition(), oUnit:GetPosition()) <= oFriendlyACU[M28UnitInfo.refiDFRange] + iMaxDistUntilInRange + iDistAdjustment then
                                    iFriendlyACUHealthPercent = M28UnitInfo.GetUnitHealthPercent(oFriendlyACU)
                                    if iFriendlyACUHealthPercent >= iFriendlyACUHealthThreshold or (iFriendlyACUHealthPercent >= iFriendlyACUHealthThreshold * 0.8 and oFriendlyACU[M28UnitInfo.refiDFRange] > (oUnit[M28UnitInfo.refiCombatRange] or 0)) then
                                        table.insert(tNearbyAvailableACUs, oFriendlyACU)
                                    end
                                end
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tNearbyAvailableACUs) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': We have nearby available ACUs, size of table='..table.getn(tNearbyAvailableACUs)) end
                        if table.getn(tNearbyAvailableACUs) >= 2 or iHealthPercent < iBaseHealthThreshold - 0.1 then
                            bAddAsSnipeTarget = true
                            for iUnit, oUnit in tNearbyAvailableACUs do
                                oUnit[M28ACU.refbUseACUAggressively] = true
                                --Note - ACU code has logic to set ACU target priorities if there is a nearby snipe target
                            end
                        end
                    end
                end
                if not(bAddAsSnipeTarget) then
                    --Consider sniping if we could kill it with c. 2 bombers based on our current air tech
                    local iHealthThreshold
                    if tTeamData[iTeam][subrefiHighestFriendlyAirFactoryTech] == 1 then
                        iHealthThreshold = 1000
                    elseif tTeamData[iTeam][subrefiHighestFriendlyAirFactoryTech] == 2 then
                        iHealthThreshold = 2500
                    else iHealthThreshold = 4250
                    end
                    if oUnit[M28UnitInfo.refbIsSnipeTarget] then iHealthThreshold = iHealthThreshold + 500 end
                    if tTeamData[iTeam][subrefiOurBomberThreat] >= 500 then
                        iHealthThreshold = iHealthThreshold + math.min(750, tTeamData[iTeam][subrefiOurBomberThreat] * 0.5)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering sniping if we could probably get enough bombers, iHealthThreshold='..iHealthThreshold..'; Unit health='..oUnit:GetHealth()..'; iHealthPercent='..iHealthPercent..'; Team bomber threat='..tTeamData[iTeam][subrefiOurBomberThreat]) end
                    if oUnit:GetHealth() <= iHealthThreshold then
                        local iShield = 0
                        if oUnit.MyShield.GetHealth then iShield = oUnit.MyShield:GetHealth() end
                        if iShield == 0 or oUnit:GetHealth() + iShield <= iHealthThreshold then
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding as snipe target due to bomber vulnerability') end
                            bAddAsSnipeTarget = true
                        end
                    end

                    if not(bAddAsSnipeTarget) and iHealthPercent <= 0.5 then
                        --If we have a significant threat in range of the ACU then treat it as a snipe target if we also have more threat than the enemy
                        local tACULZData, tACULZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                        if tACULZTeamData and tACULZTeamData[M28Map.subrefThreatEnemyDFStructures] <= 1200 and tACULZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] == 0 then
                            local aiBrain = GetFirstActiveM28Brain(iTeam)
                            local iNearbyThreatToACUSearchDist = 35
                            if oUnit[M28UnitInfo.refbIsSnipeTarget] then iNearbyThreatToACUSearchDist = 45 end
                            local toNearbyDFUnits = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryDFTank - M28UnitInfo.refCategorySkirmisher, oUnit:GetPosition(), iNearbyThreatToACUSearchDist, 'Ally')
                            if M28Utilities.IsTableEmpty(toNearbyDFUnits) == false then
                                local iNearbyFriendlyDFThreat = M28UnitInfo.GetCombatThreatRating(toNearbyDFUnits, false, false)
                                local iMinThreatWanted
                                local iACUCombatThreat = M28UnitInfo.GetCombatThreatRating({oUnit}, true, false)
                                if iHealthPercent <= 0.3 then iMinThreatWanted = math.max(450, iACUCombatThreat + ((tACULZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) - iACUCombatThreat) * 0.4)
                                else iMinThreatWanted = math.max(600, M28UnitInfo.GetCombatThreatRating({oUnit}, true, false) + ((tACULZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) - iACUCombatThreat) * 0.8)
                                end
                                if oUnit[M28ACU.refiUpgradeCount] >= 2 and (oUnit[M28ACU.refiUpgradeCount] >= 3 or oUnit:GetMaxHealth() >= 14000 or (oUnit.MyShield.GetHealth and oUnit.MyShield.GetHealth() > 0)) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Dealing with heavily upgraded ACU') end
                                    iMinThreatWanted = iMinThreatWanted * 1.75
                                end
                                if oUnit[M28UnitInfo.refbIsSnipeTarget] then iMinThreatWanted = iMinThreatWanted * 0.85 end
                                if bDebugMessages == true then LOG(sFunctionRef..': iNearbyFriendlyDFThreat='..iNearbyFriendlyDFThreat..'; iMinThreatWanted='..iMinThreatWanted..'; Enemy iACUCombatThreat='..iACUCombatThreat..'; Enemy mobile DF threat in zone of ACU less ACU value (since ACU included in this)='..((tACULZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) - iACUCombatThreat)) end
                                if iNearbyFriendlyDFThreat >= iMinThreatWanted then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Adding as snipe target due to snigificant nearby ground DF threat') end
                                    bAddAsSnipeTarget = true
                                end
                            end
                        end
                    end
                end
            end
            if bAddAsSnipeTarget then
                --Does the target have fixed shield coverage?
                local bUnderFixedShield = false
                local tTargetLZData, tTargetLZTeamData = M28Map.GetLandOrWaterZoneData(oUnit:GetPosition(), true, iTeam)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether enemy target has fixed shield coverage, (tTargetLZTeamData[M28Map.subrefLZThreatEnemyShield]='..(tTargetLZTeamData[M28Map.subrefLZThreatEnemyShield] or 0)) end
                if (tTargetLZTeamData[M28Map.subrefLZThreatEnemyShield] or 0) > 0 then
                    local tFixedShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, tTargetLZTeamData[M28Map.subrefTEnemyUnits])
                    local iMaxDistanceToShield = 10
                    local iCurDist, iCurShield, iMaxShield
                    if oUnit[M28UnitInfo.refbIsSnipeTarget] then iMaxDistanceToShield = 0 end
                    if M28Utilities.IsTableEmpty(tFixedShields) == false then
                        for iShield, oShield in tFixedShields do
                            if M28UnitInfo.IsUnitValid(oShield) then
                                iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oShield, false)
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; iCurShield='..iCurShield..'; Dist to ACU='..M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oUnit:GetPosition())..'; Shield radius='..(oShield:GetBlueprint().Defense.Shield.ShieldSize or 10) * 0.5) end
                                if iCurShield >= 4000 then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oShield:GetPosition())
                                    if iCurDist <= iMaxDistanceToShield then
                                        bAddAsSnipeTarget = false
                                    else
                                        local iShieldRadius = (oShield:GetBlueprint().Defense.Shield.ShieldSize or 10) * 0.5
                                        if iCurDist - iShieldRadius <= iMaxDistanceToShield then
                                            bAddAsSnipeTarget = false
                                        end
                                    end
                                end
                            end
                        end
                    end

                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Near end of code for oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' for iTeam='..iTeam..', was this a snipe target before='..tostring((oUnit[M28UnitInfo.refbIsSnipeTarget] or false))..'; bAddAsSnipeTarget='..tostring(bAddAsSnipeTarget)..'; Time='..GetGameTimeSeconds()) end
    if bAddAsSnipeTarget == (oUnit[M28UnitInfo.refbIsSnipeTarget] or false) then
        --Do nothing
    else
        --Are either removing or adding to snipe table
        if bAddAsSnipeTarget then
            table.insert(tTeamData[iTeam][toActiveSnipeTargets], oUnit)
        else
            for iEntry, oEntry in tTeamData[iTeam][toActiveSnipeTargets] do
                if oEntry == oUnit then
                    table.remove(tTeamData[iTeam][toActiveSnipeTargets], iEntry)
                    break
                end
            end
        end
        oUnit[M28UnitInfo.refbIsSnipeTarget] = bAddAsSnipeTarget
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SnipeOverseer(iTeam)
    local sFunctionRef = 'SnipeOverseer'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    while true do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        --Decide if want to stop monitoring
        if M28Utilities.IsTableEmpty(tTeamData[iTeam][toActiveSnipeTargets]) then
            if M28Utilities.IsTableEmpty(tTeamData[iTeam][reftEnemyLandExperimentals]) == false or tTeamData[iTeam][refiEnemyAirAAThreat] >= 10000 or tTeamData[iTeam][refiEnemyAirToGroundThreat] >= 10000 or tTeamData[iTeam][refiConstructedExperimentalCount] > 0 or GetGameTimeSeconds() >= 1800 then
                if bDebugMessages == true then LOG(sFunctionRef..': We want to stop monitoring for snipe targets as game has gotten too late, iTeam='..iTeam..'; TIme='..GetGameTimeSeconds()) end
                break
            end
            if M28Utilities.IsTableEmpty(tTeamData[iTeam][reftEnemyACUs]) == false then
                for iUnit, oUnit in tTeamData[iTeam][reftEnemyACUs] do
                    ConsiderAddingUnitAsSnipeTarget(oUnit, iTeam)
                end
            end
        else
            --Either way we want to consider ACUs, since hte function will consider removing them from snipe targets or adding other snipe targets
            if M28Utilities.IsTableEmpty(tTeamData[iTeam][reftEnemyACUs]) == false then
                for iUnit, oUnit in tTeamData[iTeam][reftEnemyACUs] do
                    ConsiderAddingUnitAsSnipeTarget(oUnit, iTeam)
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': end of code') end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MonitorLeavingT1SpamMode(iTeam)
    local sFunctionRef = 'MonitorLeavingT1SpamMode'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Will start monitoring whether we want to cancel our t1 spam flag for iTeam='..iTeam..'; Start of code, time='..GetGameTimeSeconds()) end
    if not(tTeamData[iTeam][refbActiveT1SpamMonitor]) and tTeamData[iTeam][refbFocusOnT1Spam] then
        tTeamData[iTeam][refbActiveT1SpamMonitor] = true

        local iMexesWantedToExit = table.getn(M28Map.tMassPoints) * 0.65
        if bDebugMessages == true then LOG(sFunctionRef..': We are focusing on t1 spam at the moment, about to start main loop, iMexesWantedToExit='..iMexesWantedToExit) end
        while tTeamData[iTeam][refbFocusOnT1Spam] do --(allows us turning this off elsewhere, e.g. when we build enough T2 power that we can start reclaiming t1 power)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            --Various cases where we want to stop t1 spam:
            if GetGameTimeSeconds() >= 1080 or (tTeamData[iTeam][subrefiHighestEnemyAirTech] or 0) >= 3 or (tTeamData[iTeam][subrefiHighestEnemyGroundTech] or 0) >= 3 or (tTeamData[iTeam][subrefiHighestEnemyGroundTech] or 0) >= 3
                    or (tTeamData[iTeam][refiEnemyAirToGroundThreat] or 0) >= 1000 or tTeamData[iTeam][subrefiTeamGrossMass] >= 20 or M28Utilities.IsTableEmpty(tTeamData[iTeam][reftoEnemyT2Arti]) == false
                    or tTeamData[iTeam][subrefiHighestFriendlyFactoryTech] >= 3 or tTeamData[iTeam][subrefiHighestFriendlyNavalFactoryTech] >= 2
                    or M28Utilities.IsTableEmpty(tTeamData[iTeam][reftLongRangeEnemyDFUnits]) == false
                    or M28Conditions.GetHighestOtherTeamT3MexCount(iTeam) >= 2 or M28Utilities.IsTableEmpty(tTeamData[iTeam][reftEnemyLandExperimentals]) == false or M28Utilities.IsTableEmpty(tTeamData[iTeam][refiConstructedExperimentalCount]) == false
                    or M28Overseer.bNoRushActive then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to cancel t1 spam based on one of basic flags') end
                break
            else
                --How many mexes do we have
                local iTotalMexCount = 0
                for iBrain, oBrain in tTeamData[iTeam][subreftoFriendlyActiveM28Brains] do
                    iTotalMexCount = iTotalMexCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryMex)
                end
                if iTotalMexCount >= iMexesWantedToExit then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to leave as have most of hte mexes on the map') end
                    break
                end
                --Exit t1 spam mode early on 10km maps
                if M28Map.iMapSize >= 512 and (GetGameTimeSeconds() >= 600 or (tTeamData[iTeam][subrefiHighestEnemyNavyTech] or 0) >= 1 or (tTeamData[iTeam][subrefiHighestFriendlyNavalFactoryTech] or 0) >= 1 or (tTeamData[iTeam][subrefiHighestFriendlyAirFactoryTech] or 0) >= 2 or tTeamData[iTeam][subrefiTeamGrossEnergy] >= 900 * tTeamData[iTeam][refiHighestBrainResourceMultiplier]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': 10km so want to leave earlier than if was 5k') end
                    break
                end
                if bDebugMessages == true then LOG(sFunctionRef..': End of loop at time='..GetGameTimeSeconds()..'; want to continue with t1 spam for now') end
            end

        end
        if bDebugMessages == true then LOG(sFunctionRef..': Exiting t1 spam mode now for team '..iTeam..', time='..GetGameTimeSeconds()) end
        tTeamData[iTeam][refbFocusOnT1Spam] = false
        tTeamData[iTeam][refbActiveT1SpamMonitor] = false

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MonitorVulnerableFatboys(iTeam)
    if not(tTeamData[iTeam][refbActiveVulnerableFatboyMonitor]) then
        tTeamData[iTeam][refbActiveVulnerableFatboyMonitor] = true
        local iCurShield, iMaxShield
        while M28Conditions.IsTableOfUnitsStillValid(tTeamData[iTeam][reftoVulnerableFatboys]) do
            for iCurFatboy = table.getn(tTeamData[iTeam][reftoVulnerableFatboys]), 1, -1 do
                local oFatboy = tTeamData[iTeam][reftoVulnerableFatboys][iCurFatboy]
                iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oFatboy, true)
                if (iCurShield >= 1500 and iCurShield / iMaxShield >= 0.6) or M28UnitInfo.IsUnitUnderwater(oFatboy) then
                    table.remove(tTeamData[iTeam][reftoVulnerableFatboys], iCurFatboy)
                    if M28Utilities.IsTableEmpty(tTeamData[iTeam][refbActiveVulnerableFatboyMonitor]) then break end
                end
            end
            WaitSeconds(10)
        end
        tTeamData[iTeam][refbActiveVulnerableFatboyMonitor] = false
    end
end

function RefreshRecentEnemyTeleportLocations(iTeam)
    local sFunctionRef = 'RefreshRecentEnemyTeleportLocations'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(tTeamData[iTeam][reftRecentEnemyTeleportDetails]) == false then
        for iCurEntry = table.getn(tTeamData[iTeam][reftRecentEnemyTeleportDetails]), 1, -1 do
            local tCurEntry = tTeamData[iTeam][reftRecentEnemyTeleportDetails][iCurEntry]
            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry '..iCurEntry..'; Is teleport unit valid='..tostring(M28UnitInfo.IsUnitValid(tCurEntry[subrefoTeleportUnit]))..'; reftActiveTeleportLocation='..repru(tCurEntry[subrefoTeleportUnit][M28UnitInfo.reftActiveTeleportLocation])..'; Cur time='..GetGameTimeSeconds()..'; Time since teleport attempt='..GetGameTimeSeconds() - tCurEntry[subrefiTeleportTime]) end
            if not(M28UnitInfo.IsUnitValid(tCurEntry[subrefoTeleportUnit])) or GetGameTimeSeconds() - tCurEntry[subrefiTeleportTime] >= 180 or not(tCurEntry[subrefoTeleportUnit][M28UnitInfo.reftActiveTeleportLocation]) or M28Utilities.GetDistanceBetweenPositions(tCurEntry[subrefoTeleportUnit][M28UnitInfo.reftActiveTeleportLocation], tCurEntry[subreftTeleportTarget]) >= 5 then
                table.remove(tTeamData[iTeam][reftRecentEnemyTeleportDetails], iCurEntry)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function EnemyNovaxSatelliteMonitor(oNovax, iTeam)
    --Tracks enemy novax and flags for zones that are near it (so they can e.g. get more mobile shielding)
    local sFunctionRef = 'EnemyNovaxSatelliteMonitor'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iNearbyZoneMidpointDistThreshold = 150 --Dist between the novax zone midpoint and the cur zone midpoint - want to beh igher than main search range in case novax is towards the edge of the midpoint
    local iNovaxDistToMidpointThreshold = 100
    while M28UnitInfo.IsUnitValid(oNovax) and tTeamData[iTeam][subrefiActiveM28BrainCount] > 0 do
        local tStartLZOrWZData, tStartLZOrWZTeamData = M28Map.GetLandOrWaterZoneData(oNovax:GetPosition(), true, iTeam)
        if tStartLZOrWZData then
            tStartLZOrWZTeamData[M28Map.refiTimeOfNearbyEnemyNovax] = GetGameTimeSeconds()
            M28Air.RecordOtherLandAndWaterZonesByDistance(tStartLZOrWZData, tStartLZOrWZData[M28Map.subrefMidpoint])
            if M28Utilities.IsTableEmpty(tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                for iEntry, tSubtable in tStartLZOrWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                    if tSubtable[M28Map.subrefiDistance] > iNearbyZoneMidpointDistThreshold then break end
                    local tAltLZOrWZData
                    local iCurLZOrWZRef = tSubtable[M28Map.subrefiLandOrWaterZoneRef]
                    if tSubtable[M28Map.subrefbIsWaterZone] then
                        tAltLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iCurLZOrWZRef]][M28Map.subrefPondWaterZones][iCurLZOrWZRef]
                    else
                        tAltLZOrWZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][iCurLZOrWZRef]
                    end
                    if M28Utilities.GetDistanceBetweenPositions(oNovax:GetPosition(), tAltLZOrWZData[M28Map.subrefMidpoint]) <= iNovaxDistToMidpointThreshold then
                        local tAltLZOrWZTeamData
                        if tSubtable[M28Map.subrefbIsWaterZone] then
                            tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                        else
                            tAltLZOrWZTeamData = tAltLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                        end
                        tAltLZOrWZTeamData[M28Map.refiTimeOfNearbyEnemyNovax] = GetGameTimeSeconds()
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end