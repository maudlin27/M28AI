---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 19:23
---
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Config = import('/mods/M28AI/lua/M28Config.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')
local M28Navy = import('/mods/M28AI/lua/AI/M28Navy.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')



--Global variables
bBuildLocationLoopActive = false --true if have a loop that is checking for build locations
bWZBuildLocationLoopActive = false --as above but for water zones
tsBlueprintsBySize = {[1] = 'ueb2101', [2] = 'ueb1101', [3] = 'ueb4302', [6] = 'ueb1201', [8] = 'ueb1301', [9]='xrl0403', [10]='uab0304', [16] = 'xsa0402', [22] = 'mai2822', [24] = 'mai2824', [26] = 'mai2826'} --[24] = 'uaa0310'} --Blueprints to use when trying to find locations that can buid on for a building of a particular size
tsWZBlueprintsBySize = {[1] = 'ueb2109', [2] = 'ueb4201', [6] = 'ual0401', [8] = 'ura0401', [9]='uel0401', [10]='ueb0103', [14]='ueb0103', [16]='uas0401', [24]='uaa0310'} --Blueprints to use when trying to find locations that can buid on on water for a building/engineer built unit of a particular size
iMaxBuildingSize = 24
--Some blueprints have different skirt size offsets, e.g. naval factories; current solution is to manually note any of the BlueprintsBySize blueprints above and then list alternatives to try
tsExtraBlueprintsToCheck = {['ueb0103'] = {'urb0103', 'xsb0103'},
}
tAllScathis = {} --If a scathis is constructed it gets recorded here (and we then check this for build locations to avoid trying to build on a scathis); for performance reasons will just use a single global table
tiBPByTech = {[0]=5,[1]=5,[2]=12.5,[3]=30, [4]=30}
iCurQueueRefNumber = 0

bActiveDestroyedBuildingLoop = false
tRecentlyDestroyedBuildings = {} --ordered 1, 2,..x
    subrefDestroyedBuildingBlueprint = 'DBP' --blueprint only
    subrefDestroyedBuildingLocation = 'DPS' --'Location, i.e. {xyz}
    subrefDestroyedBuildingTime = 'DTM' --gametimeseconds

--against brain:
--refiEngineerCurUniqueReference - this is also against unit so is declared in below section rather than here

--Against unit varaibles
refiEngineerCurUniqueReference = 'M28EngCurUniqueReference' --Against both aiBrain and engineer; aiBrain stores the xth engineer object its given an action to, so this can be used as a unique reference
refiAssignedAction = 'M28EngAssignedAction' --against Engineer, records the refAction value the engineer was given if it has an active order
reftAssignedReclaimSegments = 'M28EngReclaimSegments' --against engineer, returns {iReclaimSegmentX, iReclaimSegmentZ]}, used when engineer givne a reclaim area order
refbPrimaryBuilder = 'M28EngPrimaryBuilder' --If was the first engineer assigned to build something (and isnt assisting) then this should be true
refbHasSpareAction = 'M28EngSpareA' --true if engineer has spare action, nil or false if it doesnt
reftUnitsReclaimingUs = 'M28EngReclaimingUnits' --If have queued up reclaim order on a unit, this will store all units given such an order
reftUnitsWeAreReclaiming = 'M28EngUnitsReclaiming' --If have queued up reclaim order on a unit, this stors against the reclaimer the unit being reclaimed
reftQueuedBuildings = 'M28EngQueuedBuildings' --Whenever issuebuild order is given it should update this
subrefQueueRef = 1 --Unique queue reference number (the same as the ref number given to the land zone)
subrefBuildingID = 2 --Blueprint/UnitId of the building queued
subrefBuildingLocation = 3 --Location the building is to be built at
subrefBuildingRadius = 4 --Size (radius) of the building
subrefPlateauOrZero = 5 --Plateau where hte building is to be built; zero if water zone
subrefLandOrWaterZone = 6 --Land zone where hte building is to be built
refbBuildingExperimental = 'M28EngBuildingExperimental' --True if engineer is building an experimental andh aving itself tracked in the team table for this
refiAssignedActionPriority = 'M28EngPriority' --Priority of the currently assigned action
reftUnitBlacklistSegmentXZ = 'M28UnitBlacklist' --table, ordered 1, 2...', returns {SegmentX, SegmentZ} - contains blacklist details for a unit, used for under construciton experimentals so when construction completes the blacklist status can be cleared
refiGETemplateTimeTryingToBuild = 'M28UnitTimBldGE' --If an engineer on gameender template duty is trying to construct somethign, this tracks how man ycycles it has been trying to construct before being given a reset order
refiPlateauAndZoneTravelingBeforeTempReclaimOrder = 'M28EngTrZT' --If engineer was moving to a land zone but was then temporarily given a reclaim order, then this shoudl record the zone itw as traveling to prior to the reclaim order and then give it a new travel order to this zone even if another engi is also going there

--Shield related variables against a unit
refiFailedShieldBuildDistance = 'M28EngFailedShieldBuildDist' --against a building wanting shielding - records the distance of the closest location that we can build (so can decide if the unit can even be shielded)
refiFailedShieldConstructionCount = 'M28EngFailedShdCnt' --Number of times we have tried to get a build locatino to cover this unit and failed
refoUnitActivelyShielding = 'M28EngUntActShd' --against the engineer, gives the unit e.g. gameender it is providing special shielding services to
refbActiveUnitShieldingThread = 'M28EngActivShld' --against the gameender/similar unit, true if it has a thread that isa ctively trying to use engineers to protect it
reftEngineersActivelyShielding = 'M28EngActiveEngShd' --against the gameender/similar unit, contains table of all the engineers assigned toa ctively try and protect it
refbDontIncludeAsPartCompleteBuildingForConstruction = 'M28EngActiveShdD' --True if shield is being used for active special shielding defence - i.e. will check for this flag to make sure a normal build shield action doenst assist it
refiTimeOfLastShieldRepairOrder = 'M28EngTimeLastOrd' --For units that are repairing, dont want to reissue the same order multiple times


--Actions for engineers (dont have as local variables due to cap on how many local variables we can have)
--Intended actions are those from M27 that havent been integrated yet
refActionBuildMex = 1
refActionBuildHydro = 2
refActionReclaimArea = 3
refActionBuildPower = 4
refActionBuildLandFactory = 5
refActionBuildEnergyStorage = 6
refActionSpare = 7
refActionHasNearbyEnemies = 8
refActionUpgradeBuilding = 9
refActionBuildSecondPower = 10
refActionBuildAirStaging = 11
refActionBuildAirFactory = 12
refActionBuildSMD = 13
refActionBuildMassStorage = 14
refActionBuildT1Radar = 15
refActionBuildT2Radar = 16
refActionBuildT3Radar = 17
refActionAssistSMD = 18
refActionAssistAirFactory = 19
refActionBuildThirdPower = 20
refActionBuildExperimental = 21
refActionReclaimFriendlyUnit = 22
--See below for reclaimenemyunit action
refActionBuildT3MexOverT2 = 23
refActionUpgradeHQ = 24 --Assists an HQ with its upgrade
refActionReclaimTrees = 25
refActionBuildT1Sonar = 26
refActionBuildT2Sonar = 27
refActionAssistNuke = 28
refActionBuildShield = 29
refActionBuildT3ArtiPower = 30
refActionBuildTMD = 31
refActionBuildAA = 32
refActionBuildEmergencyPD = 33 --Indented values below mean not yet got the main code in place
refActionBuildSecondLandFactory = 34
refActionBuildSecondAirFactory = 35
refActionBuildTML = 36
refActionBuildSecondExperimental = 37
refActionLoadOntoTransport = 38
refActionFortifyFirebase = 39
refActionAssistShield = 40
refActionBuildSecondShield = 41
refActionBuildEmergencyArti = 42 --Not yet got the main code in place that M27 used, for now just have basic placeholder that builds T2 the same as a normal building
refActionAssistTML = 43
refActionBuildQuantumGateway = 44
refActionBuildQuantumOptics = 45
refActionBuildHive = 46
refActionSelenMexBuild = 47
refActionBuildSecondTMD = 48
refActionBuildNavalFactory = 49
refActionAssistNavalFactory = 50
refActionNavalSpareAction = 51
refActionBuildWall = 52 --E.g. for building walls around T1 PD
refActionBuildT3MexOnly = 53
refActionAssistMexUpgrade = 54
refActionSAMCreep = 55 --Intended to gradually expand SAM coverage for mexes
refActionBuildMassFab = 56 --For T2 mass fabs to be built by mass storage
refActionMoveToLandZone = 57
refActionRunToLandZone = 58
refActionMoveToWaterZone = 59
refActionRunToWaterZone = 60
refActionAssistUpgrade = 61
refActionReclaimEnemyUnit = 62
refActionBuildSecondMassStorage = 63
refActionCompletePartBuiltMex = 64
refActionBuildExperimentalNavy = 65
refActionBuildGameEnder = 66
refActionBuildLandExperimental = 67 --e.g. for when building in water
refActionCaptureUnit = 68
refActionRepairUnit = 69 --e.g. can use to repair an underconstruction building
refActionSpecialShieldDefence = 70 --Covers the building of shields, but uses different approach to normal, intended for protecting a game ender from sustained T3 arti fire
refActionBuildT3MassFab = 71 --Just for building t3 mass fab
refActionAssistLandFactory = 72
refActionBuildT1TorpLauncher = 73
refActionBuildTorpLauncher = 74
refActionManageGameEnderTemplate = 75 --if there's an available template for building t3 arti or a gameender, then this action shoudl be used

--tiEngiActionsThatDontBuild = {refActionReclaimArea, refActionSpare, refActionNavalSpareAction, refActionHasNearbyEnemies, refActionReclaimFriendlyUnit, refActionReclaimTrees, refActionUpgradeBuilding, refActionAssistSMD, refActionAssistTML, refActionAssistMexUpgrade, refActionAssistAirFactory, refActionAssistNavalFactory, refActionUpgradeHQ, refActionAssistNuke, refActionLoadOntoTransport, refActionAssistShield}

tiLastBuildingSizeFromActionForTeam = {} --[x] is the team ref, [y] is the action ref, returns the building size (if there was one), used to help stop logic if we have run out of places to build

--Categories to use where no complex logic required (if it wont always be the same category then add logic to GetCategoryToBuildOrAssistFromAction
tiActionCategory = {
    [refActionBuildMex] = M28UnitInfo.refCategoryT1Mex,
    [refActionBuildHydro] = M28UnitInfo.refCategoryHydro,
    [refActionBuildPower] = M28UnitInfo.refCategoryPower - categories.NAVAL, --some mods like xtremewars add a naval power building
    [refActionBuildLandFactory] = M28UnitInfo.refCategoryLandFactory,
    [refActionBuildSecondPower] = M28UnitInfo.refCategoryPower - categories.NAVAL,
    [refActionBuildAirStaging] = M28UnitInfo.refCategoryAirStaging,
    [refActionBuildAirFactory] = M28UnitInfo.refCategoryAirFactory,
    [refActionBuildSecondAirFactory] = M28UnitInfo.refCategoryAirFactory,
    [refActionBuildSMD] = M28UnitInfo.refCategorySMD,
    [refActionBuildMassStorage] = M28UnitInfo.refCategoryMassStorage,
    [refActionBuildT1Radar] = M28UnitInfo.refCategoryT1Radar,
    [refActionBuildT2Radar] = M28UnitInfo.refCategoryT2Radar,
    [refActionBuildT3Radar] = M28UnitInfo.refCategoryT3Radar,
    [refActionAssistSMD] = M28UnitInfo.refCategorySMD,
    [refActionAssistAirFactory] = M28UnitInfo.refCategoryAirFactory,
    [refActionAssistLandFactory] = M28UnitInfo.refCategoryLandFactory,
    [refActionBuildEnergyStorage] = M28UnitInfo.refCategoryEnergyStorage,
    [refActionBuildThirdPower] = M28UnitInfo.refCategoryPower - categories.NAVAL,
    [refActionBuildT1Sonar] = M28UnitInfo.refCategoryT1Sonar,
    [refActionBuildT2Sonar] = M28UnitInfo.refCategoryT2Sonar,
    --[refActionBuildShield] = M28UnitInfo.refCategoryFixedShield, --Use custom logic so we will consider only building t2 shields in some cases
    --[refActionBuildSecondShield] = M28UnitInfo.refCategoryFixedShield, --use custom logic so we will consider only building t2 shields in some cases
    [refActionBuildNavalFactory] = M28UnitInfo.refCategoryNavalFactory,
    [refActionAssistNavalFactory] = M28UnitInfo.refCategoryNavalFactory,
    [refActionBuildTMD] = M28UnitInfo.refCategoryTMD,
    [refActionBuildAA] = M28UnitInfo.refCategoryStructureAA - categories.EXPERIMENTAL,
    --refActionBuildEmergencyPD - will use custom code as sometimes want T1 PD
    [refActionBuildEmergencyArti] = M28UnitInfo.refCategoryFixedT2Arti,
    [refActionBuildQuantumGateway] = M28UnitInfo.refCategoryQuantumGateway,
    [refActionBuildSecondLandFactory] = M28UnitInfo.refCategoryLandFactory,
    [refActionBuildTML] = M28UnitInfo.refCategoryTML,
    [refActionAssistShield] = M28UnitInfo.refCategoryFixedShield * categories.TECH3,
    [refActionBuildSecondMassStorage] = M28UnitInfo.refCategoryMassStorage,
    [refActionCompletePartBuiltMex] = M28UnitInfo.refCategoryT1Mex,
    [refActionBuildExperimentalNavy] = categories.NAVAL * categories.EXPERIMENTAL - categories.UNSELECTABLE - categories.UNTARGETABLE,
    [refActionBuildGameEnder] = M28UnitInfo.refCategoryGameEnder,
    [refActionBuildLandExperimental] = M28UnitInfo.refCategoryLandExperimental,
    [refActionBuildWall] = M28UnitInfo.refCategoryWall,
    [refActionBuildT3MassFab] = M28UnitInfo.refCategoryMassFab * categories.TECH3,
    [refActionBuildT1TorpLauncher] = M28UnitInfo.refCategoryTorpedoLauncher * categories.TECH1,
    [refActionBuildTorpLauncher] = M28UnitInfo.refCategoryTorpedoLauncher,
    [refActionManageGameEnderTemplate] = refActionManageGameEnderTemplate, --Special case where if a category is equal to this variable then will apply this logic; done this way so we can convert a 'build experimental' action into this action
}

tiActionOrder = {
    [refActionBuildMex] = M28Orders.refiOrderIssueBuild,
    [refActionBuildHydro] = M28Orders.refiOrderIssueBuild,
    [refActionBuildPower] = M28Orders.refiOrderIssueBuild,
    [refActionBuildLandFactory] = M28Orders.refiOrderIssueBuild,
    [refActionBuildSecondPower] = M28Orders.refiOrderIssueBuild,
    [refActionBuildAirStaging] = M28Orders.refiOrderIssueBuild,
    [refActionBuildAirFactory] = M28Orders.refiOrderIssueBuild,
    [refActionBuildSecondAirFactory] = M28Orders.refiOrderIssueBuild,
    [refActionBuildEnergyStorage] = M28Orders.refiOrderIssueBuild,
    [refActionMoveToLandZone] = M28Orders.refiOrderIssueMove,
    [refActionRunToLandZone] = M28Orders.refiOrderIssueMove,
    [refActionMoveToWaterZone] = M28Orders.refiOrderIssueMove,
    [refActionRunToWaterZone] = M28Orders.refiOrderIssueMove,
    [refActionReclaimFriendlyUnit] = M28Orders.refiOrderIssueReclaim,
    [refActionAssistUpgrade] = M28Orders.refiOrderIssueGuard,
    [refActionAssistAirFactory] = M28Orders.refiOrderIssueGuard,
    [refActionAssistLandFactory] = M28Orders.refiOrderIssueGuard,
    [refActionBuildSMD] = M28Orders.refiOrderIssueBuild,
    [refActionBuildMassStorage] = M28Orders.refiOrderIssueBuild,
    [refActionBuildT1Radar] = M28Orders.refiOrderIssueBuild,
    [refActionBuildT2Radar] = M28Orders.refiOrderIssueBuild,
    [refActionBuildT3Radar] = M28Orders.refiOrderIssueBuild,
    [refActionAssistSMD] = M28Orders.refiOrderIssueGuard,
    [refActionBuildThirdPower] = M28Orders.refiOrderIssueBuild,
    [refActionBuildExperimental] = M28Orders.refiOrderIssueBuild,
    [refActionBuildSecondExperimental] = M28Orders.refiOrderIssueBuild,
    [refActionReclaimArea] = M28Orders.refiOrderIssueReclaim,--will actually have a move order followed by reclaim order
    [refActionBuildT1Sonar] = M28Orders.refiOrderIssueBuild,
    [refActionBuildT2Sonar] = M28Orders.refiOrderIssueBuild,
    [refActionBuildShield] = M28Orders.refiOrderIssueBuild,
    [refActionBuildSecondShield] = M28Orders.refiOrderIssueBuild,
    [refActionBuildNavalFactory] = M28Orders.refiOrderIssueBuild,
    [refActionAssistNavalFactory] = M28Orders.refiOrderIssueGuard,
    [refActionBuildTMD] = M28Orders.refiOrderIssueBuild,
    [refActionBuildAA] = M28Orders.refiOrderIssueBuild,
    [refActionBuildEmergencyPD] = M28Orders.refiOrderIssueBuild,
    [refActionBuildEmergencyArti] = M28Orders.refiOrderIssueBuild,
    [refActionBuildQuantumGateway] = M28Orders.refiOrderIssueBuild,
    [refActionBuildSecondLandFactory] = M28Orders.refiOrderIssueBuild,
    [refActionBuildTML] = M28Orders.refiOrderIssueBuild,
    [refActionLoadOntoTransport] = M28Orders.refiOrderLoadOntoTransport, --sometimes will be a move order
    [refActionAssistShield] = M28Orders.refiOrderIssueGuard,
    [refActionReclaimEnemyUnit] = M28Orders.refiOrderIssueReclaim,
    [refActionBuildSecondMassStorage] = M28Orders.refiOrderIssueBuild,
    [refActionCompletePartBuiltMex] = M28Orders.refiOrderIssueBuild,
    [refActionBuildExperimentalNavy] = M28Orders.refiOrderIssueBuild,
    [refActionBuildGameEnder] = M28Orders.refiOrderIssueBuild,
    [refActionBuildLandExperimental] = M28Orders.refiOrderIssueBuild,
    [refActionCaptureUnit] = M28Orders.refiOrderIssueCapture,
    [refActionRepairUnit] = M28Orders.refiOrderIssueRepair,
    [refActionSpecialShieldDefence] = M28Orders.refiOrderIssueBuild, --Sometimes will want to be idle
    [refActionBuildWall] = M28Orders.refiOrderIssueBuild,
    [refActionBuildT3MassFab] = M28Orders.refiOrderIssueBuild,
    [refActionBuildT1TorpLauncher] = M28Orders.refiOrderIssueBuild,
    [refActionBuildTorpLauncher] = M28Orders.refiOrderIssueBuild,
    [refActionManageGameEnderTemplate] = M28Orders.refiOrderIssueBuild, --will use custom logic
}

--Adjacent categories to search for for a particular action
tiActionAdjacentCategory = {
    [refActionBuildPower] = M28UnitInfo.refCategoryAirFactory * categories.TECH3 + M28UnitInfo.refCategoryAirFactory * categories.TECH2 + M28UnitInfo.refCategoryT3Radar + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategorySML + M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti * categories.UEF + M28UnitInfo.refCategoryMassFab * categories.TECH3,
    [refActionBuildSecondPower] = M28UnitInfo.refCategoryAirFactory * categories.TECH3 + M28UnitInfo.refCategoryT3Radar + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategorySML + M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti * categories.UEF + M28UnitInfo.refCategoryMassFab * categories.TECH3,
    [refActionBuildThirdPower] = M28UnitInfo.refCategorySML + M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti * categories.UEF + M28UnitInfo.refCategoryMassFab * categories.TECH3,
    [refActionBuildLandFactory] = M28UnitInfo.refCategoryMex,
    [refActionBuildAirFactory] = M28UnitInfo.refCategoryT3Power + M28UnitInfo.refCategoryHydro,
    [refActionBuildSecondAirFactory] = M28UnitInfo.refCategoryT3Power + M28UnitInfo.refCategoryHydro,
    [refActionBuildSMD] = M28UnitInfo.refCategoryT3Power,
    [refActionBuildT1Radar] = M28UnitInfo.refCategoryT1Power,
    [refActionBuildT2Radar] = M28UnitInfo.refCategoryT2Power,
    [refActionBuildT3Radar] = M28UnitInfo.refCategoryT3Power,
    [refActionBuildT3MassFab] = M28UnitInfo.refCategoryT3Power,
}

--Include any actions where we wont be building a category or searching for a category to assist
--The difference between this and tiActionCategory is for buildings where we need special code to determine the category to build, such as emergency PD (T1 vs T2 vs T3)
tbActionsThatDontHaveCategory = {
    [refActionMoveToLandZone] = true,
    [refActionRunToLandZone] = true,
    [refActionMoveToWaterZone] = true,
    [refActionRunToWaterZone] = true,
    [refActionReclaimFriendlyUnit] = true,
    [refActionAssistUpgrade] = true, --need special logic to only identify upgrading units for this
    [refActionReclaimArea] = true,
    [refActionReclaimEnemyUnit] = true,
    [refActionLoadOntoTransport] = true,
    [refActionCaptureUnit] = true,
    [refActionRepairUnit] = true,
    [refActionSpecialShieldDefence] = true,
    --Not set for refActionManageGameEnderTemplate as will treat it as having a category ref equal to the action ref itself
}

tiIgnoreUnderConstructionThreshold = { --specify the number of under construction units to ignore, e.g. if set as 1, then if we only have 1 under construction we will build a new one, but if we have 2+ we will assist an under construction one (picking one that is less well complete)
    [refActionBuildMex] = 100,
    [refActionBuildSecondLandFactory] = 1,
    [refActionBuildSecondAirFactory] = 1,
    [refActionBuildSecondMassStorage] = 1,
    [refActionBuildSecondPower] = 1,
    [refActionBuildThirdPower] = 2,
    [refActionBuildSecondExperimental] = 1, --have a manual override for this where we are building t3 arti or g ameender
    [refActionBuildSecondShield] = 1,
    [refActionManageGameEnderTemplate] = 100, --Dont want to try and search for buildings to assist with this action as will handle via special logic
}

tbIgnoreEngineerAssistance = { --Any actions where we dont want to assist an engineer already constructiong the building should go here; main purpose is building a mex
    [refActionBuildMex] = true,
    [refActionCompletePartBuiltMex] = true,
    [refActionAssistShield] = true,
    [refActionLoadOntoTransport] = true,
    [refActionBuildWall] = true,
    [refActionManageGameEnderTemplate] = true, --will have special logic to handle
}

tbActionsWithFactionSpecificLogic = { --Any actions where it is important to know what factions we have available when deciding what to build
    [refActionBuildExperimental] = true,
    [refActionBuildSecondExperimental] = true,
}

tiActionSubstitute = { --Any actions where we want to take into account BP already assigned to the specified alternative action
    [refActionBuildExperimental] = refActionManageGameEnderTemplate,
    [refActionBuildSecondExperimental] = refActionManageGameEnderTemplate,
    [refActionBuildGameEnder] = refActionManageGameEnderTemplate,
}




function GetEngineerUniqueCount(oEngineer)
    local iUniqueRef = oEngineer[refiEngineerCurUniqueReference]
    if iUniqueRef == nil then
        local aiBrain = oEngineer:GetAIBrain()
        iUniqueRef = aiBrain[refiEngineerCurUniqueReference] + 1
        aiBrain[refiEngineerCurUniqueReference] = iUniqueRef
        oEngineer[refiEngineerCurUniqueReference] = iUniqueRef
    end
    return iUniqueRef
end

function IsBuildLocationBlockedByResources(tLZOrWZData, iBuildingRadius, tTargetLocation, bAvoidStorageAdjacency)
    --Brain:CanBuildStructureAt() ignores (unbuilt) resource deposits, i.e. mexes and hydros; this cycles through all such locations and checks if they are blocking

    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZMexLocations]) == false then
        local iRadiusThreshold = 0.99
        if bAvoidStorageAdjacency then iRadiusThreshold = 2.9 end
        local iCurXDif, iCurZDif
        for iMex, tMex in tLZOrWZData[M28Map.subrefLZMexLocations] do --WZs use same ref
            iCurXDif = math.abs(tMex[1] - tTargetLocation[1])
            if iCurXDif <= iBuildingRadius + iRadiusThreshold then --mex is 2x2 in size
                iCurZDif = math.abs(tMex[3] - tTargetLocation[3])
                if iCurZDif <= iBuildingRadius + iRadiusThreshold then
                    --Check not on a corner position
                    if iCurXDif <= iBuildingRadius or iCurZDif <= iBuildingRadius or math.abs(iCurXDif - iCurZDif) >= iRadiusThreshold then
                        return true
                    end
                end
            end
        end
    end
    --Check hydros
    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefHydroLocations]) == false then
        local iCurXDif, iCurZDif
        for iHydro, tHydro in tLZOrWZData[M28Map.subrefHydroLocations] do --WZs use same ref
            iCurXDif = math.abs(tHydro[1] - tTargetLocation[1])
            if iCurXDif <= iBuildingRadius + 2.99 then --hydro is 6x6 in size
                iCurZDif = math.abs(tHydro[3] - tTargetLocation[3])
                if iCurZDif <= iBuildingRadius + 2.99 then
                    --Check not on a corner position
                    if iCurXDif <= iBuildingRadius or iCurZDif <= iBuildingRadius or math.abs(iCurXDif - iCurZDif) >= 0.99 then
                        return true
                    end
                end
            end
        end
    end

    return false
end

function CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, iOptionalPlateauGroupOrZero, iOptionalLandOrWaterZone, iEngiActionToIgnore, bClearActionsIfNotStartedBuilding, bCheckForQueuedBuildings, bCheckForOverlappingBuildings, bCheckBlacklistIfNoGameEnder)
    --iOptionalPlateauGroupOrZero, iOptionalLandOrWaterZone, iEngiActionToIgnore, bClearActionsIfNotStartedBuilding and bCheckForOverlappingBuildings are optional
    --iOptionalPlateauGroupOrZero and iOptionalLandOrWaterZone: If specified, then will check this zone for queued units, if bCheckForQueuedBuildings is true
    --bCheckBlacklistIfNoGameEnder - will checkblacklist if either this is true, or the zone contains a gameender

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CanBuildAtLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then
        LOG(sFunctionRef..': About to see if we can build '..(sBlueprintToBuild or 'nil')..' at '..repru(tTargetLocation)..'; iEngiActionToIgnore='..(iEngiActionToIgnore or 'nil')..'; bClearActionsIfNotStartedBuilding='..tostring((bClearActionsIfNotStartedBuilding or false))..'; surface height at target='..GetSurfaceHeight(tTargetLocation[1], tTargetLocation[3])..'; aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation)='..tostring(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation)))
        if sBlueprintToBuild == 'ueb0103' then LOG(sFunctionRef..': Extra check for size 14 - can we build naval fac here? aiBrain:CanBuildStructureAt='..tostring(aiBrain:CanBuildStructureAt('xsb0103', tTargetLocation))) end
    end


    local bCanBuildStructure = false
    if aiBrain.CanBuildStructureAt and (aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation) == true or (EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryHydro, sBlueprintToBuild) and ((EntityCategoryContains(M28UnitInfo.refCategoryMex, sBlueprintToBuild) and M28Conditions.CanBuildOnMexLocation(tTargetLocation)) or EntityCategoryContains(M28UnitInfo.refCategoryHydro, sBlueprintToBuild) and M28Conditions.CanBuildOnHydroLocation(tTargetLocation)))) then
        bCanBuildStructure = true
        if tsExtraBlueprintsToCheck[sBlueprintToBuild] then
            for iEntry, sAltBlueprint in tsExtraBlueprintsToCheck[sBlueprintToBuild] do
                if not(aiBrain:CanBuildStructureAt(sAltBlueprint, tTargetLocation)) then
                    bCanBuildStructure = false
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Passed hte basic aiBrain check of whether se can build a structure at the target location, bCheckForQueuedBuildings='..tostring(bCheckForQueuedBuildings or false)..'; bCanBuildStructure after checking alt blueprints='..tostring(bCanBuildStructure)) end
        if bCanBuildStructure then

            local iSkirtSizeRadius = __blueprints[sBlueprintToBuild].Physics.SkirtSizeX * 0.5
            if bCheckForQueuedBuildings == true then
                if bDebugMessages == true then LOG(sFunctionRef..': Checking for queued buildings, iOptionalPlateauGroupOrZero='..(iOptionalPlateauGroupOrZero or 'nil')..'; iOptionalLandOrWaterZone='..(iOptionalLandOrWaterZone or 'nil')) end
                if iOptionalPlateauGroupOrZero and iOptionalLandOrWaterZone then
                    --local iBuildingSize = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
                    local iBuildingRadius = math.floor(M28UnitInfo.GetBuildingSize(sBlueprintToBuild) * 0.5)
                    local tLZOrWZData, tLZOrWZTeamData
                    if iOptionalPlateauGroupOrZero > 0 then
                        tLZOrWZData  = M28Map.tAllPlateaus[iOptionalPlateauGroupOrZero][M28Map.subrefPlateauLandZones][iOptionalLandOrWaterZone]
                        tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
                    else
                        --Water zone
                        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iOptionalLandOrWaterZone]][M28Map.subrefPondWaterZones][iOptionalLandOrWaterZone]
                        tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][aiBrain.M28Team]
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of queued buildings empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefQueuedBuildings]))..'; iBuildingRadius='..iBuildingRadius..'; tTargetLocation='..repru(tTargetLocation)..'; reprs of table='..reprs(tLZOrWZData[M28Map.subrefQueuedLocationsByPosition])) end
                    if tLZOrWZData and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefQueuedBuildings]) == false then
                        local iBaseX = math.floor(tTargetLocation[1])
                        local iBaseZ = math.floor(tTargetLocation[3])
                        local iBuildingRadiusAdjust = math.ceil(iBuildingRadius)
                        for iX = iBaseX - iBuildingRadiusAdjust, iBaseX + iBuildingRadiusAdjust, 1 do
                            if tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX] then
                                if bDebugMessages == true then LOG(sFunctionRef..': Table of queued locations for iX '..iX..'='..reprs(tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX])..'; iBaseZ='..iBaseZ..'; iBuildingRadiusAdjust='..iBuildingRadiusAdjust) end
                                for iZ = iBaseZ - iBuildingRadiusAdjust, iBaseZ + iBuildingRadiusAdjust do
                                    if tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX][iZ] then
                                        bCanBuildStructure = false
                                        break
                                    end
                                end
                                if not(bCanBuildStructure) then break end
                            end
                        end
                    end
                else
                    M28Utilities.ErrorHandler('If we want to check for queued buildings then we need to specify the plateau and land zone')
                end
            end
            if bCanBuildStructure then
                --Check in case scathis is blocking us
                if M28Utilities.IsTableEmpty(tAllScathis) == false then
                    for iUnit, oUnit in tAllScathis do
                        if M28Utilities.GetDistanceBetweenPositions(tTargetLocation, oUnit:GetPosition()) < (iSkirtSizeRadius + oUnit:GetBlueprint().Physics.SkirtSizeX * 0.5) then
                            bCanBuildStructure = false
                            if bDebugMessages == true then LOG(sFunctionRef..': Are too close to a scathis so wont build here') end
                            break
                        end
                    end
                end

                if bCanBuildStructure and bCheckForOverlappingBuildings then

                    --Thanks to jip for flagging there's an engine bug where in rare situations units can be built slightly overlapping even if aiBrain:CanBuildStructureAt returns true - comments in the code Jip linked to suggested this is only where a building has upgraded
                    -- compute build locations and issue the capping

                    -- find all units that may prevent us from building
                    local tNearbyStructures = GetUnitsInRect(tTargetLocation[1] - (iSkirtSizeRadius + 4), tTargetLocation[3] - (iSkirtSizeRadius + 4), tTargetLocation[1] + (iSkirtSizeRadius + 4), tTargetLocation[3] + (iSkirtSizeRadius + 4))
                    if M28Utilities.IsTableEmpty(tNearbyStructures) == false then
                        tNearbyStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryUpgraded, tNearbyStructures)
                        local iClosestDistance
                        if M28Utilities.IsTableEmpty(tNearbyStructures) == false then
                            for iStructure, oStructure in tNearbyStructures do
                                if not(oStructure.Dead) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': oStructure='..oStructure.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStructure)..'; position='..repru(oStructure:GetPosition())..'; target location='..repru(tTargetLocation)..'; target building ID='..sBlueprintToBuild..'; 50% of target building skirt size='..iSkirtSizeRadius..'; 50% of oStructure skrit size='..oStructure:GetBlueprint().Physics.SkirtSizeX * 0.5) end
                                    iClosestDistance = math.max(math.abs(oStructure:GetPosition()[1] - tTargetLocation[1]), math.abs(oStructure:GetPosition()[3] - tTargetLocation[3]))
                                    if iClosestDistance < (iSkirtSizeRadius + oStructure:GetBlueprint().Physics.SkirtSizeX * 0.5) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Cant build as iClosestDistance='..iClosestDistance..'which is less than the two skirt sizes') end
                                        bCanBuildStructure = false
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
                if not(bCanBuildStructure) and bDebugMessages == true then LOG(sFunctionRef..': Skirt size is overlaping with a building that could have upgraded so will return false') end
            end
            if bCanBuildStructure and (bCheckBlacklistIfNoGameEnder or M28Team.tTeamData[aiBrain.M28Team][M28Team.refbStartedOnUnitWantingSpecialShielding]) then
                local iPlateau = iOptionalPlateauGroupOrZero
                local iLandZone = iOptionalLandOrWaterZone
                if not(iOptionalLandOrWaterZone) or not(iOptionalPlateauGroupOrZero) then
                    iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                end
                local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                if bDebugMessages == true then LOG(sFunctionRef..': Checking against blacklist for the floor of target location and in the building radius, is blacklist nil for floor='..tostring(tLZData[M28Map.subrefBuildLocationBlacklistByPosition][math.floor(tTargetLocation[1])][math.floor(tTargetLocation[3])] == nil)..'; FloorX='..math.floor(tTargetLocation[1])..'; FloorZ='..math.floor(tTargetLocation[3])) end
                local iFloorX = math.floor(tTargetLocation[1])
                local iFloorZ = math.floor(tTargetLocation[3])
                for iBlacklistX = iFloorX - iSkirtSizeRadius, iFloorX + iSkirtSizeRadius do
                    if tLZData[M28Map.subrefBuildLocationBlacklistByPosition][iBlacklistX] then
                        for iBlacklistZ = iFloorZ - iSkirtSizeRadius, iFloorZ + iSkirtSizeRadius do
                            if tLZData[M28Map.subrefBuildLocationBlacklistByPosition][iBlacklistX][iBlacklistZ] then
                                bCanBuildStructure = false
                                break
                            end
                        end
                        if not(bCanBuildStructure) then break end
                    end
                end
                --Approach for v18 and earlier
                --[[if tLZData[M28Map.subrefBuildLocationBlacklistByPosition][math.floor(tTargetLocation[1])][math.floor(tTargetLocation[3])] then
                    bCanBuildStructure = false
                end--]]
                --Even older blacklist approach (commented out) - from a while before v18, not sure when
                --[[if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefBuildLocationBlacklistByPosition]) == false then
                    for iEntry, tBlacklistData in tLZData[M28Map.subrefBuildLocationBlacklist] do
                        local iDistThreshold = tLZData[M28Map.subrefBuildLocationBlacklist][table.getn(tLZData[M28Map.subrefBuildLocationBlacklist])][M28Map.subrefBlacklistSize] + iSkirtSizeRadius
                        if math.abs(tTargetLocation[1] - tBlacklistData[M28Map.subrefBlacklistLocation][1]) <= iDistThreshold and math.abs(tTargetLocation[3] - tBlacklistData[M28Map.subrefBlacklistLocation][3]) <= iDistThreshold then
                            return false
                        end

                    end
                end--]]
            end
        elseif bDebugMessages == true then LOG(sFunctionRef..': If try same size building with different skirt offsets then cant build here')
        end
    elseif bDebugMessages == true then LOG(sFunctionRef..': Cant build structure at the location')
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bCanBuildStructure='..tostring(bCanBuildStructure)) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bCanBuildStructure
end

function CheckIfBuildableLocationsNearPositionStillValid(aiBrain, tLocation, bCheckLastBlacklistEntry, iBuildingRadius)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckIfBuildableLocationsNearPositionStillValid'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Check if the locations near tLocation are still valid - e.g. usually called if we have just built a unit (so unlikely to be valid) or have identified a blacklist location



    if not(aiBrain.M28IsDefeated) then
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tLocation)
        local tLZOrWZData --, sBlueprintSizeRef
        if (iLandOrWaterZone or 0) == 0 then
            iLandOrWaterZone = M28Map.GetWaterZoneFromPosition(tLocation)
            if iLandOrWaterZone > 0 then
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                --sBlueprintSizeRef = tsWZBlueprintsBySize
                iPlateauOrZero = 0
            end
        else
            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
            --sBlueprintSizeRef = tsBlueprintsBySize
        end
        if (iLandOrWaterZone or 0) > 0 then
            local iBaseSegmentX, iBaseSegmentZ = M28Map.GetPathingSegmentFromPosition(tLocation)
            local iAffectedDistanceRadius = iBuildingRadius + iMaxBuildingSize * 0.5
            if bDebugMessages == true then
                LOG(sFunctionRef..': Want to see if existing build locations are still valid, iAffectedDistanceRadius='..iAffectedDistanceRadius..'; iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Buildable locations before update for size 8=='..(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][8] or 'nil')..'; bCheckLastBlacklistEntry='..tostring(bCheckLastBlacklistEntry or false))
            end
            CheckIfSegmentsStillBuildable(aiBrain, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, iBaseSegmentX, iBaseSegmentZ, iAffectedDistanceRadius, bCheckLastBlacklistEntry)

            --Search for more building locations for every building where we havent considered the full amount if we havent considered any this cycle
            --[[local iTotalSegmentCount, sBlueprintSizeRef
            if iPlateauOrZero == 0 then
                iTotalSegmentCount = table.getn(tLZOrWZData[M28Map.subrefWZSegments])
                sBlueprintSizeRef = tsWZBlueprintsBySize
            else
                iTotalSegmentCount = tLZOrWZData[M28Map.subrefLZTotalSegmentCount]
                sBlueprintSizeRef = tsBlueprintsBySize
            end--]]
            if (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iBuildingRadius * 2] or 0) <= 10 then
                if (tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] or 0) <= 30 then
                    local iSegmentsToConsider = 4
                    if (tLZOrWZData[M28Map.subrefiCumulativeSegmentsConsideredForBuilding] or 0) < (tLZOrWZData[M28Map.subrefLZTotalSegmentCount] or 0) then iSegmentsToConsider = 15 end
                    SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iSegmentsToConsider)
                end
            end

            --Update mass storage locations
            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': About to update mass storage locations for iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..', tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable]='..repru(tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable])..'; Nickname of first aiBrain='..M28Overseer.tAllActiveM28Brains[1].Nickname) end
                local aiBrain = M28Overseer.tAllActiveM28Brains[1]
                local function WantToKeep(tArray, iEntry, aiBrain)
                    return aiBrain:CanBuildStructureAt('ueb1106', tArray[iEntry])
                end

                local iRevisedIndex = 1
                local iTableSize = table.getn(tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable])

                for iOrigIndex=1, iTableSize do
                    if tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable][iOrigIndex] then --Needed as sometimes the last entry is nil
                        if aiBrain.CanBuildStructureAt and aiBrain:CanBuildStructureAt('ueb1106', tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable][iOrigIndex]) then
                            --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                            if (iOrigIndex ~= iRevisedIndex) then
                                tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable][iRevisedIndex] = tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable][iOrigIndex];
                                tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable][iOrigIndex] = nil;
                            end
                            iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                        else
                            tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable][iOrigIndex] = nil;
                        end
                    end
                end
                if iRevisedIndex < iTableSize then
                    --table.setn(tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable], iRevisedIndex - 1)
                    for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
                        table.remove(tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable], iRemovalEntry)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function FindBuildableLocationsForSegment(aiBrain, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, iSegmentX, iSegmentZ)
    --Use if e.g. a building has died nearby and this may now have a greater build range
    --First get a blueprint of the same size (or just use htis if this is a different size)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'FindBuildableLocationsForSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local sBlueprintTable
    if iPlateauOrZero == 0 then sBlueprintTable = tsWZBlueprintsBySize
    else sBlueprintTable = tsBlueprintsBySize
    end
    if bDebugMessages == true then LOG(sFunctionRef..': iSegmentX='..(iSegmentX or 'nil')..'; iSegmentZ='..(iSegmentZ or 'nil')) end
    local tCurPosition = M28Map.GetPositionFromPathingSegments(iSegmentX, iSegmentZ)
    local iHighestCurSize = (tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] or 0)
    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, Time='..GetGameTimeSeconds()..'; Brain='..aiBrain.Nickname..'; iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; iSegmentX='..iSegmentX..'; iSegmentZ='..iSegmentZ..'; iHighestCurSize='..iHighestCurSize) end
    if iHighestCurSize < iMaxBuildingSize then
        for iSize, sGenericBlueprint in sBlueprintTable do

            if iSize > iHighestCurSize then
                --CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, iOptionalPlateauGroupOrZero, iOptionalLandOrWaterZone, iEngiActionToIgnore, bClearActionsIfNotStartedBuilding, bCheckForQueuedBuildings, bCheckForOverlappingBuildings, bCheckBlacklistIfNoGameEnder)
                if CanBuildAtLocation(aiBrain, sGenericBlueprint, tCurPosition,     iPlateauOrZero,             iLandOrWaterZone,           nil,                false,                              false,                  false,                          true) then
                    if not(tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX]) then
                        if not(tLZOrWZData[M28Map.subrefBuildableSizeBySegment]) then tLZOrWZData[M28Map.subrefBuildableSizeBySegment] = {} end
                        tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX] = {}
                    end
                    tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] = iSize
                    if not(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize][iSegmentX][iSegmentZ]) then
                        if not(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize][iSegmentX]) then
                            if not(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize]) then
                                if not(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment]) then
                                    tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment] = {}
                                end
                                tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize] = {}
                            end
                            tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize][iSegmentX] = {}
                        end
                        --Record the count of how many buildable locations we have for this size
                        tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize][iSegmentX][iSegmentZ] = true
                        if not(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]) then
                            if not(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize]) then tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize] = {} end
                            tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] = 1
                            if bDebugMessages == true then LOG(sFunctionRef..': No size previously recorded for iPlateau'..iPlateauOrZero..'Zone '..iLandOrWaterZone..' and size '..iSize..'; recording 1 as we can build at segmentX'..iSegmentX..'Z'..iSegmentZ..'; tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]='..tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]) end
                        else
                            tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] = tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] + 1
                            if bDebugMessages == true then LOG(sFunctionRef..': Increasing the number of entries by 1 for iPlateau'..iPlateauOrZero..'Zone '..iLandOrWaterZone..' and size '..iSize..'; count='..tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]..'as we can build at segmentX'..iSegmentX..'Z'..iSegmentZ) end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Can build at location '..repru(tCurPosition)..' for iSize='..(iSize or 'nil')..'; LZ midpoint='..repru(tLZOrWZData[M28Map.subrefMidpoint])..'; tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]='..(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 'nil')) end
                else
                    --If we cant build this then we cant build anything larger either
                    if bDebugMessages == true then LOG(sFunctionRef..': We cant build at position '..repru(tCurPosition)..' for size '..iSize) end
                    break
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize]='..repru(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize])) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckIfSegmentsStillBuildable(aiBrain, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, iBaseSegmentX, iBaseSegmentZ, iAffectedDistanceRadius, bCheckBlacklistIfNoGameEnder)
    --Use if e.g. a building has just started construction meaning we likely cant build nearby
    --First get a blueprint of the same size (or just use htis if this is a different size)
    --bCheckBlacklistIfNoGameEnder - if true then will check to the blacklist; if false then won't check unless there is a gameender in the zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckIfSegmentsStillBuildable'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iSegmentSearchSize = math.ceil(iAffectedDistanceRadius + iMaxBuildingSize * 0.5 / M28Map.iLandZoneSegmentSize)
    local sBlueprintTable
    if iPlateauOrZero == 0 then sBlueprintTable = tsWZBlueprintsBySize
    else sBlueprintTable = tsBlueprintsBySize
    end
    local iLastValidSize
    local GetPositionFromPathingSegments = M28Map.GetPositionFromPathingSegments
    if bDebugMessages == true then LOG(sFunctionRef..': About to search from SegmentX='..math.max(1, iBaseSegmentX - iSegmentSearchSize)..' to '..math.min(iBaseSegmentX + iSegmentSearchSize, M28Map.iMaxLandSegmentX)..' and Z='..math.max(1, iBaseSegmentZ - iSegmentSearchSize)..' to '..math.min(iBaseSegmentZ + iSegmentSearchSize, M28Map.iMaxLandSegmentZ)) end
    for iSegmentX = math.max(1, iBaseSegmentX - iSegmentSearchSize), math.min(iBaseSegmentX + iSegmentSearchSize, M28Map.iMaxLandSegmentX), 1 do
        for iSegmentZ = math.max(1, iBaseSegmentZ - iSegmentSearchSize), math.min(iBaseSegmentZ + iSegmentSearchSize, M28Map.iMaxLandSegmentZ), 1 do
            if bDebugMessages == true then LOG(sFunctionRef..': iCurSegmentX='..iSegmentX..'Z'..iSegmentZ..'; Buildable size='..(tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] or 0)) end
            if (tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] or 0) > 0 then
                iLastValidSize = nil
                for iSize, sBlueprint in sBlueprintTable do
                    if iSize > (tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] or 0) then
                        break
                    else
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Checking if buildable for iSegmentX='..iSegmentX..'; iSegmentZ='..iSegmentZ..'; iSize='..iSize..'; iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; bCheckBlacklistIfNoGameEnder='..tostring(bCheckBlacklistIfNoGameEnder)..'; Can build here='..tostring(CanBuildAtLocation(aiBrain, sBlueprint, GetPositionFromPathingSegments(iSegmentX, iSegmentZ),     iPlateauOrZero,             iLandOrWaterZone,           nil,                false,                              false,                  false,                          bCheckBlacklistIfNoGameEnder)))
                            --T3 pgen size - show buildable in blue nonbuildable in red
                            if iSize == 8 then
                                local bCanBuild = CanBuildAtLocation(aiBrain, sBlueprint, GetPositionFromPathingSegments(iSegmentX, iSegmentZ),     iPlateauOrZero,             iLandOrWaterZone,           nil,                false,                              false,                  false,                          bCheckBlacklistIfNoGameEnder)
                                if bCanBuild then M28Utilities.DrawLocation(GetPositionFromPathingSegments(iSegmentX, iSegmentZ), 1)
                                else
                                    M28Utilities.DrawLocation(GetPositionFromPathingSegments(iSegmentX, iSegmentZ), 2)
                                end
                            end
                        end
                        if CanBuildAtLocation(aiBrain, sBlueprint, GetPositionFromPathingSegments(iSegmentX, iSegmentZ),     iPlateauOrZero,             iLandOrWaterZone,           nil,                false,                              false,                  false,                          bCheckBlacklistIfNoGameEnder) then
                            --No change needed, location is still valid
                            iLastValidSize = iSize
                        else
                            --Cant build anymore, remove this and any subsequent locations
                            for iRemoveSize, sBlueprint in sBlueprintTable do
                                if iRemoveSize > iLastValidSize then
                                    if tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iRemoveSize][iSegmentX][iSegmentZ] then
                                        tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iRemoveSize][iSegmentX][iSegmentZ] = nil
                                        tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iRemoveSize] = math.max(0, (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iRemoveSize] or 1) - 1)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Just removed recording segmentX'..iSegmentX..'Z'..iSegmentZ..' from being buildable in plateau '..iPlateauOrZero..' Zone '..iLandOrWaterZone..', count by size for this zone for iRemoveSIze '..iRemoveSize..' and iSize='..iSize..'='..tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iRemoveSize]) end
                                    end
                                end
                            end
                            tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] = iLastValidSize
                            if bDebugMessages == true then LOG(sFunctionRef..': Finished removing buildable entries, tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ]='..(tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] or 'nil')..'; tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][8][iSegmentX][iSegmentZ]='..tostring(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][8][iSegmentX][iSegmentZ] or false)..'; iLastValidSize='..(iLastValidSize or 'nil')) end
                            break
                        end
                    end
                end
            end
        end
    end
    if tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][2] <= 0 and tLZOrWZData[M28Map.subrefLZTotalSegmentCount] >= 50 and GetGameTimeSeconds() >= 60 then
        M28Utilities.ErrorHandler('Dont have any locations that even a 2x2 building in P'..(iPlateauOrZero or 'nil')..'Z'..(iLandOrWaterZone or 'nil')..' can build in so likely something has gone wrong, will refresh the build count')
        LOG('Count by size before update='..repru(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize]))
        local iCurCount
        for iSize, sBlueprint in sBlueprintTable do
            iCurCount = 0

            if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize]) == false then
                for iSegmentX, tSubtable in tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize] do
                    for iSegmentZ, bValid in tSubtable do
                        iCurCount = iCurCount + 1
                    end
                end
            end
            tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] = iCurCount
        end
        LOG('Count by size after update='..repru(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize]))
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iOptionalMaxSegmentsToConsider)
    --Updates the plateau with a general buildable locations (if there are any) for iLandOrWaterZone
    --Will treat locations immediately adjacent to mexes as being unbuildable, to avoid taking up mass storage positions
    --iOptionalMaxSegmentsToConsider - will stop searching if reach this number of segments
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SearchForBuildableLocationsForLandOrWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tLZOrWZData
    local iSegmentRef
    if iPlateauOrZero == 0 then
        tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        iSegmentRef = M28Map.subrefWZSegments
    else
        tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        iSegmentRef = M28Map.subrefLZSegments
    end
    if not(tLZOrWZData) then
        M28Utilities.ErrorHandler('Dont have valid zone, iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil'))
    else
        local iSegmentsToConsider
        if (tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] or 0) >= 50 and GetGameTimeSeconds() >= 60 then
            if not(iOptionalMaxSegmentsToConsider) then
                iSegmentsToConsider = 3
                if iPlateauOrZero == 0 then iSegmentsToConsider = 6
                else iSegmentsToConsider = 3
                end
            else
                if GetGameTimeSeconds() >= 150 and (GetGameTimeSeconds() >= 900 or M28Overseer.refiRoughTotalUnitsInGame >= 500) then
                    if iPlateauOrZero == 0 then
                        iSegmentsToConsider = math.min(10, math.floor(iOptionalMaxSegmentsToConsider))
                    else
                        iSegmentsToConsider = math.min(5, math.floor(iOptionalMaxSegmentsToConsider))
                    end
                else
                    if iPlateauOrZero == 0 then
                        iSegmentsToConsider = math.max(10, math.floor(iOptionalMaxSegmentsToConsider))
                    else
                        iSegmentsToConsider = math.max(5, math.floor(iOptionalMaxSegmentsToConsider))
                    end
                end
            end
        else
            if M28Overseer.refiRoughTotalUnitsInGame >= 500 then
                iSegmentsToConsider = math.max(math.floor((iOptionalMaxSegmentsToConsider or 0)), 20)
            else
                iSegmentsToConsider = math.max(math.floor((iOptionalMaxSegmentsToConsider or 0)), 50)
            end
        end

        local iTotalSegments = table.getn(tLZOrWZData[iSegmentRef])
        local iSegmentStart = math.floor((tLZOrWZData[M28Map.subrefiLastSegmentEntryConsideredForBuilding] or 0) + 1)
        if iSegmentStart > iTotalSegments then iSegmentStart = 1 end
        local tSegmentXZ
        local iSegmentEnd = math.floor(math.min(iTotalSegments, iSegmentStart + iSegmentsToConsider))

        --Cycle through every segment in the land/water zone and see if we can build the desired unit at the segment midpoint
        if bDebugMessages == true then
            LOG(sFunctionRef..': About to cycle through each segment to check for buildable locations. iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; iOptionalMaxSegmentsToConsider='..(iOptionalMaxSegmentsToConsider or 'nil')..'; iSegmentStart='..iSegmentStart..'; iTotalSegments='..iTotalSegments..'; iSegmentEnd='..iSegmentEnd)
            if iPlateauOrZero == 0 then
                LOG(sFunctionRef..': Dealing with water zone, subrefWZSegments count='..table.getn(tLZOrWZData[M28Map.subrefWZSegments])..'MinSegX='..tLZOrWZData[M28Map.subrefWZMinSegX]..' Z'..tLZOrWZData[M28Map.subrefWZMinSegZ]..'; MaxX='..tLZOrWZData[M28Map.subrefWZMaxSegX]..' Z'..tLZOrWZData[M28Map.subrefWZMaxSegZ])
            end
        end
        for iSegmentCount = iSegmentStart, iSegmentEnd do
            tSegmentXZ = tLZOrWZData[iSegmentRef][iSegmentCount]
            if bDebugMessages == true then LOG(sFunctionRef..': About to find buildable locations for segment X'..(tSegmentXZ[1] or 'nil')..' Z'..(tSegmentXZ[2] or 'nil')..'; iSegmentCount='..(iSegmentCount or 'nil')..'; iSegmentStart='..(iSegmentStart or 'nil')..'; iSegmentEnd='..(iSegmentEnd or 'nil')) end
            FindBuildableLocationsForSegment(aiBrain, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, tSegmentXZ[1], tSegmentXZ[2])
            tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] = (tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] or 0) + 1
        end
        tLZOrWZData[M28Map.subrefiLastSegmentEntryConsideredForBuilding] = iSegmentEnd
        tLZOrWZData[M28Map.subrefiCumulativeSegmentsConsideredForBuilding] = (tLZOrWZData[M28Map.subrefiCumulativeSegmentsConsideredForBuilding] or 0) + iSegmentEnd
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of c ode, LZOrWZData[subrefBuildLocationSegmentCountBySize]='..repru(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize] or {'nil'})..'; tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick]='..(tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetPotentialBuildLocationsNearLocation(aiBrain, tLZOrWZData, iPlateauOrZero, iLandOrWaterZone, iSize, iOptionalMaxCycleSize)
    --Returns a table of potentail build locations (if there are any) for iSize building in the zone in question
    --If there aren't many build locations then will try searching for more

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPotentialBuildLocationsNearLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bDontCheckForNoRush = not(M28Overseer.bNoRushActive)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Time='..GetGameTimeSeconds()..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iSize='..iSize..'; tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]='..(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 0)..'; Midpoint in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tLZOrWZData[M28Map.subrefMidpoint]))) end
    if (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 0) < 10 or (M28Map.bIsCampaignMap and (iSize >= 14 or (iSize >= 3 and GetGameTimeSeconds() <= 300))) or (iOptionalMaxCycleSize or 100) <= 20 then
        --SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iOptionalMaxSegmentsToConsider)
        SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, nil)
    end
    if (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 0) > 0 then

        local tPotentialLocations = {}
        local GetPositionFromPathingSegments = M28Map.GetPositionFromPathingSegments
        local iCycleSize = 1
        if (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 0) >= 50 then
            iCycleSize = math.ceil((tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 0) / 40)
            --Water zones are larger so can run more of a risk of not finding the right location with too large a cycle size
            if iCycleSize >= 30 then
                if iPlateauOrZero == 0 then
                    iCycleSize = math.max(30, math.ceil(iCycleSize * 0.6))
                else
                    iCycleSize = math.max(30, math.ceil(iCycleSize * 0.8))
                end
            end
        end
        if iOptionalMaxCycleSize then iCycleSize = math.min(iCycleSize, iOptionalMaxCycleSize) end
        local iCurCount = 0
        for iSegmentX, tSubtable in tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize] do
            for iSegmentZ, bInclude in tSubtable do
                iCurCount = iCurCount + 1
                if iCurCount < iCycleSize then
                    iCurCount = iCurCount + 1
                else
                    if bDontCheckForNoRush or M28Conditions.IsLocationInNoRushArea(GetPositionFromPathingSegments(iSegmentX, iSegmentZ)) then
                        table.insert(tPotentialLocations, GetPositionFromPathingSegments(iSegmentX, iSegmentZ))
                        iCurCount = 0
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': About to return tPotentialLocations with a size of '..table.getn(tPotentialLocations)..'; iCycleSize='..iCycleSize..'; Size of buidlable locations in total='..tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return tPotentialLocations
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Didnt find any build locations for size '..iSize) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SearchForBuildableLocationsNearTarget(aiBrain, tLZOrWZData, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, iBaseSegmentX, iBaseSegmentZ, iAffectedDistanceRadius)
    local iDistanceSearchSize = math.max(iAffectedDistanceRadius, 8)
    --local iSegmentSearchSize = math.ceil(iAffectedDistanceRadius + iMaxBuildingSize * 0.5 / M28Map.iLandZoneSegmentSize)
    iSegmentSearchSize = math.ceil(iDistanceSearchSize / M28Map.iLandZoneSegmentSize)
    for iSegmentX = math.max(1, iBaseSegmentX - iSegmentSearchSize), math.min(iBaseSegmentX + iSegmentSearchSize, M28Map.iMaxLandSegmentX), 1 do
        for iSegmentZ = math.max(1, iBaseSegmentZ - iSegmentSearchSize), math.min(iBaseSegmentZ + iSegmentSearchSize, M28Map.iMaxLandSegmentZ), 1 do
            FindBuildableLocationsForSegment(aiBrain, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, iSegmentX, iSegmentZ)
        end
    end
end

function SearchForBuildableLocationsNearDestroyedBuilding(oDestroyedBuilding)
    --Searhces all segments around oDestroyedBuilding in the same land zone, and if we can build in them for a particular size, then records that location as a buildable location for that size for the land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SearchForBuildableLocationsNearDestroyedBuilding'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Cant fork thread as causes error, and need to wait a few seconds for death animation to take effect
    table.insert(tRecentlyDestroyedBuildings, {[subrefDestroyedBuildingBlueprint] = oDestroyedBuilding.UnitId, [subrefDestroyedBuildingLocation] = {oDestroyedBuilding:GetPosition()[1], oDestroyedBuilding:GetPosition()[2], oDestroyedBuilding:GetPosition()[3]}, [subrefDestroyedBuildingTime] = GetGameTimeSeconds()})
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetPotentialAdjacencyLocations(aiBrain, sBlueprintToBuild, tTargetLocation, iMaxAreaToSearch, iCatToBuildBy, oUnitToBuildBy, bStopWhenHaveValidLocation)
    --Returns a table of all locations that are valid buildable locations for sBlueprintToBuild where it will benefit from an adjacencybonus with iCatToBuildBy or oUnitToBuildBy
    --bStopWhenHaveValidLocation - if we are happy to get the first result then this will abort as soon as a valid location is found
    --Returns {} if no valid locations can be found
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPotentialAdjacencyLocations'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tPotentialLocations = {}
    local toPossibleBuildingsToBuildBy = {}
    local iPlateauOrZero, iLandOrWaterZone --Values are set if we have a cat to build by (but need here as refer to again later on)
    local iWaterZone, iPond, sAlliedUnitRef
    local tLZOrWZTeamData
    local tLZOrWZData


    if bDebugMessages == true then LOG(sFunctionRef..': sBLueprintToBuild='..(sBlueprintToBuild or 'nil')..'; tTargetLocation='..repru(tTargetLocation)..'; iMaxAreaToSearch='..iMaxAreaToSearch..'; Is iCatToBuildBy empty='..tostring(iCatToBuildBy == nil)..'; is oUnitToBuildBy empty='..tostring(oUnitToBuildBy == nil)..'; bStopWhenHaveValidLocation='..tostring(bStopWhenHaveValidLocation or false)) end

    if iCatToBuildBy then
        --sBlueprintBuildBy = M28FactoryOverseer.GetBlueprintThatCanBuildOfCategory(aiBrain, iCatToBuildBy, oEngineer)--, false, false)
        iPlateauOrZero, iLandOrWaterZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
        if (iLandOrWaterZone or 0) == 0 then
            iWaterZone = M28Map.GetWaterZoneFromPosition(tTargetLocation)
            iPond = M28Map.tiPondByWaterZone[iWaterZone]
            if iWaterZone > 0 and iPond > 0 then
                iPlateauOrZero = 0
                tLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][aiBrain.M28Team]
                sAlliedUnitRef = M28Map.subreftoLZOrWZAlliedUnits
                iLandOrWaterZone = iWaterZone
            end
        else
            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
            tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
            sAlliedUnitRef = M28Map.subreftoLZOrWZAlliedUnits
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Have a cat to build by, tTargetLocation='..repru(tTargetLocation)..'; iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Is table of allied units in this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[sAlliedUnitRef]))) end

        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[sAlliedUnitRef]) == false then --Note - LZ and WZ refs use the same reference
            if bDebugMessages == true then LOG(sFunctionRef..': Size of tLZOrWZTeamData[sAlliedUnitRef]='..table.getn(tLZOrWZTeamData[sAlliedUnitRef])..'; iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone) end
            local tRelevantBuildingsInSameLandZone = EntityCategoryFilterDown(iCatToBuildBy, tLZOrWZTeamData[sAlliedUnitRef])
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of releevant buildings empty='..tostring(M28Utilities.IsTableEmpty(tRelevantBuildingsInSameLandZone))) end
            if M28Utilities.IsTableEmpty(tRelevantBuildingsInSameLandZone) == false then
                for iUnit, oUnit in tRelevantBuildingsInSameLandZone do
                    if oUnit:GetAIBrain() == aiBrain then
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering distance between unit of category wanted for adjacency and target location, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Dist='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation)..'; Position='..repru(oUnit:GetPosition())) end
                        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation) <= iMaxAreaToSearch then
                            table.insert(toPossibleBuildingsToBuildBy, oUnit)
                        end
                    end
                end
            end
        end
    elseif oUnitToBuildBy and not(oUnitToBuildBy.Dead) then
        --sBlueprintBuildBy = oUnitToBuildBy.UnitId
        toPossibleBuildingsToBuildBy = {oUnitToBuildBy}
    else M28Utilities.ErrorHandler('No adjacency category or unit specified')
    end

    local bAbort = false
    local iNewBuildingRadius = M28UnitInfo.GetBuildingSize(sBlueprintToBuild) * 0.5
    local iValidLocationCount = 0
    local iValidBuildingCount = 0
    local bHaveValidLocation = false
    local bDontCheckForNoRush = not(M28Overseer.bNoRushActive)
    local function AddAdjacencyLocationsToPotentialLocations(tAdjacencyBuildingPosition, iAdjacencyBuildingRadius, iNewBuildingRadius)
        local iCurZ, iCurX
        local iCycleSize = math.abs(iAdjacencyBuildingRadius - iNewBuildingRadius)
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tAdjacencyBuildingPosition)
        if iPlateauOrZero > 0 then
            if (iLandOrWaterZone or 0) == 0 then
                iLandOrWaterZone = M28Map.GetWaterZoneFromPosition(tAdjacencyBuildingPosition)
                if iLandOrWaterZone > 0 then
                    iPlateauOrZero = 0
                end
            end
            if iLandOrWaterZone > 0 then
                bHaveValidLocation = false
                if bDebugMessages == true then LOG(sFunctionRef..': tAdjacencyBuildingPosition='..repru(tAdjacencyBuildingPosition)..'; iAdjacencyBuildingRadius='..iAdjacencyBuildingRadius..'; iNewBuildingRadius='..iNewBuildingRadius..'; iCycleSize='..iCycleSize) end

                --First go along top and bottom:
                for iZFactor = -1, 1, 2 do
                    iCurZ = tAdjacencyBuildingPosition[3] + (iAdjacencyBuildingRadius + iNewBuildingRadius) * iZFactor
                    for iCurX = tAdjacencyBuildingPosition[1] - iCycleSize, tAdjacencyBuildingPosition[1] + iCycleSize, 1 do
                        if CanBuildAtLocation(aiBrain, sBlueprintToBuild, { iCurX, 0, iCurZ}, iPlateauOrZero, iLandOrWaterZone, nil, false, true, false, true) then
                            if bDontCheckForNoRush or M28Conditions.IsLocationInNoRushArea({iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ}) then
                                table.insert(tPotentialLocations, {iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ})
                                if bStopWhenHaveValidLocation then bAbort = true break end
                                iValidLocationCount = iValidLocationCount + 1
                                bHaveValidLocation = true
                            end
                        end
                    end
                    if bAbort then break end
                end

                --Next go along the sides:
                if not(bAbort) then
                    for iXFactor = -1, 1, 2 do
                        iCurX = tAdjacencyBuildingPosition[1] + (iAdjacencyBuildingRadius + iNewBuildingRadius) * iXFactor
                        for iCurZ = tAdjacencyBuildingPosition[3] - iCycleSize, tAdjacencyBuildingPosition[3] + iCycleSize, 1 do
                            if CanBuildAtLocation(aiBrain, sBlueprintToBuild, { iCurX, 0, iCurZ}, iPlateauOrZero, iLandOrWaterZone, nil, false, true, false, true) then
                                if bDontCheckForNoRush or M28Conditions.IsLocationInNoRushArea({iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ}) then
                                    table.insert(tPotentialLocations, {iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ})
                                    if bStopWhenHaveValidLocation then bAbort = true break end
                                    iValidLocationCount = iValidLocationCount + 1
                                    bHaveValidLocation = true
                                end
                            end
                        end
                        if bAbort then break end
                    end
                end
            end
        end
    end


    if M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Have possible buildings to build by, so will consider best location') end
        local iAdjacencyBuildingRadius
        for iBuilding, oBuilding in toPossibleBuildingsToBuildBy do
            iAdjacencyBuildingRadius = M28UnitInfo.GetBuildingSize(oBuilding.UnitId) * 0.5
            AddAdjacencyLocationsToPotentialLocations(oBuilding:GetPosition(), iAdjacencyBuildingRadius, iNewBuildingRadius)
            if bHaveValidLocation then
                iValidBuildingCount = iValidBuildingCount + 1
                if iValidBuildingCount >= 3 and iValidLocationCount >= 3 then break end
            end
            if bAbort then break end
        end
    else
        --No nearby buildings of the desired kind - if we want to build BY a mex or hydro then consider unbuilt resource locations, unless we are bulding in a water zone
        if iLandOrWaterZone > 0 then
            local tResourceLocations
            local iAdjacencyBuildingRadius
            if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryMex, iCatToBuildBy, false) then
                tResourceLocations = tLZOrWZData[M28Map.subrefMexUnbuiltLocations] --Dont want all locations incase non-M28 teammate has built there
                iAdjacencyBuildingRadius = 1
                if bDebugMessages == true then LOG(sFunctionRef..': Want to build by a mex so recording tResourceLocations based on iPlateauOrZero='..(iPlateauOrZero or 'nil')..' and iLandOrWaterZone='..(iLandOrWaterZone or 'nil')) end
            elseif M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryHydro, iCatToBuildBy, false) then
                tResourceLocations = tLZOrWZData[M28Map.subrefHydroUnbuiltLocations] --we use the same variable for land and water zones
                iAdjacencyBuildingRadius = 3
            end
            if tResourceLocations then
                for iCurResource, tCurResource in tResourceLocations do
                    AddAdjacencyLocationsToPotentialLocations(tCurResource, iAdjacencyBuildingRadius, iNewBuildingRadius)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tPotentialLocations
end

function DrawBlacklistedLocations(tLZData)
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefBuildLocationBlacklistByPosition]) == false then
        for iX, tZ in tLZData[M28Map.subrefBuildLocationBlacklistByPosition] do
            for iZ, bTrue in tZ do
                M28Utilities.DrawLocation({iX, GetSurfaceHeight(iX, iZ), iZ}, 2)
            end
        end
        --Old blacklist approach:
        --[[for iEntry, tBlacklistData in tLZData[M28Map.subrefBuildLocationBlacklist] do
        M28Utilities.DrawLocation(tBlacklistData[M28Map.subrefBlacklistLocation], 2, nil, tBlacklistData[M28Map.subrefBlacklistSize] * 2)
    end--]]
    end
end

function DrawBuildableLocations(tLZOrWZData, iSize)
    LOG('DrawBuildableLocations: Is table of build locations for iSize'..(iSize or 'nil')..'empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize]))..'; buildable location count='..(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize] or 'nil'))
    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize]) == false then
        for iSegmentX, tSubtable in tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize] do
            for iSegmentZ, bValid in tSubtable do
                M28Utilities.DrawLocation(M28Map.GetPositionFromPathingSegments(iSegmentX, iSegmentZ))
                --LOG('DrawBuildableLocations: highest build size for segX='..iSegmentX..'Z'..iSegmentZ..'='..(tLZOrWZData[M28Map.subrefBuildableSizeBySegment][iSegmentX][iSegmentZ] or 'nil'))
            end
        end
    end
end

function GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerAction, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bNotYetUsedLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData, bCalledFromGetBestLocation, sBlueprintOverride)
    --Returns blueprint and location for oEngineer to build at and returns these or nil if no suitable locations can be found
    --iCatToBuildBy: Optional, specify if want to look for adjacency locations; Note to factor in 50% of the builder's size and 50% of the likely adjacency building size
    --iOptionalEngineerAction - ideally should populate this, will both help with debug and more importantly is used to track building sizes by action so can switch off parts of engineer logic when run out of build space

    --NOTE: bNotYetUsedLookForQueuedBuildings isn't currently used (instead we just use bCheckForQueuedBuildings for mexes and always set it to true)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBlueprintAndLocationToBuild'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for action (if specified) '..(iOptionalEngineerAction or 'nil')..', Engineer UC='..GetEngineerUniqueCount(oEngineer)..'; Engineer ID and LC='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Techlevel='..M28UnitInfo.GetUnitTechLevel(oEngineer)..'; tAlternativePositionToLookFrom='..repru(tAlternativePositionToLookFrom or {'nil'})..'; bBuildCheapestStructure='..tostring((bBuildCheapestStructure or false))..'; All blueprints that meet the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild))..'; iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')..'; Time='..GetGameTimeSeconds()..'; Engineer brain='..oEngineer:GetAIBrain().Nickname) end
    local bDontCheckForNoRush = not(M28Overseer.bNoRushActive)

    --Get the blueprint to build
    --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition, oFactory, bGetSlowest, bGetFastest, bGetCheapest,             iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
    local sBlueprintToBuild = sBlueprintOverride or M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oEngineer, false,          false,      bBuildCheapestStructure, iOptionalCategoryForStructureToBuild)


    if sBlueprintToBuild == nil then
        --Factory specific - retry but removing any tech restrictions on iCategoryToBuild
        if bDebugMessages == true then LOG(sFunctionRef..': sBlueprintToBuild is nil before factory recheck, oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..', bCloseToUnitCap='..tostring(aiBrain[M28Overseer.refbCloseToUnitCap])..'; repru(EntityCategoryGetUnitList(iCategoryToBuild)='..repru(EntityCategoryGetUnitList(iCategoryToBuild))) end
        if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryFactory, iCategoryToBuild) then
            if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryLandFactory, iCategoryToBuild) then
                iCategoryToBuild = M28UnitInfo.refCategoryLandFactory
            elseif M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryAirFactory, iCategoryToBuild) then
                iCategoryToBuild = M28UnitInfo.refCategoryAirFactory
            elseif M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryNavalFactory, iCategoryToBuild) then
                iCategoryToBuild = M28UnitInfo.refCategoryNavalFactory
            end
            --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition, oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
            sBlueprintToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oEngineer, false,          false, bBuildCheapestStructure, iOptionalCategoryForStructureToBuild)
        end
        if not(sBlueprintToBuild) then
            if (iOptionalEngineerAction == refActionBuildShield or iOptionalEngineerAction == refActionBuildSecondShield) and EntityCategoryContains(categories.TECH2, oEngineer.UnitId) then
                --Presumably we tried getting a T2 engi to build a T3 shield, as a T2 shield cant be built close enough, so dont sent error message
                tLZTeamData[M28Map.refiFixedShieldT2EngiFailureCount] = (tLZTeamData[M28Map.refiFixedShieldT2EngiFailureCount] or 0) + 1
                if bDebugMessages == true then LOG(sFunctionRef..': Failed ot build shield with t2 engi, tLZTeamData[M28Map.refiFixedShieldT2EngiFailureCount] ='..(tLZTeamData[M28Map.refiFixedShieldT2EngiFailureCount]  or 'nil')) end
                if tLZTeamData[M28Map.refiFixedShieldT2EngiFailureCount] >= 10 then M28Utilities.ErrorHandler('Still trying to build t3 shields with t2 engineers', true) end
            elseif not(aiBrain[M28Overseer.refbCloseToUnitCap]) and not(M28Map.bIsCampaignMap) and not(M28Overseer.bUnitRestrictionsArePresent) then
                M28Utilities.ErrorHandler('sBlueprintToBuild is nil, could happen e.g. if try and get sparky to build sxomething it cant or try to build support factory without the HQ or if unit restrictions are present - refer to log for more details')
                if not(iCategoryToBuild) then LOG(sFunctionRef..': No category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer))
                else
                    LOG(sFunctionRef..': Had category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..'; All blueprints that satisfy the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild))..'; Engineer highest land factory tech='..oEngineer:GetAIBrain()[M28Economy.refiOurHighestLandFactoryTech]..'; bUnitRestrictionsArePresent='..tostring(M28Overseer.bUnitRestrictionsArePresent)..'; Is table of restrictions empty='..tostring(M28Utilities.IsTableEmpty(import("/lua/game.lua").GetRestrictions()))..'; iOptionalEngineerAction='..(iOptionalEngineerAction or 'nil'))
                end
            end

            --If trying to build experimental, then just build any kind of experimental (excl transports and PD)
            if M28Overseer.bUnitRestrictionsArePresent and M28Utilities.DoesCategoryContainCategory(iCategoryToBuild, M28UnitInfo.refCategoryExperimentalLevel) and aiBrain:GetEconomyStoredRatio('MASS') >= 0.35 then
                --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition,                                                                                                   oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
                sBlueprintToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryExperimentalLevel -categories.TRANSPORTATION - categories.TRANSPORTFOCUS - categories.NAVAL - M28UnitInfo.refCategoryPD, oEngineer, false,        false,          nil,        nil)
                --If we have ended up with a game ender then only proceed if we have sufficient eco
                if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder, sBlueprintToBuild) and M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] < 80 then
                    --If <= 350 mass per sec+45m in gametime, or < 70% mass stored, then dont build
                    local iGrossThreshold = 35
                    if GetGameTimeSeconds() >= 2700 then --45m+ into game
                        iGrossThreshold = math.max(15, iGrossThreshold - 1 * (GetGameTimeSeconds() - 2700) / 180) --Decrease threshold by 10 pass per sec for every 3m after 45m
                    end

                    if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] <= iGrossThreshold or M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamAverageMassPercentStored] <= 0.7 then
                        sBlueprintToBuild = nil
                    end
                end
            end
        end
    end

    if sBlueprintToBuild == nil then
        if bDebugMessages == true then LOG(sFunctionRef..': Finished trying to get blueprint to build, but unable to find one') end
    else
        if iOptionalEngineerAction then
            tiLastBuildingSizeFromActionForTeam[oEngineer:GetAIBrain().M28Team][iOptionalEngineerAction] = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
        end

        --Adjust the search range and record key info needed for the search
        local tEngineerPosition = oEngineer:GetPosition()
        local tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition)
        local tPotentialBuildLocations = {}

        --Increase max area to search if dealing with czar or similarly large unit due to its size
        if __blueprints[sBlueprintToBuild].Physics.SkirtSizeX >= 10 then
            iMaxAreaToSearch = iMaxAreaToSearch * 1.5
            if bDebugMessages == true then LOG(sFunctionRef..': Building a large unit such as a czar, increased iMaxAreaToSearch to '..iMaxAreaToSearch) end
        end
        --Reduce max area to search if dealing with a shield (should already have limited this earlier to some extent so this is more of a redundnacy now, but before we were guessing as to the shield size)
        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
            iMaxAreaToSearch = math.min(iMaxAreaToSearch, (__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) * 0.5)
            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with a shield so reduce max area to search based on half of shield size. iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')..'; shield size='..__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) end
        elseif EntityCategoryContains(M28UnitInfo.refCategoryTMD, sBlueprintToBuild) then
            local iTMDRange = 30
            local oTMDBP = __blueprints[sBlueprintToBuild]
            if M28Utilities.IsTableEmpty(__blueprints[sBlueprintToBuild]) == false then
                for iWeapon, tWeapon in __blueprints[sBlueprintToBuild].Weapon do
                    if tWeapon.MaxRadius then
                        iTMDRange = math.min(iTMDRange, tWeapon.MaxRadius)
                    end
                end
                iMaxAreaToSearch = math.min(iMaxAreaToSearch, math.max(11, iTMDRange * 0.8))
            end
        end


        if M28Utilities.IsTableEmpty(tTargetLocation) then tTargetLocation = tEngineerPosition end
        if bDebugMessages == true then LOG(sFunctionRef..': finishrd checking if tTargetLocation is valid, tTargetLocation='..repru(tTargetLocation)..'; tEngineerPosition='..repru(tEngineerPosition)..'; is engineer valid='..tostring(M28UnitInfo.IsUnitValid(oEngineer))..'; sBlueprintToBuild='..sBlueprintToBuild) end

        --Target location adjustments
        local oClosestUnitToTML
        if EntityCategoryContains(M28UnitInfo.refCategoryTMD, sBlueprintToBuild) then
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]) == false and M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftEnemyTML]) then
                local iStartingPlateau, iStartingLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                local iCurDist
                local iClosestDist = 100000
                local oClosestTML
                for iUnit, oUnit in M28Team.tTeamData[aiBrain.M28Team][M28Team.reftEnemyTML] do
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation)
                    if iCurDist < iClosestDist then
                        oClosestTML = oUnit
                        iClosestDist = iCurDist
                    end
                end
                iClosestDist = 100000
                local tClosestTMLLocation = oClosestTML:GetPosition()
                for iUnit, oUnit in tLZTeamData[M28Map.reftUnitsWantingTMD] do
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tClosestTMLLocation, oUnit:GetPosition())
                    if iCurDist < iClosestDist then
                        iClosestDist = iCurDist
                        oClosestUnitToTML = oUnit
                    end
                end
                local iDistToMoveAway = 10
                if EntityCategoryContains(categories.AEON, sBlueprintToBuild) then iDistToMoveAway = 6 end
                if bDebugMessages == true then LOG(sFunctionRef..': Updating target location for oClosestUnitToTML at position '..repru(oClosestUnitToTML:GetPosition())..'; oClosestUnitToTML='..oClosestUnitToTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestUnitToTML)..'; oClosestTML='..oClosestTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestTML)..'; TML position='..repru(oClosestTML:GetPosition())..'; Closest unit to TML position='..repru(oClosestUnitToTML:GetPosition())) end
                tTargetLocation = M28Utilities.MoveInDirection(oClosestUnitToTML:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnitToTML:GetPosition(), tClosestTMLLocation), 10, true, false, true)
                if iStartingPlateau > 0 and iStartingLZ > 0 then
                    --Check the new target location is in the same LZ, if not then change distance to 0
                    local iNewPlateau, iNewLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                    if not(iNewLZ == iStartingLZ) then
                        tTargetLocation = oClosestUnitToTML:GetPosition()
                    end
                end
            end

        end

        if bDebugMessages == true then LOG(sFunctionRef..': sBlueprintToBuild='..(sBlueprintToBuild or 'nil')..'; Location to look from='..repru(tTargetLocation)) end
        --Mex or hydro or mass storage - consider the resource/storage locations
        if EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryHydro + M28UnitInfo.refCategoryMassStorage, sBlueprintToBuild) then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
            local iWaterZone, iPond
            local iPlateauOrZero, iLandOrWaterZone
            local tLZOrWZData
            if bDebugMessages == true then LOG(sFunctionRef..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' is considerinb building mex or hydro '..sBlueprintToBuild..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
            if (iLandZone or 0) == 0 then
                iWaterZone = M28Map.GetWaterZoneFromPosition(tTargetLocation)
                iPond = M28Map.tiPondByWaterZone[iWaterZone]
                if iWaterZone > 0 and iPond > 0 then
                    iPlateauOrZero = 0
                    iLandOrWaterZone = iWaterZone
                    tLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
                end
            else
                tLZOrWZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                iPlateauOrZero = iPlateau
                iLandOrWaterZone = iLandZone
            end
            local tResourceLocations
            if M28Utilities.IsTableEmpty(tLZOrWZData) then M28Utilities.ErrorHandler('Dont have valid water or land zone but are looking to build a resource')
            else
                if EntityCategoryContains(M28UnitInfo.refCategoryMex, sBlueprintToBuild) then
                    tResourceLocations = tLZOrWZData[M28Map.subrefMexUnbuiltLocations]
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to build mex so tResourceLocations for Plateau'..(iPlateau or 'nil')..' LZ '..(iLandZone or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'='..repru(tResourceLocations)) end
                elseif EntityCategoryContains(M28UnitInfo.refCategoryHydro, sBlueprintToBuild) then
                    tResourceLocations = tLZOrWZData[M28Map.subrefHydroUnbuiltLocations]
                elseif EntityCategoryContains(M28UnitInfo.refCategoryMassStorage, sBlueprintToBuild) then
                    tResourceLocations = tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable]
                else M28Utilities.ErrorHandler('Unrecognised resource category')
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished getting resource locations, tResourceLocations='..repru(tResourceLocations)) end
            if tResourceLocations then
                --Cycle through and include any that are buildable
                local bCheckForQueuedBuildings = true
                --ACU shouldnt check for queued buildings as otherwise it treats its own queued order as meaning it cant build there!
                if EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then bCheckForQueuedBuildings = false end
                local tBackupResourceLocation
                for iCurResource, tCurResource in tResourceLocations do
                    if bDebugMessages == true then
                        --CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, iOptionalPlateauGroupOrZero, iOptionalLandOrWaterZone, iEngiActionToIgnore, bClearActionsIfNotStartedBuilding, bCheckForQueuedBuildings, bCheckForOverlappingBuildings)
                        LOG(sFunctionRef..': Checking if can build '..sBlueprintToBuild..' on resource location '..repru(tCurResource)..'; result='..tostring(CanBuildAtLocation(aiBrain, sBlueprintToBuild, tCurResource, iPlateau, iLandZone, nil, false, true, false))..'; Can we build just using the brain function check='..tostring(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tCurResource))..'; Is table of units in rect around tCurResource empty='..tostring(M28Utilities.IsTableEmpty(GetUnitsInRect(M28Utilities.GetRectAroundLocation(tCurResource, 0.49))))..'; will draw locations we can build on in blue, and those we cant in red. bCheckForQueuedBuildings='..tostring(bCheckForQueuedBuildings or false))
                        if CanBuildAtLocation(aiBrain, sBlueprintToBuild, tCurResource, iPlateauOrZero, iLandOrWaterZone, nil, false, bCheckForQueuedBuildings, false, false, false) then
                            M28Utilities.DrawLocation(tCurResource, 1)
                        else
                            M28Utilities.DrawLocation(tCurResource, 2)
                        end
                    end
                    if CanBuildAtLocation(aiBrain, sBlueprintToBuild, tCurResource, iPlateauOrZero, iLandOrWaterZone, nil, false, bCheckForQueuedBuildings, false, false) then
                        if bDontCheckForNoRush or M28Conditions.IsLocationInNoRushArea(tCurResource) then
                            table.insert(tPotentialBuildLocations, tCurResource)
                        end
                    elseif not(tBackupResourceLocation) and aiBrain:CanBuildStructureAt(sBlueprintToBuild, tCurResource) then
                        tBackupResourceLocation = {tCurResource[1], tCurResource[2], tCurResource[3]}
                    end
                end
                --Backup - sometimes (very rarely) we might have 1 engineer trying to build a mex, aibrain shows it as able to build, but hte main canbuildatlocation doesnt; this will add the first such location as somewhere to build if otherwise we wouldnt build anywhere despite having unbuilt locations
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if need backup location, tBackupResourceLocation='..repru(tBackupResourceLocation)..'; tPotentialBuildLocations='..repru(tPotentialBuildLocations)..'; Is tPotentialBuildLocations empty='..tostring(M28Utilities.IsTableEmpty(tPotentialBuildLocations))) end
                if tBackupResourceLocation and M28Utilities.IsTableEmpty(tPotentialBuildLocations) then
                    table.insert(tPotentialBuildLocations, tBackupResourceLocation)
                    if bDebugMessages == true then LOG(sFunctionRef..': Relying on backup location') end
                end
            end
        else
            --Get adjacency location if we want adjacency
            if iCatToBuildBy or oUnitToBuildBy then
                if bDebugMessages == true then LOG(sFunctionRef..': About to get potential adjacency locations, sBlueprintToBuild='..(sBlueprintToBuild or 'nil')..'; is iCatToBuildBy empty='..tostring(iCatToBuildBy == nil)) end
                tPotentialBuildLocations = GetPotentialAdjacencyLocations(aiBrain, sBlueprintToBuild, tTargetLocation, iMaxAreaToSearch, iCatToBuildBy, oUnitToBuildBy)
                if bDebugMessages == true then LOG(sFunctionRef..': Finished getting potential adjacency locations, sBlueprintToBuild='..sBlueprintToBuild..'; tPotentialBuildLocations='..repru(tPotentialBuildLocations)) end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': is tPotentialBuildLocations empty='..tostring(M28Utilities.IsTableEmpty(tPotentialBuildLocations))..'; tTargetLocation='..repru(tTargetLocation)) end
            if M28Utilities.IsTableEmpty(tPotentialBuildLocations) then
                --Shield specific - dont want to try searching further away
                if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) and iMaxAreaToSearch and tAlternativePositionToLookFrom then
                    --Try a more precise search around the target
                    local iMaxSegmentAdjust = math.floor(iMaxAreaToSearch * 0.7 / M28Map.iLandZoneSegmentSize) --70% due to diagonals
                    if bDebugMessages == true then LOG(sFunctionRef..': Trying to build shield, sBlueprintToBuild='..sBlueprintToBuild..'; iMaxSegmentAdjust='..iMaxSegmentAdjust..'; iMaxAreaToSearch='..iMaxAreaToSearch) end
                    if iMaxSegmentAdjust >= 1 then
                        local bCheckForGameEnderTemplate = false
                        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                        local tLZData
                        local iBuildingTemplateSizeCheck = M28UnitInfo.GetBuildingSize(sBlueprintToBuild) * 0.5 + 0.5 --add 0.5 due to offset issues
                        if bDebugMessages == true then LOG(sFunctionRef..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' is considerinb building mex or hydro '..sBlueprintToBuild..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
                        if (iLandZone or 0) > 0 and (iPlateau or 0) > 0 then
                            tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                            tLZTeamData = tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
                            if M28Conditions.HaveActiveGameEnderTemplateLogic(tLZTeamData) then bCheckForGameEnderTemplate = true end
                        end


                        local iBaseSegmentX, iBaseSegmentZ = M28Map.GetPathingSegmentFromPosition(tAlternativePositionToLookFrom)

                        local iSizeWanted = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
                        tPotentialBuildLocations = {}
                        if bDebugMessages == true then LOG(sFunctionRef..': Trying to build a shield so dont want to search further afaield, will do detailed check around target instead, iSizeWanted='..iSizeWanted..'; iBaseSegmentX='..iBaseSegmentX..'; iBaseSegmentZ='..iBaseSegmentZ) end
                        for iCurSegmentX = math.max(1, iBaseSegmentX - iMaxSegmentAdjust), iBaseSegmentX + iMaxSegmentAdjust, 1 do
                            for iCurSegmentZ = math.max(1, iBaseSegmentZ - iMaxSegmentAdjust), iBaseSegmentZ + iMaxSegmentAdjust, 1 do
                                if bDebugMessages == true then LOG(sFunctionRef..': Max size for Cur SegmentX'..iCurSegmentX..'Z'..iCurSegmentZ..'='.. (tLZData[M28Map.subrefBuildableSizeBySegment][iCurSegmentX][iCurSegmentZ] or 0)) end
                                if (tLZData[M28Map.subrefBuildableSizeBySegment][iCurSegmentX][iCurSegmentZ] or 0) >= iSizeWanted then
                                    if not(bCheckForGameEnderTemplate) or not(M28Conditions.WillBlockTemplateLocation(tLZTeamData, iCurSegmentX, iCurSegmentZ, iBuildingTemplateSizeCheck)) then
                                        table.insert(tPotentialBuildLocations, M28Map.GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ))
                                        if bDebugMessages == true then LOG(sFunctionRef..': Found a segment where the highest size should be enough for a shield, will add to potential build locations') end
                                    end
                                end
                            end
                        end
                    end
                else
                    --use the predefined build locations for the land zoneM28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]M28Map.subrefBuildLocationSegmentCountBySize][iSize]
                    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                    local iPond
                    local tLZOrWZData
                    if (iLandOrWaterZone or 0) == 0 then
                        iLandOrWaterZone = M28Map.GetWaterZoneFromPosition(tTargetLocation)
                        if iLandOrWaterZone then
                            iPond = M28Map.tiPondByWaterZone[iLandOrWaterZone]
                            tLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                            iPlateauOrZero = 0
                        else
                            iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tTargetLocation)
                            if iPlateauOrZero == 0 and (iLandOrWaterZone or 0) > 0 then
                                iPond = M28Map.tiPondByWaterZone[iLandOrWaterZone]
                                tLZOrWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                            end
                        end
                    else
                        tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                    end
                    local iSize = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
                    --Game-ender specific logic - use a larger build size
                    if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder, sBlueprintToBuild) then
                        --Artillery structures (rapid fire and mavor) - use czar
                        if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalArti - categories.MOBILE, sBlueprintToBuild) then
                            iSize = math.max(iSize, iMaxBuildingSize)
                        else
                            --Yolona, scathis
                            iSize = math.max(iSize, 16)
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Are trying to build a gameender, iSize to use='..iSize) end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, sBlueprintToBuild) then
                        local tAlliedUnits = tLZOrWZData[M28Map.subrefWZTeamData][aiBrain.M28Team][M28Map.subreftoLZOrWZAlliedUnits]
                        if M28Utilities.IsTableEmpty(tAlliedUnits) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tAlliedUnits)) == false then
                            iSize = math.max(iSize, 16) --Czar can be built on cliffs where naval units cant be, hence do size 16 which is tempest
                            if bDebugMessages == true then LOG(sFunctionRef..': Are trying to build a 2nd or more naval factory so increasing size wanted for the naval factory to '..iSize) end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Dont have any naval fac in this WZ, is tAlliedUnits empty='..tostring(M28Utilities.IsTableEmpty(tAlliedUnits))..'; iSize='..iSize..'; aiBrain='..aiBrain.Nickname..'; Highest naval fac='..(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyNavalFactoryTech] or 'nil')) end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have searched all segments in the land zone before, tLocation='..repru(tTargetLocation)..'; sBlueprintToBuild='..sBlueprintToBuild..'; iSize='..iSize..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize]='..repru(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize])..'; Segments considered for build locations='..repru(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize])..'; Total segments in LZ (nil if wZ)='..(tLZOrWZData[M28Map.subrefLZTotalSegmentCount] or 'nil')..'; Is table of build locations empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefBuildLocationsBySizeAndSegment][iSize]))..'; Close to unit cap='..tostring(aiBrain[M28Overseer.refbCloseToUnitCap])..'; Is this a t1 pgen='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryT1Power, sBlueprintToBuild))..'; Time='..GetGameTimeSeconds()) end
                    local iCycleSizeLimit
                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield * categories.TECH3, sBlueprintToBuild) and (M28Map.bIsCampaignMap or not(aiBrain[M28Overseer.refbCloseToUnitCap])) then
                        iCycleSizeLimit = 4
                        --early game - do much more detailed search for t1 pgen locations so are more likely to find somewhere in engineer build area
                    elseif not(aiBrain[M28Overseer.refbCloseToUnitCap]) then
                        if EntityCategoryContains(M28UnitInfo.refCategoryT1Power, sBlueprintToBuild) and GetGameTimeSeconds() <= 900 then
                            iCycleSizeLimit = 3
                            if bDebugMessages == true then LOG(sFunctionRef..': Reducing cycle size limit as building a t1 pgen') end
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryT2Power, sBlueprintToBuild) and GetGameTimeSeconds() <= 1200 then
                            iCycleSizeLimit = 4
                            if bDebugMessages == true then LOG(sFunctionRef..': Reducing cycle size limit as building a t2 pgen') end
                        end
                    end
                    --GetPotentialBuildLocationsNearLocation(aiBrain, tLZOrWZData, iPlateauOrZero, iLandOrWaterZone, iSize, iOptionalMaxCycleSize)
                    tPotentialBuildLocations = GetPotentialBuildLocationsNearLocation(aiBrain, tLZOrWZData, iPlateauOrZero, iLandOrWaterZone, iSize, iCycleSizeLimit)
                    if M28Utilities.IsTableEmpty(tPotentialBuildLocations) and bDontCheckForNoRush then
                        if tLZOrWZData[M28Map.subrefLZbCoreBase] then
                            M28Utilities.ErrorHandler('Run out of build locations for iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iSize='..iSize, true)
                            if bDebugMessages == true and not(iPond) then
                                LOG(sFunctionRef..': Will draw affected land zone, and if we have any blacklisted locations will draw in red')
                                M28Map.DrawSpecificLandZone(iPlateauOrZero, iLandOrWaterZone)
                                DrawBlacklistedLocations(tLZOrWZData)
                            end
                            --Treat the closest land zone as core to expand locations to do building going forwards
                            if not(iPond) and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZAdjacentLandZones]) == false and tLZOrWZData[M28Map.subrefLZPathingToOtherLandZones][1] then
                                M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][tLZOrWZData[M28Map.subrefLZPathingToOtherLandZones][1][M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefbCoreBaseOverride] = true
                                if bDebugMessages == true then LOG(sFunctionRef..': have made alt LZ'..tLZOrWZData[M28Map.subrefLZPathingToOtherLandZones][1][M28Map.subrefLZNumber]..' a core base now') end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': No adjacency locations or not looking for adjacency; tPotentialBuildLocations based on land zone build locations for iSize='..iSize..'; Blueprint size='..M28UnitInfo.GetBuildingSize(sBlueprintToBuild)..'='..repru(tPotentialBuildLocations)..'; will draw each location in light blue; Is tPotentialBuildLocations empty='..tostring(M28Utilities.IsTableEmpty(tPotentialBuildLocations)))
                        if M28Utilities.IsTableEmpty(tPotentialBuildLocations) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': Total number of potential build locations='..table.getn(tPotentialBuildLocations)..'; Total locations for LZ for this size of building='..tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][M28UnitInfo.GetBuildingSize(sBlueprintToBuild)]) end
                            for iEntry, tEntry in tPotentialBuildLocations do
                                M28Utilities.DrawLocation(tEntry, 5)
                            end
                        end
                    end
                end
            end
        end

        --Pick the preferred build location
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of potential build locations empty='..tostring(M28Utilities.IsTableEmpty(tPotentialBuildLocations))..'; sBlueprintToBuild='..sBlueprintToBuild..'; iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')) end
        if M28Utilities.IsTableEmpty(tPotentialBuildLocations) == false then
            --GetBestBuildLocationForTarget(oEngineer, sBlueprintToBuild, tTargetLocation, tPotentialBuildLocations, iOptionalMaxDistanceFromTargetLocation)
            local tBestLocation = GetBestBuildLocationForTarget(oEngineer, sBlueprintToBuild, tTargetLocation, tPotentialBuildLocations, iMaxAreaToSearch, bCalledFromGetBestLocation)
            if bDebugMessages == true then LOG(sFunctionRef..': Just got best location to build at, tBestLocation='..repru(tBestLocation)) end
            if tBestLocation then
                --TMD check - if too far away to proect the unit we are interested in, then flag that dont want to try building tmd for the unit anymore
                if oClosestUnitToTML then
                    local iCurDist = M28Utilities.GetDistanceBetweenPositions(oClosestUnitToTML:GetPosition(), tBestLocation)
                    if bDebugMessages == true then LOG(sFunctionRef..': Are getting best location for TMD so will check if this best location is too far away, iCurDist='..iCurDist..'; sBlueprintToBuild='..sBlueprintToBuild) end
                    if iCurDist >= 30 or (EntityCategoryContains(categories.AEON, sBlueprintToBuild) and iCurDist >= 12.5) then
                        oClosestUnitToTML[M28Building.refbNoNearbyTMDBuildLocations] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Flagging that we dont think there are nearby TMD locations for oClosestUnitToTML='..oClosestUnitToTML.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestUnitToTML)..'; If location is really far away then will clear altogether') end
                        if iCurDist >= 40 then
                            --Dont bother trying to build as so far away may be of no use
                            tBestLocation = nil
                        end
                    end
                end
                return sBlueprintToBuild, tBestLocation
            else
                if bDebugMessages == true then LOG(sFunctionRef..': We couldnt find any suitable best location for sBlueprintToBuild='..sBlueprintToBuild..'; so will abort') end
            end
        elseif bDebugMessages == true then LOG(sFunctionRef..': No build locations found')
        end
    end
    return sBlueprintToBuild, nil
end

function ResetFailedShieldBuildDistance(oUnit, iDelayInSeconds)
    WaitSeconds(iDelayInSeconds)
    if M28UnitInfo.IsUnitValid(oUnit) then
        oUnit[refiFailedShieldBuildDistance] = nil
    end
end

function GetBestBuildLocationForTarget(oEngineer, sBlueprintToBuild, tTargetLocation, tPotentialBuildLocations, iOptionalMaxDistanceFromTargetLocation, bAlreadyTriedAlternatives)
    --Assumes we have already checked for: Adjacency; In the same land zone; Valid location to build
    --WIll then consider: If engineer can build without moving; How far away it is from the engineer; if it will block mex adjacency, and (if we specify a maximum distance) if it is within the max distance
    --bAlreadyTriedAlternatives - set to true if we have already called this function via this function
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBestBuildLocationForTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iHighestPriority = -1000
    local iCurPriority, iCurDistance
    local iBestLocationRef
    local oEngiBP = oEngineer:GetBlueprint()
    local iNewBuildingRadius = M28UnitInfo.GetBuildingSize(sBlueprintToBuild) * 0.5
    local iBuilderRange = (oEngiBP.Economy.MaxBuildDistance or 5) + math.min(oEngiBP.SizeX, oEngiBP.SizeZ) + iNewBuildingRadius - 0.5
    local rBuildAreaRect
    local iMaxRange = iOptionalMaxDistanceFromTargetLocation or 200
    local aiBrain = oEngineer:GetAIBrain()
    local bBuildTowardsHydro = false
    local tLocationToBuildTowards
    local iDistWantedTowardsLocationAwayFromArti = 40
    local tiClosestDistByPriorityAndCount --[x] is the priority before adjusting for this, returns {iDistance, iCount} where iCount is the number of times this has been updated (as need to increase priority by this to ensure we have a greater uplift than a further away distance)
    local bTryOtherLocationsIfNoneBuildableImmediately = false
    local bTryAndBuildAtlantis = false
    local bAvoidArti = false
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local iTeam = oEngineer:GetAIBrain().M28Team
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
    local tArtiPositionToBuildAwayFrom
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
        --Get average position of enemy T2 arti and build away from here
        tArtiPositionToBuildAwayFrom = M28Utilities.GetAverageOfUnitPositions(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits])
    end
    if EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, sBlueprintToBuild) then bTryAndBuildAtlantis = true end

    if GetGameTimeSeconds() <= 10 and EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryFactory, sBlueprintToBuild) then
        if not(bAlreadyTriedAlternatives) then
            bTryOtherLocationsIfNoneBuildableImmediately = true
        end
    end
    --Reduce likelihood of units switching build location targets slightly
    local tLastBuildLocationForUnit
    local tLastOrder = oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]]
    if tLastOrder[M28Orders.subrefsOrderBlueprint] and tLastOrder[M28Orders.subrefsOrderBlueprint] == sBlueprintToBuild then tLastBuildLocationForUnit = tLastOrder[M28Orders.subreftOrderPosition] end
    if bDebugMessages == true then
        local iEngineerSegmentX, iEngineerSegmentZ = M28Map.GetPathingSegmentFromPosition(oEngineer:GetPosition())
        LOG(sFunctionRef..': iTeam='..aiBrain.M28Team..'; aiBrain='..aiBrain.Nickname..'; Time='..GetGameTimeSeconds()..'; tLastOrder reprs='..reprs(tLastOrder)..'; tLastBuildLocationForUnit if we think it is the same='..repru(tLastBuildLocationForUnit)..'; sBlueprintToBuild='..sBlueprintToBuild..'; Building size of BP to build='..M28UnitInfo.GetBuildingSize(sBlueprintToBuild)..'; Engineer position='..repru(oEngineer:GetPosition())..'; Dist to target='..M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), tTargetLocation)..'; iEngineerSegmentX='..iEngineerSegmentX..'Z='..iEngineerSegmentZ)
    end

    local bLocationBuildableImmediately, bBestLocationBuildableImmediately
    local bDontCheckPlayableArea = true
    if M28Map.bIsCampaignMap then
        bDontCheckPlayableArea = false
        if M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.rebTeamOnlyHasCampaignAI] then bDontCheckPlayableArea = true end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': bDontCheckPlayableArea='..tostring(bDontCheckPlayableArea or false)..'; Is brain M28AI='..tostring(aiBrain.M28AI or false)..'; Is brain campaign AI='..tostring(aiBrain.CampaignAI)..'; Does team only have campaign AI='..tostring(M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.rebTeamOnlyHasCampaignAI] or false)) end
    --Start of game - build factory closer to hydro if possible
    if GetGameTimeSeconds() <= 60 and EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) and EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, sBlueprintToBuild) then
        --Do we have hydro in this LZ? dont want to consider if water zone
        if (iLandZone or 0) > 0 and iPlateau > 0 then
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefHydroUnbuiltLocations]) == false then
                local iClosestHydroDist = 100000
                local iCurDist
                for iEntry, tHydro in tLZData[M28Map.subrefHydroUnbuiltLocations] do
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), tHydro)
                    if iCurDist < iClosestHydroDist then
                        iClosestHydroDist = iCurDist
                        tLocationToBuildTowards = {tHydro[1], tHydro[2], tHydro[3]}
                        bBuildTowardsHydro = true
                    end
                end
            end
        end
    end

    if not(tLocationToBuildTowards) then
        --Build towards the midpoing except for certain unit categories
        if not(EntityCategoryContains(M28UnitInfo.refCategoryPD + M28UnitInfo.refCategoryTMD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild)) then
            if (iLandZone or 0) > 0 and iPlateau > 0 then
                if tArtiPositionToBuildAwayFrom then
                    tLocationToBuildTowards = M28Utilities.MoveInDirection(tArtiPositionToBuildAwayFrom, M28Utilities.GetAngleFromAToB(tArtiPositionToBuildAwayFrom, tLZData[M28Map.subrefMidpoint]), 128 + iDistWantedTowardsLocationAwayFromArti + 25, true, false, true)
                    if tLocationToBuildTowards then
                        bAvoidArti = true
                    else
                        tLocationToBuildTowards = tLZData[M28Map.subrefMidpoint]
                    end
                else
                    tLocationToBuildTowards = tLZData[M28Map.subrefMidpoint]
                end
            end
        end
    end
    if tLocationToBuildTowards then tiClosestDistByPriorityAndCount = {} end

    local bCheckForStorageAdjacency = EntityCategoryContains(M28UnitInfo.refCategoryMassStorage, sBlueprintToBuild)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; sBLueprintToBuild='..(sBlueprintToBuild or 'nil')..'; tTargetLocation='..repru(tTargetLocation)..'; tPotentialBuildLocations='..repru(tPotentialBuildLocations)..'; iOptionalMaxDistanceFromTargetLocation='..(iOptionalMaxDistanceFromTargetLocation or 'nil')..'; iMaxRange='..iMaxRange..'; iBuilderRange='..iBuilderRange..'; iNewBuildingRadius='..iNewBuildingRadius..'; bBuildTowardsHydro='..tostring(bBuildTowardsHydro)..'; tLocationToBuildTowards (e.g. for hydro)='..repru(tLocationToBuildTowards)..'; Engineer position='..repru(oEngineer:GetPosition())) end
    --local tiTopThreeLocationRefs = {}
    --local tiTopThreePriorities = {-100, -100, -100}
    --local iPriorityValueOfNoUnits = 1 --i.e. priority adjust if no units in build area
    --local iMaxRanking = table.getn(tiTopThreePriorities)
    for iCurLocation, tCurLocation in tPotentialBuildLocations do
        if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tCurLocation) then
            bLocationBuildableImmediately = true
            iCurPriority = -100
            iCurDistance = M28Utilities.GetDistanceBetweenPositions(tTargetLocation, tCurLocation)
            if bDebugMessages == true then
                LOG(sFunctionRef..': Considering location ref '..iCurLocation..'; tCurLocation='..repru(tCurLocation)..'; iCurDistance='..iCurDistance..'; iMaxRange='..iMaxRange..'; Can we build here='..tostring(oEngineer:GetAIBrain():CanBuildStructureAt(sBlueprintToBuild, tCurLocation)))
                if tLastBuildLocationForUnit then LOG(sFunctionRef..': Rough dist to last build location='..M28Utilities.GetRoughDistanceBetweenPositions(tCurLocation, tLastBuildLocationForUnit)) end
                M28Utilities.DrawLocation(tCurLocation)
            end
            if aiBrain:CanBuildStructureAt(sBlueprintToBuild, tCurLocation) then
                if iCurDistance <= iMaxRange then
                    if iCurDistance <= iBuilderRange then
                        iCurPriority = iCurPriority + 3
                        if bDebugMessages == true then LOG(sFunctionRef..': Within build range so increasing priority by 3') end
                    else
                        bLocationBuildableImmediately = false
                    end
                    rBuildAreaRect = Rect(tCurLocation[1] - iNewBuildingRadius, tCurLocation[3] - iNewBuildingRadius, tCurLocation[1] + iNewBuildingRadius, tCurLocation[3] + iNewBuildingRadius)
                    if bDebugMessages == true then LOG(sFunctionRef..': Will force debug on whether we have reclaim in rec, do we have reclaim='..tostring(M28Map.GetReclaimInRectangle(1, rBuildAreaRect, true))) end
                    if M28Map.GetReclaimInRectangle(1, rBuildAreaRect) == false then --Less of an issue now that FAF clears trees that are in the way (but still relevant for rocks and tree groups)
                        iCurPriority = iCurPriority + 2
                        if bDebugMessages == true then LOG(sFunctionRef..': No reclaim in build area so increasing priority by 2') end
                    else
                        bLocationBuildableImmediately = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Reclaim in build area so not increasing priority') end
                    end
                    if not(M28Conditions.AreMobileLandUnitsInRect(rBuildAreaRect)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': No units in rect so increasing priority by 4') end
                        iCurPriority = iCurPriority + 4
                    else
                        bLocationBuildableImmediately = false
                        if iCurDistance <= iBuilderRange then iCurPriority = iCurPriority + 2 end
                    end
                    if iCurDistance <= 50 then
                        if iCurDistance <= math.max(10, iBuilderRange - 0.5) then
                            iCurPriority = iCurPriority + 7
                            if bDebugMessages == true then LOG(sFunctionRef..': Location is within 10 so increasing priority by 7') end
                        else
                            bLocationBuildableImmediately = false
                            if iCurDistance <= 15 then
                                iCurPriority = iCurPriority + 6
                            elseif iCurDistance <= 25 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Location within 25 so increasing priority by 5') end
                                iCurPriority = iCurPriority + 5
                            else
                                iCurPriority = iCurPriority + 3
                            end
                        end
                    end
                    --General dist adjust
                    if iCurDistance >= 15 then
                        iCurPriority = iCurPriority - iCurDistance / iMaxRange * 6
                    end

                    --Adjust if can build immediately
                    if bLocationBuildableImmediately then
                        iCurPriority = iCurPriority + 1
                        if EntityCategoryContains(M28UnitInfo.refCategorySMD + M28UnitInfo.refCategoryFixedShield + M28UnitInfo.refCategoryTMD, sBlueprintToBuild) then iCurPriority = iCurPriority + 4 end
                    end

                    --Naval fac specifically - want a bit more space to build - can we build atlantis both here and 2 to the left and right?
                    if bTryAndBuildAtlantis and aiBrain:CanBuildStructureAt('ues0401', tCurLocation) then
                        iCurPriority = iCurPriority + 10
                        if bDebugMessages == true then LOG(sFunctionRef..': Can build atlantis here so increasing prioriyt, will increase more if can build to left and right') end

                        if aiBrain:CanBuildStructureAt('ues0401', {tCurLocation[1] - 3, tCurLocation[2], tCurLocation[3]}) then iCurPriority = iCurPriority + 10 end
                        if aiBrain:CanBuildStructureAt('ues0401', {tCurLocation[1] + 3, tCurLocation[2], tCurLocation[3]}) then iCurPriority = iCurPriority + 10 end
                    end

                    --Adjust if was location of our last build order
                    if tLastBuildLocationForUnit and M28Utilities.GetRoughDistanceBetweenPositions(tLastBuildLocationForUnit, tCurLocation) <= 0.75 then
                        iCurPriority = iCurPriority + 1
                        if bDebugMessages == true then LOG(sFunctionRef..': Are close to our last build order location so increasing priority by 1') end
                    end

                    --Mass s torage specific - value higher mexes (wont bother with mass fabs)
                    if bCheckForStorageAdjacency then
                        local rAdjacencyRect = M28Utilities.GetRectAroundLocation(tCurLocation, 2.749) --If changing here also update m28events and m28economy
                        local tPotentiallyAdjacentMexes = GetUnitsInRect(rAdjacencyRect)
                        local iAdjacencyValue = 0
                        local iConstructionFactor
                        if M28Utilities.IsTableEmpty(tPotentiallyAdjacentMexes) == false then
                            tPotentiallyAdjacentMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tPotentiallyAdjacentMexes)
                            if M28Utilities.IsTableEmpty(tPotentiallyAdjacentMexes) == false then
                                for iMex, oMex in tPotentiallyAdjacentMexes do
                                    if M28Utilities.GetDistanceBetweenPositions(oMex:GetPosition(), tCurLocation) <= 2.25 then
                                        if oMex:GetFractionComplete() < 1 then
                                            iConstructionFactor = oMex:GetFractionComplete() * 0.75
                                        else
                                            iConstructionFactor = 1
                                        end
                                        iAdjacencyValue = iAdjacencyValue + (oMex:GetBlueprint().Economy.ProductionPerSecondMass or 0) * iConstructionFactor
                                    end
                                end
                            end
                        end
                        iCurPriority = iCurPriority + iAdjacencyValue
                    end



                    --Build towards hydro adjust or away from enemy T2 arti
                    if tLocationToBuildTowards then
                        local iCurDistTowardsBuildTowards = M28Utilities.GetDistanceBetweenPositions(tCurLocation, tLocationToBuildTowards)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering adjustment for building towards hydro, iCurDistTowardsBuildTowards='..iCurDistTowardsBuildTowards..'; iCurPrioriyt='..iCurPriority..'; tiClosestDistByPriorityAndCount for this priority='..repru(tiClosestDistByPriorityAndCount[iCurPriority])..'; Are we equal or less than this distance='..tostring(iCurDistTowardsBuildTowards <= (tiClosestDistByPriorityAndCount[iCurPriority][1] or 100000))..'; bAvoidArti='..tostring(bAvoidArti or false)..'; iDistWantedTowardsLocationAwayFromArti='..(iDistWantedTowardsLocationAwayFromArti or 'nil')) end
                        if bAvoidArti then
                            if iCurDistTowardsBuildTowards <= iDistWantedTowardsLocationAwayFromArti then
                                iCurPriority = iCurPriority + 5
                            elseif iCurDistTowardsBuildTowards <= (iDistWantedTowardsLocationAwayFromArti + 30) and M28Utilities.GetDistanceBetweenPositions(tCurLocation, tArtiPositionToBuildAwayFrom) >= 150 then
                                iCurPriority = iCurPriority + 4
                            end
                        end
                        if iCurDistTowardsBuildTowards <= (tiClosestDistByPriorityAndCount[iCurPriority][1] or 100000) then
                            tiClosestDistByPriorityAndCount[iCurPriority] = {iCurDistTowardsBuildTowards, (tiClosestDistByPriorityAndCount[iCurPriority][2] or 0) + 1}
                            iCurPriority = iCurPriority + tiClosestDistByPriorityAndCount[iCurPriority][2] * 0.1
                            if bBuildTowardsHydro then iCurPriority = iCurPriority + 1 end
                            if bDebugMessages == true then LOG(sFunctionRef..': Increased priority due to being the closest for this base level to hydro or zone midpoint, iCurPriority after uplift='..iCurPriority) end
                        end
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Not within max range, so will just try and pick the closest location within range') end
                    --Not within range, so have priority factor in range so at least we pick the cloesst to being in range
                    iCurPriority = iCurPriority - 5 - 1 * iCurDistance / 1000
                end
            else
                iCurPriority = iCurPriority - 100
                --NOTE: Dont include adjustments after this poitn, as abovel ogic assumes we have got to the post-modifier priority for buildtowardshydro
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering tCurLocation='..repru(tCurLocation)..'; iCurDistance='..iCurDistance..'; iCurPriority='..iCurPriority) end
            --[[ Started drafting code below so we would only check for units in rec for the top 3 entries, but decided to scrap as already checking for htis above via M28Conditions check for mobile units
            --Only record if is top priority, or close enough to top priority that positions might change after factoring in units in rectangle
            if iCurPriority > tiTopThreePriorities[iMaxRanking] and iCurPriority + iPriorityValueOfNoUnits > tiTopThreePriorities[1] then
                for iCurRanking = 1, iMaxRanking, 1 do
                    if iCurPriority > tiTopThreePriorities[iCurRanking] then
                        --Reorder existing entries
                        if iCurRanking < iMaxRanking then
                            for iRanking = iMaxRanking, iCurRanking + 1, -1 do
                                tiTopThreePriorities[iRanking] = tiTopThreePriorities[iRanking - 1]
                                tiTopThreeLocationRefs[iRanking] = tiTopThreeLocationRefs[iRanking - 1]
                            end
                        end
                        tiTopThreePriorities[iCurRanking] = iCurPriority
                        tiTopThreeLocationRefs[iCurRanking] = iCurLocation
                        break
                    end
                end
            end--]]
            if iCurPriority > iHighestPriority then
                iHighestPriority = iCurPriority
                iBestLocationRef = iCurLocation
                bBestLocationBuildableImmediately = bLocationBuildableImmediately
                if bDebugMessages == true then LOG(sFunctionRef..': Have a new best priority, iHighestPriority='..iHighestPriority) end
            end
        end
    end
    --Adjust priorities for units in rect

    --[[if tiTopThreeLocationRefs[2] then
        local iCurPriority
        local bDontHaveUnitsInBuildArea
        for iEntry, iRef in tiTopThreeLocationRefs do
            iCurPriority = tiTopThreePriorities[iEntry]
            bDontHaveUnitsInBuildArea = true
            local tNearbyUnits = GetUnitsInRect(M28Utilities.GetRectAroundLocation(tTargetLocation, iNewBuildingRadius - 0.5))
            if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                bDontHaveUnitsInBuildArea = false
            end
            if bDebugMessages == true then
                LOG(sFunctionRef..': bDontHaveUnitsInBuildArea='..tostring(bDontHaveUnitsInBuildArea)..'; iEntry='..iEntry..'; Priority before='..tiTopThreePriorities[iEntry]..'; iPriorityValueOfNoUnits='..iPriorityValueOfNoUnits)
                M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tTargetLocation, iNewBuildingRadius - 0.5), 3, 50, nil)
            end
            if bDontHaveUnitsInBuildArea then
                tiTopThreePriorities[iEntry] = tiTopThreePriorities[iEntry] + iPriorityValueOfNoUnits
            end
        end
    end

    iHighestPriority = tiTopThreePriorities[1]
    iBestLocationRef = tiTopThreeLocationRefs[1]--]]

    if bDebugMessages == true then

        LOG(sFunctionRef..': Finished searching, is iBestLocationRef nil='..tostring(iBestLocationRef == nil)..'; Are we trying to build a shield='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild))..'; iHighestPriority='..(iHighestPriority or 'nil'))
        if iBestLocationRef then
            local tCurLocation = tPotentialBuildLocations[iBestLocationRef]
            local rBuildAreaRect = Rect(tCurLocation[1] - iNewBuildingRadius, tCurLocation[3] - iNewBuildingRadius, tCurLocation[1] + iNewBuildingRadius, tCurLocation[3] + iNewBuildingRadius)
            local tUnitsInBuildArea = GetUnitsInRect(rBuildAreaRect)
            LOG(sFunctionRef..': Best location='..repru(tPotentialBuildLocations[iBestLocationRef])..'; Are there mobile units in this rect='..tostring(M28Conditions.AreMobileLandUnitsInRect(rBuildAreaRect))..'; is tUnitsInBuildArea empty='..tostring(M28Utilities.IsTableEmpty(tUnitsInBuildArea))..'; Will draw build area rect')
            if tUnitsInBuildArea then
                for iUnit, oUnit in tUnitsInBuildArea do
                    LOG(sFunctionRef..': Unit in build area: iUnit='..iUnit..'; Unit ID and LC='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit is mobile land='..tostring(EntityCategoryContains(categories.MOBILE * categories.LAND, oUnit.UnitId)))
                end
            end
            M28Utilities.DrawRectangle(rBuildAreaRect, 3)
        end
    end
    if not(iBestLocationRef) and EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
        local tNearbyUnits = GetUnitsInRect(M28Utilities.GetRectAroundLocation(tTargetLocation, 2))
        if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
            for iUnit, oUnit in tNearbyUnits do
                oUnit[refiFailedShieldBuildDistance] = math.max(iOptionalMaxDistanceFromTargetLocation + 1, (oUnit[refiFailedShieldBuildDistance] or 0))
                --Reset this after 6 minutes (we might have more buildable areas open up)
                ForkThread(ResetFailedShieldBuildDistance, oUnit, 360)
                if bDebugMessages == true then LOG(sFunctionRef..': Set shield failed idstance for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to '..oUnit[refiFailedShieldBuildDistance]) end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': bBestLocationBuildableImmediately='..tostring(bBestLocationBuildableImmediately)..'; bTryOtherLocationsIfNoneBuildableImmediately='..tostring(bTryOtherLocationsIfNoneBuildableImmediately or false)) end
    if not(bBestLocationBuildableImmediately) and bTryOtherLocationsIfNoneBuildableImmediately then
        --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerAction, iCategoryToBuild, iMaxAreaToSearch,                  iCatToBuildBy, tAlternativePositionToLookFrom, bNotYetUsedLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData, bCalledFromGetBestLocation, sBlueprintOverride)
        local sRedundantBlueprint, tAltBestLocation = GetBlueprintAndLocationToBuild(aiBrain, oEngineer, nil,                        nil,           iOptionalMaxDistanceFromTargetLocation, nil,        tTargetLocation,                true,                               nil,            nil,                                nil,                    tLZData, tLZTeamData,   true,                   sBlueprintToBuild)
        if bDebugMessages == true then LOG(sFunctionRef..': tAltBestLocation='..repru(tAltBestLocation)..'; oEngineer:GetPosition='..repru(oEngineer:GetPosition())) end
        if tAltBestLocation and M28Utilities.GetDistanceBetweenPositions(tAltBestLocation, oEngineer:GetPosition()) <= iMaxRange then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return tAltBestLocation
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tPotentialBuildLocations[iBestLocationRef]='..repru(tPotentialBuildLocations[iBestLocationRef])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if iBestLocationRef then return tPotentialBuildLocations[iBestLocationRef]
    else return nil
    end
end





function GetLocationToMoveForConstruction(oUnit, tTargetLocation, sBlueprintID, iBuildDistanceMod, bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation)
    --Gets the location that oBuilder should move to in order to be within range of building on tLocation, factoring in the size of buildingType
    --sBlueprintID - if nil, then will treat the action as having a size of 0
    --iBuildDistanceMod - increase or decrease if want to move closer/further away than build distance would send you; e.g. if want to get 3 inside the build distance, set this to -3
    --Returns nil if no valid location or are in range and bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation is not true

    --Note: Will always try to be a minimum of 1 away


    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetLocationToMoveForConstruction'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local sPathing = M28UnitInfo.GetUnitPathingType(oUnit)
    local iPathingGroupWanted = NavUtils.GetLabel(sPathing, oUnit:GetPosition())

    local tPotentialMoveLocation
    if bDebugMessages == true then LOG(sFunctionRef..': Start, time='..GetGameTimeSeconds()..'; tTargetLocatino='..repru(tTargetLocation)..'; Unit position='..repru(oUnit:GetPosition())..'; sBlueprintID='..(sBlueprintID or 'nil')..'; oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')) end
    local iAngleFromTargetToBuilder = M28Utilities.GetAngleFromAToB(tTargetLocation, oUnit:GetPosition())
    local iBuildRange = oUnit:GetBlueprint().Economy.MaxBuildDistance
    local iDistanceWantedFromTarget = math.max(1, iBuildRange + (iBuildDistanceMod or 0))
    local oBlueprint
    local iBuildingRadius = 0
    if sBlueprintID then
        oBlueprint = __blueprints[sBlueprintID]
        if oBlueprint then
            iBuildingRadius = math.min(oBlueprint.Physics.SkirtSizeX, oBlueprint.Physics.SkirtSizeZ) - 0.01
        end
    end
    iDistanceWantedFromTarget = iDistanceWantedFromTarget + iBuildingRadius

    if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; tTargetLocation='..repru(tTargetLocation)..'; sBlueprintID='..(sBlueprintID or 'nil')..'; iBuildDistanceMod='..(iBuildDistanceMod or 'nil')..'bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation='..tostring(bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation or false)) end
    if not(bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation) then
        --Check if we are in range already
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if we are already in range of the target, distance='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation)..'; iDistanceWantedFromTarget='..iDistanceWantedFromTarget..'; iBuildingRadius='..iBuildingRadius) end
        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation) <= iDistanceWantedFromTarget then
            if bDebugMessages == true then LOG(sFunctionRef..': Target location is already in range') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return nil
        end
    end

    for iDistanceToMove = iDistanceWantedFromTarget, 1, -1 do
        tPotentialMoveLocation = M28Utilities.MoveInDirection(tTargetLocation,iAngleFromTargetToBuilder, iDistanceToMove, true, false, true)
        if NavUtils.GetLabel(sPathing, tPotentialMoveLocation) == iPathingGroupWanted then
            if bDebugMessages == true then LOG(sFunctionRef..': Have a valid location engi can move to='..repru(tPotentialMoveLocation)..'; Dist from target='..M28Utilities.GetDistanceBetweenPositions(tPotentialMoveLocation, tTargetLocation)..'; iDistanceToMove='..(iDistanceToMove or 'nil')..'; will check no buildings in a radius of 5 that are blocking this location') end
            local rRectangleToSearch = M28Utilities.GetRectAroundLocation(tPotentialMoveLocation, 5)
            local tBlockingUnits = GetUnitsInRect(rRectangleToSearch)
            local bDontMove = false
            if M28Utilities.IsTableEmpty(tBlockingUnits) == false then
                local tBlockingBuildings = EntityCategoryFilterDown(categories.STRUCTURE, tBlockingUnits)
                local iBlockingSize
                for iBuilding, oBuilding in tBlockingBuildings do
                    iBlockingSize = M28UnitInfo.GetBuildingSize(oBuilding.UnitId) * 0.5
                    local tBuildingPosition = oBuilding:GetPosition()
                    if math.abs(tBuildingPosition[1] - tPotentialMoveLocation[1]) <= iBlockingSize and math.abs(tBuildingPosition[3] - tPotentialMoveLocation[3]) <= iBlockingSize then
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Will be blocked by a building so wont move here')
                            M28Utilities.DrawLocation(tPotentialMoveLocation, 2)
                        end
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return nil
                    end
                end
            end


            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return tPotentialMoveLocation
        elseif bDebugMessages == true then LOG(sFunctionRef..': Cant move to the desired location, will draw in red') M28Utilities.DrawLocation(tPotentialMoveLocation, 2)
        end
        if iDistanceToMove <= 1 then
            if bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return {tTargetLocation[1], tTargetLocation[2], tTargetLocation[3]}
            end
            break
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return nil

    --Below was from M27 - left commented out as might be of use when introduce naval factory logic again
    --[[
tPossibleTarget = M28Map.GetPositionAtOrNearTargetInPathingGroup(tBuilderLocation, tLocation, iDistanceWantedFromTarget, 0, oBuilder, true, true, iMinDistanceFromCurrentBuilderMoveTarget)

--Adjust further for naval factory to facilitate greater cliff-building
if tPossibleTarget and EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, sBlueprintID) then
    --If we move from Possible target towards our currnet position do we come across a cliff very soon?

    local bHaveCliff = false

    local iAngleFromMoveTarget = M28Utilities.GetAngleFromAToB(tPossibleTarget, tBuilderLocation)

    local iMaxCliffSearchRange = 15 + math.floor(iBuildDistance)

    function IsCliffBlockingTarget(tTarget)
        local iDistToMoveTarget = M28Utilities.GetDistanceBetweenPositions(tBuilderLocation, tTarget)
        local tCliffPositionCheck
        if iDistToMoveTarget > 1 then
            for iDistAdjust = 1, math.min(iMaxCliffSearchRange, math.floor(iDistToMoveTarget)) do
                tCliffPositionCheck = M28Utilities.MoveInDirection(tPossibleTarget, iAngleFromMoveTarget, iDistAdjust, true, false)
                if not(NavUtils.GetLabel(sPathing, tCliffPositionCheck) == iEngiPathingGroup) then
                    return true
                end
            end
        end
        return false
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Building naval factory, IsCliffBlockingTarget(tPossibleTarget='..tostring(IsCliffBlockingTarget(tPossibleTarget))..'; tPossibleTarget='..repru(tPossibleTarget)..'; tLocation (of where we want to build)='..repru(tLocation)) end
    if IsCliffBlockingTarget(tPossibleTarget) then
        --Can we get any closer to our build distance if we broaden the angle range?  Also increase the distance slightly
        iDistanceWantedFromTarget = iDistanceWantedFromTarget + 0.1
        local iAngleToEngi = M28Utilities.GetAngleFromAToB(tLocation, tBuilderLocation)
        local tReplacementTarget
        local tPathingPosition
        if bDebugMessages == true then LOG(sFunctionRef..': About to try different positions from tLocation '..repru(tLocation)..' to tBuilderLocation '..repru(tBuilderLocation)..'; Angle to here='..iAngleToEngi..'; iDistanceWantedFromTarget='..iDistanceWantedFromTarget) end
        for iAngleAdjust = 0, 40, 8 do
            for iAngleFactor = -1, 1, 2 do
                --MoveInDirection(tStart, iAngle, iDistance, bKeepInMapBounds, bTravelUnderwater)
                tPathingPosition = M28Utilities.MoveInDirection(tLocation, iAngleToEngi + iAngleAdjust * iAngleFactor, iDistanceWantedFromTarget, true, false)
                if bDebugMessages == true then

                    local iColour = 3
                    if NavUtils.GetLabel(sPathing, tPathingPosition) == iEngiPathingGroup and not(IsCliffBlockingTarget(tPathingPosition)) then iColour = 7 end
                    LOG(sFunctionRef..': Considering tPathingPosition='..repru(tPathingPosition)..'; iAngleAdjust='..iAngleAdjust * iAngleFactor..'; Pathing group='..NavUtils.GetLabel(sPathing, tPathingPosition)..'; Engi pathing group='..iEngiPathingGroup..'; Is cliff blocking target='..tostring(IsCliffBlockingTarget(tPathingPosition))..'; will draw match in white, nonmatch in black. iColour='..iColour..'; Dist from original move target planned='..M28Utilities.GetDistanceBetweenPositions(tPathingPosition, tPossibleTarget))
                    M28Utilities.DrawLocation(tPathingPosition, false, iColour, 200)
                end
                if NavUtils.GetLabel(sPathing, tPathingPosition) == iEngiPathingGroup and not(IsCliffBlockingTarget(tPathingPosition)) then
                    tReplacementTarget = tPathingPosition
                end

                if iAngleAdjust == 0 or tReplacementTarget then break end
            end
            if tReplacementTarget then break end
        end
        if tReplacementTarget then
            if bDebugMessages == true then LOG(sFunctionRef..': Have a replacement position to use') end
            tPossibleTarget = {tReplacementTarget[1], tReplacementTarget[2], tReplacementTarget[3]}

        end
    end
end
--]]
end

function BuildStructureNearLocation(aiBrain, oEngineer, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bLookForPartCompleteBuildings, bLookForQueuedBuildings, oUnitToBuildBy, bNeverBuildRandom, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, iOptionalEngiActionRef)
    --NOT USED? Might be old code copied from M27 that ended up rewriting?

    --Determines the blueprint and location for oEngineer to build at; also returns the location
    --iCatToBuildBy: Optional, specify if want to look for adjacency locations; Note to factor in 50% of the builder's size and 50% of the likely adjacency building size
    --bLookForQueuedBuildings: Optional, if true, then doesnt choose a target if another engineer already has that target function ref assigned to build something
    --Returns nil if dealing with a non-resource based building

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'BuildStructureNearLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Engineer UC='..GetEngineerUniqueCount(oEngineer)..'; Engineer LC='..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Techlevel='..M28UnitInfo.GetUnitTechLevel(oEngineer)..'; tAlternativePositionToLookFrom='..repru(tAlternativePositionToLookFrom or {'nil'})..'; bBuildCheapestStructure='..tostring((bBuildCheapestStructure or false))..'; bNeverBuildRandom='..tostring((bNeverBuildRandom or false))..'; All blueprints that meet the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild))..'; iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')..'; Water zone of position to look from (if any)='..(M28Map.GetWaterZoneFromPosition(tAlternativePositionToLookFrom or oEngineer:GetPosition()) or 'nil')) end


    local bAbortConstruction = false

    --Get the blueprint to build
                                    --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition, oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
    local sBlueprintToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oEngineer, false,        false,  bBuildCheapestStructure, iOptionalCategoryForStructureToBuild)
    local tTargetLocation
    if sBlueprintToBuild == nil then
        if not(aiBrain[M28Overseer.refbCloseToUnitCap]) then
            M28Utilities.ErrorHandler('sBlueprintToBuild is nil, could happen e.g. if try and get sparky to build sxomething it cant - refer to log for more details')
            if not(iCategoryToBuild) then LOG(sFunctionRef..': No category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer))
            else
                LOG(sFunctionRef..': Had category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..'; All blueprints that satisfy the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild)))
            end
        end
    else

        --Adjust the search range and record key info needed for the search
        local tEngineerPosition = oEngineer:GetPosition()
        tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition)
        --Increase max area to search if dealing with czar or similarly large unit due to its size
        if __blueprints[sBlueprintToBuild].Physics.SkirtSizeX >= 10 then
            iMaxAreaToSearch = iMaxAreaToSearch * 1.5
            if bDebugMessages == true then LOG(sFunctionRef..': Building a large unit such as a czar, increased iMaxAreaToSearch to '..iMaxAreaToSearch) end
        end

        --Reduce max area to search if dealing with a shield
        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
            iMaxAreaToSearch = math.min(iMaxAreaToSearch, (__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) * 0.5)
            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with a shield so reduce max area to search based on half of shield size. iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')..'; shield size='..__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) end
        end


        if bDebugMessages == true then LOG(sFunctionRef..': sBlueprintToBuild='..(sBlueprintToBuild or 'nil')..'; Location to look from='..repru(tAlternativePositionToLookFrom or oEngineer:GetPosition())) end
        local sBlueprintBuildBy
        local bFindRandomLocation = false

        if not(tTargetLocation) then tTargetLocation = tEngineerPosition end
        local bFoundEnemyInstead = false

        local sPathing = M28UnitInfo.GetUnitPathingType(oEngineer)
        local iNewBuildingRadius = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)[1] * 0.5
        local iBuilderRange = oEngineer:GetBlueprint().Economy.MaxBuildDistance + math.min(oEngineer:GetBlueprint().SizeX, oEngineer:GetBlueprint().SizeZ)*0.5
        local iDistanceFromStart = M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()])
        local bBuildNearToEnemy = false
        if iDistanceFromStart <= 80 then bBuildNearToEnemy = true end

        --Check we're not trying to buidl a mex or hydro or mass storage or mass fab
        local bMexHydroOrStorage = false
        if EntityCategoryContains(refCategoryMex, sBlueprintToBuild) or EntityCategoryContains(refCategoryHydro, sBlueprintToBuild) or EntityCategoryContains(M28UnitInfo.refCategoryMassStorage + M28UnitInfo.refCategoryMassFab, sBlueprintToBuild)  then
            bMexHydroOrStorage = true
        end


        --If specified, first check if there's an existing part complete building we can help complete instead of starting a new building
        --Check if is an existing building of the type wanted first:
        local oPartCompleteBuilding
        if bLookForPartCompleteBuildings then
            --GetPartCompleteBuilding(aiBrain, oBuilder, iCategoryToBuild, iBuildingSearchRange, iEnemySearchRange)
            --Returns nil if no nearby part complete building
            --iEnemySearchRange: nil if dont care about nearby enemies, otherwise will ignore buildings that have enemies within iEnemySearchRange
            oPartCompleteBuilding = GetPartCompleteBuilding(aiBrain, oEngineer, iCategoryToBuild, iBuilderRange + 15, nil)
        end
        if oPartCompleteBuilding then
            if bDebugMessages == true then LOG(sFunctionRef..': have partcompletebuilding so returning that as the position') end
            tTargetLocation = oPartCompleteBuilding:GetPosition()
        else
            if bDebugMessages == true then
                local sEngUniqueRef = GetEngineerUniqueCount(oEngineer)
                LOG(sFunctionRef..': Eng builder unique ref='..sEngUniqueRef..'; builder range='..iBuilderRange)
            end



            if not(bMexHydroOrStorage) then
                --For non-extraction buildings, if we have specified we want to build adjacent to something then look for nearby buildings that can give us the adjacency wanted
                if iCatToBuildBy or oUnitToBuildBy then
                    local toPossibleBuildingsToBuildBy
                    local iBuildingCount = 0
                    local tPossibleTargets = {}
                    local tBuildingPosition

                    if iCatToBuildBy then
                        toPossibleBuildingsToBuildBy = aiBrain:GetUnitsAroundPoint(iCatToBuildBy, tTargetLocation, iMaxAreaToSearch, 'Ally')
                        local iCurDist
                        local iClosestDist = 100000
                        --ACU specific - cant build by hydro, but might have nearby hydro
                        if bDebugMessages == true then LOG(sFunctionRef..': Engineer position='..repru(oEngineer:GetPosition())..'; tTargetLocation='..repru(tTargetLocation)..'; iMaxAreaToSearch='..iMaxAreaToSearch..'; is toPossibleBuildingsToBuildBy empty='..tostring(M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy))) end
                        if M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy) == false then
                            --Try to build by the closest unit of the category wanted
                            local oClosestBuilding
                            for iUnit, oUnit in  toPossibleBuildingsToBuildBy do
                                if oUnit:GetAIBrain() == aiBrain then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEngineer:GetPosition())
                                    if iCurDist < iClosestDist then
                                        oClosestBuilding = oUnit
                                        iClosestDist = iCurDist
                                    end
                                end
                            end
                            if oClosestBuilding then
                                sBlueprintBuildBy = oClosestBuilding.UnitId
                                if bDebugMessages == true then LOG(sFunctionRef..': Will update sBlueprintBuildBy to be the closest building for adjacency='..oClosestBuilding.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestBuilding)) end
                            end
                        end


                    elseif oUnitToBuildBy then
                        sBlueprintBuildBy = oUnitToBuildBy.UnitId
                        toPossibleBuildingsToBuildBy = {oUnitToBuildBy}
                    else M28Utilities.ErrorHandler('Missing code')
                    end


                    if M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have possible buildings to build by, so will consider best location') end
                        for iBuilding, oBuilding in toPossibleBuildingsToBuildBy do
                            if not(oBuilding.Dead) and oBuilding.GetPosition and oBuilding:GetAIBrain() == aiBrain then
                                tBuildingPosition = oBuilding:GetPosition()
                                if M28Utilities.GetDistanceBetweenPositions(tBuildingPosition, tTargetLocation) <= iMaxAreaToSearch then
                                    iBuildingCount = iBuildingCount + 1
                                    tPossibleTargets[iBuildingCount] = tBuildingPosition
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Found iBuildingCount='..iBuildingCount..' to build by') end
                        if iBuildingCount == 0 then bFindRandomLocation = not(bNeverBuildRandom) end
                    else
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Cant find any buildings for adjacency, getting random location to build unless we want to build by a mex/hydro and have an unbuilt one nearby')
                            local tNearestBuildingOfCategory = aiBrain:GetUnitsAroundPoint(iCatToBuildBy, tTargetLocation, 10000, 'Ally')
                            if M28Utilities.IsTableEmpty(tNearestBuildingOfCategory) then LOG(sFunctionRef..': Dont have any units of the desired category anywhere on map')
                            else
                                local oNearestBuildingOfCategory = M28Utilities.GetNearestUnit(tNearestBuildingOfCategory, oEngineer:GetPosition(), aiBrain)
                                LOG(sFunctionRef..': Nearest unit of desired category is '..oNearestBuildingOfCategory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestBuildingOfCategory)..' which is '..M28Utilities.GetDistanceBetweenPositions(oNearestBuildingOfCategory:GetPosition(), oEngineer:GetPosition())..' away from the engineer')
                            end
                        end
                        bFindRandomLocation = not(bNeverBuildRandom)
                    end

                    --Also check for unbuilt buildings if dealing with a mex or hydro, unless are building a shield
                    local tResourceLocations
                    if not(EntityCategoryContains(categories.SHIELD, sBlueprintToBuild)) then
                        --land factory - say that we're looking for a mex even if cant find one
                        if bDebugMessages == true then LOG(sFunctionRef..': About to check if building early fac and cant find mex/hydro. Does cat to build by contain mex or hydro='..tostring(M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryHydro + M28UnitInfo.refCategoryMex, iCatToBuildBy, false))..'; sBlueprintBuildBy='..(sBlueprintBuildBy or 'nil')..'; Does engi contain tech1 or ACU='..tostring(EntityCategoryContains(categories.TECH1 + categories.COMMAND, oEngineer.UnitId))..'; Does blueprint to build contain factory='..tostring(EntityCategoryContains(categories.FACTORY, sBlueprintToBuild))) end
                        if iCatToBuildBy and not(sBlueprintBuildBy) and EntityCategoryContains(categories.TECH1 + categories.COMMAND, oEngineer.UnitId) and EntityCategoryContains(categories.FACTORY, sBlueprintToBuild) then
                            if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryMex, iCatToBuildBy, false) then
                                sBlueprintBuildBy = 'ueb1103'
                            elseif M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryHydro, iCatToBuildBy, false) then
                                sBlueprintBuildBy = 'ueb1102'
                            end
                        end
                        if sBlueprintBuildBy then
                            if EntityCategoryContains(M28UnitInfo.refCategoryMex, sBlueprintBuildBy) then
                                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                                local iPond, iWaterZone
                                if (iLandZone or 0) == 0 then
                                    iWaterZone = M28Map.GetWaterZoneFromPosition(tTargetLocation)
                                    iPond = M28Map.tiPondByWaterZone[iWaterZone]
                                    tResourceLocations = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefLZMexLocations]
                                else
                                    tResourceLocations = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Will add any mexes within 20 of target location to be considered, tResourceLocations='..repru(tResourceLocations)) end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryHydro, sBlueprintBuildBy) or EntityCategoryContains(M28UnitInfo.refCategoryT2Power, sBlueprintBuildBy) then --Dont want to make this all power, because the adjacency code requires a building size, and only works for a single building size; i.e. if try and get adjacency for t1 power and include hydro locations, then it will think it needs to build within the hydro for adjacency
                                local iPlateau, iZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                                if not(iZone) then M28Utilities.ErrorHandler('Trying to build a hydro but dont have a valid zone') end
                                tResourceLocations = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iZone][M28Map.subrefHydroLocations]
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tResourceLocations) == false then
                        for iResource, tCurResourceLocation in tResourceLocations do
                            iBuildingCount = iBuildingCount + 1
                            tPossibleTargets[iBuildingCount] = tCurResourceLocation
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and build by resource location (mex or hydro); iBuildingCount including these locations='..iBuildingCount..'; table of building locations='..repru(tPossibleTargets)) end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of resource locations empty='..tostring(M28Utilities.IsTableEmpty(tResourceLocations))..'; iBuildingCount='..iBuildingCount) end
                    if iBuildingCount > 0 then
                        --GetBestBuildLocationForTarget(tablePosTarget, sTargetBuildingBPID, sNewBuildingBPID, bCheckValid, aiBrain, bReturnOnlyBestMatch, pBuilderPos, iMaxAreaToSearch, iBuilderRange, bIgnoreOutsideBuildArea, bBetterIfNoReclaim, bPreferCloseToEnemy, bPreferFarFromEnemy, bLookForQueuedBuildings)
                        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build the shield anywhere near the target. iOptionalEngiActionRef='..(iOptionalEngiActionRef or 'nil')) end
                            local bBuildAwayFromEnemy = false
                            if iOptionalEngiActionRef == refActionFortifyFirebase then bBuildAwayFromEnemy = true end
                            tTargetLocation = GetBuildLocationForShield(aiBrain, sBlueprintToBuild, tAlternativePositionToLookFrom, bBuildAwayFromEnemy)
                            if not(tTargetLocation) then bAbortConstruction = true end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': About to call GetBestBuildLocation; iBuildingCount='..iBuildingCount..'; sBlueprintBuildBy='..(sBlueprintBuildBy or 'nil')) end
                            --Go through all possible adjacent build locations identified, and choose the best one
                            tTargetLocation = GetBestBuildLocationForTarget(tPossibleTargets, sBlueprintBuildBy, sBlueprintToBuild, true, aiBrain, true, tTargetLocation, iMaxAreaToSearch, iBuilderRange, false, true, bBuildNearToEnemy, not(bBuildNearToEnemy), bLookForQueuedBuildings)
                            --Double-check the resulting location is valid
                            if M28Utilities.IsTableEmpty(tTargetLocation) == true then
                                if bDebugMessages == true then LOG('Adjacency location is empty, will try finding anywhere to build') end
                                bFindRandomLocation = not(bNeverBuildRandom)
                            else
                                bFindRandomLocation = false
                                if bDebugMessages == true then LOG(sFunctionRef..': Have determined the best build location for target to be '..repru(tTargetLocation)..'; will double-check we can build here, can build here='..tostring(CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, nil, nil, nil, false, bLookForQueuedBuildings, false, true))) end
                                if not(CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, nil, nil, nil, false, bLookForQueuedBuildings, false, true)) then
                                    --if aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation) == false or not(M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)])) then
                                    M28Utilities.ErrorHandler('Cant build '..sBlueprintToBuild..' on adjacency location tTargetLocation='..repru({tTargetLocation[1], tTargetLocation[2],tTargetLocation[3]}))
                                    bFindRandomLocation = not(bNeverBuildRandom)
                                else
                                    --Check we're within mapBoundary
                                    if bDebugMessages == true then LOG(sFunctionRef..': Cant build at the location; Checking if tTargetLocation '..repru(tTargetLocation)..' is in the playable area '..repru(M28Map.rMapPlayableArea)..' based on building size radius='..iNewBuildingRadius) end
                                    if (tTargetLocation[1] - iNewBuildingRadius) < M28Map.rMapPlayableArea[1] or (tTargetLocation[3] - iNewBuildingRadius) < M28Map.rMapPlayableArea[2] or (tTargetLocation[1] + iNewBuildingRadius) > M28Map.rMapPlayableArea[3] or (tTargetLocation[3] + iNewBuildingRadius) > M28Map.rMapPlayableArea[4] then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Target location isnt in playable area so will find random place to build instead') end
                                        bFindRandomLocation = not(bNeverBuildRandom)
                                        tTargetLocation = tEngineerPosition
                                    end
                                    if bDebugMessages == true then M28Utilities.DrawLocation(tTargetLocation) end
                                end
                            end
                        end
                    else
                        bFindRandomLocation = not(bNeverBuildRandom)
                        if bDebugMessages == true then LOG(sFunctionRef..': Cant find any valid buildings for adjacency') end
                    end
                else
                    --If no was adjacency wanted, then either build at the target location, or find a random location to build (subject to some unit specific points)
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have a category to build by, will look for random location unless current target is valid or we are a shield') end
                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
                        local bBuildAwayFromEnemy = false
                        if iOptionalEngiActionRef == refActionFortifyFirebase then bBuildAwayFromEnemy = true end
                        tTargetLocation = GetBuildLocationForShield(aiBrain, sBlueprintToBuild, tAlternativePositionToLookFrom, bBuildAwayFromEnemy)
                        if tTargetLocation then bFindRandomLocation = false else bFindRandomLocation = not(bNeverBuildRandom) end
                    else
                        bFindRandomLocation = not(bNeverBuildRandom)
                    end
                end
            else
                --Dealing with mex or hydro or storage
                if bDebugMessages == true then LOG(sFunctionRef..': Are trying to build a mex, hydro or storage; tTargetLocation='..repru((tTargetLocation or {}))..'; oEngineer='..GetEngineerUniqueCount(oEngineer)..'; LC='..M28UnitInfo.GetUnitLifetimeCount(oEngineer)) end
                if M28Utilities.IsTableEmpty(tTargetLocation) == true then
                    M28Utilities.ErrorHandler('Trying to build mex, hydro or storage without defined location')
                else
                    if aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation) then --and M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)]) then
                        --Not interested in if other units have queued up, as e.g. might be ACU that can build and is much closer, so just want whichever unit is closest to try and build
                        if bDebugMessages == true then LOG(sFunctionRef..': Can build structure at targetlocation='..repru(tTargetLocation)..'; if are buildling a t1 mex and there is a t3 mex queued up then will ignore though') end
                        --Are we trying to build a T1 mex? If so then only consider if have an order to build T3 mex
                        if EntityCategoryContains(refCategoryT1Mex, sBlueprintToBuild) then
                            local sLocationRef = M28Utilities.ConvertLocationToReference(tTargetLocation)
                            if aiBrain[reftEngineerAssignmentsByLocation][sLocationRef] and M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][sLocationRef][refActionBuildT3MexOverT2]) == false then
                                bAbortConstruction = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Trying to build t1 mex when want to build t3 here') end
                            end
                        end
                    else
                        --Cant build at location, is that because of enemy building blocking it, or we have a part-built building?
                        if bDebugMessages == true then LOG(sFunctionRef..': Are trying to build a mex or hydro or mass storage so cant get a random location, but we cant build a structure at the target') end
                        local tEnemyBuildingAtTarget = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, tTargetLocation, 1, 'Enemy')
                        if M28Utilities.IsTableEmpty(tEnemyBuildingAtTarget) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have enemy buildings around target') end
                            M28PlatoonUtilities.MoveNearConstruction(aiBrain, oEngineer, tTargetLocation, sBlueprintToBuild, 0, false, false, false)
                            for iUnit, oUnit in tEnemyBuildingAtTarget do
                                if oUnit.GetPosition then
                                    IssueReclaim({oEngineer}, oUnit)
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy building is at the target mex/hydro so will try and reclaim that first') end

                            IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                            if bDebugMessages == true then LOG(sFunctionRef..': 1 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation)) end
                            bAbortConstruction = true
                            bFoundEnemyInstead = true

                        else
                            local tAllyBuildingAtTarget = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, tTargetLocation, 1, 'Ally')
                            if M28Utilities.IsTableEmpty(tAllyBuildingAtTarget) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will target the ally building as its part complete') end
                                oPartCompleteBuilding = tAllyBuildingAtTarget[1]
                            else
                                --Are we stopped from building due to reclaim?

                                local tNewBuildingSize = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
                                local fSizeMod = 0.5

                                local rTargetRect = M28Utilities.GetRectAroundLocation(tTargetLocation, tNewBuildingSize[1] * fSizeMod)
                                if bDebugMessages == true then LOG(sFunctionRef..': tTargetLocation='..repru(tTargetLocation)..'; tNewBuildingSize='..repru(tNewBuildingSize)..'; rTargetRect='..repru(rTargetRect)) end
                                --GetReclaimInRectangle(iReturnType, rRectangleToSearch)
                                --iReturnType: 1 = true/false; 2 = number of wrecks; 3 = total mass, 4 = valid wrecks
                                local tReclaimables = M28Map.GetReclaimInRectangle(4, rTargetRect)

                                if M28Utilities.IsTableEmpty(tReclaimables) == false then
                                    for iReclaim, oReclaim in tReclaimables do
                                        --oEngineer:IssueReclaim(oReclaim)
                                        IssueReclaim({oEngineer}, oReclaim)
                                    end
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef..': Reclaim found that is blocking mex or hydro so will reclaim all wrecks in rectangle='..repru(rTargetRect))
                                        M28Utilities.DrawRectangle(rTargetRect, 7, 100)
                                    end

                                    IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                                    if bDebugMessages == true then LOG(sFunctionRef..': 2 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation)) end

                                else
                                    --Are we trying to build a T3 mex? If so then we probably are trying to replace a T2 mex which  can lead to problems with the canbuild check
                                    if iCategoryToBuild == M28UnitInfo.refCategoryT3Mex then
                                        IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef..': Not sure we can build here but will try anyway')
                                            LOG(sFunctionRef..': 3 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation))
                                        end
                                    else
                                        --One likely explanation is that enemy has built on the mex and we cant see the building, in which case we only want to check this for debugging purposes, and proceed with the default action of having hte engineer try to move there
                                        local tUnits = GetUnitsInRect(rTargetRect)
                                        if M28Utilities.IsTableEmpty(tUnits) == true then
                                            M28Utilities.ErrorHandler(sFunctionRef..': Cant build at resource location but no units or reclaim on it, will just try moving near the target instead. sBlueprintToBuild='..sBlueprintToBuild..'; Engineer UC='..GetEngineerUniqueCount(oEngineer)..'; LC='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Location='..repru({tTargetLocation[1], tTargetLocation[2],tTargetLocation[3]})..'; Will draw white circle around the target if in debug mode. CanBuildStructure result='..tostring(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation))..'; Is the table of assigned engineer actions empty='..tostring(M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)])), true)
                                            if bDebugMessages == true then
                                                M28Utilities.DrawLocation(tTargetLocation, nil, 7)
                                                LOG(sFunctionRef..': Cnat build at TargetLocation='..repru(tTargetLocation)..'; RectangleSearched='..repru(rTargetRect))
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will just move to the target location') end
                                        M28PlatoonUtilities.MoveNearConstruction(aiBrain, oEngineer, tTargetLocation, sBlueprintToBuild, 0, false, false, false)
                                        bAbortConstruction = true
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        --Switch to random location if an amphibious unit cant path there and its not a resource based location
        if not(bFindRandomLocation) and not(bAbortConstruction) then -- and not(bMexHydroOrStorage) then
            if not(NavUtils.GetLabel(sPathing, tTargetLocation) == NavUtils.GetLabel(sPathing, oEngineer:GetPosition())) then
                bFindRandomLocation = not(bNeverBuildRandom)
            end
        end

        if bFindRandomLocation and (bMexHydroOrStorage or EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild)) and not(bAbortConstruction) and not(iOptionalEngiActionRef == refActionFortifyFirebase) then
            --Backup - Trying to build a mex or hydro so no point getting random location
            if not(EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild)) then
                M28Utilities.ErrorHandler('Are trying to build in a random place for am ex/hydro/mass storage - figure out why as this shouldnt trigger; Engineer with UC='..GetEngineerUniqueCount(oEngineer)..'='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; trying to build blueprint='..sBlueprintToBuild)
                if bDebugMessages == true then LOG(sFunctionRef..': Trying to build mex or hydro so cant choose a random location') end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Trying to build a shield but couldnt find anywhere to build it so no point building it in the end. iOptionalEngiActionRef='..(iOptionalEngiActionRef or 'nil')) end
            end
            bFindRandomLocation = false
            bAbortConstruction = true
        end

        --Look for a random location if we failed to find a suitable location in the above steps
        if bFindRandomLocation == true and not(bAbortConstruction) then
            if bDebugMessages == true then LOG(sFunctionRef..': Are finding a random location to build unless current location is valid; sBlueprintToBuild='..sBlueprintToBuild..'; iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')) end
            if M28Utilities.IsTableEmpty(tTargetLocation) == true then tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition) end

            --First check in build area for the best location assuming the target location isnt far away
            if M28Utilities.GetDistanceBetweenPositions(tTargetLocation, tEngineerPosition) <= 30 then tTargetLocation = GetBestBuildLocationForTarget(tTargetLocation, nil, sBlueprintToBuild, true, aiBrain, true, tTargetLocation, iMaxAreaToSearch, iBuilderRange, false, true, bBuildNearToEnemy, not(bBuildNearToEnemy), false) end
            if M28Utilities.IsTableEmpty(tTargetLocation) == true or not(CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, nil, nil, nil, false, bLookForQueuedBuildings, true)) then
                --if M28Utilities.IsTableEmpty(tTargetLocation) == true or not(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation)) or not(M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)])) then
                if M28Utilities.IsTableEmpty(tTargetLocation) then tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition) end
                if bDebugMessages == true then
                    LOG(sFunctionRef..' Cant build '..sBlueprintToBuild..'; will try and find a random place to build; target location for random place to build='..repru(tTargetLocation))
                    if iCategoryToBuild == nil then LOG(sFunctionRef..' iCategoryToBuild is nil somehow') end
                end
                --FindRandomPlaceToBuild(aiBrain, oBuilder, tStartPosition, sBlueprintToBuild, iSearchSizeMin, iSearchSizeMax, bForcedDebug)
                local bSuitableForLastSuccessfulLocation = EntityCategoryContains(M28UnitInfo.refCategoryStructure + categories.EXPERIMENTAL - M28UnitInfo.refCategorySatellite - M28UnitInfo.refCategoryFirebaseSuitable, sBlueprintToBuild) and M28Utilities.IsTableEmpty(aiBrain[reftLastSuccessfulLargeBuildingLocation]) == false
                local iSearchCycles = nil
                if bSuitableForLastSuccessfulLocation then iSearchCycles = 3 end
                tTargetLocation = FindRandomPlaceToBuild(aiBrain, oEngineer, (tTargetLocation or tAlternativePositionToLookFrom or tEngineerPosition), sBlueprintToBuild, 2, iMaxAreaToSearch, bDebugMessages, iSearchCycles)
                if M28Utilities.IsTableEmpty(tTargetLocation) == true then
                    --Try searching the last location we built at successfully for a couple of cycles if arent building a firebase unit
                    if bSuitableForLastSuccessfulLocation then
                        tTargetLocation = FindRandomPlaceToBuild(aiBrain, oEngineer, aiBrain[reftLastSuccessfulLargeBuildingLocation], sBlueprintToBuild, 2, iMaxAreaToSearch, false, math.min(3, (iSearchCycles or 3)))
                    end
                    if M28Utilities.IsTableEmpty(tTargetLocation) then
                        LOG(sFunctionRef..': WARNING - couldnt find a random place to build based on position='..repru(tTargetLocation)..'; will abort construction')
                        bAbortConstruction = true
                    end
                elseif bDebugMessages == true then LOG(sFunctionRef..': Found random place to build='..repru(tTargetLocation))
                end
            else if bDebugMessages == true then LOG(sFunctionRef..': No need for random place as current targetlocation is valid, ='..repru(tTargetLocation)) end
            end
        end
        --Only proceed with sending a build order (or repair order for a part complete building) if we had success in the earlier steps
        if bAbortConstruction == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Not aborting function so will try to move near construction if we have a valid location') end
            if M28Utilities.IsTableEmpty(tTargetLocation) == false and sBlueprintToBuild then
                --Adjust Target location if building PD
                if EntityCategoryContains(M28UnitInfo.refCategoryPD, sBlueprintToBuild) then
                    tTargetLocation = AdjustPDBuildLocation(aiBrain, tTargetLocation, sBlueprintToBuild)
                end
                --MoveNearConstruction(aiBrain, oBuilder, tLocation, sBlueprintID, iBuildDistanceMod, bReturnMovePathInstead, bUpdatePlatoonMovePath, bReturnNilIfAlreadyMovingNearConstruction, bReturnMoveLocationifGivenOne)
                local tMoveNearTargetLocation = M28PlatoonUtilities.MoveNearConstruction(aiBrain, oEngineer, tTargetLocation, sBlueprintToBuild, 0, false, false, false, true)
                if oPartCompleteBuilding then
                    if bDebugMessages == true then LOG(sFunctionRef..': Send order for oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to repair '..oPartCompleteBuilding.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPartCompleteBuilding)..' at '..repru(oPartCompleteBuilding:GetPosition())) end

                    IssueRepair({ oEngineer}, oPartCompleteBuilding)
                else
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Send order for oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to build '..sBlueprintToBuild..' at '..repru(tTargetLocation)..'; will draw target location in gold')
                        M28Utilities.DrawLocation(tTargetLocation, nil, 4, 500)
                    end

                    --MAIN ISSUEBUILDMOBILE FOR CONSTRUCTION (i.e. other issuebuilds here are for specific actions)
                    IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                    if bDebugMessages == true then LOG(sFunctionRef..': 4 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation)..' with surface height='..GetSurfaceHeight(tTargetLocation[1], tTargetLocation[3])..'; tMoveNearTargetLocation='..repru(tMoveNearTargetLocation)) end
                end
                if M28Utilities.IsTableEmpty(tMoveNearTargetLocation) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to start thread checking for when the engineer is in build range') end
                    ForkThread(TrackWhenEngineerInBuildRange, oEngineer, tMoveNearTargetLocation, (sBlueprintToBuild or oPartCompleteBuilding.UnitId), tTargetLocation, oPartCompleteBuilding)
                    if sBlueprintToBuild and not(oPartCompleteBuilding) then
                        ForkThread(CheckIfEngineerLikelyStuck, oEngineer, sBlueprintToBuild, tTargetLocation)
                    end

                end
            end
        else
            if bDebugMessages == true then LOG('Warning - couldnt find any places to build after looking randomly nearby, will abort construction. bFoundEnemyInstead='..tostring(bFoundEnemyInstead)) end
            if bDebugMessages == true then
                LOG(sFunctionRef..': Aborted construction, will draw target location in red')
                M28Utilities.DrawLocation(tTargetLocation, nil, 2, 100)
            end
            if not(bMexHydroOrStorage) then tTargetLocation = nil end
        end
    end
    if bDebugMessages == true then
        if sBlueprintToBuild == nil then LOG('sBlueprintToBuild is nil')
        else
            if tTargetLocation then
                LOG(sFunctionRef..': tTargetLocation='..repru(tTargetLocation)..'; aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation)='..tostring(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation))..'; sBlueprintToBuild='..(sBlueprintToBuild or 'nil'))
                if not(bAbortConstruction) then M28Utilities.DrawLocation(tTargetLocation, nil, 7, 100) end --show in white (colour 7)
                LOG(sFunctionRef..': About to list any units in 1x1 rectangle around targetlocation')
                local iSizeAdj = 3
                local rBuildAreaRect = Rect(tTargetLocation[1] - iSizeAdj, tTargetLocation[3] - iSizeAdj, tTargetLocation[1] + iSizeAdj, tTargetLocation[3] + iSizeAdj)
                local tUnitsInRect = GetUnitsInRect(rBuildAreaRect)
                local tsUnitRefs = {}
                if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                    for iUnit, oUnit in tUnitsInRect do
                        table.insert(tsUnitRefs, iUnit, oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
                    end
                end
                LOG('tsUnitRefs='..repru(tsUnitRefs))
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tTargetLocation
end

function GetPartCompleteBuilding(aiBrain, oBuilder, iCategoryToBuild, iBuildingSearchRange)
    --Returns nil if no nearby part complete building
    --iEnemySearchRange: nil if dont care about nearby enemies, otherwise will ignore buildings that have enemies within iEnemySearchRange
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPartCompleteBuilding'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tBuilderPosition = oBuilder:GetPosition()
    local tAllBuildings = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, tBuilderPosition, iBuildingSearchRange, 'Ally')
    local iCurDistanceToBuilder
    local iMinDistanceToBuilder = 10000
    local tBuildingPosition
    local oNearestPartCompleteBuilding
    if M28Utilities.IsTableEmpty(tAllBuildings) == false then
        for iBuilding, oBuilding in tAllBuildings do
            --Dont try and compelte part built shields as may be part built due to special shielding logic
            if oBuilding.GetFractionComplete and oBuilding.GetPosition and oBuilding:GetFractionComplete() < 1 and not(EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oBuilding.UnitId)) then
                local tNearbyEnemies
                tBuildingPosition = oBuilding:GetPosition()
                iCurDistanceToBuilder = M28Utilities.GetDistanceBetweenPositions(tBuildingPosition, tBuilderPosition)
                if iCurDistanceToBuilder < iMinDistanceToBuilder then
                    iMinDistanceToBuilder = iCurDistanceToBuilder
                    oNearestPartCompleteBuilding = oBuilding
                end
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oNearestPartCompleteBuilding
end

function SlowlyRefreshBuildableLandZoneLocations(oOrigBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SlowlyRefreshBuildableLandZoneLocations'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    bBuildLocationLoopActive = true
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iSearchesConsideredThisTick
    local iTicksWaitedThisCycle
    local iSegmentsBeforeWaiting
    if GetGameTimeSeconds() >= 600 or M28Overseer.refiRoughTotalUnitsInGame >= 500 then iSegmentsBeforeWaiting = 16 --Must be a multiple of 2, i.e. 2^x results in this
    else iSegmentsBeforeWaiting = 32
    end
    local aiBrain = oOrigBrain

    --First update every start position that has an M28 brain to make sure we have a decent number of options recorded for a land factory and smaller
    for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
        if bDebugMessages == true then LOG(sFunctionRef..': About to start recording buildable locations for the starting land zone for oBrain='..oBrain.Nickname..'; Index='..oBrain:GetArmyIndex()..'; Start pos='..repru(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])) end
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
        if (iLandZone or 0) > 0 then
                --SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iOptionalMaxSegmentsToConsider)
            SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateau, iLandZone, iSegmentsBeforeWaiting * 10)

            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    end

    while true do
        --Get a new brain if needed
        if aiBrain.M28IsDefeated then
            aiBrain = nil
            for iBrain, oBrain in ArmyBrains do
                if oBrain.M28AI and not(oBrain.M28IsDefeated) then
                    aiBrain = oBrain
                    break
                end
            end
            if not(aiBrain) then
                break
            end
        end

        iTicksWaitedThisCycle = 0
        iSearchesConsideredThisTick = 0

        --Cycle through every plateau
        for iPlateau, tPlateauSubtable in M28Map.tAllPlateaus do
            for iLandZone, tLandZoneInfo in tPlateauSubtable[M28Map.subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Updating for iPlateau='..iPlateau..'; iLandZone='..iLandZone) end
                if tLandZoneInfo[M28Map.subrefBuildLocationsBySizeAndSegment] then
                    if tLandZoneInfo[M28Map.subrefLZTotalSegmentCount] >= 80 or tLandZoneInfo[M28Map.subrefLZMexCount] > 0 then
                        --SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iOptionalMaxSegmentsToConsider)
                        SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateau, iLandZone, iSegmentsBeforeWaiting)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        iTicksWaitedThisCycle = iTicksWaitedThisCycle + 1
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    end
                end
                iTicksWaitedThisCycle = iTicksWaitedThisCycle + 1
            end
        end
        if iTicksWaitedThisCycle < 1000 then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1000 - iTicksWaitedThisCycle)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            iSegmentsBeforeWaiting = math.max(2, iSegmentsBeforeWaiting * 0.5)
        elseif iTicksWaitedThisCycle >= 3000 then
            iSegmentsBeforeWaiting = math.min(64, iSegmentsBeforeWaiting * 2)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordBuildableCoreWaterZoneLocationsNearStartOfGame()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordBuildableCoreWaterZoneLocationsNearStartOfGame'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    bWZBuildLocationLoopActive = true
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iSearchesConsideredThisTick
    local iTicksWaitedThisCycle
    local iSegmentsBeforeWaiting = 16 --Must be a multiple of 2, i.e. 2^x results in this

    local tWZShortlistByWZ = {} --Index is WZ

    local iCurWZ
    local aiBrain
    --Get the naval build locations for each M28 brain to create a shortlist that will be cycled through
    for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
        aiBrain = oBrain
        if M28Utilities.IsTableEmpty(M28Map.tPondDetails) == false then
            for iPond, tPondSubtable in M28Map.tPondDetails do
                if M28Utilities.IsTableEmpty(tPondSubtable[M28Map.subrefBuildLocationByStartPosition]) == false then
                    for iEntry, tPosition in tPondSubtable[M28Map.subrefBuildLocationByStartPosition] do
                        iCurWZ = M28Map.GetWaterZoneFromPosition(tPosition)
                        if (iCurWZ or 0) > 0 then
                            tWZShortlistByWZ[iCurWZ] = true
                        end
                    end
                end
            end
        end
    end
    local tWZShortlist = {}
    if M28Utilities.IsTableEmpty(tWZShortlistByWZ) == false then
        for iWZ, bInclude in tWZShortlistByWZ do
            table.insert(tWZShortlist, iWZ)
        end
    end

    if M28Utilities.IsTableEmpty(tWZShortlist) == false then
        --First ensure we have basic sizes for the WZ and some entries
        for iEntry, iWaterZone in tWZShortlist do
            SearchForBuildableLocationsForLandOrWaterZone(aiBrain, 0, iWaterZone, iSegmentsBeforeWaiting)
        end

        local iTotalCycles = 0

        while iTotalCycles <= 100 do
            iTotalCycles = iTotalCycles + 1
            --Get a new brain if needed
            if aiBrain.M28IsDefeated then
                aiBrain = nil
                for iBrain, oBrain in ArmyBrains do
                    if oBrain.M28AI and not(oBrain.M28IsDefeated) then
                        aiBrain = oBrain
                        break
                    end
                end
                if not(aiBrain) then
                    break
                end
            end

            iTicksWaitedThisCycle = 0
            iSearchesConsideredThisTick = 0

            --Cycle through every entry
            for iEntry, iWaterZone in tWZShortlist do
                        --SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iOptionalMaxSegmentsToConsider)
                SearchForBuildableLocationsForLandOrWaterZone(aiBrain, 0, iWaterZone, iSegmentsBeforeWaiting)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                iTicksWaitedThisCycle = iTicksWaitedThisCycle + 1
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DecideOnExperimentalToBuild(iActionToAssign, aiBrain, tbEngineersOfFactionOrNilIfAlreadyAssigned, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iLandOrWaterZone)
    --Only intended to be used for determiming land experimentals

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DecideOnExperimentalToBuild'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iFactionRequired
    local iCategoryWanted
    local bDontWantExperimental = false
    local iGameEnderTemplateCategory
    if not(tbEngineersOfFactionOrNilIfAlreadyAssigned) then
        if bDebugMessages == true then LOG(sFunctionRef..': Already have unit under construction so will return experimentallevel') end
        iCategoryWanted = M28UnitInfo.refCategoryExperimentalLevel - categories.NAVAL --Already have the unit under construction
        if M28Conditions.HaveActiveGameEnderTemplateLogic(tLZOrWZTeamData) and not(aiBrain.M28Easy) then
            iCategoryWanted = refActionManageGameEnderTemplate
        end
    elseif iActionToAssign == refActionManageGameEnderTemplate then
        iCategoryWanted = refActionManageGameEnderTemplate
    else
        --Do we have an experimental level unit under construciton in this LZ?
        local tExperimentalsInLZ
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            tExperimentalsInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryExperimentalLevel, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tExperimentalsInLZ) == false then
                for iUnit, oUnit in tExperimentalsInLZ do
                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() < 1 and oUnit:GetFractionComplete() > 0.001 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Setting category to experimental level as have part complete experimental') end
                        iCategoryWanted = M28UnitInfo.refCategoryExperimentalLevel - categories.NAVAL
                        break
                    end
                end
            end
        end
        if not(iCategoryWanted) then
            if bDebugMessages == true then LOG(sFunctionRef..': Deciding on what experimental to construct, iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; Time='..GetGameTimeSeconds()..'; Team mass income='..(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] or 'nil')..'; Brain='..aiBrain.Nickname..'; Is campaignAI='..tostring(aiBrain.CampaignAI or false)..'; Is M28AI='..tostring(aiBrain.M28AI or false)..'; Land subteam='..(aiBrain.M28LandSubteam or 'nil')..'; Is table of land subteam empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subreftoFriendlyM28Brains]))..'; Team gross mass='..M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass]..'; refbBuiltParagon='..tostring(aiBrain[M28Economy.refbBuiltParagon] or false)) end
            --Land subteam - use aiBrain.M28LandSubteam
            local iSubteamSize =  table.getn(M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subreftoFriendlyM28Brains])
            local iEnemyLandExperimentalCount = table.getn(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftEnemyLandExperimentals])
            local bEnemyHasFatboys = false
            if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFatboy, M28Team.tTeamData[aiBrain.M28Team][M28Team.reftEnemyLandExperimentals])) == false then
                bEnemyHasFatboys = true
            end
            local iTeam = aiBrain.M28Team
            local iDistToNearestEnemyBase = M28Utilities.GetDistanceBetweenPositions(tLZOrWZTeamData[M28Map.reftClosestEnemyBase], tLZOrWZData[M28Map.subrefMidpoint])
            local bCanPathByLand
            local bCanPathAmphibiously
            if NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZOrWZData[M28Map.subrefMidpoint]) == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) then
                bCanPathByLand = true
            else bCanPathByLand = false
            end
            if NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, tLZOrWZData[M28Map.subrefMidpoint]) == NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) then
                bCanPathAmphibiously = true
            else bCanPathAmphibiously = false
            end

            --Non-faction specific logic:

            --Initial land experimental (very high priority subject to map)
            local iTeamLandExperimentals = 0
            for iBrain, oBrain in M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subreftoFriendlyM28Brains] do
                iTeamLandExperimentals = iTeamLandExperimentals + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandExperimental)
            end

            if iTeamLandExperimentals >= 1 or M28Team.tTeamData[iTeam][M28Team.subrefiOurBomberThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] >= 7000 or M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandExperimental) >= 2 then
                --Factor in experimentals under construction (as no longer a high priority to build land experimentals)
                local bHaveExperimentalForThisLandZone, iOtherLandZonesWithExperimental, iMassToComplete = GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateauOrZero, iLandOrWaterZone, false, nil, M28UnitInfo.refCategoryLandExperimental)
                iTeamLandExperimentals = iTeamLandExperimentals + iOtherLandZonesWithExperimental
            end


            --Do we think we can handle enemy threat with air?
            local bEnemyHasDangerousLandExpWeCantHandle = false
            local iEnemyLandExperimentals = 0
            local iEnemyClosestLandExperimentalOnSamePlateau = 10000
            local iEnemyExpOnSamePlateau = 0
            local bHaveAirControl = M28Conditions.TeamHasAirControl(iTeam)
            local iCurModDist
            if M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) then
                for iExp, oExp in M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
                    if NavUtils.GetLabel(M28Map.refPathingTypeHover, oExp:GetPosition()) == iPlateauOrZero then
                        iEnemyExpOnSamePlateau = iEnemyExpOnSamePlateau + math.max(0.3, oExp:GetFractionComplete())
                        iCurModDist = M28Utilities.GetDistanceBetweenPositions(oExp:GetPosition(), tLZOrWZData[M28Map.subrefMidpoint])
                        if oExp:GetFractionComplete() <= 0.6 then
                            iCurModDist = iCurModDist + (200 - 250 * oExp:GetFractionComplete())
                        end
                        iEnemyClosestLandExperimentalOnSamePlateau = math.min(iEnemyClosestLandExperimentalOnSamePlateau, iCurModDist)
                    end
                end
            end

            if iEnemyClosestLandExperimentalOnSamePlateau <= math.min(700, math.max(450, M28Map.iMapSize * 0.5)) then
                bEnemyHasDangerousLandExpWeCantHandle = true

                local iCombinedAirToGroundThreat = M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiOurBomberThreat]
                if iEnemyClosestLandExperimentalOnSamePlateau >= 225 or iCombinedAirToGroundThreat >= 60000 then
                    if iCombinedAirToGroundThreat >= 12500 and (iCombinedAirToGroundThreat >= 30000 or bHaveAirControl) then
                        if iEnemyExpOnSamePlateau == 1 or iCombinedAirToGroundThreat >= 40000 or iCombinedAirToGroundThreat >= 7500 + 5000 * iEnemyExpOnSamePlateau then
                            bEnemyHasDangerousLandExpWeCantHandle = false
                        end
                    end
                    if bEnemyHasDangerousLandExpWeCantHandle then
                        if iTeamLandExperimentals > iEnemyClosestLandExperimentalOnSamePlateau then
                            bEnemyHasDangerousLandExpWeCantHandle = false
                        elseif M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] and iTeamLandExperimentals >= math.min(3, iEnemyClosestLandExperimentalOnSamePlateau) then
                            bEnemyHasDangerousLandExpWeCantHandle = false
                        elseif iTeamLandExperimentals >= 4 then --will come a point where want to assume we can handle enemy
                            bEnemyHasDangerousLandExpWeCantHandle = false
                        end
                    end
                end
            end

            local iTeamNukes = 0
            if bDebugMessages == true then LOG(sFunctionRef..': iTeamLandExperimentals='..iTeamLandExperimentals..'; bCanPathByLand='..tostring(bCanPathByLand)..'; bCanPathAmphibiously='..tostring(bCanPathAmphibiously)..'; bEnemyHasDangerousLandExpWeCantHandle='..tostring(bEnemyHasDangerousLandExpWeCantHandle)..'; iEnemyClosestLandExperimentalOnSamePlateau='..iEnemyClosestLandExperimentalOnSamePlateau) end
            if iTeamLandExperimentals == 0 and bCanPathByLand and (bEnemyHasDangerousLandExpWeCantHandle or M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandExperimental) < math.min(4, math.max(2, M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] * 0.5))) then
                iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                if bDebugMessages == true then LOG(sFunctionRef..': We have no land experimentals but can reach the enemy base by land so will consider building one, Is Cybran engineers of faction available='..tostring(tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionCybran] or false)..'; Lifetime land experimental count='..M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandExperimental)) end
                if tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionCybran] then
                    if M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandExperimental) < 2 then
                        iCategoryWanted = M28UnitInfo.refCategoryMonkeylord
                        iFactionRequired = M28UnitInfo.refFactionCybran
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to build a monkeylord') end
                    else
                        iCategoryWanted = M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategoryMonkeylord
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to build a megalith or other land experimental that isnt a monkeylord')
                        end
                    end
                end
            else
                --Consider getting nukes
                if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] then --dont want nuke built too far from base
                    --Do we already have nukes?
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of nukes in this zone empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategorySML, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))) end
                    if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategorySML, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) then
                        --Do teammates have no more than 1 nuke?
                        for iBrain, oBrain in M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subreftoFriendlyM28Brains] do
                            iTeamNukes = iTeamNukes + oBrain:GetCurrentUnits(M28UnitInfo.refCategorySML)
                            --Treat us as having more nukes if we have an experimental nuke
                            if iTeamNukes > 0 and oBrain:GetFactionIndex() == M28UnitInfo.refFactionSeraphim then iTeamNukes = iTeamNukes + oBrain:GetCurrentUnits(M28UnitInfo.refCategorySML * categories.EXPERIMENTAL) * 2 end
                        end
                        local bHaveExperimentalForThisLandZone, iOtherLandZonesWithExperimental, iMassToComplete = GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateauOrZero, iLandOrWaterZone, false, nil, M28UnitInfo.refCategorySML)
                        if bDebugMessages == true then LOG(sFunctionRef..': iTeamNukes based on getcurrentunits='..iTeamNukes..'; iOtherLandZonesWithExperimental='..iOtherLandZonesWithExperimental) end
                        iTeamNukes = iTeamNukes + iOtherLandZonesWithExperimental

                        if bDebugMessages == true then LOG(sFunctionRef..': iTeamNukes after update='..iTeamNukes) end
                        if (iTeamNukes == 0 or (iOtherLandZonesWithExperimental == 0 and iTeamNukes == 1 and M28Map.iMapSize > 512 and M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 3)) and (not(tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionSeraphim]) or M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] == 1 or M28Map.bIsCampaignMap or M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL) == 0) then
                            local iHighestNukeTargetValue = M28Building.GetHighestNukeTargetValue(tLZOrWZData, tLZOrWZTeamData, aiBrain.M28Team)
                            if bDebugMessages == true then LOG(sFunctionRef..': iHighestNukeTargetValue='..iHighestNukeTargetValue..'; Team gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]) end
                            if iHighestNukeTargetValue >= 18000 and (iHighestNukeTargetValue >= 30000 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 750) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to get a normal nuke') end
                                iCategoryWanted = M28UnitInfo.refCategorySML - categories.EXPERIMENTAL
                            end
                        end
                    end
                end
            end
            if not(iCategoryWanted) then
                --Check if we have gameender under construction anywhere, and if we want to consider another
                local bEnemyHasExperimentalShields = false --support for mods that add experimental shields that make certain units like the ahwassa and fatboy much less effective
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure]) == false then
                    for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure] do
                        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oUnit.UnitId) then
                            bEnemyHasExperimentalShields = true
                            break
                        end
                    end
                end

                local bDontConsiderGameEnderInMostCases = false
                local bHaveExperimentalForThisLandZone, iOtherLandZonesWithExperimental, iMassToComplete = GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateauOrZero, iLandOrWaterZone, false, nil, M28UnitInfo.refCategoryGameEnder)
                if iOtherLandZonesWithExperimental > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 400 and iMassToComplete <= M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] * 3 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 80 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or iMassToComplete >= 100000 or M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] < 5) then
                    bDontConsiderGameEnderInMostCases = true
                elseif bEnemyHasExperimentalShields and not(tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionAeon]) and not(tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionSeraphim]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= math.min(400, 95 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                    --Do we have Aeon or Searphim factories on team? If so then restrict game enders for now
                    if M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionAeon] >= 3
                            or M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeAir][M28UnitInfo.refFactionAeon] >= 3
                            or M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeAir][M28UnitInfo.refFactionSeraphim] >= 3
                            or M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech][M28Factory.refiFactoryTypeLand][M28UnitInfo.refFactionSeraphim] >= 3 then
                        bDontConsiderGameEnderInMostCases = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Our land subteam has access to aeon or seraphim tech so want to wait to build these gameenders since they should be better against heavily sheielded targets') end
                    end
                end
                if not(bDontConsiderGameEnderInMostCases) and not(tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 999 and M28Utilities.GetDistanceBetweenPositions(tLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) <= 700 then
                    bDontConsiderGameEnderInMostCases = true
                end

                if bDebugMessages == true then LOG(sFunctionRef..': We dont want a nuke, so about to consider faction specific logic if we have enough mass, bEnemyHasExperimentalShields='..tostring(bEnemyHasExperimentalShields)..'; bDontConsiderGameEnderInMostCases='..tostring(bDontConsiderGameEnderInMostCases)..'; Dist to closest enemy base='..M28Utilities.GetDistanceBetweenPositions(tLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestEnemyBase])..'; Is core base='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase])..'; Do we have air control='..tostring(bHaveAirControl)..'; Gunship threat='..M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat]..'; Bomber threat='..M28Team.tTeamData[iTeam][M28Team.subrefiOurBomberThreat]..'; Far behind on air='..tostring(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir])) end

                --Redundancy - dont build experimentals if we are already (hopefully our build conditions wouldnt trigger if we have low mass anyway though)
                if M28Conditions.TeamHasLowMass(iTeam) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 500 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] <= 2500 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.2 and (iOtherLandZonesWithExperimental > 0 or bHaveExperimentalForThisLandZone) and iTeamLandExperimentals < iEnemyLandExperimentalCount + 1 then
                    if bDebugMessages == true then LOG(sFunctionRef..': We dont have lots of mass so wont build more experimentals') end
                    bDontWantExperimental = true
                else
                    --FACTION SPECIFIC LOGIC
                    --special case where prioritise aeon for paragon if dealing with core zone
                    if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] and bEnemyHasExperimentalShields and (tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionAeon] or tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionSeraphim]) and iTeamLandExperimentals >= 2 and not(bDontConsiderGameEnderInMostCases) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 600 and M28Map.iMapSize >= 512 then
                        if tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionAeon] and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryParagon) == 0 then
                            iCategoryWanted = M28UnitInfo.refCategoryParagon
                        elseif tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionSeraphim] then
                            iCategoryWanted = M28UnitInfo.refCategorySML * categories.EXPERIMENTAL
                        end


                        --UEF EXPERIMENTAL CHOICE
                    elseif tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionUEF] then
                        --Decide between fatboy and novax, or (with v.high eco) mavor
                        iFactionRequired = M28UnitInfo.refFactionUEF
                        local iCurFatboyCount = 0
                        local iCurNovaxCount = 0
                        local iCurT3ArtiCount = 0 --mavor treated as 3 t3 arti
                        --How many fatboys do we have on the subteam already?
                        for iBrain, oBrain in M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subreftoFriendlyM28Brains] do
                            iCurFatboyCount = iCurFatboyCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryFatboy)
                            iCurNovaxCount = iCurNovaxCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryNovaxCentre)
                            iCurT3ArtiCount = iCurT3ArtiCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti) + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryExperimentalArti) * 3
                        end
                        local bWantNovaxInsteadOfArti = false
                        if iCurNovaxCount == 0 and not(import("/lua/game.lua").IsRestricted('xeb2402', aiBrain:GetArmyIndex())) and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryNovaxCentre) <= 2 then
                            bWantNovaxInsteadOfArti = true
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering UEF specific, iCurFatboyCount='..iCurFatboyCount..'; iCurNovaxCount='..iCurNovaxCount..'; iCurT3AritCount='..iCurT3ArtiCount) end
                        if bCanPathByLand then
                            if bEnemyHasFatboys and iCurNovaxCount == 0 then
                                iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                            elseif iCurFatboyCount == 0 then
                                iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                                --Game-ender for late game scenarios where enemy has their own arti and as a team we have already tried building a number of experimentals
                            elseif not(bDontConsiderGameEnderInMostCases) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 170 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 200 and iCurT3ArtiCount <= M28Team.tTeamData[iTeam][M28Team.refiEnemyT3ArtiCount] and iTeamLandExperimentals >= 2 and (not(bEnemyHasDangerousLandExpWeCantHandle) or M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] >= 12000) and M28Map.iMapSize >= 512 and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryGameEnder) == 0 and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryExperimentalLevel) >= 2 * (1.5 + M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                                if bWantNovaxInsteadOfArti then iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                                else iCategoryWanted =  M28UnitInfo.refCategoryExperimentalArti
                                end
                            elseif iCurNovaxCount == 0 and bWantNovaxInsteadOfArti then
                                iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                            elseif (bEnemyHasDangerousLandExpWeCantHandle or iCurFatboyCount < 2) and iCurFatboyCount < math.min(5, math.max(math.min(3, 1 + iSubteamSize, 1 + iEnemyLandExperimentalCount), iCurT3ArtiCount + math.max(0, iCurT3ArtiCount - 3))) and (not(bEnemyHasExperimentalShields) or bEnemyHasFatboys or iCurFatboyCount < iEnemyLandExperimentalCount *0.75) then
                                iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                            else
                                --High mass - be more likely to consider mavor
                                if not(bDontConsiderGameEnderInMostCases) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 80 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.5 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 20000 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 110) then
                                    --Get gameender, unless we already have lots of T3 arti in which case consider getting more novaxes (since might be on a more spread out map)
                                    if iCurT3ArtiCount < 3 then
                                        if bWantNovaxInsteadOfArti then iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                                        else
                                            if tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 999 or M28Utilities.GetDistanceBetweenPositions(tLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) >= 800 then
                                                iCategoryWanted =  M28UnitInfo.refCategoryExperimentalArti
                                            else
                                                iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                            end
                                        end
                                    elseif iCurNovaxCount < math.min(2, iCurT3ArtiCount) and not(bEnemyHasExperimentalShields) and (iCurNovaxCount == 0 or M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbNoAvailableTorpsForEnemies]) then
                                        iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                                    else
                                        if iCurT3ArtiCount >= 5 or tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 999 or M28Utilities.GetDistanceBetweenPositions(tLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) >= 800 then
                                            iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                                        else
                                            iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                        end
                                    end
                                else
                                    --Novax or T3 arti (or mavor if enemy base is far away)
                                    if iCurNovaxCount < 3 + iCurT3ArtiCount and (not(bEnemyHasExperimentalShields) or iCurNovaxCount < 1) then
                                        iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                                    else
                                        if iDistToNearestEnemyBase <= 775 then
                                            iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                        else
                                            iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                                        end
                                    end
                                end
                            end
                        else
                            --Cant path with land - prioritise novax more
                            if iCurFatboyCount == 0 and iEnemyLandExperimentalCount > 0 then
                                iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                            else
                                --High mass - be more likely to consider mavor
                                if not(bDontConsiderGameEnderInMostCases) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 80 then
                                    --Get gameender, unless we already have lots of T3 arti in which case consider getting more novaxes (since might be on a more spread out map)
                                    if iCurT3ArtiCount < 3 then
                                        if bWantNovaxInsteadOfArti then iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                                        else iCategoryWanted =  M28UnitInfo.refCategoryExperimentalArti
                                        end
                                    elseif iCurNovaxCount < math.max(2, iCurT3ArtiCount) and (not(bEnemyHasExperimentalShields) or iCurNovaxCount == 0) then
                                        iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                                    else
                                        iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                                    end
                                else
                                    --Novax or T3 arti
                                    if iCurNovaxCount < math.min(3, 1 + iCurT3ArtiCount) and (not(bEnemyHasExperimentalShields) or iCurNovaxCount <= 1) then
                                        iCategoryWanted = M28UnitInfo.refCategoryNovaxCentre
                                    else
                                        if iDistToNearestEnemyBase <= 750 and iCurT3ArtiCount < 4 then
                                            iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                        else
                                            iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                                        end
                                    end
                                end
                            end
                        end
                        --SERAPHIM EXPERIMENTAL CHOICE
                    elseif tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionSeraphim] then
                        iFactionRequired = M28UnitInfo.refFactionSeraphim
                        --Build ahwassa if have air contorl or cant path to enemy with land
                        local iGameEnderCount = 0
                        local iAhwassaCount = 0
                        local iCurT3ArtiCount = 0 --mavor treated as 3 t3 arti

                        for iBrain, oBrain in M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subreftoFriendlyM28Brains] do
                            iGameEnderCount = iGameEnderCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryGameEnder)
                            iAhwassaCount = iAhwassaCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL)
                            iCurT3ArtiCount = iCurT3ArtiCount + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti) + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryExperimentalArti) * 3
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Sera builder, iGameEnderCount='..iGameEnderCount..'; iAhwassaCount='..iAhwassaCount..'; iCurT3ArtiCount='..iCurT3ArtiCount..'; Have air control='..tostring(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl])..'; iTeamLandExperimentals='..iTeamLandExperimentals..'; bEnemyHasDangerousLandExpWeCantHandle='..tostring(bEnemyHasDangerousLandExpWeCantHandle)..'; bDontConsiderGameEnderInMostCases='..tostring(bDontConsiderGameEnderInMostCases)..'; Constructed exp count='..M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount]..'; Ahwassa LC='..M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL)..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Dist to enemy='..M28Utilities.GetDistanceBetweenPositions(tLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestEnemyBase])) end
                        --If we have air control, or arent facing a threat from enemy land, then consider either exp bomber or yolona oss
                        if not(bCanPathByLand) or M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl] or (not(M28Team.tTeamData[iTeam][M28Team.refbFarBehindOnAir]) and iTeamLandExperimentals >= math.max(1, iEnemyLandExperimentalCount)) or (not(bEnemyHasDangerousLandExpWeCantHandle) or iTeamLandExperimentals > iEnemyLandExperimentalCount + 2) then
                            local iAhwassaLifetimeCount = M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL)
                            if not(bDontConsiderGameEnderInMostCases) and iAhwassaLifetimeCount > 0 and (iAhwassaCount >= 2 or iAhwassaLifetimeCount >= 3) and (iGameEnderCount * 3 + iCurT3ArtiCount < 3 * iAhwassaLifetimeCount) and (M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= 4 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 25 + 25 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and
                                    --If have air control: Be much more likely to get lots of ahwassa first
                                    ((M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl] and (iGameEnderCount == 0 or iGameEnderCount * 4 < iAhwassaCount) and (iCurT3ArtiCount < 3 or iCurT3ArtiCount + iGameEnderCount * 4 < iAhwassaCount) and iAhwassaCount >= 1 and iAhwassaLifetimeCount >= 4 and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= math.max(5, 2 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and (M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or iAhwassaCount >= 3 or iAhwassaLifetimeCount >= 7))
                                            --Dont have air control - be more likely to consider gameender/t3 arti
                                            or (not(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl]) and (M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= math.max(5, 2 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])))) then
                                --(((iAhwassaCount > 0 or M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL) >= 2) and (iGameEnderCount == 0 or iGameEnderCount * 3 <= iAhwassaCount) and ((not(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl]) or (iGameEnderCount == 0 and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= math.max(5, 2 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and M28Conditions.GetLifetimeBuildCount(aiBrain, categories.EXPERIMENTAL * M28UnitInfo.refCategoryAirToGround) >= 3)) and iDistToNearestEnemyBase >= 300 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.5 or  and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 90)) or (bEnemyHasExperimentalShields and iAhwassaCount >= math.max(1, 2 * iEnemyLandExperimentalCount))) then
                                if iCurT3ArtiCount < 4 and M28Utilities.GetDistanceBetweenPositions(tLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) <= 750 then
                                    iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                    if bDebugMessages == true then LOG(sFunctionRef..': will get T3 arti as enemy base within 750 and iCurT3ArtiCount='..iCurT3ArtiCount) end
                                else
                                    iCategoryWanted = M28UnitInfo.refCategorySML * categories.EXPERIMENTAL
                                    if bDebugMessages == true then LOG(sFunctionRef..': will get a yolona oss') end
                                end
                            else
                                iCategoryWanted = M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL
                                if bDebugMessages == true then LOG(sFunctionRef..': will build an ahwassa') end
                            end
                        else
                            --Build t3 arti or yolona if are in arti wars (will have built ahwassa above if we had air control)
                            if not(bEnemyHasDangerousLandExpWeCantHandle) and (M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or (iTeamLandExperimentals >= 3 and iAhwassaCount >= 3)) then
                                local iCurT3ArtiCount = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti)
                                if bDebugMessages == true then LOG(sFunctionRef..': Defending against arti so considering yolona or t3 arti since we dont have air control, unless our lifetime count for an ahwassa is 0, iCurT3ArtiCount='..iCurT3ArtiCount) end
                                if M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL) == 0 then
                                    iCategoryWanted = M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL
                                    if bDebugMessages == true then LOG(sFunctionRef..': will get exp bomber') end
                                elseif iCurT3ArtiCount >= 4 or (not(bDontConsiderGameEnderInMostCases) and (iDistToNearestEnemyBase >= 750 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 50 + 40 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) then
                                    iCategoryWanted = M28UnitInfo.refCategorySML * categories.EXPERIMENTAL
                                    if bDebugMessages == true then LOG(sFunctionRef..': will get yolona') end
                                else
                                    iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                    if bDebugMessages == true then LOG(sFunctionRef..': will get T3 arti') end
                                end

                                --Consider building a yolona instead of a ythotha (or ahwassa instead of either) in some cases (e.g. where lots of land exp)
                            elseif (iTeamLandExperimentals >= 3 + 3 * (aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti) + iGameEnderCount * 2) and ((iTeamLandExperimentals >= math.max(5, iEnemyLandExperimentalCount + 1) or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandExperimental) >= 3 + iGameEnderCount) or (iGameEnderCount == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 80))) or (not(bDontConsiderGameEnderInMostCases) and bEnemyHasExperimentalShields and iTeamLandExperimentals >= 1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 80) then
                                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 70 and iDistToNearestEnemyBase <= 750 then
                                    local iT3ArtiCount = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti)
                                    if not(bDontConsiderGameEnderInMostCases) and iAhwassaCount < (iT3ArtiCount + iGameEnderCount * 3) and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL) < 2 + (iT3ArtiCount + iGameEnderCount * 3) then
                                        iCategoryWanted = M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL
                                        if bDebugMessages == true then LOG(sFunctionRef..': want an ahwassa') end
                                    elseif iT3ArtiCount < 4 and not(bEnemyHasExperimentalShields) then
                                        iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want sera t3 arti') end
                                    else
                                        iCategoryWanted = M28UnitInfo.refCategorySML * categories.EXPERIMENTAL
                                        if bDebugMessages == true then LOG(sFunctionRef..': want sera Exp nuke') end
                                    end
                                else
                                    if (bDontConsiderGameEnderInMostCases or (iAhwassaCount < 1 + iGameEnderCount * 3 and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL) <= 2 + iGameEnderCount * 3)) or (bEnemyHasExperimentalShields and iAhwassaCount >= math.max(1, 2 * iEnemyLandExperimentalCount)) then
                                        iCategoryWanted = M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want ahwassa') end
                                    else
                                        iCategoryWanted = M28UnitInfo.refCategorySML * categories.EXPERIMENTAL
                                        if bDebugMessages == true then LOG(sFunctionRef..': decided to get a yolona') end
                                    end
                                end
                            else
                                --We arent defending against arti (or if we are we have a more urgent enemy land exp threat), and dont have lots of ahwassa and land exp, so build either exp bomber or ythotha
                                --If have 5+ land experimentals then consider an ahwassa even if lack air control
                                if (iAhwassaCount + 1) * 2 + 3 < iTeamLandExperimentals then
                                    iCategoryWanted = M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will get another exp bomber') end
                                else
                                    iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                                    --If have Aeon then get GC in preference to Ythotha
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will get a ythotha, unless we have aeon engis in which case will get aeon') end
                                    if tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionAeon] then iFactionRequired = M28UnitInfo.refFactionAeon end
                                end
                            end
                        end
                    elseif tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionCybran] then
                        iFactionRequired = M28UnitInfo.refFactionCybran
                        --If cant path to enemy with amphibious (rather than land), or enemy is building t3 arti, then consider T3 arti
                        local iCurAirExperimentals = 0
                        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                            iCurAirExperimentals = iCurAirExperimentals + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryGunship * categories.EXPERIMENTAL + M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL + M28UnitInfo.refCategoryCzar)
                        end
                        local bAirExpForThisZone, iOtherLandZonesWithAirExperimental, AiriMassToComplete = GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateauOrZero, iLandOrWaterZone, false, nil, M28UnitInfo.refCategoryGunship * categories.EXPERIMENTAL + M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL + M28UnitInfo.refCategoryCzar)
                        iCurAirExperimentals = iCurAirExperimentals + iOtherLandZonesWithAirExperimental
                        --Switch to t3 arti or scathis in some cases (e.g. cant reach enemy by hover; or have lots of land+air exp; or enemy has fatboy)
                        if not(bCanPathAmphibiously) or ((not(bDontConsiderGameEnderInMostCases) or iDistToNearestEnemyBase <= 750) and iTeamLandExperimentals + iCurAirExperimentals * 1.25 >=  math.max(5, iEnemyLandExperimentalCount * 1.25)) or (not(bEnemyHasDangerousLandExpWeCantHandle) and iTeamLandExperimentals >= 1 and ((M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFatboy, M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals])) == false) or (aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMegalith) > 0 and M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]))) then
                            --Air exp
                            if iCurAirExperimentals == 0 and bHaveAirControl then
                                iCategoryWanted = M28UnitInfo.refCategoryAirToGround * categories.EXPERIMENTAL
                                iFactionRequired = nil
                                if bDebugMessages == true then LOG(sFunctionRef..': Cybr want exp air') end
                            elseif iDistToNearestEnemyBase <= 750 and (bDontConsiderGameEnderInMostCases or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 90 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                                if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti) < 4 then
                                    iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                    iFactionRequired = nil
                                    if bDebugMessages == true then LOG(sFunctionRef..': Cybr want T3 arti') end
                                else
                                    iCategoryWanted = M28UnitInfo.refCategoryExperimentalStructure --i.e. scathis
                                    if bDebugMessages == true then LOG(sFunctionRef..': Cybr want exp structure') end
                                end
                            else
                                iCategoryWanted = M28UnitInfo.refCategoryExperimentalStructure --this includes scathis
                                if bDebugMessages == true then LOG(sFunctionRef..': Cybr want an exp structure') end
                            end
                        else
                            --Consider air experimental in some rarer cases late game
                            local bGetAirExperimentalInstead = false
                            if (bEnemyHasFatboys and iTeamLandExperimentals >= 1) or (iTeamLandExperimentals >= 2 and (iTeamLandExperimentals >= 5 or (iTeamLandExperimentals >= 3 and (bHaveAirControl or M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat] >= 10000)) or (iTeamLandExperimentals <= 2 and (bHaveAirControl and M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat] >= 10000)))) then
                                if iCurAirExperimentals == 0 or (bEnemyHasFatboys and (iCurAirExperimentals <= math.max(1, iTeamLandExperimentals) or iCurAirExperimentals * 10000 < M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat])) or (iCurAirExperimentals * 2.5 < iTeamLandExperimentals and (iCurAirExperimentals + 1) * 10000 < M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat]) then
                                    bGetAirExperimentalInstead = true
                                end
                            end
                            if bGetAirExperimentalInstead then
                                iCategoryWanted = M28UnitInfo.refCategoryGunship * categories.EXPERIMENTAL + M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL
                                if bDebugMessages == true then LOG(sFunctionRef..': Cybr will get exp air') end
                            elseif not(bCanPathByLand) then
                                iCategoryWanted = M28UnitInfo.refCategoryMegalith --megalith has better torps
                                if bDebugMessages == true then LOG(sFunctionRef..': Cybr will get mega') end
                            else
                                if iTeamLandExperimentals == 0 and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandExperimental) < 2 then
                                    iCategoryWanted = M28UnitInfo.refCategoryMonkeylord
                                    if bDebugMessages == true then LOG(sFunctionRef..': Cybr will get monkey') end
                                else
                                    --Get megalith
                                    iCategoryWanted = M28UnitInfo.refCategoryLandExperimental - M28UnitInfo.refCategoryMonkeylord --i.e. megalith (but slightly more helpful to mods doing it this way)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Cybr will get non monkey land exp') end
                                end
                            end
                        end
                    elseif tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionAeon] then
                        iFactionRequired = M28UnitInfo.refFactionAeon
                        local iCurAirExperimentals = 0
                        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                            iCurAirExperimentals = iCurAirExperimentals + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryGunship * categories.EXPERIMENTAL + M28UnitInfo.refCategoryCzar)
                        end
                        local bAirExpForThisZone, iOtherLandZonesWithAirExperimental, AiriMassToComplete = GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateauOrZero, iLandOrWaterZone, false, nil, M28UnitInfo.refCategoryGunship * categories.EXPERIMENTAL + M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL + M28UnitInfo.refCategoryCzar)
                        local iCurT3ArtiCount = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti) + aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryExperimentalArti) * 3
                        local iLifetimeAirExpCount = M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryAirToGround * categories.EXPERIMENTAL)
                        local iLifetimeGroundExpCount =  M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandExperimental)
                        local bHaveLargeBuildAreaAvailable = false
                        if (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][24] or 0) > 0 then
                            bHaveLargeBuildAreaAvailable = true
                        end
                        iCurAirExperimentals = iCurAirExperimentals + iOtherLandZonesWithAirExperimental

                        local iEnemyT3ArtiEquivalent = M28Conditions.GetEnemyT3ArtiEquivalent(iTeam, 0.4, 3, true, nil)
                        local iFriendlyGameEnderUnderConstruction = M28Conditions.GetNumberOfUnderConstructionUnitsOfCategoryInOtherZones(tLZOrWZTeamData, iTeam, M28UnitInfo.refCategoryGameEnder)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering aeon specific experimental, iCurAirExperimentals='..iCurAirExperimentals..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Land exp='..iTeamLandExperimentals..'; iFriendlyGameEnderUnderConstruction='..iFriendlyGameEnderUnderConstruction..'; iEnemyT3ArtiEquivalent='..iEnemyT3ArtiEquivalent..'; refbDefendAgainstArti='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or false)..'; iEnemyLandExperimentalCount='..iEnemyLandExperimentalCount..'; Our gunship threat='..M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat]..'; iOur bomber threat='..M28Team.tTeamData[iTeam][M28Team.subrefiOurBomberThreat]..'; iLifetimeAirExpCount='..iLifetimeAirExpCount..'; iLifetimeGroundExpCount='..iLifetimeGroundExpCount..'; bHaveLargeBuildAreaAvailable='..tostring(bHaveLargeBuildAreaAvailable)) end
                        if bHaveLargeBuildAreaAvailable and iLifetimeGroundExpCount >= 4 and iLifetimeAirExpCount < iLifetimeGroundExpCount / 5 and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= 4 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have built lots of exp but havent tried many czars so will get some even if we lack air control') end
                            iCategoryWanted = M28UnitInfo.refCategoryAirToGround * categories.EXPERIMENTAL
                        elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1000 and (iCurAirExperimentals + iTeamLandExperimentals > (iFriendlyGameEnderUnderConstruction + iCurT3ArtiCount) or iCurAirExperimentals + iTeamLandExperimentals > 0 and iEnemyT3ArtiEquivalent > 0) then
                            iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to get salvation due to high mass') end
                            --Do we want to get t3 arti or gameender?
                        elseif not(bCanPathAmphibiously) or
                                (not(bCanPathByLand) and iDistToNearestEnemyBase >= 650 and iEnemyLandExperimentalCount == 0 and iTeamLandExperimentals + iCurAirExperimentals > 0) or
                                ((not(bDontConsiderGameEnderInMostCases) or iDistToNearestEnemyBase <= 750) and (iTeamLandExperimentals + iCurAirExperimentals * 1.6 >= math.max(3, iEnemyLandExperimentalCount + 1) or ((M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= 2 or M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) and iTeamLandExperimentals + M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] / 15000 + M28Team.tTeamData[iTeam][M28Team.subrefiOurBomberThreat] / 15000 >= math.max(2, M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] * 0.5, iEnemyLandExperimentalCount)))) or
                                (not(bEnemyHasDangerousLandExpWeCantHandle) and (not(bDontConsiderGameEnderInMostCases) or M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandExperimental) >= math.max(4, 2 + M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) and (iTeamLandExperimentals >= 1 or M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 110 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) then

                                --Consider building Czar
                            if bHaveLargeBuildAreaAvailable and iCurAirExperimentals <= iCurT3ArtiCount and (iEnemyT3ArtiEquivalent < 1 or iCurAirExperimentals == 0) and (not(M28Conditions.TeamIsFarBehindOnAir(iTeam)) or (iCurT3ArtiCount >= 3 and iCurAirExperimentals == 0 and iLifetimeAirExpCount < iCurT3ArtiCount)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to get some Czars') end
                                iCategoryWanted = M28UnitInfo.refCategoryAirToGround * categories.EXPERIMENTAL
                            elseif iDistToNearestEnemyBase <= 750 then
                                if iEnemyT3ArtiEquivalent < 4 then
                                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1000 then
                                        iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want to get a salvation due to very high mass') end
                                    else iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy base dist is '..iDistToNearestEnemyBase..' so will get T3 arti') end
                                    end
                                else
                                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= math.max(275, 110 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and iEnemyT3ArtiEquivalent <= 1.4 and iFriendlyGameEnderUnderConstruction == 0 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will get paragon1; gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; iEnemyT3ArtiEquivalent='..iEnemyT3ArtiEquivalent..'; iFriendlyGameEnderUnderConstruction='..iFriendlyGameEnderUnderConstruction) end
                                        iCategoryWanted = M28UnitInfo.refCategoryParagon
                                    else
                                        iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will get salvation as mass high enough that not sure we would benefit that much from a paragon') end
                                    end
                                end
                            else
                                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= math.max(275, 110 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and iEnemyT3ArtiEquivalent <= 1.4 and iFriendlyGameEnderUnderConstruction == 0 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to get paragon2; gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; iEnemyT3ArtiEquivalent='..iEnemyT3ArtiEquivalent..'; iFriendlyGameEnderUnderConstruction='..iFriendlyGameEnderUnderConstruction) end
                                    iCategoryWanted = M28UnitInfo.refCategoryParagon
                                else
                                    iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have enough mass that will go for a salvation') end
                                end
                            end
                        else
                            --Consider air experimental in some rarer cases late game
                            local bGetAirExperimentalInstead = false
                            if bHaveLargeBuildAreaAvailable and
                                ((bEnemyHasFatboys and iTeamLandExperimentals >= 1) or
                                (iTeamLandExperimentals >= 2 and (iTeamLandExperimentals >= 5 or (iTeamLandExperimentals >= 3 and (bHaveAirControl or M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat] >= 10000 or (iCurAirExperimentals == 0 and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryAllAir * categories.EXPERIMENTAL) == 0))) or (iTeamLandExperimentals <= 2 and (bHaveAirControl and M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat] >= 10000))))
                                or (iTeamLandExperimentals >= iCurAirExperimentals * 3 and (not(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) or bHaveAirControl) and iTeamLandExperimentals >= math.min(4, M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandExperimental) >= 3 + 3 * M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryAllAir * categories.EXPERIMENTAL))) then

                                if iCurAirExperimentals == 0 or (bEnemyHasFatboys and (iCurAirExperimentals <= math.max(1, iTeamLandExperimentals) or iCurAirExperimentals * 10000 < M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat])) or  (iCurAirExperimentals * 2.5 < iTeamLandExperimentals and (iCurAirExperimentals + 1) * 10000 < M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat]) or (iCurAirExperimentals < iTeamLandExperimentals and bHaveAirControl) then
                                    bGetAirExperimentalInstead = true
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': We can path to enemy amphibiously so will consider whether to get air or land, bGetAirExperimentalInstead='..tostring(bGetAirExperimentalInstead or false)) end
                            if bGetAirExperimentalInstead then
                                iCategoryWanted = M28UnitInfo.refCategoryGunship * categories.EXPERIMENTAL + M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL + M28UnitInfo.refCategoryCzar
                            else
                                --Build GC or paragon or T3 arti (or Czar in some rare cases)
                                if ((iTeamLandExperimentals >= 5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 70) or (iTeamLandExperimentals >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 80 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= math.max(275, 110 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and iEnemyT3ArtiEquivalent <= 1.4 and iFriendlyGameEnderUnderConstruction == 0 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will get paragon3 or T3 arti due to lots of friendly land experimentals; gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; iEnemyT3ArtiEquivalent='..iEnemyT3ArtiEquivalent..'; iFriendlyGameEnderUnderConstruction='..iFriendlyGameEnderUnderConstruction..'; iTeamLandExperimentals='..iTeamLandExperimentals) end
                                    if M28Map.iMapSize >= 512 and (M28Map.iMapSize >= 1024 or M28Conditions.GetCurrentM28UnitsOfCategoryInTeam(M28UnitInfo.refCategoryFixedT3Arti, iTeam) >= 4) and iFriendlyGameEnderUnderConstruction == 0 then
                                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 9500 then
                                            iCategoryWanted = M28UnitInfo.refCategoryParagon
                                            if bDebugMessages == true then LOG(sFunctionRef..': Getting paragon5') end
                                        else
                                            iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Getting paragon4') end
                                    else
                                        iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                        if bDebugMessages == true then LOG(sFunctionRef..': Want t3 arti') end
                                    end
                                elseif not(bEnemyHasDangerousLandExpWeCantHandle) and iDistToNearestEnemyBase <= 750 and (iTeamLandExperimentals >= math.max(1, aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryGameEnder)) or M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandExperimental) >= 3) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 40 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                                    if M28Map.iMapSize >= 1024 and iDistToNearestEnemyBase >= 400 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 40 + 40 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and iFriendlyGameEnderUnderConstruction == 0 then
                                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 9500 then
                                            iCategoryWanted = M28UnitInfo.refCategoryParagon
                                            if bDebugMessages == true then LOG(sFunctionRef..': Getting paragon5') end
                                        else
                                            iCategoryWanted = M28UnitInfo.refCategoryExperimentalArti
                                        end
                                    else
                                        iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
                                        if bDebugMessages == true then LOG(sFunctionRef..': Aeon getting t3 arti') end
                                    end

                                else
                                    --Dont reset faction requirement as GC is better than most other factions
                                    iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                                    if bDebugMessages == true then LOG(sFunctionRef..': want more land experimentals') end
                                end
                            end
                        end
                    else
                        --Not dealing with standard faction - basic choice between land and T3 arti/experimental structure, since unlikely to have hte logic in place for other units
                        if not(bCanPathAmphibiously) then
                            iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalStructure
                            local iCurExperimentalsOfType = 0
                            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                iCurExperimentalsOfType = iCurExperimentalsOfType + oBrain:GetCurrentUnits(iCategoryWanted)
                            end
                            if iCurExperimentalsOfType >= 3 + iTeamNukes and (iCurExperimentalsOfType >= 6 + iTeamNukes or M28Utilities.GetDistanceBetweenPositions(tLZOrWZTeamData[M28Map.reftClosestEnemyBase], tLZOrWZData[M28Map.subrefMidpoint]) >= 750) then
                                iCategoryWanted = M28UnitInfo.refCategorySML
                            end
                        else
                            --can path to enemy with land
                            local iBaseAdjust = 0
                            if iDistToNearestEnemyBase >= 400 then
                                if iDistToNearestEnemyBase >= 750 then iBaseAdjust = -2
                                else iBaseAdjust = -1
                                end
                            end

                            if iTeamLandExperimentals <= math.max(iEnemyLandExperimentalCount + 2 + iBaseAdjust, 3 + iBaseAdjust) then
                                iCategoryWanted = M28UnitInfo.refCategoryLandExperimental
                            else
                                iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalStructure
                                local iCurExperimentalsOfType = 0
                                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                                    iCurExperimentalsOfType = iCurExperimentalsOfType + oBrain:GetCurrentUnits(iCategoryWanted)
                                end
                                if iCurExperimentalsOfType >= 3 and iCurExperimentalsOfType <= math.max(4, iTeamLandExperimentals * 2) then
                                    iCategoryWanted = iCategoryWanted + M28UnitInfo.refCategoryLandExperimental
                                end
                            end
                        end
                    end
                end
            end
            --Switch from gameender to T3 arti if enemy has a nearby firebase and the nearest enemy base is within 820 of us
            if iCategoryWanted and M28Utilities.DoesCategoryContainCategory(iCategoryWanted, M28UnitInfo.refCategoryGameEnder) and (M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false or (tLZOrWZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) >= 1500) and M28Utilities.GetDistanceBetweenPositions(tLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestEnemyBase]) <= 820 then
                iCategoryWanted = M28UnitInfo.refCategoryFixedT3Arti
            end

            --Check if we want to switch to using a gameender template
            if iCategoryWanted and M28Utilities.DoesCategoryContainCategory(iCategoryWanted, M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryNovaxCentre) then
                --DO we have a template available?
                if M28Conditions.HaveTemplateSpaceForGameEnder(iCategoryWanted, tLZOrWZData, tLZOrWZTeamData, tbEngineersOfFactionOrNilIfAlreadyAssigned, aiBrain.M28Team) and not(aiBrain.M28Easy) then
                    iGameEnderTemplateCategory = iCategoryWanted
                    tLZOrWZTeamData[M28Map.refiLastGameEnderTemplateCategory] = iCategoryWanted
                    iCategoryWanted = refActionManageGameEnderTemplate
                end
            end
        end
    end
    if not(iCategoryWanted) and not(bDontWantExperimental) then iCategoryWanted = M28UnitInfo.refCategoryLandExperimental end --redundancy
    if iCategoryWanted == refActionManageGameEnderTemplate and not(tLZOrWZTeamData[M28Map.refiLastGameEnderTemplateCategory]) then
        --Redundancy - wouldn't expect to get here
        local iOurT3Arti = 0
        local iOurNovax = 0
        local iOurGameEnder = 0
        for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyActiveM28Brains] do
            iOurT3Arti = iOurT3Arti + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti)
            iOurNovax = iOurNovax + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti)
            iOurGameEnder = iOurGameEnder + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryGameEnder)
        end
        local iDistToNearestEnemyBase = M28Utilities.GetDistanceBetweenPositions(tLZOrWZData[M28Map.subrefMidpoint], tLZOrWZTeamData[M28Map.reftClosestEnemyBase])
        if iDistToNearestEnemyBase >= 750 then
            if tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionUEF] and (iOurNovax == 0 or (iOurNovax < 3 and M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftEnemyArtiAndExpStructure]))) then
                tLZOrWZTeamData[M28Map.refiLastGameEnderTemplateCategory] = M28UnitInfo.refCategoryNovaxCentre
            elseif iOurT3Arti < 3 then
                tLZOrWZTeamData[M28Map.refiLastGameEnderTemplateCategory] = M28UnitInfo.refCategoryFixedT3Arti
            else
                tLZOrWZTeamData[M28Map.refiLastGameEnderTemplateCategory] = M28UnitInfo.refCategoryGameEnder
            end
        else
            if tbEngineersOfFactionOrNilIfAlreadyAssigned[M28UnitInfo.refFactionUEF] and (iOurNovax == 0 or (iOurNovax < 3 and M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.reftEnemyArtiAndExpStructure]))) then
                tLZOrWZTeamData[M28Map.refiLastGameEnderTemplateCategory] = M28UnitInfo.refCategoryNovaxCentre
            else
                tLZOrWZTeamData[M28Map.refiLastGameEnderTemplateCategory] = M28UnitInfo.refCategoryGameEnder
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, will list out all blueprints meeting iCategoryWanted. iFactionRequired='..(iFactionRequired or 'nil'))
        if iCategoryWanted and not(iCategoryWanted == refActionManageGameEnderTemplate)  then
            local tBlueprints = EntityCategoryGetUnitList(iCategoryWanted)
            LOG('Blueprints='..repru(tBlueprints))
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iCategoryWanted, iFactionRequired
end

function MonitorToReissueReclaimOrder(oEngineer, oNearestReclaimableEnemy, iDistanceToReissue, iTicksToCheck)
    --Call vai fork thread, intended so e.g. when engineer is approaching an enemy to reclaim, it will start reclaiming hte moment the enemy gets within reclaim range
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MonitorToReissueReclaimOrder'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iRemainingTicksToWait = iTicksToCheck
    local iCurDist
    local iEngineerActionRequired = oEngineer[refiAssignedAction]
    local iEngineerPriorityRequired = oEngineer[refiAssignedActionPriority]

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to reclaim enemy '..oNearestReclaimableEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestReclaimableEnemy)..'; iDistanceToReissue='..iDistanceToReissue..'; iTicksToCheck='..iTicksToCheck..'; Time='..GetGameTimeSeconds()) end
    while iRemainingTicksToWait > 0 do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        iRemainingTicksToWait = iRemainingTicksToWait - 1
        --Abort if either unit is invalid, engineer is already reclaiming, or engineer appears to have orders changed (vai cahnge in priority or action)
        if bDebugMessages == true then
            LOG(sFunctionRef..': iRemainingTicksToWait='..iRemainingTicksToWait..'; TIme='..GetGameTimeSeconds()..'; Is engi valid='..tostring(M28UnitInfo.IsUnitValid(oEngineer))..'; Is nearest reclaimable enemy valid='..tostring(M28UnitInfo.IsUnitValid(oNearestReclaimableEnemy))..'; Engi action='..(oEngineer[refiAssignedAction] or 'nil')..'; Engi priority='..(oEngineer[refiAssignedActionPriority] or 'nil'))
            if M28UnitInfo.IsUnitValid(oEngineer) and M28UnitInfo.IsUnitValid(oNearestReclaimableEnemy) then
                LOG(sFunctionRef..': Dist from engi to nearest enemy='..M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), oNearestReclaimableEnemy:GetPosition())..'; Engi state='..M28UnitInfo.GetUnitState(oEngineer))
            end
        end
        if M28UnitInfo.IsUnitValid(oEngineer) and M28UnitInfo.IsUnitValid(oNearestReclaimableEnemy) and not(oEngineer:IsUnitState('Reclaiming')) and oEngineer[refiAssignedAction] == iEngineerActionRequired and oEngineer[refiAssignedActionPriority] == iEngineerPriorityRequired then
            iCurDist = M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), oNearestReclaimableEnemy:GetPosition())
            if iCurDist <= iDistanceToReissue then
                if bDebugMessages == true then LOG(sFunctionRef..': Engineer is close to target so will issue a reclaim order') end
                M28Orders.IssueTrackedReclaim(oEngineer, oNearestReclaimableEnemy, false, 'ReclByT', false)
                break --Dont want to risk clearing engineer every tick and never reclaiming
            elseif iCurDist <= iDistanceToReissue + 0.5 and EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oNearestReclaimableEnemy.UnitId) and oEngineer:IsUnitState('Moving') and oNearestReclaimableEnemy:IsUnitState('Moving') then
                --If enemy unit is moving and we are moving, then likely will be in range by the time the reclaim order goes through - check enemy engi is moving towards us
                if bDebugMessages == true then LOG(sFunctionRef..': Almost in range of enemy engineer, so will try reclaiming very slightly sooner if angle dif from them suggests they are moving towards us, angle dif='..M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oNearestReclaimableEnemy:GetPosition(), oEngineer:GetPosition()), M28UnitInfo.GetUnitFacingAngle(oNearestReclaimableEnemy))) end
                if M28Utilities.GetAngleDifference(M28Utilities.GetAngleFromAToB(oNearestReclaimableEnemy:GetPosition(), oEngineer:GetPosition()), M28UnitInfo.GetUnitFacingAngle(oNearestReclaimableEnemy)) <= 35 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Repeating reclaim order') end
                    M28Orders.IssueTrackedReclaim(oEngineer, oNearestReclaimableEnemy, false, 'ReclByET', false)
                    break --Dont want to risk clearing engineer every tick and never reclaiming
                end
            end
        else
            break
        end

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function CheckForNearbyEnemies()  end --This is incorporated into available engineers by tech - added to make it easier to locate logic
function FilterToAvailableEngineersByTech(tEngineers, bInCoreZone, tLZData, tLZTeamData, iTeam, iPlateauOrPond, iLandZone, bIsWaterZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'FilterToAvailableEngineersByTech'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..' for iPlateauOrPond='..iPlateauOrPond..'; iLandZone='..iLandZone..'; reprs of tEngineers='..reprs(tEngineers)) end

    --Returns a table of available engineers by tech
    local toAvailableEngineersByTech = {[1]= { },[2]={},[3]={}}
    local toAssignedEngineers = {}
    local bHaveAvailableEngi = false
    local aiBrain = ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]]  --M28Team.GetFirstActiveM28Brain(iTeam)
    --local tNearbyEnemiesByZone = {}
    local bCheckForEnemies = false
    local bCheckIfEnemyIsActuallyEnemy = false
    if M28Map.bIsCampaignMap and (M28Overseer.tbSpecialCodeForMission[41] or (ScenarioInfo.QAICommander and M28UnitInfo.IsUnitValid(ScenarioInfo.QAICommander))) then
        bCheckIfEnemyIsActuallyEnemy = true
    end
    if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then --M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
        --table.insert(tNearbyEnemiesByZone, tLZTeamData[M28Map.subrefTEnemyUnits])
        bCheckForEnemies = true
    end

    --[[if bIsWaterZone then
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefWZOtherWaterZones]) == false then
            local iAdjWZ
            for _, tWZSubtable in  tLZData[M28Map.subrefWZOtherWaterZones] do
                iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]

                if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                    table.insert(tNearbyEnemiesByZone, M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits])
                    bCheckForEnemies = true
                end
            end
        end
    elseif M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjacentLZ in  tLZData[M28Map.subrefLZAdjacentLandZones] do
            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iAdjacentLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                table.insert(tNearbyEnemiesByZone, M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iAdjacentLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEnemyUnits])
                bCheckForEnemies = true
            end
        end
    end--]]
    --if bDebugMessages == true then LOG(sFunctionRef..': Finished deciding if should check for enemies (based on if enemy threats in this or nearby LZ), bCheckForEnemies='..tostring(bCheckForEnemies)..'; Is table of enemy units for this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]))..'; is tNearbyEnemiesByZone empty='..tostring(M28Utilities.IsTableEmpty(tNearbyEnemiesByZone))..'; subrefLZThreatEnemyMobileDFTotalin this LZ='..(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)) end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished deciding if should check for enemies (based on if enemy threats in this or nearby LZ), bCheckForEnemies='..tostring(bCheckForEnemies)..'; If get units aroundpoint with radius of 30 is the table of units empty='..tostring(M28Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategorySubmarine, tLZData[M28Map.subrefMidpoint], 30, 'Enemy')))) end

    local iClosestDistUntilInRangeOfMobileEnemy = 100000
    local iClosestDistUntilInRangeOfStaticEnemy = 100000
    local iNearestReclaimableEnemy = 100000
    local iNearestReclaimableDangerousEnemy = 100000
    local oNearestReclaimableDangerousEnemy
    local iNearestEnemy = 100000
    local oNearestReclaimableEnemy
    local oNearestEnemy
    local iCurDistToEnemy
    local iCurDistUntilInRange
    local iCurUnitRange
    local bWantEngiToRun
    local bEngiIsUnavailable

    local iLZOrWZToRunTo
    local iThresholdToRunFromMobileEnemies = 35
    if bInCoreZone or (bIsWaterZone and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false) then iThresholdToRunFromMobileEnemies = 10 end

    local iEnemyUnitSearchRange = iThresholdToRunFromMobileEnemies + math.max(10, (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0), (tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 0), (tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0), (tLZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0), (tLZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] or 0))
    local iActualEnemySearchRange
    local iActualEnemyCategorySearch
    local iEasyEnemyCategorySearch = M28UnitInfo.refCategoryStructure
    local iNormalEnemyCategorySearch = M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategorySubmarine

    local bCheckForReclaim
    if (tLZData[M28Map.subrefTotalSignificantMassReclaim] or 0) >= 20 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 8 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.1 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] <= 300 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.35)) then
        bCheckForReclaim = true
    end

    if tEngineers then
        local bCheckForWallsToReclaim = false
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of wall segments empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPlayerWallSegments]))) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPlayerWallSegments]) == false then
            if table.getn(tLZData[M28Map.subrefLZPlayerWallSegments]) >= 10 then
                bCheckForWallsToReclaim = true
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Size of wall segment table='..table.getn(tLZData[M28Map.subrefLZPlayerWallSegments])..'; bCheckForWallsToReclaim='..tostring(bCheckForWallsToReclaim or false)) end
        end

        --Use much lower threshold to run if if we have T2+ PD in this zone
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                if iRange >= 50 and iThreat > 0 then
                    iThresholdToRunFromMobileEnemies = 5
                    break
                end
            end
        end


        if bDebugMessages == true then LOG(sFunctionRef..': iEnemyUnitSearchRange='..iEnemyUnitSearchRange..'; iThresholdToRunFromMobileEnemies='..iThresholdToRunFromMobileEnemies..'; Time='..GetGameTimeSeconds()) end
        local bIgnoreIfEnemyUnderwater = false
        local bConsiderReclaimableEnemiesInBuildRangeOnly
        for iEngineer, oEngineer in tEngineers do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering engineer '..(oEngineer.UnitId or 'nil')..'; iEngineer='..iEngineer..' with unit state='..M28UnitInfo.GetUnitState(oEngineer)..'; refiAssignedAction='..(oEngineer[refiAssignedAction] or 'nil')..'; oEngineer[M28UnitInfo.refbSpecialMicroActive]='..tostring(oEngineer[M28UnitInfo.refbSpecialMicroActive] or false)..'; refiGameTimeToResetMicroActive='..(oEngineer[M28UnitInfo.refiGameTimeToResetMicroActive] or 'nil')) end
            bWantEngiToRun = false
            bEngiIsUnavailable = false
            if not(oEngineer:IsUnitState('Attached')) and not(oEngineer[M28UnitInfo.refbSpecialMicroActive]) and not(oEngineer:IsUnitState('Capturing')) then
                if bIsWaterZone and EntityCategoryContains(categories.HOVER, oEngineer.UnitId) then bIgnoreIfEnemyUnderwater = true end
                --First check for enemies that we want to run from/take action from
                if bCheckForEnemies or bCheckForWallsToReclaim then
                    local bReclaimingDangerousEnemy = false
                    iNearestReclaimableEnemy = 10000
                    iNearestReclaimableDangerousEnemy = 10000
                    iClosestDistUntilInRangeOfMobileEnemy = 10000
                    iClosestDistUntilInRangeOfStaticEnemy = 10000
                    oNearestReclaimableDangerousEnemy = nil
                    oNearestReclaimableEnemy = nil
                    oNearestEnemy = nil
                    bConsiderReclaimableEnemiesInBuildRangeOnly = false

                    --If engi is building emergency PD or Arti or torp launcher then dont run
                    if not(oEngineer[refiAssignedAction] == refActionBuildEmergencyPD or oEngineer[refiAssignedAction] == refActionBuildEmergencyArti or oEngineer[refiAssignedAction] == refActionBuildWall or oEngineer[refiAssignedAction] == refActionBuildT1TorpLauncher or oEngineer[refiAssignedAction] == refActionBuildTorpLauncher) then
                        --Is the engineer reclaiming an engineer or combat unit, or alternatively building something whose fraction complete is almost done?
                        if oEngineer:IsUnitState('Reclaiming') then
                            local oReclaimTarget = oEngineer:GetFocusUnit()
                            if oReclaimTarget and not(oReclaimTarget.Dead) and ((oReclaimTarget[M28UnitInfo.refiCombatRange] or 0) > 0 or EntityCategoryContains(categories.RECLAIM, oReclaimTarget.UnitId)) then
                                bReclaimingDangerousEnemy = true
                            end
                        end
                        if not(bReclaimingDangerousEnemy or ((oEngineer:IsUnitState('Repairing') or oEngineer:IsUnitState('Building')) and oEngineer:GetFocusUnit() and oEngineer:GetFocusUnit():GetFractionComplete() >= 0.9 and oEngineer:GetFocusUnit():GetFractionComplete() < 1) or (oEngineer:IsUnitState('Capturing') and oEngineer:GetWorkProgress() >= 0.75)) then
                            if not(oEngineer[M28UnitInfo.refbEasyBrain]) or (not(oEngineer:IsUnitState('Reclaiming')) and not(oEngineer:IsUnitState('Repairing')) and not(oEngineer:IsUnitState('Building'))) then
                                if aiBrain.GetUnitsAroundPoint then
                                    if oEngineer[M28UnitInfo.refbEasyBrain] then
                                        iActualEnemySearchRange = math.min(10, iEnemyUnitSearchRange)
                                        iActualEnemyCategorySearch = iEasyEnemyCategorySearch
                                    else
                                        iActualEnemySearchRange = iEnemyUnitSearchRange
                                        iActualEnemyCategorySearch = iNormalEnemyCategorySearch
                                    end
                                    local tNearbyEnemiesByZone = aiBrain:GetUnitsAroundPoint(iActualEnemyCategorySearch, oEngineer:GetPosition(), iActualEnemySearchRange, 'Enemy')
                                    --for iSubtable, tSubtable in tNearbyEnemiesByZone do
                                    --if M28Utilities.IsTableEmpty(tSubtable) == false then
                                    --for iUnit, oUnit in tSubtable do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby enemies empty for engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'='..tostring(M28Utilities.IsTableEmpty(tNearbyEnemiesByZone))) end
                                    if M28Utilities.IsTableEmpty(tNearbyEnemiesByZone) == false then

                                        for iUnit, oUnit in tNearbyEnemiesByZone do
                                            --It's not possible to reclaim an under construction building
                                            if not(oUnit.Dead) and (oUnit:GetFractionComplete() == 1 or not(oUnit:IsBeingBuilt())) then
                                                if not(bCheckIfEnemyIsActuallyEnemy) or (IsEnemy(oEngineer:GetAIBrain():GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex())) then
                                                    if not(bIgnoreIfEnemyUnderwater) or not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                                                        iCurUnitRange = (oUnit[M28UnitInfo.refiDFRange] or 0) + (oUnit[M28UnitInfo.refiIndirectRange] or 0)
                                                        if bIsWaterZone then iCurUnitRange = math.max(iCurUnitRange, (oUnit[M28UnitInfo.refiAntiNavyRange] or 0)) end
                                                        iCurDistToEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEngineer:GetPosition())
                                                        if iCurDistToEnemy < iNearestEnemy then
                                                            iNearestEnemy = iCurDistToEnemy
                                                            oNearestEnemy = oUnit
                                                        end
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurUnitRange='..iCurUnitRange..'; iCurDistToEnemy='..iCurDistToEnemy..'; Is reclaimable='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryReclaimable, oUnit.UnitId))) end
                                                        if iCurDistToEnemy < iNearestReclaimableDangerousEnemy and EntityCategoryContains(M28UnitInfo.refCategoryReclaimable, oUnit.UnitId) then
                                                            if oUnit[M28UnitInfo.refiCombatRange] > 0 or EntityCategoryContains(categories.RECLAIM, oUnit.UnitId) then
                                                                --Dangerous enemy
                                                                iNearestReclaimableDangerousEnemy = iCurDistToEnemy
                                                                oNearestReclaimableDangerousEnemy = oUnit
                                                            end
                                                            if iCurDistToEnemy < iNearestReclaimableEnemy then
                                                                iNearestReclaimableEnemy = iCurDistToEnemy
                                                                oNearestReclaimableEnemy = oUnit
                                                            end
                                                        end
                                                        --Ignore land scouts and similar unthreatening units
                                                        if iCurUnitRange > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) then
                                                            iCurDistUntilInRange = iCurDistToEnemy - iCurUnitRange
                                                            if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then
                                                                if iCurDistUntilInRange < iClosestDistUntilInRangeOfMobileEnemy then iClosestDistUntilInRangeOfMobileEnemy = iCurDistUntilInRange end
                                                            else
                                                                if iCurDistUntilInRange < iClosestDistUntilInRangeOfStaticEnemy then iClosestDistUntilInRangeOfStaticEnemy = iCurDistUntilInRange end
                                                            end
                                                        end
                                                    end
                                                end
                                            else
                                                if bDebugMessages == true then LOG(sFunctionRef..': Unit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' is dead or is being built (cant reclaim under construction units), is table of g etguards empty='..tostring(M28Utilities.IsTableEmpty(oUnit:GetGuards()))) end
                                            end
                                        end
                                        --end
                                    end
                                    --Consider reclaiming wall segment instead
                                    if bDebugMessages == true then LOG(sFunctionRef..': bCheckForWallsToReclaim='..tostring(bCheckForWallsToReclaim or false)..'; iNearestReclaimableEnemy='..(iNearestReclaimableEnemy or 'nil')..'; iClosestDistUntilInRangeOfStaticEnemy='..(iClosestDistUntilInRangeOfStaticEnemy or 'nil')..'; iClosestDistUntilInRangeOfMobileEnemy='..(iClosestDistUntilInRangeOfMobileEnemy or 'nil')) end
                                    if bCheckForWallsToReclaim and (iNearestReclaimableEnemy or 100) >= 10 and (iClosestDistUntilInRangeOfStaticEnemy or 100) >= 8 and (iClosestDistUntilInRangeOfMobileEnemy or 100) >= 10 then
                                        local iEngiIndex = oEngineer:GetAIBrain():GetArmyIndex()
                                        for iUnit, oUnit in tLZData[M28Map.subrefLZPlayerWallSegments] do
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering wall '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; Dist to engi='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEngineer:GetPosition())..'; Is enemy='..tostring(IsEnemy(iEngiIndex, oUnit:GetAIBrain():GetArmyIndex()))) end
                                            if M28UnitInfo.IsUnitValid(oUnit) and IsEnemy(iEngiIndex, oUnit:GetAIBrain():GetArmyIndex()) then
                                                iCurDistToEnemy = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEngineer:GetPosition())
                                                if iCurDistToEnemy < (iNearestReclaimableEnemy or 10000) then
                                                    iNearestReclaimableEnemy = iCurDistToEnemy
                                                    oNearestReclaimableEnemy = oUnit
                                                end
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Checking for nearby enemies for engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; iNearestReclaimableEnemy='..iNearestReclaimableEnemy..'; iClosestDistUntilInRangeOfStaticEnemy='..iClosestDistUntilInRangeOfStaticEnemy..'; Core base='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase] or false)..'; Core expansion='..tostring(tLZTeamData[M28Map.subrefLZCoreExpansion] or false)) end
                                    local iEngiBuildDistance = oEngineer:GetBlueprint().Economy.MaxBuildDistance
                                    if iNearestReclaimableEnemy < 20 and ((iClosestDistUntilInRangeOfStaticEnemy >= 10 and iNearestReclaimableEnemy <= iEngiBuildDistance) or iNearestReclaimableEnemy <= (iEngiBuildDistance + 7) or (iNearestReclaimableEnemy <= iEngiBuildDistance + 14 and (tLZTeamData[M28Map.subrefLZbCoreBase] or tLZTeamData[M28Map.subrefLZCoreExpansion]))) then
                                        --Reclaim enemy
                                        --Switch the target to the nearest dangerous enemy if it is in our build range
                                        if iNearestReclaimableDangerousEnemy < iEngiBuildDistance and oNearestReclaimableDangerousEnemy then
                                            oNearestReclaimableEnemy = oNearestReclaimableDangerousEnemy
                                        end
                                        bEngiIsUnavailable = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will reclaim or capture unit, is capture target='..tostring(oNearestReclaimableEnemy[M28UnitInfo.refbIsCaptureTarget])..'; Is oNearestReclaimableEnemy valid='..tostring(M28UnitInfo.IsUnitValid(oNearestReclaimableEnemy))) end
                                        if oNearestReclaimableEnemy[M28UnitInfo.refbIsCaptureTarget] then
                                            TrackEngineerAction(oEngineer, refActionCaptureUnit, false, 1)
                                            --Dont capture if already capturing (redundancy)
                                            if not(oEngineer:IsUnitState('Capturing')) then
                                                M28Orders.IssueTrackedCapture(oEngineer, oNearestReclaimableEnemy, false, 'CapE')
                                                if bDebugMessages == true then LOG(sFunctionRef..': Told engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to capture enemy unit') end
                                            end
                                        else
                                            TrackEngineerAction(oEngineer, refActionReclaimEnemyUnit, false, 1)
                                            M28Orders.IssueTrackedReclaim(oEngineer, oNearestReclaimableEnemy, false, 'RecE')
                                            if bDebugMessages == true then LOG(sFunctionRef..': Told engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to reclaim enemy unit '..oNearestReclaimableEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestReclaimableEnemy)..'; Is getguards empty='..tostring(M28Utilities.IsTableEmpty(oNearestReclaimableEnemy:GetGuards()))..'; Unit:IsBeingBuilt()='..tostring(oNearestReclaimableEnemy:IsBeingBuilt())) end
                                            --Monitor every tick for the next 9 ticks to see if enemy gets in-range
                                            local oEnemyBP = oNearestReclaimableEnemy:GetBlueprint()
                                            local iDistanceUntilInRange = iEngiBuildDistance + math.min(oEnemyBP.Physics.SkirtSizeX, oEnemyBP.Physics.SkirtSizeZ) * 0.5
                                            if bDebugMessages == true then LOG(sFunctionRef..': Checking if we want to monitor reclaim distance, iDistanceUntilInRange='..iDistanceUntilInRange..'; iNearestReclaimableEnemy='..iNearestReclaimableEnemy..'; Speed of us and them='..(oEnemyBP.Physics.MaxSpeed or 0) + oEngineer:GetBlueprint().Physics.MaxSpeed) end
                                            if iNearestReclaimableEnemy > iDistanceUntilInRange and iNearestReclaimableEnemy - iDistanceUntilInRange <= (oEnemyBP.Physics.MaxSpeed or 0) + oEngineer:GetBlueprint().Physics.MaxSpeed + 0.2 then
                                                ForkThread(MonitorToReissueReclaimOrder, oEngineer, oNearestReclaimableEnemy, iDistanceUntilInRange, 9)
                                            end
                                        end
                                    else
                                        --Enemy not close enough to reclaim, do we want to run?
                                        if not(tLZTeamData[M28Map.subrefLZbCoreBase]) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Not close enough to reclaim enemy, and not a core LZ, iClosestDistUntilInRangeOfStaticEnemy='..iClosestDistUntilInRangeOfStaticEnemy..'; iClosestDistUntilInRangeOfMobileEnemy='..iClosestDistUntilInRangeOfMobileEnemy..'; iThresholdToRunFromMobileEnemies='..iThresholdToRunFromMobileEnemies) end
                                            if iClosestDistUntilInRangeOfStaticEnemy < 8 or iClosestDistUntilInRangeOfMobileEnemy <= iThresholdToRunFromMobileEnemies then
                                                --Dont run if we are building a land factory and have a friendly combat threat in the zone or factory is near-complete
                                                if tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= 40 and (oEngineer:IsUnitState('Building') or oEngineer:IsUnitState('Reclaiming')) and (oEngineer:GetWorkProgress() >= 0.75 or (oEngineer[M28Orders.reftiLastOrders][1][M28Orders.subrefsOrderBlueprint] and EntityCategoryContains(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryPD, oEngineer[M28Orders.reftiLastOrders][1][M28Orders.subrefsOrderBlueprint]))) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to risk engineer sticking around to try and complete its building') end
                                                else
                                                    local tPositionToRunFrom
                                                    if oNearestEnemy then tPositionToRunFrom = oNearestEnemy:GetPosition() end
                                                    if not(bIsWaterZone) then
                                                        iLZOrWZToRunTo =  M28Land.GetLandZoneToRunTo(iTeam, iPlateauOrPond, iLandZone, M28Map.refPathingTypeHover, oEngineer:GetPosition(), tPositionToRunFrom)
                                                        if not(iLZOrWZToRunTo == iLandZone) and iLZOrWZToRunTo then --If LZ to run to is same as cur LZ might as well use engineer normally (e.g. might have defences to build)
                                                            --Run to the LZ
                                                            M28Orders.IssueTrackedMove(oEngineer, M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLZOrWZToRunTo][M28Map.subrefMidpoint], 8, false, 'RunTo'..iLZOrWZToRunTo)
                                                            bEngiIsUnavailable = true
                                                            TrackEngineerAction(oEngineer, refActionRunToLandZone, false, 1, {iPlateauOrPond, iLZOrWZToRunTo})
                                                        end
                                                    else
                                                        iLZOrWZToRunTo = M28Navy.GetWaterZoneToRunTo(iTeam, iPlateauOrPond, iLandZone, M28Map.refPathingTypeHover, oEngineer:GetPosition(), tPositionToRunFrom)
                                                        if not(iLZOrWZToRunTo == iLandZone) then --If LZ to run to is same as cur LZ might as well use engineer normally (e.g. might have defences to build)
                                                            --Run to the LZ
                                                            M28Orders.IssueTrackedMove(oEngineer, M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iLZOrWZToRunTo][M28Map.subrefMidpoint], 8, false, 'NRunTo'..iLZOrWZToRunTo)
                                                            bEngiIsUnavailable = true
                                                            TrackEngineerAction(oEngineer, refActionRunToWaterZone, false, 1, nil, iLZOrWZToRunTo)
                                                        else
                                                            --Consider moving to land zone instead if there is an adjacent LZ
                                                            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentLandZones]) == false then
                                                                local tClosestRallyPoint
                                                                local iClosestRallyPointDist = 100000
                                                                local iCurRallyPointDist
                                                                for iEntry, tLZSubtable in tLZData[M28Map.subrefAdjacentLandZones] do
                                                                    local tCurRallyPoint = M28Land.GetNearestLandRallyPoint(tLZData, iTeam, tLZSubtable[M28Map.subrefWPlatAndLZNumber][1], tLZSubtable[M28Map.subrefWPlatAndLZNumber][2], nil)
                                                                    if tCurRallyPoint then
                                                                        iCurRallyPointDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tCurRallyPoint)
                                                                        if iCurRallyPointDist < iClosestRallyPointDist then
                                                                            tClosestRallyPoint = {tCurRallyPoint[1], tCurRallyPoint[2], tCurRallyPoint[3]}
                                                                            iClosestRallyPointDist = iCurRallyPointDist
                                                                        end
                                                                    end
                                                                end
                                                                if tClosestRallyPoint then
                                                                    local iPlateau, iLZToRunTo = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tClosestRallyPoint)
                                                                    M28Orders.IssueTrackedMove(oEngineer, (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZToRunTo][M28Map.subrefMidpoint] or tClosestRallyPoint), 8, false, 'WLRunTo'..iLZOrWZToRunTo)
                                                                    bEngiIsUnavailable = true
                                                                    TrackEngineerAction(oEngineer, refActionRunToLandZone, false, 1, {iPlateau, iLZToRunTo})
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            else
                                                --We arent yet close enough that we want to run so do nothing
                                            end
                                        end
                                    end
                                end
                            end
                        else
                            if not(bReclaimingDangerousEnemy) then
                                bConsiderReclaimableEnemiesInBuildRangeOnly = true
                            end
                        end
                    else
                        --Check we arent reclaiming dangerous enemy
                        if oEngineer:IsUnitState('Reclaiming') then
                            local oReclaimTarget = oEngineer:GetFocusUnit()
                            if oReclaimTarget and not(oReclaimTarget.Dead) and ((oReclaimTarget[M28UnitInfo.refiCombatRange] or 0) > 0 or EntityCategoryContains(categories.RECLAIM, oReclaimTarget.UnitId)) then
                                bReclaimingDangerousEnemy = true
                            end
                        end
                        if not(bReclaimingDangerousEnemy) then
                            bConsiderReclaimableEnemiesInBuildRangeOnly = true
                        end
                    end
                end
                if bConsiderReclaimableEnemiesInBuildRangeOnly then
                    --We are doing a high priority action, so only consider reclaimable enemies that are in our build range
                    if bDebugMessages == true then LOG(sFunctionRef..': Engineer doing high priority action so will only consider enemies in build range unless close to completion, work progress='..oEngineer:GetWorkProgress()..'; Is primary builder='..tostring(oEngineer[refbPrimaryBuilder])) end
                    if not(oEngineer:GetWorkProgress() >= 0.9) and (not(oEngineer[refbPrimaryBuilder]) or oEngineer:GetWorkProgress() <= 0.6) then
                        local iEngiBuildDistance = oEngineer:GetBlueprint().Economy.MaxBuildDistance
                        if oEngineer[M28UnitInfo.refbEasyBrain] then
                            iActualEnemyCategorySearch = iEasyEnemyCategorySearch
                        else
                            iActualEnemyCategorySearch = iNormalEnemyCategorySearch
                        end
                        local tReclaimableEnemies = aiBrain:GetUnitsAroundPoint(iActualEnemyCategorySearch, oEngineer:GetPosition(), iEngiBuildDistance, 'Enemy')
                        local oEnemyCombatOrReclaimer
                        local oOtherEnemy
                        if M28Utilities.IsTableEmpty(tReclaimableEnemies) == false then
                            for iEnemy, oEnemy in tReclaimableEnemies do
                                if (oEnemy[M28UnitInfo.refiCombatRange] or 0) > 0 or EntityCategoryContains(categories.RECLAIM, oEnemy.UnitId) then
                                    oEnemyCombatOrReclaimer = oEnemy
                                    break
                                elseif not(oOtherEnemy) then oOtherEnemy = oEnemy
                                end
                            end
                        end
                        local oReclaimTarget = oEnemyCombatOrReclaimer or oOtherEnemy
                        if oReclaimTarget then
                            TrackEngineerAction(oEngineer, refActionReclaimEnemyUnit, false, 1)
                            M28Orders.IssueTrackedReclaim(oEngineer, oReclaimTarget, false, 'RecPE')
                            if bDebugMessages == true then LOG(sFunctionRef..': Told engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to reclaim enemy that is in its range, enemy='..oReclaimTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oReclaimTarget)) end
                            bEngiIsUnavailable = true
                        end
                    end
                end
            else
                bEngiIsUnavailable = true
            end


            --Finished checking for enemies; now check more generally if engineer is busy
            if bDebugMessages == true then LOG(sFunctionRef..': Is engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' unavailable='..tostring(bEngiIsUnavailable)) end
            if not(bEngiIsUnavailable) then
                bEngiIsUnavailable = not(M28Conditions.IsEngineerAvailable(oEngineer))

                if bDebugMessages == true then LOG(sFunctionRef..': Entry in table='..iEngineer..'; Considering if engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' is available, result='..tostring(M28Conditions.IsEngineerAvailable(oEngineer, true) or false)..'; Eng unit state='..M28UnitInfo.GetUnitState(oEngineer)..'; bEngiIsUnavailable='..tostring(bEngiIsUnavailable or false)..'; oEngineer[refiPlateauAndZoneTravelingBeforeTempReclaimOrder] ='..repru(oEngineer[refiPlateauAndZoneTravelingBeforeTempReclaimOrder] )) end
                if oEngineer[refiPlateauAndZoneTravelingBeforeTempReclaimOrder] and not(oEngineer[refiAssignedAction] == refActionMoveToLandZone) and not(oEngineer:IsUnitState('Reclaiming')) then
                    local iTargetPlateau = oEngineer[refiPlateauAndZoneTravelingBeforeTempReclaimOrder][1]
                    local iTargetZone = oEngineer[refiPlateauAndZoneTravelingBeforeTempReclaimOrder][2]

                    oEngineer[refiPlateauAndZoneTravelingBeforeTempReclaimOrder] = nil

                    local tTargetZoneData = M28Map.tAllPlateaus[iTargetPlateau][M28Map.subrefPlateauLandZones][iTargetZone]

                    if bDebugMessages == true then
                        if not(tTargetZoneData[M28Map.subrefMidpoint]) then LOG(sFunctionRef..': Dont have valid midpoint data for target P='..iTargetPlateau..';Z='..iTargetZone)
                        else
                            LOG(sFunctionRef..': Considering if engi is closer to the target sone P'..iTargetPlateau..'Z'..iTargetZone..' zone it used to be traveling to than this midpoint, dist from engi to prev zone midpoint='..M28Utilities.GetDistanceBetweenPositions(tTargetZoneData[M28Map.subrefMidpoint], oEngineer:GetPosition())..'; Dist from this zone midpoint='..M28Utilities.GetDistanceBetweenPositions(tTargetZoneData[M28Map.subrefMidpoint], tLZData[M28Map.subrefMidpoint]))
                        end
                    end
                    if tTargetZoneData and M28Utilities.GetDistanceBetweenPositions(tTargetZoneData[M28Map.subrefMidpoint], oEngineer:GetPosition()) <= M28Utilities.GetDistanceBetweenPositions(tTargetZoneData[M28Map.subrefMidpoint], tLZData[M28Map.subrefMidpoint]) then

                        M28Orders.IssueTrackedMove(oEngineer, tTargetZoneData[M28Map.subrefMidpoint], 3, false, 'ResumeeMTP'..iTargetPlateau..'Z'..iTargetZone)
                        TrackEngineerAction(oEngineer, refActionMoveToLandZone, false, 1, { iTargetPlateau, iTargetZone })
                        bEngiIsUnavailable = true
                        if bDebugMessages == true then LOG(sFunctionRef..': will send engi '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to this zone, oEngineer[M28Land.reftiPlateauAndLZToMoveTo]='..repru(oEngineer[M28Land.reftiPlateauAndLZToMoveTo])) end
                    end
                elseif bCheckForReclaim then
                    if not(bEngiIsUnavailable) then
                        if M28ACU.ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrPond, iLandZone, tLZData, tLZTeamData, oEngineer, true, 20) then
                            bEngiIsUnavailable = true
                        end
                    elseif oEngineer:IsUnitState('Moving') and oEngineer[refiAssignedAction] == refActionMoveToLandZone then
                        --Engineer is already busy; exception if engineer is traveling to another zone where want to reissue its old order after issuing a reclaim order
                        local iTargetPlateau = oEngineer[M28Land.reftiPlateauAndLZToMoveTo][1]
                        local iTargetZone = oEngineer[M28Land.reftiPlateauAndLZToMoveTo][2]

                        if M28ACU.ConsiderNearbyReclaimForACUOrEngineer(iPlateauOrPond, iLandZone, tLZData, tLZTeamData, oEngineer, true, 50) then
                            if iTargetPlateau and iTargetZone then

                                if bDebugMessages == true then LOG(sFunctionRef..': Recording plateau and LZ that engi was going to move to but has been diverted from, iTargetPlateau='..(iTargetPlateau or 'nil')..'; iTargetZone='..(iTargetZone or 'nil')) end
                                bEngiIsUnavailable = true
                                oEngineer[refiPlateauAndZoneTravelingBeforeTempReclaimOrder] = {iTargetPlateau, iTargetZone}
                            elseif bDebugMessages == true then LOG(sFunctionRef..': engi '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; had an action to move to a land zone but didnt have a target plateau or zone recorded (maybe it ran from enemy units?), so it wont resume its orders later')
                            end
                        end
                    end
                end
            end
            if bEngiIsUnavailable then
                table.insert(toAssignedEngineers, oEngineer)
            else
                --Clear engineer trackers as redundancy in case failed to clear previously
                if oEngineer[refiAssignedAction] then ClearEngineerTracking(oEngineer) end

                table.insert(toAvailableEngineersByTech[M28UnitInfo.GetUnitTechLevel(oEngineer)], oEngineer)
                if bDebugMessages == true then LOG(sFunctionRef..': Just added engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to toAvailableEngineersByTech, Eng tech level='..M28UnitInfo.GetUnitTechLevel(oEngineer)..'; Size of table='..table.getn(toAvailableEngineersByTech[M28UnitInfo.GetUnitTechLevel(oEngineer)])) end
                bHaveAvailableEngi = true
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished recording available engineers, Is tEngineers empty='..tostring(M28Utilities.IsTableEmpty(tEngineers))..'; bHaveAvailableEngi='..tostring(bHaveAvailableEngi)..'; Is toAssignedEngineers empty='..tostring(M28Utilities.IsTableEmpty(toAssignedEngineers))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bHaveAvailableEngi then return toAvailableEngineersByTech, toAssignedEngineers
    else return nil, toAssignedEngineers
    end
end

function GetCategoryToBuildOrAssistFromAction(iActionToAssign, iMinTechLevel, aiBrain, tbEngineersOfFactionOrNilIfAlreadyAssigned, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iLandOrWaterZone)
    --Returns the building category type based on the action; iMinTechLevel is optional; aiBrain is required if dealing with construction of experimental
    --tbEngineersOfFaction is true for each faction that we have an engineer of iMinTechLevel available for, but is nil if we don't need to worry about factions, either due to category or because the unit/building is under construciton already

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetCategoryToBuildOrAssistFromAction'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iCategoryToBuild = tiActionCategory[iActionToAssign]
    local iOptionalFactionRequired --Used for certain categories where chocie of category depended on the faction available
    if bDebugMessages == true then LOG(sFunctionRef..': Time of start='..GetGameTimeSeconds()..'; iActionToAssign='..iActionToAssign..'; iMinTechLevel='..iMinTechLevel..'; aiBrain='..aiBrain.Nickname..'; repru(tbEngineersOfFactionOrNilIfAlreadyAssigned)='..repru(tbEngineersOfFactionOrNilIfAlreadyAssigned)..'; Is tbActionsThatDontHaveCategory[iActionToAssign] nil='..tostring(tbActionsThatDontHaveCategory[iActionToAssign] == nil)..'; Is tiActionCategory[iActionToAssign] nil='..tostring(tiActionCategory[iActionToAssign] == nil)) end
    --Manual adjustments to default category
    if iActionToAssign == refActionBuildGameEnder then
        if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] >= 750 then
            iCategoryToBuild = iCategoryToBuild - M28UnitInfo.refCategoryParagon
        elseif M28Conditions.GetTeamLifetimeBuildCount(aiBrain.M28Team, M28UnitInfo.refCategoryParagon) > 0 then
            local iParagonUnderConstruction = M28Conditions.GetNumberOfUnderConstructionUnitsOfCategoryInOtherZones(tLZOrWZTeamData, aiBrain.M28Team, M28UnitInfo.refCategoryParagon)
            if iParagonUnderConstruction > 0 then
                iCategoryToBuild = iCategoryToBuild - M28UnitInfo.refCategoryParagon
            end
        end
        if M28Conditions.HaveTemplateSpaceForGameEnder(iCategoryToBuild, tLZOrWZData, tLZOrWZTeamData, tbEngineersOfFactionOrNilIfAlreadyAssigned, aiBrain.M28Team) and not(aiBrain.M28Easy) then
            tLZOrWZTeamData[M28Map.refiLastGameEnderTemplateCategory] = iCategoryToBuild
            iCategoryToBuild = refActionManageGameEnderTemplate
        end
    end
    if not(iCategoryToBuild) and not(tbActionsThatDontHaveCategory[iActionToAssign]) then
        if iActionToAssign == refActionBuildEmergencyPD then
            if aiBrain[M28Overseer.refbCloseToUnitCap] then
                if bDebugMessages == true then LOG(sFunctionRef..': Close to unit cap so will get T2PlusPD') end
                iCategoryToBuild = M28UnitInfo.refCategoryT2PlusPD
            else
                if iMinTechLevel == 1 then
                    iCategoryToBuild = M28UnitInfo.refCategoryPD - categories.TECH3 - categories.EXPERIMENTAL
                elseif iMinTechLevel > 1 or (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 and (aiBrain[M28Economy.refiGrossMassBaseIncome] >= 4 or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPD * categories.TECH1) > 0)) then
                    --Want to build either T2 or T2+ PD
                    local iT2PD = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPD * categories.TECH2)
                    if iT2PD <= 5 or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPD * categories.TECH3) >= iT2PD then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have 5 or fewer t2 pd so will get more t2 pd') end
                        iCategoryToBuild = M28UnitInfo.refCategoryPD - categories.TECH3 - categories.EXPERIMENTAL
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Have at least 5 T2 PD so will get T2PlusPD') end
                        iCategoryToBuild = M28UnitInfo.refCategoryT2PlusPD
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Have no T1 PD so will get T1 PD') end
                    iCategoryToBuild = M28UnitInfo.refCategoryPD * categories.TECH1
                end
            end
        elseif iActionToAssign == refActionFortifyFirebase then
            M28Utilities.ErrorHandler('Firebase logic not in place')
            --Calculate closest firebase and assume we are trying to build this
            if aiBrain[refiFirebaseBeingFortified] then
                iCategoryToBuild = aiBrain[refiFirebaseCategoryWanted][aiBrain[refiFirebaseBeingFortified]]
                if M28Utilities.IsTableEmpty(iCategoryToBuild, false) then M28Utilities.ErrorHandler('Dont have a category to build for firebase ref '..(aiBrain[refiFirebaseBeingFortified] or 'nil')..'; will just build T2 plus PD')
                    iCategoryToBuild = M28UnitInfo.refCategoryT2PlusPD
                end
            else
                M28Utilities.ErrorHandler('Dont have a firebase to be fortified so will just build T2 plus PD')
                iCategoryToBuild = M28UnitInfo.refCategoryT2PlusPD
            end
        elseif iActionToAssign == refActionBuildExperimental or iActionToAssign == refActionBuildSecondExperimental then
            iCategoryToBuild, iOptionalFactionRequired = DecideOnExperimentalToBuild(iActionToAssign, aiBrain, tbEngineersOfFactionOrNilIfAlreadyAssigned, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iLandOrWaterZone)
        elseif iActionToAssign == refActionBuildShield or iActionToAssign == refActionBuildSecondShield then
            --NOTE: Separately this gets changed to tech3 if need increased range
            if bDebugMessages == true then LOG(sFunctionRef..': Considering building shield, iMinTechLevel='..iMinTechLevel..'; M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyT3ArtiCount]='..M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyT3ArtiCount]..'; Novax count='..M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyNovaxCount]..'; Enemy air to ground='..M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyAirToGroundThreat]..'; SValue='..tLZOrWZTeamData[M28Map.subrefLZSValue]..'; Core base='..tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase])) end

            if M28Map.bIsCampaignMap then iCategoryToBuild = M28UnitInfo.refCategoryFixedShield
            elseif iMinTechLevel == 2 and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false and (not(M28Team.tTeamData[aiBrain.M28Team][M28Team.refbDefendAgainstArti]) or (M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyT3ArtiCount] == 0 and M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyNovaxCount] <= 2)) and not(aiBrain[M28Overseer.refbCloseToUnitCap]) then
                iCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.TECH2
                if bDebugMessages == true then LOG(sFunctionRef..': Will build T2 shield') end
            elseif iMinTechLevel >= 3 or (M28Team.tTeamData[aiBrain.M28Team][M28Team.refbDefendAgainstArti] and (M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyT3ArtiCount] > 0 or M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyNovaxCount] > 2)) or aiBrain[M28Overseer.refbCloseToUnitCap] or (M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyAirToGroundThreat] >= 12000 and (tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or tLZOrWZTeamData[M28Map.subrefLZSValue] >= 8000)) then
                iCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.TECH3
                if bDebugMessages == true then LOG(sFunctionRef..': Only want T3 shields') end
            else
                iCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.TECH2
                if bDebugMessages == true then LOG(sFunctionRef..': Will build T2 shield') end
            end
        else
            M28Utilities.ErrorHandler('Need to add code for action='..(iActionToAssign or 'nil'))
        end
    end
    if iCategoryToBuild and not(iCategoryToBuild == refActionManageGameEnderTemplate) then
        --Power specific - only build at the minimum tech level, presume this is so if we want to build T1/T2 power while having access to T3 (due to very low power) we can; will therefore add adjustment when looking for part-build buildings to counter this
        if iActionToAssign == refActionBuildPower then
            --Only restrict the power we will build if we have no unit restrictions and/or arent in a campaign
            if not(M28Overseer.bUnitRestrictionsArePresent or M28Map.bIsCampaignMap) then
                iCategoryToBuild = iCategoryToBuild * M28UnitInfo.ConvertTechLevelToCategory(iMinTechLevel)
            end
        else
            if iMinTechLevel > 1 then
                if iMinTechLevel == 3 then iCategoryToBuild = iCategoryToBuild * categories.TECH3 + iCategoryToBuild*categories.EXPERIMENTAL
                else iCategoryToBuild = iCategoryToBuild - categories.TECH1
                end
            end
        end
        --Unit cap - dont build T1 if near cap, and only build experimentals if very near cap
        if aiBrain[M28Overseer.refbCloseToUnitCap] then
            if bDebugMessages == true then LOG(sFunctionRef..': Are close to unit cap, wont build T1 units, does category to build contain only T1 and not HQ or mex='..tostring(M28Utilities.DoesCategoryContainCategory(categories.TECH1, iCategoryToBuild, true))..'; Does it contain HQ or T3 or experimental='..tostring(M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryAllHQFactories + categories.TECH3 + categories.EXPERIMENTAL + M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryPower * categories.TECH2, iCategoryToBuild))) end
            if M28Utilities.DoesCategoryContainCategory(categories.TECH1  - M28UnitInfo.refCategoryAirStaging - M28UnitInfo.refCategoryT1Mex, iCategoryToBuild, true) and not(M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryAllHQFactories + categories.TECH3 + categories.EXPERIMENTAL + M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryPower * categories.TECH2, iCategoryToBuild)) then
                iCategoryToBuild = nil
            elseif aiBrain[M28Overseer.refiExpectedRemainingCap] < 15 then
                if not(M28Utilities.DoesCategoryContainCategory(categories.TECH3 + categories.EXPERIMENTAL + M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryPower * categories.TECH2, iCategoryToBuild)) then
                    iCategoryToBuild = nil
                end
            elseif (M28Team.tTeamData[aiBrain.M28Team][M28Team.refiLowestUnitCapAdjustmentLevel] or 0) <= 1 and aiBrain:GetCurrentUnits(iCategoryToBuild) >= 100 then
                if M28Utilities.DoesCategoryContainCategory(categories.TECH3 + categories.EXPERIMENTAL + M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryPower * categories.TECH2, iCategoryToBuild) and aiBrain:GetCurrentUnits(iCategoryToBuild) > 150 then
                    --Do nothing
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Have lots of the target category to build so wont build any more') end
                    iCategoryToBuild = nil
                end

            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is iCategoryToBuild nil after unit cap adjustment='..tostring(iCategoryToBuild == nil)) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iCategoryToBuild, iOptionalFactionRequired
end

function GetEngineersOfTechWanted(iMinTechLevelWanted, toAvailableEngineersByTech)
    local tEngineersOfTechWanted
    if iMinTechLevelWanted == 3 then
        tEngineersOfTechWanted = toAvailableEngineersByTech[3]
    else
        tEngineersOfTechWanted = {}
        if iMinTechLevelWanted == 2 then
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[2]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[2] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[3]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[3] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
        else
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[1]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[1] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[2]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[2] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[3]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[3] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
        end
    end
    return tEngineersOfTechWanted
end

function GetPartCompleteBuildingInZone(iTeam, iPlateauOrPond, iLandOrWaterZone, iCategoryWanted, bIsWaterZone, iConstructionCountToIgnore)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPartCompleteBuildingInZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iValidCount = 0

    if bDebugMessages == true then
        local tBlueprints = EntityCategoryGetUnitList(iCategoryWanted)
        LOG(sFunctionRef..': Start of code at game time seconds='..GetGameTimeSeconds()..', will list out every blueprint of iCategoryWanted='..reprs(tBlueprints)..'; iPlateauOrPond='..iPlateauOrPond)
    end
    local tLZOrWZTeamData
    local sAlliedUnitRef
    if bIsWaterZone then
        tLZOrWZTeamData = M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
        sAlliedUnitRef = M28Map.subreftoLZOrWZAlliedUnits
    else
        tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
        sAlliedUnitRef = M28Map.subreftoLZOrWZAlliedUnits
    end
    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[sAlliedUnitRef]) == false then
        local tBuildingsOfCategory = EntityCategoryFilterDown(iCategoryWanted, tLZOrWZTeamData[sAlliedUnitRef])
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of buildings of category empty='..tostring(M28Utilities.IsTableEmpty(tBuildingsOfCategory))) end
        if M28Utilities.IsTableEmpty(tBuildingsOfCategory) == false then
            for iUnit, oUnit in tBuildingsOfCategory do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fractino compelte='..oUnit:GetFractionComplete()..'; oUnit[refbDontIncludeAsPartCompleteBuildingForConstruction]='..tostring(oUnit[refbDontIncludeAsPartCompleteBuildingForConstruction] or false)) end
                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() < 1 and not(oUnit[M28Building.refoGameEnderBeingShielded]) and not(oUnit[refbDontIncludeAsPartCompleteBuildingForConstruction]) then
                    --If upgrading a factory then assist this unless we have high mass and dont have low power
                    if not(oUnit:IsUnitState('BeingUpgraded')) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.2 or M28Conditions.HaveLowPower(iTeam) or (table.getn(tBuildingsOfCategory) >= 4 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 or iCategoryWanted == M28UnitInfo.refCategoryLandFactory)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Found a part complete building '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()..', will return this') end
                        if (iConstructionCountToIgnore or 0) <= iValidCount then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return oUnit
                        else
                            iValidCount = iValidCount + 1
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return nil
end

function RemoveBuildingFromQueuedBuildings(oEngineer, oBuilding)
    --Intended to be called when oEngineer starts building oBuilding
    if M28Utilities.IsTableEmpty(oEngineer[reftQueuedBuildings]) == false then
        for iEntry, tOrderDetails in oEngineer[reftQueuedBuildings] do
            if tOrderDetails[subrefBuildingID] == oBuilding.UnitId and math.abs(oBuilding:GetPosition()[1] - tOrderDetails[subrefBuildingLocation][1]) < 0.5 and math.abs(oBuilding:GetPosition()[3] - tOrderDetails[subrefBuildingLocation][3]) < 0.5 then
                local tLZOrWZTeamData, tLZOrWZData
                if tOrderDetails[subrefPlateauOrZero] == 0 then
                    tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[tOrderDetails[subrefLandOrWaterZone]]][M28Map.subrefPondWaterZones][tOrderDetails[subrefLandOrWaterZone]]
                    tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][oEngineer:GetAIBrain().M28Team]
                else
                    --Dealing with land zone
                    tLZOrWZData = M28Map.tAllPlateaus[tOrderDetails[subrefPlateauOrZero]][M28Map.subrefPlateauLandZones][tOrderDetails[subrefLandOrWaterZone]]
                    tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
                end
                ChangeQueuedLocationsTracker(tOrderDetails[subrefBuildingLocation], tLZOrWZData, tOrderDetails[subrefBuildingRadius], false)
                if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefQueuedBuildings]) == false then
                    for iLZEntry, tLZOrWZOrderDetails in tLZOrWZTeamData[M28Map.subrefQueuedBuildings] do
                        if tLZOrWZOrderDetails[M28Map.subrefQueueRef] == tOrderDetails[subrefQueueRef] then
                            table.remove(tLZOrWZTeamData[M28Map.subrefQueuedBuildings], iLZEntry)
                            break
                        end
                    end
                end

                table.remove(oEngineer[reftQueuedBuildings], iEntry)
                break
            end

        end
    end
end

function RefreshPartBuiltMexList(tLZOrWZTeamData)
    local iRevisedIndex = 1
    local iTableSize = table.getn(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes])

    for iOrigIndex=1, iTableSize do
        if M28UnitInfo.IsUnitValid(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes][iOrigIndex]) and tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes][iOrigIndex]:GetFractionComplete() < 1 then
            --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
            if (iOrigIndex ~= iRevisedIndex) then
                tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes][iRevisedIndex] = tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes][iOrigIndex];
                tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes][iOrigIndex] = nil;
            end
            iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
        else
            tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes][iOrigIndex] = nil;
        end
    end
    if iRevisedIndex < iTableSize then
        --table.setn(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes], iRevisedIndex - 1)
        for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
            table.remove(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes], iRemovalEntry)
        end
    end
end

function UpdatePartBuiltListForCompletedMex(oMex)
    if oMex:GetAIBrain().M28AI and oMex:GetFractionComplete() == 1 then
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oMex:GetPosition())
        if iLandZone > 0 then
            RefreshPartBuiltMexList(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oMex:GetAIBrain().M28Team])
        end

    end
end


function RecordPartBuiltMex(oEngineer, oMex)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordPartBuiltMex'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oMex:GetPosition())
    local iWaterZone, iPond
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just started building oMex='..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
    if (iLandZone or 0) == 0 then
        iWaterZone = M28Map.GetWaterZoneFromPosition(oMex:GetPosition())
        iPond = M28Map.tiPondByWaterZone[iWaterZone]
    end
    if iLandZone > 0 or (iWaterZone > 0 and iPond > 0) then
        if oMex:GetAIBrain().M28AI then
            local tLZOrWZTeamData
            if iLandZone > 0 then tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oMex:GetAIBrain().M28Team]
            else tLZOrWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][oMex:GetAIBrain().M28Team]
            end
            if not(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes]) then tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes] = {} end
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes]) then
                if not(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes]) then tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes] = {} end
                table.insert(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes], oMex)
                if bDebugMessages == true then LOG(sFunctionRef..': Added the mex to the table of part built mexes') end
            else
                local bAlreadyInTable = false
                for iUnit, oUnit in tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes] do
                    if oUnit == oMex then bAlreadyInTable = true break end
                end
                if not(bAlreadyInTable) then
                    table.insert(tLZOrWZTeamData[M28Map.subreftoPartBuiltMexes], oMex)
                    if bDebugMessages == true then LOG(sFunctionRef..': Mex not already recorded so added to the table of part built mexes') end
                end
            end
        end

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end



function ClearEngineerTracking(oEngineer)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ClearEngineerTracking'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Is paused='..tostring(oEngineer[M28UnitInfo.refbPaused] or false)..'; oEngineer[refbBuildingExperimental]='..tostring(oEngineer[refbBuildingExperimental] or false)..'; oEngineer[M28Land.reftiPlateauAndLZToMoveTo]='..repru(oEngineer[M28Land.reftiPlateauAndLZToMoveTo])..'; oEngineer[reftAssignedReclaimSegments]='..repru(oEngineer[reftAssignedReclaimSegments])..'; Is table of queued buildings empty='..tostring(M28Utilities.IsTableEmpty(oEngineer[reftQueuedBuildings]))..'; Is table of engineers assisting this empty='..tostring(M28Utilities.IsTableEmpty(oEngineer[M28UnitInfo.reftoUnitsAssistingThis]))..'; Do we have a valid unit for special shield tracking='..tostring(M28UnitInfo.IsUnitValid(oEngineer[refoUnitActivelyShielding]))..'; oEngineer[M28Building.reftArtiTemplateRefs]='..repru(oEngineer[M28Building.reftArtiTemplateRefs])) end
    --Unpause unit if it was paused (redundancy)
    if oEngineer[M28UnitInfo.refbPaused] then M28UnitInfo.PauseOrUnpauseMassUsage(oEngineer, false) end

    --Reset stuck count
    oEngineer[M28Conditions.refiEngineerStuckCheckCount] = 0

    oEngineer[refbPrimaryBuilder] = false
    oEngineer[refiAssignedActionPriority] = nil
    oEngineer[refiAssignedAction] = nil
    oEngineer[refbHasSpareAction] = nil

    --Update experimental construction tracking:
    if oEngineer[refbBuildingExperimental] then
        --As backup, also remove any dead engineers from this table
        local iRevisedIndex = 1
        local tArray = M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subreftTeamEngineersBuildingExperimentals]
        local iTableSize = table.getn(tArray)
        if bDebugMessages == true then LOG(sFunctionRef..': removing engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' from table of engis building experimentals, iTableSize='..iTableSize) end
        for iOrigIndex=1, iTableSize do
            if tArray[iOrigIndex] then
                if oEngineer ~= tArray[iOrigIndex] and M28UnitInfo.IsUnitValid(tArray[iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                    --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                    if (iOrigIndex ~= iRevisedIndex) then
                        tArray[iRevisedIndex] = tArray[iOrigIndex];
                        tArray[iOrigIndex] = nil;
                    end
                    iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                else
                    tArray[iOrigIndex] = nil;
                end
            end
        end

        if iRevisedIndex < iTableSize then
            --table.setn(tArray, iRevisedIndex - 1)
            for iRemovalEntry = iTableSize, iRevisedIndex, -1 do
                table.remove(tArray, iRemovalEntry)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': table size after removal='..table.getn(tArray)..'; iRevisedIndex='..iRevisedIndex..'; tArray[iTableSize]='..(tArray[iTableSize].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tArray[iTableSize]) or 'nil')) end

        oEngineer[refbBuildingExperimental] = nil
    end

    --Update details of engineers moving to a plateau
    if oEngineer[M28Land.reftiPlateauAndLZToMoveTo] then
        local tTargetLZTeamData = M28Map.tAllPlateaus[oEngineer[M28Land.reftiPlateauAndLZToMoveTo][1]][M28Map.subrefPlateauLandZones][oEngineer[M28Land.reftiPlateauAndLZToMoveTo][2]][M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
        if tTargetLZTeamData and M28Utilities.IsTableEmpty(tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': removing from table of engis traveling here, size of table='..table.getn(tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere])) end
            for iUnit, oUnit in tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere] do
                if oUnit == oEngineer then
                    table.remove(tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere][iUnit])
                    break
                end
            end
        end
    end
    oEngineer[M28Land.reftiPlateauAndLZToMoveTo] = nil

    --Clear reclaim assignment tracking
    if oEngineer[reftAssignedReclaimSegments] then
        if bDebugMessages == true then LOG(sFunctionRef..': Engineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; reftAssignedReclaimSegments='..repru(oEngineer[reftAssignedReclaimSegments])) end
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.tReclaimAreas[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]][M28Map.refReclaimSegmentMidpoint])
        if (iLandZone or 0) > 0 then
            local tEngiAssignedByReclaim = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team][M28Map.subrefReclaimAreaAssignmentsBySegment]
            if tEngiAssignedByReclaim and tEngiAssignedByReclaim[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]] then tEngiAssignedByReclaim[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]] = math.max(0, (tEngiAssignedByReclaim[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]] or 0) - 1) end
        elseif (iPlateau or 0) > 0 then
            local iWaterZone = M28Map.GetWaterZoneFromPosition(M28Map.tReclaimAreas[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]][M28Map.refReclaimSegmentMidpoint])
            if (iWaterZone or 0) > 0 then
                local tEngiAssignedByReclaim = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZTeamData][oEngineer:GetAIBrain().M28Team][M28Map.subrefReclaimAreaAssignmentsBySegment]
                if tEngiAssignedByReclaim and tEngiAssignedByReclaim[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]] then tEngiAssignedByReclaim[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]] = math.max(0, (tEngiAssignedByReclaim[oEngineer[reftAssignedReclaimSegments][1]][oEngineer[reftAssignedReclaimSegments][2]] or 0) - 1) end
            end
        end
        oEngineer[reftAssignedReclaimSegments] = nil
    end

    --Clear any queued building orders
    if M28Utilities.IsTableEmpty(oEngineer[reftQueuedBuildings]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': removing from table of queued buildings, size of table='..table.getn(oEngineer[reftQueuedBuildings])) end
        for iEntry, tOrderDetails in oEngineer[reftQueuedBuildings] do
            local tLZOrWZTeamData, tLZOrWZData
            if tOrderDetails[subrefPlateauOrZero] > 0 then
                tLZOrWZData = M28Map.tAllPlateaus[tOrderDetails[subrefPlateauOrZero]][M28Map.subrefPlateauLandZones][tOrderDetails[subrefLandOrWaterZone]]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
            else
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[tOrderDetails[subrefLandOrWaterZone]]][M28Map.subrefPondWaterZones][tOrderDetails[subrefLandOrWaterZone]]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][oEngineer:GetAIBrain().M28Team]
            end
            ChangeQueuedLocationsTracker(tOrderDetails[subrefBuildingLocation], tLZOrWZData, tOrderDetails[subrefBuildingRadius], false)

            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefQueuedBuildings]) == false then
                for iLZEntry, tLZOrderDetails in tLZOrWZTeamData[M28Map.subrefQueuedBuildings] do
                    if tLZOrderDetails[M28Map.subrefQueueRef] == tOrderDetails[subrefQueueRef] then
                        table.remove(tLZOrWZTeamData[M28Map.subrefQueuedBuildings], iLZEntry)
                        break
                    end
                end
            end
        end
    end
    oEngineer[reftQueuedBuildings] = nil

    --Clear assisting engineers
    if M28Utilities.IsTableEmpty(oEngineer[M28UnitInfo.reftoUnitsAssistingThis]) == false then
        local tEngineersToRemove = {}
        if bDebugMessages == true then LOG(sFunctionRef..': Will clear all engineers assisting this, number of engineers assisting='..table.getn(oEngineer[M28UnitInfo.reftoUnitsAssistingThis])) end
        for iAssistingEngineer, oAssistingEngineer in oEngineer[M28UnitInfo.reftoUnitsAssistingThis] do
            if M28UnitInfo.IsUnitValid(oAssistingEngineer) then
                table.insert(tEngineersToRemove, oAssistingEngineer)
            end
        end
        for iAssistingEngineer, oAssistingEngineer in tEngineersToRemove do
            if not(oAssistingEngineer == oEngineer) and not(oEngineer['M28TempClearing']) then
                oEngineer['M28TempClearing'] = true
                M28Orders.IssueTrackedClearCommands(oAssistingEngineer)
                oEngineer['M28TempClearing'] = nil
            end
        end
        oEngineer[M28UnitInfo.reftoUnitsAssistingThis] = nil
    end

    --Clear special shield tracking
    if oEngineer[refoUnitActivelyShielding] then
        if M28UnitInfo.IsUnitValid(oEngineer[refoUnitActivelyShielding]) then
            if M28Utilities.IsTableEmpty(oEngineer[refoUnitActivelyShielding][reftEngineersActivelyShielding]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': remvogin from special shield engineers list, size of list='..table.getn(oEngineer[refoUnitActivelyShielding][reftEngineersActivelyShielding])) end
                for iRecordedEngi, oRecordedEngi in oEngineer[refoUnitActivelyShielding][reftEngineersActivelyShielding] do
                    if oRecordedEngi == oEngineer then
                        table.remove(oEngineer[refoUnitActivelyShielding][reftEngineersActivelyShielding], iRecordedEngi)
                        break
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(oEngineer[refoUnitActivelyShielding][reftEngineersActivelyShielding]) then
            oEngineer[refoUnitActivelyShielding][reftEngineersActivelyShielding] = nil
        end
        oEngineer[refoUnitActivelyShielding] = nil

    end

    --Clear gameender tracking
    if oEngineer[M28Building.reftArtiTemplateRefs] then
        local iTemplateRef = oEngineer[M28Building.reftArtiTemplateRefs][3]
        local tLZData, tLZTeamData = M28Map.GetLandOrWaterZoneData(oEngineer:GetPosition(), true, oEngineer:GetAIBrain().M28Team)
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplateRef][M28Map.subrefGEEngineers]) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': removing from list of engineers assigned to GE Template, size of table='..table.getn(tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplateRef][M28Map.subrefGEEngineers])) end
            for iRecordedEngi, oRecordedEngi in tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplateRef][M28Map.subrefGEEngineers] do
                if oRecordedEngi == oEngineer then
                    table.remove(tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplateRef][M28Map.subrefGEEngineers], iRecordedEngi)
                    break
                end
            end
        end
        oEngineer[M28Building.reftArtiTemplateRefs] = nil
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TrackQueuedBuilding(oEngineer, sBuildingID, tBuildLocation)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TrackQueuedBuilding'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time='..GetGameTimeSeconds()..'; oEngineer='..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil')..'; sBuildingID='..(sBuildingID or 'nil')..'; tBuildLocation='..repru(tBuildLocation)..'; iCurQueueRefNumber='..iCurQueueRefNumber) end

    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tBuildLocation)

    if iPlateauOrZero > 0 then
        if (iLandOrWaterZone or 0) == 0 then
            iLandOrWaterZone = M28Map.GetWaterZoneFromPosition(tBuildLocation)
            iPlateauOrZero = 0
        end
        if iLandOrWaterZone > 0 then
            iCurQueueRefNumber = iCurQueueRefNumber + 1
            if not(oEngineer[reftQueuedBuildings]) then oEngineer[reftQueuedBuildings] = {} end
            if bDebugMessages == true then LOG(sFunctionRef..': About to get building size='..(M28UnitInfo.GetBuildingSize(sBuildingID) or 'nil')) end
            local iBuildingRadius = math.floor(M28UnitInfo.GetBuildingSize(sBuildingID) * 0.5)
            table.insert(oEngineer[reftQueuedBuildings], {[subrefQueueRef] = iCurQueueRefNumber, [subrefBuildingID] = sBuildingID, [subrefBuildingLocation] = tBuildLocation, [subrefBuildingRadius] = iBuildingRadius, [subrefPlateauOrZero] = iPlateauOrZero, [subrefLandOrWaterZone] = iLandOrWaterZone})
            local tLZOrWZTeamData, tLZOrWZData
            if iPlateauOrZero > 0 then
                tLZOrWZData  = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
            else
                --Water zone
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                tLZOrWZTeamData = tLZOrWZData[M28Map.subrefWZTeamData][oEngineer:GetAIBrain().M28Team]
            end

            if iPlateauOrZero == 0 then

                tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][oEngineer:GetAIBrain().M28Team]
            else
                tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
            end
            if not(tLZOrWZTeamData[M28Map.subrefQueuedBuildings]) then tLZOrWZTeamData[M28Map.subrefQueuedBuildings] = {} end
            table.insert(tLZOrWZTeamData[M28Map.subrefQueuedBuildings], {[M28Map.subrefQueueRef] = iCurQueueRefNumber, [M28Map.subrefBuildingID] = sBuildingID, [M28Map.subrefBuildingLocation] = tBuildLocation, [M28Map.subrefBuildingRadius] = iBuildingRadius, [M28Map.subrefPrimaryBuilder] = oEngineer})
            --Record the locations as being queued
            ChangeQueuedLocationsTracker(tBuildLocation, tLZOrWZData, iBuildingRadius, true)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ChangeQueuedLocationsTracker(tBuildLocation, tLZOrWZData, iBuildingRadius, bAddToQueue)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ChangeQueuedLocationsTracker'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iBaseX = math.floor(tBuildLocation[1])
    local iBaseZ = math.floor(tBuildLocation[3])
    for iX = iBaseX - iBuildingRadius, iBaseX + iBuildingRadius, 1 do
        if bAddToQueue then
            if not(tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX]) then
                if not(tLZOrWZData[M28Map.subrefQueuedLocationsByPosition]) then tLZOrWZData[M28Map.subrefQueuedLocationsByPosition] = {} end
                tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX] = {}
            end
            for iZ = iBaseZ - iBuildingRadius, iBaseZ + iBuildingRadius do
                tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX][iZ] = true
            end
        else
            if tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX] then
                for iZ = iBaseZ - iBuildingRadius, iBaseZ + iBuildingRadius do
                    tLZOrWZData[M28Map.subrefQueuedLocationsByPosition][iX][iZ] = nil
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TrackEngineerAction(oEngineer, iActionToAssign, bIsPrimaryBuilder, iCurPriority, tOptionalPlatAndLandToMoveTo, vOptionalOtherVariable, bMarkAsSpare)
    --bIsPrimaryBuilder - true if engineer will be building the item in question (so false if assisting an engineer or repairing a building or assisting an upgrade or moving somewhere etc.
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TrackEngineerAction'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Special logic (done in a genric way in case end up with more scenarios like this) - if action to assign currnetly is special shield logic and we have a different action to assign then clear engineer tracking (as we have an override that prevents it being cleared via orders)
    if oEngineer[refiAssignedAction] and not(oEngineer[refiAssignedAction] == iActionToAssign) then ClearEngineerTracking(oEngineer) end

    oEngineer[refiAssignedAction] = iActionToAssign
    oEngineer[refbPrimaryBuilder] = (bIsPrimaryBuilder or false)
    oEngineer[refiAssignedActionPriority] = iCurPriority
    oEngineer[refbHasSpareAction] = bMarkAsSpare

    --Track experimental construction
    if iActionToAssign == refActionBuildExperimental or iActionToAssign == refActionBuildSecondExperimental or iActionToAssign == refActionBuildGameEnder or iActionToAssign == refActionBuildExperimentalNavy or iActionToAssign == refActionBuildLandExperimental or iActionToAssign == refActionManageGameEnderTemplate then
        if not(oEngineer[refbBuildingExperimental]) then --dont want engineers on GE template to keep being added to table
            table.insert(M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subreftTeamEngineersBuildingExperimentals], oEngineer)
            oEngineer[refbBuildingExperimental] = true
            if bDebugMessages == true then
                local iDeadCount = 0
                for iUnit, oUnit in M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subreftTeamEngineersBuildingExperimentals] do
                    if oUnit.Dead then iDeadCount = iDeadCount + 1 end
                end
                LOG(sFunctionRef..': Adding engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to team '..oEngineer:GetAIBrain().M28Team..' table of engineers building experimental, size of table='..table.getn(M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subreftTeamEngineersBuildingExperimentals])..'; iDeadCount='..iDeadCount)
            end
        end
    else
        oEngineer[refbBuildingExperimental] = nil
    end

    --Track info e.g. for units moving to other plateaus
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
    local tTargetLZTeamData
    if tOptionalPlatAndLandToMoveTo then
        oEngineer[M28Land.reftiPlateauAndLZToMoveTo] = {tOptionalPlatAndLandToMoveTo[1], tOptionalPlatAndLandToMoveTo[2]}
        tTargetLZTeamData = M28Map.tAllPlateaus[tOptionalPlatAndLandToMoveTo[1]][M28Map.subrefPlateauLandZones][tOptionalPlatAndLandToMoveTo[2]][M28Map.subrefLZTeamData][oEngineer:GetAIBrain().M28Team]
        if bDebugMessages == true then LOG(sFunctionRef..': Recorded engi as having a plateau to move to, oEngineer[M28Land.reftiPlateauAndLZToMoveTo]='..repru(oEngineer[M28Land.reftiPlateauAndLZToMoveTo])) end
    end
    if vOptionalOtherVariable then
        if iActionToAssign == refActionReclaimArea then
            oEngineer[reftAssignedReclaimSegments] = vOptionalOtherVariable
        elseif iActionToAssign == refActionRunToWaterZone or iActionToAssign == refActionMoveToWaterZone then
            if bDebugMessages == true then LOG(sFunctionRef..': Engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' wants to move to water zone '..vOptionalOtherVariable..'; iCurPriority='..(iCurPriority or 'nil')) end
            oEngineer[M28Land.reftiPlateauAndLZToMoveTo] = nil
            oEngineer[M28Navy.refiWZToMoveTo] = vOptionalOtherVariable
            local iPond = M28Map.tiPondByWaterZone[vOptionalOtherVariable]
            tTargetLZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][vOptionalOtherVariable][M28Map.subrefWZTeamData][oEngineer:GetAIBrain().M28Team]
        else M28Utilities.ErrorHandler('vOptionalOtherVariable is specified but dont know what for, iActionToAssign='..iActionToAssign)
        end
    end

    --Track if we are moving to a land or water zone
    if tTargetLZTeamData then
        if not(tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere]) then tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere] = {} end
        table.insert(tTargetLZTeamData[M28Map.subrefTEngineersTravelingHere], oEngineer)
        --Reduce BP wanted by the LZ, and no longer flag it as wanting BP if this satisfies all its needs
        local iEngiTechLevel = M28UnitInfo.GetUnitTechLevel(oEngineer)
        for iTech = iEngiTechLevel, 1, -1 do
            if tTargetLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                tTargetLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] = tTargetLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] - oEngineer:GetBlueprint().Economy.BuildRate
                local bNoLongerWantBP = false
                if tTargetLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] <= 0 then
                    bNoLongerWantBP = true
                    for iAltTech = iTech, 1, -1 do
                        if tTargetLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iAltTech] > 0 then
                            bNoLongerWantBP = false
                            break
                        end
                    end
                end
                if bNoLongerWantBP then
                    tTargetLZTeamData[M28Map.subrefTbWantBP] = false
                end
                break
            end
        end
    end

    --Track potential blacklist locations for primary engineers - note that more general queued building construction tracking is done via TrackQueuedBuilding based on when an order is given to construct something
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to track engineer for blacklisted locations, Time='..GetGameTimeSeconds()..'; Engineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; bIsPrimaryBuilder='..tostring(bIsPrimaryBuilder or false)..'; oEngineer[M28Orders.refiOrderCount]='..(oEngineer[M28Orders.refiOrderCount] or 'nil')..'; Last order type='..(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] or 'nil')) end
    if bIsPrimaryBuilder and not(tbActionsThatDontHaveCategory[iActionToAssign]) and oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild then
        ForkThread(MonitorEngineerForBlacklistLocation, oEngineer)
    end

    --Unpause engineer
    if oEngineer[M28UnitInfo.refbPaused] then
        M28UnitInfo.PauseOrUnpauseEnergyUsage(oEngineer, false)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' action='..(oEngineer[refiAssignedAction] or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function HaveSameTargetAndNotStartedBuilding(oEngineer, iOrigAction, iOrigQueueRef, sOrigBlueprint, tOrigBuildLocation)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'HaveSameTargetAndNotStartedBuilding'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if bDebugMessages == true then
        if M28UnitInfo.IsUnitValid(oEngineer) then
            LOG(sFunctionRef..': time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..': Engineer is valid, refbPrimaryBuilder='..tostring(oEngineer[refbPrimaryBuilder])..'; Assigned action='..(oEngineer[refiAssignedAction] or 'nil')..'; Engineer unit state='..M28UnitInfo.GetUnitState(oEngineer)..'; Qued buildings queue ref='..(oEngineer[reftQueuedBuildings][1][subrefQueueRef] or 'nil')..'; Last order blueprint='..(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] or 'nil')..'; Last order position='..repru(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition] or {'nil'}))
        else
            LOG(sFunctionRef..': Engineer is no longer valid')
        end
    end
    if M28UnitInfo.IsUnitValid(oEngineer) and oEngineer[refbPrimaryBuilder] and oEngineer[refiAssignedAction] == iOrigAction and not(oEngineer:IsUnitState('Building')) and not(oEngineer:IsUnitState('Repairing')) and oEngineer[reftQueuedBuildings][1][subrefQueueRef] == iOrigQueueRef and sOrigBlueprint == oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] then --and oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition] and M28Utilities.GetDistanceBetweenPositions(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition], tOrigBuildLocation) <= 1 then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return true
    else
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false
    end
end

function ClearBlacklistForUnitConstructed(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ClearBlacklistForUnitConstructed'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is table of blacklists empty='..tostring(M28Utilities.IsTableEmpty(oUnit[reftUnitBlacklistSegmentXZ]))) end
    if M28Utilities.IsTableEmpty(oUnit[reftUnitBlacklistSegmentXZ]) == false then
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
        if iPlateauOrZero and (iLandOrWaterZone or 0) > 0 then
            local tLZOrWZData
            if iPlateauOrZero == 0 then
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
            else
                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
            end
            for iEntry, tiSegmentXZ in oUnit[reftUnitBlacklistSegmentXZ] do
                if tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][tiSegmentXZ[1]][tiSegmentXZ[2]] then tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][tiSegmentXZ[1]][tiSegmentXZ[2]] = nil end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished clearing the blacklisted locations, iPlateau='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; repru of blacklisted locations for zone='..repru(tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition])) end
        end
    end
    oUnit[reftUnitBlacklistSegmentXZ] = nil
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DelayedBlacklistReset(tLZOrWZData, iX, iZ, iResetTimeInSeconds, oOptionalUnitToTrack)
    WaitSeconds(iResetTimeInSeconds)
    if not(oOptionalUnitToTrack) or not(M28UnitInfo.IsUnitValid(oOptionalUnitToTrack)) then
        tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][iX][iZ] = nil
    end
end

function RecordBlacklistLocation(tLocation, iRadius, iResetTimeInSeconds, oOptionalUnitToTrack)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordBlacklistLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --oOptionalUnitToTrack - i.e. should have experimental units under construction specified here - if specified, means iresettimeinseconds only triggers if that unit doesnt exist, as a redundancy for if we failed to pickup the event when it died
    --iResetTimeInSeconds - per above, if  oOptionalUnitToTrack is specififed then this only triggers if hte unit no longer exists after waiting iResetTimeInSeconds

    local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tLocation)
    if bDebugMessages == true then LOG(sFunctionRef..': Gametimeseconds='..GetGameTimeSeconds()..'; tLocation='..repru(tLocation)..'; iRadius='..(iRadius or 'nil')..'; iResetTimeInSeconds='..(iResetTimeInSeconds or 'nil')..'; oOptionalUnitToTrack='..(oOptionalUnitToTrack.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oOptionalUnitToTrack) or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')) end
    if (iLandOrWaterZone or 0) > 0 then
        local tLZOrWZData
        if iPlateauOrZero == 0 then
            tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        else
            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        end
        if oOptionalUnitToTrack then
            oOptionalUnitToTrack[reftUnitBlacklistSegmentXZ] = {}
        end


        local iBaseX = math.floor(tLocation[1])
        local iBaseZ = math.floor(tLocation[3])
        local iSegmentRadius = math.floor(iRadius / M28Map.iLandZoneSegmentSize)
        if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through every position for iSegmentRadius='..iSegmentRadius..'; iBaseX='..iBaseX..'; iBaseZ='..iBaseZ) end
        for iX = iBaseX - iSegmentRadius, iBaseX + iSegmentRadius do
            for iZ = iBaseZ - iSegmentRadius, iBaseZ + iSegmentRadius do
                if not(tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][iX][iZ]) then
                    if not(tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][iX]) then
                        if not(tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition]) then tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition] = {} end
                        tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][iX] = {}
                    end
                    tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition][iX][iZ] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Added blacklist to location iX='..iX..'; iZ='..iZ..'; iResetTimeInSeconds='..(iResetTimeInSeconds or 'nil')) end
                    if (iResetTimeInSeconds or 0) >= 0 then
                        ForkThread(DelayedBlacklistReset, tLZOrWZData, iX, iZ, iResetTimeInSeconds, oOptionalUnitToTrack)
                    end
                    if oOptionalUnitToTrack then
                        table.insert(oOptionalUnitToTrack[reftUnitBlacklistSegmentXZ], {iX, iZ})
                        if bDebugMessages == true then LOG(sFunctionRef..': Added blacklist location for oOptionalUnitToTrack='..oOptionalUnitToTrack.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOptionalUnitToTrack)..'; X'..iX..'Z'..iZ) end
                    end
                else
                    --Already reocrded as a blacklist so wont rerecord/add a new reset to it
                end
            end
        end
        if bDebugMessages == true then
            LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Added location to the blacklist, tLocation='..repru(tLocation)..'; iRadius='..(iRadius or 0)..'; iResetTimeInSeconds='..(iResetTimeInSeconds or 'nil')..'; repru of blacklist locations='..repru(tLZOrWZData[M28Map.subrefBuildLocationBlacklistByPosition])..'; will draw all blacklisted locations for this LZ')
            DrawBlacklistedLocations(tLZOrWZData)
        end

    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MonitorEngineerForBlacklistLocation(oEngineer)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MonitorEngineerForBlacklistLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local sOrigBlueprint = oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint]
    --Only consider engineers with a single queued up building
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; sOrigBlueprint='..(sOrigBlueprint or 'nil')..'; Is table of queued buildings empty='..tostring(M28Utilities.IsTableEmpty(oEngineer[reftQueuedBuildings]))..'; Size of queued buildings table='..table.getn(oEngineer[reftQueuedBuildings] or {})) end
    if sOrigBlueprint and M28Utilities.IsTableEmpty(oEngineer[reftQueuedBuildings]) == false and table.getn(oEngineer[reftQueuedBuildings]) == 1 then
        --Ignore for mexes and hydrocarbons
        if not(EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryHydro, sOrigBlueprint)) then
            local iOrigQueueRef = oEngineer[reftQueuedBuildings][1][subrefQueueRef]
            local sTrackerRef = 'M28Q'..iOrigQueueRef
            if not(oEngineer[sTrackerRef]) then
                oEngineer[sTrackerRef] = true
                local tOrigBuildLocation = {oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition][1], oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition][2], oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition][3]}
                local bCloseToTarget = false
                local iOrigAction = oEngineer[refiAssignedAction]
                local iWaitCount = 0
                local iOrigTime = GetGameTimeSeconds()

                --[[function HaveSameTargetAndNotStartedBuilding()
                if bDebugMessages == true then
                    if M28UnitInfo.IsUnitValid(oEngineer) then
                    --]]
                --LOG('HaveSameTargetAndNotStartedBuilding: time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..': Engineer is valid, refbPrimaryBuilder='..tostring(oEngineer[refbPrimaryBuilder])..'; Assigned action='..(oEngineer[refiAssignedAction] or 'nil')..'; Engineer unit state='..M28UnitInfo.GetUnitState(oEngineer)..'; Qued buildings queue ref='..(oEngineer[reftQueuedBuildings][1][subrefQueueRef] or 'nil')..'; Last order blueprint='..(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] or 'nil')..'; Last order position='..repru(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition] or {'nil'}))
                --[[else
                LOG('HaveSameTargetAndNotStartedBuilding: Engineer is no longer valid')
            end
        end--]]
                --if M28UnitInfo.IsUnitValid(oEngineer) and oEngineer[refbPrimaryBuilder] and oEngineer[refiAssignedAction] == iOrigAction and not(oEngineer:IsUnitState('Building')) and not(oEngineer:IsUnitState('Repairing')) and oEngineer[reftQueuedBuildings][1][subrefQueueRef] == iOrigQueueRef and sOrigBlueprint == oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] and oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition] and M28Utilities.GetDistanceBetweenPositions(oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subreftOrderPosition], tOrigBuildLocation) <= 1 then
                --[[return true
        else
            return false
        end
    end--]]
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitSeconds(10)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                if bDebugMessages == true then LOG(sFunctionRef..': time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..': Finished first wait, HaveSameTargetAndNotStartedBuilding='..tostring(HaveSameTargetAndNotStartedBuilding(oEngineer, iOrigAction, iOrigQueueRef, sOrigBlueprint, tOrigBuildLocation))..'; iOrigQueueRef='..repru(iOrigQueueRef or 'nil')..'; tOrigBuildLocation='..repru(tOrigBuildLocation)..'; iOrigAction='..repru(iOrigAction or 'nil')) end

                while HaveSameTargetAndNotStartedBuilding(oEngineer, iOrigAction, iOrigQueueRef, sOrigBlueprint, tOrigBuildLocation) and not(bCloseToTarget) do
                    if bDebugMessages == true then LOG(sFunctionRef..': time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..': bCloseToTarget='..tostring(bCloseToTarget)..'; Dist between engineer pos and orig build location='..M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), tOrigBuildLocation)) end
                    if M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), tOrigBuildLocation) <= 12 then bCloseToTarget = true break
                    else
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitSeconds(10)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        iWaitCount = iWaitCount + 1
                        if iWaitCount >= 20 then break end
                    end
                end
                if bCloseToTarget then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitSeconds(45)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished another wait and are close to target, time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; HaveSameTargetAndNotStartedBuilding()='..tostring(HaveSameTargetAndNotStartedBuilding(oEngineer, iOrigAction, iOrigQueueRef, sOrigBlueprint, tOrigBuildLocation))) end
                    if HaveSameTargetAndNotStartedBuilding(oEngineer, iOrigAction, iOrigQueueRef, sOrigBlueprint, tOrigBuildLocation) then
                        --If there are no mobile units then wait another 30s
                        local bAddToBlacklist = true
                        local iRadius = M28UnitInfo.GetBuildingSize(sOrigBlueprint) * 0.5
                        local rNearbyRect = M28Utilities.GetRectAroundLocation(tOrigBuildLocation, iRadius)
                        local tUnitsInRect = GetUnitsInRect(rNearbyRect)
                        if M28Utilities.IsTableEmpty(tUnitsInRect) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.MOBILE * categories.LAND, tUnitsInRect)) then
                            bAddToBlacklist = false
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitSeconds(30)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                            if HaveSameTargetAndNotStartedBuilding(oEngineer, iOrigAction, iOrigQueueRef, sOrigBlueprint, tOrigBuildLocation) then
                                bAddToBlacklist = true
                            end
                        end
                        if bAddToBlacklist then

                            --Add location to blacklist
                            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tOrigBuildLocation)
                            if bDebugMessages == true then LOG(sFunctionRef..': time='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..': Want to add to blacklist, iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; sOrigBlueprint='..sOrigBlueprint) end
                            if iPlateau and iLandZone then
                                RecordBlacklistLocation(tOrigBuildLocation, 1, 480) --i.e. reset after 8 minutes

                                --Prev approach below:
                                --table.insert(tLZData[M28Map.subrefBuildLocationBlacklist], {[M28Map.subrefBlacklistLocation] = tOrigBuildLocation, [M28Map.subrefBlacklistSize] = iRadius, [M28Map.subrefBlacklistType] = M28Map.BlacklistTimeout})

                                --Update existing build locations to remove if they are near here
                                CheckIfBuildableLocationsNearPositionStillValid(oEngineer:GetAIBrain(), tOrigBuildLocation, true, M28UnitInfo.GetBuildingSize(sOrigBlueprint) * 0.5)

                                --Clear this engineer and any assisting engineers (assisting engineers are cleared via ClearEngineerTracking)
                                M28Orders.IssueTrackedClearCommands(oEngineer)
                            end
                        end
                    end
                end
            end
            oEngineer[sTrackerRef] = nil
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetEngineerToReclaimNearbyArea(oEngineer, iPriorityOverride, tLZOrWZTeamData, iPlateauOrPond, iLandOrWaterZone, bWantEnergyNotMass, bOnlyConsiderReclaimInRangeOfEngineer, iMinIndividualValueOverride, bIsWaterZone, bOptionalReturnTrueIfGivenOrder)
    --Gets engineer to find the nearest unassigned reclaim segment in the land zone that has mass/energy, to move to the middle of it, and reclaim it
    --Factors in how much mass is in the segment and how many engineers have been assigned already and adjusts the chosen segment accordingly
    --bOnlyConsiderReclaimInRangeOfEngineer - if true then will use oEngineer position instead of the midpoint of the reclaim segment that want to target
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetEngineerToReclaimNearbyArea'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local bGivenOrder = false
    local iCurPriority = (iPriorityOverride or oEngineer[refiAssignedActionPriority] or 1)
    local tLZOrWZData
    if bIsWaterZone then tLZOrWZData = M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iLandOrWaterZone]
    else tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; iPlateauOrPond='..iPlateauOrPond..'; iLandOrWaterZone='..iLandOrWaterZone..'; bWantEnergyNotMass='..tostring(bWantEnergyNotMass or false)..'; bOnlyConsiderReclaimInRangeOfEngineer='..tostring(bOnlyConsiderReclaimInRangeOfEngineer or false)..'; iMinIndividualValueOverride='..(iMinIndividualValueOverride or 'nil')..'; bIsWaterZone='..tostring(bIsWaterZone or false)..'; Total mass in zone='..tLZOrWZData[M28Map.subrefTotalMassReclaim]..'; Total significant mass='..tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim]) end
    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefReclaimSegments]) == false then
        local iClosestSegmentDist = 100000
        local tiClosestSegmentXZ
        local iCurModDist
        local sTotalReclaimValueRef
        local iReclaimValuePerEngi
        local oNearestReclaim
        local iEngiPlateau = NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oEngineer:GetPosition())

        local iMinSignifSegmentValue = 0
        local bDontCheckSignificantValue = true
        local bReduceModDistIfSignificantMass = false
        if not(bWantEnergyNotMass) then
            if not(bOnlyConsiderReclaimInRangeOfEngineer) then
                if tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim] >= 500 then
                    iMinSignifSegmentValue = M28Map.iSignificantMassThreshold --10 (as of v43)
                    bDontCheckSignificantValue = false
                elseif tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim] > 0 then
                    bReduceModDistIfSignificantMass = true
                end
            end
        end

        local iMinReclaimIndividualValue = (iMinIndividualValueOverride or M28Map.iLowestMassThreshold)


        if bWantEnergyNotMass then
            sTotalReclaimValueRef = M28Map.subrefLZTotalEnergyReclaim
            iReclaimValuePerEngi = 300
        else
            sTotalReclaimValueRef = M28Map.subrefTotalMassReclaim
            iReclaimValuePerEngi = 200
        end

        local oEngBP = oEngineer:GetBlueprint()
        --if oEngBP.Economy.MaxBuildDistance >= 10 then iSegmentSearchSize = math.max(1, math.ceil((oEngBP.Economy.MaxBuildDistance + 2) / math.min(M28Map.iReclaimSegmentSizeX, M28Map.iReclaimSegmentSizeZ))) end
        --local iMoveSpeed = oEngBP.Physics.MaxSpeed
        local iMaxDistanceToEngineer = oEngBP.Economy.MaxBuildDistance + math.min(oEngBP.SizeX, oEngBP.SizeZ) * 0.5 - 0.1
        local bCheckTerrain = false
        if iMaxDistanceToEngineer < math.min(M28Map.iReclaimSegmentSizeX, M28Map.iReclaimSegmentSizeZ) then bCheckTerrain = true end
        local sReclaimTableRef
        if bWantEnergyNotMass then sReclaimTableRef = M28Map.refSegmentReclaimTotalEnergy
        else sReclaimTableRef = M28Map.refReclaimHighestIndividualMassReclaim --M28Map.refReclaimTotalMass
        end

        local bDontConsiderPlayableArea = not(M28Map.bIsCampaignMap)
        local bDontConsiderNoRush = not(M28Overseer.bNoRushActive)

        if not(bOnlyConsiderReclaimInRangeOfEngineer) then
            for iSegmentCount, tSegmentXZ in tLZOrWZData[M28Map.subrefReclaimSegments] do
                if M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][sReclaimTableRef] >= iMinReclaimIndividualValue and (bDontCheckSignificantValue or M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][M28Map.refReclaimTotalSignificantMass] >= iMinSignifSegmentValue) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering reclaim location at position '..repru(M28Map.GetReclaimLocationFromSegment(tSegmentXZ[1], tSegmentXZ[2]))..'; plyaable area='..repru(M28Map.rMapPlayableArea)..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(M28Map.GetReclaimLocationFromSegment(tSegmentXZ[1], tSegmentXZ[2])))..'; bDontConsiderPlayableArea='..tostring(bDontConsiderPlayableArea)..'; Mass reclaim in segment='..(M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][M28Map.refReclaimTotalMass] or 'nil')..'; Signif mass in segment='..(M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][M28Map.refReclaimTotalSignificantMass] or 'nil')) end
                    if bDontConsiderPlayableArea or M28Conditions.IsLocationInPlayableArea(M28Map.GetReclaimLocationFromSegment(tSegmentXZ[1], tSegmentXZ[2])) then
                        if bDontConsiderNoRush or M28Conditions.IsLocationInNoRushArea(M28Map.GetReclaimLocationFromSegment(tSegmentXZ[1], tSegmentXZ[2])) then
                            iCurModDist = M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), M28Map.GetReclaimLocationFromSegment(tSegmentXZ[1], tSegmentXZ[2]))
                            if iCurModDist > iMaxDistanceToEngineer then
                                if tLZOrWZTeamData[M28Map.subrefReclaimAreaAssignmentsBySegment][tSegmentXZ[1]] and tLZOrWZTeamData[M28Map.subrefReclaimAreaAssignmentsBySegment][tSegmentXZ[1]][tSegmentXZ[2]] and tLZOrWZData[sTotalReclaimValueRef] < (iReclaimValuePerEngi * tLZOrWZTeamData[M28Map.subrefReclaimAreaAssignmentsBySegment][tSegmentXZ[1]][tSegmentXZ[2]]) then
                                    iCurModDist = iCurModDist + 60 * tLZOrWZTeamData[M28Map.subrefReclaimAreaAssignmentsBySegment][tSegmentXZ[1]][tSegmentXZ[2]] * iReclaimValuePerEngi / math.max(5, tLZOrWZData[sTotalReclaimValueRef]) --Low priority area
                                end
                            end
                            if bReduceModDistIfSignificantMass and M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][M28Map.refReclaimTotalSignificantMass] > 0 then iCurModDist = iCurModDist * 0.5 end --Prioritise locations with significant reclaim over those without
                            if iCurModDist < iClosestSegmentDist then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have a new closest dist='..iCurModDist..'; SegmentXZ='..repru(tSegmentXZ)) end
                                iClosestSegmentDist = iCurModDist
                                tiClosestSegmentXZ = {tSegmentXZ[1], tSegmentXZ[2]}
                            end
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': tiClosestSegmentXZ='..repru(tiClosestSegmentXZ)..'; bOnlyConsiderReclaimInRangeOfEngineer='..tostring(bOnlyConsiderReclaimInRangeOfEngineer or false)) end
        if tiClosestSegmentXZ or bOnlyConsiderReclaimInRangeOfEngineer then
            --Get reclaim in the segment
            local tTargetPos
            if bOnlyConsiderReclaimInRangeOfEngineer then
                tTargetPos = oEngineer:GetPosition()
            else tTargetPos = M28Map.GetReclaimLocationFromSegment(tiClosestSegmentXZ[1], tiClosestSegmentXZ[2])
            end

            local iCurDistToTargetPos
            if bDebugMessages == true then
                if bOnlyConsiderReclaimInRangeOfEngineer then LOG(sFunctionRef..': Only considering reclaim around the engineer position rather than the wider land zone')
                else
                    LOG(sFunctionRef..': Considering all reclaim in the land zone, Eng build distance='..oEngBP.Economy.MaxBuildDistance..'; SizeX='..oEngBP.SizeX..'; Eng SizeZ='..oEngBP.SizeZ..'; tiClosestSegmentXZ='..repru(tiClosestSegmentXZ)..'; Mass/energy reclaim in this segment (depending on which we are searching for)='..M28Map.tReclaimAreas[tiClosestSegmentXZ[1]][tiClosestSegmentXZ[2]][sReclaimTableRef]..'; searching for energy not mass='..tostring(bWantEnergyNotMass))
                end
            end

            --GetReclaimInRectangle(iReturnType, rRectangleToSearch)
            --    --iReturnType: 1 = true/false; 2 = number of wrecks; 3 = total mass, 4 = valid wrecks
            local rReclaimRectangle
            if bOnlyConsiderReclaimInRangeOfEngineer then
                if bDebugMessages == true then LOG(sFunctionRef..': Only considering reclaim in range of negineer so will consider arond tTargetPos='..repru(tTargetPos)..'; using a radius of '..math.max(M28Map.iReclaimSegmentSizeX * 0.5, iMaxDistanceToEngineer, M28Map.iReclaimSegmentSizeZ * 0.5)..'; Playable area='..repru(M28Map.rMapPlayableArea)) end
                rReclaimRectangle = M28Utilities.GetRectAroundLocation(tTargetPos, math.max(M28Map.iReclaimSegmentSizeX * 0.5, iMaxDistanceToEngineer, M28Map.iReclaimSegmentSizeZ * 0.5))
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Will consider the reclaim segment using iMaxDistanceToEngineer='..(iMaxDistanceToEngineer or 'nil')..'; Reclaim segment midpoint='..repru(M28Map.tReclaimAreas[tiClosestSegmentXZ[1]][tiClosestSegmentXZ[2]][M28Map.refReclaimSegmentMidpoint])..'; Playable area='..repru(M28Map.rMapPlayableArea)) end
                rReclaimRectangle = M28Map.GetReclaimSegmentRectangle(tiClosestSegmentXZ[1], tiClosestSegmentXZ[2], iMaxDistanceToEngineer)
            end
            local tNearbyReclaim = M28Map.GetReclaimInRectangle(4, rReclaimRectangle)
            if bDebugMessages == true then
                local iTargetPosPlateau, iTargetPosLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetPos)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering for iPlateauOrPond='..(iPlateauOrPond or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; Engineer='..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil')..'; iMaxDistanceToEngineer='..(iMaxDistanceToEngineer or 'nil')..'; oEngBP.Economy.MaxBuildDistance='..(oEngBP.Economy.MaxBuildDistance or 'nil')..'; tiClosestSegmentXZ='..repru(tiClosestSegmentXZ)..'; Is tNearbyReclaim empty='..tostring(M28Utilities.IsTableEmpty(tNearbyReclaim))..'; Total mass recorded against this reclaim segment='..(M28Map.tReclaimAreas[tiClosestSegmentXZ[1]][tiClosestSegmentXZ[2]][M28Map.refReclaimTotalMass] or 'nil')..'; tTargetPos='..repru(tTargetPos)..'; Eng pos='..repru(oEngineer:GetPosition())..'; Target Plateau and LZ='..(iTargetPosPlateau or 'nil')..'-'..(iTargetPosLZ or 0)..'; Reclaim segment='..repru(tiClosestSegmentXZ)..'; rReclaimRectangle='..repru(rReclaimRectangle)..'; M28Map.iReclaimSegmentSizeX='..(M28Map.iReclaimSegmentSizeX or 'nil')..'; iMaxDistanceToEngineer='..(iMaxDistanceToEngineer or 'nil')) end
                M28Utilities.DrawRectangle(rReclaimRectangle, 2, 20)
            end

            local bConsiderBelowMinValueIfCantFindAny = true
            if EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then bConsiderBelowMinValueIfCantFindAny = false end
            local iCurMinToUse = 0
            if not(bConsiderBelowMinValueIfCantFindAny) then iCurMinToUse = iMinReclaimIndividualValue end

            if M28Utilities.IsTableEmpty(tNearbyReclaim) == false then
                local iNearestReclaim = 10000
                local iNearestReclaimWithAnyValue = 10000
                local oNearestAnyValueReclaim
                local iReclaimRadius

                local iEngiTerrainLabel = NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oEngineer:GetPosition())


                for iReclaim, oReclaim in tNearbyReclaim do
                    --is this valid reclaim within our build area?
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': iReclaim='..iReclaim..'; oReclaim.MaxMassReclaim='..(oReclaim.MaxMassReclaim or 0))
                        if oReclaim.MaxMassReclaim >= 100 or (bWantEnergyNotMass and oReclaim.MaxEnergyReclaim >= 100) then
                            LOG('Large reclaim, repr of all values='..reprs(oReclaim))
                            if oReclaim.GetBlueprint then
                                LOG('oReclaim has a blueprint='..reprs(oReclaim:GetBlueprint()))
                            else LOG('oReclaim doesnt have .GetBlueprint')
                            end
                        end
                    end

                    if oReclaim.CachePosition and not(oReclaim:BeenDestroyed()) and ((not(bWantEnergyNotMass) and ((bConsiderBelowMinValueIfCantFindAny and not(oNearestReclaim)) or (not(bWantEnergyNotMass) and oReclaim.MaxMassReclaim >= iCurMinToUse) or (bWantEnergyNotMass and oReclaim.MaxEnergyReclaim >= iCurMinToUse))))  then
                        if bDontConsiderNoRush or M28Conditions.IsLocationInNoRushArea(oReclaim.CachePosition) then
                            iReclaimRadius = math.min(oReclaim:GetBlueprint().SizeX, oReclaim:GetBlueprint().SizeZ)*0.5
                            iCurDistToTargetPos = math.max(0, M28Utilities.GetDistanceBetweenPositions(tTargetPos, oReclaim.CachePosition) - iReclaimRadius)
                            --Can we path to it?
                            if iCurDistToTargetPos < iNearestReclaim and (not(bCheckTerrain) or (NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oReclaim.CachePosition) == iEngiTerrainLabel or (iCurDistToTargetPos <= 12 and M28Utilities.GetDistanceBetweenPositions(oReclaim.CachePosition, oEngineer:GetPosition()) <= iReclaimRadius + iMaxDistanceToEngineer))) then
                                iNearestReclaim = iCurDistToTargetPos
                                oNearestReclaim = oReclaim
                                if bConsiderBelowMinValueIfCantFindAny then
                                    if bWantEnergyNotMass then
                                        iCurMinToUse = math.min(iMinReclaimIndividualValue, oReclaim.MaxEnergyReclaim)
                                    else
                                        iCurMinToUse = math.min(iMinReclaimIndividualValue, oReclaim.MaxMassReclaim)
                                    end
                                end
                            end
                            --Backup e.g. if looking for energy reclaim but only have mass available
                            if not(oNearestReclaim) then
                                if iCurDistToTargetPos < iNearestReclaimWithAnyValue and (oReclaim.MaxMassReclaim or 0) + (oReclaim.MaxEnergyReclaim or 0) > 0 then
                                    if not(oNearestAnyValueReclaim) or NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oReclaim.CachePosition) == iEngiPlateau or NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oReclaim.CachePosition) == iPlateauOrPond then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Recording reclaim as a backup for now so we have at least something to reclaim') end
                                        oNearestAnyValueReclaim = oReclaim
                                        iNearestReclaimWithAnyValue = iCurDistToTargetPos
                                        if bConsiderBelowMinValueIfCantFindAny then
                                            if bWantEnergyNotMass then
                                                iCurMinToUse = math.min(iMinReclaimIndividualValue, oReclaim.MaxEnergyReclaim)
                                            else
                                                iCurMinToUse = math.min(iMinReclaimIndividualValue, oReclaim.MaxMassReclaim)
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                if not(oNearestReclaim) then
                    oNearestReclaim = oNearestAnyValueReclaim
                    --Check this is in the same zone
                    if oNearestReclaim and bCheckTerrain then
                        if not(NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oNearestReclaim.CachePosition) == iEngiPlateau or NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, oNearestReclaim.CachePosition) == iPlateauOrPond) then
                            local iDistToReclaim = M28Utilities.GetDistanceBetweenPositions(oNearestReclaim.CachePosition, oEngineer:GetPosition())
                            local iRangeToWreck = iMaxDistanceToEngineer + math.min(oNearestReclaim:GetBlueprint().SizeX, oNearestReclaim:GetBlueprint().SizeZ)*0.5
                            if iDistToReclaim > iRangeToWreck then
                                local tPotentialLocationToMove = M28Utilities.MoveInDirection(oNearestReclaim.CachePosition, M28Utilities.GetAngleFromAToB(oNearestReclaim.CachePosition, oEngineer:GetPosition()), iRangeToWreck, true, false, M28Map.bIsCampaignMap)
                                if bDebugMessages == true then LOG(sFunctionRef..': Ignoring reclaim as we cant path to it, unless the engineer can path somewhere that is within build range of here, tPotentialLocationToMove='..repru(tPotentialLocationToMove)..'; Hover label='..(NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, tPotentialLocationToMove) or 'nil')..'; iPlateauOrPond='..iPlateauOrPond) end
                                if M28Utilities.IsTableEmpty(tPotentialLocationToMove) or not(NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, tPotentialLocationToMove) == iEngiPlateau or NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, tPotentialLocationToMove) == iPlateauOrPond) then
                                    --Want to consider reassigning this reclaim segment if the only reclaim in it is in a different plateau
                                    oNearestReclaim = nil
                                    if tiClosestSegmentXZ then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Reclaim segments for this zone before reassignment='..reprs(tLZOrWZData[subrefReclaimSegments])) end
                                        M28Map.ReassignReclaimSegment(tiClosestSegmentXZ[1], tiClosestSegmentXZ[2], tLZOrWZData)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Reclaim segments for this zone after reassignment='..reprs(tLZOrWZData[subrefReclaimSegments])) end
                                    end
                                end
                            end
                        end
                    end
                end
                if oNearestReclaim then
                    if oEngineer:IsUnitState('Capturing') then M28Utilities.ErrorHandler('Are aborting an engineer that was capturing and telling it to reclaim instead', true, true) end
                    bGivenOrder = true
                    M28Orders.IssueTrackedReclaim(oEngineer, oNearestReclaim, false, 'ReclLZSeg')
                    if bDebugMessages == true then LOG(sFunctionRef..': Will send order to get reclaim at position '..repru(oNearestReclaim.CachePosition)..'; will draw a box around here; oNearestReclaim ID='..(oNearestReclaim.UnitId or 'nil')..'; mass value='..(oNearestReclaim.MaxMassReclaim or 'nil')) M28Utilities.DrawLocation(oNearestReclaim.CachePosition) end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have any reclaim of sufficient value; iMinReclaimIndividualValue='..iMinReclaimIndividualValue) end
                end

            else
                if bDebugMessages == true then LOG(sFunctionRef..' No reclaim in nearby segments, will update the reclaim in this segment if engi isnt range restricted') end
                if not(bOnlyConsiderReclaimInRangeOfEngineer) and tiClosestSegmentXZ then
                    if bDebugMessages == true then LOG(sFunctionRef..': Total mass pre update='..M28Map.tReclaimAreas[tiClosestSegmentXZ[1]][tiClosestSegmentXZ[2]][M28Map.refReclaimTotalMass]) end
                    M28Map.UpdateReclaimDataNearSegments(tiClosestSegmentXZ[1], tiClosestSegmentXZ[2], 0)
                    if bDebugMessages == true then LOG(sFunctionRef..': Total mass post update='..M28Map.tReclaimAreas[tiClosestSegmentXZ[1]][tiClosestSegmentXZ[2]][M28Map.refReclaimTotalMass]) end
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': No segments in land zone with sufficient reclaim') end
        end
        if bGivenOrder and not(EntityCategoryContains(categories.COMMAND, oEngineer.UnitId)) then
            TrackEngineerAction(oEngineer, refActionReclaimArea, false, iCurPriority, nil, tiClosestSegmentXZ)
        elseif not(bGivenOrder) then
            --Flag that this zone has failed to find anything for engineers to reclaim, so we limit BP to assign to 5
            tLZOrWZData[M28Map.subrefiTimeFailedToGetReclaim] = GetGameTimeSeconds()
            if bDebugMessages == true then LOG(sFunctionRef..': Recording that we failed to get reclaim in this zone, is oNearestReclaim nil='..tostring(oNearestReclaim == nil)) end
            --If there is a valid reclaim nearby (it just is too low value) then also give order to reclaim this
            if oNearestReclaim and not(oEngineer:IsUnitState('Capturing')) then
                M28Orders.IssueTrackedReclaim(oEngineer, oNearestReclaim, false, 'ReclBLZSeg')
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bGivenOrder and bOptionalReturnTrueIfGivenOrder then return true end
end

function FilterEngineersOfTechAndEngiCountForFaction(iOptionalFactionRequired, tEngineersOfTechWanted)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'FilterEngineersOfTechAndEngiCountForFaction'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tEngineersOfFactionAndTechWanted
    tEngineersOfFactionAndTechWanted = {}
    local iRevisedEngiCount = 0
    for iTechEngi, oTechEngi in tEngineersOfTechWanted do
        if M28UnitInfo.GetUnitFaction(oTechEngi) == iOptionalFactionRequired then
            table.insert(tEngineersOfFactionAndTechWanted, oTechEngi)
            iRevisedEngiCount = iRevisedEngiCount + 1
            if bDebugMessages == true then LOG(sFunctionRef..': oTechEngi='..oTechEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTechEngi)..' is the right faction so including in revised list, iRevisedEngiCount='..iRevisedEngiCount) end
        end
    end
    if iRevisedEngiCount == 0 then M28Utilities.ErrorHandler('After filtering to a faction we have no available engineers - this shouldnt be possible') end
    --Now replace original table os we dont have to update below references (do by returning these values now since have moved this logic to a function)
    if bDebugMessages == true then LOG(sFunctionRef..': Finished updating list, iRevisedEngiCount='..iRevisedEngiCount..'; Last engi in list='..(tEngineersOfTechWanted[iEngiCount].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount]) or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tEngineersOfFactionAndTechWanted, iRevisedEngiCount

end

function ActiveShieldMonitor(oUnitToProtect, tLZTeamData, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ActiveShieldMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if not(oUnitToProtect[refbActiveUnitShieldingThread]) then
        oUnitToProtect[refbActiveUnitShieldingThread] = true
        local iShieldCategoryToBuild
        local iOptionalFactionRequired
        local iEngineerFactionRequired = M28UnitInfo.refCategoryEngineer
        local iTimeOfLastBlockingBuildingCheck
        local iPreviousAction
        local refiShieldActionConstruct = 1
        local refiShieldActionAssist = 2

        if oUnitToProtect[M28Building.refoNearbyFactoryOfFaction] then
            iOptionalFactionRequired = M28UnitInfo.GetUnitFaction(oUnitToProtect[M28Building.refoNearbyFactoryOfFaction])
        end
        if not(iOptionalFactionRequired) then iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield
        else
            if iOptionalFactionRequired == M28UnitInfo.refFactionSeraphim then
                --Does enemy have mavor? if so then want T3 shields not T2
                local bEnemyHasMavor = false
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure]) == false then
                    for iArti, oArti in M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure] do
                        if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalArti * categories.UEF, oArti.UnitId) then
                            bEnemyHasMavor = true
                        end
                    end
                end
                if bEnemyHasMavor then
                    iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.SERAPHIM
                else
                    --If go for T2 shielding then will be quicker to build and cheaper, and still cover the unit provided the shield can absorb a single shot
                    iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.TECH2 * categories.SERAPHIM
                end
                iEngineerFactionRequired = iEngineerFactionRequired * categories.SERAPHIM  - categories.EXPERIMENTAL
            elseif iOptionalFactionRequired == M28UnitInfo.refFactionAeon then
                iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.AEON - categories.EXPERIMENTAL
                iEngineerFactionRequired = iEngineerFactionRequired * categories.AEON
            elseif iOptionalFactionRequired == M28UnitInfo.refFactionUEF then
                iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.UEF  - categories.EXPERIMENTAL
                iEngineerFactionRequired = iEngineerFactionRequired * categories.UEF
            else
                iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield
            end
        end
        local sLikelyShieldBlueprint = M28Factory.GetMostExpensiveBlueprintOfCategory(iShieldCategoryToBuild)
        local iBlueprintBuildTime = (__blueprints[sLikelyShieldBlueprint].Economy.BuildTime or 1250)

        local aiBrain = oUnitToProtect:GetAIBrain()
        local iTotalAvailableLocations = 0
        for iEntry, tLocation in oUnitToProtect[M28Building.reftLocationsForPriorityShield] do
            iTotalAvailableLocations = iTotalAvailableLocations + 1
            if bDebugMessages == true then
                LOG(sFunctionRef..': Will draw tLocation in reftLocationsForPriorityShield')
                M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tLocation, M28UnitInfo.GetBuildingSize(sLikelyShieldBlueprint) * 0.5), 4, 200)
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop to protect the unit if it is still valid, is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnitToProtect))..'; Unit to protect='..(oUnitToProtect.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitToProtect) or 'nil')) end
        while M28UnitInfo.IsUnitValid(oUnitToProtect) and not(oUnitToProtect[M28Building.reftArtiTemplateRefs]) do
            if bDebugMessages == true then LOG(sFunctionRef..': Loop start at time '..GetGameTimeSeconds()..'; Is table of engineers actively shielding empty='..tostring(M28Utilities.IsTableEmpty(oUnitToProtect[reftEngineersActivelyShielding]))..'; oUnitToProtect='..oUnitToProtect.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToProtect)..'; Assigned plateau and LZ='..repru(oUnitToProtect[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam])..'; reftArtiTemplateRefs='..repru(oUnitToProtect[M28Building.reftArtiTemplateRefs])) end
            if M28Utilities.IsTableEmpty(oUnitToProtect[reftEngineersActivelyShielding]) == false then
                --Decide what to do with the engineers - first see how many shields we have, and if any are compelted:
                local iConstructedShields = 0
                local iActiveShields = 0
                local iPartConstructedShields = 0
                local oNearestCompletionShield
                local iHighestPartCompleteShield = -0.01 --So a 0% complete building gets included
                local iLowestPartCompleteShield = 1.01
                local oLowestCompletionShield
                local oLastCompletedShield
                local iCurShield, iMaxShield
                local oLowestConstructedShieldHealth
                local oHighestConstructedShieldHealth
                local iLowestConstructedShieldHealth = 100000
                local iHighestConstructedShieldHealthPercent = 0
                if bDebugMessages == true then LOG(sFunctionRef..': oUnitToProtect='..oUnitToProtect.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToProtect)..'; Is table of special assigned shields empty='..tostring(M28Utilities.IsTableEmpty(oUnitToProtect[M28Building.reftoSpecialAssignedShields]))) end
                if M28Utilities.IsTableEmpty(oUnitToProtect[M28Building.reftoSpecialAssignedShields]) == false then
                    local tiEntriesToRemove = {}
                    for iShield, oShield in oUnitToProtect[M28Building.reftoSpecialAssignedShields] do
                        if M28UnitInfo.IsUnitValid(oShield) then
                            if not(oShield[refbDontIncludeAsPartCompleteBuildingForConstruction]) then
                                oShield[refbDontIncludeAsPartCompleteBuildingForConstruction] = true

                                --Clear any assisting or building engineers who dont have the special shield action (to avoid a unit that is constructing a shield using this)
                                local tGuardingEngineers = oShield:GetGuards()
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of guarding engineers empty='..tostring(M28Utilities.IsTableEmpty(tGuardingEngineers))) end
                                if M28Utilities.IsTableEmpty(tGuardingEngineers) == false then
                                    for iGuard, oGuard in tGuardingEngineers do
                                        if not(oGuard[refiAssignedAction] == refActionSpecialShieldDefence) and not(oGuard[refiAssignedAction] == refActionManageGameEnderTemplate) then
                                            M28Orders.IssueTrackedClearCommands(oGuard)
                                        end
                                    end
                                end
                                --Also check every engineer in this zone
                                local tEngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                if M28Utilities.IsTableEmpty(tEngineersInZone) == false then
                                    for iPotentialEngineer, oPotentialEngineer in tEngineersInZone do
                                        if M28UnitInfo.IsUnitValid(oPotentialEngineer) then
                                            if oPotentialEngineer[refiAssignedAction] == refActionBuildShield or oPotentialEngineer[refiAssignedAction] == refActionBuildSecondShield or oPotentialEngineer[refiAssignedAction] == refActionAssistShield then
                                                if bDebugMessages == true then LOG(sFunctionRef..': have engineer with action '..oPotentialEngineer[refiAssignedAction]..'; Engineer='..oPotentialEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPotentialEngineer)..'; Focus unit='..(oPotentialEngineer:GetFocusUnit().UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oPotentialEngineer:GetFocusUnit()) or 'nil')) end
                                                if oPotentialEngineer:GetFocusUnit()[refbDontIncludeAsPartCompleteBuildingForConstruction] or oPotentialEngineer:GetFocusUnit()[refiAssignedAction] == refActionSpecialShieldDefence then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will clear engineer orders') end
                                                    M28Orders.IssueTrackedClearCommands(oPotentialEngineer)
                                                end
                                            end
                                        end
                                    end
                                end
                                --Check shield isnt on a priority list to assist
                                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]) == false then
                                    for iCurShieldEntry = table.getn(tLZTeamData[M28Map.reftPriorityShieldsToAssist]), 1, -1 do
                                        if tLZTeamData[M28Map.reftPriorityShieldsToAssist][iCurShieldEntry][refbDontIncludeAsPartCompleteBuildingForConstruction] then
                                            table.remove(tLZTeamData[M28Map.reftPriorityShieldsToAssist], iCurShieldEntry)
                                        end
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering assigned shield oShield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; Fraction complete='..oShield:GetFractionComplete()) end
                            if oShield:GetFractionComplete() == 1 then
                                iConstructedShields = iConstructedShields + 1
                                oLastCompletedShield = oShield
                                iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': COnsidering shield health of constructed shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; iCurShield='..iCurShield..'; iMaxShield='..iMaxShield..'; iLowestConstructedShieldHealth='..iLowestConstructedShieldHealth..'; oUnit.MyShield:GetHealth()='..(oShield.MyShield:GetHealth() or 'nil')..'; Shield ratio='..(oShield:GetShieldRatio(false) or 0)..'; IsUp='..tostring(oShield.MyShield:IsUp())..'; IsOn='..tostring(oShield.MyShield:IsOn())..'; Depleted by damage='..tostring(oShield.DepletedByDamage or false)) end
                                if iCurShield > 0 then iActiveShields = iActiveShields + 1 end
                                if iCurShield < iLowestConstructedShieldHealth then
                                    oLowestConstructedShieldHealth = oShield
                                    iLowestConstructedShieldHealth = iCurShield
                                end
                                if (iCurShield / iMaxShield) > iHighestConstructedShieldHealthPercent then
                                    iHighestConstructedShieldHealthPercent = (iCurShield / iMaxShield)
                                    oHighestConstructedShieldHealth = oShield
                                end
                            else
                                iPartConstructedShields = iPartConstructedShields + 1
                                if oShield:GetFractionComplete() > iHighestPartCompleteShield then
                                    iHighestPartCompleteShield = oShield:GetFractionComplete()
                                    oNearestCompletionShield = oShield
                                end
                                if oShield:GetFractionComplete() < iLowestPartCompleteShield then
                                    iLowestPartCompleteShield = oShield:GetFractionComplete()
                                    oLowestCompletionShield = oShield
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Have a part constructed shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' with fraction compelte '..oShield:GetFractionComplete()..'; oNearestCompletionShield='..(oNearestCompletionShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestCompletionShield) or 'nil')) end
                            end
                        else
                            tiEntriesToRemove[iShield] = true
                        end
                    end
                    if M28Utilities.IsTableEmpty(tiEntriesToRemove) == false then
                        for iEntry, bRemove in tiEntriesToRemove do
                            oUnitToProtect[M28Building.reftoSpecialAssignedShields][iEntry] = nil
                        end
                    end
                end

                function ConstructNewShield()
                    local bProceededWithConstruction = false
                    --Need to construct a new shield (need to be wanting to do this for at least a tick due to delay in constructionstarting triggering due to forked thread)
                    local tPositionToBuild
                    local tAltPositionToBuild
                    local iActionGiven
                    if bDebugMessages == true then LOG(sFunctionRef..': ConstructNewShield: repru of locations for priority shield='..repru(oUnitToProtect[M28Building.reftLocationsForPriorityShield])..'; sLikelyShieldBlueprint='..(sLikelyShieldBlueprint or 'nil')..'; iPreviousAction='..(iPreviousAction or 'nil')..'; oLowestConstructedShieldHealth='..(oLowestConstructedShieldHealth.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oLowestConstructedShieldHealth) or 'nil')..'; ') end

                    for iEntry, tLocation in oUnitToProtect[M28Building.reftLocationsForPriorityShield] do
                        --basic check whether we can build (we should already be able to)
                        if bDebugMessages == true then LOG(sFunctionRef..': Can we build sLikelyShieldBlueprint '..sLikelyShieldBlueprint..' at tLocation '..repru(tLocation)..'='..tostring(aiBrain:CanBuildStructureAt(sLikelyShieldBlueprint, tLocation))) end
                        if aiBrain:CanBuildStructureAt(sLikelyShieldBlueprint, tLocation) then
                            if tPositionToBuild then
                                tAltPositionToBuild = tLocation
                                break
                            else
                                tPositionToBuild = tLocation
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': tPositionToBuild='..repru(tPositionToBuild)) end
                    if tPositionToBuild then
                        local toEngineersOfWrongFaction = {}
                        local oFirstEngineerOfRightFaction
                        local iEngineerBuildOrderCount = 0
                        for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Does this contain the required faction='..tostring(EntityCategoryContains(iEngineerFactionRequired, oEngineer.UnitId))) end
                            if EntityCategoryContains(iEngineerFactionRequired, oEngineer.UnitId) then
                                iEngineerBuildOrderCount = iEngineerBuildOrderCount + 1
                                --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition, oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
                                local sBlueprintToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, iShieldCategoryToBuild, oEngineer, false,  false,          false,          nil,                                false)
                                if bDebugMessages == true then LOG(sFunctionRef..': Checking what shields engineer '..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil')..' can build; iOptionalFactionRequired='..(iOptionalFactionRequired or 'nil')..'; Will try and build unit '..sBlueprintToBuild..' at position '..repru(tPositionToBuild)) end
                                --Have the 4th engineer try to build in the alt location, so if the main location is blocked we may still get construction started
                                if iEngineerBuildOrderCount == 4 and tAltPositionToBuild then
                                    M28Orders.IssueTrackedBuild(oEngineer, tAltPositionToBuild, sBlueprintToBuild, false, 'SpAEBS')
                                else
                                    M28Orders.IssueTrackedBuild(oEngineer, tPositionToBuild, sBlueprintToBuild, false, 'SpEBS')
                                end
                                iActionGiven = refiShieldActionConstruct
                                bProceededWithConstruction = true

                                if not(oFirstEngineerOfRightFaction) then oFirstEngineerOfRightFaction = oEngineer end
                            else
                                table.insert(toEngineersOfWrongFaction, oEngineer)
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished telling engineers of right faction to build, Is table of engineers of wrong faction empty='..tostring(M28Utilities.IsTableEmpty(toEngineersOfWrongFaction))..'; bProceededWithConstruction='..tostring(bProceededWithConstruction)..'; Is oFirstEngineerOfRightFaction nil='..tostring(oFirstEngineerOfRightFaction == nil)) end
                        if M28Utilities.IsTableEmpty(toEngineersOfWrongFaction) == false then
                            if not(oFirstEngineerOfRightFaction) then
                                local bBuildAnyShield = false
                                if bDebugMessages == true then LOG(sFunctionRef..': Do we want to build a shield with wrong faction? Engineers of wrong faction='..table.getn(toEngineersOfWrongFaction)..'; iActiveShields='..iActiveShields..'; oUnitToProtect:GetFractionComplete()='..oUnitToProtect:GetFractionComplete()..'; iHighestConstructedShieldHealthPercent='..iHighestConstructedShieldHealthPercent..'; iConstructedShields='..iConstructedShields) end
                                if (table.getn(toEngineersOfWrongFaction) >= 5 or (iActiveShields == 0 and oUnitToProtect:GetFractionComplete() >= 0.2) or (iHighestConstructedShieldHealthPercent <= 0.5 and iConstructedShields >= 2)) then
                                    if iConstructedShields + iPartConstructedShields <= 1 then bBuildAnyShield = true
                                    elseif iConstructedShields >= 2 and iHighestConstructedShieldHealthPercent <= 0.8 then
                                        bBuildAnyShield = true
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': bBuildAnyShield='..tostring(bBuildAnyShield)) end
                                    if bBuildAnyShield then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have so many engineers of the wrong faction that will just try and get them to build a shield') end
                                        for iEngineer, oEngineer in toEngineersOfWrongFaction do
                                            --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition,                                   oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
                                            local sBlueprintToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryFixedShield * categories.TECH3, oEngineer, false,       false,          false,      nil,                                 false)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Checking what shields engineer '..(oEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineer) or 'nil')..' can build as backup as dont have right faction; iOptionalFactionRequired='..(iOptionalFactionRequired or 'nil')..'; Will try and build unit '..(sBlueprintToBuild or 'nil')..' at position '..repru(tPositionToBuild)) end
                                            if sBlueprintToBuild then
                                                M28Orders.IssueTrackedBuild(oEngineer, tPositionToBuild, sBlueprintToBuild, false, 'SBkEBS')
                                                iActionGiven = refiShieldActionConstruct
                                            end
                                        end
                                        bProceededWithConstruction = true
                                    end
                                end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Will get engineers to assist the one doing the construction') end
                                for iEngineer, oEngineer in toEngineersOfWrongFaction do
                                    --if not(oEngineer == oFirstEngineerOfRightFaction) then
                                    M28Orders.IssueTrackedGuard(oEngineer, oFirstEngineerOfRightFaction, false, 'SpEGE', false)
                                    --end
                                    iActionGiven = refiShieldActionConstruct
                                end
                            end
                        end
                    else
                        M28Utilities.ErrorHandler('We are unable to build at a predefined shield location, will check for small blocking M28 buildings and destroy them', true)
                        --Only search for units that are actually built on the shield location - so e.g. this wont cover if a factory is built where part of the factory covers the shield location
                        local iSearchRadius = M28UnitInfo.GetBuildingSize(sLikelyShieldBlueprint) * 0.5 - 0.49 --even at -0.75 will get units that arent in the build area being included
                        if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through oUnitToProtect[M28Building.reftLocationsForPriorityShield]='..repru(oUnitToProtect[M28Building.reftLocationsForPriorityShield])..'; iSearchRadius='..iSearchRadius..'; iTimeOfLastBlockingBuildingCheck='..(iTimeOfLastBlockingBuildingCheck or 'nil')) end
                        if GetGameTimeSeconds() - (iTimeOfLastBlockingBuildingCheck or -100) >= 5 then
                            iTimeOfLastBlockingBuildingCheck = GetGameTimeSeconds()
                            for iEntry, tLocation in oUnitToProtect[M28Building.reftLocationsForPriorityShield] do
                                local rShieldAreaRect = M28Utilities.GetRectAroundLocation(tLocation, iSearchRadius)
                                local tUnitsNearby = GetUnitsInRect(rShieldAreaRect)
                                local oCurBuildingBP
                                if M28Utilities.IsTableEmpty(tUnitsNearby) == false then
                                    local tBuildingsNearby = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryFixedShield - M28UnitInfo.refCategoryMex - M28UnitInfo.refCategoryHydro, tUnitsNearby)
                                    if M28Utilities.IsTableEmpty(tBuildingsNearby) == false then
                                        --Do we have a shield near her?
                                        local bNearbyShield = false
                                        local tShieldsNearby = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, tUnitsNearby)
                                        if M28Utilities.IsTableEmpty(tShieldsNearby) == false then
                                            --Redundancy - check if have any shields near here and both dont do the kill logic if we do, and also assign such shields to the game ender
                                            for iShield, oShield in tShieldsNearby do
                                                if oShield:GetAIBrain().M28AI and oShield:GetAIBrain().M28Team == iTeam then
                                                    if M28Utilities.GetRoughDistanceBetweenPositions(oShield:GetPosition(), tLocation) <= 4 then
                                                        bNearbyShield = true
                                                        if oShield['OnConstructionStarted'] then
                                                            --We for some reason havent assigned this shield against the game ender so will now
                                                            local oFirstEngineer
                                                            for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                                                                oFirstEngineer = oEngineer
                                                                break
                                                            end
                                                            ForkThread(AssignShieldToGameEnder, oShield, oFirstEngineer)
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                        if not(bNearbyShield) then
                                            for iBuilding, oBuilding in tBuildingsNearby do
                                                if oBuilding:GetAIBrain().M28AI and oBuilding:GetAIBrain().M28Team == aiBrain.M28Team then
                                                    oCurBuildingBP = oBuilding:GetBlueprint()
                                                    if (oCurBuildingBP.Economy.BuildCostMass or 0) * oBuilding:GetFractionComplete() <= 5000 then
                                                        --Check the building position and size means it is actually a blocking building
                                                        if oBuilding:GetPosition()[1] >= rShieldAreaRect[1] and oBuilding:GetPosition()[1] <= rShieldAreaRect[3] and oBuilding:GetPosition()[3] >= rShieldAreaRect[2] and oBuilding:GetPosition()[3] <= rShieldAreaRect[2] and (not(oBuilding[M28UnitInfo.refbCampaignTriggerAdded]) or not(M28Map.bIsCampaignMap)) then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Will destroy blocking building='..oBuilding.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBuilding)..'; Building position='..repru(oBuilding:GetPosition())..'; will draw rectangle that this is within')
                                                                M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tLocation, iSearchRadius))
                                                            end
                                                            M28Orders.IssueTrackedKillUnit(oBuilding)
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    if iActionGiven then
                        iPreviousAction =  iActionGiven
                    end
                    return bProceededWithConstruction
                end

                function AssistShield(oShield)
                    --Assist this (if bPauseEngineers is true then will make sure every engineer is paused so they dont actually complete it)
                    if oShield:GetFractionComplete() < 1 then
                        if bDebugMessages == true then LOG(sFunctionRef..': AssistShield: Will repair shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' with fraction complete '..oShield:GetFractionComplete()) end
                        for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                            --Issue where engineers are given repair order but do nothing - will try adding small delay in case issue is being given same order every tick
                            if GetGameTimeSeconds() - (oEngineer[refiTimeOfLastShieldRepairOrder] or -10) < 1 and oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]][M28Orders.subrefoOrderUnitTarget] == oShield then
                                if bDebugMessages == true then LOG(sFunctionRef..': It has been less than 1s since we last gave order to repair') end
                            else
                                oEngineer[refiTimeOfLastShieldRepairOrder] = GetGameTimeSeconds()
                                if bDebugMessages == true then LOG(sFunctionRef..': Engineer unit state='..M28UnitInfo.GetUnitState(oEngineer)..'; Is state repairing='..tostring(oEngineer:IsUnitState('Repairing'))..'; Engineer work progress='..(oEngineer:GetWorkProgress() or 'nil')) end
                                M28Orders.IssueTrackedRepair(oEngineer, oShield, false, 'SpecShR', false)
                            end
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': AssistShield: Will assist shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' with fraction complete '..oShield:GetFractionComplete()) end
                        for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Giving guard order to oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer))
                                local oFocusUnit = oEngineer:GetFocusUnit()
                                if oFocusUnit then
                                    LOG(sFunctionRef..': Engineer cur focus unit='..oFocusUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFocusUnit))
                                end
                            end
                            M28Orders.IssueTrackedGuard(oEngineer, oShield, false, 'SpecShG', false)
                        end
                    end
                    iPreviousAction =  refiShieldActionAssist
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Deciding what to do, iConstructedShields='..iConstructedShields..'; iPartConstructedShields='..iPartConstructedShields..'; iHighestPartCompleteShield='..iHighestPartCompleteShield..'; iActiveShields='..iActiveShields..'; iTotalAvailableLocations='..iTotalAvailableLocations) end
                if iConstructedShields == 0 then
                    --Want to build a shield - complete the closest to completion if we have any
                    if oNearestCompletionShield then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to construct a shield, will assist the one nearest completion='..oNearestCompletionShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestCompletionShield)..' fraction complete='..oNearestCompletionShield:GetFractionComplete()) end
                        AssistShield(oNearestCompletionShield)
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to construct a shield, none under construction so will build a new one') end
                        ConstructNewShield()
                    end
                else
                    --We already have 1 constructed shield, want to make sure we have another shield that is closest to completion next
                    --% wanted - if are assigning 500 build power to this, and the shortest BT shield is 1250, then in theory we could end up building the shield in 0.4s, i.e. each tick would be 4%.  In reality this seems unlikely though
                    local iPercentCompleteWanted
                    local iTotalBuildPowerAvailable = 0
                    for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                        iTotalBuildPowerAvailable = iTotalBuildPowerAvailable + oEngineer:GetBlueprint().Economy.BuildRate
                    end
                    if aiBrain.M28AI then
                        iTotalBuildPowerAvailable = iTotalBuildPowerAvailable * M28Team.tTeamData[aiBrain.M28Team][M28Team.refiHighestBrainBuildMultiplier]
                    end
                    --Treat build power as being 50% more than it actually is to give a bit more leeway
                    iPercentCompleteWanted = math.min(0.99, math.max(0.8, 1 - iTotalBuildPowerAvailable * 2.5 / (iBlueprintBuildTime * 10) - 0.002))
                    if iPartConstructedShields > 0 and iHighestPartCompleteShield < iPercentCompleteWanted then
                        --Want to assist existing part complete shield
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to assist existing part complete shield as it isnt near complete yet, iPercentCompleteWanted='..iPercentCompleteWanted..'; oNearestCompletionShield='..oNearestCompletionShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestCompletionShield)..'; Fraction complete='..oNearestCompletionShield:GetFractionComplete()) end
                        AssistShield(oNearestCompletionShield)
                    else
                        --We have at least 1 constructed shield, and at least 1 shield whose % complete is at the level wanted; Therefore we want a 3rd shield that is near-complete constructed
                        if iPartConstructedShields + iConstructedShields < iTotalAvailableLocations and ConstructNewShield() then
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to build a new shiled as we have more available locations than we have shields built or started building') end
                        else
                            --Get the lowest complete shield to assist if it needs it
                            if iPartConstructedShields > 0 and (iLowestPartCompleteShield < iPercentCompleteWanted or iActiveShields == 0) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to assist the lowest complete shield as it isnt nearly done, oLowestCompletionShield='..oLowestCompletionShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLowestCompletionShield)..'; Fraction complete='..oLowestCompletionShield:GetFractionComplete()) end
                                AssistShield(oLowestCompletionShield)
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Checking if weant to ctrlK a shield, iPartConstructedShields='..iPartConstructedShields..'; iConstructedShields='..iConstructedShields) end
                                if iPartConstructedShields == 0 and iConstructedShields >= 2 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to ctrlK a shield so can rebuild') end
                                    if oLowestConstructedShieldHealth and (not(oLowestConstructedShieldHealth[M28UnitInfo.refbCampaignTriggerAdded]) or not(M28Map.bIsCampaignMap)) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will ctrlK shield '..oLowestConstructedShieldHealth.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLowestConstructedShieldHealth)) end
                                        M28Orders.IssueTrackedKillUnit(oLowestConstructedShieldHealth)
                                        --Clear assisting engineers in case they are assisting a part-complete shield that we want to stop
                                        if iPreviousAction == refiShieldActionAssist then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Previous action was to assist shield so will clear all engineerse that have a previous action being to assist a shield so they dont finish a part complete shield') end
                                            for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                                                M28Orders.IssueTrackedClearCommands(oEngineer)
                                            end
                                        end
                                    else
                                        local bAssistUnitToProtectInstead = false
                                        if oUnitToProtect:GetFractionComplete() < 1 and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) then
                                            local iCurHealth, iMaxHealth = M28UnitInfo. GetCurrentAndMaximumShield(oLastCompletedShield, true)
                                            if iCurHealth > iMaxHealth * 0.9 then
                                                bAssistUnitToProtectInstead = true
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Unable to find shield to kill so will default to assisting last compelted shield, bAssistUnitToProtectInstead='..bAssistUnitToProtectInstead) end
                                        if bAssistUnitToProtectInstead then
                                            AssistShield(oUnitToProtect)
                                        else
                                            AssistShield(oLastCompletedShield)
                                        end
                                    end
                                else
                                    --We have 1 complete shield, and all other shield locations have near-complete shields, so dont want to do anything else - have the engineers assist the completed shield, unless it has >80% shield health and the unit to protect isnt completed yet
                                    local bAssistUnitToProtectInstead = false
                                    if oUnitToProtect:GetFractionComplete() < 1 and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) then
                                        local iCurHealth, iMaxHealth = M28UnitInfo. GetCurrentAndMaximumShield(oLastCompletedShield, true)
                                        if iCurHealth > iMaxHealth * 0.9 then
                                            bAssistUnitToProtectInstead = true
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Nothing to do so will assist a complete shield unless want to assist underconstruction gameender, oLastCompletedShield='..oLastCompletedShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oLastCompletedShield)..'; bAssistUnitToProtectInstead='..tostring(bAssistUnitToProtectInstead)) end
                                    if bAssistUnitToProtectInstead then
                                        AssistShield(oUnitToProtect)
                                    else
                                        AssistShield(oLastCompletedShield)
                                    end
                                end
                            end
                        end
                    end
                end

                --Decide whether to ctrlK shield so can start building another
                if iConstructedShields >= math.max(iTotalAvailableLocations, 2) or (iConstructedShields > 1 and iConstructedShields + iPartConstructedShields >= iTotalAvailableLocations and iActiveShields < iConstructedShields) and (not(oLowestConstructedShieldHealth[M28UnitInfo.refbCampaignTriggerAdded]) or not(M28Map.bIsCampaignMap)) then
                    --CtrlK a completed shield with the lowest shield value
                    if bDebugMessages == true then LOG(sFunctionRef..': iConstructedShields='..iConstructedShields..'; iTotalAvailableLocations='..iTotalAvailableLocations..'; iConstructedShields='..iConstructedShields..'; iPartConstructedShields='..iPartConstructedShields..'; iActiveShields='..iActiveShields..'; iLowestConstructedShieldHealth='..(iLowestConstructedShieldHealth or 'nil')) end
                    M28Orders.IssueTrackedKillUnit(oLowestConstructedShieldHealth)
                end

                --Make sure engineers show the action they have been assigned (as will have had orders cleared from above) - changed so will no longer clear in M28Orders
                --[[local bFirstEngineer = true
                for iEngineer, oEngineer in oUnitToProtect[reftEngineersActivelyShielding] do
                    if not(oEngineer[refiAssignedAction] == refActionSpecialShieldDefence) then
                        TrackEngineerAction(oEngineer, refActionSpecialShieldDefence, bFirstEngineer, iPriorityToUse)
                        if bFirstEngineer then bFirstEngineer = false end
                    end
                end--]]


            else
                if bDebugMessages == true then LOG(sFunctionRef..': Engineers no longer actively shielding, will end the loop at time '..GetGameTimeSeconds()) end
                oUnitToProtect[refbActiveUnitShieldingThread] = false
                break
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        if M28Utilities.IsTableEmpty(oUnitToProtect[reftEngineersActivelyShielding]) == false then
            local tEngisToClear = {}
            for iEngi, oEngi in oUnitToProtect[reftEngineersActivelyShielding] do
                if M28UnitInfo.IsUnitValid(oEngi) then
                    table.insert(tEngisToClear, oEngi)
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is tEngisToClear empty='..tostring(tEngisToClear)) end
            if M28Utilities.IsTableEmpty(tEngisToClear) == false then
                for iEngi, oEngi in tEngisToClear do
                    M28Orders.IssueTrackedClearCommands(oEngi)
                    ClearEngineerTracking(oEngi)
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code at time '..GetGameTimeSeconds()..'; Is game ender valid='..tostring(M28UnitInfo.IsUnitValid(oUnitToProtect) or false)..'; ActiveShieldMonitoe='..tostring(oUnitToProtect[refbActiveUnitShieldingThread] or false)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AssignEngineerToShieldDefenceDuty(oEngineer, tLZTeamData)
    --Get the highest value unit to defend (for now will only support 1 unit for shield defence duty)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignEngineerToShieldDefenceDuty'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local oUnitToProtect
    local iHighestMassValue = 0
    local iCurMassValue
    local iUnitToProtectEntry
    for iGameEnder, oGameEnder in tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
        if M28UnitInfo.IsUnitValid(oGameEnder) then
            iCurMassValue = oGameEnder:GetBlueprint().Economy.BuildCostMass * oGameEnder:GetFractionComplete()
            if iCurMassValue > iHighestMassValue then
                iHighestMassValue = iCurMassValue
                oUnitToProtect = oGameEnder
                iUnitToProtectEntry = iGameEnder
            end
        end
    end
    if oUnitToProtect and oUnitToProtect[M28Building.reftArtiTemplateRefs] then
        oUnitToProtect = nil
        table.remove(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection], iUnitToProtectEntry)
        if bDebugMessages == true then LOG(sFunctionRef..': Have a gameender flagged as wanting special shielding, will cancel as it is part of a GE template') end
    end
    if not(oUnitToProtect) then
        --Clear engineer actions as we dont have something for them to do after all
        ClearEngineerTracking(oEngineer)
    else
        if not(oUnitToProtect[reftEngineersActivelyShielding]) then oUnitToProtect[reftEngineersActivelyShielding] = {} end
        table.insert(oUnitToProtect[reftEngineersActivelyShielding], oEngineer)
        oEngineer[refoUnitActivelyShielding] = oUnitToProtect
        if not(oUnitToProtect[refbActiveUnitShieldingThread]) then
            ForkThread(ActiveShieldMonitor, oUnitToProtect, tLZTeamData, oEngineer:GetAIBrain().M28Team)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function GETemplateReassessGameEnderCategory(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam, tTableRef, oFirstAeon, oFirstSeraphim, oFirstUEF, oFirstCybran, oFirstEngineer, bWantToChangeDueToNovax)
    local sFunctionRef = 'GETemplateReassessGameEnderCategory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if not(oFirstUEF) and M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryNovaxCentre, tLZTeamData[M28Map.refiLastGameEnderTemplateCategory]) then
        --Switch from novax to T3 arti (or gameender if enemy base is very far away)
        if bDebugMessages == true then LOG(sFunctionRef..': we dont have a UEF engi but our category includes novax, will include T3 arti if enemy base is close, otherwise will include gameender') end
        if M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 750 then
            tLZTeamData[M28Map.refiLastGameEnderTemplateCategory] = M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryNovaxCentre
        else
            tLZTeamData[M28Map.refiLastGameEnderTemplateCategory] = M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryNovaxCentre
        end
    elseif not(oFirstSeraphim) and M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategorySML, tLZTeamData[M28Map.refiLastGameEnderTemplateCategory]) then
        --Switch from yolona to gameender
        if bDebugMessages == true then LOG(sFunctionRef..': will expand from building SML to building any gameender as we lack a seraphim engi') end
        tLZTeamData[M28Map.refiLastGameEnderTemplateCategory] = M28UnitInfo.refCategoryGameEnder
    elseif not(oFirstAeon) and M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryParagon, tLZTeamData[M28Map.refiLastGameEnderTemplateCategory]) then
        if bDebugMessages == true then LOG(sFunctionRef..': Will expand from building paragon to building any gameender') end
        tLZTeamData[M28Map.refiLastGameEnderTemplateCategory] = M28UnitInfo.refCategoryGameEnder
    else
        --Set to T3 arti or gameender (include novax if we have no existing arti)
        if M28Utilities.IsTableEmpty(tTableRef[M28Map.subrefGEArtiUnits]) then
            if bDebugMessages == true then LOG(sFunctionRef..': No existing arti units so will cover t3 arti gameender and novax') end
            tLZTeamData[M28Map.refiLastGameEnderTemplateCategory] = M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryNovaxCentre
        else
            --If we have a novax built, then get T3 arti if enemy base is close
            if bDebugMessages == true then LOG(sFunctionRef..': We already have an arti type unit so will build t3 arti if enemy close, or t3 arti and gameender otherwise') end
            if bWantToChangeDueToNovax and M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 750 then
                tLZTeamData[M28Map.refiLastGameEnderTemplateCategory] = M28UnitInfo.refCategoryFixedT3Arti
            else
                tLZTeamData[M28Map.refiLastGameEnderTemplateCategory] = M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryGameEnder
            end
        end
    end

    --Exclude paragon if we have high mass
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= math.min(800, math.max(350, 150 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier])) then
        if bDebugMessages == true then LOG(sFunctionRef..': Want to exclude paragon as we have lots of mass') end
        tLZTeamData[M28Map.refiLastGameEnderTemplateCategory] = tLZTeamData[M28Map.refiLastGameEnderTemplateCategory] - M28UnitInfo.refCategoryParagon
    end


    --Check - can our first engineer build units of the desired category? If not then change the category to be an experimental level unit as we might have unit restrictions preventing this
    if oFirstEngineer then
        local aiBrain = oFirstEngineer:GetAIBrain()
        local sArtiToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, tLZTeamData[M28Map.refiLastGameEnderTemplateCategory], oFirstEngineer)
        if not(sArtiToBuild) then tLZTeamData[M28Map.refiLastGameEnderTemplateCategory] = M28UnitInfo.refCategoryExperimentalLevel - categories.NAVAL
            M28Team.tTeamData[aiBrain.M28Team][M28Team.refbUnableToBuildArtiOrGameEnders] = true
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function GETemplateStartBuildingArtiOrGameEnder(tAvailableEngineers, tAvailableT3EngineersByFaction, tLZData, tLZTeamData, iPlateau, iLandZone, iTeam, tTableRef, iTableRef, oFirstAeon, oFirstSeraphim, oFirstUEF, oFirstCybran, oFirstEngineer)
    --Decide on the arti blueprint we want to try and build; priority to use:
    --Aeon (Paragon and T3 arti) > Seraphim (Yolona) > UEF (Mavor) > Cybran (Scathis)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GETemplateStartBuildingArtiOrGameEnder'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bTriedBuildingSomething = false

    if bDebugMessages == true then LOG(sFunctionRef..': Start of logic for building arti at zone '..iLandZone..', is tAvailableEngineers empty='..tostring(M28Utilities.IsTableEmpty(tAvailableEngineers))..'; Arti locations='..repru(tTableRef[M28Map.subrefGEArtiLocations])) end
    local sArtiToBuild = nil
    local aiBrain
    local oEngineerToBuild
    if oFirstAeon then
        aiBrain = oFirstAeon:GetAIBrain()
        oEngineerToBuild = oFirstAeon
                                --GetBlueprintThatCanBuildOfCategory(aiBrain, iCategoryCondition,                                    oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences, iOptionalMaxSkirtSize)
        sArtiToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, tLZTeamData[M28Map.refiLastGameEnderTemplateCategory], oFirstAeon,    nil,        nil,        nil,            nil,                                nil,                    10)
    end
    if not(sArtiToBuild) then
        if oFirstSeraphim then
            aiBrain = oFirstSeraphim:GetAIBrain()
            sArtiToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, tLZTeamData[M28Map.refiLastGameEnderTemplateCategory], oFirstSeraphim,    nil,        nil,        nil,            nil,                                nil,                    10)
            oEngineerToBuild = oFirstSeraphim
        end
        if not(sArtiToBuild) then
            if oFirstUEF then
                aiBrain = oFirstUEF:GetAIBrain()
                sArtiToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, tLZTeamData[M28Map.refiLastGameEnderTemplateCategory], oFirstUEF,    nil,        nil,        nil,            nil,                                nil,                    10)
                oEngineerToBuild = oFirstUEF
            end
            if not(sArtiToBuild) then
                if oFirstCybran then
                    aiBrain = oFirstCybran:GetAIBrain()
                    sArtiToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, tLZTeamData[M28Map.refiLastGameEnderTemplateCategory], oFirstCybran,    nil,        nil,        nil,            nil,                                nil,                    10)
                    oEngineerToBuild = oFirstCybran
                end
                if not(sArtiToBuild) then
                    if oFirstEngineer then
                        aiBrain = oFirstEngineer:GetAIBrain()
                        sArtiToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, tLZTeamData[M28Map.refiLastGameEnderTemplateCategory], oFirstEngineer,    nil,        nil,        nil,            nil,                                nil,                    10)
                        oEngineerToBuild = oFirstEngineer
                    end
                end
            end
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef..': sArtiToBuild before considering engi last order='..(sArtiToBuild or 'nil')..'; oEngineerToBuild='..(oEngineerToBuild.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineerToBuild) or 'nil')..'; iCyclesWaitingForEngineer='..(tTableRef[M28Map.subrefiCyclesWaitingForEngineer] or 'nil')..'; Is table of available engineers empty='..tostring(M28Utilities.IsTableEmpty(tAvailableEngineers))..'; Time='..GetGameTimeSeconds())
        if sArtiToBuild then
            local tBlueprints = EntityCategoryGetUnitList(tLZTeamData[M28Map.refiLastGameEnderTemplateCategory])
            LOG(sFunctionRef..': All blueprints that meet GE template category:')
            for iEntry, sBlueprint in tBlueprints do
                LOG('Blueprint '..sBlueprint..': '..(__blueprints[sBlueprint].General.UnitName or 'nil'))
            end
        end
    end
    if sArtiToBuild and oEngineerToBuild then
        local sLastBlueprint = oEngineerToBuild[M28Orders.reftiLastOrders][oEngineerToBuild[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] or 'nil'
        if sLastBlueprint and not(sLastBlueprint == sArtiToBuild) and EntityCategoryContains(tLZTeamData[M28Map.refiLastGameEnderTemplateCategory], sLastBlueprint) then
            sArtiToBuild = sLastBlueprint
            if bDebugMessages == true then LOG(sFunctionRef..': engi last blueprint was different, but also met the category, sLastBlueprint='..sLastBlueprint..'; so will change what to build to this') end
        end

        tTableRef[M28Map.subrefiCyclesWaitingForEngineer] = 0
        --Is either of the arti locations available? If not then need to reclaim any buildings there (assuming we dont have a T3 arti there)
        local iBuildingSize = M28UnitInfo.GetBuildingSize(sArtiToBuild)
        local tLocationToBuild
        for iEntry, tBuildLocation in tTableRef[M28Map.subrefGEArtiLocations] do
            if aiBrain:CanBuildStructureAt(sArtiToBuild, tBuildLocation) then
                tLocationToBuild = {tBuildLocation[1], tBuildLocation[2],tBuildLocation[3]}
                break
            end
        end
        if not(tLocationToBuild) then
            --Look to reclaim buildings that are blocking us, unless they are very high value buildings
            local iLowestValueBlockingBuildings = 150000 --basic threshold to prevent reclaiming really high value buildings
            local tLowestValueBlockingBuildings, iCurValueBlockingBuildings, iLowestValueRef
            local bHavePotentiallyValidLocation = false
            local tUnitsToConsiderReclaiming
            for iEntry, tBuildLocation in tTableRef[M28Map.subrefGEArtiLocations] do
                local tBlockingUnits = GetUnitsInRect(M28Utilities.GetRectAroundLocation(tBuildLocation, iBuildingSize * 0.5 - 0.3)) --tried with -0.7 but wouldnt pickup on SAM that was just inside the shield build area
                if not(tBlockingUnits) then
                    M28Utilities.ErrorHandler('Tempalte location cant be built on but has no units in it')
                else
                    local tBlockingUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryWall, tBlockingUnits)
                    if M28Utilities.IsTableEmpty(tBlockingUnits) then
                        M28Utilities.ErrorHandler('Template location cant be built on but has no buildings in it')
                    else
                        tUnitsToConsiderReclaiming = {}
                        for iUnit, oUnit in tBlockingUnits do
                            if M28UnitInfo.IsUnitValid(oUnit) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering potentially blocking unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Dist to arti position='..M28Utilities.GetDistanceBetweenPositions(tBuildLocation, oUnit:GetPosition())..'; Fraction complete='..oUnit:GetFractionComplete()) end
                                if oUnit[M28Building.reftArtiTemplateRefs] then
                                    --Do nothing, and stop looking
                                    tUnitsToConsiderReclaiming = nil
                                    break
                                elseif EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnit.UnitId) and (oUnit:GetFractionComplete() >= 0.05 or oUnit:GetHealth() >= 500 or M28Utilities.GetDistanceBetweenPositions(tBuildLocation, oUnit:GetPosition()) <= 1.5) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have an experimental level unit that might be blocking, if it is close then will record') end
                                    if M28Utilities.GetDistanceBetweenPositions(tBuildLocation, oUnit:GetPosition()) <= 3 then
                                        oUnit[M28Building.reftArtiTemplateRefs] = {iPlateau, iLandZone, iTableRef}
                                        local bAdd = true
                                        if M28Utilities.IsTableEmpty(tTableRef[M28Map.subrefGEArtiUnits]) == false then
                                            for iRecorded, oRecorded in tTableRef[M28Map.subrefGEArtiUnits] do
                                                if oRecorded == oUnit then bAdd = false break end
                                            end
                                        end
                                        if bAdd then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Adding blocking arti unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of arti units for P'..iPlateau..'Z'..iLandZone..'T'..iTableRef) end
                                            table.insert(tTableRef[M28Map.subrefGEArtiUnits], oUnit)
                                        end
                                    end
                                    tUnitsToConsiderReclaiming = nil
                                    break

                                else
                                    table.insert(tUnitsToConsiderReclaiming, oUnit)
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(tUnitsToConsiderReclaiming) == false then
                            iCurValueBlockingBuildings = M28UnitInfo.GetCombatThreatRating(tUnitsToConsiderReclaiming, false, true)
                            if iCurValueBlockingBuildings < iLowestValueBlockingBuildings then
                                iLowestValueBlockingBuildings = iCurValueBlockingBuildings
                                tLowestValueBlockingBuildings = tUnitsToConsiderReclaiming
                                iLowestValueRef = iEntry
                                bHavePotentiallyValidLocation = true
                            end
                        end
                    end
                end
            end
            if bHavePotentiallyValidLocation then
                tTableRef[M28Map.subrefbFailedToGetArtiLocation] = false
                --Get all engineers to reclaim the units here
                local oUnitToReclaim = tLowestValueBlockingBuildings[1]
                CheckAndClearEngineersConstructingTargetUnit(oUnitToReclaim, tLZTeamData)
                for iEngineer, oEngineer in tAvailableEngineers do
                    if oEngineer[M28UnitInfo.refbPaused] then M28UnitInfo.PauseOrUnpauseEnergyUsage(oEngineer, false) end
                    M28Orders.IssueTrackedReclaim(oEngineer, oUnitToReclaim, false, 'GERecl', false)
                end
                tAvailableEngineers = nil
                tAvailableT3EngineersByFaction = nil
                if bDebugMessages == true then LOG(sFunctionRef..': Want engineers to reclaim blocking unit '..oUnitToReclaim.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToReclaim)) end
            else
                --Dont have a valid location, so need to come up with some redundancy logic, e.g. clear engis and flag that we mustn't try and use this location again, unless we already have an arti unit
                --e.g. have a flag on the index; and then when creating an index first check we dont already have an index; and then update the function for considering if we have available locations
                tTableRef[M28Map.subrefbFailedToGetArtiLocation] = true
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': oEngineerToBuild='..(oEngineerToBuild.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineerToBuild) or 'nil')..'; Is table of tAvailableEngineers empty='..tostring(M28Utilities.IsTableEmpty(tAvailableEngineers))) end
            --We have a location to build - get 1 engineer to build (the others can build a shield)
            for iEngineer, oEngineer in tAvailableEngineers do
                if oEngineer == oEngineerToBuild then
                    table.remove(tAvailableEngineers, iEngineer)
                    if bDebugMessages == true then LOG(sFunctionRef..': Removing engineer from table of engineers by faction if it isnt empty, faction='..(M28UnitInfo.GetFactionNumberFromBlueprint(oEngineer.UnitId) or 'nil')..'; Engineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Is tAvailableT3EngineersByFaction empty='..tostring(M28Utilities.IsTableEmpty(tAvailableT3EngineersByFaction))..'; Is tAvailableT3EngineersByFaction for faction empty='..tostring(M28Utilities.IsTableEmpty(tAvailableT3EngineersByFaction[M28UnitInfo.GetFactionNumberFromBlueprint(oEngineer.UnitId)]))) end
                    table.remove(tAvailableT3EngineersByFaction[M28UnitInfo.GetFactionNumberFromBlueprint(oEngineer.UnitId)], 1)
                    break
                end
            end

            local tMoveLocation = GetLocationToMoveForConstruction(oEngineerToBuild, tLocationToBuild, sArtiToBuild, 0, false)
            if tMoveLocation and (oEngineerToBuild[M28Conditions.refiEngineerStuckCheckCount] or 0) <= 10 then
                if bDebugMessages == true then LOG(sFunctionRef..': GE Telling engineer '..oEngineerToBuild.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineerToBuild)..' to move to '..repru(tMoveLocation)..' and then build '..sArtiToBuild..' at location '..repru(tLocationToBuild)..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTableRef='..iTableRef) end
                M28Orders.IssueTrackedMoveAndBuild(oEngineerToBuild, tLocationToBuild, sArtiToBuild, tMoveLocation, 1, false, 'GEMBArtT'..iTableRef)
                bTriedBuildingSomething = true
                if M28Utilities.GetDistanceBetweenPositions(oEngineerToBuild:GetPosition(), tMoveLocation) <= 2 then oEngineerToBuild[M28Conditions.refiEngineerStuckCheckCount] = (oEngineerToBuild[M28Conditions.refiEngineerStuckCheckCount] or 0) + 1 end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': GE Telling engineer '..oEngineerToBuild.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineerToBuild)..' to build '..sArtiToBuild..' at build location '..repru(tLocationToBuild)..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTableRef='..iTableRef) end
                ConsiderResettingGEEngineerJustBeforeGivingNewOrder(oEngineerToBuild)
                M28Orders.IssueTrackedBuild(oEngineerToBuild, tLocationToBuild, sArtiToBuild, false, 'GEBArt')
                bTriedBuildingSomething = true
            end
            if oEngineerToBuild[M28UnitInfo.refbPaused] then M28UnitInfo.PauseOrUnpauseEnergyUsage(oEngineerToBuild, false) end
            oEngineerToBuild[refbPrimaryBuilder] = true
            if not(oEngineerToBuild[M28Building.reftArtiTemplateRefs][3] == iTableRef) or not( oEngineerToBuild[M28Building.reftArtiTemplateRefs][2] == iLandZone) then oEngineerToBuild[M28Building.reftArtiTemplateRefs] = {iPlateau, iLandZone, iTableRef} end --Redundancy
        end
    else
        tTableRef[M28Map.subrefiCyclesWaitingForEngineer] = (tTableRef[M28Map.subrefiCyclesWaitingForEngineer] or 0) + 1
        if tTableRef[M28Map.subrefiCyclesWaitingForEngineer] >= 15 and oFirstEngineer then
            --Reevaluate what gameender or T3 arti unit we want
            GETemplateReassessGameEnderCategory(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam, tTableRef, oFirstAeon, oFirstSeraphim, oFirstUEF, oFirstCybran, oFirstEngineer)

            tTableRef[M28Map.subrefiCyclesWaitingForEngineer] = 0
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bTriedBuildingSomething
end

function GETemplateAssistUnit(tAvailableEngineers, tAvailableT3EngineersByFaction, iTableRef, oUnit, iOptionalMax)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GETemplateAssistUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCurEntry = 0
    if oUnit:GetFractionComplete() < 1 then
        if iOptionalMax then
            --Check if any existing engineers are building the unit, and if so then have the first one of them as the first engineer (so we keep building with the unit that started construction)
            for iEngineer, oEngineer in tAvailableEngineers do
                if oEngineer:GetFocusUnit() == oUnit then
                    M28Orders.IssueTrackedRepair(oEngineer, oUnit, false, 'GEFRepT'..iTableRef, false)
                    iCurEntry = iCurEntry + 1
                    if iCurEntry == 1 then oEngineer[refbPrimaryBuilder] = true else oEngineer[refbPrimaryBuilder] = false end
                    table.remove(tAvailableEngineers, iEngineer)
                    local iFactionRef = M28UnitInfo.GetFactionNumberFromBlueprint(oEngineer.UnitId)
                    if M28Utilities.IsTableEmpty( tAvailableT3EngineersByFaction[iFactionRef]) == false then
                        for iFactionEngi, oFactionEngi in tAvailableT3EngineersByFaction[iFactionRef] do
                            if oFactionEngi == oEngineer then
                                table.remove(tAvailableT3EngineersByFaction[iFactionRef], iFactionEngi)
                                break
                            end
                        end
                    end
                    break
                end
            end
        end
        if not(iOptionalMax) or iCurEntry < iOptionalMax then
            for iEngineer, oEngineer in tAvailableEngineers do
                M28Orders.IssueTrackedRepair(oEngineer, oUnit, false, 'GERepT'..iTableRef, false)
                if iOptionalMax then
                    iCurEntry = iCurEntry + 1
                    if iCurEntry == 1 then oEngineer[refbPrimaryBuilder] = true else oEngineer[refbPrimaryBuilder] = false end
                    if iCurEntry >= iOptionalMax then break end
                end
            end
        end
    else
        for iEngineer, oEngineer in tAvailableEngineers do
            M28Orders.IssueTrackedGuard(oEngineer, oUnit, false, 'GEAssT'..iTableRef, false)
            if iOptionalMax then
                iCurEntry = iCurEntry + 1
                if iCurEntry == 1 then oEngineer[refbPrimaryBuilder] = true else oEngineer[refbPrimaryBuilder] = false end
                if iCurEntry >= iOptionalMax then break end
            end
        end
    end
    if iOptionalMax then
        for iCurEngi = iCurEntry, 1, -1 do
            local oEngineer = tAvailableEngineers[iCurEngi]
            local iFactionRef = M28UnitInfo.GetFactionNumberFromBlueprint(oEngineer.UnitId)
            if M28Utilities.IsTableEmpty(tAvailableT3EngineersByFaction[iFactionRef]) == false then
                for iFactionEngi, oFactionEngi in tAvailableT3EngineersByFaction[iFactionRef] do
                    if oFactionEngi == oEngineer then
                        table.remove(tAvailableT3EngineersByFaction[iFactionRef], iFactionEngi)
                        break
                    end
                end
            end

            table.remove(tAvailableEngineers, iCurEngi)
        end
    else
        tAvailableEngineers = nil
        tAvailableT3EngineersByFaction = nil
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderResettingGEEngineerJustBeforeGivingNewOrder(oEngineerToBuild)
    oEngineerToBuild[refiGETemplateTimeTryingToBuild] = (oEngineerToBuild[refiGETemplateTimeTryingToBuild] or 0) + 1
    if oEngineerToBuild[refiGETemplateTimeTryingToBuild] >= 15 then
        M28Orders.IssueTrackedClearCommands(oEngineerToBuild)
        oEngineerToBuild[refiGETemplateTimeTryingToBuild] = 0
    end
end

function GETemplateStartBuildingShield(tAvailableEngineers, tAvailableT3EngineersByFaction, tLZTeamData, iPlateau, iLandZone, tTableRef, iTemplateRef, oFirstAeon, oFirstSeraphim, oFirstUEF, oFirstCybran, oFirstEngineer, iMaxShieldsToTryAndBuild, iOptionalMaxEngiPerAction, bOnlyGetT3)
    --Decide on the arti blueprint we want to try and build; priority to use:
    --Aeon (Paragon and T3 arti) > Seraphim (Yolona) > UEF (Mavor) > Cybran (Scathis)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GETemplateStartBuildingShield'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bTriedBuildingSomething = false

    local sShieldToBuild = nil
    local aiBrain
    local oEngineerToBuild
    local iShieldCategoryToBuild
    if bOnlyGetT3 then
        iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.TECH3 * categories.SIZE12 --e.g. for mods that add experimental shields we are unlikely to want more than 2 exp shields
    else
        iShieldCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.SIZE12
    end

    local iFactionRef
    if oFirstSeraphim then
        aiBrain = oFirstSeraphim:GetAIBrain()
        iFactionRef = M28UnitInfo.refFactionSeraphim
        oEngineerToBuild = tAvailableT3EngineersByFaction[iFactionRef][1]
        if oEngineerToBuild then
            sShieldToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, iShieldCategoryToBuild, oEngineerToBuild)
        end

    end
    if not(sShieldToBuild) then
        if oFirstUEF then
            aiBrain = oFirstUEF:GetAIBrain()
            iFactionRef = M28UnitInfo.refFactionUEF
            oEngineerToBuild = tAvailableT3EngineersByFaction[iFactionRef][1]
            if oEngineerToBuild then
                sShieldToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, iShieldCategoryToBuild, oEngineerToBuild)
            end
        end
        if not(sShieldToBuild) then
            if oFirstAeon then
                aiBrain = oFirstAeon:GetAIBrain()
                iFactionRef = M28UnitInfo.refFactionAeon
                oEngineerToBuild = tAvailableT3EngineersByFaction[iFactionRef][1]
                if oEngineerToBuild then
                    sShieldToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, iShieldCategoryToBuild, oEngineerToBuild)
                end
            end
            if not(sShieldToBuild) then
                if oFirstCybran then
                    aiBrain = oFirstCybran:GetAIBrain()
                    iFactionRef = M28UnitInfo.refFactionCybran
                    oEngineerToBuild = tAvailableT3EngineersByFaction[iFactionRef][1]
                    if oEngineerToBuild then
                        sShieldToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, iShieldCategoryToBuild, oEngineerToBuild)
                    end
                end
                if not(sShieldToBuild) then
                    if oFirstEngineer then
                        aiBrain = oFirstEngineer:GetAIBrain()
                        oEngineerToBuild = oFirstEngineer
                        if oEngineerToBuild then
                            sShieldToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, iShieldCategoryToBuild, oEngineerToBuild)
                        end
                    end
                end
            end
        end
    end
    local tEngisOfDesiredFaction = tAvailableT3EngineersByFaction[iFactionRef]
    if bDebugMessages == true then LOG(sFunctionRef..': dealing with iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; sShieldToBuild='..(sShieldToBuild or 'nil')..'; oEngineerToBuild='..(oEngineerToBuild.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oEngineerToBuild) or 'nil')) end
    if sShieldToBuild and oEngineerToBuild then
        local sLastBlueprint = oEngineerToBuild[M28Orders.reftiLastOrders][oEngineerToBuild[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] or 'nil'
        if sLastBlueprint and not(sLastBlueprint == sShieldToBuild) and EntityCategoryContains(iShieldCategoryToBuild, sLastBlueprint) then
            sShieldToBuild = sLastBlueprint
            if bDebugMessages == true then LOG(sFunctionRef..': engi last blueprint was different, but also met the desired shield category, sLastBlueprint='..sLastBlueprint..'; so will change what to build to this') end
        end


        --Scenarios where we have 2 arti locations but our shield radius is too small - dont want to build on the 7th shield location, but instead want to build on the arti location
        local bUseArtiInsteadOfLastShieldLocation = false
        local tbShieldEntiresNotToConsider = {}

        if __blueprints[sShieldToBuild].Defense.ShieldSize <= 37 and table.getn(tTableRef[M28Map.subrefGEArtiLocations]) >= 2 and not(oFirstUEF) and not(oFirstSeraphim) then
            --Only want to build aeon/cybran shields in the 'middle' locations (where they cover both game-enders and all other shields), outer shields will need to be UEF/Seraphim
            tbShieldEntiresNotToConsider = {[1]=true,[2]=true,[5]=true,[6]=true,[8]=true}
            --Flag we want UEF and sera engineers
            if not(tLZTeamData[M28Map.subreftbBPByFactionWanted]) then tLZTeamData[M28Map.subreftbBPByFactionWanted] = {} end
            if not(oFirstUEF) then
                tLZTeamData[M28Map.subreftbBPByFactionWanted][M28UnitInfo.refFactionUEF] = true
                if bDebugMessages == true then LOG(sFunctionRef..': Flagging that we want UEF engineers for zone '..iLandZone) end
            end
            if not(oFirstSeraphim) then
                tLZTeamData[M28Map.subreftbBPByFactionWanted][M28UnitInfo.refFactionSeraphim] = true
                if bDebugMessages == true then LOG(sFunctionRef..': Flagging that we want Seraphim engineers for zone '..iLandZone) end
            end

            --Look for a factory to build the engineers that we want
            if M28Utilities.IsTableEmpty(tTableRef[M28Map.subrefGEArtiUnits]) == false then
                for iArti, oArti in tTableRef[M28Map.subrefGEArtiUnits] do
                    if not(M28UnitInfo.IsUnitValid(oArti[M28Building.refoNearbyFactoryOfFaction])) then
                        M28Building.RecordNearbyFactoryForShieldEngineers(oArti, { [M28UnitInfo.refFactionUEF] = true, [M28UnitInfo.refFactionSeraphim] = true })
                    end
                    break
                end
            end

            --Build in arti location if we lack UEF and Seraphim factories
            if oEngineerToBuild then
                local iLandSubteam = oEngineerToBuild:GetAIBrain().M28LandSubteam
                local tFactoriesByTech = M28Team.tLandSubteamData[iLandSubteam][M28Team.subrefFactoriesByTypeFactionAndTech]
                if (tFactoriesByTech[M28UnitInfo.refFactionUEF][1] or 0) == 0 and (tFactoriesByTech[M28UnitInfo.refFactionUEF][2] or 0) == 0 and  (tFactoriesByTech[M28UnitInfo.refFactionUEF][3] or 0) == 0
                        and (tFactoriesByTech[M28UnitInfo.refFactionSeraphim][1] or 0) == 0 and (tFactoriesByTech[M28UnitInfo.refFactionSeraphim][2] or 0) == 0 and  (tFactoriesByTech[M28UnitInfo.refFactionSeraphim][3] or 0) == 0 then
                    bUseArtiInsteadOfLastShieldLocation = true
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Our shield size is below 37 and we have 2+ arti locations in this zone, so will consider 1 less hsield entry and flag we want UEF or seraphim engineers for this zone') end
        end

        --Are any of the shield locations available? If not then need to reclaim blocking buildings
        local iBuildingSize = M28UnitInfo.GetBuildingSize(sShieldToBuild)
        local tLocationsToBuild = {}
        local iLocationsToBuild = 0
        if not(iMaxShieldsToTryAndBuild) then iMaxShieldsToTryAndBuild = 1 end
        for iEntry, tBuildLocation in tTableRef[M28Map.subrefGEShieldLocations] do
            if not(tbShieldEntiresNotToConsider[iEntry]) then
                if bDebugMessages == true then LOG(sFunctionRef..': Considering shield location '..repru(tBuildLocation)..'; can we build a shield here='..tostring(aiBrain:CanBuildStructureAt(sShieldToBuild, tBuildLocation))) end
                if aiBrain:CanBuildStructureAt(sShieldToBuild, tBuildLocation) then
                    table.insert(tLocationsToBuild, {tBuildLocation[1], tBuildLocation[2],tBuildLocation[3]})
                    iLocationsToBuild = iLocationsToBuild + 1
                    if iLocationsToBuild >= iMaxShieldsToTryAndBuild then
                        break
                    end
                else
                    if bDebugMessages == true then  M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tBuildLocation, 3), 2) end
                end
            end
        end
        if bUseArtiInsteadOfLastShieldLocation and M28Utilities.IsTableEmpty(tLocationsToBuild) then
            --Consider the second arti location
            if aiBrain:CanBuildStructureAt(sShieldToBuild, tTableRef[M28Map.subrefGEArtiLocations][2]) then
                table.insert(tLocationsToBuild, {tTableRef[M28Map.subrefGEArtiLocations][2][1], tTableRef[M28Map.subrefGEArtiLocations][2][2],tTableRef[M28Map.subrefGEArtiLocations][2][3]})
                iLocationsToBuild = iLocationsToBuild + 1
            end
        end

        local tFirstLocationBuiltAt

        if M28Utilities.IsTableEmpty(tLocationsToBuild) == false then
            --First assign the first engineer

            for iEngineer, oEngineer in tAvailableEngineers do
                if oEngineer == oEngineerToBuild then
                    if bDebugMessages == true then LOG(sFunctionRef..': Setting engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to build the shield') end
                    table.remove(tAvailableEngineers, iEngineer)
                    break
                end
            end
            if M28Utilities.IsTableEmpty(tEngisOfDesiredFaction) == false then
                for iEngineer, oEngineer in tEngisOfDesiredFaction do
                    if oEngineer == oEngineerToBuild then
                        table.remove(tEngisOfDesiredFaction, iEngineer)
                        break
                    end
                end
            end
            local tMoveLocation = GetLocationToMoveForConstruction(oEngineerToBuild, tLocationsToBuild[1], sShieldToBuild, 0, false)
            if tMoveLocation and (oEngineerToBuild[M28Conditions.refiEngineerStuckCheckCount] or 0) <= 10 then
                if bDebugMessages == true then LOG(sFunctionRef..': GE S Telling engineer '..oEngineerToBuild.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineerToBuild)..' to move to '..repru(tMoveLocation)..' and then build '..sShieldToBuild..' at location '..repru(tLocationsToBuild[1])) end
                M28Orders.IssueTrackedMoveAndBuild(oEngineerToBuild, tLocationsToBuild[1], sShieldToBuild, tMoveLocation, 1, false, 'GEMBShT'..iTemplateRef)
                if M28Utilities.GetDistanceBetweenPositions(oEngineerToBuild:GetPosition(), tMoveLocation) <= 2 then oEngineerToBuild[M28Conditions.refiEngineerStuckCheckCount] = (oEngineerToBuild[M28Conditions.refiEngineerStuckCheckCount] or 0) + 1 end
                bTriedBuildingSomething = true
            else
                if bDebugMessages == true then LOG(sFunctionRef..': GE S Telling engineer '..oEngineerToBuild.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineerToBuild)..' to build '..sShieldToBuild..' at build location '..repru(tLocationsToBuild[1])..'; oEngineerToBuild[refiGETemplateTimeTryingToBuild]='..(oEngineerToBuild[refiGETemplateTimeTryingToBuild] or 'nil')) end

                M28Orders.IssueTrackedBuild(oEngineerToBuild, tLocationsToBuild[1], sShieldToBuild, false, 'GEBArt')
                bTriedBuildingSomething = true

            end
            if oEngineerToBuild[M28UnitInfo.refbPaused] then M28UnitInfo.PauseOrUnpauseEnergyUsage(oEngineerToBuild, false) end
            oEngineerToBuild[refbPrimaryBuilder] = true
            tFirstLocationBuiltAt = {tLocationsToBuild[1][1], tLocationsToBuild[1][2], tLocationsToBuild[1][3]}
            if not(oEngineerToBuild[M28Building.reftArtiTemplateRefs][3] == iTemplateRef) or not( oEngineerToBuild[M28Building.reftArtiTemplateRefs][2] == iLandZone) then oEngineerToBuild[M28Building.reftArtiTemplateRefs] = {iPlateau, iLandZone, iTemplateRef} end --Redundancy
            table.remove(tLocationsToBuild, 1)

            --Now try and build at the other locations if have any
            local iMaxCount = iMaxShieldsToTryAndBuild + 1
            local iCurLoopCount = 0
            if M28Utilities.IsTableEmpty(tEngisOfDesiredFaction) == false and M28Utilities.IsTableEmpty(tLocationsToBuild) == false then
                local iLastEngi = table.getn(tEngisOfDesiredFaction)
                local iLastLocation = table.getn(tLocationsToBuild)
                while M28Utilities.IsTableEmpty(tEngisOfDesiredFaction) == false and M28Utilities.IsTableEmpty(tLocationsToBuild) == false do
                    iCurLoopCount = iCurLoopCount + 1
                    if iCurLoopCount > iMaxCount then M28Utilities.ErrorHandler('Infinite loop protection') break end

                    tMoveLocation = GetLocationToMoveForConstruction(tEngisOfDesiredFaction[iLastEngi], tLocationsToBuild[iLastLocation], sShieldToBuild, 0, false)
                    if tMoveLocation and (tEngisOfDesiredFaction[iLastEngi][M28Conditions.refiEngineerStuckCheckCount] or 0) <= 10 then
                        if bDebugMessages == true then LOG(sFunctionRef..': GE Extra Telling engineer '..tEngisOfDesiredFaction[iLastEngi].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngisOfDesiredFaction[iLastEngi])..' to move to '..repru(tMoveLocation)..' and then build '..sShieldToBuild..' at location '..repru(tLocationsToBuild[iLastLocation])) end
                        M28Orders.IssueTrackedMoveAndBuild(tEngisOfDesiredFaction[iLastEngi], tLocationsToBuild[iLastLocation], sShieldToBuild, tMoveLocation, 1, false, 'GEMEBShT'..iTemplateRef)
                        if M28Utilities.GetDistanceBetweenPositions(tEngisOfDesiredFaction[iLastEngi]:GetPosition(), tMoveLocation) <= 2 then tEngisOfDesiredFaction[iLastEngi][M28Conditions.refiEngineerStuckCheckCount] = (tEngisOfDesiredFaction[iLastEngi][M28Conditions.refiEngineerStuckCheckCount] or 0) + 1 end
                        bTriedBuildingSomething = true
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': GE Extra Telling engineer '..tEngisOfDesiredFaction[iLastEngi].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngisOfDesiredFaction[iLastEngi])..' to build '..sShieldToBuild..' at build location '..repru(tLocationsToBuild[iLastLocation])) end
                        ConsiderResettingGEEngineerJustBeforeGivingNewOrder(oEngineerToBuild)
                        M28Orders.IssueTrackedBuild(tEngisOfDesiredFaction[iLastEngi], tLocationsToBuild[iLastLocation], sShieldToBuild, false, 'GEEBSh'..iTemplateRef)
                        bTriedBuildingSomething = true
                    end
                    if not(tEngisOfDesiredFaction[iLastEngi][M28Building.reftArtiTemplateRefs][3] == iTemplateRef) or not( tEngisOfDesiredFaction[iLastEngi][M28Building.reftArtiTemplateRefs][2] == iLandZone) then oEngineerToBuild[M28Building.reftArtiTemplateRefs] = {iPlateau, iLandZone, iTemplateRef} end --Redundancy
                    for iEngineer, oEngineer in tAvailableEngineers do
                        if oEngineer == tEngisOfDesiredFaction[iLastEngi] then
                            table.remove(tAvailableEngineers, iEngineer)
                            break
                        end
                    end
                    table.remove(tEngisOfDesiredFaction, iLastEngi)
                    iLastEngi = iLastEngi - 1
                    table.remove(tLocationsToBuild, iLastLocation)
                    iLastLocation = iLastLocation - 1
                end
            end

        end

        if M28Utilities.IsTableEmpty(tAvailableEngineers) == false and iLocationsToBuild < iMaxShieldsToTryAndBuild and (iLocationsToBuild == 0 or not(bUseArtiInsteadOfLastShieldLocation)) then
            --Look to reclaim buildings that are blocking us with remaining engineers, unless they are very high value buildings
            local iLowestValueBlockingBuildings = 150000 --basic threshold to prevent reclaiming really high value buildings
            local tLowestValueBlockingBuildings, iCurValueBlockingBuildings, iLowestValueRef
            local bHavePotentiallyValidLocation = false
            local tUnitsToConsiderReclaiming
            local iXDif, iZDif

            function ConsiderUnitsToReclaim(tBuildLocation)
                local tBlockingUnits = GetUnitsInRect(M28Utilities.GetRectAroundLocation(tBuildLocation, iBuildingSize * 0.5 - 0.3))
                if not(tBlockingUnits) then
                    M28Utilities.ErrorHandler('Tempalte location cant be built on but has no units in it')
                else
                    local tBlockingUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryWall, tBlockingUnits)
                    if M28Utilities.IsTableEmpty(tBlockingUnits) then
                        M28Utilities.ErrorHandler('Template location cant be built on but has no buildings in it')
                    else
                        tUnitsToConsiderReclaiming = {}
                        for iUnit, oUnit in tBlockingUnits do
                            if M28UnitInfo.IsUnitValid(oUnit) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Location '..repru(tBuildLocation)..' has a blocking unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at position '..repru(oUnit:GetPosition())..' with radius='..M28UnitInfo.GetBuildingSize(oUnit.UnitId)*0.5..'; Is unit oUnit[M28Building.reftArtiTemplateRefs] nil='..tostring(oUnit[M28Building.reftArtiTemplateRefs]==nil)) end
                                if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnit.UnitId) then
                                    --Do nothing
                                    tUnitsToConsiderReclaiming = nil
                                    break
                                elseif oUnit[M28Building.reftArtiTemplateRefs] then
                                    --Do nothing
                                    tUnitsToConsiderReclaiming = nil
                                    break

                                else
                                    local bShieldToAdd = false
                                    --e.g. has another engineer unrelated to template logic gone and built in our template, but managed to build in the right place?
                                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield - categories.TECH2, oUnit.UnitId) then
                                        iXDif = math.abs(oUnit:GetPosition()[1] - tBuildLocation[1])
                                        if iXDif <= 0.5 or (iXDif >= 2.5 and iXDif <= 3.5) then
                                            iZDif = math.abs(oUnit:GetPosition()[3] - tBuildLocation[3])
                                            if iZDif <= 0.5 or (iZDif >= 2.5 and iZDif <= 3.5) then
                                                bShieldToAdd = true
                                            end
                                        end
                                    end
                                    if bShieldToAdd then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Dealing with a fixed hsield that is in the right location to form part of our logic so will add') end
                                        oUnit[M28Building.reftArtiTemplateRefs] = {iPlateau, iLandZone, iTemplateRef}
                                        --Check not already in the table (redundancy)
                                        local bAlreadyRecorded = false
                                        if M28Utilities.IsTableEmpty(tTableRef[M28Map.subrefGEShieldUnits]) == false then
                                            for iRecordedShield, oRecordedShield in tTableRef[M28Map.subrefGEShieldUnits] do
                                                if oRecordedShield == oUnit then
                                                    bAlreadyRecorded = true
                                                    break
                                                end
                                            end
                                        end
                                        if not(bAlreadyRecorded) then
                                            table.insert(tTableRef[M28Map.subrefGEShieldUnits], oUnit)
                                        end

                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will add to table of units to reclaim') end
                                        table.insert(tUnitsToConsiderReclaiming, oUnit)
                                    end
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(tUnitsToConsiderReclaiming) == false then
                            iCurValueBlockingBuildings = M28UnitInfo.GetCombatThreatRating(tUnitsToConsiderReclaiming, false, true)
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurValueBlockingBuildings='..iCurValueBlockingBuildings..'; iLowestValueBlockingBuildings='..iLowestValueBlockingBuildings) end
                            if iCurValueBlockingBuildings < iLowestValueBlockingBuildings then
                                iLowestValueBlockingBuildings = iCurValueBlockingBuildings
                                tLowestValueBlockingBuildings = tUnitsToConsiderReclaiming
                                bHavePotentiallyValidLocation = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Have a potentially valid location for shields so will reclaim if it remains the lowest value of blocking units') end
                            end
                        end
                    end
                end
            end

            for iEntry, tBuildLocation in tTableRef[M28Map.subrefGEShieldLocations] do
                if not(tbShieldEntiresNotToConsider[iEntry]) then
                    ConsiderUnitsToReclaim(tBuildLocation)
                end
            end
            if not(bHavePotentiallyValidLocation) and M28Utilities.IsTableEmpty(tTableRef[M28Map.subrefGEArtiLocations][2]) == false then ConsiderUnitsToReclaim(tTableRef[M28Map.subrefGEArtiLocations][2]) end
            if bHavePotentiallyValidLocation then
                --Get all engineers to reclaim the units here
                local oUnitToReclaim = tLowestValueBlockingBuildings[1]
                local iEngisGivenReclaimOrder = 0
                CheckAndClearEngineersConstructingTargetUnit(oUnitToReclaim, tLZTeamData)
                for iEngineer, oEngineer in tAvailableEngineers do
                    if oEngineer[M28UnitInfo.refbPaused] then M28UnitInfo.PauseOrUnpauseEnergyUsage(oEngineer, false) end
                    M28Orders.IssueTrackedReclaim(oEngineer, oUnitToReclaim, false, 'GESRecl', false)
                    iEngisGivenReclaimOrder = iEngisGivenReclaimOrder + 1
                    if iOptionalMaxEngiPerAction and iEngisGivenReclaimOrder >= iOptionalMaxEngiPerAction then break end
                    bTriedBuildingSomething = true
                end
                if iOptionalMaxEngiPerAction then
                    for iRemoveCount = 1, iEngisGivenReclaimOrder do
                        local oEngiToRemove = tAvailableEngineers[1]
                        if M28Utilities.IsTableEmpty(tEngisOfDesiredFaction) == false then
                            for iFactionEngi, oFactionEngi in tEngisOfDesiredFaction do
                                if oFactionEngi == oEngiToRemove then
                                    table.remove(tEngisOfDesiredFaction, iFactionEngi)
                                    break
                                end
                            end
                        end
                        table.remove(tAvailableEngineers, 1)
                    end
                else
                    tAvailableEngineers = nil
                    tEngisOfDesiredFaction = nil
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Want to create space for shield by reclaiming unit '..oUnitToReclaim.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToReclaim)) end
            end
        else
            if M28Utilities.IsTableEmpty(tAvailableEngineers) == false then
                local iEngisGivenOrder = 1
                if not(iOptionalMaxEngiPerAction) or iEngisGivenOrder < iOptionalMaxEngiPerAction then
                    --Get every other engineer to assist this engineer
                    local iRemainingEngisGivenGuard = 0
                    for iEngineer, oEngineer in tAvailableEngineers do
                        if oEngineer:CanBuild(sShieldToBuild) then
                            M28Orders.IssueTrackedBuild(oEngineer, tFirstLocationBuiltAt, sShieldToBuild, false, 'GEXtraBS'..iTemplateRef)
                            bTriedBuildingSomething = true
                        else
                            M28Orders.IssueTrackedGuard(oEngineer, oEngineerToBuild, false, 'GESAss', false)
                        end
                        iRemainingEngisGivenGuard = iRemainingEngisGivenGuard + 1
                        if iOptionalMaxEngiPerAction and iRemainingEngisGivenGuard + iEngisGivenOrder >= iOptionalMaxEngiPerAction then break end
                    end

                    if iOptionalMaxEngiPerAction then
                        for iRemoveCount = 1, iRemainingEngisGivenGuard do
                            local oEngiToRemove = tAvailableEngineers[1]
                            if M28Utilities.IsTableEmpty(tEngisOfDesiredFaction) == false then
                                for iFactionEngi, oFactionEngi in tEngisOfDesiredFaction do
                                    if oFactionEngi == oEngiToRemove then
                                        table.remove(tEngisOfDesiredFaction, iFactionEngi)
                                        break
                                    end
                                end
                            end

                            table.remove(tAvailableEngineers, 1)
                        end
                    else
                        tAvailableEngineers = nil
                        tEngisOfDesiredFaction = nil
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bTriedBuildingSomething
end

function GETemplateConsiderDefences(tAvailableEngineers, tAvailableT3EngineersByFaction, tLZTeamData, iPlateau, iLandZone, tTableRef, iTemplateRef, iTeam, iOptionalMaxEngiPerAction)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GETemplateConsiderDefences'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bTriedBuildingSomething = false

    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to get defences such as SMD, iLandZone='..iLandZone..'; iTemplateRef='..iTemplateRef..'; Do we have active shield monitor='..tostring(tTableRef[M28Map.subrefGEbActiveShieldMonitor])) end

    if tTableRef[M28Map.subrefGEbActiveShieldMonitor] then
        --Consider getting SMD if we dont have one and enemy has nukes, and we have an SMD location for this table
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if want SMD for template '..iTemplateRef..'; in P'..iPlateau..'Z'..iLandZone..'; Is table of enemy nukes empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]))..'; Do we have a valid SMD unit in this template already='..tostring(M28UnitInfo.IsUnitValid(tTableRef[M28Map.subrefGESMDUnit]))..'; Is table of available t3 engineers empty='..tostring(M28Utilities.IsTableEmpty(tAvailableT3EngineersByFaction))..'; Is SMD location for this template empty='..tostring(M28Utilities.IsTableEmpty(tTableRef[M28Map.subrefGESMDLocation]))) end
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false and not(M28UnitInfo.IsUnitValid(tTableRef[M28Map.subrefGESMDUnit])) and M28Utilities.IsTableEmpty(tTableRef[M28Map.subrefGESMDLocation]) == false and M28Utilities.IsTableEmpty(tAvailableT3EngineersByFaction) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategorySML - categories.BATTLESHIP, M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers])) == false then
            --Enemy has nuke (non sera battleship version) and we lack SMD for this template, so get SMD unless we have another template in this zone that has SMD
            local bHaveOtherTemplateWithSMD = false
            for iTemplate, tSubtable in tLZTeamData[M28Map.reftActiveGameEnderTemplates] do
                if M28UnitInfo.IsUnitValid(tTableRef[M28Map.subrefGESMDUnit]) then
                    bHaveOtherTemplateWithSMD = true
                    break
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bHaveOtherTemplateWithSMD='..tostring(bHaveOtherTemplateWithSMD)) end
            if not(bHaveOtherTemplateWithSMD) then
                --Wnat to build SMD
                local oEngineerToBuild
                for iFaction, tEngineers in tAvailableT3EngineersByFaction do
                    for iEngineer, oEngineer in tEngineers do
                        oEngineerToBuild = oEngineer
                        break
                    end
                    if oEngineerToBuild then
                        break
                    end
                end
                if oEngineerToBuild then
                    local aiBrain = oEngineerToBuild:GetAIBrain()
                    local sBPToBuild = M28Factory.GetBlueprintThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategorySMD, oEngineerToBuild)
                    local sLastBlueprint = oEngineerToBuild[M28Orders.reftiLastOrders][oEngineerToBuild[M28Orders.refiOrderCount]][M28Orders.subrefsOrderBlueprint] or 'nil'
                    if sLastBlueprint and not(sLastBlueprint == sBPToBuild) and EntityCategoryContains(M28UnitInfo.refCategorySMD, sLastBlueprint) then
                        sBPToBuild = sLastBlueprint
                        if bDebugMessages == true then LOG(sFunctionRef..': engi last blueprint was different, but also met the category, sLastBlueprint='..sLastBlueprint..'; so will change what to build to this') end
                    end

                    local tBuildLocation = {tTableRef[M28Map.subrefGESMDLocation][1], tTableRef[M28Map.subrefGESMDLocation][2], tTableRef[M28Map.subrefGESMDLocation][3]}
                    if bDebugMessages == true then LOG(sFunctionRef..': can we build SMD at the location='..tostring(aiBrain:CanBuildStructureAt(sBPToBuild, tTableRef[M28Map.subrefGESMDLocation]))..'; Engineer='..oEngineerToBuild.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineerToBuild)..'; sBPToBuild='..sBPToBuild..'; tBuildLocation='..repru(tBuildLocation)) end
                    if not(aiBrain:CanBuildStructureAt(sBPToBuild, tBuildLocation)) then
                        tBuildLocation = {tBuildLocation[1] + 0.5, 0, tBuildLocation[3] + 0.5}
                        tBuildLocation[2] = GetSurfaceHeight(tBuildLocation[1], tBuildLocation[3])
                        if bDebugMessages == true then LOG(sFunctionRef..': can we build at adjusted tBuildLocation='..repru(tBuildLocation)..'='..tostring(aiBrain:CanBuildStructureAt(sBPToBuild, tBuildLocation))) end
                    end
                    if aiBrain:CanBuildStructureAt(sBPToBuild, tBuildLocation) then
                        --First assign the first engineer
                        for iEngineer, oEngineer in tAvailableEngineers do
                            if oEngineer == oEngineerToBuild then
                                if bDebugMessages == true then LOG(sFunctionRef..': Setting engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to build the SMD') end
                                table.remove(tAvailableEngineers, iEngineer)
                                break
                            end
                        end
                        if M28Utilities.IsTableEmpty(tAvailableT3EngineersByFaction) == false then
                            local bRemovedFromEngiByFaction = false
                            for iFaction, tEngisOfDesiredFaction in tAvailableT3EngineersByFaction do
                                for iEngineer, oEngineer in tEngisOfDesiredFaction do
                                    if oEngineer == oEngineerToBuild then
                                        table.remove(tEngisOfDesiredFaction, iEngineer)
                                        bRemovedFromEngiByFaction = true
                                        break
                                    end
                                end
                                if bRemovedFromEngiByFaction then break end
                            end
                        end

                        local tMoveLocation = GetLocationToMoveForConstruction(oEngineerToBuild, tBuildLocation, sBPToBuild, 0, false)
                        if tMoveLocation and (oEngineerToBuild[M28Conditions.refiEngineerStuckCheckCount] or 0) <= 10 then
                            if bDebugMessages == true then LOG(sFunctionRef..': GE SMD Telling engineer '..oEngineerToBuild.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineerToBuild)..' to move to '..repru(tMoveLocation)..' and then build '..sBPToBuild..' at location '..repru(tBuildLocation)) end
                            M28Orders.IssueTrackedMoveAndBuild(oEngineerToBuild, tBuildLocation, sBPToBuild, tMoveLocation, 1, false, 'GESMDMB')
                            bTriedBuildingSomething = true
                            if M28Utilities.GetDistanceBetweenPositions(oEngineerToBuild:GetPosition(), tMoveLocation) <= 2 then oEngineerToBuild[M28Conditions.refiEngineerStuckCheckCount] = (oEngineerToBuild[M28Conditions.refiEngineerStuckCheckCount] or 0) + 1 end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': GE SMD Telling engineer '..oEngineerToBuild.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineerToBuild)..' to build '..sBPToBuild..' at build location '..repru(tBuildLocation)..'; oEngineerToBuild[refiGETemplateTimeTryingToBuild]='..(oEngineerToBuild[refiGETemplateTimeTryingToBuild] or 'nil')) end
                            M28Orders.IssueTrackedBuild(oEngineerToBuild, tBuildLocation, sBPToBuild, false, 'GESMDB')
                            bTriedBuildingSomething = true
                        end
                        if oEngineerToBuild[M28UnitInfo.refbPaused] then M28UnitInfo.PauseOrUnpauseEnergyUsage(oEngineerToBuild, false) end
                        oEngineerToBuild[refbPrimaryBuilder] = true
                        if not(oEngineerToBuild[M28Building.reftArtiTemplateRefs][3] == iTemplateRef) or not( oEngineerToBuild[M28Building.reftArtiTemplateRefs][2] == iLandZone) then oEngineerToBuild[M28Building.reftArtiTemplateRefs] = {iPlateau, iLandZone, iTemplateRef} end --Redundancy
                    else
                        if bDebugMessages == true then M28Utilities.DrawRectangle(M28Utilities.GetRectAroundLocation(tBuildLocation, 1.5), 2, 200) end
                        --Look to reclaim buildings that are blocking us with remaining engineers, unless they are very high value buildings
                        local iLowestValueBlockingBuildings = 150000 --basic threshold to prevent reclaiming really high value buildings
                        local tLowestValueBlockingBuildings, iCurValueBlockingBuildings, iLowestValueRef
                        local bHavePotentiallyValidLocation = false
                        local tUnitsToConsiderReclaiming
                        local iXDif, iZDif
                        local iBuildingSize = M28UnitInfo.GetBuildingSize(sBPToBuild)

                        function ConsiderUnitsToReclaim(tSearchLocation)
                            local tBlockingUnits = GetUnitsInRect(M28Utilities.GetRectAroundLocation(tSearchLocation, iBuildingSize * 0.5 - 0.3))
                            if not(tBlockingUnits) then
                                M28Utilities.ErrorHandler('Tempalte location cant be built on but has no units in it')
                            else
                                local tBlockingUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryWall, tBlockingUnits)
                                if M28Utilities.IsTableEmpty(tBlockingUnits) then
                                    M28Utilities.ErrorHandler('Template location cant be built on but has no buildings in it')
                                else
                                    tUnitsToConsiderReclaiming = {}
                                    for iUnit, oUnit in tBlockingUnits do
                                        if M28UnitInfo.IsUnitValid(oUnit) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Location '..repru(tSearchLocation)..' has a blocking unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at position '..repru(oUnit:GetPosition())..' with radius='..M28UnitInfo.GetBuildingSize(oUnit.UnitId)*0.5..'; Is unit oUnit[M28Building.reftArtiTemplateRefs] nil='..tostring(oUnit[M28Building.reftArtiTemplateRefs]==nil)) end
                                            if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnit.UnitId) then
                                                --Do nothing
                                                tUnitsToConsiderReclaiming = nil
                                                break
                                            elseif oUnit[M28Building.reftArtiTemplateRefs] then
                                                --Do nothing
                                                tUnitsToConsiderReclaiming = nil
                                                break
                                            else
                                                local bUnitToAdd = false
                                                --e.g. has another engineer unrelated to template logic gone and built in our template, but managed to build in the right place?
                                                if EntityCategoryContains(M28UnitInfo.refCategorySMD, oUnit.UnitId) then
                                                    iXDif = math.abs(oUnit:GetPosition()[1] - tSearchLocation[1])
                                                    if iXDif <= 0.5 or (iXDif >= 2.5 and iXDif <= 3.5) then
                                                        iZDif = math.abs(oUnit:GetPosition()[3] - tSearchLocation[3])
                                                        if iZDif <= 0.5 or (iZDif >= 2.5 and iZDif <= 3.5) then
                                                            bUnitToAdd = true
                                                        end
                                                    end
                                                end
                                                if bUnitToAdd then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Dealing with a fixed hsield that is in the right location to form part of our logic so will add') end
                                                    oUnit[M28Building.reftArtiTemplateRefs] = {iPlateau, iLandZone, iTemplateRef}
                                                    tUnitsToConsiderReclaiming = nil
                                                    --Check not already in the table (redundancy)
                                                    local bAlreadyRecorded = false
                                                    if M28Utilities.IsTableEmpty(tTableRef[M28Map.subrefGEShieldUnits]) == false then
                                                        for iRecordedShield, oRecordedShield in tTableRef[M28Map.subrefGEShieldUnits] do
                                                            if oRecordedShield == oUnit then
                                                                bAlreadyRecorded = true
                                                                break
                                                            end
                                                        end
                                                    end
                                                    if not(bAlreadyRecorded) then
                                                        table.insert(tTableRef[M28Map.subrefGEShieldUnits], oUnit)
                                                    end
                                                    break
                                                else
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will add to table of units to reclaim') end
                                                    table.insert(tUnitsToConsiderReclaiming, oUnit)
                                                end
                                            end
                                        end
                                    end
                                    if M28Utilities.IsTableEmpty(tUnitsToConsiderReclaiming) == false then
                                        iCurValueBlockingBuildings = M28UnitInfo.GetCombatThreatRating(tUnitsToConsiderReclaiming, false, true)
                                        if bDebugMessages == true then LOG(sFunctionRef..': iCurValueBlockingBuildings='..iCurValueBlockingBuildings..'; iLowestValueBlockingBuildings='..iLowestValueBlockingBuildings) end
                                        if iCurValueBlockingBuildings < iLowestValueBlockingBuildings then
                                            iLowestValueBlockingBuildings = iCurValueBlockingBuildings
                                            tLowestValueBlockingBuildings = tUnitsToConsiderReclaiming
                                            bHavePotentiallyValidLocation = true
                                            if bDebugMessages == true then LOG(sFunctionRef..': Have a potentially valid location for shields so will reclaim if it remains the lowest value of blocking units') end
                                        end
                                    end
                                end
                            end
                        end


                        ConsiderUnitsToReclaim(tTableRef[M28Map.subrefGESMDLocation])
                        if bDebugMessages == true then LOG(sFunctionRef..': bHavePotentiallyValidLocation='..tostring(bHavePotentiallyValidLocation or false)..'; Is tLowestValueBlockingBuildings empty='..tostring(M28Utilities.IsTableEmpty(tLowestValueBlockingBuildings))) end
                        if bHavePotentiallyValidLocation then
                            --Get all engineers to reclaim the units here
                            local oUnitToReclaim = tLowestValueBlockingBuildings[1]
                            local iEngisGivenReclaimOrder = 0
                            CheckAndClearEngineersConstructingTargetUnit(oUnitToReclaim, tLZTeamData)
                            for iEngineer, oEngineer in tAvailableEngineers do
                                M28Orders.IssueTrackedReclaim(oEngineer, oUnitToReclaim, false, 'GESMDRecl', false)
                                iEngisGivenReclaimOrder = iEngisGivenReclaimOrder + 1
                                if iOptionalMaxEngiPerAction and iEngisGivenReclaimOrder >= iOptionalMaxEngiPerAction then break end
                            end
                            if iOptionalMaxEngiPerAction then
                                for iRemoveCount = 1, iEngisGivenReclaimOrder do
                                    local oEngiToRemove = tAvailableEngineers[1]
                                    if M28Utilities.IsTableEmpty(tAvailableT3EngineersByFaction) == false then
                                        for iFactionEngi, oFactionEngi in tAvailableT3EngineersByFaction do
                                            if oFactionEngi == oEngiToRemove then
                                                table.remove(tAvailableT3EngineersByFaction, iFactionEngi)
                                                break
                                            end
                                        end
                                    end
                                    table.remove(tAvailableEngineers, 1)
                                end
                            else
                                tAvailableEngineers = nil
                                tAvailableT3EngineersByFaction = nil
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to create space for SMD by reclaiming unit '..oUnitToReclaim.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToReclaim)) end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bTriedBuildingSomething
end

function GameEnderTemplateManager(tLZData, tLZTeamData, iTemplateRef, iPlateau, iLandZone, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GameEnderTemplateManager'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tTableRef = tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplateRef]
    if not(tTableRef[M28Map.subrefGEbActiveMonitor]) then
        if bDebugMessages == true then LOG(sFunctionRef..': iTemplateRef='..(iTemplateRef or 'nil')..'; Is tLZTeamData[M28Map.reftActiveGameEnderTemplates] empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates]))..'; Arti locations='..repru(tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplateRef][M28Map.subrefGEArtiLocations])) end
        tTableRef[M28Map.subrefGEbActiveMonitor] = true
        M28Overseer.refiCurGETemplateGlobalCount = M28Overseer.refiCurGETemplateGlobalCount + 1

        local iCurTick = (GetGameTimeSeconds() - math.floor(GetGameTimeSeconds())) * 10
        local iTicksToWait = M28Overseer.refiCurGETemplateGlobalCount - iCurTick - 1
        if iTicksToWait < 0 then iTicksToWait = iTicksToWait + 10 end
        while iTicksToWait >= 10 do
            iTicksToWait = iTicksToWait - 10
        end
        if M28Overseer.refiCurGETemplateGlobalCount == 1 then iTicksToWait = math.min(iTicksToWait, 4) end
        if bDebugMessages == true then LOG(sFunctionRef..': Count='..M28Overseer.refiCurGETemplateGlobalCount..'; iTicksToWait='..iTicksToWait..'; iCurTick='..iCurTick..'; Time='..GetGameTimeSeconds()) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(iTicksToWait)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        local iShieldLocations = table.getn(tTableRef[M28Map.subrefGEShieldLocations])
        local iArtiLocations = table.getn(tTableRef[M28Map.subrefGEArtiLocations])
        tTableRef[M28Map.subrefGEbDontNeedEngineers] = false



        local oFirstUEF, oFirstAeon, oFirstCybran, oFirstSeraphim, oFirstEngineer
        local bHaveAlreadyTriedSwitchingCategoryForNovax = false
        local bTriedBuildingSomething = false
        local bGaveBuildOrder = false




        while not(tTableRef[M28Map.subrefGEbDontNeedEngineers]) do
            --Decide whether to continue with loop - abort if have no engineers and no arti and no shields
            local bStillValid = false
            if M28Conditions.IsTableOfUnitsStillValid(tTableRef[M28Map.subrefGEEngineers]) then bStillValid = true end
            if M28Conditions.IsTableOfUnitsStillValid(tTableRef[M28Map.subrefGEArtiUnits]) then bStillValid = true end
            if M28Conditions.IsTableOfUnitsStillValid(tTableRef[M28Map.subrefGEShieldUnits]) then bStillValid = true end
            if bDebugMessages == true then LOG(sFunctionRef..': Starting new loop at time='..GetGameTimeSeconds()..'; bStillValid='..tostring(bStillValid or false)..'; Time of last M28 death='..(M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastM28PlayerDefeat] or 'nil')..'; Is this table flagged as no longer wanting engis='..tostring(tTableRef[M28Map.subrefGEbDontNeedEngineers])) end
            if bStillValid then
                --Decide what to do with engineers, if we have any
                local tAvailableEngineers = {}
                local tAvailableT3EngineersByFaction = {}
                local tLowCompletionShieldsToAssist = {}
                oFirstUEF = nil
                oFirstAeon = nil
                oFirstCybran = nil
                oFirstSeraphim = nil
                oFirstEngineer = nil

                if M28Utilities.IsTableEmpty(tTableRef[M28Map.subrefGEEngineers]) == false then
                    for iEngineer, oEngineer in tTableRef[M28Map.subrefGEEngineers] do

                        table.insert(tAvailableEngineers, oEngineer)
                        if EntityCategoryContains(categories.ENGINEER * categories.TECH3, oEngineer.UnitId) then
                            if not(oFirstUEF) and EntityCategoryContains(categories.UEF * categories.TECH3, oEngineer.UnitId) then oFirstUEF = oEngineer end
                            if not(oFirstAeon) and EntityCategoryContains(categories.AEON * categories.TECH3, oEngineer.UnitId) then oFirstAeon = oEngineer end
                            if not(oFirstCybran) and EntityCategoryContains(categories.CYBRAN * categories.TECH3, oEngineer.UnitId) then oFirstCybran = oEngineer end
                            if not(oFirstSeraphim) and EntityCategoryContains(categories.SERAPHIM * categories.TECH3, oEngineer.UnitId) then oFirstSeraphim = oEngineer end
                            if not(oFirstEngineer) and EntityCategoryContains(M28UnitInfo.refCategoryEngineer * categories.TECH3 + categories.SUBCOMMANDER * categories.TECH3, oEngineer.UnitId) then oFirstEngineer = oEngineer end
                            if not(oEngineer[M28Building.reftArtiTemplateRefs]) then oEngineer[M28Building.reftArtiTemplateRefs] = {iPlateau, iLandZone, iTemplateRef} end --redundancy
                        end
                    end

                    tAvailableT3EngineersByFaction = {}
                    if oFirstAeon then tAvailableT3EngineersByFaction[M28UnitInfo.refFactionAeon] = EntityCategoryFilterDown(categories.AEON * categories.TECH3, tAvailableEngineers) end
                    if oFirstUEF then tAvailableT3EngineersByFaction[M28UnitInfo.refFactionUEF] = EntityCategoryFilterDown(categories.UEF * categories.TECH3, tAvailableEngineers) end
                    if oFirstCybran then tAvailableT3EngineersByFaction[M28UnitInfo.refFactionCybran] = EntityCategoryFilterDown(categories.CYBRAN * categories.TECH3, tAvailableEngineers) end
                    if oFirstSeraphim then tAvailableT3EngineersByFaction[M28UnitInfo.refFactionSeraphim] = EntityCategoryFilterDown(categories.SERAPHIM * categories.TECH3, tAvailableEngineers) end
                    if not(oFirstAeon) and not(oFirstUEF) and not(oFirstCybran) and not(oFirstSeraphim) then tAvailableT3EngineersByFaction[M28UnitInfo.refFactionUnrecognised] = EntityCategoryFilterDown(categories.TECH3, tAvailableEngineers) end
                    if M28UnitInfo.IsUnitValid(oFirstEngineer) or iTeam then --We might have T1-2 engineers that dont qualify as a first available negi but could still do some stuff
                        if not(iTeam) then iTeam = oFirstEngineer:GetAIBrain().M28Team end --mostly a redundancy since should always have a team from the function calling this

                        local iCompletedArti = 0
                        local iUnderConstructionArti = 0
                        local iCompletedShields = 0
                        local iCompletedM28EasyShields = 0
                        local iUnderConstructionShields = 0
                        local oNearestCompletionShield, oNearestCompletionArti
                        local iHighestCompletionShield = -0.1
                        local iHighestCompletionArti = -0.1
                        local iExpShieldCount = 0
                        bTriedBuildingSomething = false

                        if M28Utilities.IsTableEmpty(tTableRef[M28Map.subrefGEArtiUnits]) == false then
                            for iArti, oArti in tTableRef[M28Map.subrefGEArtiUnits] do
                                if oArti:GetFractionComplete() == 1 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': We have completed oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)..'; at position '..repru(oArti:GetPosition())..'; Arti locations in template='..repru(tTableRef[M28Map.subrefGEArtiLocations])) end
                                    iCompletedArti = iCompletedArti  + 1
                                else
                                    iUnderConstructionArti = iUnderConstructionArti + 1
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oArti='..oArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oArti)..'; Fraction complete='..oArti:GetFractionComplete()..'; iHighestCompletionArti='..iHighestCompletionArti) end
                                    if oArti:GetFractionComplete() > iHighestCompletionArti then
                                        iHighestCompletionArti = oArti:GetFractionComplete()
                                        oNearestCompletionArti = oArti
                                    end
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(tTableRef[M28Map.subrefGEShieldUnits]) == false then
                            for iShield, oShield in tTableRef[M28Map.subrefGEShieldUnits] do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering shield='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; Fraction complete='..oShield:GetFractionComplete()..'; Shield arti ref='..repru(oShield[M28Building.reftArtiTemplateRefs])) end
                                if oShield:GetFractionComplete() == 1 then
                                    iCompletedShields = iCompletedShields  + 1
                                    if oShield[M28UnitInfo.refbEasyBrain] then
                                        iCompletedM28EasyShields = iCompletedM28EasyShields + 1
                                    end
                                else
                                    iUnderConstructionShields = iUnderConstructionShields + 1
                                    if oShield:GetFractionComplete() > iHighestCompletionShield then
                                        iHighestCompletionShield = oShield:GetFractionComplete()
                                        oNearestCompletionShield = oShield
                                    end
                                    if oShield:GetFractionComplete() < 0.07 then
                                        table.insert(tLowCompletionShieldsToAssist, oShield)
                                    end
                                end
                                if EntityCategoryContains(categories.EXPERIMENTAL, oShield.UnitId) then iExpShieldCount = iExpShieldCount+ 1 end
                            end
                        end

                        if bDebugMessages == true then LOG(sFunctionRef..': Finished checking how many shields and arti we have in iPlateau='..iPlateau..'; Zone='..iLandZone..'; Template ref='..iTemplateRef..', iCompletedShields='..iCompletedShields..'; iUnderConstructionShields='..iUnderConstructionShields..'; iCompletedArti='..iCompletedArti..'; iUnderConstructionArti='..iUnderConstructionArti..'; Number of engis='..table.getn(tAvailableEngineers)) end

                        --Check shields for cycling once we have a certain number
                        if iCompletedShields >= 3 and (iCompletedM28EasyShields == 0 or iCompletedShields - iCompletedM28EasyShields >= 2) then
                            if bDebugMessages == true then LOG(sFunctionRef..': we have at least 3 shields so will check if we are shield cycling, tTableRef[M28Map.subrefGEbActiveShieldMonitor]='..tostring(tTableRef[M28Map.subrefGEbActiveShieldMonitor] or false)) end
                            ForkThread(M28Building.MonitorShieldsForCycling, tTableRef, iTeam, iLandZone)
                        end

                        --If we dont have a T3 arti even started construction, then build one with the closest engineer able to build the desired category
                        if iCompletedArti == 0 and iUnderConstructionArti == 0 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build an arti or gameender, is table of available engineers empty='..tostring(M28Utilities.IsTableEmpty(tAvailableEngineers))..'; oFirstEngineer='..(oFirstEngineer.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oFirstEngineer) or 'nil')..'; Is tAvailableT3EngineersByFaction empty='..tostring(M28Utilities.IsTableEmpty(tAvailableT3EngineersByFaction))) end
                            bGaveBuildOrder = GETemplateStartBuildingArtiOrGameEnder(tAvailableEngineers, tAvailableT3EngineersByFaction, tLZData, tLZTeamData, iPlateau, iLandZone, iTeam, tTableRef, iTemplateRef, oFirstAeon, oFirstSeraphim, oFirstUEF, oFirstCybran, oFirstEngineer)
                            if bGaveBuildOrder then bTriedBuildingSomething = true end
                            if M28UnitInfo.IsUnitValid(oFirstEngineer) and M28Team.tTeamData[oFirstEngineer:GetAIBrain().M28Team][M28Team.refbUnableToBuildArtiOrGameEnders] then
                                tTableRef[M28Map.subrefGEbDontNeedEngineers] = true
                                break
                            end
                        end

                        if M28Utilities.IsTableEmpty(tAvailableEngineers) == false then
                            local iOrigAvailableEngis = table.getn(tAvailableEngineers)
                            local bExcludeExpShields
                            if iExpShieldCount > 0 then
                                if iExpShieldCount >= 2 or (iExpShieldCount >= 1 and iShieldLocations - iCompletedShields - iUnderConstructionShields >= 5) then bExcludeExpShields = true
                                else
                                    --We have 1 exp shield - dont get a second if we dont have a gameender
                                    bExcludeExpShields = true
                                    if iUnderConstructionArti + iCompletedArti > 0 then
                                        for iArti, oArti in tTableRef[M28Map.subrefGEArtiUnits] do
                                            if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder, oArti.UnitId) then
                                                bExcludeExpShields = false
                                                break
                                            end
                                        end

                                    end
                                end
                            end
                            --If have lots of engineers then spread out since the biggest delay may be starting construction of a shield
                            if (iUnderConstructionShields == 0 and (iCompletedShields == 0 or iCompletedShields < math.min(6, iHighestCompletionArti * 8))) or (iOrigAvailableEngis >= 5 and iUnderConstructionShields > 0 and iCompletedShields + iUnderConstructionShields < iShieldLocations and iUnderConstructionShields < 4) then
                                --Start building so have at least 4 shields built at once (want to do ahead of assisting shields, since faction used for this is important) - have 1 engi building each shield
                                if bDebugMessages == true then LOG(sFunctionRef..': Will try assigning 1 engi each to building a shield since iOrigAvailableEngis='..iOrigAvailableEngis) end

                                --GETemplateStartBuildingShield(tAvailableEngineers, tAvailableT3EngineersByFaction, tLZTeamData, iPlateau, iLandZone, tTableRef, iTemplateRef, oFirstAeon, oFirstSeraphim, oFirstUEF, oFirstCybran, oFirstEngineer, iMaxShieldsToTryAndBuild,                                                                                  iOptionalMaxEngiPerAction, bOnlyGetT3)
                                bGaveBuildOrder = GETemplateStartBuildingShield(tAvailableEngineers, tAvailableT3EngineersByFaction, tLZTeamData, iPlateau, iLandZone, tTableRef, iTemplateRef, oFirstAeon, oFirstSeraphim, oFirstUEF, oFirstCybran, oFirstEngineer, math.min(4 - iUnderConstructionShields, iShieldLocations - iCompletedShields - iUnderConstructionShields), 1,                           bExcludeExpShields)
                                if bGaveBuildOrder then bTriedBuildingSomething = true end

                            end
                            if M28Utilities.IsTableEmpty(tAvailableEngineers) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': Still have available engineers for zone '..iLandZone..'; will have 1 engi assisting the gameender and then have the rest building shields or helping tocompletion unless we want to assist a shield as ah igher priority. iOrigAvailableEngi'..iOrigAvailableEngis..'; Is tLowCompletionShieldsToAssist empty='..tostring(M28Utilities.IsTableEmpty(tLowCompletionShieldsToAssist))..'; iUnderConstructionShields='..iUnderConstructionShields..'; iCompletedShields='..iCompletedShields..'; iHighestCompletionArti='..iHighestCompletionArti..'; is oNearestCompletionShield valid='..tostring(M28UnitInfo.IsUnitValid(oNearestCompletionShield))) end
                                if iHighestCompletionArti > 0.03 and (iUnderConstructionShields == 1 or iUnderConstructionShields <= 2 and iHighestCompletionShield <= 0.03) and oNearestCompletionShield and (iCompletedShields == 0 or iCompletedShields < math.min(6, iHighestCompletionArti * 8)) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': will get one engi to assist nearest completion shield='..oNearestCompletionShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestCompletionShield)) end
                                    GETemplateAssistUnit(tAvailableEngineers, tAvailableT3EngineersByFaction, iTemplateRef, oNearestCompletionShield, 1)
                                end
                                if M28Utilities.IsTableEmpty(tAvailableEngineers) == false then
                                    --Have 1 engi assisting the arti if it is under construction so it doesnt die from low health
                                    if iUnderConstructionArti > 0 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have an under construction arti so will try and assist it, oNearestCompletionArti='..(oNearestCompletionArti.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestCompletionArti) or 'nil')) end
                                        GETemplateAssistUnit(tAvailableEngineers, tAvailableT3EngineersByFaction, iTemplateRef, oNearestCompletionArti, 1)
                                    end

                                    --next have 1 engi assisting each low health under construction shield
                                    if iOrigAvailableEngis >= 5 and M28Utilities.IsTableEmpty(tLowCompletionShieldsToAssist) == false and M28Utilities.IsTableEmpty(tAvailableEngineers) == false then
                                        for iShield, oShield in tLowCompletionShieldsToAssist do
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will get 1 engineer to assist the low construction shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)) end
                                            GETemplateAssistUnit(tAvailableEngineers, tAvailableT3EngineersByFaction, iTemplateRef, oShield, 1)
                                            if M28Utilities.IsTableEmpty(tLowCompletionShieldsToAssist) then break end --redundancy, but hopefully shouldnt happen
                                        end
                                    end

                                    --If still have available engineers, then focus on getting more shielding if either we lack 3 completed shields, or enemy has T3 arti
                                    if M28Utilities.IsTableEmpty(tAvailableEngineers) == false then
                                        if oNearestCompletionShield then
                                            local iLimitOnEngisToAssistShield
                                            if iCompletedShields >= 3 and not(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) then iLimitOnEngisToAssistShield = 1 end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will assist nearest completion shield='..oNearestCompletionShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestCompletionShield)..'; iLimitOnEngisToAssistShield='..(iLimitOnEngisToAssistShield or 'nil')) end
                                            GETemplateAssistUnit(tAvailableEngineers, tAvailableT3EngineersByFaction, iTemplateRef, oNearestCompletionShield, iLimitOnEngisToAssistShield)
                                        elseif iCompletedShields + iUnderConstructionShields < iShieldLocations then
                                            if bDebugMessages == true then LOG(sFunctionRef..': We can build more shields so we will') end
                                            bGaveBuildOrder = GETemplateStartBuildingShield(tAvailableEngineers, tAvailableT3EngineersByFaction, tLZTeamData, iPlateau, iLandZone, tTableRef, iTemplateRef, oFirstAeon, oFirstSeraphim, oFirstUEF, oFirstCybran, oFirstEngineer, math.min(4, iShieldLocations - iCompletedShields), nil, bExcludeExpShields)
                                            if bGaveBuildOrder then bTriedBuildingSomething = true end
                                        end
                                        if M28Utilities.IsTableEmpty(tAvailableEngineers) == false then
                                            --Consider building SMD if enemy has nukes
                                            local oDefenceToAssist

                                            if M28UnitInfo.IsUnitValid(tTableRef[M28Map.subrefGESMDUnit]) then
                                                if tTableRef[M28Map.subrefGESMDUnit]:GetFractionComplete() < 1 then
                                                    oDefenceToAssist = tTableRef[M28Map.subrefGESMDUnit]
                                                end
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': oDefenceToAssist='..(oDefenceToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oDefenceToAssist) or 'nil')) end
                                            if oDefenceToAssist then
                                                GETemplateAssistUnit(tAvailableEngineers, tAvailableT3EngineersByFaction, iTemplateRef, oDefenceToAssist)
                                            else
                                                --Assign up to 4 engis to build defences
                                                bGaveBuildOrder = GETemplateConsiderDefences(tAvailableEngineers, tAvailableT3EngineersByFaction, tLZTeamData, iPlateau, iLandZone, tTableRef, iTemplateRef, iTeam, 4)
                                                if bGaveBuildOrder then bTriedBuildingSomething = true end
                                            end
                                            if M28Utilities.IsTableEmpty(tAvailableEngineers) == false then
                                                --We have all our shields constructed (or dont want to devote them all to shields due to enemy not having arti yet); redundancy - check if we have under construction arti
                                                if bDebugMessages == true then LOG(sFunctionRef..': Still have engineers available, oNearestCompletionArti='..(oNearestCompletionArti.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestCompletionArti) or 'nil')..'; bTriedBuildingSomething='..tostring(bTriedBuildingSomething)) end
                                                if oNearestCompletionArti then
                                                    --Assist this
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will assist the arti until completion, oNearestCompletionArti='..oNearestCompletionArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestCompletionArti)) end

                                                    local iMaxEngineers
                                                    --Limit engineers to just 1 if we are low on mass and have another active template which is further along, and this one still has quite a while to go
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to limit engis due to low mass, iHighestCompletionArti='..iHighestCompletionArti..'; Team has low mass='..tostring(M28Conditions.TeamHasLowMass(iTeam))..'; Mass%='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]) end
                                                    if iHighestCompletionArti < 0.6 and M28Conditions.TeamHasLowMass(iTeam) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.025 then
                                                        local oNearestCompletionOtherArti
                                                        local iNearestCompletionOtherArti = iHighestCompletionArti --no point considering arti further from completion than this zone
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of other active templates empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.tPotentiallyActiveGETemplates]))) end
                                                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.tPotentiallyActiveGETemplates]) == false then
                                                            for iEntry, tOtherTableRef in M28Team.tTeamData[iTeam][M28Team.tPotentiallyActiveGETemplates] do
                                                                if bDebugMessages == true then LOG(sFunctionRef..': is other table of arti units empty='..tostring(M28Utilities.IsTableEmpty(tOtherTableRef[M28Map.subrefGEArtiUnits]))) end
                                                                if not(tOtherTableRef == tTableRef) and M28Utilities.IsTableEmpty(tOtherTableRef[M28Map.subrefGEArtiUnits]) == false then
                                                                    for iOtherArti, oOtherArti in tOtherTableRef[M28Map.subrefGEArtiUnits] do
                                                                        if bDebugMessages == true then if M28UnitInfo.IsUnitValid(oOtherArti) then LOG(sFunctionRef..': considering oOtherArti='..oOtherArti.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOtherArti)..'; Fraction complete='..oOtherArti:GetFractionComplete()) end end
                                                                        if M28UnitInfo.IsUnitValid(oOtherArti) and oOtherArti:GetFractionComplete() < 1 and oOtherArti:GetFractionComplete() > iNearestCompletionOtherArti then
                                                                            if bDebugMessages == true then LOG(sFunctionRef..': want to assist this other arti in priority to this template arti') end
                                                                            iNearestCompletionOtherArti = oOtherArti:GetFractionComplete()
                                                                            oNearestCompletionOtherArti = oOtherArti
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Finished considering if want to save mass for other GE template, oNearestCompletionOtherArti='..(oNearestCompletionOtherArti.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestCompletionOtherArti) or 'nil')..'; iNearestCompletionOtherArti='..(iNearestCompletionOtherArti or 'nil')..'; iHighestCompletionArti='..iHighestCompletionArti) end
                                                        if oNearestCompletionOtherArti and not(oNearestCompletionOtherArti == oNearestCompletionArti) then
                                                            iMaxEngineers = 1
                                                        end

                                                    end
                                                    --GETemplateAssistUnit(tAvailableEngineers, tAvailableT3EngineersByFaction, iTableRef, oUnit, iOptionalMax)
                                                    GETemplateAssistUnit(tAvailableEngineers, tAvailableT3EngineersByFaction, iTemplateRef, oNearestCompletionArti, iMaxEngineers)
                                                end
                                                if M28Utilities.IsTableEmpty(tAvailableEngineers) == false then
                                                    --We have shielding and game-ender, do we have space for a second game-ender type unit (or T3 arti)?
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Have available engineers and no arti to build or assist so want to start building a second (if its possible), iCompletedArti='..iCompletedArti..'; iArtiLocations='..iArtiLocations..'; bTriedBuildingSomething='..tostring(bTriedBuildingSomething)) end
                                                    if iCompletedArti < iArtiLocations and (iCompletedArti >= 1 or not(bTriedBuildingSomething)) and not(oNearestCompletionArti) then
                                                        --First check we have the mass to support                                                                                                                                                                                --GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateau, iLandZone, bOptionalReturnMassToCompleteOtherZoneUnderConstruction, iOptionalSearchRange, iOptionalCategoryFilter)
                                                        local bHaveExperimentalForThisLandZone, iOtherLandZonesWithExperimental, iMassToComplete = GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateau, iLandZone, true,                            nil,            M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to build another gameender unit from this template, iTeam='..(iTeam or 'nil')..'; iOtherLandZonesWithExperimental='..(iOtherLandZonesWithExperimental or 'nil')..'; iMassToComplete='..(iMassToComplete or 'nil')..'; Stored mass='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] or 'nil')..'; Gross mass='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] or 'nil')..'; Av mass%='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] or 'nil')..'; Time='..GetGameTimeSeconds()) end
                                                        if (iOtherLandZonesWithExperimental or 0) == 0 or (iMassToComplete or 0) <= math.max(10000, 5000 + (M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] or 0)) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 800 or (iMassToComplete < 40000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.5 and not(M28Conditions.TeamHasLowMass(iTeam)))
                                                                or (iMassToComplete <= 20000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 5000 and iOtherLandZonesWithExperimental <= 1) then

                                                            --Change the category to build if we have UEF and built a novax, or if we have high mass income on our team and we could be building a paragon
                                                            if not(bHaveAlreadyTriedSwitchingCategoryForNovax) and oFirstUEF and M28Utilities.IsTableEmpty(tTableRef[M28Map.subrefGEArtiUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryNovaxCentre, tTableRef[M28Map.subrefGEArtiUnits])) == false and M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryNovaxCentre, tLZTeamData[M28Map.refiLastGameEnderTemplateCategory]) then
                                                                GETemplateReassessGameEnderCategory(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam, tTableRef, oFirstAeon, oFirstSeraphim, oFirstUEF, oFirstCybran, oFirstEngineer, true)
                                                                bHaveAlreadyTriedSwitchingCategoryForNovax = true
                                                            elseif oFirstAeon and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 600 and M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryParagon, tLZTeamData[M28Map.refiLastGameEnderTemplateCategory]) then
                                                                GETemplateReassessGameEnderCategory(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam, tTableRef, oFirstAeon, oFirstSeraphim, oFirstUEF, oFirstCybran, oFirstEngineer, true)
                                                            end
                                                            GETemplateStartBuildingArtiOrGameEnder(tAvailableEngineers, tAvailableT3EngineersByFaction, tLZData, tLZTeamData, iPlateau, iLandZone, iTeam, tTableRef, iTemplateRef, oFirstAeon, oFirstSeraphim, oFirstUEF, oFirstCybran, oFirstEngineer)
                                                        elseif bDebugMessages == true then LOG(sFunctionRef..': Want to hold off getting another arti or equivalent for now')
                                                        end
                                                    end
                                                    if M28Utilities.IsTableEmpty(tAvailableEngineers) == false then
                                                        --If we have a shield part complete then assist it
                                                        if oNearestCompletionShield then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Redundancy - assist shield as have got all the arti we can, nearest completion shield='..oNearestCompletionShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestCompletionShield)) end
                                                            GETemplateAssistUnit(tAvailableEngineers, tAvailableT3EngineersByFaction, iTemplateRef, oNearestCompletionShield)
                                                        elseif not(bTriedBuildingSomething) and not(oNearestCompletionArti) and not(oDefenceToAssist) and not(oNearestCompletionShield) then
                                                            --Check we have all the completed arti - we may just have decided to wait until we have more mass
                                                            if iCompletedArti >= iArtiLocations and iCompletedShields >= math.min(7,iShieldLocations) then
                                                                --We have built all possible shields and arti/gameenders, so have no more use for engineers for this logic
                                                                tTableRef[M28Map.subrefGEbDontNeedEngineers] = true
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        if iCompletedArti >= iArtiLocations and not(bTriedBuildingSomething) and M28Utilities.IsTableEmpty(tAvailableEngineers) == false and iCompletedShields >= iShieldLocations then
                            tTableRef[M28Map.subrefGEbDontNeedEngineers] = true
                            break
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': We dont have a first engineer')
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have engineers') end
                end

                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitSeconds(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            else
                --No valid units so should abort the loop
                if bDebugMessages == true then LOG(sFunctionRef..': have no valid units so will abort') end
                break
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Aborting loop, is table of engineers empty='..tostring(M28Utilities.IsTableEmpty(tTableRef[M28Map.subrefGEEngineers]))..'; tTableRef[M28Map.subrefGEbDontNeedEngineers]='..tostring(tTableRef[M28Map.subrefGEbDontNeedEngineers])..'; Time='..GetGameTimeSeconds()) end
        if tTableRef[M28Map.subrefGEbDontNeedEngineers] and M28Utilities.IsTableEmpty(tTableRef[M28Map.subrefGEEngineers]) == false then
            for iEngineer, oEngineer in tTableRef[M28Map.subrefGEEngineers] do
                if bDebugMessages == true then LOG(sFunctionRef..': We dont want any more engineers for this template ref, iTemplateRef='..iTemplateRef..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Clearing flag for engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Time='..GetGameTimeSeconds()) end
                M28Orders.IssueTrackedClearCommands(oEngineer)
                --Make sure RAS SACUs have their assigned template cleared
                if oEngineer[M28Building.reftArtiTemplateRefs] and not(EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oEngineer.UnitId)) then
                    oEngineer[M28Building.reftArtiTemplateRefs] = nil
                else
                    ClearEngineerTracking(oEngineer)
                end
            end
        end
    end

    --Redundancy - clear engineers
    if M28Utilities.IsTableEmpty(tTableRef[M28Map.subrefGEEngineers]) == false then
        for iEngineer, oEngineer in tTableRef[M28Map.subrefGEEngineers] do
            if bDebugMessages == true then LOG(sFunctionRef..': Redundancy for clearing engineers for this template ref, iTemplateRef='..iTemplateRef..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Clearing flag for engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Time='..GetGameTimeSeconds()) end
            if M28UnitInfo.IsUnitValid(oEngineer) then
                M28Orders.IssueTrackedClearCommands(oEngineer)
                --Make sure RAS SACUs have their assigned template cleared
                if oEngineer[M28Building.reftArtiTemplateRefs] and not(EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oEngineer.UnitId)) then
                    oEngineer[M28Building.reftArtiTemplateRefs] = nil
                else
                    ClearEngineerTracking(oEngineer)
                end
            end
        end
    end

    tTableRef[M28Map.subrefGEbActiveMonitor] = false
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AssignEngineerToGameEnderTemplate(oEngineer, tLZData, tLZTeamData, iPlateau, iLandZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignEngineerToGameEnderTemplate'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --Will find a gameender tempalte for oEngineer to join, or create a new one if there's no active one

    if bDebugMessages == true then LOG(sFunctionRef..': About to assign engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to gameendertemplate for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Engi team='..oEngineer:GetAIBrain().M28Team) end
    local iTemplateRef
    local bAddedToNewTemplate = false
    --Work out the template ref that we will be assisting, or create a new one if we have none
    --Do we have an active gameendertemplate
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates]) == false then
        for iEntry, tSubtable in tLZTeamData[M28Map.reftActiveGameEnderTemplates] do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iTemplateRef='..iEntry..'; Does it no longer need engis='..tostring(tSubtable[M28Map.subrefGEbDontNeedEngineers])..'; Has it failed ot get an arti location='..tostring(tSubtable[M28Map.subrefbFailedToGetArtiLocation])..'; Is table of arti units empty='..tostring(M28Utilities.IsTableEmpty(tSubtable[M28Map.subrefGEArtiUnits]))) end
            if not(tSubtable[M28Map.subrefGEbDontNeedEngineers]) and not(tSubtable[M28Map.subrefbFailedToGetArtiLocation]) then
                iTemplateRef = iEntry
                break
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': iTemplateRef after checking active templates='..(iTemplateRef or 'nil')) end
    if not(iTemplateRef) then
        bAddedToNewTemplate = true
        function AddBaseTableToLZTeamData(tBaseTable)
            local bProceed = true
            local tNewMidpoint = M28Map.GetPositionFromPathingSegments(tBaseTable[M28Map.subrefiSegX], tBaseTable[M28Map.subrefiSegZ])
            if not(tLZTeamData[M28Map.reftActiveGameEnderTemplates]) then
                tLZTeamData[M28Map.reftActiveGameEnderTemplates] = {}
            else
                --Check we havent already recorded and have flagged it as not needing engineers
                for iExistingTable, tExistingTable in tLZTeamData[M28Map.reftActiveGameEnderTemplates] do
                    if tExistingTable[M28Map.subrefGEMidpoint][1] == tNewMidpoint[1] and tExistingTable[M28Map.subrefGEMidpoint][3] == tNewMidpoint[3] then
                        bProceed = false
                        if not(tExistingTable[M28Map.subrefGEbDontNeedEngineers]) or not(tExistingTable[M28Map.subrefbFailedToGetArtiLocation]) then
                            iTemplateRef = iExistingTable
                        else
                            --We thought we had a valid location but turns out we dont; check if this is the location of a base template, and if so then clear that base template so we dont repeat this issue
                            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefGameEnderTemplateBackupLocationSizeAndSegment]) == false then
                                if tBaseTable[M28Map.subrefiSegX] == tLZData[M28Map.subrefGameEnderTemplateBackupLocationSizeAndSegment][M28Map.subrefiSegX] and tBaseTable[M28Map.subrefiSegZ] == tLZData[M28Map.subrefGameEnderTemplateBackupLocationSizeAndSegment][M28Map.subrefiSegZ] then
                                    M28Utilities.ErrorHandler('Have recorded a failed attempt to build at a backup location so will clear the backup location', true)
                                    tLZData[M28Map.subrefGameEnderTemplateBackupLocationSizeAndSegment] = nil
                                end
                            end

                        end
                        break
                    end
                end
            end
            if bProceed then
                --Work out if we have sera or UEF T3 engis in this zone
                local tSeraAndUEFT3Engis = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer * categories.UEF * categories.TECH3 + M28UnitInfo.refCategoryEngineer * categories.SERAPHIM * categories.TECH3, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                local bHaveLargeShields = not(M28Utilities.IsTableEmpty(tSeraAndUEFT3Engis))
                local tArtiLocations, tShieldLocations
                if bHaveLargeShields then
                    tArtiLocations = tBaseTable[M28Map.subreftLargeArtiLocations]
                    tShieldLocations = tBaseTable[M28Map.subreftLargeShieldLocations]
                else
                    tArtiLocations = tBaseTable[M28Map.subreftSmallArtiLocations]
                    tShieldLocations = tBaseTable[M28Map.subreftSmallShieldLocations]
                end


                table.insert(tLZTeamData[M28Map.reftActiveGameEnderTemplates], {
                    [M28Map.subrefGEMidpoint] = {tNewMidpoint[1], tNewMidpoint[2], tNewMidpoint[3]},
                    [M28Map.subrefGESize] = tBaseTable[M28Map.subrefiSize],
                    [M28Map.subrefGEArtiLocations] = {},
                    [M28Map.subrefGEShieldLocations] = {},
                    [M28Map.subrefGEArtiUnits] = {},
                    [M28Map.subrefGEShieldUnits] = {},
                    [M28Map.subrefGEEngineers] = {},
                    [M28Map.subrefGEbActiveMonitor] = false,
                    [M28Map.subrefGEbDontNeedEngineers] = false,
                    [M28Map.subrefbFailedToGetArtiLocation] = false,
                    [M28Map.subrefGEbActiveShieldMonitor] = false,
                    [M28Map.subrefiCyclesWaitingForEngineer] = 0
                })
                iTemplateRef = table.getn(tLZTeamData[M28Map.reftActiveGameEnderTemplates])
                for _, tLocation in tArtiLocations do
                    table.insert(tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplateRef][M28Map.subrefGEArtiLocations], {tLocation[1], tLocation[2], tLocation[3]})
                end
                for _, tLocation in tShieldLocations do
                    table.insert(tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplateRef][M28Map.subrefGEShieldLocations], {tLocation[1], tLocation[2], tLocation[3]})
                end
                --Add SMD to the last shield location, if we can build there, and if we have access to UEF or Seraphim shielding (since Cybran and Aeon shields are too small to cover SMD)
                if bHaveLargeShields then
                    local tLastShield = tShieldLocations[table.getn(tShieldLocations)]
                    local tPotentialSMDLocation = {tLastShield[1] + 4.5, 0, tLastShield[3] - 1.5}
                    tPotentialSMDLocation[2] = GetSurfaceHeight(tPotentialSMDLocation[1], tPotentialSMDLocation[3])
                    if oEngineer:GetAIBrain():CanBuildStructureAt('ueb4302', tPotentialSMDLocation) then
                        tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplateRef][M28Map.subrefGESMDLocation] = {tPotentialSMDLocation[1], tPotentialSMDLocation[2], tPotentialSMDLocation[3]}
                    end
                end


                if bDebugMessages == true then
                    local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(tNewMidpoint)
                    LOG(sFunctionRef..': Have just added a new active gameendertemplate table to iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Size of gameendertemplates table='..table.getn(tLZTeamData[M28Map.reftActiveGameEnderTemplates])..'; Arti locations='..repru(tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplateRef][M28Map.subrefGEArtiLocations])..'; Largest build location pre blacklist for the midpoint segments='..(tLZTeamData[M28Map.subrefBuildLocationSegmentCountBySize][iSegmentX][iSegmentZ] or 'nil')..'; tPotentialSMDLocation='..repru(tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplateRef][M28Map.subrefGESMDLocation])..'; bHaveLargeShields='..tostring(bHaveLargeShields or false)..'; Shield locations='..repru(tShieldLocations)..'; Template size='..tBaseTable[M28Map.subrefiSize]..'; Midpoint='..repru(tBaseTable[M28Map.subrefGEMidpoint])..'; Playable area='..repru(M28Map.rMapPlayableArea))
                end


                --Set a blacklist for this location
                RecordBlacklistLocation(tNewMidpoint, tBaseTable[M28Map.subrefiSize] + 1, 600)
                --Update buildable areas around here
                CheckIfBuildableLocationsNearPositionStillValid(oEngineer:GetAIBrain(), tNewMidpoint, true, tBaseTable[M28Map.subrefiSize])
                if bDebugMessages == true then
                    local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(tNewMidpoint)
                    LOG(sFunctionRef..': Post blacklist and checking buildable locations, largest build location for the midpoint segments='..(tLZTeamData[M28Map.subrefBuildLocationSegmentCountBySize][iSegmentX][iSegmentZ] or 'nil'))
                end
                table.insert(M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.tPotentiallyActiveGETemplates], tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplateRef])
            end
        end

        --See if we have somewhere in this zone we can build a template without needing to reclaim any buildings
        local tiSizesToConsider = {26,24,22} --If changing, then update similar in M28Engineer AssignEngineerToGameEnderTemplate
        local iPreferredSegX, iPreferredSegZ, iPreferredSize, sCurBP, iCurRadius
        local iCurDistToEnemyBase
        local iFurtherstDistToEnemyBase = 0

        --First check if we currently have any locations in the zone still available, in which case we dont need to reclaim anything and can just use this (picking hte largest size locaiton, that is furthest from the enemy base)
        local iPlayableSizeRadius
        for _, iCurSize in tiSizesToConsider do
            iPlayableSizeRadius = iCurSize * 0.5 + 0.5
            if bDebugMessages == true then LOG(sFunctionRef..': Is table for size '..iCurSize..' empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefBuildLocationsBySizeAndSegment][iCurSize]))) end
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefBuildLocationsBySizeAndSegment][iCurSize]) == false then
                sCurBP = tsBlueprintsBySize[iCurSize]
                iCurRadius = iCurSize * 0.5
                for iSegX, tSubtable in tLZData[M28Map.subrefBuildLocationsBySizeAndSegment][iCurSize] do
                    for iSegZ, bValid in tSubtable do
                        local tCurMidpoint = M28Map.GetPositionFromPathingSegments(iSegX, iSegZ)
                        iCurDistToEnemyBase = M28Utilities.GetDistanceBetweenPositions(tCurMidpoint, tLZTeamData[M28Map.reftClosestEnemyBase])
                        if iCurDistToEnemyBase > iFurtherstDistToEnemyBase then
                            --Check we can actually build here, taking into account resource deposits
                            if not(IsBuildLocationBlockedByResources(tLZData, iCurRadius, M28Map.GetPositionFromPathingSegments(iSegX, iSegZ), true)) then
                                --Check we are in the payable area
                                if tCurMidpoint[1] - iPlayableSizeRadius >= M28Map.rMapPlayableArea[1] and  tCurMidpoint[3] - iPlayableSizeRadius >= M28Map.rMapPlayableArea[2] and tCurMidpoint[1] + iPlayableSizeRadius <= M28Map.rMapPlayableArea[3] and tCurMidpoint[3] + iPlayableSizeRadius <= M28Map.rMapPlayableArea[4] then
                                    iFurtherstDistToEnemyBase = iCurDistToEnemyBase
                                    iPreferredSize = iCurSize
                                    iPreferredSegX = iSegX
                                    iPreferredSegZ = iSegZ
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': had thought we had a valid build location but it is outside the playable area, tCurMidpoint='..repru(tCurMidpoint)..'; rMapPlayableArea='..repru(M28Map.rMapPlayableArea)..'; iCurSize='..iCurSize) end
                                end
                            elseif bDebugMessages == true then LOG(sFunctionRef..': Segment X'..iSegX..'Z'..iSegZ..' is blocked by resources so will ignore')
                            end
                        end
                    end
                end
            end
            if iPreferredSize then break end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iPreferredSize after checking if have large enough locatino to build with no relcaiming='..(iPreferredSize or 'nil')) end
        if iPreferredSize then
            --Add this location to the LZTeamData - need to work out where each building will go
            local tMidpoint = M28Map.GetPositionFromPathingSegments(iPreferredSegX, iPreferredSegZ)
            local tBaseTable = M28Map.AddGameEnderTemplateInfoToTable(tMidpoint, iPreferredSize)
            AddBaseTableToLZTeamData(tBaseTable)

        else
            --We dont have anywhere we can build based on current buildable locations; see if we recorded a valid location at the start of the game that we can use instead
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefGameEnderTemplateBackupLocationSizeAndSegment]) == false then
                --Add this location to the LZTeamData
                AddBaseTableToLZTeamData(tLZData[M28Map.subrefGameEnderTemplateBackupLocationSizeAndSegment])
                if bDebugMessages == true then LOG(sFunctionRef..': Have just added the backup location to the gameender active table, iTemplateRef='..(iTemplateRef or 'nil')) end
            end

        end
    end

    if iTemplateRef then

        local bAddEngineer = true
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplateRef][M28Map.subrefGEEngineers]) == false then
            for iRecordedEngineer, oRecordedEngineer in tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplateRef][M28Map.subrefGEEngineers] do
                if oRecordedEngineer == oEngineer then bAddEngineer = false break end
            end
        end
        if bAddEngineer then
            table.insert(tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplateRef][M28Map.subrefGEEngineers], oEngineer)
            oEngineer[M28Building.reftArtiTemplateRefs] = {iPlateau, iLandZone, iTemplateRef}
            if bAddedToNewTemplate then
                --Set priority to 1 so it is hopefully less likely to be overwritten
                oEngineer[refbPrimaryBuilder] = true
                oEngineer[refiAssignedActionPriority] = 1
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Will start a manager for this zone if we dont already have one, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; arti locations='..repru(tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplateRef][M28Map.subrefGEArtiLocations])) end
        if not(tLZTeamData[M28Map.reftActiveGameEnderTemplates][iTemplateRef][M28Map.subrefGEbActiveMonitor]) then
            local iTeam
            if M28UnitInfo.IsUnitValid(oEngineer) then iTeam = oEngineer:GetAIBrain().M28Team end
            ForkThread(GameEnderTemplateManager, tLZData, tLZTeamData, iTemplateRef, iPlateau, iLandZone, iTeam)
        end
    else
        M28Utilities.ErrorHandler('Couldnt find a gameender template for engineer to assist so will clear its orders')
        M28Orders.IssueTrackedClearCommands(oEngineer)
        ClearEngineerTracking(oEngineer)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderActionToAssign(iActionToAssign, iMinTechWanted, iTotalBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iCurPriority, tLZOrWZData, tLZOrWZTeamData, iTeam, iPlateauOrPond, iLandOrWaterZone, toAvailableEngineersByTech, toAssignedEngineers, bIsWaterZone, iSpecificFactionRequiredOverride, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
    --vOptionalVariable can be a table, nil or a value; used to pass info specific to the action if it needs it
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderActionToAssign'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --Dont try getting any mroe BP for htis action if have run out of buildable locations
    local iExpectedBuildingSize = tiLastBuildingSizeFromActionForTeam[iTeam][iActionToAssign]
    if bDebugMessages == true then
        if iExpectedBuildingSize then
            LOG(sFunctionRef..': iExpectedBuildingSize='..(iExpectedBuildingSize or 'nil')..';  tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iSize]='..( tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iExpectedBuildingSize] or 'nil')..'; iMinTechWanted='..(iMinTechWanted or 'nil'))
        else
            LOG(sFunctionRef..': iExpectedBuildingSize is nil,='..(iExpectedBuildingSize or 'nil')..'; iMinTechWanted='..(iMinTechWanted or 'nil'))
        end
    end
    local iPlateauOrZero
    if bIsWaterZone then iPlateauOrZero = 0 else iPlateauOrZero = iPlateauOrPond end

    if iExpectedBuildingSize and (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iExpectedBuildingSize] or 0) == 0 then
        if not(iActionToAssign == refActionBuildMex) and not(iActionToAssign == refActionBuildHydro) then

            if (tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] or 0) < 30 then
                local iSegmentsToConsider = 5
                if (tLZOrWZData[M28Map.subrefiCumulativeSegmentsConsideredForBuilding] or 0) < (tLZOrWZData[M28Map.subrefLZTotalSegmentCount] or 0) then iSegmentsToConsider = 20 end

                --SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, iOptionalMaxSegmentsToConsider)
                SearchForBuildableLocationsForLandOrWaterZone(M28Team.GetFirstActiveM28Brain(iTeam), iPlateauOrZero, iLandOrWaterZone, iSegmentsToConsider)
            end
            if (tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize][iExpectedBuildingSize] or 0) == 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Setting build power to 0 as no buildable locations, tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick]='..(tLZOrWZData[M28Map.subrefSegmentsConsideredThisTick] or 'nil')..'; repru of tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize] for all sizes='..repru(tLZOrWZData[M28Map.subrefBuildLocationSegmentCountBySize])) end
                iTotalBuildPowerWanted = 0
            end
        end
    end

    if iTotalBuildPowerWanted < 0 then M28Utilities.ErrorHandler('Have negative BP wanted')
    elseif iTotalBuildPowerWanted > 0 then
        --Reduce BP for high modifiers where we have at least 50% mass stored and dont have spare engineers
        if iTotalBuildPowerWanted > 15 and M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier] >= 1.5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.35 and tLZOrWZTeamData[M28Map.subrefTbWantBP] and (tLZOrWZTeamData[M28Map.subrefSpareBPByTech][1] == 0 and tLZOrWZTeamData[M28Map.subrefSpareBPByTech][2] == 0 and tLZOrWZTeamData[M28Map.subrefSpareBPByTech][3] == 0) then
            --Only half BP for building the first power if we have lots of power already
            if iTotalBuildPowerWanted > 2 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] then
                if not(iActionToAssign == refActionLoadOntoTransport) and (not(iActionToAssign == refActionBuildPower) or (iMinTechWanted == 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier] * 500)) then
                    iTotalBuildPowerWanted = iTotalBuildPowerWanted * math.max(1 / M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier], 0.35)
                    if bDebugMessages == true then LOG(sFunctionRef..': Significantly build power wanted to reflect our build rate') end
                end
            end
        end

        --Reclaim specific - limit BP to 5 if we have recenlty failed to find something to reclaim
        if (iActionToAssign == refActionReclaimArea or iActionToAssign == refActionReclaimTrees) and tLZOrWZData[M28Map.subrefiTimeFailedToGetReclaim] and GetGameTimeSeconds() - tLZOrWZData[M28Map.subrefiTimeFailedToGetReclaim] <= 3 then
            if bDebugMessages == true then LOG(sFunctionRef..': Time since last failed to get reclaim for this zone='..GetGameTimeSeconds() - tLZOrWZData[M28Map.subrefiTimeFailedToGetReclaim]..'; BP wanted before limitation='..iTotalBuildPowerWanted..'; will cap at 5') end
            iTotalBuildPowerWanted = math.min(5, iTotalBuildPowerWanted)
        end


        --Experimental specific - Dont want to build if we have other engineers in a different zone building an experimental and we dont have the eco to support multiple ones - instead rely on separate engi transfer and mass transfer logic to get the experimental built
        if (iActionToAssign == refActionBuildExperimental or iActionToAssign == refActionBuildSecondExperimental or iActionToAssign == refActionBuildGameEnder or iActionToAssign == refActionBuildExperimentalNavy or iActionToAssign == refActionBuildLandExperimental) then
            if bDebugMessages == true then LOG(sFunctionRef..': About to remove BP wanted for experimental construction if we already have one under construction nearby that has recently started, or are about to start construction, and we cant support multiple at once, and dont have one in this zone') end
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]) == false and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 400 then
                --Do we have negative mass income, or have less than 70% mass stored? Also only consider for land experimentals (not navy) for now:
                if not(bIsWaterZone) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] < 1 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.7) then
                    --NOTE: If changing above thresholds then make sure the M28Events OnConstructionStarted is stricter
                    local iSearchRange = math.max(150, 400 - M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass])
                    local iSearchCategory = nil --means will search for everything
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 140 then
                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 280 then
                            iSearchCategory = M28UnitInfo.refCategoryGameEnder
                        else
                            iSearchCategory = M28UnitInfo.refCategoryGameEnder + M28UnitInfo.refCategoryFixedT3Arti
                        end
                    end
                    local bHaveExperimentalForThisLandZone, iOtherLandZonesWithExperimental, iMassToComplete = GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateauOrPond, iLandOrWaterZone, true, iSearchRange, iSearchCategory)
                    if iMassToComplete >= math.max(15000, M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] * 1.25) and not(bHaveExperimentalForThisLandZone) then
                        --Estimate how long it will take to complete if we manage to spend 40% of gross mass on existing experimentals
                        if (iMassToComplete - M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]) / M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 0.4 > 40 then
                            iTotalBuildPowerWanted = 0
                            if bDebugMessages == true then LOG(sFunctionRef..': iMassToComplete='..iMassToComplete..'; Mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; will set BPWanted to 0') end
                        end
                    end
                end
            end
        end
        --Reduce the build power wanted by the existing build power assigned to that action for the LZ, unless bBPIsInAdditionToExisting is true or bMarkAsSpare is true
        local bAlreadyHaveTechLevelWanted = false
        if M28Utilities.IsTableEmpty(toAssignedEngineers) == false and iTotalBuildPowerWanted > 0 and not(bMarkAsSpare) then
            local iSubstituteAction = tiActionSubstitute[iActionToAssign]
            for iEngi, oEngi in toAssignedEngineers do
                if not(oEngi[M28UnitInfo.refbSpecialMicroActive]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..': Considering if oEngi '..oEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngi)..' already has iActionToAssign '..iActionToAssign..'; oEngi[refiAssignedAction]='..(oEngi[refiAssignedAction] or 'nil')..'; Engi tech level='..M28UnitInfo.GetUnitTechLevel(oEngi)..'; iMinTechWanted='..iMinTechWanted) end
                    if oEngi[refiAssignedAction] == iActionToAssign or (iSubstituteAction and oEngi[refiAssignedAction] == iSubstituteAction) then
                        if not(bAlreadyHaveTechLevelWanted) and M28UnitInfo.GetUnitTechLevel(oEngi) >= iMinTechWanted then
                            --Only flag as having min tech level wanted if we will be able to make use of this engineer per the later code
                            if not(tbIgnoreEngineerAssistance[iActionToAssign]) and oEngi[M28Orders.reftiLastOrders] and oEngi[M28Orders.reftiLastOrders][oEngi[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild then
                                bAlreadyHaveTechLevelWanted = true
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Reducing total Build power wanted by '..oEngi:GetBlueprint().Economy.BuildRate..' unless bBPIsInAdditionToExisting is true; bBPIsInAdditionToExisting='..tostring(bBPIsInAdditionToExisting or false)) end
                        if not(bBPIsInAdditionToExisting) then
                            iTotalBuildPowerWanted = iTotalBuildPowerWanted - oEngi:GetBlueprint().Economy.BuildRate
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': About to check if want to lower tech level wanted, bAlreadyHaveTechLevelWanted='..tostring(bAlreadyHaveTechLevelWanted)..'; iMinTechWanted='..iMinTechWanted..'; Is campaign map='..tostring(M28Map.bIsCampaignMap)) end
        if bAlreadyHaveTechLevelWanted and not(bDontUseLowerTechEngineersToAssist) then iMinTechWanted = 1
            --Campaign - might have T3 air fac but not be able to build T3 engineers
        elseif iMinTechWanted > 1 and (M28Map.bIsCampaignMap or M28Overseer.bUnitRestrictionsArePresent) and (iActionToAssign == refActionBuildLandFactory or iActionToAssign == refActionBuildAirFactory or iActionToAssign == refActionBuildPower or iActionToAssign == refActionBuildSecondLandFactory or iActionToAssign == refActionBuildSecondAirFactory) and M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            --Check we have engineers of the relevant tech level to be able to build the factory
            local iEngiCategoryWanted
            if iMinTechWanted >= 3 then iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer * categories.TECH3
            else iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer - categories.TECH1
            end
            local tExistingEngineersOfCategory = EntityCategoryFilterDown(iEngiCategoryWanted, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if bDebugMessages == true then LOG(sFunctionRef..': Is tExistingEngineersOfCategory empty='..tostring(M28Utilities.IsTableEmpty(tExistingEngineersOfCategory))) end
            if M28Utilities.IsTableEmpty(tExistingEngineersOfCategory) then
                if bDebugMessages == true then LOG(sFunctionRef..': Will lower min tech level wanted to build a factory due to being a campaign or having unit restrictions') end
                iMinTechWanted = iMinTechWanted - 1
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; iActionToAssign='..iActionToAssign..'; iTeam='..iTeam..'; iPlateauOrPond='..iPlateauOrPond..'; iLandOrWaterZone='..iLandOrWaterZone..'; Have just updated BP wanted for existing engineers with the same action, iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; Is toAvailableEngineersByTech empty='..tostring(M28Utilities.IsTableEmpty(toAvailableEngineersByTech))..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted) end


        --Do we have an engineer of the tech level wanted? First assign any available engineers of the right tech level to the action
        --If we dont have any engineers of the right tech level available, then see if we have an engineer with a lower priority action
        local tEngineersOfTechWanted
        if toAvailableEngineersByTech and iTotalBuildPowerWanted > 0 then tEngineersOfTechWanted = GetEngineersOfTechWanted(iMinTechWanted, toAvailableEngineersByTech) end
        if M28Utilities.IsTableEmpty(toAvailableEngineersByTech) and iTotalBuildPowerWanted > 0 and M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
            local bConsiderRetreatingEngineers = false
            if iActionToAssign == refActionBuildEmergencyPD and (tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or (tLZOrWZTeamData[M28Map.subrefLZCoreExpansion] and (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) < (tLZOrWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0))) then
                bConsiderRetreatingEngineers = true
            end
            --Do we have already assigned engineers with a lower priority that we could use?
            local iEngiCategoryWanted
            if iMinTechWanted <= 1 then iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer
            elseif iMinTechWanted == 2 then iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer * categories.TECH2 + M28UnitInfo.refCategoryEngineer * categories.TECH3
            else iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer * categories.TECH3
            end
            local toAssignedEngisOfTechLevel = EntityCategoryFilterDown(iEngiCategoryWanted, toAssignedEngineers)
            if M28Utilities.IsTableEmpty(toAssignedEngisOfTechLevel) == false then
                tEngineersOfTechWanted = {}
                local iHighestPriorityEngi = iCurPriority
                local oHighestPriorityEngi
                for iEngi, oEngi in toAssignedEngisOfTechLevel do
                    if not(oEngi[refbPrimaryBuilder]) and not(oEngi[refiAssignedAction] == iActionToAssign) and oEngi[refiAssignedActionPriority] > iHighestPriorityEngi and not(oEngi:IsUnitState('Reclaiming')) and not(oEngi:IsUnitState('Attached')) and not(oEngi:IsUnitState('Capturing')) then
                        --Exception for engineers assisting a shield
                        if not(oEngi[refiAssignedAction] == refActionAssistShield) or not(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) or (M28Team.tTeamData[iTeam][M28Team.refiEnemyT3ArtiCount] == 0 and M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] <= 2) then
                            iHighestPriorityEngi = oEngi[refiAssignedActionPriority]
                            oHighestPriorityEngi = oEngi
                        end
                    elseif bConsiderRetreatingEngineers and not(oHighestPriorityEngi) and oEngi[refiAssignedActionPriority] < iHighestPriorityEngi and oEngi[refiAssignedAction] == refActionRunToLandZone and not(oEngi:IsUnitState('Reclaiming')) and not(oEngi:IsUnitState('Attached')) and not(oEngi:IsUnitState('Capturing')) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will make use of engi running away to build emergency PD') end
                        oHighestPriorityEngi = oEngi
                    end
                end
                if oHighestPriorityEngi then
                    table.insert(tEngineersOfTechWanted, oHighestPriorityEngi)
                    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; iMinTechWanted='..iMinTechWanted..'; oHighestPriorityEngi='..oHighestPriorityEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oHighestPriorityEngi)..'; oHighestPriorityEngi action='..(oHighestPriorityEngi[refiAssignedAction] or 'nil')..' with a priority '..(oHighestPriorityEngi[refiAssignedActionPriority] or 'nil')..'; Is primary='..tostring(oHighestPriorityEngi[refbPrimaryBuilder] or false)..'; table size='..table.getn(tEngineersOfTechWanted)) end
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Is tEngineersOfTechWanted empty='..tostring(M28Utilities.IsTableEmpty(tEngineersOfTechWanted))) end
        if M28Utilities.IsTableEmpty(tEngineersOfTechWanted) == false and iTotalBuildPowerWanted > 0 then

            local sOrderRef = 'A'..iActionToAssign..'Pr'..iCurPriority --For debugging - if show unit names then will include this
            local iMaxSearchRange = 180 --Must be bigger than the largest land zone or else units wont be able to build, so can lead to engineers entering a land zone to build and then moving away to a different land zone
            local iEngiCount = table.getn(tEngineersOfTechWanted)
            local iCurEngiTechLevel
            local iCurEngiBuildPower
            local aiBrain = tEngineersOfTechWanted[1]:GetAIBrain()
            local iMinCategoryTechLevel = iMinTechWanted
            --Override tech level if we lack the relevant factory HQ
            if iActionToAssign == refActionBuildLandFactory or iActionToAssign == refActionBuildSecondLandFactory then
                iMinCategoryTechLevel = math.max(1, math.min(iMinTechWanted, (aiBrain[M28Economy.refiOurHighestLandFactoryTech] or 1)))
            elseif iActionToAssign == refActionBuildAirFactory or iActionToAssign == refActionBuildSecondAirFactory then
                iMinCategoryTechLevel = math.max(1, math.min(iMinTechWanted, (aiBrain[M28Economy.refiOurHighestAirFactoryTech] or 1)))
            elseif iActionToAssign == refActionBuildNavalFactory then
                iMinCategoryTechLevel = math.max(1, math.min(iMinTechWanted, (aiBrain[M28Economy.refiOurHighestNavalFactoryTech] or 1)))
            end
            --Check faction available
            local tbEngineersOfFaction
            if tbActionsWithFactionSpecificLogic[iActionToAssign] and not(bAlreadyHaveTechLevelWanted) then
                tbEngineersOfFaction = {}
                for iUnit, oUnit in tEngineersOfTechWanted do
                    tbEngineersOfFaction[M28UnitInfo.GetUnitFaction(oUnit)] = true
                end
            end

            local iCategoryWanted, iOptionalFactionRequired = GetCategoryToBuildOrAssistFromAction(iActionToAssign, iMinCategoryTechLevel, aiBrain, tbEngineersOfFaction, tLZOrWZData, tLZOrWZTeamData, iPlateauOrZero, iLandOrWaterZone)
            --Land and air facs - optional variable can be used to specify max tech level to use
            if vOptionalVariable and (iActionToAssign == refActionBuildAirFactory or iActionToAssign == refActionBuildLandFactory or iActionToAssign == refActionBuildSecondLandFactory or iActionToAssign == refActionBuildSecondLandFactory) and vOptionalVariable >= iMinCategoryTechLevel and (vOptionalVariable == 1 or vOptionalVariable == 2) then
                iCategoryWanted = iCategoryWanted * M28UnitInfo.ConvertTechLevelToCategory(vOptionalVariable)
            end
            if iSpecificFactionRequiredOverride and not(iOptionalFactionRequired) then iOptionalFactionRequired = iSpecificFactionRequiredOverride end

            function UpdateBPTracking()
                iCurEngiTechLevel = M28UnitInfo.GetUnitTechLevel(tEngineersOfTechWanted[iEngiCount])
                iCurEngiBuildPower = tEngineersOfTechWanted[iEngiCount]:GetBlueprint().Economy.BuildRate
                iTotalBuildPowerWanted = iTotalBuildPowerWanted - iCurEngiBuildPower
                if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[iCurEngiTechLevel]) == false then --If we are reassigning an engineer this wont have a value
                    for iEngi, oEngi in toAvailableEngineersByTech[iCurEngiTechLevel] do
                        if oEngi == tEngineersOfTechWanted[iEngiCount] then
                            table.insert(toAssignedEngineers, tEngineersOfTechWanted[iEngiCount])
                            table.remove(toAvailableEngineersByTech[iCurEngiTechLevel], iEngi)
                            break
                        end
                    end
                end

                tEngineersOfTechWanted[iEngiCount] = nil
                iEngiCount = iEngiCount - 1
            end

            if bDebugMessages == true then LOG(sFunctionRef..': iActionToAssign='..iActionToAssign..'; iEngiCount='..iEngiCount..'; Is category watned nil='..tostring(iCategoryWanted == nil)..'; iMinCategoryTechLevel='..(iMinCategoryTechLevel or 'nil')) end

            --Special logic for converting an action to a different one:
            if iCategoryWanted == refActionManageGameEnderTemplate then iActionToAssign = refActionManageGameEnderTemplate iCategoryWanted = nil end


            if iCategoryWanted then
                --Do we have a part complete unit of this category already under construction in this land zone?
                --Building a factory - change whether to search for assistance based on mass stored %; for mass storage instead base the check on how many locations we have as we may be trying to build a second storage
                local iConstructionCountToIgnore = (tiIgnoreUnderConstructionThreshold[iActionToAssign] or 0)
                --local bShouldIgnoreUnderConstruction = tbIgnoreUnderConstructionActions[iActionToAssign]
                if iActionToAssign == refActionBuildLandFactory or iActionToAssign == refActionBuildAirFactory then
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 15 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then iConstructionCountToIgnore = 1 end
                elseif iActionToAssign == refActionBuildMassStorage and table.getn(tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable]) >= 5 then iConstructionCountToIgnore = 1
                elseif iConstructionCountToIgnore > 0 and iActionToAssign == refActionBuildSecondExperimental then
                    if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti + M28UnitInfo.refCategoryParagon + M28UnitInfo.refCategorySML * categories.EXPERIMENTAL, iCategoryWanted) then
                        iConstructionCountToIgnore = 0
                    end
                end

                local oBuildingToAssist
                if iConstructionCountToIgnore < 100 then
                    --We adjust power to only consider the min tech levle not higher ones (presumably so we can build t1/t2 power when we have access to t3, if we need more power to build t3); therefore need to take this into account here
                    local iUnderConstructionCategory
                    if iActionToAssign == refActionBuildPower then
                        iUnderConstructionCategory = M28UnitInfo.refCategoryPower - M28UnitInfo.refCategoryHydro
                    else iUnderConstructionCategory = iCategoryWanted
                    end
                    oBuildingToAssist = GetPartCompleteBuildingInZone(iTeam, iPlateauOrPond, iLandOrWaterZone, iUnderConstructionCategory, bIsWaterZone, iConstructionCountToIgnore)
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking to see if we have a unit of the desired category. oBuildingToAssist='..(oBuildingToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBuildingToAssist) or 'nil')..'; bIsWaterZone='..tostring(bIsWaterZone)) end
                end

                if oBuildingToAssist then
                    --Assist the building under construction that has the category we want
                    while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                        if bDebugMessages == true then LOG(sFunctionRef..': Assigning engineer for repair action '..iActionToAssign..'; iEngiCount='..iEngiCount..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted) end
                        M28Orders.IssueTrackedRepair(tEngineersOfTechWanted[iEngiCount], oBuildingToAssist, false, sOrderRef)
                        TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, not(bAlreadyHaveTechLevelWanted), iCurPriority, nil, nil, bMarkAsSpare)
                        UpdateBPTracking()
                    end
                else
                    --Dont have any buildings of the type wanted under construction; do we have an engineer already assigned to the same action? If so then assist it
                    local oEngineerToAssist
                    if not(tbIgnoreEngineerAssistance[iActionToAssign]) and M28Utilities.IsTableEmpty(toAssignedEngineers) == false then

                        for iEngi, oEngi in toAssignedEngineers do
                            if oEngi[refiAssignedAction] == iActionToAssign then
                                --Only assist if engi last order was to build
                                if bDebugMessages == true then
                                    if oEngi[M28Orders.reftiLastOrders] then
                                        LOG(sFunctionRef..': Considering if oEngi '..oEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngi)..' can be assisted to build this; tablegetn of last orders='..oEngi[M28Orders.refiOrderCount]..'; reprs of last orders='..reprs(oEngi[M28Orders.reftiLastOrders])..'; refiOrderCount='..oEngi[M28Orders.refiOrderCount]..'; Is the last order to build something='..tostring(oEngi[M28Orders.reftiLastOrders][oEngi[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild))
                                    else
                                        LOG(sFunctionRef..': Considering if oEngi '..oEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngi)..' can be assisted to build this; Engi last orders is nil, reprs='..reprs(oEngi[M28Orders.reftiLastOrders]))
                                    end
                                end
                                if oEngi[M28Orders.reftiLastOrders] and oEngi[M28Orders.reftiLastOrders][oEngi[M28Orders.refiOrderCount]][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild then
                                    --if Engineer cur target is flagged to not  be assisted, then dont assist this engineer
                                    if not(oEngi:GetFocusUnit()[refbDontIncludeAsPartCompleteBuildingForConstruction]) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': We can assist the engineer') end
                                        oEngineerToAssist = oEngi
                                        break
                                    end
                                end
                            end
                        end
                    end
                    if not(oEngineerToAssist) then
                        --Has a building been queued for this land zone even if we havent found an engineer to assist? (e.g. rare cases where engineer queues order then briefly drops out of the land zone list of engineers)
                        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefQueuedBuildings]) == false and iConstructionCountToIgnore == 0 and not(tbIgnoreEngineerAssistance[iActionToAssign]) then
                            for iEntry, tQueuedDetails in tLZOrWZTeamData[M28Map.subrefQueuedBuildings] do
                                if EntityCategoryContains(iCategoryWanted, tQueuedDetails[M28Map.subrefBuildingID]) and M28UnitInfo.IsUnitValid(tQueuedDetails[M28Map.subrefPrimaryBuilder]) and not(tQueuedDetails[M28Map.subrefPrimaryBuilder]:GetFocusUnit()[refbDontIncludeAsPartCompleteBuildingForConstruction]) and not(tQueuedDetails[M28Map.subrefPrimaryBuilder][refiAssignedAction] == refActionSpecialShieldDefence) then
                                    oEngineerToAssist = tQueuedDetails[M28Map.subrefPrimaryBuilder]
                                    break
                                end
                            end
                        end
                    end
                    if oEngineerToAssist then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will assign engineers to build, iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                        local tLastOrder = oEngineerToAssist[M28Orders.reftiLastOrders][oEngineerToAssist[M28Orders.refiOrderCount]]
                        local sBlueprintToBuild = tLastOrder[M28Orders.subrefsOrderBlueprint]
                        local tOrderPosition = tLastOrder[M28Orders.subreftOrderPosition]
                        if sBlueprintToBuild and tOrderPosition and EntityCategoryContains(iCategoryWanted, sBlueprintToBuild) then
                            while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                if tEngineersOfTechWanted[iEngiCount]:CanBuild(sBlueprintToBuild) then
                                    --Can build
                                    M28Orders.IssueTrackedBuild(tEngineersOfTechWanted[iEngiCount], tOrderPosition, sBlueprintToBuild, false, sOrderRef..'B')
                                else
                                    --Assist the engineer for lower tech enginers
                                    M28Orders.IssueTrackedGuard(tEngineersOfTechWanted[iEngiCount], oEngineerToAssist, false, sOrderRef..'A')
                                end
                                TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, nil, nil, bMarkAsSpare)
                                UpdateBPTracking()
                            end

                        else
                            --Assist the engineer for all engineers
                            while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                if bDebugMessages == true then LOG(sFunctionRef..': Assigning engineer for assist engineer action '..iActionToAssign..'; iEngiCount='..iEngiCount..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted) end
                                M28Orders.IssueTrackedGuard(tEngineersOfTechWanted[iEngiCount], oEngineerToAssist, false, sOrderRef..'A')
                                TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, nil, nil, bMarkAsSpare)
                                UpdateBPTracking()
                            end
                        end
                    else

                        if tiActionOrder[iActionToAssign] == M28Orders.refiOrderIssueGuard then
                            --Want to assist something, and are just looking for a single predefined category (so dont need the  later on custom logic)
                            local oUnitToAssist
                            if vOptionalVariable and M28UnitInfo.IsUnitValid(vOptionalVariable) then oUnitToAssist = vOptionalVariable
                            else
                                local oBackupUnit
                                local sAlliedUnitRef
                                if bIsWaterZone then sAlliedUnitRef = M28Map.subreftoLZOrWZAlliedUnits
                                else sAlliedUnitRef = M28Map.subreftoLZOrWZAlliedUnits
                                end
                                local tUnitsOfCategoryInLZ = EntityCategoryFilterDown(tiActionCategory[iActionToAssign], tLZOrWZTeamData[sAlliedUnitRef])
                                if M28Utilities.IsTableEmpty(tUnitsOfCategoryInLZ) == false then
                                    --Shield assistance - special logic
                                    if iActionToAssign == refActionAssistShield then
                                        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftPriorityShieldsToAssist]) then --redundancy
                                            M28Utilities.ErrorHandler('Dont have a priority shield to assist somehow')
                                        else
                                            --Get the shield with the least assistance
                                            local iLowestBPAssisting = 100000
                                            local iCurBPAssisting
                                            for iShield, oShield in tLZOrWZTeamData[M28Map.reftPriorityShieldsToAssist] do
                                                iCurBPAssisting = 0
                                                if M28Utilities.IsTableEmpty(oShield[M28UnitInfo.reftoUnitsAssistingThis]) == false then
                                                    for iAssisting, oAssisting in oShield[M28UnitInfo.reftoUnitsAssistingThis] do
                                                        iCurBPAssisting = iCurBPAssisting + (oAssisting:GetBlueprint().Economy.BuildRate or 0)
                                                    end
                                                end
                                                if iCurBPAssisting < iLowestBPAssisting then
                                                    iLowestBPAssisting = iCurBPAssisting
                                                    oUnitToAssist = oShield
                                                    if iLowestBPAssisting == 0 then break end
                                                end
                                            end
                                        end
                                    else
                                        for iUnit, oUnit in tUnitsOfCategoryInLZ do
                                            if oUnit:GetWorkProgress() > 0 then
                                                oUnitToAssist = oUnit
                                            else
                                                oBackupUnit = oUnitToAssist
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to assist unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' with work progress '..oUnit:GetWorkProgress()) end
                                        end
                                        if not(oUnitToAssist) then oUnitToAssist = oBackupUnit end
                                    end
                                end
                            end
                            if M28UnitInfo.IsUnitValid(oUnitToAssist) then
                                while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                    if bDebugMessages == true then LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to assist unit '..oUnitToAssist.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToAssist)) end
                                    M28Orders.IssueTrackedGuard(tEngineersOfTechWanted[iEngiCount], oUnitToAssist, false, sOrderRef)
                                    TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, nil, nil, bMarkAsSpare)
                                    UpdateBPTracking()
                                end
                            else
                                --Dont have anything to assist
                                if bDebugMessages == true then LOG(sFunctionRef..': Cant assist the desired category so will stop trying to assist it and reduce build power required') end
                                iTotalBuildPowerWanted = 0
                            end

                        else
                            --No building under construciton, and no existing engineer to assist - assign engineers to build instead

                            --Do we need a specific faction? If so then filter available engineers to just these
                            if iOptionalFactionRequired then tEngineersOfTechWanted, iEngiCount = FilterEngineersOfTechAndEngiCountForFaction(iOptionalFactionRequired, tEngineersOfTechWanted) end

                            if iEngiCount > 0 then
                                --Building power - if we get to T3, have at least 750 gross energy per tick, and have an action to build second power, then change building power normally so it builds separately to building second power
                                if iActionToAssign == refActionBuildThirdPower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 1000 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                                    tiIgnoreUnderConstructionThreshold[refActionBuildPower] = 1
                                end
                                local oFirstEngineer = tEngineersOfTechWanted[iEngiCount]
                                local sBlueprint, tBuildLocation
                                local iAdjacencyCategory

                                --Early game - build cheapest option of a unit (e.g. useful for mods that might add expensive hydros or experimental units)
                                local bGetCheapest = false
                                if GetGameTimeSeconds() <= 900 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 10 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 300 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 6 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 15 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and not(iActionToAssign == refActionBuildLandFactory) and not(iActionToAssign == refActionBuildAirFactory) and not(iActionToAssign == refActionBuildExperimental) and not(M28Team.tTeamData[aiBrain.M28Team][M28Team.refiTimeLastNearUnitCap]) then bGetCheapest = true
                                end


                                if bDebugMessages == true then LOG(sFunctionRef..': About to get the blueprint and build location, oFirstEngineer='..oFirstEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFirstEngineer)) end
                                if iActionToAssign == refActionBuildShield or iActionToAssign == refActionBuildSecondShield then
                                    GetMaxShieldSearchRangeForEngineer(oFirstEngineer, iCategoryWanted)
                                    --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerAction, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy,                         tAlternativePositionToLookFrom, bNotYetUsedLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData, bCalledFromGetBestLocation, sBlueprintOverride)
                                    sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted, iMaxSearchRange, tiActionAdjacentCategory[iActionToAssign], vOptionalVariable:GetPosition(), false,                              nil,                nil,                                false,                  tLZOrWZData, tLZOrWZTeamData)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished getting blueprint and build location for shield, sBlueprint='..(sBlueprint or 'nil')..'; tBuildLocation='..repru(tBuildLocation)..'; vOptionalVariable='..(vOptionalVariable.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(vOptionalVariable) or 'nil')..'; iMaxSearchRange='..iMaxSearchRange..'; vOptionalVariable position='..repru(vOptionalVariable:GetPosition())) end
                                    if M28Utilities.IsTableEmpty(tBuildLocation) and vOptionalVariable.UnitId then
                                        vOptionalVariable[refiFailedShieldConstructionCount] = (vOptionalVariable[refiFailedShieldConstructionCount] or 0) + 1
                                        if vOptionalVariable[refiFailedShieldConstructionCount] >= 5 then
                                            --Lower value by 1 in 3 minutes
                                            M28Utilities.DelayChangeVariable(vOptionalVariable, refiFailedShieldConstructionCount, -1, 180, nil, nil, nil, nil, true)
                                        end
                                    end
                                elseif vOptionalVariable and (iActionToAssign == refActionBuildEmergencyPD or iActionToAssign == refActionBuildEmergencyArti) then
                                    --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerAction, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy,                tAlternativePositionToLookFrom, bNotYetUsedLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData, bCalledFromGetBestLocation, sBlueprintOverride)
                                    sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted, iMaxSearchRange, tiActionAdjacentCategory[iActionToAssign], vOptionalVariable,       false,                              nil,             nil,                                   bGetCheapest,                   tLZOrWZData, tLZOrWZTeamData)
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef..': Have just tried to get location for PD, vOptionalVariable='..repru(vOptionalVariable)..'; sBlueprint='..(sBlueprint or 'nil')..'; tBuildLocation='..repru(tBuildLocation))
                                        if M28Utilities.IsTableEmpty(tBuildLocation) == false then
                                            M28Utilities.DrawLocation(tBuildLocation)
                                        end
                                    end
                                elseif vOptionalVariable and iActionToAssign == refActionBuildTMD then
                                    --Build near the unit we want to protect (get blueprint will also factor in maxsearchrange based on the TMD range)
                                    if vOptionalVariable.UnitId then
                                        --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerAction, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy,                tAlternativePositionToLookFrom, bNotYetUsedLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData, bCalledFromGetBestLocation, sBlueprintOverride)
                                        sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted, iMaxSearchRange, tiActionAdjacentCategory[iActionToAssign], vOptionalVariable:GetPosition(), false,                      nil,                nil,                                bGetCheapest, tLZOrWZData, tLZOrWZTeamData)
                                    elseif M28Utilities.IsTableEmpty(vOptionalVariable) == false then
                                        sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted, iMaxSearchRange, tiActionAdjacentCategory[iActionToAssign], vOptionalVariable,               false,                      nil,                nil,                                bGetCheapest, tLZOrWZData, tLZOrWZTeamData)
                                    else
                                        M28Utilities.ErrorHandler('Trying to build TMD without a unit or location')
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Building TMD, sBlueprint='..sBlueprint..'; tBuildLocation='..repru(tBuildLocation)) end
                                elseif iActionToAssign == refActionBuildAirStaging and (bGetCheapest or not(M28Team.tTeamData[aiBrain.M28Team][M28Team.refiTimeLastNearUnitCap])) then
                                    --Mod support for mods that introduce t3 air staging which is very expensive - want to avoid unless close to unit cap
                                    --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerAction, iCategoryToBuild,                                         iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bNotYetUsedLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData, bCalledFromGetBestLocation, sBlueprintOverride)
                                    sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted - categories.TECH3 - categories.EXPERIMENTAL, iMaxSearchRange, iAdjacencyCategory, nil,                           false,                          nil,                nil,                                bGetCheapest,           tLZOrWZData,  tLZOrWZTeamData)
                                else
                                    iAdjacencyCategory = tiActionAdjacentCategory[iActionToAssign]
                                    if not(iAdjacencyCategory) and (iActionToAssign == refActionBuildExperimental or iActionToAssign == refActionBuildSecondExperimental) then
                                        if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti * categories.STRUCTURE + M28UnitInfo.refCategorySML, iCategoryWanted) then
                                            iAdjacencyCategory = M28UnitInfo.refCategoryT3Power
                                        end
                                    end
                                    --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerAction, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bNotYetUsedLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData, bCalledFromGetBestLocation, sBlueprintOverride)
                                    sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted, iMaxSearchRange, iAdjacencyCategory, nil,                                false,                          nil,                nil,                                bGetCheapest, tLZOrWZData, tLZOrWZTeamData)
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Just got blueprint and location to build for oFirstEngineer='..oFirstEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFirstEngineer)..'; iActionTOAssign='..iActionToAssign..'; sBlueprint='..(sBlueprint or 'nil')..'; tBuildLocation='..repru(tBuildLocation)..'; Is tiActionAdjacentCategory[iActionToAssign] nil='..tostring(tiActionAdjacentCategory[iActionToAssign] == nil)) end
                                if M28Utilities.IsTableEmpty(tBuildLocation) then
                                    if not(iActionToAssign == refActionBuildShield or iActionToAssign == refActionBuildSecondShield) then
                                        if sBlueprint and (GetGameTimeSeconds() <= 300 or GetGameTimeSeconds() - (tLZOrWZTeamData[M28Map.refiTimeLastShowedBuildLocationFailure] or -300) >= 300) then
                                            --Couldnt find a build locaiton, but might be valid particularly later in the game or on small island maps, so only show as a warning message every 5m
                                            local Game = import("/lua/game.lua")
                                            if not(Game.IsRestricted(sBlueprint, M28Team.GetFirstActiveM28Brain(iTeam))) then
                                                local bShowError = true
                                                if M28Map.bIsCampaignMap and EntityCategoryContains(M28UnitInfo.refCategoryMex, sBlueprint) then
                                                    --Is the first unbuilt mex location outside the playable area?
                                                    if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefMexUnbuiltLocations][1]) == false and not(M28Conditions.IsLocationInPlayableArea(tLZOrWZData[M28Map.subrefMexUnbuiltLocations][1])) then
                                                        --Mex is outside playable area so dont show error, and dont flag location as needing engis for mexes
                                                        tLZOrWZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] = false
                                                        bShowError = false
                                                    end
                                                end
                                                if bShowError then
                                                    M28Utilities.ErrorHandler('Unable to find build location, iActionToAssign='..(iActionToAssign or 'nil')..'; P'..(iPlateauOrPond or 'nil')..'Z'..(iLandOrWaterZone or 'nil')..'; sBlueprint='..(sBlueprint or 'nil'), true)
                                                    --Note - campaign maps where building mex - reason may be that all the mex locations remaining are outside of the playable area
                                                    tLZOrWZTeamData[M28Map.refiTimeLastShowedBuildLocationFailure] = GetGameTimeSeconds()
                                                    SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateauOrZero, iLandOrWaterZone, nil)
                                                end
                                            end
                                        end
                                    end
                                elseif sBlueprint then
                                    local tMoveLocation
                                    while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Assigning engineer for building action '..iActionToAssign..'; iEngiCount='..iEngiCount..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; tiActionOrder[iActionToAssign]='..(tiActionOrder[iActionToAssign] or 'nil')..'; sBlueprint='..sBlueprint..'; tBuildLocation='..repru(tBuildLocation)..'; Eng cur state='..M28UnitInfo.GetUnitState(tEngineersOfTechWanted[iEngiCount])) end
                                        --Is our order to build or assist?
                                        if tiActionOrder[iActionToAssign] then
                                            if tiActionOrder[iActionToAssign] == M28Orders.refiOrderIssueBuild then
                                                tMoveLocation = GetLocationToMoveForConstruction(tEngineersOfTechWanted[iEngiCount], tBuildLocation, sBlueprint, 0, false)
                                                if tMoveLocation then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Telling engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to move to '..repru(tMoveLocation)..' and then build '..sBlueprint..' at location '..repru(tBuildLocation)) end
                                                    M28Orders.IssueTrackedMoveAndBuild(tEngineersOfTechWanted[iEngiCount], tBuildLocation, sBlueprint, tMoveLocation, 1, false, sOrderRef)
                                                else
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Telling engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to build '..sBlueprint..' at build location '..repru(tBuildLocation)) end
                                                    M28Orders.IssueTrackedBuild(tEngineersOfTechWanted[iEngiCount], tBuildLocation, sBlueprint, false, sOrderRef)
                                                end
                                                TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, true, iCurPriority, nil, nil, bMarkAsSpare)
                                                UpdateBPTracking()
                                                --Mex specific - build a separate unit
                                                if iActionToAssign == refActionBuildMex and iTotalBuildPowerWanted > 0 and iEngiCount > 0 then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Were building a mex at tBuildLocation='..repru(tBuildLocation)..'; however have already assigned an engineer and have more to assign, so will build at a different mex now') end
                                                    --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iOptionalEngineerAction, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bNotYetUsedLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, tLZData, tLZTeamData, bCalledFromGetBestLocation, sBlueprintOverride)
                                                    sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iActionToAssign, iCategoryWanted, iMaxSearchRange, iAdjacencyCategory, nil,                                false,                          nil,             nil,                                   false,                  tLZOrWZData,    tLZOrWZTeamData)
                                                    if M28Utilities.IsTableEmpty(tBuildLocation) then break end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': New mex build location='..repru(tBuildLocation)) end
                                                end
                                            else
                                                M28Utilities.ErrorHandler('Need to add code for actions that dont involve building, ActionToAssign='..iActionToAssign..'; order ref='..(tiActionOrder[iActionToAssign] or 'nil'))
                                            end
                                        else
                                            M28Utilities.ErrorHandler('Missing action order type for iActionToAssign '..iActionToAssign)
                                        end
                                    end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': Cant build the desired category so will stop trying to build it and reduce build power required') end
                                    iTotalBuildPowerWanted = 0
                                end
                            else
                                iTotalBuildPowerWanted = 0
                                if iOptionalFactionRequired then
                                    if not(tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted]) then tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted] = {} end
                                    tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted][iOptionalFactionRequired] = true
                                end
                            end
                        end
                    end
                end
            else --Dont have a category to search for
                --Order specific logic
                if iActionToAssign == refActionMoveToLandZone then
                    local iTargetLZ
                    local iPlateauToMoveTo
                    if bIsWaterZone then
                        iTargetLZ = vOptionalVariable[2]
                        iPlateauToMoveTo = vOptionalVariable[1]
                    else
                        iTargetLZ = vOptionalVariable
                        iPlateauToMoveTo = iPlateauOrPond
                    end
                    local tTargetLZ = M28Map.tAllPlateaus[iPlateauToMoveTo][M28Map.subrefPlateauLandZones][iTargetLZ]


                    sOrderRef = sOrderRef..'TLZ='..iTargetLZ
                    if M28Utilities.IsTableEmpty(tTargetLZ) then
                        M28Utilities.ErrorHandler('Invalid LZ  for moving to, iPlateauOrPOND='..iPlateauOrPond..'; iPlateauToMoveTo='..(iPlateauToMoveTo or 'nil')..'; will do reprs of iTargetLZ in log')
                        LOG(sFunctionRef..': Invalid LZ for moving to, iPlateauOrPond='..(iPlateauOrPond or 'nil')..'; iTargetLZ='..reprs(iTargetLZ)..'; vOptionalVariable='..reprs(vOptionalVariable))
                    else
                        local tMoveLocation = tTargetLZ[M28Map.subrefMidpoint]
                        while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to move to iPlateauOrPond '..iPlateauOrPond..'; iTargetLZ='..iTargetLZ)
                            end
                            M28Orders.IssueTrackedMove(tEngineersOfTechWanted[iEngiCount], tMoveLocation, 5, false, sOrderRef)
                            TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, {iPlateauToMoveTo, iTargetLZ}, nil, bMarkAsSpare)
                            UpdateBPTracking()
                        end
                    end
                elseif iActionToAssign == refActionMoveToWaterZone then
                    local iTargetWZ = vOptionalVariable
                    local iPond = M28Map.tiPondByWaterZone[iTargetWZ]
                    local tTargetWZ = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iTargetWZ]
                    sOrderRef = sOrderRef..'TWZ='..iTargetWZ
                    if M28Utilities.IsTableEmpty(tTargetWZ) then
                        M28Utilities.ErrorHandler('Invalid WZ  for moving to, iPlateauOrPond='..iPlateauOrPond..'; will do reprs of iTargetWZ in log')
                        LOG(sFunctionRef..': iTargetWZ='..reprs(iTargetWZ))
                    else
                        local tMoveLocation = tTargetWZ[M28Map.subrefMidpoint]
                        while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to move to iPlateauOrPond '..iPlateauOrPond..'; iTargetWZ='..iTargetWZ..'; iPond='..iPond)
                            end
                            M28Orders.IssueTrackedMove(tEngineersOfTechWanted[iEngiCount], tMoveLocation, 5, false, sOrderRef)
                            TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, nil, iTargetWZ, bMarkAsSpare)
                            UpdateBPTracking()
                        end
                    end
                elseif iActionToAssign == refActionAssistUpgrade then
                    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoActiveUpgrades]) then
                        M28Utilities.ErrorHandler('Trying to assist upgrade but there are none for this LZ')
                    else
                        local oBestProgress
                        if vOptionalVariable and M28UnitInfo.IsUnitValid(vOptionalVariable) then
                            oBestProgress = vOptionalVariable
                        else
                            local iBestProgress = 0
                            local iCurProgress
                            for iUnit, oUnit in tLZOrWZTeamData[M28Map.subreftoActiveUpgrades] do
                                if M28UnitInfo.IsUnitValid(oUnit) and oUnit.GetWorkProgress then
                                    iCurProgress = (oUnit:GetWorkProgress() or 0)
                                    if iCurProgress > iBestProgress then
                                        iBestProgress = iCurProgress
                                        oBestProgress = oUnit
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iBestProgress='..iBestProgress..'; Is oBestProgress valid='..tostring(M28UnitInfo.IsUnitValid(oBestProgress))..'; Best progress ID='..(oBestProgress.UnitId or 'nil')..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                        if oBestProgress then
                            while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                if bDebugMessages == true then LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to assist unit '..oBestProgress.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBestProgress)) end
                                M28Orders.IssueTrackedGuard(tEngineersOfTechWanted[iEngiCount], oBestProgress, false, sOrderRef)
                                TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, nil, nil, bMarkAsSpare)
                                UpdateBPTracking()
                            end
                        end
                    end
                elseif iActionToAssign == refActionReclaimArea then
                    local bWantEnergyNotMass = vOptionalVariable[1]
                    while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                        if bDebugMessages == true then LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to reclaim nearby, iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                        --GetEngineerToReclaimNearbyArea(oEngineer,                       iPriorityOverride,   tLZOrWZTeamData, iPlateauOrPondOrPond, iLandOrWaterZone, bWantEnergyNotMass, bOnlyConsiderReclaimInRangeOfEngineer, iMinIndividualValueOverride, bIsWaterZone)
                        GetEngineerToReclaimNearbyArea(tEngineersOfTechWanted[iEngiCount], iCurPriority, tLZOrWZTeamData, iPlateauOrPond,           iLandOrWaterZone,      bWantEnergyNotMass, false, vOptionalVariable[2], bIsWaterZone)
                        UpdateBPTracking()
                    end
                elseif iActionToAssign == refActionReclaimFriendlyUnit or iActionToAssign == refActionReclaimEnemyUnit then
                    --Search for nearest unit in LZ units to be reclaimed
                    local iNearestUnitDist = 10000
                    local oNearestUnit
                    local iCurDist

                    local tUnitsToReclaim
                    if vOptionalVariable then
                        if M28Utilities.IsTableEmpty(tUnitsToReclaim, true) then
                            tUnitsToReclaim = {vOptionalVariable}
                        else
                            tUnitsToReclaim = vOptionalVariable
                        end
                    else
                        tUnitsToReclaim = tLZOrWZTeamData[M28Map.subreftoUnitsToReclaim]
                    end

                    if M28Utilities.IsTableEmpty(tUnitsToReclaim) then
                        M28Utilities.ErrorHandler('Want to reclaim a unit but no units in LZ to reclaim')
                    else
                        while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                            if bDebugMessages == true then LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to move to iPlateauOrPond '..iPlateauOrPond) end


                            local bAreDeadUnits = false
                            for iUnit, oUnit in tUnitsToReclaim do
                                if M28UnitInfo.IsUnitValid(oUnit) then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tEngineersOfTechWanted[iEngiCount]:GetPosition(), oUnit:GetPosition())
                                    if iCurDist < iNearestUnitDist then
                                        iNearestUnitDist = iCurDist
                                        oNearestUnit = oUnit
                                    end
                                else
                                    --Have dead units in the list of units to reclaim, so need to update the table
                                    if not(bAreDeadUnits) then
                                        bAreDeadUnits = true
                                        ForkThread(M28Economy.RefreshUnitsToReclaim, iTeam, iPlateauOrPond, iLandOrWaterZone)
                                    end
                                end
                            end

                            if oNearestUnit then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to reclaim oNearestUnit='..oNearestUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestUnit)) end
                                M28Orders.IssueTrackedReclaim(tEngineersOfTechWanted[iEngiCount], oNearestUnit, false, 'RecObs')
                                TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, nil, nil, bMarkAsSpare)
                                UpdateBPTracking()
                            else
                                break
                            end
                        end
                    end
                elseif iActionToAssign == refActionLoadOntoTransport then
                    if iTotalBuildPowerWanted > 0 and iEngiCount > 0 then
                        --Load onto first transport in LZ needing engis (max 1 engi per transport)]
                        for iTransport, oTransport in tLZOrWZTeamData[M28Map.reftoTransportsWaitingForEngineers] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Trying to load engi into transport, iEngiCount='..iEngiCount..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; oTransport='..oTransport.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTransport)..'; Engineer='..(tEngineersOfTechWanted[iEngiCount].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount]) or 'nil')..'; Transport engis wanted='..oTransport[M28Air.refiEngisWanted]..'; Transport cargo capacity='..M28Air.GetTransportEngiCargoAndRemainingCapacity(oTransport, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech])) end
                            M28Orders.IssueTrackedTransportLoad(tEngineersOfTechWanted[iEngiCount], oTransport, false, sOrderRef, false)
                            TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority) --(not using bmarkasspare as dont want to change orders for an engiener loading into transport)
                            UpdateBPTracking()
                            if bDebugMessages == true then LOG(sFunctionRef..': Post sending order to load onto transport, iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                            if iEngiCount <= 0 or iTotalBuildPowerWanted <= 0 then
                                break
                            end
                        end
                    end
                elseif iActionToAssign == refActionCaptureUnit then
                    local oUnitToCapture = vOptionalVariable
                    if bDebugMessages == true then LOG(sFunctionRef..': oUnitToCapture='..oUnitToCapture.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToCapture)..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                    while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                        if bDebugMessages == true then LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to capture unit '..oUnitToCapture.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToCapture)..'; iEngiCount='..iEngiCount..' unless it is already capturing') end
                        if not(tEngineersOfTechWanted[iEngiCount]:IsUnitState('Capturing')) then
                            M28Orders.IssueTrackedCapture(tEngineersOfTechWanted[iEngiCount], oUnitToCapture, false, 'Cap', false)
                        end
                        TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority) --(not using bmarkasspare since are capturing and dont want to abort part way through)
                        UpdateBPTracking()
                    end
                elseif iActionToAssign == refActionRepairUnit then
                    local oUnitToRepair = vOptionalVariable
                    while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                        if bDebugMessages == true then LOG(sFunctionRef..': About to tell engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to repair nearby unit '..oUnitToRepair.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToRepair)..', iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                        M28Orders.IssueTrackedRepair(tEngineersOfTechWanted[iEngiCount], oUnitToRepair, false, 'Rep', false)
                        TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, nil, nil, bMarkAsSpare)
                        UpdateBPTracking()
                    end
                elseif iActionToAssign == refActionSpecialShieldDefence then
                    --Get list of units in zone that want defence and get the best faction they think is available
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of units for special shield protection empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]))) end
                    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) then
                        M28Utilities.ErrorHandler('Are trying to do special shield protection but have no units wanting it')
                    else
                        for iUnit, oUnit in tLZOrWZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
                            if oUnit[M28Building.refoNearbyFactoryOfFaction] then
                                iOptionalFactionRequired = M28UnitInfo.GetUnitFaction(oUnit)
                                break
                            end
                        end
                        if iOptionalFactionRequired then tEngineersOfTechWanted, iEngiCount = FilterEngineersOfTechAndEngiCountForFaction(iOptionalFactionRequired, tEngineersOfTechWanted) end
                        if iEngiCount > 0 then
                            while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                AssignEngineerToShieldDefenceDuty(tEngineersOfTechWanted[iEngiCount], tLZOrWZTeamData)
                                if bDebugMessages == true then LOG(sFunctionRef..': Have just assigned engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to do special shield protection logic, will now update tracking of that engineer') end
                                --TRACKING NOTE - this will get cleared so the ActiveShieldMonitor will then impute backup values - i.e. changes made to below are unlikely to have an effect
                                TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, nil, nil, bMarkAsSpare)
                                UpdateBPTracking()
                            end
                        else
                            iTotalBuildPowerWanted = 0
                            if iOptionalFactionRequired then
                                --Flag that we need engineers of the desired faction
                                if not(tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted]) then tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted] = {} end
                                tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted][iOptionalFactionRequired] = true
                            end
                        end
                    end
                elseif iActionToAssign == refActionManageGameEnderTemplate then
                    if iEngiCount > 0 then
                        while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                            AssignEngineerToGameEnderTemplate(tEngineersOfTechWanted[iEngiCount], tLZOrWZData, tLZOrWZTeamData, iPlateauOrPond, iLandOrWaterZone)
                            if bDebugMessages == true then LOG(sFunctionRef..': Have just assigned engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to do special game ender or t3 arti construction, iTeam='..iTeam) end
                            --TRACKING NOTE - this will get cleared so the ActiveShieldMonitor will then impute backup values - i.e. changes made to below are unlikely to have an effect
                            TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign, false, iCurPriority, nil, nil, bMarkAsSpare)
                            UpdateBPTracking()
                        end
                    end

                else
                    if not(aiBrain[M28Overseer.refbCloseToUnitCap]) then
                        --Exception for experimentals where in low mass scenarios where we are building experimentals in another zone already we wont build in this zone
                        if not(iActionToAssign == refActionBuildExperimental or iActionToAssign == refActionBuildSecondExperimental) or not(M28Conditions.TeamHasLowMass(iTeam)) then
                            M28Utilities.ErrorHandler('Unrecognised order, need to add logic, iActionToAssign='..(iActionToAssign or 'nil'))
                        end
                    end
                    iTotalBuildPowerWanted = 0
                end
            end
        end

        --If we still have build power we want to assign, record in the land zone
        if bDebugMessages == true then LOG(sFunctionRef..': About to update BP wanted for iPlateauOrPond'..iPlateauOrPond..'; iLandOrWaterZone='..iLandOrWaterZone..'; iTeam='..iTeam..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; tLZBuildPowerByTechWanted before update='..repru(tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted])) end
        if iTotalBuildPowerWanted > 0 and not(bDontIncreaseLZBPWanted) then
            local iAdditionalBuildPowerWanted
            if not(tLZOrWZTeamData[M28Map.subreftiBPWantedByAction][iActionToAssign]) then
                iAdditionalBuildPowerWanted = iTotalBuildPowerWanted
            else
                if bBPIsInAdditionToExisting then
                    iAdditionalBuildPowerWanted = iTotalBuildPowerWanted
                    iTotalBuildPowerWanted = tLZOrWZTeamData[M28Map.subreftiBPWantedByAction][iActionToAssign] + iTotalBuildPowerWanted
                else
                    iAdditionalBuildPowerWanted = math.max(0, iTotalBuildPowerWanted - tLZOrWZTeamData[M28Map.subreftiBPWantedByAction][iActionToAssign])
                end
            end
            if iAdditionalBuildPowerWanted > 0 then
                tLZOrWZTeamData[M28Map.subreftiBPWantedByAction][iActionToAssign] = iTotalBuildPowerWanted
                tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iMinTechWanted] = (tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iMinTechWanted] or 0) + iTotalBuildPowerWanted
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    for iTech = 3, 1, -1 do
        if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[iTech]) == false then
            return iTech
        end
    end
    return 0
end

function UpdateSpareEngineerNumber(tLZOrWZTeamData, toAvailableEngineersByTech)
    --Intended to be called after running all engineer builder logic for the LZ
    tLZOrWZTeamData[M28Map.subrefSpareBPByTech] = {[1]=0, [2]=0,[3]=0}
    local iTotalBP
    for iTech = 1, 3, 1 do
        if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[iTech]) == false then
            iTotalBP = 0
            for iUnit, oUnit in toAvailableEngineersByTech[iTech] do
                iTotalBP = iTotalBP + oUnit:GetBlueprint().Economy.BuildRate
                if M28Config.M28ShowUnitNames then M28Orders.UpdateUnitNameForOrder(oUnit, 'Idle') end
            end
            tLZOrWZTeamData[M28Map.subrefSpareBPByTech][iTech] = iTotalBP
        end
    end
end

function GetBPToAssignToSMD(iPlateau, iLandZone, iTeam, tLZTeamData, bCoreZone, bHaveLowMass, bWantMorePower)
    --Returns BP to assign, and whether it should be assigned to assist the SMD (returns true) rather than building a new SMD
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPToAssignToSMD'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iBPWanted = 0
    local bAssistSMD = false
    local oUnshieldedSMD
    local oUnderConstructionShield
    --Does this LZ have enough value?
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want SMD for iPlateau '..iPlateau..'; iLandZone '..iLandZone..'; LZ building vlaue='..(tLZTeamData[M28Map.subrefLZSValue] or 'nil')) end
    if tLZTeamData[M28Map.subrefLZSValue] >= 11000 or tLZTeamData[M28Map.reftObjectiveSMDLocation] then
        local tSMD = EntityCategoryFilterDown(M28UnitInfo.refCategorySMD, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local iSMDsWeHave = 0
        local iSMDsWithNoMissiles = 0
        local iUnderConstructionSMD = 0
        local iHighestCompletionUnshieldedSMD = 0.1 --No point shielding SMD below this as we risk it decaying before shield is complete
        local bHaveShieldCoverage
        if M28Utilities.IsTableEmpty(tSMD) == false then
            for iSMDNumber, oSMD in tSMD do
                --Check we've completed construction
                if M28UnitInfo.IsUnitValid(oSMD) then
                    if bDebugMessages == true then LOG(sFunctionRef .. ': Have an SMD '..oSMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oSMD)..', will check if its completed construction; fraction complete='..oSMD:GetFractionComplete()..'; Ammo count='..oSMD:GetTacticalSiloAmmoCount()..'; oSMD[M28Building.refbMissileRecentlyBuilt]='..tostring(oSMD[M28Building.refbMissileRecentlyBuilt] or false)..'; Does SMD have an empty table of shields covering it='..tostring(M28Utilities.IsTableEmpty(oSMD[M28Building.reftoShieldsProvidingCoverage]))..'; Does SMD want shield coverage='..tostring(oSMD[M28Building.refbUnitWantsShielding] or false)..'; oSMD[refiFailedShieldConstructionCount]='..(oSMD[refiFailedShieldConstructionCount] or 'nil')..'; iHighestCompletionUnshieldedSMD='..iHighestCompletionUnshieldedSMD) end
                    --Consider if we want to focus on shielding for this SMD instead
                    if oSMD[M28Building.refbUnitWantsShielding] and M28Utilities.IsTableEmpty(oSMD[M28Building.reftoShieldsProvidingCoverage]) and (oSMD[refiFailedShieldConstructionCount] or 0) <= 2 and oSMD:GetFractionComplete() > iHighestCompletionUnshieldedSMD then
                        iHighestCompletionUnshieldedSMD = oSMD:GetFractionComplete()
                        oUnshieldedSMD = oSMD
                        if bDebugMessages == true then LOG(sFunctionRef..': Setting oSMD as one that we want to shield') end
                    elseif M28Utilities.IsTableEmpty(oSMD[M28Building.reftoShieldsProvidingCoverage]) == false and oSMD:GetFractionComplete() > iHighestCompletionUnshieldedSMD then
                        bHaveShieldCoverage = false
                        for iShield, oShield in oSMD[M28Building.reftoShieldsProvidingCoverage] do
                            if oShield:GetFractionComplete() == 1 then
                                bHaveShieldCoverage = true
                                break
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': bHaveShieldCoverage='..tostring(bHaveShieldCoverage or false)) end
                        if not(bHaveShieldCoverage) then
                            local iClosestShieldCompletion = 0
                            iHighestCompletionUnshieldedSMD = oSMD:GetFractionComplete()
                            for iShield, oShield in oSMD[M28Building.reftoShieldsProvidingCoverage] do
                                if oShield:GetFractionComplete() > iClosestShieldCompletion then
                                    iClosestShieldCompletion = oShield:GetFractionComplete()
                                    oUnderConstructionShield = oShield
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': want to assist part complete shield, oUnderConstructionShield='..(oUnderConstructionShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnderConstructionShield) or 'nil')) end
                        end
                    end
                    if oSMD:GetFractionComplete() == 1 then
                        iSMDsWeHave = iSMDsWeHave + 1
                        if oSMD.GetTacticalSiloAmmoCount and oSMD:GetTacticalSiloAmmoCount() < 1 and not (oSMD[M28Building.refbMissileRecentlyBuilt]) then
                            iSMDsWithNoMissiles = iSMDsWithNoMissiles + 1
                            if bDebugMessages == true then LOG(sFunctionRef..': SMD has no missile, iSMDsWithNoMissiles='..iSMDsWithNoMissiles) end
                        end
                    else
                        iUnderConstructionSMD = iUnderConstructionSMD + 1
                    end
                end
            end
        end

        local iEnemyNukes = 0 --Cant use table.getn
        local iEnemyBattleshipNukes = 0
        local iEnemyNormalNukes = 0
        local bEnemyNukeNotConstructed = true
        if M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) then
            for iNuke, oNuke in M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers] do
                if EntityCategoryContains(categories.BATTLESHIP, oNuke.UnitId) then
                    iEnemyBattleshipNukes = iEnemyBattleshipNukes + 1
                elseif EntityCategoryContains(categories.EXPERIMENTAL, oNuke.UnitId) then
                    iEnemyNormalNukes = iEnemyNormalNukes + 8
                else
                    iEnemyNormalNukes = iEnemyNormalNukes + 1
                end
                if oNuke.GetFractionComplete and oNuke:GetFractionComplete() >= 0.95 then
                    bEnemyNukeNotConstructed = false
                end
            end
        elseif bDebugMessages == true then
            LOG(sFunctionRef .. ': No SML detected but will build SMD anyway as a precaution as we have a good economy')
        end
        if iEnemyBattleshipNukes > 0 and iEnemyNormalNukes == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 500 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 300 or M28Map.bIsCampaignMap) then
            iEnemyNukes = 0
        else
            iEnemyNukes = math.max(iEnemyNormalNukes, iEnemyBattleshipNukes * 0.2, 1) --Redundancy - if table isnt empty enemy must have at least one, and will assume they have 1 if we are building as a precaution
        end
        if oUnshieldedSMD and iHighestCompletionUnshieldedSMD < 1 and not(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) then
            --dont want to shield SMD as a priority if we arent worried about arti/novax
            if bDebugMessages == true then LOG(sFunctionRef..': enemy lacks T3 arti or novax so want to prioritise building SMD overt building shield for it') end
            oUnshieldedSMD = nil
            oUnderConstructionShield = nil
        end
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': iSMDsWeHave=' .. iSMDsWeHave .. '; iEnemyNukes=' .. iEnemyNukes..'; iEnemyNormalNukes='..iEnemyNormalNukes..'; iEnemyBattleshipNukes='..iEnemyBattleshipNukes..'; bEnemyNukeNotConstructed='..tostring(bEnemyNukeNotConstructed))
            if iEnemyNukes > 1 then
                LOG(sFunctionRef .. ': Will now list out each nuke unit ID')
                for iNuke, oNuke in M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers] do
                    LOG(sFunctionRef .. ': iNuke=' .. iNuke .. '; oNuke=' .. oNuke.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oNuke))
                end
            end
        end
        local iSMDWanted = math.min(iEnemyNukes, math.max(1, math.floor((M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) / 5)))
        if bHaveLowMass then
            iSMDWanted = math.min( iEnemyNukes * 2 / 3, iSMDWanted)
            if iEnemyNukes <= 5 then iSMDWanted = math.min(iSMDWanted, 3) end
        end
        --Cap amount of SMD, in turn depending on enemy nuke size
        if iEnemyNukes >= 5 and tLZTeamData[M28Map.subrefLZSValue] >= 12000 * iEnemyNukes then iSMDWanted = math.min(8, iSMDWanted)
        else iSMDWanted = math.min(4, iSMDWanted)
        end

        --Dont get SMD if enemy has no nukes but has nearby T2 arti
        if iEnemyNukes == 0 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
            iSMDWanted = 0
        end

        if iSMDWanted <= 0 and tLZTeamData[M28Map.reftObjectiveSMDLocation] then iSMDWanted = 1 end
        if bDebugMessages == true then LOG(sFunctionRef..': iSMDsWeHave='..iSMDsWeHave..'; iSMDWanted='..iSMDWanted..'; iSMDsWithNoMissiles='..iSMDsWithNoMissiles) end
        if iSMDsWeHave < iSMDWanted or iSMDsWithNoMissiles > 0 then
            if bHaveLowMass or iSMDsWeHave > 0 then iBPWanted = 150
            elseif bWantMorePower then iBPWanted = 225
            else iBPWanted = 300 end
            if not(bCoreZone) then iBPWanted = iBPWanted * 0.5 end
        end
        if iSMDsWithNoMissiles > 0 and (iSMDsWeHave >= iSMDWanted or iSMDsWeHave == iSMDsWithNoMissiles) and iUnderConstructionSMD ==0 then
            --If have under construction SMD then finish it off
            bAssistSMD = true
            iBPWanted = math.max(150, iBPWanted * 3)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iBPWanted='..(iBPWanted or 'nil')..'; bAssistSMD='..tostring(bAssistSMD)..'; oUnderConstructionShield='..(oUnderConstructionShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnderConstructionShield) or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBPWanted, bAssistSMD, oUnshieldedSMD, oUnderConstructionShield
end

function GetBPToAssignToMassStorage(iPlateauOrZero, iLandOrWaterZone, iTeam, tLZOrWZData, tLZOrWZTeamData, bCoreZone, bHaveLowMass, bWantMorePower)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPToAssignToMassStorage'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iBPWanted = 0
    --Are all mexes in the LZ at T2+ or do we have any T3 mexes in the LZ?
    if bDebugMessages == true then LOG(sFunctionRef..': iPlateauOrZero='..iPlateauOrZero..'; iLandOrWaterZone='..iLandOrWaterZone..'; T2+T3 mex count='..tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3]..'; T1 mex count='..tLZOrWZTeamData[M28Map.subrefMexCountByTech][1]..'; Is table of mass storage locations to build empty='..tostring(M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable]))..'; Size of mex table='..table.getn(tLZOrWZData[M28Map.subrefLZMexLocations])..'; Zone mex count='..tLZOrWZData[M28Map.subrefLZMexCount]) end
    if tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] + tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] > 0 and (tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZOrWZTeamData[M28Map.subrefMexCountByTech][1] == 0 or tLZOrWZTeamData[M28Map.subrefMexCountByTech][2] >= 4) then
        --Do we have empty locations for mass storage?
        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable]) == false then
            --Do we have really low power?
            if not(bWantMorePower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] < 0.5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < 0) then

                iBPWanted = 10
                if not (bHaveLowMass) or tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] > 0 then
                    iBPWanted = iBPWanted + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
                    if not (bWantMorePower) then
                        iBPWanted = iBPWanted + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2
                    end
                else
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 50 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0 then
                        iBPWanted = iBPWanted + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 0.5
                    end
                end
            elseif tLZOrWZTeamData[M28Map.subrefMexCountByTech][3] > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 50 then
                iBPWanted = 5
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if have really low power, bWantMorePower='..tostring(bWantMorePower)..'; % E stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored]..'; Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; iBPWanted='..iBPWanted) end
        end
    end
    if iBPWanted > 0 and M28Overseer.bNoRushActive then
        --are any storage locations inside norush?
        local bCanBuild = false
        for iEntry, tLocation in tLZOrWZData[M28Map.subrefLZOrWZMassStorageLocationsAvailable] do
            if M28Conditions.IsLocationInNoRushArea(tLocation) then
                bCanBuild = true
                break
            end
        end
        if not(bCanBuild) then iBPWanted = 0 end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBPWanted
end

function GetBPToAssignToAssistUpgrade(tLZTeamData, iTeam, bCoreZone, bHaveLowMass, bHaveLowPower, bWantMorePower)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPToAssignToAssistUpgrade'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iBPWanted = 0

    if bDebugMessages == true then LOG(sFunctionRef..': Considering if any active upgrades we want to assist; Is table of upgrades empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoActiveUpgrades]))..'; ='..tostring(bWantMorePower)..'; Have low power='..tostring(M28Conditions.HaveLowPower(iTeam))..'; bHaveLowMass='..tostring(bHaveLowMass)..'; bHaveLowPower='..tostring(bHaveLowPower)) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoActiveUpgrades]) == false and (not(bHaveLowPower) or (not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] >= 0.9 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 7))) then
        if not(bWantMorePower) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] > 0.8 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > 2) then
            if bCoreZone then iBPWanted = 5 end
            if not(bHaveLowPower) then
                if not (bHaveLowMass) then
                    iBPWanted = iBPWanted + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2
                    if not (bWantMorePower) then
                        iBPWanted = iBPWanted + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2
                    end
                else
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 50 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0 then
                        iBPWanted = iBPWanted + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
                    end
                end
            end
            if not(bCoreZone) and iBPWanted > 5 then iBPWanted = math.min(25, iBPWanted * 0.5) end
        end
        --Increase assistance if we have lots of upgrades
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] >= 0.95 and not(bHaveLowPower) then
            if table.getn(tLZTeamData[M28Map.subreftoActiveUpgrades]) >= 3 then iBPWanted = iBPWanted * 2
            elseif table.getn(tLZTeamData[M28Map.subreftoActiveUpgrades]) == 2 then iBPWanted = iBPWanted * 1.25
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef .. ': iBPWanted=' .. iBPWanted) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBPWanted
end

function GetBPForShieldAssistance(tLZTeamData, iTeam)
    --Assist shields to defend against arti
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPForShieldAssistance'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iBPWanted = 0
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for game time='..GetGameTimeSeconds()..'; Are we defending against arti='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti])) end
    if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] and (M28Team.tTeamData[iTeam][M28Team.refiEnemyT3ArtiCount] > 0 or M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] > 2) then
        M28Building.RecordPriorityShields(iTeam, tLZTeamData)
        if bDebugMessages == true then LOG(sFunctionRef..': Is the table of priority shields empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]))) end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftPriorityShieldsToAssist]) == false then
            local iEnemyT3ArtiValue = 0
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure]) == false then
                for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure] do
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        if EntityCategoryContains(M28UnitInfo.refCategoryNovaxCentre, oUnit.UnitId) then
                            if oUnit:GetFractionComplete() >= 0.5 then
                                iEnemyT3ArtiValue = iEnemyT3ArtiValue + 0.5
                            else
                                iEnemyT3ArtiValue = iEnemyT3ArtiValue + 0.25
                            end

                        elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti, oUnit.UnitId) then
                            if oUnit:GetFractionComplete() >= 0.75 then
                                iEnemyT3ArtiValue = iEnemyT3ArtiValue + 1
                            else
                                if oUnit:GetFractionComplete() >= 0.25 then
                                    iEnemyT3ArtiValue = iEnemyT3ArtiValue + 0.5
                                else
                                    iEnemyT3ArtiValue = iEnemyT3ArtiValue + 0.25
                                end
                            end
                        end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyMobileSatellites]) == false then
                local iNovaxCount = 0
                for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyMobileSatellites] do
                    iNovaxCount = iNovaxCount + 1
                end
                iEnemyT3ArtiValue = math.max(iEnemyT3ArtiValue, iNovaxCount * 0.5)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is the table of enemy arti empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure]))..'; iEnemyT3ArtiValue='..iEnemyT3ArtiValue..'; number of priority shields for thie LZ='..table.getn(tLZTeamData[M28Map.reftPriorityShieldsToAssist])) end
            local iShieldsWantingAssistance = 0
            local iShieldsRecentlyDamaged = 0
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.5 and iEnemyT3ArtiValue >= 2 then
                iShieldsWantingAssistance = table.getn(tLZTeamData[M28Map.reftPriorityShieldsToAssist])
            else
                local iCurShield, iMaxShield

                for iShield, oShield in tLZTeamData[M28Map.reftPriorityShieldsToAssist] do
                    if M28UnitInfo.IsUnitValid(oShield) then
                        iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                        if iCurShield > 0 and not(oShield[M28UnitInfo.refbPaused]) then
                            if EntityCategoryContains(categories.TECH2, oShield.UnitId) then
                                if iCurShield < iMaxShield * 0.7 then
                                    iShieldsRecentlyDamaged = iShieldsRecentlyDamaged + 0.5
                                end
                            elseif iCurShield < iMaxShield then
                                if iCurShield < iMaxShield * 0.8 then
                                    iShieldsRecentlyDamaged = iShieldsRecentlyDamaged + 1
                                else
                                    iShieldsRecentlyDamaged = iShieldsRecentlyDamaged + 0.75
                                end
                            else
                                --How long since shield took damage?
                                if oShield[M28UnitInfo.refiTimeLastDamaged] and GetGameTimeSeconds() - (oShield[M28UnitInfo.refiTimeLastDamaged] or -100) <= 30 then --If changing also consider changing RecordPriorityShields
                                    if oShield[M28UnitInfo.refiTimeLastDamaged] and GetGameTimeSeconds() - (oShield[M28UnitInfo.refiTimeLastDamaged] or -100) <= 20 then
                                        iShieldsRecentlyDamaged = iShieldsRecentlyDamaged + 0.6
                                    else
                                        iShieldsRecentlyDamaged = iShieldsRecentlyDamaged + 0.3
                                    end
                                end
                            end
                        end
                    end
                end
                if iShieldsRecentlyDamaged > 0 then
                    local iTotalShields = table.getn(tLZTeamData[M28Map.reftPriorityShieldsToAssist])
                    if iTotalShields < iShieldsRecentlyDamaged then
                        iShieldsWantingAssistance = iShieldsRecentlyDamaged + (iTotalShields - iShieldsRecentlyDamaged) * 0.5
                    else
                        iShieldsWantingAssistance = iShieldsRecentlyDamaged
                    end
                end
                if tLZTeamData[M28Map.subrefLZbCoreBase] then iShieldsWantingAssistance = math.max(iShieldsWantingAssistance, 0.4) end

            end
            --Reduce BP for shield assistance if we have lots of mass - i.e. in late game scenario better to spend mass than to assist a full health shield
            iBPWanted = iShieldsWantingAssistance * math.max(120, math.min(780, (360 * iEnemyT3ArtiValue)))
            --Cap BP wanted to equiv of 33 engineers (22 if we have active gameender template in the zone)
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftActiveGameEnderTemplates]) then
                iBPWanted = math.min(iBPWanted, 990)
            else
                iBPWanted = math.min(iBPWanted, 660)
            end

        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iBPWanted='..iBPWanted) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBPWanted
end

function GetBPMinTechAndUnitForFixedShields(tLZData, tLZTeamData, iTeam, bCoreZone, bHaveLowMass, bWantMorePower, bConsideringSecondShield, iLandZoneRef, iPlateau)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPMinTechAndUnitForFixedShields'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iBPWanted = 0
    local iTechLevelWanted = 2
    local oUnitToShield
    local iHighestMassValue = 0
    local iHighMassThreshold = 15000
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..'; Is table of units wanting fixed shields empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitWantingFixedShield]))..'; bConsideringSecondShield='..tostring(bConsideringSecondShield or false)) end
    if M28Conditions.IsTableOfUnitsStillValid(tLZTeamData[M28Map.reftoLZUnitWantingFixedShield]) then
        --Early in a campaign (less than 20m in) - dont get shield if dont have good mass, unless on Aeon mission 5 where need to build shields to defend civilians
        local bGetShield = true
        if M28Map.bIsCampaignMap then
            if bHaveLowMass and GetGameTimeSeconds() <= 1200 and not(ScenarioInfo.Ariel and ScenarioInfo.UEF and ScenarioInfo.Colonies) then --First 20m
                --Does enemy have a >=60% complete arti, and game is at least 10m old?
                if GetGameTimeSeconds() >= 600 then
                    if M28Conditions.GetEnemyT3ArtiEquivalent(iTeam, 1, 0, false, 0.6) > 0 then
                        bGetShield = true
                    else
                        bGetShield = false
                    end
                else
                    bGetShield = false
                end
            end
        else
            --Not a campaign map - dont get a shield if we have a low lifetime experimental count on our team and low mass
            if not(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) and (bHaveLowMass or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 25 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                if (bHaveLowMass and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 20) then
                    bGetShield = false
                elseif M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryExperimentalLevel) < (1 + 0.5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                    bGetShield = false
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bGetShield='..tostring(bGetShield)) end
        if bGetShield then

            --Shield the highest value unit in this LZ that wants a shield, factoring in failed shield attempts
            if bConsideringSecondShield then iHighestMassValue = iHighMassThreshold end --will only try shielding if we have very high value target (e.g. t3 arti or experimental) that is unshielded
            local iCurMass
            local aiBrain = M28Team.GetFirstActiveM28Brain(iTeam)
            local iLowestShieldAttempt = 10 --dont want to keep trying to shield if have failed lots of times (the count gets reset over time)
            local iSegmentsToConsider = 4
            if tLZData[M28Map.subrefiCumulativeSegmentsConsideredForBuilding] < tLZData[M28Map.subrefLZTotalSegmentCount] then iSegmentsToConsider = 15 end

            for iUnit, oUnit in tLZTeamData[M28Map.reftoLZUnitWantingFixedShield] do
                --Increase likelihood the build location we want is available
                SearchForBuildableLocationsForLandOrWaterZone(aiBrain, iPlateau, iLandZoneRef, 15)
                if (oUnit[refiFailedShieldConstructionCount] or 0) <= iLowestShieldAttempt then
                    iCurMass = oUnit:GetBlueprint().Economy.BuildCostMass * oUnit:GetFractionComplete()
                    if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; iCurMass='..reprs(iCurMass)..'; iHighestMassValue='..reprs(iHighestMassValue)..'; (oUnit[refiFailedShieldConstructionCount]='..reprs(oUnit[refiFailedShieldConstructionCount])..'; iLowestShieldAttempt='..reprs(iLowestShieldAttempt)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Build cost mass via blueprint='..(__blueprints[oUnit.UnitId].Economy.BuildCostMass or 'nil')) end
                    if iCurMass and (iCurMass > iHighestMassValue or (oUnit[refiFailedShieldConstructionCount] or 0) < iLowestShieldAttempt) then
                        --Check we are likely to be able ot build a shield nearby
                        if (oUnit[refiFailedShieldBuildDistance] or 0) <= 17 then --Cybran ED4 has a readius of 17
                            if oUnit:GetFractionComplete() >= 0.35 or not(EntityCategoryContains(M28UnitInfo.refCategoryT2Mex, oUnit.UnitId)) or not(bHaveLowMass) then
                                iHighestMassValue = iCurMass
                                oUnitToShield = oUnit
                                iLowestShieldAttempt = (oUnit[refiFailedShieldConstructionCount] or 0)
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurMass='..(iCurMass or 'nil')..'; iHighestMassValue='..(iHighestMassValue or 'nil')..'; Failed shield build distance='..(oUnit[refiFailedShieldBuildDistance] or 0)..'; (oUnit[refiFailedShieldConstructionCount] or 0)='..(oUnit[refiFailedShieldConstructionCount] or 0)) end
            end
            if oUnitToShield then
                if (not(EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnitToShield.UnitId)) or (EntityCategoryContains(M28UnitInfo.refCategoryT3Mex, oUnitToShield.UnitId) and not(bHaveLowMass) and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]))) and (iHighestMassValue >= iHighMassThreshold or (M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] and (M28Team.tTeamData[iTeam][M28Team.refiEnemyT3ArtiCount] > 0 or M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] > 2)) or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 12000) then
                    iTechLevelWanted = 3
                    --Think have logic elsewhere which will make a T3 shield be built if nowhere for T2 shield that will cover it

                end
                iBPWanted = 210
                if bCoreZone or iHighestMassValue >= 25000 then iBPWanted = iBPWanted + 60 end
                if bWantMorePower then iBPWanted = iBPWanted * 0.75 end
                if bHaveLowMass then iBPWanted = iBPWanted * 0.75 end
                if bDebugMessages == true then LOG(sFunctionRef..': Have a unit to shield, bCoreZone='..tostring(bCoreZone or false)..'; M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or false)..'; bWantMorePower='..tostring(bWantMorePower)..'; bHaveLowMass='..tostring(bHaveLowMass)..'; iBPWanted='..iBPWanted) end
            end
        end
    end

    --Second shield - dont get shield if dont ahve a first shield
    if iBPWanted > 0 and bConsideringSecondShield then
        local tExistingShields = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedShield, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local bHaveCompletedShield = false
        if M28Utilities.IsTableEmpty(tExistingShields) == false then
            for iShield, oShield in tExistingShields do
                if oShield:GetFractionComplete() then
                    bHaveCompletedShield = true
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Considering second shield, bHaveCompletedShield in zone='..tostring(bHaveCompletedShield)) end
        if not(bHaveCompletedShield) then
            iBPWanted = 0
        end
    end

    if iBPWanted > 0 and iTechLevelWanted < 3 then
        if oUnitToShield and (oUnitToShield[refiFailedShieldBuildDistance] or 0) > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryT2Mex, oUnitToShield.UnitId)) then
            iTechLevelWanted = 3
        elseif (tLZTeamData[M28Map.refiFixedShieldT2EngiFailureCount] or 0) >= 5 then
            iTechLevelWanted = 3
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': oUnitToShield='..(oUnitToShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnitToShield) or 'nil')..'; iBPWanted='..iBPWanted..'; iTechLevelWanted='..iTechLevelWanted..'; iHighestMassValue='..iHighestMassValue) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBPWanted, iTechLevelWanted, oUnitToShield
end

function GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateau, iLandZone, bOptionalReturnMassToCompleteOtherZoneUnderConstruction, iOptionalSearchRange, iOptionalCategoryFilter)
    --returns two variables, the first is true/false if iLandZone has a queued experimental to build; the second is the number of other land zones for iTeam that have queued experimentals to build
    --Optional variables are all for if bOptionalReturnMassToCompleteOtherZoneUnderConstruction is true, except for iOptionalCategoryFilter
    --bOptionalReturnMassToCompleteOtherZoneUnderConstruction will return the amount of mass needed to complete all under construction experimentals in other zones
    --iOptionalSearchRange Will only include those within iOptionalSearchRange
    --iOptionalCategoryFilter - if specified, then will only count engineers who are building or are queued to build a unit meeting this category (will include everything if nil)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetExperimentalsBeingBuiltInThisAndOtherLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bHaveExperimentalForThisLandZone = false
    local iOtherLandZonesWithExperimental = 0
    local iMassToComplete
    if bOptionalReturnMassToCompleteOtherZoneUnderConstruction then iMassToComplete = 0 end

    if bDebugMessages == true then LOG(sFunctionRef..': Is table of engis building exp empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]))..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; Time='..GetGameTimeSeconds()) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]) == false then
        local tiPlateauAndLZBuildingExperimental = {}
        local toUnderConstructionExperimentalsInOtherZonesByUnitRef = {}
        local iCurPlateau, iCurLZ
        local bIncludeCurEntry
        local sCurBPBeingBuilt
        for iEngi, oEngi in M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals] do
            if M28UnitInfo.IsUnitValid(oEngi) and oEngi[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam] then
                iCurPlateau = oEngi[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][1]
                iCurLZ = oEngi[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2]
                bIncludeCurEntry = nil
                if bDebugMessages == true then LOG(sFunctionRef..': Considering engineer '..oEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngi)..'; iCurPlateau='..(iCurPlateau or 'nil')..'; iCurLZ='..(iCurLZ or 'nil')..'; Engi last order blueprint='..(oEngi[M28Orders.reftiLastOrders][(oEngi[M28Orders.refiOrderCount] or 1)][M28Orders.subrefsOrderBlueprint] or 'nil')..'; Engi last order reprs='..reprs(oEngi[M28Orders.reftiLastOrders])..'; is primary engineer='..tostring(oEngi[refbPrimaryBuilder] or false))
                    local oEngiOrderTarget = oEngi[M28Orders.reftiLastOrders][(oEngi[M28Orders.refiOrderCount] or 1)][M28Orders.subrefoOrderUnitTarget]
                    if M28UnitInfo.IsUnitValid(oEngiOrderTarget) then
                        LOG(sFunctionRef..': oEngiOrderTarget='..oEngiOrderTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngiOrderTarget)..'; Fraction complete='..oEngiOrderTarget:GetFractionComplete())
                        local oOrderTargetFocus = oEngiOrderTarget:GetFocusUnit()
                        if M28UnitInfo.IsUnitValid(oOrderTargetFocus) then
                            LOG(sFunctionRef..': oOrderTargetFocus='..oOrderTargetFocus.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOrderTargetFocus)..'; fraction complete='..oOrderTargetFocus:GetFractionComplete())
                        end
                    end
                end
                if bOptionalReturnMassToCompleteOtherZoneUnderConstruction then --Check if want to include this
                    if not(iCurLZ == iLandZone and iPlateau == iCurPlateau) then
                        bIncludeCurEntry = false
                        local oCurExperimental = oEngi:GetFocusUnit()
                        if oCurExperimental and oCurExperimental:GetFractionComplete() < 1 then
                            if not(iOptionalCategoryFilter) or EntityCategoryContains(iOptionalCategoryFilter, oCurExperimental.UnitId) then
                                if not(toUnderConstructionExperimentalsInOtherZonesByUnitRef[oCurExperimental.EntityId]) then
                                    bIncludeCurEntry = true
                                    toUnderConstructionExperimentalsInOtherZonesByUnitRef[oCurExperimental.EntityId] = oCurExperimental
                                end
                            end
                        end
                    end
                end
                if not(iOptionalCategoryFilter) then
                    bIncludeCurEntry = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have an optional category filter o will include this zone as building an experimental') end
                elseif bIncludeCurEntry == nil then
                    sCurBPBeingBuilt = oEngi[M28Orders.reftiLastOrders][(oEngi[M28Orders.refiOrderCount] or 1)][M28Orders.subrefsOrderBlueprint]
                    if bDebugMessages == true then LOG(sFunctionRef..': sCurBPBeingBuilt='..(sCurBPBeingBuilt or 'nil')) end
                    if sCurBPBeingBuilt and EntityCategoryContains(iOptionalCategoryFilter, sCurBPBeingBuilt) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Are queued up to be building a unit of the specified category so will include this zone as building an experimental') end
                        bIncludeCurEntry = true
                    else
                        local oCurExperimental = oEngi:GetFocusUnit()
                        if oCurExperimental and oCurExperimental:GetFractionComplete() < 1 and EntityCategoryContains(iOptionalCategoryFilter, oCurExperimental.UnitId) then
                            bIncludeCurEntry = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Engi is actively building the experimental' ..oCurExperimental.UnitId..M28UnitInfo.GetUnitLifetimeCount(oCurExperimental)) end
                        end
                    end
                end
                if bIncludeCurEntry then
                    if not(tiPlateauAndLZBuildingExperimental[iCurPlateau]) then tiPlateauAndLZBuildingExperimental[iCurPlateau] = {} end
                    tiPlateauAndLZBuildingExperimental[iCurPlateau][iCurLZ] = (tiPlateauAndLZBuildingExperimental[iCurPlateau][iCurLZ] or 0) + 1
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is tiPlateauAndLZBuildingExperimental empty='..tostring(M28Utilities.IsTableEmpty(tiPlateauAndLZBuildingExperimental))..'; reprs='..reprs(tiPlateauAndLZBuildingExperimental)) end
        if M28Utilities.IsTableEmpty(tiPlateauAndLZBuildingExperimental) == false then
            for iAssignedPlateau, tEngineersByLZ in tiPlateauAndLZBuildingExperimental do
                for iAssignedLZ, iEngineersAssigned in tEngineersByLZ do
                    if iPlateau == iAssignedPlateau and iLandZone == iAssignedLZ then
                        bHaveExperimentalForThisLandZone = true
                    else
                        iOtherLandZonesWithExperimental = iOtherLandZonesWithExperimental + 1
                    end
                end
            end
        end
        if bOptionalReturnMassToCompleteOtherZoneUnderConstruction and M28Utilities.IsTableEmpty(toUnderConstructionExperimentalsInOtherZonesByUnitRef) == false then
            local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
            for iUnit, oUnit in toUnderConstructionExperimentalsInOtherZonesByUnitRef do
                if not(iOptionalSearchRange) or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= iOptionalSearchRange then
                    iMassToComplete = iMassToComplete + (oUnit:GetBlueprint().Economy.BuildCostMass or 0) * (1 - oUnit:GetFractionComplete())
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iOtherLandZonesWithExperimental='..iOtherLandZonesWithExperimental..'; iMassToComplete='..(iMassToComplete or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bHaveExperimentalForThisLandZone, iOtherLandZonesWithExperimental, iMassToComplete
end

function GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, iAdjLZ, iPathingRef, iHighestTechEngiAvailable, bNearbyZone, bIslandPathing, bRequireUnbuiltMexes)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPByTechWantedForAlternativeLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tiBPWantedByTech
    local tAltLZ = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
    if not(M28Map.bIsCampaignMap) or M28Conditions.IsLocationInPlayableArea(tAltLZ[M28Map.subrefMidpoint]) or M28Team.tTeamData[iTeam][M28Team.rebTeamOnlyHasCampaignAI] then
        local tAltLZTeamData = tAltLZ[M28Map.subrefLZTeamData][iTeam]
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Does iAdjLZ '..iAdjLZ..' for plateau '..iPlateau..' want BP='..tostring(tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP])..'; bIslandPathing='..tostring(bIslandPathing or false)..'; base tLZData[M28Map.subrefLZIslandRef]='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..'; iAdjLZ tAltLZ[M28Map.subrefLZIslandRef]='..(tAltLZ[M28Map.subrefLZIslandRef] or 'nil')..'; Is table of unbuilt mexes empty='..tostring(M28Utilities.IsTableEmpty(tAltLZ[M28Map.subrefMexUnbuiltLocations]))..'; bRequireUnbuiltMexes='..tostring(bRequireUnbuiltMexes or false)) end
        if not(bRequireUnbuiltMexes) or (M28Utilities.IsTableEmpty(tAltLZ[M28Map.subrefMexUnbuiltLocations]) == false and (not(tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase]) or M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryEngineer, tAltLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))) then
            local iTotalBPWanted = 0
            --Do we need unbuilt mexes?


            --Does the LZ want BP?
            if tAltLZTeamData[M28Map.subrefTbWantBP] or bIslandPathing then
                --Do we have engis of the right tech level to give to the LZ? (ignore this check if we are trying to move engineers to an island for which the closest LZ doesnt want engineers
                local bHaveSufficientTech = false
                if tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP] then
                    for iTech = 1, iHighestTechEngiAvailable, 1 do
                        if (tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][iTech] or 0) > 0 then
                            bHaveSufficientTech = true
                            break
                        end
                    end
                end

                if bHaveSufficientTech or (bIslandPathing and not(tLZData[M28Map.subrefLZIslandRef] == tAltLZ[M28Map.subrefLZIslandRef])) then
                    --Would we path through any dangerous LZs?
                    if M28Land.IsLandZonePathSafe(iPlateau, tLZData, iTeam, iPathingRef, bIslandPathing) then
                        tiBPWantedByTech = {[1]=0,[2]=0,[3]=0}
                        if not(bIslandPathing) or bHaveSufficientTech then
                            for iTech = 1, iHighestTechEngiAvailable, 1 do
                                if (tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][iTech] or 0) > 0 then
                                    tiBPWantedByTech[iTech] = tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][iTech]
                                    iTotalBPWanted = iTotalBPWanted + tiBPWantedByTech[iTech]
                                end
                            end
                        else
                            for iEntry, iIslandLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][tAltLZ[M28Map.subrefLZIslandRef]] do
                                local tIslandLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iIslandLZ]
                                if tIslandLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP] and M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEngineersTravelingHere]) then
                                    for iTech = 1, iHighestTechEngiAvailable, 1 do
                                        if (tIslandLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][iTech] or 0) > 0 then
                                            tiBPWantedByTech[iTech] = tIslandLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][iTech]
                                            iTotalBPWanted = iTotalBPWanted + tiBPWantedByTech[iTech]
                                            if iTotalBPWanted >= math.min(25, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tIslandLZData[M28Map.subrefLZIslandRef]] * 5) then
                                                break
                                            end
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if iIslandLZ '..iIslandLZ..' wants BP='..tostring(tIslandLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP])..'; Island mex count='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tIslandLZData[M28Map.subrefLZIslandRef]]..'; LZ mex count='..tIslandLZData[M28Map.subrefLZMexCount]..'; iTotalBPWanted after considering this islandLZ='..iTotalBPWanted) end
                            end
                        end
                    end
                end
            end



            --Override - for core land zones dont want any BP from a non-adjacent zone in certain cases
            if bIslandPathing or (not(bNearbyZone) and tiBPWantedByTech and tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase]) then

                local iBPToAssign

                if bIslandPathing then
                    iBPToAssign = math.min(iTotalBPWanted, 25, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tAltLZ[M28Map.subrefLZIslandRef]] * 5)
                else
                    if M28Utilities.IsTableEmpty(tAltLZ[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTEngineersTravelingHere]) then
                        iBPToAssign = math.max(5, iTotalBPWanted - 3 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]])
                    else
                        iBPToAssign = math.max(0, iTotalBPWanted - 3 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]])
                    end
                end
                if iBPToAssign < iTotalBPWanted then
                    local iBPToIgnore = iTotalBPWanted - iBPToAssign
                    local iCurBPToIgnore
                    local iRevisedBPWanted = 0
                    for iTech, iBuildPowerWanted in tiBPWantedByTech do
                        iCurBPToIgnore = math.min(iBuildPowerWanted, iBPToIgnore)
                        tiBPWantedByTech[iTech] = tiBPWantedByTech[iTech] - iCurBPToIgnore
                        iBPToIgnore = iBPToIgnore - iCurBPToIgnore
                        iRevisedBPWanted = iRevisedBPWanted + tiBPWantedByTech[iTech]
                    end
                    if iRevisedBPWanted == 0 then
                        tiBPWantedByTech = nil
                        if bDebugMessages == true then LOG(sFunctionRef..': Have reduced BP wanted by tech for iAdjZone='..iAdjLZ..'; iTotalBPWanted='..iTotalBPWanted..'; iRevisedBPWanted='..iRevisedBPWanted) end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iAdjLZ='..iAdjLZ..'; tiBPWantedByTech='..repru(tiBPWantedByTech)) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tiBPWantedByTech
end

function GetEngisWantedForTransports(tLZTeamData)
    local iTransports = table.getn(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers])
    local iEngisWanted = 0
    for iEntry = iTransports, 1, -1 do
        if not(M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers][iEntry])) or (tLZTeamData[M28Map.reftoTransportsWaitingForEngineers][iEntry][M28Air.refiEngisWanted] or 0) <= 0 then
            table.remove(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers], iEntry)
        else
            iEngisWanted = iEngisWanted + tLZTeamData[M28Map.reftoTransportsWaitingForEngineers][iEntry][M28Air.refiEngisWanted]
        end
    end
    return iEngisWanted
end

function GetZoneAndFactionForPriorityEngineerTravel(tBaseLZTeamData, iTeam, iBaseLandZone, iBasePlateau)
    local iZoneWantingEngineer, iFactionWanted
    for iFactory, oFactory in tBaseLZTeamData[M28Map.reftFactoriesWantedForEngineers] do
        if M28Utilities.IsTableEmpty(oFactory[M28Building.reftoUnitsWantingFactoryEngineers]) == false then
            --Do we already have at least 3 engineers of this factory's faction in the zone that the gameender is in?
            local iFactionRef = M28UnitInfo.GetUnitFaction(oFactory)
            for iUnit, oUnit in oFactory[M28Building.reftoUnitsWantingFactoryEngineers] do
                if M28UnitInfo.IsUnitValid(oUnit) then
                    local iGameEnderPlateau, iGameEnderZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                    local tLZTeamData = M28Map.tAllPlateaus[iGameEnderPlateau][M28Map.subrefPlateauLandZones][iGameEnderZone][M28Map.subrefLZTeamData][iTeam]
                    if tLZTeamData[M28Map.subreftbBPByFactionWanted][iFactionRef] then
                        if  iBasePlateau == iGameEnderPlateau and not(iGameEnderZone == iBaseLandZone) then
                            --How many T3 engineers of this faction do we have traveling to this zone already?
                            local iEngiCatWanted = M28UnitInfo.refCategoryEngineer * categories.TECH3
                            if iFactionRef == M28UnitInfo.refFactionUEF then iEngiCatWanted = iEngiCatWanted * categories.UEF
                            elseif iFactionRef == M28UnitInfo.refFactionAeon then iEngiCatWanted = iEngiCatWanted * categories.AEON
                            elseif iFactionRef == M28UnitInfo.refFactionCybran then iEngiCatWanted = iEngiCatWanted * categories.CYBRAN
                            elseif iFactionRef == M28UnitInfo.refFactionSeraphim then iEngiCatWanted = iEngiCatWanted * categories.SERAPHIM
                            end
                            local iEngisAlreadyTraveling = 0
                            --Want at least 3 enginers traveling of the desired tech level
                            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
                                for iEngi, oEngi in  tLZTeamData[M28Map.subrefTEngineersTravelingHere] do
                                    if M28UnitInfo.IsUnitValid(oEngi) and EntityCategoryContains(iEngiCatWanted, oEngi.UnitId) then
                                        iEngisAlreadyTraveling = iEngisAlreadyTraveling + 1
                                    end
                                end
                            end
                            if iEngisAlreadyTraveling < 3 then
                                iZoneWantingEngineer = iGameEnderZone
                                iFactionWanted = iFactionRef
                                break
                            end
                        end
                    end
                end
            end
        end
        if iZoneWantingEngineer then break end
    end
    return iZoneWantingEngineer, iFactionWanted
end

function GetPDThreatAboveRangeThresholdAlongPath(iPlateau, iLandZone, tLZData, tLZTeamData, iTeam, iRangeThreshold, tTarget)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPDThreatAboveRangeThresholdAlongPath'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; iRangeThreshold='..iRangeThreshold..'; tTarget='..repru(tTarget)..'; Dist from target to LZ mid='..M28Utilities.GetDistanceBetweenPositions(tTarget, tLZData[M28Map.subrefMidpoint])) end
    local iCurPDThreat = 0
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
            if iRange >= iRangeThreshold then
                iCurPDThreat = iCurPDThreat + iThreat
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPDThreat for just this zone='..iCurPDThreat) end
    local iTargetPlateauOrZero, iTargetLandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tTarget)
    if bDebugMessages == true then LOG(sFunctionRef..': iTargetLandZone='..(iTargetLandZone or 'nil')..'; iTargetPlateauOrZero='..(iTargetPlateauOrZero or 'nil')) end
    if iTargetLandZone > 0 and iTargetPlateauOrZero == iPlateau and not(iTargetLandZone == iLandZone) then
        --ACU is in a different land zone
        if bDebugMessages == true then LOG(sFunctionRef..': Table of land zone path from start to target='..repru(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath])) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath]) == false then
            for iEntry, iAdjLZ in  tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath] do
                if not(iAdjLZ == iLandZone) then
                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
                        for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                            if iRange >= iRangeThreshold then
                                iCurPDThreat = iCurPDThreat + iThreat
                            end
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPDThreat after factoring in adjacent zones='..iCurPDThreat) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iCurPDThreat
end

function GetClosestMobileTMLIfWantMoreTMD(iTeam, tLZTeamData)
    --Assumes we have already confirmed there are enemy mobile tml on the enemy team
    --Dont bother trying to get TMD if enemy has units in this zone
    --NOTE: After drafting this decided to use a different approach to tracking mobile TML
    M28Utilities.ErrorHandler('Obsolete never tested code')
    local oMobileTMLToDefendAgainst
    if (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) == 0 and (tLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) == 0 then

        local iZoneTMDCount = 0
        local tZoneTMD = EntityCategoryFilterDown(M28UnitInfo.refCategoryTMD, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tZoneTMD) == false then
            for iUnit, oUnit in tZoneTMD do
                if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then iZoneTMDCount = iZoneTMDCount + 1 end
            end
        end
        if iZoneTMDCount < 4 or (iZoneTMDCount < 16 and tLZTeamData[M28Map.subrefLZSValue] > iZoneTMDCount * 800) then
            --Get the closest enemy TML to midpoint
            local iCurDist
            local iClosestDist = 100000
            local oClosestUnit
            local tMidpoint = tLZTeamData[M28Map.subrefMidpoint]
            for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyMobileTML] do
                iCurDist = M28Utilities.GetDistanceBetweenPositions(tMidpoint, oUnit:GetPosition()) - math.max((oUnit[M28UnitInfo.refiManualRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0))
                if iCurDist < iClosestDist then
                    iClosestDist = iCurDist
                    oClosestUnit = oUnit
                end
            end
            if iClosestDist <= 50 then
                oMobileTMLToDefendAgainst = oClosestUnit
            end

        end
    end
    return oMobileTMLToDefendAgainst
end

function GetCaptureBPWanted(oUnitToCapture, bHaveLowPower, iTeam, bIsCoreBase)
    local iTargetBuildTime = (oUnitToCapture:GetBlueprint().Economy.BuildTime or 1)
    local iBPWanted = math.min(5 + 20 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iTargetBuildTime * 0.25)

    local iTimeToCapture = iTargetBuildTime / iBPWanted
    if iTimeToCapture >= 10 and not(bHaveLowPower) then
        iBPWanted = math.min(40 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iTargetBuildTime / 10)
    end
    iBPWanted = math.max(5, iBPWanted)
    return iBPWanted
end

function ConsiderCoreBaseLandZoneEngineerAssignment(tLZTeamData, iTeam, iPlateau, iLandZone, tEngineers)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderCoreBaseLandZoneEngineerAssignment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    --For land zones in the core base
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local toAvailableEngineersByTech, toAssignedEngineers = FilterToAvailableEngineersByTech(tEngineers, true, tLZData, tLZTeamData, iTeam, iPlateau, iLandZone)
    local bDontCheckPlayableArea = false
    if M28Map.bIsCampaignMap then
        bDontCheckPlayableArea = true
        if M28Team.tTeamData[iTeam][M28Team.rebTeamOnlyHasCampaignAI] then bDontCheckPlayableArea = false end
    end

    tLZTeamData[M28Map.subrefTBuildPowerByTechWanted] = {[1]=0,[2]=0,[3]=0}
    if bDebugMessages == true then LOG(sFunctionRef..': Have just reset BPByTech to 0 for Plateau'..iPlateau..'; LZ='..iLandZone..'; repru='..repru(tLZTeamData[M28Map.subrefTBuildPowerByTechWanted])) end
    --local iCurCondition = 0
    local iCurPriority = 0
    local iHighestTechEngiAvailable
    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
    local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)
    local bWantMorePower = M28Conditions.WantMorePower(iTeam)
    local bWantMoreFactories = M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone)
    local iBPWanted
    local iActiveMexUpgrades = M28Conditions.GetActiveMexUpgrades(tLZTeamData)
    local iNearbyEnemyAirToGroundThreat = tLZTeamData[M28Map.refiEnemyAirToGroundThreat]
    local iHighestTechInZone = M28Conditions.GetHighestTechInZone(iTeam, tLZTeamData) --Highest completed factory HQ or engineer in the zone (or 1 if none)
    local iFactoriesInLZ = 0
    local tFactoriesInLZ
    local aiBrain = ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]]
    local bSaveMassForMML = M28Conditions.SaveMassForMMLForFirebase(tLZData, tLZTeamData, iTeam, bHaveLowMass)



    --For now only do land zone not water zone given water zone includes torp bombers
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
            iNearbyEnemyAirToGroundThreat = iNearbyEnemyAirToGroundThreat + tLZTeamData[M28Map.refiEnemyAirToGroundThreat]
        end
    end

    function HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
        --Done as subfunction for convenience so can just note the key values for the action in question and add on the others that wont change
        --vOptionalVariable can be used for action specific information to save having to recalculate the same thing - could be a table, nil, or a value
        ConsiderActionToAssign(iActionToAssign, math.max(1, iMinTechLevelWanted), iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iCurPriority, tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, toAvailableEngineersByTech, toAssignedEngineers, false, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
    end

    if bDebugMessages == true then
        LOG(sFunctionRef..': About to consider what actions we want to give engineers for iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iTeam='..(iTeam or 'nil')..'; bHaveLowMass='..tostring(bHaveLowMass or false)..'; Team gross mass='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] or 'nil')..'; Lowest mass % stored='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] or 'nil')..'; Team mass stored='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] or 'nil')..'; Team net mass='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] or 'nil')..'; Team gross mass='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] or 'nil'))
        LOG(sFunctionRef..': Repeat of log but without the nil backups to help identify errors, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Team gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Lowest mass % stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; Team mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Team net mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]..'; Team gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass])
    end
    local iMinTechLevelForPower = 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 then
        local iPowerMod = 1 + (M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] - 1) * 0.4
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 2 then
            iPowerMod = iPowerMod + (((ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Economy.refiBrainResourceMultiplier] or 1) - 1) * 0.9)
        else iPowerMod = iPowerMod + (((ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Economy.refiBrainResourceMultiplier] or 1) - 1) * 0.7)
        end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then iPowerMod = iPowerMod + 1 end
        if bDebugMessages == true then LOG(sFunctionRef..': iPowerMod='..iPowerMod..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]='..(tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex] or 'nil')..'; Brain='..(ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].Nickname or 'nil')..'; Resource mod='..(ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Economy.refiBrainResourceMultiplier] or 'nil')) end
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 23 * iPowerMod then iMinTechLevelForPower = 1
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 110 * iPowerMod then iMinTechLevelForPower = 2
        else
            if bHaveLowPower and not(bHaveLowMass) then
                iMinTechLevelForPower = iHighestTechInZone
            else
                iMinTechLevelForPower = M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]
            end
        end

    end

    if bDebugMessages == true then LOG(sFunctionRef..': iMinTechLevelForPower='..iMinTechLevelForPower..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end

    --Active gameender template - want to always have 1 engi on duty as highest priority to avoid having orders cancelled
    iCurPriority = iCurPriority + 1
    if M28Conditions.HaveActiveGameEnderTemplateLogic(tLZTeamData) then
        HaveActionToAssign(refActionManageGameEnderTemplate, 3, 25)
    end

    --Higher priority than low power - if we need to rush T3 AA due to enemy having T3 air and us not having good enoguh AA force
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] <= 3000 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 then
        --Get AirAA threat for the likely subteam in here
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            for iUnit, oUnit in tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits] do
                if oUnit:GetAIBrain().M28AI then
                    aiBrain = oUnit:GetAIBrain()
                    break
                end
            end
            if M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiOurAirAAThreat] <= 1200 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirAA * categories.TECH3) == 0 then
                --Do we have any T3 AA here already?
                local tExistingAirAA = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructureAA * categories.TECH3, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                local bAlreadyHaveT3AA = false
                if M28Utilities.IsTableEmpty(tExistingAirAA) == false then
                    for iUnit, oUnit in tExistingAirAA do
                        if oUnit:GetFractionComplete() >= 1 then
                            bAlreadyHaveT3AA = true
                            break
                        end
                    end
                end
                if not(bAlreadyHaveT3AA) then
                    if not(bSaveMassForMML) or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > (tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0) * 2 then
                        iBPWanted = 30
                        if not(bHaveLowPower) then iBPWanted = 90 end
                        HaveActionToAssign(refActionBuildAA, 3, iBPWanted)
                        if bDebugMessages == true then LOG(sFunctionRef..': T3 AA builder - iBPWanted='..iBPWanted) end
                    end
                end
            end
        end
    end



    --First T2 PD emergency builder if we have no T2 PD and nearby enemy threat (unless are on a t1 land spam map)
    --Approaching enemy guncom - prioritise upgrades if dont have T2, if do have T2 then get T2 PD; also get T2 PD if enemies are in this LZ and we have T2 tech
    iCurPriority = iCurPriority + 1
    local oNearestEnemy
    local iApproachingACUThreat, oNearestEnemyACU = M28Conditions.GetThreatOfApproachingEnemyACUsAndNearestACU(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    local tNearestEnemyACU
    if oNearestEnemyACU then tNearestEnemyACU = oNearestEnemyACU:GetPosition() end
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if emergency PD is needed, iApproachingACUThreat='..iApproachingACUThreat) end
    if not(M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 25 and (((iApproachingACUThreat > 0 or (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2)) and (M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU] or (not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 4))) or (tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false)) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 and (not(M28Overseer.bNoRushActive) or M28Overseer.iNoRushTimer - GetGameTimeSeconds() <= 120 or (not(bHaveLowMass) and not(bHaveLowPower) and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 0)) then
        --We have T2 (or only need T1 due to enemy not having gun), so want to build PD
        local iRangeThreshold = 35 --Range of Aeon guncom
        local iCurPDThreat = 0
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                if iRange >= iRangeThreshold then
                    iCurPDThreat = iCurPDThreat + iThreat
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': We have T2 or better, iCurPDThreat='..iCurPDThreat..'; iAppraochingACUThreat='..iApproachingACUThreat..'; iRangeThreshold='..iRangeThreshold..'; tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]='..repru(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange])..'; iLandZone='..iLandZone) end
        if iCurPDThreat <= 470 then
            --Dont get T2 PD if we need mass for MML as the ACU is a T2 engi ACU with no gun, unless we have minimal threat in this zone
            if not(bSaveMassForMML) or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3 or (iApproachingACUThreat  > tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryMML) >= 5) then
                iBPWanted = 40
                if not(bHaveLowMass) and not(bHaveLowPower) then iBPWanted = 80 end
                local tTargetBuildLocation
                if tNearestEnemyACU then
                    tTargetBuildLocation = GetStartSearchPositionForEmergencyPD(tNearestEnemyACU, tLZData[M28Map.subrefMidpoint], iPlateau, iLandZone, tLZTeamData)
                else
                    local tEnemiesToConsider = {}
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                        for iUnit, oUnit in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                            if M28UnitInfo.IsUnitValid(oUnit) then
                                table.insert(tEnemiesToConsider, oUnit)
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tEnemiesToConsider) == false then
                        if not(oNearestEnemy) then oNearestEnemy = M28Utilities.GetNearestUnit(tLZTeamData[M28Map.reftoNearestDFEnemies], tLZData[M28Map.subrefMidpoint], true, M28Map.refPathingTypeLand) end
                        if oNearestEnemy then --factors in if can path to enemy by land
                            if bDebugMessages == true then LOG(sFunctionRef..': oNearestEnemy='..(oNearestEnemy.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oNearestEnemy) or 'nil')..'; tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint])) end
                            tTargetBuildLocation = GetStartSearchPositionForEmergencyPD(oNearestEnemy:GetPosition(), tLZData[M28Map.subrefMidpoint], iPlateau, iLandZone, tLZTeamData)
                        end
                    end
                    if not(oNearestEnemy) then iBPWanted = 0 end
                end
                if iBPWanted > 0 and tTargetBuildLocation then
                    --Reduce BP wanted if there is nearby T2 arti (as we probably want to get more T2 arti instead)
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then iBPWanted = iBPWanted * 0.5 end
                    HaveActionToAssign(refActionBuildEmergencyPD, 2, iBPWanted, tTargetBuildLocation)
                    if bDebugMessages == true then LOG(sFunctionRef..': Will build emergency T2 PD') end
                end
            end
        end
    end

    --Start of game or low power - build hydro if one nearby, otherwise build pgen
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Low power at start of game builder, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Is table of hydro locations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroLocations]))..'; Is table of unbuilt locations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations]))..'; bHaveLowPower='..tostring(bHaveLowPower)..'; bHaveLowMass='..tostring(bHaveLowMass)) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 200 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 10 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier] then
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroLocations]) == false then
            --Norush check
            if bDebugMessages == true then LOG(sFunctionRef..': CHecking if hydro prevented by norush, M28Overseer.bNoRushActive='..tostring(M28Overseer.bNoRushActive or false)..'; M28Conditions.NoRushPreventingHydroOrMex(tLZData)='..tostring(M28Conditions.NoRushPreventingHydroOrMex(tLZData) or false)) end
            if M28Overseer.bNoRushActive and M28Conditions.NoRushPreventingHydroOrMex(tLZData) then
                if bDebugMessages == true then LOG(sFunctionRef..': Norush is preventing b uilding a hydro at core zone so will just build a pgen, iLandZone='..iLandZone) end
                HaveActionToAssign(refActionBuildPower, iMinTechLevelForPower, 10)
            else

                if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..':  Will try and build a hydro, unless we have no unbuilt locations and have no part complete hydro in which case will build power') end
                local bCanBuildOrAssistHydro = false
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefHydroUnbuiltLocations]) == false then
                    bCanBuildOrAssistHydro = true
                else
                    local tHydroInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryHydro, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tHydroInZone) == false then
                        for iUnit, oUnit in tHydroInZone do
                            if oUnit:GetFractionComplete() < 1 then bCanBuildOrAssistHydro = true break end
                        end
                    end
                end
                --Issue on some maps if lots of hydro locations spread out
                if bDebugMessages == true then LOG(sFunctionRef..': bCanBuildOrAssistHydro='..tostring(bCanBuildOrAssistHydro)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; bHaveLowMass='..tostring(bHaveLowMass)..'; bHaveLowPower='..tostring(bHaveLowPower)..'; Hydros in zone='..table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroLocations])..'; Higheest friendly factory tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; Get power instead of hydro='..tostring(M28Conditions.GetPowerInsteadOfHydroEvenIfHydroAvailable(iTeam, tLZData, tLZTeamData, iPlateau, iLandZone, bHaveLowMass, bHaveLowPower))) end
                if bCanBuildOrAssistHydro and not(M28Conditions.GetPowerInsteadOfHydroEvenIfHydroAvailable(iTeam, tLZData, tLZTeamData, iPlateau, iLandZone, bHaveLowMass, bHaveLowPower)) then
                    HaveActionToAssign(refActionBuildHydro, 1, 10)
                else
                    HaveActionToAssign(refActionBuildPower, iMinTechLevelForPower, 5)
                end
            end
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..': Will try and build PGens') end
            HaveActionToAssign(refActionBuildPower, iMinTechLevelForPower, 5)
        end
    else
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefHydroUnbuiltLocations]) == false and (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 20 >=  M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] or (bHaveLowPower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 0.5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) then
            if bDebugMessages == true then LOG(sFunctionRef..': Have at least 10 energy income on the team, cHecking if hydro prevented by norush, M28Overseer.bNoRushActive='..tostring(M28Overseer.bNoRushActive or false)..'; M28Conditions.NoRushPreventingHydroOrMex(tLZData)='..tostring(M28Conditions.NoRushPreventingHydroOrMex(tLZData) or false)..'; Want power instad of hydro='..tostring(M28Conditions.GetPowerInsteadOfHydroEvenIfHydroAvailable(iTeam, tLZData, tLZTeamData, iPlateau, iLandZone, bHaveLowMass, bHaveLowPower))) end
            if (M28Overseer.bNoRushActive and M28Conditions.NoRushPreventingHydroOrMex(tLZData)) or M28Conditions.GetPowerInsteadOfHydroEvenIfHydroAvailable(iTeam, tLZData, tLZTeamData, iPlateau, iLandZone, bHaveLowMass, bHaveLowPower) then
                if bDebugMessages == true then LOG(sFunctionRef..': Norush is preventing b uilding a hydro so will just build a pgen, iLandZone='..iLandZone) end

                HaveActionToAssign(refActionBuildPower, iMinTechLevelForPower, 10)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': WIll try to build hydro') end
                HaveActionToAssign(refActionBuildHydro, 1, 10)
            end
            --Make sure we have 1 power of the cur tech level provided dont have low mass
        elseif (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 0.5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or (M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= math.max(0.2, 0.15 + 10 * M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]))) and (bHaveLowPower and ((not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 30 or GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or -100) <= 10)) or (not(bHaveLowMass) and bWantMorePower and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < (30 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] + 160 * math.max(0, (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] - 2))) * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier]) then
            --Exception if recently built power and have nearby enemies (so can e.g. do things like PD)
            if iNearbyEnemyAirToGroundThreat == 0 and (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) == 0 and not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.35 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 3 then
                iBPWanted = 4 * tiBPByTech[iMinTechLevelForPower]
                if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                    iBPWanted = 3 * tiBPByTech[iMinTechLevelForPower]
                else
                    iBPWanted = 4 * tiBPByTech[iMinTechLevelForPower]
                end
            else
                if (tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.03) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] >= 0.25 then
                    iBPWanted = tiBPByTech[iMinTechLevelForPower]
                else
                    iBPWanted = 2 * tiBPByTech[iMinTechLevelForPower]
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Start of game Want more power, iBPWanted='..iBPWanted..'; Nearby enemy air to ground threat='..iNearbyEnemyAirToGroundThreat..'; Enemy combat total='..(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)..'; Enemies in this or adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Mass%='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) end
            HaveActionToAssign(refActionBuildPower, iMinTechLevelForPower, iBPWanted)

        end
    end

    --Mass storage if we have none (e.g. for snadbox games where lose ACU)
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.9 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] < 50 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 0.1 and tLZTeamData[M28Map.subrefMexCountByTech][1] + tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 then
        --Build mass storage for this team - e.g. if in sandbox and lost ACU
        HaveActionToAssign(refActionBuildMassStorage, 1, 5)
    end


    --Being bombed or have large air force in our core base - need AA if dont have any fixed AA (see a bit later on for high priority AA builder when under air attack if already have 1 fixed AA)
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 or iNearbyEnemyAirToGroundThreat >= 500 or tLZTeamData[M28Map.refiEnemyAirAAThreat] >= 500 then
        --If overall enemy air threat is low and we are on a nont2 mex map then want to rly on MAA
        if not(M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam]) or M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround] >= 200 or tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] == 0 then
            --Do we already have fixed AA in this LZ?
            local iAACategory = M28UnitInfo.refCategoryStructureAA
            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then iAACategory = iAACategory * categories.TECH3 end
            local tExistingFixedAA = EntityCategoryFilterDown(iAACategory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            local bHaveFixedAA = false
            if M28Utilities.IsTableEmpty(tExistingFixedAA) == false then
                for iUnit, oUnit in tExistingFixedAA do
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have fixed AA, considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                    if oUnit:GetFractionComplete() then bHaveFixedAA = true break end
                end
            end
            if not(bHaveFixedAA) then
                iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
                if tLZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 or iNearbyEnemyAirToGroundThreat >= 500 then iBPWanted = iBPWanted * 2 end
                if not(bHaveLowPower) then
                    if not(bHaveLowMass) then iBPWanted = iBPWanted * 4
                    else iBPWanted = iBPWanted * 2
                    end
                end
                HaveActionToAssign(refActionBuildAA, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted)
                if bDebugMessages == true then LOG(sFunctionRef..': AA builder if no fixed AA: iBPWanted='..iBPWanted..'; iNearbyEnemyAirToGroundThreat='..iNearbyEnemyAirToGroundThreat..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; subrefiAlliedGroundAAThreat='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]) end
            end
        end
    end

    --Low mass and significant relcaim with no enemies - assign 1 engineer as very high priority (so we can fund other high priority actions)
    iCurPriority = iCurPriority + 1
    if (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.15 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.3 and M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam])) and tLZData[M28Map.subrefTotalSignificantMassReclaim] >= 1000 then
        if bDebugMessages == true then LOG(sFunctionRef..': High priority mass reclaim, Total mass in Plateau '..iPlateau..' LZ '..iLandZone..'='..tLZData[M28Map.subrefTotalMassReclaim]..'; Signif mass='..tLZData[M28Map.subrefTotalSignificantMassReclaim]) end
        iBPWanted = 5
        if not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) then
            iBPWanted = 10
            if not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                iBPWanted = math.max(15, tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]])
            end
            if tLZData[M28Map.subrefTotalSignificantMassReclaim] >= 3000 then
                iBPWanted = iBPWanted * 1.5
                if tLZData[M28Map.subrefTotalSignificantMassReclaim] >= 10000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.075 then
                    iBPWanted = iBPWanted * 1.5
                end
            end
        end

        --Have 1 engi search for high value wrecks
        HaveActionToAssign(refActionReclaimArea, 1, 5, { false, 50 })
        --Then have 1-2 engis search for reclaim generally
        iCurPriority = iCurPriority + 1
        HaveActionToAssign(refActionReclaimArea, 1, iBPWanted, {false, nil})


    else
        iCurPriority = iCurPriority + 1
    end

    --Have 1 engi start on an experimental if we have all T3 mexes and very high mass % stored
    iCurPriority = iCurPriority + 1
    if not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.7 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and tLZTeamData[M28Map.subrefMexCountByTech][3] >= tLZData[M28Map.subrefLZMexCount] and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then
        if bDebugMessages == true then LOG(sFunctionRef..': Very high priority exp builder so we can get the build location ready') end
        HaveActionToAssign(refActionBuildExperimental, 3, 5)
    end


    --Protect game-ender or similar high avlue target (very high priority on assumption if we have built such a unit we shouldnt have to worry about lack of resources for this
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) == false then
        --Double check the units still need special shield protection
        local bContinue = true
        for iUnit, oUnit in tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
            if oUnit[M28Building.reftArtiTemplateRefs] then
                table.remove(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection], iUnit)
                bContinue = false
                break
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Want to assign units to active shield protection, will list out each unit for this zone that wants active protection')
            for iUnit, oUnit in tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
                LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Mass cost='..oUnit:GetBlueprint().Economy.BuildCostMass)
            end
        end
        if bContinue then
            --Check not an easy AI
            if not(tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex].M28Easy) then

                if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] then
                    iBPWanted = math.max(100, M28Team.tTeamData[iTeam][M28Team.refiEnemyT3ArtiCount] * 300 + M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] * 75)
                else
                    iBPWanted = 100
                end


                if bDebugMessages == true then LOG(sFunctionRef..': Special shield defence action iBPWanted='..iBPWanted) end

                --Only use T3 engineers (even if we already have t3 engineers assigned) as want to make sure we can quickly get good concentrated build power
                --function HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist)
                HaveActionToAssign(refActionSpecialShieldDefence, 3, iBPWanted,         nil,                nil,                    nil,                        nil,                            true)
            end
        end
    end




    --Unclaimed mex in the zone
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then
        LOG(sFunctionRef..': Considering if unbuilt or part build mexes in t his LZ, is subrefMexUnbuiltLocations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]))..'; Is subreftoPartBuiltMexes empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]))..'; Mex by tech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; subrefLZMexCount='..tLZData[M28Map.subrefLZMexCount])
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) == false then
            LOG(sFunctionRef..': Size of unbuilt locations table='..table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]))

        end
    end
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) == false and not(M28Overseer.bNoRushActive and M28Conditions.NoRushPreventingHydroOrMex(tLZData, true)) then
        iBPWanted = math.max(5, table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) * 2.5)
        if bHaveLowPower and not(bHaveLowMass) and iBPWanted > 10 then
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= 0.25 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.5 then
                iBPWanted = 10
            elseif iBPWanted > 20 and iBPWanted >= tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2 then
                iBPWanted = 20
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': High priority mex builder, Have a total of '..table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations])..' unbuilt mex locations in this zone, iBPWanted='..iBPWanted..'; Highest friendly tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end
        HaveActionToAssign(refActionBuildMex, 1, iBPWanted)
        if (tLZTeamData[M28Map.subreftiBPWantedByAction][refActionBuildMex] or 0) > 0 then tLZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] = true end
    elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
        --Do we have no engineers assigned to building a mex?
        local bHaveEngisBuilding = false
        if bDebugMessages == true then LOG(sFunctionRef..': Have part built mexes, is toAssignedEngineers empty='..tostring(M28Utilities.IsTableEmpty(toAssignedEngineers))) end
        if M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
            for iEngi, oEngi in toAssignedEngineers do
                if oEngi[refiAssignedAction] == refActionBuildMex then
                    bHaveEngisBuilding = true
                    break
                end
            end
        end
        if not(bHaveEngisBuilding) then
            --Refresh list of mexes
            RefreshPartBuiltMexList(tLZTeamData)
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to assign 5 BP to complete a part built mex') end
                HaveActionToAssign(refActionCompletePartBuiltMex, 1, 5)
            end
        end
    end


    --Early game transport wanting engineer (takes priority over factory if we have at least 2 in this zone)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; Is table of transports waiting for engineers empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers]) == false then
        --Check the table is still valid
        local iEngisWantedForTransports = GetEngisWantedForTransports(tLZTeamData)
        if bDebugMessages == true then LOG(sFunctionRef..': iEngisWantedForTransports after refresh='..iEngisWantedForTransports) end
        if iEngisWantedForTransports > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': want engineers to load onto transport if early game, will first check if we have at least 2 factories in this zone and if the transport has a lifetime count of 1 and we only have 1 transport, size of transport table='..table.getn(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers])..'; Time='..GetGameTimeSeconds()) end
            if table.getn(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers]) == 1 and GetGameTimeSeconds() <= 900 then
                local bFirstTransport = true
                if (M28UnitInfo.GetUnitLifetimeCount(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers][1] or 1)) > 1 then bFirstTransport = false end
                if bDebugMessages == true then LOG(sFunctionRef..': bFirstTransport='..tostring(bFirstTransport)) end
                if bFirstTransport then
                    if not(tFactoriesInLZ) or iFactoriesInLZ == 0 then
                        iFactoriesInLZ = 0
                        tFactoriesInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    end
                    if M28Utilities.IsTableEmpty(tFactoriesInLZ) == false then
                        for iFactory, oFactory in tFactoriesInLZ do
                            if oFactory:GetFractionComplete() == 1 then
                                iFactoriesInLZ = iFactoriesInLZ + 1
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iFactoriesInLZ='..iFactoriesInLZ) end
                    if iFactoriesInLZ >= 2 then
                        --iActionToAssign,      iMinTechLevelWanted, i  BuildPowerWanted,                                                                       vOptionalVariable,  bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting
                        --BP wanted - engineers already attached shouldn't be treated as available, however want BP wanted to be total not additional to avoid multiple unattached engineers being given the same order
                        if bDebugMessages == true then LOG(sFunctionRef..': Will seek engineers for transport') end
                        HaveActionToAssign(refActionLoadOntoTransport, 1, iEngisWantedForTransports * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]], nil, false,false) --Max 5 BP to make sure we only try loading 1 engi at a time
                    end
                end
            end
        end
    end

    --Adjacent zones wanting mexes that dont already have 1 engineer traveling for every 2 unbuilt mexes
    iCurPriority = iCurPriority + 1
    --(ANY CHANGES TO BELOW - CONSIDER REPLICATING FOR BOTH CORE AND NONCORE BUILDERS) Adjacent LZ that wants engineers (only chekc if we have available engineers)
    --(as of v24 decided to go with differences for the minior LZ (which uses a simplified appraoch) vs core base highest priority for adj LZs
    local tiAdjacentLandZonesWantingEngineersThatAlreadyHaveSome = {}
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have available engineers to send to another LZ. GetHighestTechEngiAvailable='..GetHighestTechEngiAvailable(toAvailableEngineersByTech)) end
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    local iNearbyZonesWantingEngineers = 0
    local iPrevEngisAvailable
    local tLZWantingBPConsidered = {}
    local iAdjLZ
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
        local iEngineersTravelingHere
        local iEngineersPresentHere
        local iMaxEngineersWanted
        for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
            if tPathingDetails[M28Map.subrefLZTravelDist] <= tLZData[M28Map.subrefLZFurthestAdjacentLandZoneTravelDist] then
                iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                if tAdjLZTeamData[M28Map.subrefTbWantBP] and not(tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] or (tAdjLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) > 0) then
                    iEngineersTravelingHere = 0
                    iEngineersPresentHere = 0
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
                        iEngineersTravelingHere = table.getn(tAdjLZTeamData[M28Map.subrefTEngineersTravelingHere])
                    end
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                        local tEngineersInAdjZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tAdjLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                        if M28Utilities.IsTableEmpty(tEngineersInAdjZone) == false then
                            iEngineersPresentHere = table.getn(tEngineersInAdjZone)
                        end
                    end
                    iMaxEngineersWanted = 1
                    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then iMaxEngineersWanted = 2 end
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefMexUnbuiltLocations]) == false then
                        iMaxEngineersWanted = math.max(iMaxEngineersWanted, math.ceil(table.gent(tAdjLZTeamData[M28Map.subrefMexUnbuiltLocations]) * 0.5))
                    end
                    if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefHydroUnbuiltLocations]) == false then
                        iMaxEngineersWanted = iMaxEngineersWanted + 1
                    end
                    if iEngineersTravelingHere + iEngineersPresentHere >= iMaxEngineersWanted then
                        tiAdjacentLandZonesWantingEngineersThatAlreadyHaveSome[iPathingRef] = iAdjLZ
                    else
                        tLZWantingBPConsidered[iAdjLZ] = true
                        local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, iAdjLZ, iPathingRef, iHighestTechEngiAvailable, true, false, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                        if tiBPByTechWanted then
                            for iTech = 1, iHighestTechEngiAvailable, 1 do
                                if tiBPByTechWanted[iTech] > 0 then
                                    iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                    iBPWanted = iNearbyZonesWantingEngineers * 5 + tiBPByTechWanted[iTech]
                                    HaveActionToAssign(refActionMoveToLandZone, iTech, iBPWanted, iAdjLZ, true)
                                    if (tLZTeamData[M28Map.subreftiBPWantedByAction][refActionMoveToLandZone] or 0) > 0 then tLZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] = true end
                                    if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                        iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                    end

                                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want iBPWanted='..iBPWanted..' to go to iAdjLZ='..iAdjLZ..'; iNearbyZonesWantingEngineers='..iNearbyZonesWantingEngineers..'; iHighestTechEngiAvailable='..iHighestTechEngiAvailable) end
                                    if iHighestTechEngiAvailable == 0 then break end
                                end
                            end
                        end
                        if iHighestTechEngiAvailable == 0 then break end
                    end
                end
            else
                break --Table shoudl be sorted closest first so if we are too far away now the later entries should be ignored
            end
        end
    end

    iCurPriority = iCurPriority + 1
    --If have adjacent waterzone that has unbuilt mexes and has no engineers (incl traveling engineers) then also send engineer here
    if bDebugMessages == true then LOG(sFunctionRef..': High priority Considering if we have adjacent WZ that wants engineer for unbuilt mexes or core WZ, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
        local iCurWZ, iCurPond
        local iBPAlreadyAssigned = 0
        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
            iCurWZ = tSubtable[M28Map.subrefAWZRef]
            iCurPond = M28Map.tiPondByWaterZone[iCurWZ]
            local tWZData = M28Map.tPondDetails[iCurPond][M28Map.subrefPondWaterZones][iCurWZ]
            if bDebugMessages == true then LOG(sFunctionRef..': iCurWZ='..iCurWZ..'; Is table of unbuilt mexes empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]))) end
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]) == false then
                local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]

                local iEngineersTravelingHere
                local iEngineersPresentHere
                local iMaxEngineersWanted
                if bDebugMessages == true then LOG(sFunctionRef..': does zone want bp='..tostring(tWZTeamData[M28Map.subrefTbWantBP])..'; subrefbEnemiesInThisOrAdjacentWZ='..tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])..'; enemy air to ground='..(tWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0)) end
                if tWZTeamData[M28Map.subrefTbWantBP] and not(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] or (tWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) > 0) then
                    iEngineersTravelingHere = 0
                    iEngineersPresentHere = 0
                    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
                        iEngineersTravelingHere = table.getn(tWZTeamData[M28Map.subrefTEngineersTravelingHere])
                    end
                    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                        local tEngineersInAdjZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                        if M28Utilities.IsTableEmpty(tEngineersInAdjZone) == false then
                            iEngineersPresentHere = table.getn(tEngineersInAdjZone)
                        end
                    end
                    iMaxEngineersWanted = 1
                    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefMexUnbuiltLocations]) == false then
                        iMaxEngineersWanted = math.max(iMaxEngineersWanted, math.ceil(table.gent(tWZTeamData[M28Map.subrefMexUnbuiltLocations]) * 0.5))
                    end
                    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefHydroUnbuiltLocations]) == false then
                        iMaxEngineersWanted = iMaxEngineersWanted + 1
                    end
                    iBPWanted = iMaxEngineersWanted * 5
                    HaveActionToAssign(refActionMoveToWaterZone, 1, iBPWanted + iBPAlreadyAssigned, iCurWZ, true)
                    iBPAlreadyAssigned = iBPAlreadyAssigned + iBPWanted
                    if (tLZTeamData[M28Map.subreftiBPWantedByAction][refActionMoveToWaterZone] or 0) > 0 then tLZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] = true end
                    if bDebugMessages == true then LOG(sFunctionRef..': Tried to send engineers to iCurWZ '..iCurWZ..'; iBPWanted='..iBPWanted..'; iBPAlreadyAssigned='..iBPAlreadyAssigned) end
                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                    if iHighestTechEngiAvailable == 0 or iBPAlreadyAssigned >= iBPWanted * 3 then break end
                end
            end
        end
    end

    --Very High priority factory if we have fewer than 4 (or if lwoer thre number of mexes in the LZ or small map and signif mass stored) and is a smaller map - takes priority over mex expansion; also build more than 4 if dont have low mass and outtech enemy; also if enemy only at T1 and small map then keep building
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want v.high priority factory builder, mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; bWantMoreFactories='..tostring(bWantMoreFactories)..'; Team gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; GameTime='..GetGameTimeSeconds()) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 11 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 100 and bWantMoreFactories and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1 and (GetGameTimeSeconds() >= 200 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1.5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or M28Map.iMapSize <= 256) then

        if iFactoriesInLZ == 0 or not(tFactoriesInLZ) then
            tFactoriesInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tFactoriesInLZ) == false then iFactoriesInLZ = table.getn(tFactoriesInLZ) end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iFactoriesInLZ='..iFactoriesInLZ..'; LZ mex count='..tLZData[M28Map.subrefLZMexCount]..'; M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]='..M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) end
        local iFactoryAdjust = 0
        if M28Map.iMapSize <= 256 then
            iFactoryAdjust = math.min(3,M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] / 100)
        end
        if not(bHaveLowMass) and not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] <= 2 and M28Map.iMapSize <= 1024 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] > math.max(M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech], M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech], M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech]) then
            --We outtech enemy and have decent mass and power, so want more factories to make use of our advantage, if enemy base is relatively near
            if M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZTeamData[M28Map.reftClosestFriendlyBase]) <= 550 and NavUtils.GetTerrainLabel(tLZTeamData[M28Map.reftClosestEnemyBase]) == NavUtils.GetTerrainLabel(tLZTeamData[M28Map.reftClosestFriendlyBase]) then
                iFactoryAdjust = iFactoryAdjust + 2
            end
        end

        if iFactoryAdjust <= 3 and not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] <= 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] <= 1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 300 and M28Map.iMapSize < 1024 and (M28Map.iMapSize <= 256 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 800) and not(bHaveLowPower) and ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Map.refbCanPathToEnemyBaseWithLand] then
            iFactoryAdjust = 4
        end

        --Increase factories wanted if have lots of mexes upgrading
        if not(bHaveLowMass) and not(bHaveLowPower) and (tLZTeamData[M28Map.subrefiActiveMexUpgrades] or 0) >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 8 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
            iFactoryAdjust = iFactoryAdjust + 1
        end

        if iFactoriesInLZ < iFactoryAdjust + math.max(2 , math.min(4, tLZData[M28Map.subrefLZMexCount] + 1, 10 * M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) then
            iBPWanted = 5
            if not(bHaveLowMass) then iBPWanted = iBPWanted * 2.5 end
            if not(bHaveLowPower) then iBPWanted = iBPWanted * 2.5 end
            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 and GetGameTimeSeconds() <= 400 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] < 4 then
                iBPWanted = math.min(15, iBPWanted)
                if bHaveLowMass or bHaveLowPower or GetGameTimeSeconds() <= 300 then iBPWanted = math.min(10, iBPWanted) end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build factory, iBPWanted='..iBPWanted) end
            local bWantAirNotLand
            if iFactoriesInLZ == 0 then bWantAirNotLand = false
            else bWantAirNotLand = M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)
            end
            local iFactoryAction
            if bWantAirNotLand then iFactoryAction = refActionBuildAirFactory
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Want to build land factory not air factory1') end
                iFactoryAction = refActionBuildLandFactory
            end
            if bHaveLowPower and bWantAirNotLand then iBPWanted = iBPWanted * 0.5 end

            --Change factory action if we already have a particular type under construction
            local tFactoriesInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryAirFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tFactoriesInZone) == false then
                for iUnit, oUnit in tFactoriesInZone do
                    if oUnit:GetFractionComplete() < 1 then
                        if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oUnit.UnitId) then iFactoryAction = refActionBuildAirFactory
                        elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) then iFactoryAction = refActionBuildLandFactory
                        end
                    end
                end
            end
            if M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier] >= 2.0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 750 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and ArmyBrains[M28Map.reftiClosestFriendlyM28BrainIndex][M28Economy.refiOurHighestFactoryTechLevel] >= 3 then
                --Get quantum gateway instead if we dont already have one
                local tCompletedGateway = EntityCategoryFilterDown(M28UnitInfo.refCategoryQuantumGateway, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                local iCompletedGateway = 0
                if M28Utilities.IsTableEmpty(tCompletedGateway) == false then
                    for iGateway, oGateway in tCompletedGateway do
                        if oGateway:GetFractionComplete() == 1 then iCompletedGateway = iCompletedGateway + 1 end
                    end
                end
                if iCompletedGateway < 2 and (iCompletedGateway == 0 or (not(bHaveLowMass) and not(bHaveLowPower))) then
                    HaveActionToAssign(refActionBuildQuantumGateway, 3, iBPWanted)
                else
                    HaveActionToAssign(iFactoryAction, 1, iBPWanted)
                end
            else
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.4 and (M28Team.tTeamData[iTeam][M28Team.refiHighestBrainBuildMultiplier] >= 1.5 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.6) then
                    iBPWanted = iBPWanted * 0.5
                    HaveActionToAssign(iFactoryAction, 1, iBPWanted)
                    local iSecondAction = refActionBuildSecondLandFactory
                    if iFactoryAction == refActionBuildAirFactory then iSecondAction = refActionBuildSecondAirFactory end
                    HaveActionToAssign(iSecondAction, 1, iBPWanted)
                else
                    HaveActionToAssign(iFactoryAction, 1, iBPWanted)
                end
            end

        end
    end

    --At least 1 T3 engineers assigned to gameender template if one is active; also assign an extra engineer if we require an engineer of a particular faction and have that engineer available
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering very high priority for active gameender template engineers, do we have active gameender template='..tostring(M28Conditions.HaveActiveGameEnderTemplateLogic(tLZTeamData))) end
    if M28Conditions.HaveActiveGameEnderTemplateLogic(tLZTeamData) then
        HaveActionToAssign(refActionManageGameEnderTemplate, 3, 30)
        if bDebugMessages == true then LOG(sFunctionRef..': Hihest priority We have an active gameender template so will assign engis to this, do we want UEF engis='..tostring(tLZTeamData[M28Map.subreftbBPByFactionWanted][M28UnitInfo.refFactionUEF] or false)..'; do we want sera engineers='..tostring(tLZTeamData[M28Map.subreftbBPByFactionWanted][M28UnitInfo.refFactionSeraphim] or false)) end
        if tLZTeamData[M28Map.subreftbBPByFactionWanted][M28UnitInfo.refFactionUEF] or tLZTeamData[M28Map.subreftbBPByFactionWanted][M28UnitInfo.refFactionSeraphim] then
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of available T3 engineers empty='..tostring(M28Utilities.IsTableEmpty(toAvailableEngineersByTech[3]))) end
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[3]) == false then
                local tUEFAndSeraphimEngineers = EntityCategoryFilterDown(categories.UEF + categories.SERAPHIM, toAvailableEngineersByTech[3])
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of UEF and sera engineers empty='..tostring(M28Utilities.IsTableEmpty(tUEFAndSeraphimEngineers))) end
                if M28Utilities.IsTableEmpty(tUEFAndSeraphimEngineers) == false then
                    --We have UEF/Sera T3 engineers, and this zone is flagged as wanting engineers of that faction, so assign an additional engineer

                    local iFactionWanted
                    if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.SERAPHIM, tUEFAndSeraphimEngineers)) == false then iFactionWanted = M28UnitInfo.refFactionSeraphim else iFactionWanted = M28UnitInfo.refFactionUEF end
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to assign faction specific engineer as a very high prioriyt for zone '..iLandZone..'; iFactionWanted='..(iFactionWanted or 'nil')) end
                    HaveActionToAssign(refActionManageGameEnderTemplate, 3, 30, nil, false, true, iFactionWanted)
                end
            end
        end
    end


    --Need SMD as enemy has nuke launcher
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; About to consider if want SMD, is table of enemy nukes empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false then
        local bAssistSMD = false
        local oSMDToShield, oUnderConstructionShield
        iBPWanted, bAssistSMD, oSMDToShield, oUnderConstructionShield = GetBPToAssignToSMD(iPlateau, iLandZone, iTeam, tLZTeamData, true, bHaveLowMass, bWantMorePower)
        if bDebugMessages == true then LOG(sFunctionRef..': iBPWanted for SMD='..(iBPWanted or 'nil')..'; bAssistSMD='..tostring(bAssistSMD or false)..'; oSMDToShield='..(oSMDToShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oSMDToShield) or 'nil')) end
        if iBPWanted > 0 then
            if oUnderConstructionShield then
                if bDebugMessages == true then LOG(sFunctionRef..': Have under construction shield we want to complete to cover SMD') end
                HaveActionToAssign(refActionRepairUnit, 1, iBPWanted, oUnderConstructionShield)
            elseif oSMDToShield then
                iCurPriority = iCurPriority + 1
                if bDebugMessages == true then LOG(sFunctionRef..': Need to shield the SMD first') end
                local iTechLevelWanted = 2
                if (oSMDToShield[refiFailedShieldConstructionCount] or 0) > 0 or (tLZTeamData[M28Map.refiFixedShieldT2EngiFailureCount] or 0) >= 5 then iTechLevelWanted = 3 end
                HaveActionToAssign(refActionBuildShield, iTechLevelWanted, iBPWanted, oSMDToShield)

            elseif bAssistSMD then
                iCurPriority = iCurPriority + 2
                if bDebugMessages == true then LOG(sFunctionRef..': Will assist existing SMD') end
                HaveActionToAssign(refActionAssistSMD, 1, iBPWanted)
            else
                iCurPriority = iCurPriority + 3
                if bDebugMessages == true then LOG(sFunctionRef..': Want to build SMD, iCurPrioriyt='..iCurPriority) end
                HaveActionToAssign(refActionBuildSMD, 3, iBPWanted)
            end
        else
            iCurPriority = iCurPriority + 3
        end
    else
        iCurPriority = iCurPriority + 3
    end

    --Transports waiting for engineers
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; Is table of transports waiting for engineers empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoTransportsWaitingForEngineers]) == false then
        --Check the table is still valid
        local iEngisWantedForTransports = GetEngisWantedForTransports(tLZTeamData)
        if bDebugMessages == true then LOG(sFunctionRef..': iEngisWantedForTransports after refresh='..iEngisWantedForTransports) end
        if iEngisWantedForTransports > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': want engineers to load onto transport') end
            --iActionToAssign,      iMinTechLevelWanted, i  BuildPowerWanted,                                                                       vOptionalVariable,  bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting
            --BP wanted - engineers already attached shouldn't be treated as available, however want BP wanted to be total not additional to avoid multiple unattached engineers being given the same order
            HaveActionToAssign(refActionLoadOntoTransport, 1, iEngisWantedForTransports * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]], nil, false,false) --Max 5 BP to make sure we only try loading 1 engi at a time
        end
    end

    --Zones wanting specific faction engineers (e.g. for shielding game ender)
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftFactoriesWantedForEngineers]) == false then
        local iZoneWantingEngineersOfFaction, iFactionWanted = GetZoneAndFactionForPriorityEngineerTravel(tLZTeamData, iTeam, iLandZone, iPlateau)
        if iZoneWantingEngineersOfFaction and iFactionWanted then
            HaveActionToAssign(refActionMoveToLandZone, 3, 90, iZoneWantingEngineersOfFaction, true, false, iFactionWanted)
        end
    end

    --Energy storage if we have none and at least 1 T2+ mex
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; Considering building energy storage, Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; Have low power='..tostring(bHaveLowPower)..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount]='..M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount]..'; Enemy unit with highest health='..M28Team.tTeamData[iTeam][M28Team.refiEnemyHighestMobileLandHealth]) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] <= 0 and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 1 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 75) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 35 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2.5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
        --Is the number of storage in this LZ <= lowest storage count?
        local toStorageInThisLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryEnergyStorage, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local iStorageInThisLZ = 0
        if M28Utilities.IsTableEmpty(toStorageInThisLZ) == false then
            for iUnit, oUnit in toStorageInThisLZ do
                if oUnit:GetFractionComplete() == 1 then iStorageInThisLZ = iStorageInThisLZ + 1 end
            end
        else
            iStorageInThisLZ = 0
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iStorageInThisLZ='..iStorageInThisLZ) end
        if iStorageInThisLZ <= M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then --are ok with gifting storage to a teammate
            if not(bSaveMassForMML) or (iStorageInThisLZ == 0 and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] >= tLZData[M28Map.subrefLZMexCount]) then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to get storage, Is tEngineers[1] valid='..tostring(M28UnitInfo.IsUnitValid(tEngineers[1]))) end
                iBPWanted = 5
                if not(bHaveLowMass) and not(bHaveLowPower) then iBPWanted = 20 end
                HaveActionToAssign(refActionBuildEnergyStorage, 1, iBPWanted)
            end
        end
    end

    --Units needing air staging
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': About to check if we need air staging for core zone, Time='..GetGameTimeSeconds()..'; Time of last shortage='..(M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastAirStagingShortage] or 'nil')) end
    if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastAirStagingShortage] or 0) <= 1.1 then
        --Limit of 3 air staging in a LZ
        local tExistingAirStaging = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirStaging, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local iExistingAirStaging = 0
        local oExistingM28Brain
        local iAirStagingInThisZoneUnderConstruction = 0
        if M28Utilities.IsTableEmpty(tExistingAirStaging) == false then
            for iStaging, oStaging in tExistingAirStaging do
                if oStaging:GetAIBrain().M28AI then
                    if oStaging:GetFractionComplete() == 1 then
                        oExistingM28Brain = oStaging:GetAIBrain()
                        iExistingAirStaging = iExistingAirStaging + 1
                    else
                        iAirStagingInThisZoneUnderConstruction = iAirStagingInThisZoneUnderConstruction + 1
                    end
                end
            end
        end
        local iUnderConstructionInOtherZonesWithLowResources = 0
        if bDebugMessages == true then LOG(sFunctionRef..': iAirStagingInThisZoneUnderConstruction='..iAirStagingInThisZoneUnderConstruction..'; Active brain count='.. M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]..'; bHaveLowMass='..tostring(bHaveLowMass)..'; bHaveLowPower='..tostring(bHaveLowPower)..'; Highest air fac tech='.. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]) end
        if iAirStagingInThisZoneUnderConstruction == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] > 1 and (bHaveLowMass or bHaveLowPower or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] < 3) then
            --How many under construction air staging do we have
            iUnderConstructionInOtherZonesWithLowResources = M28Conditions.GetNumberOfUnderConstructionUnitsOfCategoryInOtherZones(tLZTeamData, iTeam, M28UnitInfo.refCategoryAirStaging)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iExistingAirStaging='..iExistingAirStaging..'; bHaveLowMass='..tostring(bHaveLowMass)..'; iAirStagingInThisZoneUnderConstruction='..iAirStagingInThisZoneUnderConstruction..'; iUnderConstructionInOtherZonesWithLowResources='..iUnderConstructionInOtherZonesWithLowResources) end
        if iUnderConstructionInOtherZonesWithLowResources == 0 and (iExistingAirStaging <= 1 or (iExistingAirStaging < 3 and not(bHaveLowMass)) or (iExistingAirStaging < 8 and oExistingM28Brain and oExistingM28Brain:GetCurrentUnits(M28UnitInfo.refCategoryAllNonExpAir) >= 50 * iExistingAirStaging)) then

            iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
            if not(bHaveLowMass) then iBPWanted = iBPWanted * 2 end
            HaveActionToAssign(refActionBuildAirStaging, 1, iBPWanted, nil, false)
            if bDebugMessages == true then LOG(sFunctionRef..': Have flagged we want air staging with iBPWanted='..iBPWanted) end
        end
    end


    --1st experimental - Enemy has land experimental and we dont have one of our own yet (and havent completed one before), unless enemy has a fatboy (in which case we want to focus more on getting t2 arti)
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] <= 1 and (M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] == 0 or (M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiOurBomberThreat] < 12000 and not(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) and M28Conditions.GetCurrentM28UnitsOfCategoryInTeam(M28UnitInfo.refCategoryLandExperimental, iTeam) == 0)) and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.ALLUNITS - M28UnitInfo.refCategoryFatboy, M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals])) == false then
        local iEnemyHighestPercentComplete = 0
        local iClosestExperimental = 100000
        for iExperimental, oExperimental in M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals] do
            if M28UnitInfo.IsUnitValid(oExperimental) and EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryAllAir, oExperimental.UnitId) then
                iEnemyHighestPercentComplete = math.max(iEnemyHighestPercentComplete, oExperimental:GetFractionComplete())
                iClosestExperimental = math.min(iClosestExperimental, M28Utilities.GetDistanceBetweenPositions(oExperimental:GetPosition(), tLZData[M28Map.subrefMidpoint]))
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iEnemyHighestPercentComplete='..iEnemyHighestPercentComplete..'; iClosestExperimental='..iClosestExperimental..'; Can path with land='..tostring(ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Map.refbCanPathToEnemyBaseWithLand])..'; Can path with amphibious='..tostring(ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Map.refbCanPathToEnemyBaseWithAmphibious])) end
        if iEnemyHighestPercentComplete > 0 and iClosestExperimental <= 750 and (ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Map.refbCanPathToEnemyBaseWithLand] or (iClosestExperimental <= 650 and ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Map.refbCanPathToEnemyBaseWithAmphibious])) then
            --[[local iAliveExperimentals = 0
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                local tFriendlyExperimentals = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandExperimental, false, false)
                if M28Utilities.IsTableEmpty(tFriendlyExperimentals) == false then
                    for iExperimental, oExperimental in tFriendlyExperimentals do
                        if oExperimental:GetFractionComplete() >= 0.95 then
                            iAliveExperimentals = iAliveExperimentals + 1
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iAliveExperimentals='..iAliveExperimentals) end
            if iAliveExperimentals == 0 then--]]

            local iHighestCompleteExperimentalInZone = 0
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                local tExperimentalsUnderConstruction = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if M28Utilities.IsTableEmpty(tExperimentalsUnderConstruction) == false then
                    for iUnit, oUnit in tExperimentalsUnderConstruction do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            iHighestCompleteExperimentalInZone = math.max(iHighestCompleteExperimentalInZone, oUnit:GetFractionComplete())
                        end
                    end
                end

            end
            if bDebugMessages == true then LOG(sFunctionRef..': iHighestCompleteExperimentalInZone='..iHighestCompleteExperimentalInZone) end
            iBPWanted = 240
            if iHighestCompleteExperimentalInZone > 0 and (iHighestCompleteExperimentalInZone + 0.2 >= iEnemyHighestPercentComplete or iHighestCompleteExperimentalInZone >= 0.6) then
                --Assist the experimental
                HaveActionToAssign(refActionBuildExperimental, 1, iBPWanted)
            else
                --Assist air factory if we have air control or enemy experimental is already complete (since unlikely to have time to build our own to counter it)
                if (iEnemyHighestPercentComplete == 1 and iClosestExperimental <= 650) or M28Conditions.TeamHasAirControl(iTeam) then

                    if bHaveLowPower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= 0.6 then iBPWanted = 120
                    elseif not(bHaveLowPower) and (not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                        iBPWanted = 400
                    end
                    local tAirFacsToAssist = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory * M28UnitInfo.ConvertTechLevelToCategory(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]), tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    local oAirFactoryToAssist
                    if M28Utilities.IsTableEmpty(   tAirFacsToAssist) then
                        tAirFacsToAssist = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of air facs to assist empty='..tostring(M28Utilities.IsTableEmpty(tAirFacsToAssist))..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iBPWanted='..iBPWanted) end
                    if M28Utilities.IsTableEmpty(tAirFacsToAssist) == false then

                        local iHighestAirFac = 0
                        local iCurTechLevel
                        for iFactory, oFactory in tAirFacsToAssist do
                            iCurTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
                            if iCurTechLevel > iHighestAirFac then
                                iHighestAirFac = iCurTechLevel
                                oAirFactoryToAssist = oFactory
                            end
                        end
                        if oAirFactoryToAssist then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will assist air factory '..oAirFactoryToAssist.UnitId..M28UnitInfo.GetUnitLifetimeCount(oAirFactoryToAssist)) end
                            HaveActionToAssign(refActionAssistAirFactory, 1, iBPWanted, oAirFactoryToAssist)
                        end
                    end
                else
                    local iTechLevelWanted = 3
                    if iHighestCompleteExperimentalInZone > 0 and iHighestCompleteExperimentalInZone < 1 then iTechLevelWanted = 1 end
                    HaveActionToAssign(refActionBuildExperimental, iTechLevelWanted, iBPWanted)

                end
            end
            --end
        end
    end


    --Quantum gateway in a high AiX scenario
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier] >= 2.0 and tLZTeamData[M28Map.subrefMexCountByTech][3] >= math.min(10, tLZData[M28Map.subrefLZMexCount]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 750 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and ArmyBrains[M28Map.reftiClosestFriendlyM28BrainIndex][M28Economy.refiOurHighestFactoryTechLevel] >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 900 then
        --Get quantum gateway if we dont already have one
        local tCompletedGateway = EntityCategoryFilterDown(M28UnitInfo.refCategoryQuantumGateway, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local iCompletedGateway = 0
        if M28Utilities.IsTableEmpty(tCompletedGateway) == false then
            for iGateway, oGateway in tCompletedGateway do
                if oGateway:GetFractionComplete() == 1 then iCompletedGateway = iCompletedGateway + 1 end
            end
        end
        iBPWanted = 30
        if not(bHaveLowMass) and not(bHaveLowPower) then iBPWanted = 60 end
        if iCompletedGateway < 2 and (iCompletedGateway == 0 or (not(bHaveLowMass) and not(bHaveLowPower))) then
            HaveActionToAssign(refActionBuildQuantumGateway, 3, iBPWanted)
        end
    end

    --At least 5 T3 engineers assigned to gameender template if one is active
    iCurPriority = iCurPriority + 1
    if M28Conditions.HaveActiveGameEnderTemplateLogic(tLZTeamData) then
        HaveActionToAssign(refActionManageGameEnderTemplate, 3, 150)
        if bDebugMessages == true then LOG(sFunctionRef..': We have an active gameender template so will assign engis to this') end
    end

    --first every experimental to build - rush if have t3 mex
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': First experimental - consider rushing if have t3 mex, M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount]='..M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Active brain count='..M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]..'; T3 mexes='..tLZTeamData[M28Map.subrefMexCountByTech][3]) end
    if M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 14 + 5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 250 + 75 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 then
        local bHaveExperimentalForThisLandZone, iOtherLandZonesWithExperimental, iMassToComplete = GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateau, iLandZone, true, nil, M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryAirToGround * categories.EXPERIMENTAL)
        if bHaveExperimentalForThisLandZone or (iOtherLandZonesWithExperimental == 0 and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryExperimentalLevel) < 3) then
            iBPWanted = 150
            if not(bHaveLowPower) then iBPWanted = 200
                if not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) then iBPWanted = 400 end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and rush our first experimental, iBPWanted='..iBPWanted) end
            HaveActionToAssign(refActionBuildExperimental, 3, iBPWanted)
        end
    end


    --Shielding in a high mass scenario
    iCurPriority = iCurPriority + 1
    if (M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] or (not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 25 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 250 + 250 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
        local iBPWanted, iTechLevelWanted, oUnitToShield = GetBPMinTechAndUnitForFixedShields(tLZData, tLZTeamData, iTeam, true, bHaveLowMass, bWantMorePower, false, iLandZone, iPlateau)
        if iBPWanted > 0 then
            iBPWanted = math.min(iBPWanted, 40)

            HaveActionToAssign(refActionBuildShield, iTechLevelWanted, iBPWanted, oUnitToShield)
            if bDebugMessages == true then LOG(sFunctionRef..': High priority shield builder, iBPWanted='..iBPWanted) end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Dont want to assign any BP to high priority shield builder') end
        end
    end

    --T1 spam game - get more land facs if have mass
    iCurPriority = iCurPriority + 1
    if not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam] and bWantMoreFactories and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > 0 then
        local iFactoryAction = refActionBuildLandFactory
        if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) then iFactoryActino = refActionBuildAirFactory end
        HaveActionToAssign(iFactoryAction, 1, 15)
    end


    --Start of game - if low power and dont ahve 12 gross energy yet, then ahve 1 engi on tree reclaim duty
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Early game tree reclaim: bHaveLowPower='..tostring(bHaveLowPower)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Want to relcaim energy nt mass='..tostring(M28Conditions.WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone))) end
    if bHaveLowPower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 12 and M28Conditions.WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone) then
        HaveActionToAssign(refActionReclaimArea, 1, 5, {true, nil})
    end

    --Send engineers to adjacent zones wnating engineers hwich already have some engineers in them
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tiAdjacentLandZonesWantingEngineersThatAlreadyHaveSome) == false and iHighestTechEngiAvailable > 0 then
        for iPathingRef, iAdjLZ in tiAdjacentLandZonesWantingEngineersThatAlreadyHaveSome do
            tLZWantingBPConsidered[iAdjLZ] = true
            local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, iAdjLZ, iPathingRef, iHighestTechEngiAvailable, true, false, true)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering for adjacent zone of lower priority iAdjLZ='..iAdjLZ..'; tiBPByTechWanted='..repru(tiBPByTechWanted)) end
            if tiBPByTechWanted then
                for iTech = 1, iHighestTechEngiAvailable, 1 do
                    if tiBPByTechWanted[iTech] > 0 then
                        iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                        iBPWanted = iNearbyZonesWantingEngineers * 5 + tiBPByTechWanted[iTech]
                        HaveActionToAssign(refActionMoveToLandZone, iTech, iBPWanted, iAdjLZ, true)
                        if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                            iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                        end

                        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                        if bDebugMessages == true then LOG(sFunctionRef..': Want iBPWanted='..iBPWanted..' to go to lower priority adjacent iAdjLZ='..iAdjLZ..'; iNearbyZonesWantingEngineers='..iNearbyZonesWantingEngineers..'; iHighestTechEngiAvailable='..iHighestTechEngiAvailable) end
                        if iHighestTechEngiAvailable == 0 then break end
                    end
                end
            end
            if iHighestTechEngiAvailable == 0 then break end
        end
    end


    iCurPriority = iCurPriority + 1
    local iCoreWZWantingSupportAsLowerPriority
    --If have adjacent waterzone that has unbuilt mexes or is a core WZ, wants engineers and has no combat threat then assign engi
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have adjacent WZ that wants engineer for unbuilt mexes or core WZ, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
    if iHighestTechEngiAvailable > 0 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
        local iCurWZ, iCurPond
        local iBPAlreadyAssigned = 0
        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
            iCurWZ = tSubtable[M28Map.subrefAWZRef]
            iCurPond = M28Map.tiPondByWaterZone[iCurWZ]
            local tWZData = M28Map.tPondDetails[iCurPond][M28Map.subrefPondWaterZones][iCurWZ]
            local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
            --Use similar logic to minor land zone to avoid unintended consequences
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iCurWZ='..iCurWZ..'; Core base='..tostring(tWZTeamData[M28Map.subrefWZbCoreBase] or false)..'; tWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation]='..tostring(tWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation])..'; Does it have an empty table of unbuilt mex locations='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]))) end
            local bConsiderWaterZone = false
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]) == false then
                bConsiderWaterZone = true
            elseif tWZTeamData[M28Map.subrefWZbCoreBase] and tWZTeamData[M28Map.subrefTbWantBP] then
                --Do we already have a completed naval factory here and at least 1 engineer? if so not as high priority
                bConsiderWaterZone = true
                if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                    local tFactoriesAndEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tFactoriesAndEngineers) == false then
                        local iEngiCount = 0
                        local iCompletedFactoryCount = 0
                        for iUnit, oUnit in tFactoriesAndEngineers do
                            if oUnit:GetFractionComplete() == 1 then
                                if EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oUnit.UnitId) then
                                    iCompletedFactoryCount = iCompletedFactoryCount + 1
                                else
                                    iEngiCount = iEngiCount + 1
                                end
                            end
                        end
                        if iCompletedFactoryCount > 0 and iCompletedFactoryCount + iEngiCount >= 3 then
                            bConsiderWaterZone = false
                        end
                    end
                end
                if not(bConsiderWaterZone) then iCoreWZWantingSupportAsLowerPriority = iCurWZ end
            end
            if bConsiderWaterZone then

                if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to send engineers to an adjaent water zone, iCurWZ='..iCurWZ..'; tWZTeamData[M28Map.subrefTbWantBP]='..tostring(tWZTeamData[M28Map.subrefTbWantBP] or false)) end
                if tWZTeamData[M28Map.subrefTbWantBP] and tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 10 then
                    iBPWanted = 5
                    if tWZTeamData[M28Map.subrefTbWantBP] then
                        iBPWanted = math.min(40, math.max(tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]], tWZTeamData[M28Map.subrefTBuildPowerByTechWanted][1]))
                    end

                    HaveActionToAssign(refActionMoveToWaterZone, 1, iBPWanted + iBPAlreadyAssigned, iCurWZ, true)
                    iBPAlreadyAssigned = iBPAlreadyAssigned + iBPWanted
                    if bDebugMessages == true then LOG(sFunctionRef..': Tried to send engineers to iCurWZ '..iCurWZ..'; iBPWanted='..iBPWanted..'; iBPAlreadyAssigned='..iBPAlreadyAssigned) end
                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                    if iHighestTechEngiAvailable == 0 or iBPAlreadyAssigned >= tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 3 then break end
                end
            end

        end
    end

    --High priority reclaim if are low on mass or energy
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we will want to reclaim mass in LZ, bHaveLowMass='..tostring(bHaveLowMass)..'; tLZData[M28Map.subrefTotalMassReclaim]='..tLZData[M28Map.subrefTotalMassReclaim]) end
    if bHaveLowMass and tLZData[M28Map.subrefTotalMassReclaim] >= 50 and tLZData[M28Map.subrefTotalSignificantMassReclaim] > 0 then
        if bDebugMessages == true then LOG(sFunctionRef..': High priority reclaim, Total mass in Plateau '..iPlateau..' LZ '..iLandZone..'='..tLZData[M28Map.subrefTotalMassReclaim]) end
        HaveActionToAssign(refActionReclaimArea, 1, math.min(40, math.max(5, tLZData[M28Map.subrefTotalMassReclaim] / 50)), {false, nil})
    elseif M28Conditions.WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone) then
        HaveActionToAssign(refActionReclaimArea, 1, 5, {true, nil})
    end

    --TMD (including vs mobile ACUs with TML upgrade)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Considering if we want to get TMD; Priority of this action='..iCurPriority..'; is table of units wanting TMD empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]) == false then
        local oUnitWantingTMD = M28Building.GetUnitWantingTMD(tLZData, tLZTeamData, iTeam)
        if bDebugMessages == true then LOG(sFunctionRef..': Is oUnitWantingTMD valid unit='..tostring(M28UnitInfo.IsUnitValid(oUnitWantingTMD))) end
        if oUnitWantingTMD then
            iBPWanted = 40
            if not(bHaveLowMass) and not(bHaveLowPower) then iBPWanted = 70 end
            if bSaveMassForMML then
                iBPWanted = iBPWanted * 0.5
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Want to build TMD, iBPWanted='..iBPWanted..'; Unit wanting TMD='..oUnitWantingTMD.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitWantingTMD)) end
            HaveActionToAssign(refActionBuildTMD, 2, iBPWanted, oUnitWantingTMD)
        end
    end

    --Approaching enemy guncom - prioritise upgrades if dont have T2, if do have T2 then get T2 PD
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if emergency PD is needed, iApproachingACUThreat='..iApproachingACUThreat) end
    if iApproachingACUThreat > 0 and not(M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam]) and (not(M28Overseer.bNoRushActive) or M28Overseer.iNoRushTimer - GetGameTimeSeconds() <= 120 or (not(bHaveLowMass) and not(bHaveLowPower) and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 0)) then
        --Do we have T2 (or a teammate has t3)?
        local bHaveSufficientTech = false
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then bHaveSufficientTech = true
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 then
            local tT2PlusFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory - categories.TECH1, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tT2PlusFactories) == false then
                for iUnit, oUnit in tT2PlusFactories do
                    if oUnit:GetFractionComplete() >= 1 and oUnit:GetAIBrain().M28AI then
                        bHaveSufficientTech = true
                        break
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveSufficientTech='..tostring(bHaveSufficientTech)) end
        if not(bHaveSufficientTech) and (M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 4) then
            --Do we have an active factory upgrade?
            local bHaveActiveHQUpgrade = false
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoActiveUpgrades]) == false then
                for iUpgrade, oUpgrade in tLZTeamData[M28Map.subreftoActiveUpgrades] do
                    if EntityCategoryContains(M28UnitInfo.refCategoryFactory, oUpgrade.UnitId) then
                        bHaveActiveHQUpgrade = true
                        break
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bHaveActiveHQUpgrade='..tostring(bHaveActiveHQUpgrade)) end
            if bHaveActiveHQUpgrade then
                iBPWanted = 20
                if not(bHaveLowPower) and not(bHaveLowMass) then iBPWanted = 40 end
                HaveActionToAssign(refActionAssistUpgrade, 1, iBPWanted)
                if bDebugMessages == true then LOG(sFunctionRef..': We have an active HQ upgrade so will assist this') end
            else
                --We need a priority upgrade
                local tExistingT1LandFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory * categories.TECH1, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if M28Utilities.IsTableEmpty(tExistingT1LandFactories) == false then
                    --Get factory with lowest fraction complete
                    local oFactoryToUpgrade
                    local iLowestWorkProgress = 1
                    local iLowestLandWorkProgress = 1
                    local oBackupFactory
                    for iFactory, oFactory in tExistingT1LandFactories do
                        if M28UnitInfo.IsUnitValid(oFactory) and oFactory:GetFractionComplete() then
                            if (oFactory:GetWorkProgress() or 0) < iLowestLandWorkProgress then
                                if oFactory:GetFractionComplete() == 1 and EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oFactory.UnitId) then
                                    oFactoryToUpgrade = oFactory
                                    iLowestLandWorkProgress = (oFactory:GetWorkProgress() or 0)
                                elseif oFactory:GetWorkProgress() < iLowestWorkProgress then
                                    oBackupFactory = oFactory
                                    iLowestWorkProgress = (oFactory:GetWorkProgress() or 0)
                                end
                            end
                        end
                    end
                    if not(oFactoryToUpgrade) then oFactoryToUpgrade = oBackupFactory end
                    if bDebugMessages == true then LOG(sFunctionRef..': Have searched for t1 land factories to upgrade, is oFactoryToUpgrade valid='..tostring(M28UnitInfo.IsUnitValid(oFactoryToUpgrade))) end
                    if oFactoryToUpgrade then
                        if bDebugMessages == true then LOG(sFunctionRef..': Doign priority upgrade for oFactoryToUpgrade='..oFactoryToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactoryToUpgrade)..' due to appraoching enemy ACU') end
                        M28Economy.UpgradeUnit(oFactoryToUpgrade, true)
                    end
                end
            end
        else
            --We have T2 tech (or only need T1 due to enemy not having gun), so want to build PD
            local iRangeThreshold = 30 --typical guncom range
            if oNearestEnemyACU then iRangeThreshold = (oNearestEnemyACU[M28UnitInfo.refiDFRange] or 0) end
            if not(bHaveSufficientTech) then iRangeThreshold = 1 end
            --Increase PD threat if enemy is in another zone that has PD in it
            local iCurPDThreat = GetPDThreatAboveRangeThresholdAlongPath(iPlateau, iLandZone, tLZData, tLZTeamData, iTeam, iRangeThreshold, tNearestEnemyACU)
            local iACUPlateauOrZero, iACULandZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tNearestEnemyACU)
            if iACULandZone > 0 and iACUPlateauOrZero == iPlateau and not(iACULandZone == iLandZone) then
                --ACU is in a different land zone
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iACULandZone]][M28Map.subrefLZPath]) == false then
                    for iEntry, iAdjLZ in  tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iACULandZone]][M28Map.subrefLZPath] do
                        if not(iAdjLZ == iLandZone) then
                            local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                            if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
                                for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                                    if iRange >= iRangeThreshold then
                                        iCurPDThreat = iCurPDThreat + iThreat
                                    end
                                end
                            end
                        end
                    end
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': We have T2 or better or want T1 PD for nongun ACU, iCurPDThreat='..iCurPDThreat..'; iAppraochingACUThreat='..iApproachingACUThreat..'; bHaveSufficientTech='..tostring(bHaveSufficientTech)) end
            if (bHaveSufficientTech or iCurPDThreat == 0) and (iCurPDThreat <= math.max(1200, iApproachingACUThreat * 1.5) or (iCurPDThreat <= 2400 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 200 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0) and (iApproachingACUThreat >= 1400 or (M28Team.tTeamData[iTeam][M28Team.refbEnemyHasUpgradedACU] and iApproachingACUThreat >= 1000)))) then
                --Do we have friendly mobile units iwth decent range in this zone or an adjacent zone? if so then reduce the threat needed
                local iNearbyMobileThreat = 0
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
                    for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                        if iRange >= iRangeThreshold then
                            iNearbyMobileThreat = iNearbyMobileThreat + iThreat
                        end
                    end
                end

                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                        if M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
                            for iRange, iThreat in tAdjLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                                if iRange >= iRangeThreshold then
                                    iNearbyMobileThreat = iNearbyMobileThreat + iThreat * 0.5
                                end
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iNearbyMobileThreat='..iNearbyMobileThreat..'; iCurPDThreat='..iCurPDThreat..'; iApproachingACUThreat='..iApproachingACUThreat..'; Dist between ACU and this LZ midpoint='..M28Utilities.GetDistanceBetweenPositions(tNearestEnemyACU, tLZData[M28Map.subrefMidpoint])) end
                if iNearbyMobileThreat < 200 or iCurPDThreat < iApproachingACUThreat or iCurPDThreat + iNearbyMobileThreat < iApproachingACUThreat * 1.75 then
                    local iACUThreatFactorWanted = 1.75
                    --below check - ACU doesnt have gun yet and presumably not much veterancy, and we have near-full health T1 and T2 PD
                    if iApproachingACUThreat <= 1150 and iCurPDThreat >= 900 then
                        if (bHaveLowMass or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.3) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 6 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                            iACUThreatFactorWanted = 0.85 --i.e. if we have some nearby mobile threat (even if not much) will be enough
                        else
                            iACUThreatFactorWanted = 1.2
                        end
                    elseif iCurPDThreat >= 2400 and M28Utilities.GetDistanceBetweenPositions(tNearestEnemyACU, tLZData[M28Map.subrefMidpoint]) >= 80 then
                        iACUThreatFactorWanted = 1.4
                    end
                    if bSaveMassForMML then iACUThreatFactorWanted = iACUThreatFactorWanted * 0.75 end
                    if bDebugMessages == true then LOG(sFunctionRef..': iACUThreatFactorWanted='..iACUThreatFactorWanted..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Lowest mass percent='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; bSaveMassForMML='..tostring(bSaveMassForMML)) end
                    if iCurPDThreat + iNearbyMobileThreat < iApproachingACUThreat * iACUThreatFactorWanted then
                        if not(bSaveMassForMML) or iCurPDThreat == 0 or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) then
                            iBPWanted = 40
                            if not(bHaveLowMass) and not(bHaveLowPower) then iBPWanted = 80 end
                            local tTargetBuildLocation
                            if tNearestEnemyACU then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will get PD position, tNearestEnemyACU='..repru(tNearestEnemyACU)..'; tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint])) end
                                tTargetBuildLocation = GetStartSearchPositionForEmergencyPD(tNearestEnemyACU, tLZData[M28Map.subrefMidpoint], iPlateau, iLandZone, tLZTeamData)
                            end
                            local iPDTechLevelWanted = 2
                            if not(bHaveSufficientTech) then iPDTechLevelWanted = 1 end
                            --Reduce BP wanted if enemy has t2 arti nearby
                            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then iBPWanted = iBPWanted * 0.5 end
                            HaveActionToAssign(refActionBuildEmergencyPD, iPDTechLevelWanted, iBPWanted, tTargetBuildLocation)
                            if bDebugMessages == true then LOG(sFunctionRef..': Will build emergency PD, iPDTechLevelWanted='..iPDTechLevelWanted) end
                        end
                    end
                end
            end
        end
    end

    --Nearby enemy ground threat and we dont already have at least 2 T2 PD (more in later game scenarios)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if want emergency PD for normal ground threat, tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Is table of nearest DF enemies empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]))..'; iCurPriority='..iCurPriority..'; Norush active='..tostring(M28Overseer.bNoRushActive)..'; Time until norush nolonger active='..(GetGameTimeSeconds() - (M28Overseer.iNoRushTimer or 0))..'; Have low mass='..tostring(bHaveLowMass)..'; Have low power='..tostring(bHaveLowPower)..'; Mex count by tech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
    if not(M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam]) and tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false and (not(M28Overseer.bNoRushActive) or M28Overseer.iNoRushTimer - GetGameTimeSeconds() <= 120 or (not(bHaveLowMass) and not(bHaveLowPower) and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 0)) then
        --Get existing T2 PD threat
        local iCurPDThreat = 0
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                iCurPDThreat = iCurPDThreat + iThreat
            end
        end
        local iMaxPDThreat = 1700
        if iCurPDThreat <= 20000 and not(bSaveMassForMML) then
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 6 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                iMaxPDThreat = 2800
            end
            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 and tLZTeamData[M28Map.subrefMexCountByTech][2] + 2 * tLZTeamData[M28Map.subrefMexCountByTech][3] >= math.min(4, tLZData[M28Map.subrefLZMexCount] * 0.75) then
                iMaxPDThreat = iMaxPDThreat * 2
            end
        end
        if tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] then iMaxPDThreat=iMaxPDThreat * 1.5 end
        if bDebugMessages == true then LOG(sFunctionRef..': iCurPDThreat in just this zone='..iCurPDThreat..'; iMaxPDThreat='..iMaxPDThreat..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end
        if iCurPDThreat <= iMaxPDThreat and (iCurPDThreat == 0 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] > 1) then
            --Get nearby enemy threat, but only for adjacent LZs
            local iEnemyThreat = tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal]

            if bDebugMessages == true then LOG(sFunctionRef..': enemy combat threat in this zone='..iEnemyThreat..'; Is table of adjacent zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]))) end
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                    local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; Enemy threat in AdjLZ='..(tAltLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)..'; Mobile DF='..(tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0)..'; Mobile indirect='..(tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)) end
                    --onlu use df+IF i best enemy structure range is > 0 and < 35
                    if (tAltLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) > 0 then
                        if (tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] or 50) < 35 then
                            iEnemyThreat = iEnemyThreat + (tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) + (tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)
                        else
                            iEnemyThreat = iEnemyThreat + math.max(math.min(500, (tAltLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)), (tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) + (tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0))
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iEnemyThreat='..iEnemyThreat) end
            if iCurPDThreat < iEnemyThreat * 4 then
                --Are the enemies in an adjacent zone with none in this zone? if so factor in PD in that zone as well
                local iClosestDist = 100000
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) then
                    local iCurDist
                    local oClosestUnit
                    for iUnit, oUnit in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oClosestUnit = oUnit
                            end
                        end
                    end
                    if oClosestUnit and iClosestDist >= 50 then
                        iCurPDThreat = GetPDThreatAboveRangeThresholdAlongPath(iPlateau, iLandZone, tLZData, tLZTeamData, iTeam, 1, oClosestUnit:GetPosition())
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iCurPDThreat for slightly lower priority='..iCurPDThreat..'; iEnemyThreat='..iEnemyThreat..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])) end
                if iCurPDThreat < iEnemyThreat * 3 or (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] and iEnemyThreat >= 1500 and iCurPDThreat < iEnemyThreat * 4 and tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] <= 50 and tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] <= 50) then
                    --Is this early-game, with a relatively low enemy threat, and do we have nearby combat units that can deal with the enemy?
                    local bWantToGetPD = true

                    if iEnemyThreat <= 600 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] <= 2 and GetGameTimeSeconds() <= 720 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] < 6 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                        local iNearbyFriendlyMobileThreat = tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                iNearbyFriendlyMobileThreat = iNearbyFriendlyMobileThreat + (tAltLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] or 0)
                            end
                        end
                        if iNearbyFriendlyMobileThreat > iEnemyThreat * 1.2 or (bHaveLowMass and iCurPDThreat + iNearbyFriendlyMobileThreat > iEnemyThreat * 2.5) then
                            bWantToGetPD = false
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iNearbyFriendlyMobileThreat='..iNearbyFriendlyMobileThreat) end
                    end
                    if bWantToGetPD and bSaveMassForMML and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false and iEnemyThreat < math.min(2000, iCurPDThreat * 4) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) and M28Conditions.GetLifetimeBuildCount(ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]], M28UnitInfo.refCategoryMML) < 15 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to save mass for MMLs instead of trying to get PD') end
                        bWantToGetPD = false
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': bWantToGetPD='..tostring(bWantToGetPD)..'; iEnemyThreat='..iEnemyThreat..'; Highest tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end
                    if bWantToGetPD then
                        iBPWanted = 40
                        if not(bHaveLowMass) and not(bHaveLowPower) then iBPWanted = 80 end
                        local tEnemiesToConsider = {}
                        local oNearestEnemy
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
                            for iUnit, oUnit in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                                if M28UnitInfo.IsUnitValid(oUnit) then
                                    table.insert(tEnemiesToConsider, oUnit)
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(tEnemiesToConsider) == false then
                            if not(oNearestEnemy) then oNearestEnemy = M28Utilities.GetNearestUnit(tLZTeamData[M28Map.reftoNearestDFEnemies], tLZData[M28Map.subrefMidpoint], true, M28Map.refPathingTypeLand) end
                            if oNearestEnemy then
                                if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy='..oNearestEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemy)..'; Position='..repru(oNearestEnemy:GetPosition())) end
                                local tTargetBuildLocation = GetStartSearchPositionForEmergencyPD(oNearestEnemy:GetPosition(), tLZData[M28Map.subrefMidpoint], iPlateau, iLandZone, tLZTeamData)
                                local iMinTechWanted = 1
                                if iCurPDThreat > 0 then iMinTechWanted = 2 end
                                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then iBPWanted = iBPWanted * 0.5 end
                                HaveActionToAssign(refActionBuildEmergencyPD, iMinTechWanted, iBPWanted, tTargetBuildLocation)
                                if bDebugMessages == true then LOG(sFunctionRef..': Will build emergency PD to stop enemy ground threat, iMinTechWanted='..iMinTechWanted) end
                            end
                        end
                    end
                end
            end
        end
    end

    --High priority T1 radar if we have T2 arti but poor radar coverage
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; Radar coverage='..tLZTeamData[M28Map.refiRadarCoverage]..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]) end
    if (not(bHaveLowPower) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 100) and (tLZTeamData[M28Map.refiRadarCoverage] <= 100 or (M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.refoBestRadar]) and tLZTeamData[M28Map.refoBestRadar]:GetFractionComplete() < 1)) then
        --Do we have T2 arti in this zone, or T2 PD with poor radar, or lots of mexes
        if bDebugMessages == true then LOG(sFunctionRef..': T3 mex count='..tLZTeamData[M28Map.subrefMexCountByTech][3]..'; Is table of T2 arti empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))) end
        if tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false or (tLZTeamData[M28Map.refiRadarCoverage] <= 50 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryT2PlusPD, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false) then
            local bWantT1DueToRadarUnderConstruction = false
            if M28UnitInfo.IsUnitValid(tLZTeamData[M28Map.refoBestRadar]) and tLZTeamData[M28Map.refoBestRadar]:GetFractionComplete() < 1 then
                local tRadarInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryRadar, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                bWantT1DueToRadarUnderConstruction = true
                if M28Utilities.IsTableEmpty(tRadarInZone) == false then
                    for iUnit, oUnit in tRadarInZone do
                        if M28UnitInfo.IsUnitValid(oUnit) and (oUnit:GetFractionComplete() == 1 or EntityCategoryContains(categories.TECH1, oUnit.UnitId)) then
                            bWantT1DueToRadarUnderConstruction = false
                            break
                        end
                    end
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) end
            --T1 radar
            local bWantT1RadarFirst = false
            if (bWantT1DueToRadarUnderConstruction or tLZTeamData[M28Map.refiRadarCoverage] <= 50) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 25 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2.5 then
                --Check we dont already have t1 radar in the land zone
                if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryT1Radar, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) then
                    iBPWanted = 5
                    if not(bHaveLowMass) then iBPWanted = 15 end
                    bWantT1RadarFirst = true
                    HaveActionToAssign(refActionBuildT1Radar, 1, iBPWanted)
                    if bDebugMessages == true then LOG(sFunctionRef..': High priority T1 radar builder, iBPWanted='..iBPWanted) end
                end
            end

            --T2 radar
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if want T2 radar, tLZTeamData[M28Map.refiRadarCoverage]='..tLZTeamData[M28Map.refiRadarCoverage]..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; bWantT1RadarFirst='..tostring(bWantT1RadarFirst)) end
            if not(bSaveMassForMML) and not(bWantT1RadarFirst) and tLZTeamData[M28Map.refiRadarCoverage] <= 130 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 40 + 60 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 3 + 2 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                if not(tLZTeamData[M28Map.refbBaseInSafePosition]) or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] or M28Map.bIsCampaignMap or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then
                    --Check we dont already have t2 radar in the land zone
                    if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryT2Radar, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) then
                        iBPWanted = 20
                        if not(bHaveLowMass) then iBPWanted = 60 end
                        if bDebugMessages == true then LOG(sFunctionRef..': High priority t2 radar builder') end
                        HaveActionToAssign(refActionBuildT2Radar, 2, iBPWanted)
                    end
                end
            end
        end
    end

    --More land factories to produce MML to try and beat a firebase
    iCurPriority = iCurPriority + 1
    if bSaveMassForMML and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.05 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 300 and ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Economy.refiOurHighestLandFactoryTech] == 2 then
        if bWantMoreFactories and not(M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)) then
            HaveActionToAssign(refActionBuildLandFactory, 2, 40)
        else
            --Find the closest highest tech land factory
            local oClosestFactory
            local iHighestTech = 2 --no point assisting if we dont ahve a T2 land fac
            local iClosestDistOfHighestTech = 10000
            local tLandFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tLandFactories) == false then
                local iCurDist, iCurTech
                for iUnit, oUnit in tLandFactories do
                    iCurTech = M28UnitInfo.GetUnitTechLevel(oUnit)
                    if iCurTech >= iHighestTech then
                        if iCurTech > iHighestTech then
                            iHighestTech = iCurTech
                            iClosestDistOfHighestTech = 100000
                        end
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                        if iCurDist < iClosestDistOfHighestTech then
                            iClosestDistOfHighestTech = iCurDist
                            oClosestFactory = oUnit
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will assist land fac as we want MMLs, oClosestFactory='..(oClosestFactory.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestFactory) or 'nil')) end
            if oClosestFactory then
                HaveActionToAssign(refActionAssistLandFactory, 1, 100, oClosestFactory)
            else
                HaveActionToAssign(refActionBuildLandFactory, 2, 40)
            end
        end
    end


    --T2 arti if enemy has sniper bots or fatboy, or a firebase that threatens this zone
    iCurPriority = iCurPriority + 1
    GiveOrderForEmergencyT2Arti(HaveActionToAssign, bHaveLowMass, bHaveLowPower, iPlateau, iLandZone, tLZData, tLZTeamData, iTeam)

    --Assist land factory if we want to focus on getting sniperbots
    iCurPriority = iCurPriority + 1
    if ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Economy.refiOurHighestLandFactoryTech] >= 2 and M28Conditions.PrioritiseSniperBots(iTeam, tLZTeamData) then
        iBPWanted = 90
        if not(bHaveLowMass) then iBPWanted = 180 end
        local oClosestFactory
        local tAeonAndSeraFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory * categories.AEON + M28UnitInfo.refCategoryLandFactory * categories.SERAPHIM, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tAeonAndSeraFactories) == false then
            local oClosestFactory = M28Utilities.GetNearestUnit(tAeonAndSeraFactories, tLZData[M28Map.subrefMidpoint])
            if oClosestFactory then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to assist land factory so we can get more sniperbots') end
                HaveActionToAssign(refActionAssistLandFactory, 1, iBPWanted, oClosestFactory)
            end
        end
    end

    --Extra (second) shielding in a high mass scenario - will only try to shield t3 arti/game ender
    iCurPriority = iCurPriority + 1
    if (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 500 then

        local iBPWanted, iTechLevelWanted, oUnitToShield = GetBPMinTechAndUnitForFixedShields(tLZData, tLZTeamData, iTeam, true, bHaveLowMass, bWantMorePower, true, iLandZone, iPlateau)
        if iBPWanted > 0 then
            iBPWanted = math.min(iBPWanted, 40)
            if M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] == 0 then iBPWanted = iBPWanted * 0.5 end
            HaveActionToAssign(refActionBuildSecondShield, iTechLevelWanted, iBPWanted, oUnitToShield)
            if bDebugMessages == true then LOG(sFunctionRef..': Second shield builder, iBPWanted='..iBPWanted..'; iLandZone='..iLandZone) end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Dont want to assign any BP to second shield builder, LZ='..iLandZone) end
        end
    end

    --T2 arti to combat enemy navy if have t3 mexes
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 then
        local iAirSubteam = aiBrain.M28AirSubteam
        if bDebugMessages == true then LOG(sFunctionRef..': Considering for P'..iPlateau..'L'..iLandZone..'; M28Team.tAirSubteamData[iAirSubteam][M28Team.refbNoAvailableTorpsForEnemies]='..tostring(M28Team.tAirSubteamData[iAirSubteam][M28Team.refbNoAvailableTorpsForEnemies] or false)..'; Is table of defence water zones empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftiTorpedoDefenceWaterZones]))..'; Highest factory tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end
        if M28Team.tAirSubteamData[iAirSubteam][M28Team.refbNoAvailableTorpsForEnemies] and M28Utilities.IsTableEmpty(M28Team.tAirSubteamData[iAirSubteam][M28Team.reftiTorpedoDefenceWaterZones]) == false and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 then
            local iTotalNearbyWaterThreat = 0
            for iEntry, iWaterZone in M28Team.tAirSubteamData[iAirSubteam][M28Team.reftiTorpedoDefenceWaterZones] do
                local tWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iWaterZone]][M28Map.subrefPondWaterZones][iWaterZone]
                local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false and not(tWZTeamData[M28Map.subrefbWZOnlyHoverEnemies]) then
                    --How far away is the WZ to us?
                    if M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefMidpoint], tLZData[M28Map.subrefMidpoint]) <= 170 then
                        iTotalNearbyWaterThreat = iTotalNearbyWaterThreat + math.max(0, (tWZTeamData[M28Map.subrefWZThreatEnemySurface] or 0) - (tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0))
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Checking threat in iWaterZone='..iWaterZone..'; is table of enemy units mpety='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]))..'; does this WZ have only hover enemies='..tostring(tWZTeamData[M28Map.subrefbWZOnlyHoverEnemies])..'; iTotalNearbyWaterThreat='..iTotalNearbyWaterThreat) end
            end
            if iTotalNearbyWaterThreat >= 1000 then
                local iT2ArtiWanted = math.max(1, math.min(5, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 0.3 / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount], iTotalNearbyWaterThreat / 2000))
                local iT2ArtiCount = 0
                local tCurT2Arti = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if M28Utilities.IsTableEmpty(tCurT2Arti) == false then
                    for iUnit, oUnit in tCurT2Arti do
                        if oUnit:GetFractionComplete() == 1 then
                            iT2ArtiCount = iT2ArtiCount + 1
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iT2ArtiCount='..iT2ArtiCount..'; iT2ArtiWanted='..iT2ArtiWanted) end
                if iT2ArtiCount < iT2ArtiWanted then
                    iBPWanted = 50
                    if not(bHaveLowMass) and not(bHaveLowPower) then iBPWanted = 120 end

                    local tLocationToBuild
                    if iT2ArtiCount >= 3 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) then
                        tLocationToBuild = M28Utilities.MoveInDirection(tLZData[M28Map.subrefMidpoint], M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase]), 20, true, false)
                        if not(NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, tLocationToBuild) == iPlateau) then
                            tLocationToBuild = {tLZData[M28Map.subrefMidpoint][1]. tLZData[M28Map.subrefMidpoint][2]. tLZData[M28Map.subrefMidpoint][3]}
                        end
                    else
                        tLocationToBuild = {tLZData[M28Map.subrefMidpoint][1], tLZData[M28Map.subrefMidpoint][2], tLZData[M28Map.subrefMidpoint][3]}
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Getting T2 arti to deal with enemy navy') end
                    HaveActionToAssign(refActionBuildEmergencyArti, 2, iBPWanted, tLocationToBuild)
                end
            end
        end
    end

    --Assign engineers to experimental eg in case original constructing engineers died
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 then
        local oExperimentalToAssist = GetPartCompleteBuildingInZone(iTeam, iPlateau, iLandZone, M28UnitInfo.refCategoryExperimentalLevel - categories.NAVAL, false)
        if oExperimentalToAssist then
            iBPWanted = 30
            if oExperimentalToAssist:GetFractionComplete() >= 0.6 then
                iBPWanted = 120
                if not(bHaveLowPower) and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) then iBPWanted = math.max(iBPWanted, math.min(240, math.max(iBPWanted, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 12))) end
            elseif not(bHaveLowPower) then
                iBPWanted = 60
                if not(bHaveLowMass) then iBPWanted = 120 end
            end
            HaveActionToAssign(refActionRepairUnit, 1, iBPWanted, oExperimentalToAssist)
        end
    end


    --More factories if have some mass stored and enemy is still at T1
    iCurPriority = iCurPriority + 1
    if bWantMoreFactories and (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 300) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] == 1 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] <= math.min(2, M28Team.tTeamData[iTeam][M28Team.subrefiLowestFriendlyLandFactoryTech])) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] <= 1 then
        iBPWanted = 20
        if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) then
            HaveActionToAssign(refActionBuildAirFactory, 1, iBPWanted)
        else
            HaveActionToAssign(refActionBuildLandFactory, 1, iBPWanted)
        end
    end


    --Preemptive fixed AA if we have T2+ air fac and no fixed T2+ ground AA and dont have much MAA threat here either
    --Also includes T3 SAM preemptive builder in greater numbers if we lack air control and have at least 10 mass per tick and not low mass
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want fixed AA due to haveing T2+ air, iCurPriority='..iCurPriority..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]..'; tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 2 and tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < 800 * (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] - 1) then
        --Does enemy have air to ground threat that exceeds our AA threat in this zone, and/or do we have at least 2 T3 mexes in this zone and not have low mass?
        if bDebugMessages == true then LOG(sFunctionRef..': enemy air to ground threat='..(M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] or 0)..'; Ally groundAA in this zone='..(tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0)..'; bHaveLowMass='..tostring(bHaveLowMass)..'; bHaveLowPower='..tostring(bHaveLowPower)..'; Mex count by tech='..tLZTeamData[M28Map.subrefMexCountByTech][3] >= math.min(3, tLZData[M28Map.subrefLZMexCount] * 0.5)) end
        if (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] or 0) > (tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0) or (not(bHaveLowMass) and not(bHaveLowPower) and (tLZTeamData[M28Map.subrefMexCountByTech][3] >= math.min(3, tLZData[M28Map.subrefLZMexCount] * 0.5) or (tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] >= 3 and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] >= math.max(700, (M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat] or 0) * 1.2)))) then

            --Do we already have fixed AA in this LZ?
            local iAACategory = M28UnitInfo.refCategoryStructureAA - categories.TECH1
            if M28Team.subrefiHighestFriendlyFactoryTech >= 3 then iAACategory = iAACategory * categories.TECH3 end
            local tExistingFixedAA = EntityCategoryFilterDown(iAACategory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            local bHaveFixedAA = false
            if M28Utilities.IsTableEmpty(tExistingFixedAA) == false then
                for iUnit, oUnit in tExistingFixedAA do
                    if oUnit:GetFractionComplete() then bHaveFixedAA = true break end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bHaveFixedAA='..tostring(bHaveFixedAA)) end
            if not(bHaveFixedAA) then
                iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
                if iNearbyEnemyAirToGroundThreat > 0 then iBPWanted = iBPWanted * 2 end
                if not(bHaveLowPower) then
                    if not(bHaveLowMass) then iBPWanted = iBPWanted * 3
                    else iBPWanted = iBPWanted * 1.5
                    end
                end
                HaveActionToAssign(refActionBuildAA, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted)
                if bDebugMessages == true then LOG(sFunctionRef..': T2 plus preemptive AA builder, iBPWanted='..iBPWanted) end
            elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 and not(bHaveLowMass) and not(M28Team.tAirSubteamData[ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].M28AirSubteam][M28Team.refbHaveAirControl]) and table.getn(tExistingFixedAA) < 4 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to get T3 AA preemptively') end
                HaveActionToAssign(refActionBuildAA, 3, 30)
            end
        end
    end

    --Second power builder to help scale power late game if high on mass
    iCurPriority = iCurPriority + 1
    if bWantMorePower and not(bHaveLowMass) and not(bSaveMassForMML) and ((M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 0) >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 * (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 1)) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 120 * (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 1) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0) * 1.25 then
        iBPWanted = tiBPByTech[(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 1)] * 10
        --reduce BP wanted if dont have massive amount of mass
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] <= 5000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 25 then iBPWanted = iBPWanted * 0.6 end
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 500 then
            iBPWanted = iBPWanted * 0.5 --i.e. want to have construction started so primary power builder can build sooner but not as worried about building this really fast
        end
        --If havent built the first Pgen of this tech level yet then wait
        local bNotBuiltAnyPowerYet = false
        local oPowerToAssistInstead
        if (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 1) >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 300 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
            local tFriendlyPowerOfTechWanted = EntityCategoryFilterDown(M28UnitInfo.refCategoryPower * M28UnitInfo.ConvertTechLevelToCategory(math.min(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], 3)), tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            local iClosestToCompletion = 0
            bNotBuiltAnyPowerYet = true
            if M28Utilities.IsTableEmpty(tFriendlyPowerOfTechWanted) == false then
                for iUnit, oUnit in tFriendlyPowerOfTechWanted do
                    if oUnit:GetFractionComplete() == 1 then
                        bNotBuiltAnyPowerYet = false
                        oPowerToAssistInstead = nil
                        break
                    elseif oUnit:GetFractionComplete() > iClosestToCompletion then
                        oPowerToAssistInstead = oUnit
                        iClosestToCompletion = oUnit:GetFractionComplete()
                    end
                end
            end
        end
        if bNotBuiltAnyPowerYet then
            if bDebugMessages == true then LOG(sFunctionRef..': Normally would want to start second power builder but we havent built first yet so will focus on completing that, iClosestToCompletion='..iClosestToCompletion..'; oPowerToAssistInstead='..(oPowerToAssistInstead.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oPowerToAssistInstead) or 'nil')) end
            if oPowerToAssistInstead then
                HaveActionToAssign(refActionRepairUnit, 1, iBPWanted, oPowerToAssistInstead)
            end
        else
            HaveActionToAssign(refActionBuildSecondPower, (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 1), iBPWanted)
            if bDebugMessages == true then LOG(sFunctionRef..': Want to build second power due to lots of mass and having recently needed more energy for air production') end
        end
    end

    --Similar to above but for third power with slightly greater mass threshold, and only for very high mass and energy incomes, and only if have stalled for power in last 60s
    iCurPriority = iCurPriority + 1
    if bWantMorePower and not(bHaveLowMass) and not(bSaveMassForMML) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 8000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 60 and (GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or 0) <= 60 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0) * 1.1) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 0) >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 1500 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0) * 1.25 then
        iBPWanted = 325 --10 T3 engis
        --reduce BP wanted if dont have massive amount of mass
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] <= 15000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 80 then iBPWanted = 150 end
        HaveActionToAssign(refActionBuildThirdPower, 3, iBPWanted)
        if bDebugMessages == true then LOG(sFunctionRef..': Want to build second power due to lots of mass and having recently needed more energy for air production') end
    end

    --High priority factories
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to build a factory, bWantMoreFactories='..tostring(bWantMoreFactories)..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Mass % stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; Highest tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end
    if bWantMoreFactories and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 11 and (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.4 or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 and GetGameTimeSeconds() <= 600 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.05) or (M28Map.iMapSize <= 256 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 150 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0)))) then
        if (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 0) > 0 then
            if bHaveLowMass then iBPWanted =  tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2
            else iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 4
            end
        else
            iBPWanted = 5
        end

        local bWantAirNotLand = M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)
        local iFactoryAction
        if bWantAirNotLand then iFactoryAction = refActionBuildAirFactory
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Want to build land factory not air factory2') end
            iFactoryAction = refActionBuildLandFactory
        end

        local tFactoriesInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory + M28UnitInfo.refCategoryAirFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tFactoriesInZone) == false then
            for iUnit, oUnit in tFactoriesInZone do
                if oUnit:GetFractionComplete() < 1 and not(oUnit:IsUnitState('Upgrading')) and not(oUnit:IsUnitState('BeingUpgraded')) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a factory under construction in this zone already, unit state='..M28UnitInfo.GetUnitState(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                    if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oUnit.UnitId) then iFactoryAction = refActionBuildAirFactory
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) then iFactoryAction = refActionBuildLandFactory
                    end
                end
            end
        end

        if bHaveLowPower and bWantAirNotLand then iBPWanted = iBPWanted * 0.5 end
        if bDebugMessages == true then LOG(sFunctionRef..': Wnat to build a factory, iBPWanted='..iBPWanted..'; iFactoryAction='..iFactoryAction..'; bWantAirNotLand='..tostring(bWantAirNotLand)) end
        HaveActionToAssign(iFactoryAction, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted, nil)
    end


    --High priority islands (early-game expansion)
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS)
    iCurPriority = iCurPriority + 1
    local iBPAlreadyTraveling = 0
    GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if bDebugMessages == true then LOG(sFunctionRef..': Core LZ considering engis for islands, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Time='..GetGameTimeSeconds()) end
    if iHighestTechEngiAvailable > 0 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of pathing to other islands empty='..tostring(tLZData[M28Map.subrefLZPathingToOtherIslands])) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
            local iDistanceThreshold = math.max(125, M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) * 0.502)
            if bDebugMessages == true then LOG(sFunctionRef..': iDistanceThreshold='..iDistanceThreshold) end

            for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..'; Travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; tPathingData[M28Map.subrefIslandClosestLZRef]='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; Are there enemies in this or adjacnet LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                if tPathingData[M28Map.subrefIslandTravelDist] > iDistanceThreshold then break
                else
                    --Are there enemies in the target LZ?
                    local tIslandLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]]
                    if tPathingData[M28Map.subrefIslandClosestLZRef] and M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefMexUnbuiltLocations]) == false and (tIslandLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] or 0) == 0 then
                        local iEnemyThreatNearby = 0
                        if tIslandLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                            if M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                    local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                                    iEnemyThreatNearby = iEnemyThreatNearby + (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..'; iEnemyThreatNearby='..iEnemyThreatNearby) end
                        if iEnemyThreatNearby <= 10 then
                            local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, tPathingData[M28Map.subrefIslandClosestLZRef], iEntry, iHighestTechEngiAvailable, false, true)
                            if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                            if tiBPByTechWanted then
                                --Is it either a minor zone, or a core zone that either wants lots of BP or doesnt have any engineers traveling to it?
                                for iTech = 1, iHighestTechEngiAvailable, 1 do
                                    if tiBPByTechWanted[iTech] > 0 then
                                        iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                        iBPWanted = iBPAlreadyTraveling + 5
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and assign an engineer to go to tPathingData[M28Map.subrefIslandClosestLZRef]='..tPathingData[M28Map.subrefIslandClosestLZRef]..'; BP wanted='..iBPWanted..'; iTech='..iTech..'; iPrevEngisAvailable='..iPrevEngisAvailable) end
                                        HaveActionToAssign(refActionMoveToLandZone, iTech, iBPWanted, tPathingData[M28Map.subrefIslandClosestLZRef], true)
                                        if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                            iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                            iBPAlreadyTraveling = iBPAlreadyTraveling + tiBPByTech[iTech]
                                        end

                                        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                        if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable after this='..iHighestTechEngiAvailable) end
                                        if iHighestTechEngiAvailable == 0 then break end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    --TML if enemy has vulnerable units
    iCurPriority = iCurPriority + 1
    if iHighestTechEngiAvailable >= 2 and not(bHaveLowPower) then
        iBPWanted = GetBPToAssignToBuildingTML(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam, bHaveLowMass)
        if iBPWanted > 0 then
            HaveActionToAssign(refActionBuildTML, 2, iBPWanted)
        end
    end

    --High priority T2 radar if we have sniperbots or fatboy
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.refiRadarCoverage] <= 130 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] or 0) >= 3 and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] >= math.min(2, tLZData[M28Map.subrefLZMexCount]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 200 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]  and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and not (M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmni]) then
        local bHaveAnySnipersOrFatboy = false
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            if oBrain:GetCurrentUnits(M28UnitInfo.refCategoryFatboy) > 0 then
                bHaveAnySnipersOrFatboy = true
                break
            elseif oBrain:GetCurrentUnits(M28UnitInfo.refCategorySniperBot) >= 3 then
                bHaveAnySnipersOrFatboy = true
                break
            end
        end
        if bHaveAnySnipersOrFatboy then
            if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryT2Radar, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) then
                iBPWanted = 15
                if not(bHaveLowMass) and not(bHaveLowPower) then iBPWanted = 40 end
                HaveActionToAssign(refActionBuildT2Radar, 2, iBPWanted)
            end
        end
    end

    --High priority omni if we have fatboy or sniperbots
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.refiRadarCoverage] <= 300 and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 750 / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and tLZTeamData[M28Map.subrefMexCountByTech][3] >= math.min(2, tLZData[M28Map.subrefLZMexCount]) and (not(bHaveLowPower) or (not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > 10)) and not (M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmni]) then
        --We have built at least 1 exp, and lack omni coverage, and have enough powe that we could probably support an omni
        local bHaveFatboyOrSnipers = false
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            if oBrain:GetCurrentUnits(M28UnitInfo.refCategoryFatboy) > 0 then
                bHaveFatboyOrSnipers = true
                break
            elseif oBrain:GetCurrentUnits(M28UnitInfo.refCategorySniperBot) >= 3 then
                bHaveFatboyOrSnipers = true
                break
            end
        end
        if bHaveFatboyOrSnipers then
            --T2 radar
            local bBuildingT2 = false
            iCurPriority = iCurPriority + 1
            if bDebugMessages == true then LOG(sFunctionRef..': High priority Considering if want T2 radar, tLZTeamData[M28Map.refiRadarCoverage]='..tLZTeamData[M28Map.refiRadarCoverage]..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]) end
            if tLZTeamData[M28Map.refiRadarCoverage] <= 130 then
                --Check we dont already have t2 radar in the land zone
                if not(tLZTeamData[M28Map.refbBaseInSafePosition]) or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] or M28Map.bIsCampaignMap or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then
                    if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryT2Radar, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) then
                        iBPWanted = 20
                        if not(bHaveLowMass) then iBPWanted = 60 end
                        HaveActionToAssign(refActionBuildT2Radar, 2, iBPWanted)
                        bBuildingT2 = true
                    end
                end
            end

            --T3 radar
            iCurPriority = iCurPriority + 1
            if bDebugMessages == true then LOG(sFunctionRef..': High priority Considering whether to build T3 radar, tLZTeamData[M28Map.refiRadarCoverage]='..tLZTeamData[M28Map.refiRadarCoverage]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Closest enemy base dist to midpoint='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase])..'; tLZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
            if not(bSaveMassForMML) and tLZTeamData[M28Map.refiRadarCoverage] <= 300 then
                --Require T3 mexes before building T3 radar
                if tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 or (tLZTeamData[M28Map.subrefMexCountByTech][3] == 1 and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][1] == 0) then
                    iBPWanted = 30
                    if not(bHaveLowMass) then iBPWanted = 100 end
                    if bBuildingT2 then iBPWanted = 5 end
                    if bDebugMessages == true then LOG(sFunctionRef..': Will build T3 radar, iBPWanted='..iBPWanted..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]) end
                    HaveActionToAssign(refActionBuildT3Radar, 3, iBPWanted)
                end
            end
        end
    end

    --Focus on building our own experimental if we have one already under construction and enemy has any non fatboy experimentals, and we have at least 1 T3 mex
    iCurPriority = iCurPriority + 1
    if (not(bHaveLowPower) or not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])) and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] < M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.ALLUNITS - M28UnitInfo.refCategoryFatboy, M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals])) == false and (tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 7000) then
        local iHighestCompleteExperimentalInZone = 0
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            local tExperimentalsUnderConstruction = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandExperimental, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tExperimentalsUnderConstruction) == false then
                for iUnit, oUnit in tExperimentalsUnderConstruction do
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        iHighestCompleteExperimentalInZone = math.max(iHighestCompleteExperimentalInZone, oUnit:GetFractionComplete())
                    end
                end
            end

        end
        if bDebugMessages == true then LOG(sFunctionRef..': iHighestCompleteExperimentalInZone='..iHighestCompleteExperimentalInZone) end
        if iHighestCompleteExperimentalInZone > 0 then
            --As a very rough guide, every 1 build power on a GC will use roughly 0.5 mass per sec; so if want 50% of entire team eco on this experimental, then want to assign
            if bHaveLowMass and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] < 1000 then
                iBPWanted = math.min(500, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 8 + M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] / 25)
            else
                iBPWanted = math.min(500, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 14 + M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] / 25)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': BP want to assist under construction experimental='..iBPWanted) end
            --Assist the experimental
            HaveActionToAssign(refActionBuildExperimental, 1, iBPWanted)
        end
    end

    --Assist air fac if at T2+ and want more factories
    iCurPriority = iCurPriority + 1
    if not(bWantMorePower) and (not(bHaveLowMass) or bWantMoreFactories) and not(bSaveMassForMML) then
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 2 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 or M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryAllAir - categories.TECH1) <= 5) then
            --Check we have more power than when we last were unable to build air units
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] > (M28Team.tTeamData[iTeam][M28Team.refiEnergyWhenAirFactoryLastUnableToBuildAir] or 0) * 1.25 then
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                    local tT2PlusAirFacsInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory * M28UnitInfo.ConvertTechLevelToCategory(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]), tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(   tT2PlusAirFacsInLZ) == false and (not(bHaveLowMass) or tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                        if bHaveLowMass then iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 1.5
                        else
                            iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 4
                            if not(bWantMorePower) then iBPWanted = iBPWanted * 2 end
                        end
                        local oAirFactoryToAssist
                        local iHighestAirFac = 0
                        local iCurTechLevel
                        for iFactory, oFactory in tT2PlusAirFacsInLZ do
                            iCurTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
                            if iCurTechLevel > iHighestAirFac then
                                iHighestAirFac = iCurTechLevel
                                oAirFactoryToAssist = oFactory
                            end
                        end
                        if oAirFactoryToAssist then
                            HaveActionToAssign(refActionAssistAirFactory, 1, iBPWanted, oAirFactoryToAssist)
                        end
                    end
                end
            end
        end
    end

    --Energy storage once have eco to support it
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; Considering building energy storage, Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; Have low power='..tostring(bHaveLowPower)..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount]='..M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount]..'; Enemy unit with highest health='..M28Team.tTeamData[iTeam][M28Team.refiEnemyHighestMobileLandHealth]) end
    if not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] <= 7 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 1 + M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] * 5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 30 + M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] * 20 and (((M28Map.bIsCampaignMap or (GetGameTimeSeconds() >= 600 and M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] == 0)) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1 + 0.25 * M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount]) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2.5 + 0.25 * M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount])) then
        --Do we have enough storage to 1-shot any enemy unit?
        if M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] < math.max(1, math.ceil((M28Team.tTeamData[iTeam][M28Team.refiEnemyHighestMobileLandHealth] / 0.9 - 1000) / (0.25 * M28Building.iEnergyStorageExpectedCapacity))) then
            --Is the number of storage in this LZ <= lowest storage count?
            local toStorageInThisLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryEnergyStorage, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            local iStorageInThisLZ
            if M28Utilities.IsTableEmpty(toStorageInThisLZ) == false then
                iStorageInThisLZ = table.getn(toStorageInThisLZ)
            else
                iStorageInThisLZ = 0
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iStorageInThisLZ='..iStorageInThisLZ) end
            if iStorageInThisLZ <= M28Team.tTeamData[iTeam][M28Team.subrefiLowestEnergyStorageCount] and (not(bSaveMassForMML) or iStorageInThisLZ == 0) then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to get storage, Is tEngineers[1] valid='..tostring(M28UnitInfo.IsUnitValid(tEngineers[1]))) end
                iBPWanted = 5
                if not(bHaveLowMass) then iBPWanted = 20 end
                HaveActionToAssign(refActionBuildEnergyStorage, 1, iBPWanted)
            end
        end
    end

    --1 T3 mass fab if not defending against T3 arti and have lots of t3 mexes
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Mass fab builder: Highest friendly fac tech='..(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 'nil')..'; Mex count by tech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; bHaveLowPower='..tostring(bHaveLowPower)..'; Defending against arti='..tostring(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti])) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and (tLZTeamData[M28Map.subrefMexCountByTech][3] >= tLZData[M28Map.subrefLZMexCount] or (M28Overseer.bNoRushActive and tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 and tLZTeamData[M28Map.subrefMexCountByTech][2] == 0 and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and M28Conditions.NoRushPreventingHydroOrMex(tLZData, true))) and not(bHaveLowPower) and not(bSaveMassForMML) then
        if bDebugMessages == true then LOG(sFunctionRef..': Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; bLowMexMap='..tostring(M28Map.bIsLowMexMap)..'; M28Overseer.iMassFabRatio='..(M28Overseer.iMassFabRatio or 'nil')) end
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 250 + 500 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or ((M28Map.bIsLowMexMap or M28Overseer.bNoRushActive) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 260 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) or (M28Overseer.iMassFabRatio >= 1.3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 250 + 150 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
            --Do we either have a constructed experimental in this zone, or have unit restrictions?
            if M28Overseer.bUnitRestrictionsArePresent or (tLZTeamData[M28Map.refiZoneConstructedExperimentalCount] or 0) > 0 or M28Overseer.bNoRushActive then
                local iExistingT3MassFabs = 0
                local iUnderConstructionT3MassFabs = 0
                local tExistingMassFabs = EntityCategoryFilterDown(M28UnitInfo.refCategoryMassFab * categories.TECH3, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if M28Utilities.IsTableEmpty( tExistingMassFabs) == false then
                    for iUnit, oUnit in tExistingMassFabs do
                        if oUnit:GetFractionComplete() < 1 then iUnderConstructionT3MassFabs = iUnderConstructionT3MassFabs + 1
                        else iExistingT3MassFabs = iExistingT3MassFabs + 1
                        end
                    end
                end
                local iMaxMassFabsWanted = 1
                local iModFactor = M28Overseer.iMassFabRatio * M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier]
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 8 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or M28Map.bIsLowMexMap or iModFactor >= math.max(1.2, 1 + 0.1 * iExistingT3MassFabs) then
                    iMaxMassFabsWanted = 4
                    if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] then
                        --If enemy has multiple T3 arti or novax or gameender then reduce to 1
                        local iEnemyCount = 0
                        if M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure]) then
                            for iUnit, oUnit in M28Team.tTeamData[iTeam][M28Team.reftEnemyArtiAndExpStructure] do
                                if oUnit:GetFractionComplete() >= 0.35 then
                                    if EntityCategoryContains(M28UnitInfo.refCategoryGameEnder, oUnit.UnitId) then
                                        iEnemyCount = iEnemyCount + 3
                                    elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT3Arti, oUnit.UnitId) then
                                        iEnemyCount = iEnemyCount + 1
                                    else
                                        iEnemyCount = iEnemyCount + 0.5
                                    end
                                end
                            end
                        end
                        iMaxMassFabsWanted = math.max(0, iMaxMassFabsWanted - iEnemyCount)
                        if bDebugMessages == true then LOG(sFunctionRef..': Are defending against arti, imaxMassFabsWanted='..iMaxMassFabsWanted..'; iEnemyCount='..iEnemyCount) end
                    end
                elseif M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] then iMaxMassFabsWanted = 0
                end
                if iModFactor >= 1.5 then
                    iMaxMassFabsWanted = math.max(2,iMaxMassFabsWanted * ((iModFactor - 1)*0.5 + 1))
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iExistingT3MassFabs='..iExistingT3MassFabs..'; iMaxMassFabsWanted='..iMaxMassFabsWanted..'; iUnderConstructionT3MassFabs='..iUnderConstructionT3MassFabs) end

                if iExistingT3MassFabs < iMaxMassFabsWanted or iUnderConstructionT3MassFabs > 0 then
                    iBPWanted = 90
                    if bWantMorePower then iBPWanted = 45 end
                    HaveActionToAssign(refActionBuildT3MassFab, 3, iBPWanted)
                    if bDebugMessages == true then LOG(sFunctionRef..': iBpWanted for mass fabs='..iBPWanted) end
                elseif M28Map.bIsLowMexMap or (M28Overseer.bNoRushActive and M28Overseer.iNoRushTimer - GetGameTimeSeconds() >= 60) then
                    local tQuantumGateways = EntityCategoryFilterDown(M28UnitInfo.refCategoryQuantumGateway, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    local iExistingGateways = 0
                    if M28Utilities.IsTableEmpty( tQuantumGateways) == false then
                        for iUnit, oUnit in tQuantumGateways do
                            if oUnit:GetFractionComplete() == 1 then
                                iExistingGateways = iExistingT3MassFabs + 1
                            end
                        end
                    end
                    if iExistingGateways == 0 then
                        iBPWanted = 70
                        if bWantMorePower then iBPWanted = 35 end
                        HaveActionToAssign(refActionBuildQuantumGateway, 3, iBPWanted)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have enough mass fabs but want quantum gateway, iBPWanted='..iBPWanted) end
                    end

                end
            end
        end
    end

    --Shielding
    iCurPriority = iCurPriority + 1
    local iTechLevelWanted, oUnitToShield
    iBPWanted, iTechLevelWanted, oUnitToShield = GetBPMinTechAndUnitForFixedShields(tLZData, tLZTeamData, iTeam, true, bHaveLowMass, bWantMorePower, false, iLandZone, iPlateau)
    if iBPWanted > 0 then
        if bDebugMessages == true then LOG(sFunctionRef..': Want to build a shield, iBPWanted='..iBPWanted..'; bHaveLowMass='..tostring(bHaveLowMass)..'; bWantMorePower='..tostring(bWantMorePower)..'; oUnitToShield='..oUnitToShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToShield)..'; iTechLevelWanted='..iTechLevelWanted) end
        HaveActionToAssign(refActionBuildShield, iTechLevelWanted, iBPWanted, oUnitToShield)
    end

    --AA including SAMs
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Do we want more airaa? iNearbyEnemyAirToGroundThreat='..iNearbyEnemyAirToGroundThreat..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]) end
    if iNearbyEnemyAirToGroundThreat > 0 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= math.max(tLZTeamData[M28Map.subrefLZThreatAllyGroundAA], 800) then
        if not(M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam]) or M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround] >= 200 or tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] == 0 then
            local iGroundAAThreatWanted
            if M28Team.tAirSubteamData[ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].M28AirSubteam][M28Team.refbHaveAirControl] then
                iGroundAAThreatWanted = M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.4 + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.15
            elseif M28Team.tTeamData[iTeam][M28Team.refbFarBehindOnAir] then
                iGroundAAThreatWanted = M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.8 + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.3
                if M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] >= 2000 then iGroundAAThreatWanted = iGroundAAThreatWanted + math.min(M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.15, M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat]) end
            else
                iGroundAAThreatWanted = M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.6 + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.225
                if M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] >= 2000 then iGroundAAThreatWanted = iGroundAAThreatWanted + math.min(M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.1, M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat]) end
            end
            if not(M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam]) or iNearbyEnemyAirToGroundThreat >= 800 then
                iGroundAAThreatWanted = math.max(iNearbyEnemyAirToGroundThreat * 2, iNearbyEnemyAirToGroundThreat + iGroundAAThreatWanted)
            end
            --Cap Ground AA at equiv of 3 T2 flak if no enemy air to ground threat in this zone, and we arent at T3
            if iGroundAAThreatWanted >= 2400 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) then
                if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 then
                    iGroundAAThreatWanted = 2400
                else
                    --At T3 - reduce the amount of fixed AA wanted slightly for very high threat values (i.e. >= 10 SAM equivalent)
                    if iGroundAAThreatWanted >= 16000 then
                        if iGroundAAThreatWanted >= 30000 then
                            iGroundAAThreatWanted = 16000 + 14000 * 0.75 + (iGroundAAThreatWanted - 30000) * 0.5
                        else
                            iGroundAAThreatWanted = 16000 + (iGroundAAThreatWanted - 16000) * 0.75
                        end
                    end

                    --Campaign maps - further reduce amount earlier into the game
                    if M28Map.bIsCampaignMap and iGroundAAThreatWanted >= 8000 and (bHaveLowMass or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.4) and (tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] >= math.max(20000, 1000 * M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) or GetGameTimeSeconds() <= 15 * 60) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= math.max(20, tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] / 1000)) then
                        iGroundAAThreatWanted = math.min((iGroundAAThreatWanted - 8000) * 0.25 + 8000, 12000)
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': GroundAA='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]..'; iGroundAAThreatWanted='..iGroundAAThreatWanted..'; Friendly factory tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end
            --= M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]
            if tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < iGroundAAThreatWanted or (tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] <= 1600 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 or (tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < 1200 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2) or tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < 120)) then
                --Do we already have fixed AA in this LZ?
                local iAACategory = M28UnitInfo.refCategoryStructureAA
                if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then iAACategory = iAACategory * categories.TECH3 end
                local tExistingFixedAA = EntityCategoryFilterDown(iAACategory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of fixed AA empty='..tostring(M28Utilities.IsTableEmpty(tExistingFixedAA))..'; Ally groundAA threat='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]..'; Highest enemy air tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech]..'; Enemy air to ground threat='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Enemy AirAA threat='..tLZTeamData[M28Map.refiEnemyAirAAThreat]..'; iGroundAAThreatWanted='..iGroundAAThreatWanted..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end
                if M28Utilities.IsTableEmpty(tExistingFixedAA) or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < math.max(1500 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech], tLZTeamData[M28Map.refiEnemyAirToGroundThreat] * 3 + tLZTeamData[M28Map.refiEnemyAirAAThreat], iGroundAAThreatWanted)) or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 and tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < math.max(425 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech], tLZTeamData[M28Map.refiEnemyAirToGroundThreat] * 3 + tLZTeamData[M28Map.refiEnemyAirAAThreat] * 0.5, iGroundAAThreatWanted)) then
                    --Cap amount of SAMs if we dont have all T3 mexes in the zone and have low mass
                    if bDebugMessages == true then LOG(sFunctionRef..': bHaveLowMass='..tostring(bHaveLowMass)..'; Is table of enemy air units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]))..'; Ally groundAA threat='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]..'; Mex count by tech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; Team gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Active brain count='..M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) end
                    if not(bHaveLowMass and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) and tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] >= 6000 and (tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][1]) > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] > 15 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                        iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
                        if iNearbyEnemyAirToGroundThreat > 0 then iBPWanted = iBPWanted * 2 end
                        if not(bHaveLowPower) then
                            if not(bHaveLowMass) then iBPWanted = iBPWanted * 4
                            else iBPWanted = iBPWanted * 2
                            end
                        end
                        HaveActionToAssign(refActionBuildAA, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted)
                        if bDebugMessages == true then LOG(sFunctionRef..': WIll build more AA, iBPWanted='..iBPWanted) end
                    end
                end
            end
        end
    end

    --Reclaim specific units
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if have units to reclaim, is table empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoUnitsToReclaim]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoUnitsToReclaim]) == false then
        local bObjectiveToReclaim = false
        if M28Map.bIsCampaignMap then
            for iUnit, oUnit in tLZTeamData[M28Map.subreftoUnitsToReclaim] do
                if oUnit[M28UnitInfo.refbIsReclaimTarget] then bObjectiveToReclaim = true break end
            end
        end

        --Dont reclaim power if we have <100% stored or low power
        local bDontReclaimYet = false
        if not(bObjectiveToReclaim) and ((bHaveLowPower) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= 0.98) then
            if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryPower, tLZTeamData[M28Map.subreftoUnitsToReclaim])) == false then
                bDontReclaimYet = true
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': About to reclaim a unit but still stop if have low power and we have pgens in the list of units to reclaim, bHaveLowPower='..tostring(bHaveLowPower)..'; Average% stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored]) end
        if not(bDontReclaimYet) then
            if bDebugMessages == true then LOG(sFunctionRef..': Want to try and reclaim, bObjectiveToReclaim='..tostring(bObjectiveToReclaim)) end
            HaveActionToAssign(refActionReclaimFriendlyUnit, 1, math.min(2 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]], math.max(10, 10 * table.getn(tLZTeamData[M28Map.subreftoUnitsToReclaim]))), nil, not(bObjectiveToReclaim))
        end
    end

    --Multiple mex upgrades (core zone), or a single upgrade but are behind enemy on eco - want to assist as a higher priority
    iCurPriority = iCurPriority + 1
    if (tLZTeamData[M28Map.subrefiActiveMexUpgrades] or 0) > 0 and ((tLZTeamData[M28Map.subrefiActiveMexUpgrades] or 0) >= 2 or M28Conditions.GetHighestOtherTeamT3MexCount(iTeam) > M28Team.tTeamData[iTeam][M28Team.refiMexCountByTech][3] or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= math.max(1, 0.25 * M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.15)) and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) then
        iBPWanted = 10
        if not(bHaveLowPower) then
            iBPWanted = (tLZTeamData[M28Map.subrefiActiveMexUpgrades] or 0) * 15
        end
        if (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.3 or (not(bHaveLowMass) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= math.max(1, 0.25 * M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass])))) and bWantMoreFactories then
            iBPWanted = iBPWanted * 2
            if bHaveLowPower and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or -10) <= 5 then
                HaveActionToAssign(refActionBuildPower, iMinTechLevelForPower, iBPWanted)
            else
                if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) then
                    HaveActionToAssign(refActionBuildAirFactory, 1, iBPWanted)
                else
                    HaveActionToAssign(refActionBuildLandFactory, 1, iBPWanted)
                end
            end
        else
            HaveActionToAssign(refActionAssistUpgrade, 1, iBPWanted)
        end
    end


    --More power
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': More power builder, bHaveLowMass='..tostring(bHaveLowMass)..'; bWantMorePower='..tostring(bWantMorePower)..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Highest friendly factory tech='..(M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 'nil')) end
    if not(bHaveLowMass) and bWantMorePower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 11 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or 0) > 0 and not(bSaveMassForMML) then
        iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 5
        if bDebugMessages == true then LOG(sFunctionRef..': Want more power, iCurPriority='..iCurPriority..'; iBPWanted='..iBPWanted) end
        HaveActionToAssign(refActionBuildPower, iMinTechLevelForPower, iBPWanted)
    end

    --Assist ACU going for teleporter
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of upgrading ACUs on team empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingACUs]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingACUs]) == false then
        local oACUUpgradingForTeleportInThisZone
        local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua') --done here incase having it above causes issues (havent actually tested, but m28acu refers to parts of m28engineer)
        if M28Conditions.IsTableOfUnitsStillValid(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingACUs], false) then
            for iACU, oACU in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingACUs] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering upgrading ACU oACU='..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' owned by brain '..oACU:GetAIBrain().Nickname..'; Unit state='..M28UnitInfo.GetUnitState(oACU)..'; Planning to get teleport='..tostring(oACU[M28ACU.refbPlanningToGetTeleport])) end
                if oACU[M28ACU.refbPlanningToGetTeleport] and oACU:IsUnitState('Upgrading') then
                    --Is ACU in this zone or nearby?

                    local iACUPlateauOrZero, iACULandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oACU:GetPosition())
                    if bDebugMessages == true then LOG(sFunctionRef..': Have ACU wanting to get teleport whose unit state is upgrading, ACU brain='..oACU:GetAIBrain().Nickname..'; iACUPlateauOrZero='..(iACUPlateauOrZero or 'nil')..'; iACULandOrWaterZone='..(iACULandOrWaterZone or 'nil')..'; This plateau='..iPlateau..'; This LZ='..iLandZone..'; Dist from ACU to this zone midpoint='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oACU:GetPosition())) end
                    if iACUPlateauOrZero == iPlateau and iACULandOrWaterZone == iLandZone then --or M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], oACU:GetPosition()) <= 100) then
                        oACUUpgradingForTeleportInThisZone = oACU
                        break
                    end
                end
            end
        end

        if oACUUpgradingForTeleportInThisZone then
            if bHaveLowPower then iBPWanted = 25
            else
                iBPWanted = 60
            end
            if not(bWantMorePower) then iBPWanted = 100 end
            if bDebugMessages == true then LOG(sFunctionRef..': Have ACU trying to get teleporter upgrade, iBPWanted='..iBPWanted) end
            HaveActionToAssign(refActionAssistUpgrade, 1, iBPWanted, oACUUpgradingForTeleportInThisZone)
        end
    end

    --Shield assistance
    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPForShieldAssistance(tLZTeamData, iTeam)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionAssistShield, 1, iBPWanted)
    end

    --Higher priority mass storage if we have T3 in the LZ and available storage locations
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 11 and (tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][2] >= 4) and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 then
        iBPWanted = GetBPToAssignToMassStorage(iPlateau, iLandZone, iTeam, tLZData, tLZTeamData, true, bHaveLowMass, bWantMorePower)
        if bSaveMassForMML then iBPWanted = iBPWanted * 0.5 end
        if iBPWanted > 0 then
            HaveActionToAssign(refActionBuildMassStorage, 1, iBPWanted)
        end
    end

    --Factory builder ahead of assisting upgrades for if we have low mass stored but lots of mexes upgrading in this LZ, and are at T3
    iCurPriority = iCurPriority + 1
    if iActiveMexUpgrades >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] > 0.01 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0 and table.getn(tLZTeamData[M28Map.subreftoActiveUpgrades]) >= 3 then
        if bHaveLowPower then iBPWanted = tiBPByTech[3] * 3
        else iBPWanted = tiBPByTech[3] * 5
        end
        local bWantAirNotLand = M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)
        local iFactoryAction
        if bWantAirNotLand then iFactoryAction = refActionBuildAirFactory
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Want to build land factory not air factory3') end
            iFactoryAction = refActionBuildLandFactory
        end
        if bHaveLowPower and bWantAirNotLand then iBPWanted = iBPWanted * 0.5 end

        HaveActionToAssign(iFactoryAction, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted, nil)
    end

    --Preemptive SMD
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; About to consider if want SMD, is table of enemy nukes empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]))..'; tLZTeamData[M28Map.subrefLZSValue]='..tLZTeamData[M28Map.subrefLZSValue]..'; Lifetime T3 nonstructure count='..M28Conditions.GetTeamLifetimeBuildCount(iTeam, categories.TECH3 - categories.STRUCTURE)..'; Team mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; T3 mex count='..tLZTeamData[M28Map.subrefMexCountByTech][3]..'; Total LZ mex count='..tLZData[M28Map.subrefLZMexCount]..'; Have low mass='..tostring(bHaveLowMass)..'; M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]='..M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]..'; Condition 1 is met='..tostring((tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and (not(bHaveLowMass) or tLZTeamData[M28Map.subrefMexCountByTech][3] > 0) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 30 + 20 * (1-M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])))..'; Condition 2 is met='..tostring((tLZData[M28Map.subrefLZMexCount] >= 2 and tLZTeamData[M28Map.subrefMexCountByTech][3] >= math.min(4, tLZData[M28Map.subrefLZMexCount]) and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and (tLZTeamData[M28Map.subrefMexCountByTech][2] == 0 or tLZTeamData[M28Map.subrefMexCountByTech][3] >= 5)))..'; Condition 3 is met='..tostring((tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1 and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 30))) end
    if tLZTeamData[M28Map.subrefLZSValue] >= 20000 and not(bHaveLowPower) and (tLZTeamData[M28Map.subrefLZSValue] >= 30000 or not(bHaveLowMass)) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and not(bSaveMassForMML) then
        --Only build SMD if we have built a lot of T3 units or have built experimentals or have very high eco
        if tLZTeamData[M28Map.subrefLZSValue] >= 45000 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 30 or M28Conditions.GetTeamLifetimeBuildCount(iTeam, categories.TECH3 - categories.STRUCTURE) >= 20 then
            --Also require several T3 mexes unless we have very high mass
            if (tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and (not(bHaveLowMass) or tLZTeamData[M28Map.subrefMexCountByTech][3] > 0) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 28 + 20 * (M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] - 1))
                    or (tLZData[M28Map.subrefLZMexCount] >= 2 and tLZTeamData[M28Map.subrefMexCountByTech][3] >= math.min(4, tLZData[M28Map.subrefLZMexCount]) and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and (tLZTeamData[M28Map.subrefMexCountByTech][2] == 0 or tLZTeamData[M28Map.subrefMexCountByTech][3] >= 5))
                    or (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1 and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 30) then
                local iExperimentalLifetimeCount = M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryExperimentalLevel)
                if bDebugMessages == true then LOG(sFunctionRef..': we have high enough mass to consider getting a preemptive SMD, iExperimentalLifetimeCount='..iExperimentalLifetimeCount) end
                if iExperimentalLifetimeCount > 1 + math.min(3, M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 30 or (not(bHaveLowMass) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 30)) or M28Map.bIsCampaignMap then
                    local iSMDUnderConstructionInThisZone = M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategorySMD, true)
                    local bStillGetSMD = true
                    if iSMDUnderConstructionInThisZone == 0 then
                        local iSMDUnderConstructionInOtherZones = M28Conditions.GetNumberOfUnderConstructionUnitsOfCategoryInOtherZones(tLZTeamData, iTeam, M28UnitInfo.refCategorySMD)
                        if iSMDUnderConstructionInOtherZones > 0 then bStillGetSMD = false end
                    end
                    if bStillGetSMD then
                        local bAssistSMD = false
                        local oSMDToShield, oShieldToAssist
                        iBPWanted, bAssistSMD, oSMDToShield, oShieldToAssist = GetBPToAssignToSMD(iPlateau, iLandZone, iTeam, tLZTeamData, false, bHaveLowMass, bWantMorePower)
                        if iBPWanted > 0 and not(bAssistSMD) then --Since htis is precautionary not worried about rushing the SMD or shielding as a high priority
                            if bDebugMessages == true then LOG(sFunctionRef..': Will assign BP to build an SMD preemptively, iBPWanted='..iBPWanted) end
                            HaveActionToAssign(refActionBuildSMD, 3, iBPWanted)
                        elseif oShieldToAssist then
                            HaveActionToAssign(refActionRepairUnit, 1, iBPWanted, oShieldToAssist)
                        end
                    end
                end
            end
        end
    end

    --Build multiple land factories if have lots of mass stored (higher priority)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want high priority second factory builder, bHaveLowMass='..tostring(bHaveLowMass)..'; bHaveLowPower='..tostring(bHaveLowPower)..'; bWantMoreFactories='..tostring(bWantMoreFactories)..'; iActiveMexUpgrades='..iActiveMexUpgrades..'; Mass % stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; Friendly highest land fac tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]..'; Team net mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) end
    if not(bHaveLowMass) and not(bHaveLowPower) and bWantMoreFactories and not(bSaveMassForMML) and iFactoriesInLZ >= 4 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 11 and (iActiveMexUpgrades >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.25) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3 or iActiveMexUpgrades >= 4) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 1 or iActiveMexUpgrades >= 4) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.45 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= math.min(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 0.25, 8)) then

        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.55 then iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]] * 4
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0 then iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]] * 2
        else iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]]
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Have lots of mass so want to build more than one factory at once as high priority, iBPWanted='..iBPWanted) end
        if not(M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)) then
            HaveActionToAssign(refActionBuildSecondLandFactory, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech], iBPWanted)
        end
    end

    --Second mass storage if we have T3 mex in this LZ and 5+ mass storage locations
    iCurPriority = iCurPriority + 1
    if not(bSaveMassForMML) and (tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][2] >= 4) and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 then
        iBPWanted = GetBPToAssignToMassStorage(iPlateau, iLandZone, iTeam, tLZData, tLZTeamData, true, bHaveLowMass, bWantMorePower)
        if iBPWanted > 0 then
            if table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZOrWZMassStorageLocationsAvailable]) >= 5 then
                HaveActionToAssign(refActionBuildSecondMassStorage, 1, iBPWanted)
            end
        end
    end


    --Assist upgrades:
    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPToAssignToAssistUpgrade(tLZTeamData, iTeam, true, bHaveLowMass, bHaveLowPower, bWantMorePower)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionAssistUpgrade, 1, iBPWanted)
    end

    --Build mass storage if we have T2+ mexes
    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPToAssignToMassStorage(iPlateau, iLandZone, iTeam, tLZData, tLZTeamData, true, bHaveLowMass, bWantMorePower)
    if iBPWanted > 0 then
        if bSaveMassForMML then iBPWanted = iBPWanted * 0.5 end
        HaveActionToAssign(refActionBuildMassStorage, 1, iBPWanted)
    end

    --Lower priority core WZ wanting engineers:
    iCurPriority = iCurPriority + 1
    if iCoreWZWantingSupportAsLowerPriority then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if iHighestTechEngiAvailable > 0 then
            HaveActionToAssign(refActionMoveToWaterZone, 1, tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]], iCoreWZWantingSupportAsLowerPriority, true)
        end
    end


    --Lower priority mass reclaim
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to get more reclaim, mass%='..(M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] or 0)..'; Total mass reclaim='..tLZData[M28Map.subrefTotalMassReclaim]..'; Signif mass reclaim='..(tLZData[M28Map.subrefTotalSignificantMassReclaim] or 0)) end
    if (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.35 and tLZData[M28Map.subrefTotalMassReclaim] >= 5) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.5 and tLZData[M28Map.subrefTotalSignificantMassReclaim] >= 150) then
        if bDebugMessages == true then LOG(sFunctionRef..': Lower priority reclaim, Total mass in Plateau '..iPlateau..' LZ '..iLandZone..'='..tLZData[M28Map.subrefTotalMassReclaim]) end
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.35 then
            iBPWanted = math.min(100, math.max(5, tLZData[M28Map.subrefTotalMassReclaim] / 10))
            if tLZData[M28Map.subrefTotalSignificantMassReclaim] >= 3000 then iBPWanted = math.min(200, math.max(iBPWanted, tLZData[M28Map.subrefTotalSignificantMassReclaim] / 30)) end
        else
            iBPWanted = math.min(tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2, tLZData[M28Map.subrefTotalSignificantMassReclaim] / 20)
        end
        HaveActionToAssign(refActionReclaimArea, 1, iBPWanted, {false, nil})
    end

    --Radar (not high priority)
    iCurPriority = iCurPriority + 1
    if not(bHaveLowPower) and not (M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmni]) then
        --T1 radar
        if tLZTeamData[M28Map.refiRadarCoverage] <= 50 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 25 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2.5 then
            --Check we dont already have t1 radar in the land zone
            if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryT1Radar, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) then
                iBPWanted = 5
                if not(bHaveLowMass) then iBPWanted = 15 end
                HaveActionToAssign(refActionBuildT1Radar, 1, iBPWanted)
            end
        end

        --T2 radar
        iCurPriority = iCurPriority + 1
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if want T2 radar, tLZTeamData[M28Map.refiRadarCoverage]='..tLZTeamData[M28Map.refiRadarCoverage]..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]) end
        if tLZTeamData[M28Map.refiRadarCoverage] <= 130 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 40 + 60 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 3 + 2 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
            if not(bSaveMassForMML) or tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1 then
                --Check we dont already have t2 radar in the land zone
                if not(tLZTeamData[M28Map.refbBaseInSafePosition]) or tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] or M28Map.bIsCampaignMap or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then
                    if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryT2Radar, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) then
                        iBPWanted = 20
                        if not(bHaveLowMass) then iBPWanted = 60 end
                        HaveActionToAssign(refActionBuildT2Radar, 2, iBPWanted)
                    end
                end
            end
        end

        --T3 radar
        iCurPriority = iCurPriority + 1
        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to build T3 radar, tLZTeamData[M28Map.refiRadarCoverage]='..tLZTeamData[M28Map.refiRadarCoverage]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Closest enemy base dist to midpoint='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase])..'; tLZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
        if not(bSaveMassForMML) and tLZTeamData[M28Map.refiRadarCoverage] <= 300 and ((M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 500 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 200) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 350 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 100 and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryMobileLand * categories.TECH3 - M28UnitInfo.refCategoryEngineer) >= 40) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 and (M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase]) > tLZTeamData[M28Map.refiRadarCoverage] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20) then
            --Require T3 mexes before building T3 radar
            if tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 or (tLZTeamData[M28Map.subrefMexCountByTech][3] == 1 and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][1] == 0) then
                iBPWanted = 30
                if not(bHaveLowMass) then iBPWanted = 100 end
                if bDebugMessages == true then LOG(sFunctionRef..': Will build T3 radar, iBPWanted='..iBPWanted..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]) end
                HaveActionToAssign(refActionBuildT3Radar, 3, iBPWanted)
            end
        end
    end

    --Air fac and second air fac ahead of land experimental if enemy has significant air to ground threat, for larger maps
    iCurPriority = iCurPriority + 1
    if M28Map.iMapSize > 512 and (M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeAir] or 0) < 8 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 + (M28Team.tTeamData[iTeam][M28Team.subrefiTotalFactoryCountByType][M28Factory.refiFactoryTypeAir] or 0) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 3 and M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone) then
        if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) then
            iBPWanted = 40
            if not(bHaveLowMass) then iBPWanted = 80 end
            HaveActionToAssign(refActionBuildAirFactory, 3, iBPWanted)
            if not(bHaveLowMass) and not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 10000 and not(M28Conditions.TeamHasAirControl(iTeam)) then
                HaveActionToAssign(refActionBuildSecondAirFactory, 3, iBPWanted)
            end
        end
    end

    --Land experimental if lots of mass or have built lots of T3 units, or enemy has experimental and we dont
    iCurPriority = iCurPriority + 1
    local bExperimentalsBuiltInThisLZ, iExperimentalsBuiltInOtherLZ = GetExperimentalsBeingBuiltInThisAndOtherLandZones(iTeam, iPlateau, iLandZone)
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; iCurPriority='..iCurPriority..'; bExperimentalsBuiltInThisLZ='..tostring(bExperimentalsBuiltInThisLZ)..'; iExperimentalsBuiltInOtherLZ='..iExperimentalsBuiltInOtherLZ..'; M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; M28Team.tTeamData[iTeam][M28Team.refbBuiltLotsOfT3Combat]='..tostring(M28Team.tTeamData[iTeam][M28Team.refbBuiltLotsOfT3Combat] or false)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and (
            (bExperimentalsBuiltInThisLZ or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] > 7) and
                    --Are we already building an experimental here (in which case finish), or ave we built lots of T3 units, or does enemy have a land experimental and we arent building one anywhere?
                    ((bExperimentalsBuiltInThisLZ or (iExperimentalsBuiltInOtherLZ == 0 and (M28Team.tTeamData[iTeam][M28Team.refbBuiltLotsOfT3Combat] or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false)))
                            --Alternatively do we have lots of mass stored?
                            or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 8000 + 8000 * iExperimentalsBuiltInOtherLZ or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] > 16 + iExperimentalsBuiltInOtherLZ * 30)
                            --Alternatively have we not built an experimental before but our team has high mass income and at least 1 T3 mex in this zone?
                            or (iExperimentalsBuiltInOtherLZ == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 400 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 14 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1)
                    )
                    or GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] or -1000) <= 60
                    or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 400) then
        iBPWanted = 100 --No point trying to build an experimental with less build power
        if not(bHaveLowPower) then
            iBPWanted = iBPWanted * 1.5
            --BP wanted: e.g. monkeylord will cost 0.07 mass per tick for 1 BP; so if want to spend approx 50% of mass on the experimental, then for every 1 mass per tick generated, would want roughly 7 build power
            if not(bHaveLowMass) then iBPWanted = math.max(iBPWanted * 1.5, (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] - iExperimentalsBuiltInOtherLZ * 25 - 10) * 5) end
            if bDebugMessages == true then LOG(sFunctionRef..': iExperimentalsBuiltInOtherLZ='..iExperimentalsBuiltInOtherLZ..'; Is table of enemy land exp empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]))..'; Lifetime exp level build count='..M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryExperimentalLevel)) end
            if iExperimentalsBuiltInOtherLZ == 0 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryExperimentalLevel) < math.max(2, M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] * 0.75) then
                local iCapOnIncrease = 500
                if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] then iCapOnIncrease = 250 end
                iBPWanted = math.max(iBPWanted, math.min(iCapOnIncrease, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 6))
                if bDebugMessages == true then LOG(sFunctionRef..': IBPWanted after increasing if first experimental being built and enemy team has one='..iBPWanted) end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Will get experimental if have enough T3 mexes in this zone, tLZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
        if tLZTeamData[M28Map.subrefMexCountByTech][1] + tLZTeamData[M28Map.subrefMexCountByTech][2] == 0 or ((M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] < M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or (not(bHaveLowMass) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.4 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 25000))) and (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 4 or (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 and tLZTeamData[M28Map.subrefMexCountByTech][2] < 2) or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false)) then
            --Want to only build experimental if have mostly T3 mexes in this zone
            if not(bSaveMassForMML) or (aiBrain.GetFactionIndex and not(aiBrain:GetFactionIndex() == M28UnitInfo.refFactionUEF) and tLZTeamData[M28Map.subrefMexCountByTech][3] >= math.min(2, tLZData[M28Map.subrefLZMexCount])) then
                HaveActionToAssign(refActionBuildExperimental, 3, iBPWanted)

                --Also want more BP than what we have regardless if have lots of mass stored and experimental is being built
                if bDebugMessages == true then LOG(sFunctionRef..': Have just had action to build experimental with iBPWanted='..iBPWanted..'; If lots of mass stored will increase BP assigned to experimental, bExperimentalsBuiltInThisLZ='..tostring(bExperimentalsBuiltInThisLZ)..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; bHaveLowPower='..tostring(bHaveLowPower)) end
                if bExperimentalsBuiltInThisLZ and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] > 0.6 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 20000) and not(bHaveLowPower) then
                    --Want 60 extra BP vs what we have already assigned
                    iBPWanted = 60
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] > 0.8 or not(bWantMorePower) then iBPWanted = 120 end
                    HaveActionToAssign(refActionBuildExperimental, 3, iBPWanted, nil, false, true)
                end
            end
        end

    end

    --Build multiple land factories if have lots of mass stored (lower priority)
    iCurPriority = iCurPriority + 1
    if not(bHaveLowMass) and not(bHaveLowPower) and bWantMoreFactories and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.5 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 then
        if bDebugMessages == true then LOG(sFunctionRef..': Have lots of mass so want to build more than one factory at once (lower priority)') end

        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.7 then iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 7
        else iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 5
        end
        if not(M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)) then --factors in things like if we are on the same plateau
            HaveActionToAssign(refActionBuildSecondLandFactory, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech], tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 5)
        end
    end



    --Lower priority land zones wanting engineers:
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS) Other non adjacent LZ on this plateau that wants engineers (low priority) - prioritise those nearest this zone
    iCurPriority = iCurPriority + 1
    iBPAlreadyTraveling = 0
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then
        if M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
            for iEngi, oEngi in toAssignedEngineers do
                if oEngi[refiAssignedAction] == refActionMoveToLandZone then
                    iBPAlreadyTraveling = iBPAlreadyTraveling + oEngi:GetBlueprint().Economy.BuildRate
                end
            end
        end

        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
            for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                if iBPAlreadyTraveling > 0 or not(tLZWantingBPConsidered[iAdjLZ]) then
                    tLZWantingBPConsidered[iAdjLZ] = true
                    local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, iAdjLZ, iPathingRef, iHighestTechEngiAvailable, false)
                    if tiBPByTechWanted then
                        --Is it either a minor zone, or a core zone that either wants lots of BP or doesnt have any engineers traveling to it?
                        for iTech = 1, iHighestTechEngiAvailable, 1 do
                            if tiBPByTechWanted[iTech] > 0 then
                                iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                iBPWanted = iBPAlreadyTraveling + 5
                                if bDebugMessages == true then LOG(sFunctionRef..': Will try and assign an engineer to go to iAdjLZ='..iAdjLZ..'; BP wanted='..iBPWanted..'; iTech='..iTech..'; iPrevEngisAvailable='..iPrevEngisAvailable) end
                                HaveActionToAssign(refActionMoveToLandZone, iTech, iBPWanted, iAdjLZ, true)
                                if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                    iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                    iBPAlreadyTraveling = iBPAlreadyTraveling + tiBPByTech[iTech]
                                end

                                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable after this='..iHighestTechEngiAvailable) end
                                if iHighestTechEngiAvailable == 0 then break end
                            end
                        end
                    end
                end
                if iHighestTechEngiAvailable == 0 then break end
            end
        end
    end

    --Islands wanting engineers (provided there are no enemy naval units in an adjacent naval zone)
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Core LZ considering engis for islands, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Time='..GetGameTimeSeconds()) end
    if iHighestTechEngiAvailable > 0 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of pathing to other islands empty='..tostring(tLZData[M28Map.subrefLZPathingToOtherIslands])) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
            local iDistanceThreshold = math.max(125, M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) * 0.6)
            if bDebugMessages == true then LOG(sFunctionRef..': iDistanceThreshold='..iDistanceThreshold) end

            for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..'; Travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; tPathingData[M28Map.subrefIslandClosestLZRef]='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; Are there enemies in this or adjacnet LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                if tPathingData[M28Map.subrefIslandTravelDist] > iDistanceThreshold then break
                else
                    --Are there enemies in the target LZ?
                    if tPathingData[M28Map.subrefIslandClosestLZRef] then
                        local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]]
                        if bDebugMessages == true then LOG(sFunctionRef..': Are there enemies in the land zone or adjacent='..tostring(tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Is the midpoint in the playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]))) end
                        if not(tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                            --Can we reach the island?
                            if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]) then

                                local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, tPathingData[M28Map.subrefIslandClosestLZRef], iEntry, iHighestTechEngiAvailable, false, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                                if tiBPByTechWanted then
                                    --Is it either a minor zone, or a core zone that either wants lots of BP or doesnt have any engineers traveling to it?
                                    for iTech = 1, iHighestTechEngiAvailable, 1 do
                                        if tiBPByTechWanted[iTech] > 0 then
                                            iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                            iBPWanted = iBPAlreadyTraveling + 5
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will try and assign an engineer to go to tPathingData[M28Map.subrefIslandClosestLZRef]='..tPathingData[M28Map.subrefIslandClosestLZRef]..'; BP wanted='..iBPWanted..'; iTech='..iTech..'; iPrevEngisAvailable='..iPrevEngisAvailable) end
                                            HaveActionToAssign(refActionMoveToLandZone, iTech, iBPWanted, tPathingData[M28Map.subrefIslandClosestLZRef], true)
                                            if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                                iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                                iBPAlreadyTraveling = iBPAlreadyTraveling + tiBPByTech[iTech]
                                            end

                                            iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                            if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable after this='..iHighestTechEngiAvailable) end
                                            if iHighestTechEngiAvailable == 0 then break end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    --Quantum gateway for high AiX modifier and campaign, once we are at T3 mexes for the LZ
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to build quantum gateway, MexCountByTech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; bHaveLowPower='..tostring(bHaveLowPower)..'; mass storage locations empty?='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZOrWZMassStorageLocationsAvailable]))..'; mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]) end
    if not(bHaveLowPower) and not(bSaveMassForMML) and (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 or (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 11) or (M28Map.bIsCampaignMap and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 13))
            and (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 6 or (tLZTeamData[M28Map.subrefMexCountByTech][2] == 0 and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0))
            and (M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZOrWZMassStorageLocationsAvailable]) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.5 or (M28Map.bIsCampaignMap and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 14))
            and (M28Map.bIsCampaignMap or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] > 0 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 30) then
        --Are we in campaign (where ecoing more important) or AiX 1.2+?
        local iHighestCheatModifier = 1
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                if oBrain.CheatEnabled then
                    iHighestCheatModifier = tonumber(ScenarioInfo.Options.CheatMult or 1.5)
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bIsCampaignMap='..tostring(M28Map.bIsCampaignMap)..'; iHighestCheatModifier='..iHighestCheatModifier) end
        if M28Map.bIsCampaignMap or iHighestCheatModifier >= 1.2 or (M28Map.iMapSize >= 1024 and not(bHaveLowMass) and ((tLZTeamData[M28Map.subrefMexCountByTech][3] >= tLZData[M28Map.subrefLZMexCount] or (M28Overseer.bNoRushActive and tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 and tLZTeamData[M28Map.subrefMexCountByTech][2] == 0 and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and M28Conditions.NoRushPreventingHydroOrMex(tLZData, true))))) then
            if M28Overseer.bUnitRestrictionsArePresent or (tLZTeamData[M28Map.refiZoneConstructedExperimentalCount] or 0) > 0 or M28Overseer.bNoRushActive then
                iBPWanted = 20
                if not(bHaveLowMass) then iBPWanted = 80 end
                if bDebugMessages == true then LOG(sFunctionRef..': Will try and build a quantum gateway') end
                --Do we already have a quantum gateway in this land zone?
                local iCurQuantumGateways = 0
                local tQuantumGateways = EntityCategoryFilterDown(M28UnitInfo.refCategoryQuantumGateway, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if M28Utilities.IsTableEmpty( tQuantumGateways) == false then
                    for iUnit, oUnit in tQuantumGateways do
                        if oUnit:GetFractionComplete() >= 1 then
                            iCurQuantumGateways = iCurQuantumGateways + 1
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iCurQuantumGateways='..iCurQuantumGateways) end
                --Get 1 quantumn gateway (or 2+ if we have 1.5+ AiX modifier)
                if iCurQuantumGateways == 0 or (iCurQuantumGateways < 3 and M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier] >= 1.4 and iCurQuantumGateways < 0.4 + M28Team.tTeamData[iTeam][M28Team.refiHighestBrainResourceMultiplier]) then
                    HaveActionToAssign(refActionBuildQuantumGateway, 3, iBPWanted)
                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and assign '..iBPWanted..' to building a quantum gateway') end
                end
            end
        end
    end

    --Second experimental builder (for very high mass scenarios) assuming we have lots of T3 mexes
    iCurPriority = iCurPriority + 1
    if not(bHaveLowMass) and not(bHaveLowPower) and not(bSaveMassForMML) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 8 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 5000 then
        if tLZTeamData[M28Map.subrefMexCountByTech][1] + tLZTeamData[M28Map.subrefMexCountByTech][2] == 0 or tLZTeamData[M28Map.subrefMexCountByTech][3] >= 4 or (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 and tLZTeamData[M28Map.subrefMexCountByTech][2] < 2) or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
            --Want 30 extra BP vs what we have already assigned to both normal and second experimental builders
            iBPWanted = 30
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] > 0.8 or not(bWantMorePower) then iBPWanted = iBPWanted * 2 end
            --HaveActionToAssign(iActionToAssign,           iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting)
            HaveActionToAssign(refActionBuildExperimental,   3,                       iBPWanted,      nil,                false, true)
            if bDebugMessages == true then LOG(sFunctionRef..': Will flag that we want a second experimental to be built, additional iBPWanted='..iBPWanted) end
            HaveActionToAssign(refActionBuildSecondExperimental, 3,                     iBPWanted,      nil,                false,                      true)
        end
    end

    --Assist upgrade even if resources aren't great
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoActiveUpgrades]) == false and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] >= 0.95 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 20 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > 0 then
        HaveActionToAssign(refActionAssistUpgrade, 1, 10, false, false)
    end


    --Units to capture
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]) == false then
        --Refresh the list
        local iCaptureCount = table.getn(tLZData[M28Map.subreftoUnitsToCapture])
        for iCurCount = iCaptureCount, 1, -1 do
            if not(M28UnitInfo.IsUnitValid(tLZData[M28Map.subreftoUnitsToCapture][iCurCount])) then
                table.remove(tLZData[M28Map.subreftoUnitsToCapture], iCurCount)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Have units to capture for zone '..iLandZone..'; after freshing them is table empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]))) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]) == false then
            --Dont capture if are a hostile AI due to the risk we capture a campaign objective and progress the map
            if not(ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].HostileCampaignAI) then
                local oUnitToCapture
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 75 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                    local tPotentialCapture = EntityCategoryFilterDown(categories.ALLUNITS - M28UnitInfo.refCategoryT3Power, tLZData[M28Map.subreftoUnitsToCapture])
                    if M28Utilities.IsTableEmpty(tPotentialCapture) == false then
                        oUnitToCapture = M28Utilities.GetNearestUnit(tPotentialCapture, tLZData[M28Map.subrefMidpoint])
                    end
                else
                    oUnitToCapture = M28Utilities.GetNearestUnit(tLZData[M28Map.subreftoUnitsToCapture], tLZData[M28Map.subrefMidpoint])
                end
                if oUnitToCapture then
                    if bDebugMessages == true then LOG(sFunctionRef..': Unit to cpature='..oUnitToCapture.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToCapture)) end
                    iBPWanted = GetCaptureBPWanted(oUnitToCapture, bHaveLowPower, iTeam, tLZTeamData[M28Map.subrefLZbCoreBase])
                    HaveActionToAssign(refActionCaptureUnit, 1, iBPWanted, oUnitToCapture)
                end
            end
        end
    end

    --Units to repair
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToRepair]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Have units to repair for zone '..iLandZone..' is table empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToRepair]))) end

        if M28Conditions.IsTableOfUnitsStillValid(tLZData[M28Map.subreftoUnitsToRepair], true) then
            local oUnitToTarget = M28Utilities.GetNearestUnit(tLZData[M28Map.subreftoUnitsToRepair], tLZData[M28Map.subrefMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': Unit to repair='..oUnitToTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToTarget)) end
            HaveActionToAssign(refActionRepairUnit, 1, 5, oUnitToTarget)
        end

    end

    --Game ender builder (in addition to normal experimental builders) - intended for extreme scenarios where overflowing lots of mass, or where are in campaign, at unit cap and have decent eco
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to build gameender, bHaveLowPower='..tostring(bHaveLowPower)..'; M28Team.tTeamData[iTeam][M28Team.refiLowestUnitCapAdjustmentLevel]='..(M28Team.tTeamData[iTeam][M28Team.refiLowestUnitCapAdjustmentLevel] or 'nil')..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Gameender count='..M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount]) end
    if not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= 3 and not(bSaveMassForMML) and (
            (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 95 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.55 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 20 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 10000)
                    or (M28Map.bIsCampaignMap and ((M28Team.tTeamData[iTeam][M28Team.refiLowestUnitCapAdjustmentLevel] or 100) <= 2 or (not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 60 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 30 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) then
        local bAlreadyHaveGameEnderUnderConstruction = false
        local aiBrain = ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]] --M28Team.GetFirstActiveM28Brain(iTeam)
        if bDebugMessages == true then LOG(sFunctionRef..': About to check for nearby gameenders for team '..(iTeam or 'nil')..'; First active M28brain aibrain='..(aiBrain.Nickanme or 'nil')..'; LZ midpoint='..repru(tLZData[M28Map.subrefMidpoint])) end
        local tNearbyGameEnders = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryGameEnder, tLZData[M28Map.subrefMidpoint], 1000, 'Ally')
        local iCompletedGameEnders = 0
        if M28Utilities.IsTableEmpty(tNearbyGameEnders) == false then
            for iExperimental, oExperimental in tNearbyGameEnders do
                if oExperimental:GetFractionComplete() < 1 then
                    --Is this gameender in a different zone?
                    local iGameEnderPlateau, iGameEnderZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oExperimental:GetPosition())
                    if not(iGameEnderZone == iLandZone and iGameEnderPlateau == iPlateau) then
                        bAlreadyHaveGameEnderUnderConstruction = true
                    end
                else
                    iCompletedGameEnders = iCompletedGameEnders + 1
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bAlreadyHaveGameEnderUnderConstruction='..tostring(bAlreadyHaveGameEnderUnderConstruction or false)) end
        if not(bAlreadyHaveGameEnderUnderConstruction) then
            iBPWanted = 45
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 125 then iBPWanted = 90 end
            if iCompletedGameEnders < 1 then
                HaveActionToAssign(refActionBuildGameEnder, 3,                     iBPWanted,      nil,                false,                      true)
                if bDebugMessages == true then LOG(sFunctionRef..': iBPWanted for gameender='..iBPWanted) end
            else
                --Consider getting land experimental instead unless we have large number already
                local iCompletedLandExperimentals = 0
                local tNearbyLandExperimentals = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryLandExperimental, tLZData[M28Map.subrefMidpoint], 1000, 'Ally')
                if M28Utilities.IsTableEmpty(tNearbyLandExperimentals) == false then
                    for iUnit, oUnit in tNearbyLandExperimentals do
                        if oUnit:GetFractionComplete() >= 1 then
                            iCompletedLandExperimentals = iCompletedLandExperimentals + 1
                        end
                    end
                end
                local iLandExpeimentalsWantedPerGameEnder = 1
                if NavUtils.GetLabel(M28Map.refPathingTypeHover, tLZTeamData[M28Map.reftClosestEnemyBase]) == NavUtils.GetLabel(M28Map.refPathingTypeHover, tLZData[M28Map.subrefMidpoint]) then iLandExpeimentalsWantedPerGameEnder = 5 end
                if bDebugMessages == true then LOG(sFunctionRef..': Deciding if want gameender or land experimental, iCompletedLandExperimentals='..iCompletedLandExperimentals..'; iCompletedGameEnders='..iCompletedGameEnders..'; iLandExpeimentalsWantedPerGameEnder='..iLandExpeimentalsWantedPerGameEnder) end
                if iCompletedLandExperimentals < iCompletedGameEnders * iLandExpeimentalsWantedPerGameEnder then
                    HaveActionToAssign(refActionBuildLandExperimental, 3,                     iBPWanted,      nil,                false,                      true)
                else
                    HaveActionToAssign(refActionBuildGameEnder, 3,                     iBPWanted,      nil,                false,                      true)
                end
            end
        end
    end

    --Low priority island support - will consider further away distances tahn before, up to a distance of 400, and only if the island wants T1 engineer BP

    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Low priority core zone island engi support logic, iHighestTechEngiAvailable='..iHighestTechEngiAvailable) end
    if iHighestTechEngiAvailable > 0 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if iHighestTechEngiAvailable > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': is pathing to other islands empty='..tostring( M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]))) end
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; tLZTeamData[M28Map.reftClosestEnemyBase]='..repru(tLZTeamData[M28Map.reftClosestEnemyBase])..'; tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint])) end

                for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering island '..tPathingData[M28Map.subrefIslandNumber]..' for lower priority travel; travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; Closest LZ ref='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; are enemies in this or adjacent LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                    if tPathingData[M28Map.subrefIslandTravelDist] > 400 then break
                    else
                        --Are there enemies in the target LZ?

                        if tPathingData[M28Map.subrefIslandClosestLZRef] then
                            local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]]
                            if not(tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbDangerousEnemiesInThisLZ]) then
                                --Can we reach the island?
                                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]) then
                                    --Are there enemies in an adjacent LZ
                                    local iAdjacentEnemyThreat = 0
                                    if tAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                                        if M28Utilities.IsTableEmpty(tAdjLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                            for _, iAdjToAdjLZ in tAdjLZData[M28Map.subrefLZAdjacentLandZones] do
                                                local tAdjToAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjToAdjLZ]
                                                iAdjacentEnemyThreat = iAdjacentEnemyThreat + tAdjToAdjLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal]
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': iAdjacentEnemyThreat='..iAdjacentEnemyThreat) end
                                    if iAdjacentEnemyThreat < 10 then

                                        local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, tPathingData[M28Map.subrefIslandClosestLZRef], iEntry, iHighestTechEngiAvailable, false, true)
                                        if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                                        if (tiBPByTechWanted[1] or 0) > 0 then
                                            HaveActionToAssign(refActionMoveToLandZone, 1, 5, tPathingData[M28Map.subrefIslandClosestLZRef], true)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Finished trying to give order for engi to move to the island LZ '..tPathingData[M28Map.subrefIslandClosestLZRef]) end
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    --Build more air factories if close to overflowing mass and dont have low power (e.g. to help in campaign and unit restriction scenarios where land factories arent an option)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether want a low priority air factory if overflowing mass, bHaveLowMass='..tostring(bHaveLowMass)..'; bHaveLowPower='..tostring(bHaveLowPower)..'; Lowest mass% stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; Land facotyr lifetime count='..M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandFactory)..'; Want more factories='..tostring(M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone))..'; want air instead of land fac='..tostring(M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData))) end
    if not(bHaveLowMass) and not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.6 and M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone) then
        if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) or ((M28Map.bIsCampaignMap or M28Overseer.bUnitRestrictionsArePresent) and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandFactory) <= 1) then
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build another air factory as low priority action due to mass overflow') end
            iBPWanted = 3 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
            HaveActionToAssign(refActionBuildAirFactory, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted, nil)
        end
    end

    --Build second air factories if really close to overflowing mass and dont have low power (e.g. to help in campaign and unit restriction scenarios where land factories arent an option)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether want a low priority air factory if overflowing mass, bHaveLowMass='..tostring(bHaveLowMass)..'; bHaveLowPower='..tostring(bHaveLowPower)..'; Lowest mass% stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; Land facotyr lifetime count='..M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandFactory)..'; Want more factories='..tostring(M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone))..'; want air instead of land fac='..tostring(M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData))) end
    if not(bHaveLowMass) and not(bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.8 and M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] >= 1 then
        if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) or ((M28Map.bIsCampaignMap or M28Overseer.bUnitRestrictionsArePresent) and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandFactory) <= 1) then
            iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]]
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build another air factory as low priority action due to mass overflow, iBPWanted='..iBPWanted..'; Highest air fac tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]) end
            HaveActionToAssign(refActionBuildSecondAirFactory, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted, nil)
        end
    end

    --Check for any part constructed buildings in this zone if we have available engineers
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then
        local tBuildings = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tBuildings) == false then
            for iUnit, oUnit in tBuildings do
                --Dont assist a part built shield being built for special shielding logic
                if oUnit:GetFractionComplete() < 1 and not(oUnit[refbDontIncludeAsPartCompleteBuildingForConstruction]) then
                    HaveActionToAssign(refActionRepairUnit, 1, 5, oUnit)
                    break
                end
            end
        end
    end


    --SPARE ENGINEER ACTIONS----->
    UpdateSpareEngineerNumber(tLZTeamData, toAvailableEngineersByTech)


    --All spare engi actions
    if iHighestTechEngiAvailable > 0 then
        --Build any unbuilt mexes (with more build power than would normally assign)
        iCurPriority = iCurPriority + 1
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) == false then
            iBPWanted = 5 + tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]] * table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations])
            HaveActionToAssign(refActionBuildMex, 1, iBPWanted)
        end

        --Spare engi - assist any upgrading unit
        iCurPriority = iCurPriority + 1
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoActiveUpgrades]) == false then
            HaveActionToAssign(refActionAssistUpgrade, 1, 1000, nil, true, nil, nil, nil, true)
            iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        end

        --Spare engi - reclaim area
        iCurPriority = iCurPriority + 1 --do this after each action
        if iHighestTechEngiAvailable > 0 then
            if tLZData[M28Map.subrefTotalMassReclaim] >= 20 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.6 then
                local bWantEnergy = false
                HaveActionToAssign(refActionReclaimArea, 1, 500, {bWantEnergy, nil}, true, nil, nil, nil, true)
                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
            end
        end

        --Spare engi - assist under construction building if we dont have low mass or energy
        iCurPriority = iCurPriority + 1
        if bDebugMessages == true then LOG(sFunctionRef..': Spare engineer action, iHighestTechEngiAvaialble='..iHighestTechEngiAvailable..'; Have low mass='..tostring(bHaveLowMass)..'; Mass stored on team='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Have low power='..tostring(bHaveLowPower)) end
        if iHighestTechEngiAvailable > 0 and (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 5000) and not(bHaveLowPower) then
            --Dont assist part complete shields due to risk we are using for active shielding
            local oBuildingToAssist = GetPartCompleteBuildingInZone(iTeam, iPlateau, iLandZone, M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryExperimentalLevel - M28UnitInfo.refCategoryFixedShield -categories.NAVAL, false)
            if bDebugMessages == true then LOG(sFunctionRef..': oBuildingToAssist='..(oBuildingToAssist.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oBuildingToAssist) or 'nil')) end
            if oBuildingToAssist then
                if bDebugMessages == true then LOG(sFunctionRef..': Will assign all remaining engineers to repair building') end
                --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
                HaveActionToAssign(refActionRepairUnit, 1,                  300,                oBuildingToAssist, true,                    true, nil, nil, true) --max 300 BP to allow for a very slight spreading of engineers where have lots
                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
            end
        end

        --Spare engi action - go to any nearby land or water zone that wants BP
        iCurPriority = iCurPriority + 1

        if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; If have available engis then will look for other zones wanting them, time='..GetGameTimeSeconds()..'; Is table of other land and water zones by distance empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]))) end
        if iHighestTechEngiAvailable > 0 then
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through all other land and water zones, reprs='..reprs(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance])) end
                for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to travel to zone '..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..'; Distance='..tSubtable[M28Map.subrefiDistance]) end
                    if tSubtable[M28Map.subrefiDistance] <= 500 then
                        local tAdjLZOrWZData, tAdjLZOrWZTeamData
                        if tSubtable[M28Map.subrefbIsWaterZone] then
                            tAdjLZOrWZData =M28Map.tPondDetails[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                            tAdjLZOrWZTeamData = tAdjLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                        else
                            tAdjLZOrWZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                            tAdjLZOrWZTeamData = tAdjLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering zone '..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..'; Wnats BP='..tostring(tAdjLZOrWZTeamData[M28Map.subrefTbWantBP])..'; In playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAdjLZOrWZData[M28Map.subrefMidpoint]))..'; Zone plateau='..(NavUtils.GetLabel(M28Map.refPathingTypeHover, tAdjLZOrWZData[M28Map.subrefMidpoint]) or 'nil')..'; iPlateau='..iPlateau) end
                        if tAdjLZOrWZTeamData[M28Map.subrefTbWantBP] and NavUtils.GetLabel(M28Map.refPathingTypeHover, tAdjLZOrWZData[M28Map.subrefMidpoint]) == iPlateau and (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZOrWZData[M28Map.subrefMidpoint])) then
                            local iCurBPWanted = 0
                            local iMinTechWanted = 3
                            for iTech, iBP in tAdjLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted] do
                                iMinTechWanted = math.min(iMinTechWanted, iTech)
                                iCurBPWanted = iCurBPWanted + iBP
                            end
                            if iCurBPWanted > 0 and iMinTechWanted <= iHighestTechEngiAvailable then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have BP wanted, iCurBPWanted='..iCurBPWanted..'; PlateauorPond='..(tSubtable[M28Map.subrefiPlateauOrPond] or 'nil')..'; Land or water zone ref='..(tSubtable[M28Map.subrefiLandOrWaterZoneRef] or 'nil')..'; Is water zone='..tostring(tSubtable[M28Map.subrefbIsWaterZone] or false)) end
                                if tSubtable[M28Map.subrefbIsWaterZone] then
                                    --HaveActionToAssign(iActionToAssign,   iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable,                      bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
                                    HaveActionToAssign(refActionMoveToWaterZone, iMinTechWanted, iCurBPWanted,      tSubtable[M28Map.subrefiLandOrWaterZoneRef],true, true,nil,nil, false) --Dont treat it as spare action, or else it gets orders overwritten and can end up in a loop where it moves to another zone and that zone sends it back home
                                else
                                    HaveActionToAssign(refActionMoveToLandZone, iMinTechWanted, iCurBPWanted, tSubtable[M28Map.subrefiLandOrWaterZoneRef], true, true,nil,nil,false) --Dont treat it as spare action, or else it gets orders overwritten and can end up in a loop where it moves to another zone and that zone sends it back home
                                end
                                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                if iHighestTechEngiAvailable == 0 then break end
                            end
                        end
                    end
                end
            else
                M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint])
            end
        end

        iCurPriority = iCurPriority + 1
        --Spare engi action - assist air factory if it isnt idle and we dont have low mass
        if iHighestTechEngiAvailable > 0 and not(bHaveLowPower) and not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] > 0 and GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeAirFacHadNothingToBuild] or -100) <= 5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.35 then
            local tAirFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tAirFactories) == false then
                --Get the factory  closest to the midpoint
                local iClosestDistOfHighestTech = 100000
                local iHighestTech = 0
                local oClosestFactory
                local iCurDist, iCurTech
                for iUnit, oUnit in tAirFactories do
                    iCurTech = M28UnitInfo.GetUnitTechLevel(oUnit)
                    if iCurTech >= iHighestTech then
                        if iCurTech > iHighestTech then
                            iHighestTech = iCurTech
                            iClosestDistOfHighestTech = 100000
                        end
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])
                        if iCurDist < iClosestDistOfHighestTech then
                            iClosestDistOfHighestTech = iCurDist
                            oClosestFactory = oUnit
                        end
                    end
                end
                if oClosestFactory then
                    --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
                    HaveActionToAssign(refActionAssistAirFactory, 1,                  10000,                oClosestFactory, true,                    true,                       nil,                         nil,                                true)
                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                end
            end
        end
    end


    --Localised mex upgrade logic (this is in addition to centralised logic) - intended for games on larger maps - but only if no enemies in adjacent zone
    if bDebugMessages == true then LOG(sFunctionRef..': Considering engineer based mex upgrade logic for zone '..iLandZone..', bHaveLowPower='..tostring(bHaveLowPower)..'; mex count by tech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; Map size='..M28Map.iMapSize..'; Enemies in adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Is Active upgrades in this LZ table empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoActiveUpgrades]))..'; Team gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Is table of mexes on team empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]))..'; Team factory tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) end
    if (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 100 or not(bHaveLowPower)) and iActiveMexUpgrades == 0 and (tLZTeamData[M28Map.subrefMexCountByTech][1] + tLZTeamData[M28Map.subrefMexCountByTech][2] > 0) and M28Map.iMapSize >= 256 and (not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) or (not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 5) and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoActiveUpgrades]) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 8) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 or not(bHaveLowMass) or tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][1] > 0)) then
        --Do we have T3 factory (or T2 if we have t1 mexes) and either we aren't mass stalling, or we have no mex upgrades at a team level?
        if bDebugMessages == true then LOG(sFunctionRef..': Passed initial checks, checking further') end
        if (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 or (not(M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam]) and ((tLZTeamData[M28Map.subrefMexCountByTech][1] > 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2)) and (not(bHaveLowMass) or not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) or tLZTeamData[M28Map.subrefMexCountByTech][1] > 0 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20)))then
            --Find a mex to upgrade - first try T1 mexes
            local tPotentialMexes
            if tLZTeamData[M28Map.subrefMexCountByTech][1] then
                tPotentialMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryT1Mex, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            else
                tPotentialMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryT2Mex + M28UnitInfo.refCategoryT1Mex, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of potential mexes empty='..tostring(M28Utilities.IsTableEmpty(tPotentialMexes))) end
            if M28Utilities.IsTableEmpty(tPotentialMexes) == false then
                for iMex, oMex in tPotentialMexes do
                    if oMex:GetFractionComplete() >= 1 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will upgrade mex '..oMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oMex)) end
                        M28Economy.UpgradeUnit(oMex, true)
                        break
                    end
                end
            end

        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tLZTeamData[M28Map.subrefTBuildPowerByTechWanted] before general adjustments='..repru(tLZTeamData[M28Map.subrefTBuildPowerByTechWanted])..'; tLZTeamData[M28Map.subrefSpareBPByTech]='..repru(tLZTeamData[M28Map.subrefSpareBPByTech])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end
function ConsiderMinorLandZoneEngineerAssignment(tLZTeamData, iTeam, iPlateau, iLandZone, tEngineers)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderMinorLandZoneEngineerAssignment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local bDontCheckPlayableArea = false
    if M28Map.bIsCampaignMap then
        bDontCheckPlayableArea = true
        if M28Team.tTeamData[iTeam][M28Team.rebTeamOnlyHasCampaignAI] then bDontCheckPlayableArea = false end
    end

    --if bDebugMessages == true then M28Map.DrawSpecificLandZone(iPlateau, iLandZone, 1) end
    local iBPWanted
    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
    local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)
    local bWantMorePower = M28Conditions.WantMorePower(iTeam)
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local bAdjacentToCoreZone

    local iNearbyEnemyAirToGroundThreat = tLZTeamData[M28Map.refiEnemyAirToGroundThreat]
    --For now only do land zone not water zone given water zone includes torp bombers
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
            iNearbyEnemyAirToGroundThreat = iNearbyEnemyAirToGroundThreat + tLZTeamData[M28Map.refiEnemyAirToGroundThreat]
            if tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] then bAdjacentToCoreZone = true end
        end
    end


    local toAvailableEngineersByTech, toAssignedEngineers = FilterToAvailableEngineersByTech(tEngineers, false, tLZData, tLZTeamData, iTeam, iPlateau, iLandZone)
    tLZTeamData[M28Map.subrefTBuildPowerByTechWanted] = {[1]=0,[2]=0,[3]=0}
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Non core LZ - Have just reset BPByTech to 0 for Plateau'..iPlateau..'; LZ='..iLandZone..'; repru='..repru(tLZTeamData[M28Map.subrefTBuildPowerByTechWanted])..'; subrefLZCoreExpansion='..tostring(tLZTeamData[M28Map.subrefLZCoreExpansion] or false)..'; subrefbCoreBaseOverride='..tostring(tLZTeamData[M28Map.subrefbCoreBaseOverride] or false)..'; LZTeamData Allied nonM28 mex count='..(tLZTeamData[M28Map.refiNonM28TeammateMexCount] or 'nil')..'; Allied NonM28 factory count='..(tLZTeamData[M28Map.refiNonM28TeammateFactoryCount] or 'nil')) end

    local bTeammateHasBuiltHere = false
    if tLZData[M28Map.subrefLZMexCount] > 0 then
        if bDebugMessages == true then LOG(sFunctionRef..': Teammate mex count='..tLZTeamData[M28Map.refiNonM28TeammateMexCount]..'; Factory count='..tLZTeamData[M28Map.refiNonM28TeammateFactoryCount]..'; LZ mex count='..tLZData[M28Map.subrefLZMexCount]) end
        if (tLZTeamData[M28Map.refiNonM28TeammateMexCount] or 0) >= tLZData[M28Map.subrefLZMexCount]
                or ((tLZTeamData[M28Map.refiNonM28TeammateFactoryCount] or 0) > 0 and (tLZTeamData[M28Map.refiNonM28TeammateMexCount] or 0) >= (tLZData[M28Map.subrefLZMexCount] or 0) * 0.5) then
            bTeammateHasBuiltHere = true
            if bDebugMessages == true then LOG(sFunctionRef..': Since teammate has all the mexes or half plus factories will treat them as owning this zone and wont try and build much here') end
        end

    elseif tLZTeamData[M28Map.refiNonM28TeammateFactoryCount] > 0 then
        bTeammateHasBuiltHere = true
    end
    -- (tLZTeamData[M28Map.refiNonM28TeammateMexCount] >= tLZData[M28Map.subrefLZMexCount] tLZTeamData[M28Map.refiNonM28TeammateFactoryCount] > 0 and (tLZTeamData[M28Map.refiNonM28TeammateFactoryCount] >= 3 or
    --local iCurCondition = 0
    local iCurPriority = 0



    function HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
        --Done as subfunction for convenience so can just note the key values for the action in question and add on the others that wont change
        ConsiderActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iCurPriority, tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, toAvailableEngineersByTech, toAssignedEngineers, false, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
    end

    --Active gameender template - want to always have 1 engi on duty as highest priority to avoid having orders cancelled
    iCurPriority = iCurPriority + 1
    if M28Conditions.HaveActiveGameEnderTemplateLogic(tLZTeamData) then
        HaveActionToAssign(refActionManageGameEnderTemplate, 3, 25)
    end


    --Land fac if this is an island with no core LZs - also set this as the primary if no such LZ
    iCurPriority = iCurPriority + 1
    local iHighestTechEngiAvailable
    local bExpansionOnSameIslandAsBase = false

    if bDebugMessages == true then LOG(sFunctionRef..': do we want this zone as an expansion point? iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Time='..GetGameTimeSeconds()..'; tLZTeamData[M28Map.subrefLZCoreExpansion]='..tostring(tLZTeamData[M28Map.subrefLZCoreExpansion] or false)..'; tLZTeamData[M28Map.subrefLZCoreExpansion] is nil='..tostring(tLZTeamData[M28Map.subrefLZCoreExpansion] == nil)..'; tLZTeamData[M28Map.subrefLZExpansionOverride]='..tostring(tLZTeamData[M28Map.subrefLZExpansionOverride] or false)..'; tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][1]='..(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][1] or 'nil')) end
    if tLZTeamData[M28Map.subrefLZCoreExpansion] == nil or (tLZTeamData[M28Map.subrefLZExpansionOverride] and not(tLZTeamData[M28Map.subrefLZCoreExpansion])) then
        if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then
            local iEnemyBaseStraightLineDist = 200
            local iTravelLimit = 600 --If takes more than this to travel to the nearest friendly base, and we are more than iEnemyBaseStraightLineDist from the nearest enemy base on a straight line basis, then will consider a land expansion point

            bExpansionOnSameIslandAsBase = false
            if tLZData[M28Map.subrefLZIslandRef] == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestFriendlyBase]) then
                bExpansionOnSameIslandAsBase = true
                if not(bDontCheckPlayableArea) then
                    bExpansionOnSameIslandAsBase = false
                    --Check we can actually travel here by land
                    local iNearestBasePlateau, iNearestBaseLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tLZTeamData[M28Map.reftClosestFriendlyBase])
                    if (iNearestBaseLandZone or 0) > 0 then
                        local iEntryNumber = tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iNearestBaseLandZone]
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': iEntryNumber='..(iEntryNumber or 'nil')..'; iNearestBasePlateau='..(iNearestBasePlateau or 'nil')..'; LZ Ref based on this entry number='..(tLZData[M28Map.subrefLZPathingToOtherLandZones][iEntryNumber][M28Map.subrefLZNumber] or 'nil')..'; iNearestBaseLandZone='..iNearestBaseLandZone)
                            if not(iEntryNumber) then LOG(sFunctionRef..': Dont have a ref for iNearestBaseLandZone='..iNearestBaseLandZone..'; All refs='..repru(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef])) end
                        end
                        if iEntryNumber then
                            local tTravelPath = tLZData[M28Map.subrefLZPathingToOtherLandZones][iEntryNumber][M28Map.subrefLZPath]
                            if bDebugMessages == true then LOG(sFunctionRef..': tTravelPath='..repru(tTravelPath)) end
                            if M28Utilities.IsTableEmpty(tTravelPath) == false then
                                bExpansionOnSameIslandAsBase = true
                                for iPath, iPathLZ in tTravelPath do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iPathLZ='..iPathLZ..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefMidpoint]))) end
                                    if not(M28Conditions.IsLocationInPlayableArea(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefMidpoint])) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': iPathLZ is not in the playable area so dont want to make this an expansion') end
                                        bExpansionOnSameIslandAsBase = false
                                        break
                                    end
                                end
                                if bExpansionOnSameIslandAsBase then
                                    --Still consider as expansion point if far away
                                    if bDebugMessages == true then LOG(sFunctionRef..': Expansion is on same island as base, checking if it is still really far away such that we want to considera n expansion point, travel dist='..tLZData[M28Map.subrefLZPathingToOtherLandZones][iEntryNumber][M28Map.subrefLZTravelDist]..'; Dist to enemy base (straight line)='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase])) end
                                    if tLZData[M28Map.subrefLZPathingToOtherLandZones][iEntryNumber][M28Map.subrefLZTravelDist] >= iTravelLimit and M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase]) >= iEnemyBaseStraightLineDist then
                                        bExpansionOnSameIslandAsBase = false
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': tLZData[M28Map.subrefLZMexCount]='..(tLZData[M28Map.subrefLZMexCount] or 'nil')..'; Island mex count='..(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tLZData[M28Map.subrefLZIslandRef]] or 'nil')..'; bExpansionOnSameIslandAsBase='..tostring(bExpansionOnSameIslandAsBase or false)..'; tLZData[M28Map.subrefLZIslandRef]='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..'; Closest firendly base island ref='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestFriendlyBase]) or 'nil')) end
            if (tLZData[M28Map.subrefLZMexCount] > 0 or (M28Map.bIsCampaignMap and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tLZData[M28Map.subrefLZIslandRef]] >= 4)) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tLZData[M28Map.subrefLZIslandRef]] >= 3 and not(bExpansionOnSameIslandAsBase) then
                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable='..iHighestTechEngiAvailable) end
                if iHighestTechEngiAvailable > 0 then
                    local bHaveCoreLZ = false
                    for iEntry, iIslandLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][tLZData[M28Map.subrefLZIslandRef]] do
                        if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iIslandLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] or M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iIslandLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZCoreExpansion] then
                            if bDebugMessages == true then LOG(sFunctionRef..': iIslandlZ'..iIslandLZ..' in the island '..tLZData[M28Map.subrefLZIslandRef]..' is either a core base or expansion, Is core base='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iIslandLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZbCoreBase] or false)..'; Is core expansion='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iIslandLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZCoreExpansion] or false)..'; bDontCheckPlayableArea='..tostring(bDontCheckPlayableArea)) end
                            if bDontCheckPlayableArea then
                                bHaveCoreLZ = true
                                break
                            else
                                --Check we can actually travel here by land and it isn't too far away
                                local iEntryNumber = tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iIslandLZ]
                                if bDebugMessages == true then LOG(sFunctionRef..': iEntryNumber='..(iEntryNumber or 'nil')..'; LZ Ref based on this entry number='..(tLZData[M28Map.subrefLZPathingToOtherLandZones][iEntryNumber][M28Map.subrefLZNumber] or 'nil')..'; iIslandLZ='..iIslandLZ) end
                                if iEntryNumber then
                                    local tTravelPath = tLZData[M28Map.subrefLZPathingToOtherLandZones][iEntryNumber][M28Map.subrefLZPath]
                                    if bDebugMessages == true then LOG(sFunctionRef..': tTravelPath='..repru(tTravelPath)) end
                                    if M28Utilities.IsTableEmpty(tTravelPath) == false then
                                        bHaveCoreLZ = true
                                        for iPath, iPathLZ in tTravelPath do
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iPathLZ='..iPathLZ..'; Is in playable area='..tostring(M28Conditions.IsLocationInPlayableArea(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefMidpoint]))) end
                                            if not(M28Conditions.IsLocationInPlayableArea(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPathLZ][M28Map.subrefMidpoint])) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': iPathLZ is not in the playable area so dont think we have a core LZ after all') end
                                                bHaveCoreLZ = false
                                                break
                                            end
                                        end
                                        if bHaveCoreLZ then
                                            --Ignore if this location is far away
                                            if tLZData[M28Map.subrefLZPathingToOtherLandZones][iEntryNumber][M28Map.subrefLZTravelDist] >= iTravelLimit then
                                                bHaveCoreLZ = false
                                            end
                                            if bHaveCoreLZ then
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Updating core expansion flag, bHaveCoreLZ='..tostring(bHaveCoreLZ)..'; Have override='..tostring(tLZTeamData[M28Map.subrefLZExpansionOverride] or false)) end
                    if not(bHaveCoreLZ) or tLZTeamData[M28Map.subrefLZExpansionOverride] then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will set this location as the core expansion location') end
                        --Build a land factory
                        tLZTeamData[M28Map.subrefLZCoreExpansion] = true
                    else
                        tLZTeamData[M28Map.subrefLZCoreExpansion] = false
                    end
                end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Will update core expansion flag, tLZTeamData[M28Map.subrefLZExpansionOverride]='..tostring(tLZTeamData[M28Map.subrefLZExpansionOverride] or false)) end
                if tLZTeamData[M28Map.subrefLZExpansionOverride] then
                    tLZTeamData[M28Map.subrefLZCoreExpansion] = true
                else
                    tLZTeamData[M28Map.subrefLZCoreExpansion] = false
                end
            end
        end
    elseif tLZTeamData[M28Map.subrefLZCoreExpansion] and not(bExpansionOnSameIslandAsBase) then
        --Need to calculate if are on same island
        local iBaseIslandRef = NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestFriendlyBase])
        if iBaseIslandRef == tLZData[M28Map.subrefLZIslandRef] then
            bExpansionOnSameIslandAsBase = true
        end
    end

    local iFactoriesWanted = 0
    local iExistingFactory = 0
    local bExistingFactoryIsComplete = false
    if tLZTeamData[M28Map.subrefLZCoreExpansion] or (bAdjacentToCoreZone and not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 750) then
        if not(bTeammateHasBuiltHere) then
            local tExistingFactory = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tExistingFactory) == false then
                for iUnit, oUnit in tExistingFactory do
                    if oUnit:GetFractionComplete() == 1 then
                        bExistingFactoryIsComplete = true
                        iExistingFactory = iExistingFactory + 1
                        if M28UnitInfo.GetUnitTechLevel(oUnit) >= 2 then
                            iExistingFactory = iExistingFactory + 1
                        end
                    end
                end
            end
            iFactoriesWanted = math.min(4, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tLZData[M28Map.subrefLZIslandRef]] - 2)
            local iIslandZoneCount = table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][tLZData[M28Map.subrefLZIslandRef]])
            if bExpansionOnSameIslandAsBase then
                iFactoriesWanted = math.max(1, math.min(4, iFactoriesWanted, tLZData[M28Map.subrefLZMexCount] - 2))
                --Consider getting more factories if enemy has nearby factories, i.e. factor in adjacent zones
                if (tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 1 and tLZTeamData[M28Map.refiModDistancePercent] >= 0.2 and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tLZData[M28Map.subrefLZIslandRef]] >= 8 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 4 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 100 and tLZTeamData[M28Map.subrefMexCountByTech][1] + tLZTeamData[M28Map.subrefMexCountByTech][2] >= math.min(5, tLZData[M28Map.subrefLZMexCount]))) and not(bAdjacentToCoreZone) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech] < 2 or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 and M28Conditions.GetLifetimeBuildCount(ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]], M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryGunship + M28UnitInfo.refCategoryBomber - categories.TECH1) <= 15)) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 50 then
                    local iMexesIncludingAdjacentZones = tLZData[M28Map.subrefLZMexCount]
                    local bEnemyHasCombatOrFactory = tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]
                    local iEnemyNetCombatThreat = (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) - (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)
                    for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                        iMexesIncludingAdjacentZones = iMexesIncludingAdjacentZones + tAdjLZData[M28Map.subrefLZMexCount]
                        local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                        iEnemyNetCombatThreat = iEnemyNetCombatThreat + (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) - (tAdjLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0)
                        if not(bEnemyHasCombatOrFactory) then
                            if (tAdjLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) >= 20 then
                                bEnemyHasCombatOrFactory = true
                            elseif M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory, tAdjLZTeamData[M28Map.subrefTEnemyUnits])) == false then
                                bEnemyHasCombatOrFactory = true
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': P'..iPlateau..'Z'..iLandZone..': bEnemyHasCombatOrFactory='..tostring(bEnemyHasCombatOrFactory or false)..'; iMexesIncludingAdjacentZones='..iMexesIncludingAdjacentZones..'; iEnemyNetCombatThreat='..iEnemyNetCombatThreat) end
                    if bEnemyHasCombatOrFactory and iMexesIncludingAdjacentZones >= 6 and iEnemyNetCombatThreat <= 1000 then
                        --Dont get more factories if enemy ACU is relatively close since will likely be wasted mass
                        local iClosestEnemyACU = 100000
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs]) == false then
                            for iEnemyACU, oEnemyACU in M28Team.tTeamData[iTeam][M28Team.reftEnemyACUs] do
                                if not(oEnemyACU.Dead) then
                                    iClosestEnemyACU = math.min(iClosestEnemyACU, M28Utilities.GetDistanceBetweenPositions(oEnemyACU:GetPosition(), tLZData[M28Map.subrefMidpoint]))
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iClosestEnemyACU='..iClosestEnemyACU) end
                        if iClosestEnemyACU > 200 then
                            iFactoriesWanted = math.max(iFactoriesWanted, 3, math.min(5, iMexesIncludingAdjacentZones * 0.5))
                        end
                    end
                end

            else
                if iIslandZoneCount < 4 then iFactoriesWanted = math.max(1, math.min(iFactoriesWanted, iIslandZoneCount * 0.5)) end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iIslandZoneCount='..iIslandZoneCount..'; iFactoriesWanted pre adj='..iFactoriesWanted) end
            if (iIslandZoneCount > 2 or tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and not(bWantMorePower) and not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.4 then

                if not(bExpansionOnSameIslandAsBase) or M28Map.iMapSize >= 750 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.6 then iFactoriesWanted = iFactoriesWanted + 1 end
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.8 then
                    if not(bExpansionOnSameIslandAsBase) or M28Map.iMapSize >= 750 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.9 then iFactoriesWanted = iFactoriesWanted + math.max(1, iFactoriesWanted / 3) end
                end
            end
            if iFactoriesWanted >= 1 and M28Team.tTeamData[iTeam][M28Team.refiTimeLastNearUnitCap] and not(M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone)) then iFactoriesWanted = 1 end
            if bDebugMessages == true then LOG(sFunctionRef..': iFactoriesWanted='..iFactoriesWanted..'; bWantMorePower='..tostring(bWantMorePower)..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Mass% stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; Map size='..M28Map.iMapSize..'; bExpansionOnSameIslandAsBase='..tostring(bExpansionOnSameIslandAsBase)..'; Island mex count='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tLZData[M28Map.subrefLZIslandRef]]..'; LZ mex count='..tLZData[M28Map.subrefLZMexCount]) end
            if iFactoriesWanted > 2 then
                --Does enemy have any units/threats on this island within a certain range?
                local bEnemyHasDangerousUnitsOnIsland = tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]
                if not(bEnemyHasDangerousUnitsOnIsland) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                    local iAdjLZ
                    for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                        iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; Travel dist='..tPathingDetails[M28Map.subrefLZTravelDist]..'; Does it want DF support='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport])) end
                        if tPathingDetails[M28Map.subrefLZTravelDist] < 275 then
                            local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]='..tostring(tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])) end
                            if tAdjLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] then
                                bEnemyHasDangerousUnitsOnIsland = true
                                break
                            end
                        end
                    end
                end
                if not(bEnemyHasDangerousUnitsOnIsland) then
                    if iFactoriesWanted > 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.8 then
                        iFactoriesWanted = 3
                    else
                        iFactoriesWanted = 2 --only here if we have >=2 factories wanted
                    end
                end
            end
            if bHaveLowMass then iFactoriesWanted = math.max(1, math.floor(iFactoriesWanted * 0.5)) end
            if bDebugMessages == true then LOG(sFunctionRef..': iFactoriesWanted after adjusting for enemy units='..iFactoriesWanted..'; iExistingFactory='..iExistingFactory) end
        end
    end

    --Do we want emergency PD?
    if bDebugMessages == true then LOG(sFunctionRef..': Considering emergency PD for zone '..iLandZone..', iExistingFactory='..iExistingFactory..'; Mex count by tech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; Enemies in this or adj LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Air to ground threat='..(tLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0)..'; Ally AA threat='..(tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0)) end
    if not(bTeammateHasBuiltHere) and ((tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and (iExistingFactory >= 1 or (tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] * 2 + tLZTeamData[M28Map.subrefMexCountByTech][1] * 0.35) >= 2) and (tLZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) <= math.min(350, 0.5*(tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0))) and (not(M28Overseer.bNoRushActive) or M28Overseer.iNoRushTimer - GetGameTimeSeconds() <= 120 or (not(bHaveLowMass) and not(bHaveLowPower) and tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 0))) then
        --Does enemy have any units that can outrange a PD? If so then dont bother building
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) then
            local iHighestNearbyEnemyRange = math.max((tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0), tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0)
            local bConsiderT2PD = false
            if bDebugMessages == true then LOG(sFunctionRef..': iHighestNearbyEnemyRange='..iHighestNearbyEnemyRange..'; Highest friendly land fac tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Active brain count='..M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]..'; Mex count by tehc='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; LZ s value='..tLZTeamData[M28Map.subrefLZSValue]..'; Mex count='..tLZData[M28Map.subrefLZMexCount]) end
            if iHighestNearbyEnemyRange < 50 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 6 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and (tLZTeamData[M28Map.subrefMexCountByTech][3] + tLZTeamData[M28Map.subrefMexCountByTech][2] >= 1 or (tLZData[M28Map.subrefLZMexCount] >= 4 and tLZTeamData[M28Map.subrefLZSValue] >= 500)) and (tLZData[M28Map.subrefLZMexCount] >= 3 or tLZTeamData[M28Map.subrefMexCountByTech][2] >= 2 or tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1) then bConsiderT2PD = true end
            if iHighestNearbyEnemyRange <= 25 or bConsiderT2PD then
                local iEnemyCombatThreat = (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        local tAdjLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                        iHighestNearbyEnemyRange = math.max(iHighestNearbyEnemyRange, (tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] or 0), tAdjLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] or 0)
                        iEnemyCombatThreat = iEnemyCombatThreat + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileDFTotal] or 0) + (tAdjLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectTotal] or 0)
                    end
                end
                if iEnemyCombatThreat >= 25 then
                    if bConsiderT2PD then
                        if iHighestNearbyEnemyRange >= 50 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 2 then bConsiderT2PD = false
                        elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 2 then
                            --Do we have T2 factories or engineers of any kind in this zone?
                            local tT2Units = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryFactory - categories.TECH1, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                            local bHaveT2FactoriesOrEngineers = false
                            if M28Utilities.IsTableEmpty(tT2Units) == false then
                                for iUnit, oUnit in tT2Units do
                                    if oUnit:GetFractionComplete() == 1 then
                                        bHaveT2FactoriesOrEngineers = true
                                        break
                                    end
                                end
                            end
                            if not(bHaveT2FactoriesOrEngineers) then bConsiderT2PD = false end
                        end

                    end
                    if iHighestNearbyEnemyRange <= 25 or bConsiderT2PD then
                        local iExistingStructureThreat = 0
                        local bHaveLRPDThreat = false
                        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) == false then
                            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] do
                                iExistingStructureThreat = iExistingStructureThreat + iThreat
                                if iThreat > 0 and iRange >= 50 then bHaveLRPDThreat = true end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iExistingStructureThreat of existing PD='..iExistingStructureThreat..'; will get emergency PD if below threshold, iEnemyCombatThreat='..iEnemyCombatThreat..'; bConsiderT2PD='..tostring(bConsiderT2PD or false)) end
                        local iMinTechLevelWanted = 1
                        iBPWanted = 40
                        if bConsiderT2PD and iExistingStructureThreat >= 400 then
                            iMinTechLevelWanted = 2
                            iBPWanted = 60
                        end

                        if iExistingStructureThreat < 400 or (bConsiderT2PD and iExistingStructureThreat < math.max(800, math.max(iEnemyCombatThreat, math.min(iEnemyCombatThreat * 2, 2880)))) or (not(bConsiderT2PD) and iExistingStructureThreat < math.min(800, iEnemyCombatThreat * 3)) then
                            --Get T1 radar in priority to T2 PD if we already have T2 PD but no radar
                            if bDebugMessages == true then LOG(sFunctionRef..': Checking if we want to get t1 radar instead of t2 pd, bHaveLRPDThreat='..tostring(bHaveLRPDThreat)..'; Stalling energy='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; Radar coverage='..tLZTeamData[M28Map.refiRadarCoverage]..'; Want land scout='..tostring(tLZTeamData[M28Map.refbWantLandScout])..'; iExistingStructureThreat='..iExistingStructureThreat..'; Enemy combat='..(tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)) end
                            if bHaveLRPDThreat and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and tLZTeamData[M28Map.refiRadarCoverage] <= 40 and (tLZTeamData[M28Map.refbWantLandScout] or (tLZTeamData[M28Map.refiRadarCoverage] == 0 and iExistingStructureThreat >= 1000 and iExistingStructureThreat >= (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0))) and iExistingStructureThreat * 1.5 >= (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) then
                                HaveActionToAssign(refActionBuildT1Radar, 1, iBPWanted)
                            else
                                local tPDStartPoint
                                if iExistingStructureThreat <= 800 then tPDStartPoint = {tLZData[M28Map.subrefMidpoint][1], tLZData[M28Map.subrefMidpoint][2], tLZData[M28Map.subrefMidpoint][3]}
                                else
                                    tPDStartPoint = M28Utilities.MoveInDirection(tLZData[M28Map.subrefMidpoint], M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase]), 25, true, false, M28Map.bIsCampaignMap)
                                    if not(tPDStartPoint) or not(NavUtils.GetTerrainLabel(M28Map.refPathingTypeLand, tPDStartPoint) == tLZData[M28Map.subrefLZIslandRef]) then  tPDStartPoint = {tLZData[M28Map.subrefMidpoint][1], tLZData[M28Map.subrefMidpoint][2], tLZData[M28Map.subrefMidpoint][3]} end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to build emergency PD, iMinTechLevelWanted='..iMinTechLevelWanted..'; bConsiderT2PD='..tostring(bConsiderT2PD or false)..'; iExistingStructureThreat='..(iExistingStructureThreat or 'nil')..'; tPDStartPoint='..repru(tPDStartPoint)) end
                                HaveActionToAssign(refActionBuildEmergencyPD, iMinTechLevelWanted, 40, tPDStartPoint)
                            end
                        end
                    end
                end
            end
        end
    end

    --Consider making a zone with lots of mexes a core expansion in some cases in the early game
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': LZ mex count='..tLZData[M28Map.subrefLZMexCount]..'; tLZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; Air fac tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]..'; Team mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Active brain count='..M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]..'; tLZTeamData[M28Map.refiModDistancePercent]='..tLZTeamData[M28Map.refiModDistancePercent]..'; P='..iPlateau..'Z='..iLandZone) end
    if not(tLZTeamData[M28Map.subrefLZCoreExpansion]) and tLZData[M28Map.subrefLZMexCount] >= 3 and tLZTeamData[M28Map.subrefMexCountByTech][1] + tLZTeamData[M28Map.subrefMexCountByTech][2] >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] <= 2 and (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 150 + 50 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1.5 + 2.5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]))) then
        if not(bTeammateHasBuiltHere) or tLZTeamData[M28Map.refiNonM28TeammateFactoryCount] < 2 or tLZTeamData[M28Map.refiNonM28TeammateMexCount] <= math.max(5, tLZData[M28Map.subrefLZMexCount] * 0.75) then
            if tLZTeamData[M28Map.refiModDistancePercent] >= 0.1 or tLZData[M28Map.subrefLZMexCount] >= 5 then
                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable='..iHighestTechEngiAvailable) end
                if iHighestTechEngiAvailable > 0 then
                    --Check we can path to closest enemy base
                    if bDebugMessages == true then LOG(sFunctionRef..': Island ref='..(tLZData[M28Map.subrefLZIslandRef] or 'nil')..'; Nearest enemy base island ref='..(NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) or 'nil')) end
                    if tLZData[M28Map.subrefLZIslandRef] == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) then
                        --Check we are closer to enemy base than closest friendly base
                        local iOurDistToEnemy = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase])
                        if bDebugMessages == true then LOG(sFunctionRef..': iOurDistToEnemy='..iOurDistToEnemy..'; Map size='..M28Map.iMapSize..'; Dist from closest friendly base to enemy='..M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZTeamData[M28Map.reftClosestFriendlyBase])) end
                        if iOurDistToEnemy < math.min(650, M28Map.iMapSize * 1.1) then
                            local iClosestFriendlyBaseDist = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZTeamData[M28Map.reftClosestFriendlyBase])
                            if iClosestFriendlyBaseDist > iOurDistToEnemy then
                                tLZTeamData[M28Map.subrefLZExpansionOverride] = true
                                tLZTeamData[M28Map.subrefLZCoreExpansion] = true
                                iFactoriesWanted = math.max(iFactoriesWanted, 1)
                                if bDebugMessages == true then LOG(sFunctionRef..': setting this zone as being a core expansion with iFactoriesWanted='..iFactoriesWanted) end
                            end
                        end
                    end
                end
            end
        end
    end


    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iExistingFactory='..iExistingFactory..'; iFactoriesWanted='..iFactoriesWanted..'; P'..iPlateau..'Z'..iLandZone) end
    if iExistingFactory < iFactoriesWanted then
        --Dont want to build air factories at a core expansion point, instead only want land
        --[[local bWantAirNotLand = M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)
    local iFactoryAction
    if bWantAirNotLand then iFactoryAction = refActionBuildAirFactory
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Want to build land factory not air factory4') end
        iFactoryAction = refActionBuildLandFactory
    end--]]
        iBPWanted = 10
        if bExistingFactoryIsComplete then iBPWanted = 5 end
        local iMaxTechLevelIfAny
        if iExistingFactory == 0 then iMaxTechLevelIfAny = 1 end
        if bDebugMessages == true then LOG(sFunctionRef..': Want a land facotry, iExistingFactory='..iExistingFactory..'; iFactoriesWanted='..iFactoriesWanted..'; gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]) end
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 750 and M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) then
            HaveActionToAssign(refActionBuildAirFactory, 1, iBPWanted, iMaxTechLevelIfAny)
        else
            HaveActionToAssign(refActionBuildLandFactory, 1, iBPWanted, iMaxTechLevelIfAny)
        end
    end

    --High reclaim zone when ahve low mass - want to be reclaiming ahead of building mexes
    iCurPriority = iCurPriority + 1
    if (bHaveLowMass and tLZData[M28Map.subrefTotalSignificantMassReclaim] >= 250) or (tLZData[M28Map.subrefTotalSignificantMassReclaim] >= 1000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.15) then
        if bDebugMessages == true then LOG(sFunctionRef..': High priority reclaim, Total mass in Plateau '..iPlateau..' LZ '..iLandZone..'='..tLZData[M28Map.subrefTotalMassReclaim]) end
        iBPWanted = 5

        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.03 and tLZData[M28Map.subrefTotalSignificantMassReclaim] >= 1000 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) then
            iBPWanted = 10
            if not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                iBPWanted = math.max(15, tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]])
            end
            if tLZData[M28Map.subrefTotalSignificantMassReclaim] >= 3000 then
                iBPWanted = iBPWanted * 1.5
                if tLZData[M28Map.subrefTotalSignificantMassReclaim] >= 10000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.075 then
                    iBPWanted = iBPWanted * 1.5
                end
            end
        end
        --Have 1 engi search for high value wrecks
        HaveActionToAssign(refActionReclaimArea, 1, 5, { false, 50 })
        --Then have 1-2 engis search for reclaim generally
        iCurPriority = iCurPriority + 1
        HaveActionToAssign(refActionReclaimArea, 1, iBPWanted, {false, nil})

    else
        iCurPriority = iCurPriority + 1
    end

    if bDebugMessages == true then LOG(sFunctionRef..': About to consider what actions we want to give engineers for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; Is table of unbuilt mex locations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]))..'; Is table of part complete mexes empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]))) end
    iCurPriority = iCurPriority + 1
    --Unclaimed mex high priority
    if not(bTeammateHasBuiltHere) and M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) == false and not(M28Overseer.bNoRushActive and M28Conditions.NoRushPreventingHydroOrMex(tLZData, true)) then
        if bDebugMessages == true then LOG(sFunctionRef..': We have unbuilt mex locations for this land zone, locations='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations])) end
        HaveActionToAssign(refActionBuildMex, 1, 5)
        if (tLZTeamData[M28Map.subreftiBPWantedByAction][refActionBuildMex] or 0) > 0 then tLZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] = true end
    end

    --Reclaim enemy building if have available engineers, and enemy has buildings but no combat threat
    iCurPriority = iCurPriority + 1
    if not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefTEnemyUnits]) == false then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if iHighestTechEngiAvailable > 0 then
            local oNearestEnemyUnitToMidpoint = M28Utilities.GetNearestUnit(tLZTeamData[M28Map.subrefTEnemyUnits], tLZData[M28Map.subrefMidpoint])
            if M28UnitInfo.IsUnitValid(oNearestEnemyUnitToMidpoint) then
                HaveActionToAssign(refActionReclaimEnemyUnit, 1, 5, oNearestEnemyUnitToMidpoint)

            end
        end
    end



    --AA if enemy has air to ground threat
    if bDebugMessages == true then LOG(sFunctionRef..': High priority AA builder: iNearbyEnemyAirToGroundThreat='..iNearbyEnemyAirToGroundThreat..'; enemy air to ground threat='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Enemy AirAA threat='..tLZTeamData[M28Map.refiEnemyAirAAThreat]) end
    iCurPriority = iCurPriority + 1
    if (iNearbyEnemyAirToGroundThreat > 0 or tLZTeamData[M28Map.refiEnemyAirAAThreat] >= 500) and (not(bTeammateHasBuiltHere) or iNearbyEnemyAirToGroundThreat >= 1000) then
        --Do we already have fixed AA in this LZ?
        if not(M28Team.tTeamData[iTeam][M28Team.refbFocusOnT1Spam]) or M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround] >= 200 or tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] == 0 then
            local iAACategory = M28UnitInfo.refCategoryStructureAA
            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then iAACategory = iAACategory * categories.TECH3 end
            local tExistingFixedAA = EntityCategoryFilterDown(iAACategory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            local bHaveFixedAA = false
            if M28Utilities.IsTableEmpty(tExistingFixedAA) == false then
                for iUnit, oUnit in tExistingFixedAA do
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have fixed AA, considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
                    if oUnit:GetFractionComplete() then bHaveFixedAA = true break end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bHaveFixedAA='..tostring(bHaveFixedAA)..'; Enemy air to ground threat='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Ally groundAA threat='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]) end
            if not(bHaveFixedAA) or iNearbyEnemyAirToGroundThreat > tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] then
                iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
                if iNearbyEnemyAirToGroundThreat > 0 then iBPWanted = iBPWanted * 2 end
                if not(bHaveLowPower) then
                    if not(bHaveLowMass) then iBPWanted = iBPWanted * 4
                    else iBPWanted = iBPWanted * 2
                    end
                end
                local bIncreaseBPWanted = false
                local iT2PlusMex = 0
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefMexCountByTech]) == false then
                    for iTech, iCount in tLZTeamData[M28Map.subrefMexCountByTech] do
                        if iTech > 1 then iT2PlusMex = iT2PlusMex + iCount end
                    end
                end
                if iT2PlusMex > 0 then  bIncreaseBPWanted = true end
                --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted,                                          iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting)
                HaveActionToAssign(refActionBuildAA, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted     , nil,              true)
                if bDebugMessages == true then LOG(sFunctionRef..': Minor Zone AA builder if no fixed AA: iBPWanted='..iBPWanted..'; iNearbyEnemyAirToGroundThreat='..iNearbyEnemyAirToGroundThreat..'; tLZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; subrefiAlliedGroundAAThreat='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]..'; iT2PlusMex='..iT2PlusMex..'; bIncreaseBPWanted='..tostring(bIncreaseBPWanted)) end
            end
        end
    end

    --Protect game-ender or similar high avlue target (very high priority on assumption if we have built such a unit we shouldnt have to worry about lack of resources for this
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection]) == false then
        local bContinue = true
        for iUnit, oUnit in tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
            if oUnit[M28Building.reftArtiTemplateRefs] then
                table.remove(tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection], iUnit)
                bContinue = false
                break
            end
        end
        if bContinue then
            if not(tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex].M28Easy) then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to assign units to active shield protection, will list out each unit for this zone that wants active protection')
                    for iUnit, oUnit in tLZTeamData[M28Map.reftoUnitsForSpecialShieldProtection] do
                        LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Mass cost='..oUnit:GetBlueprint().Economy.BuildCostMass)
                    end
                end
                if M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti] then
                    iBPWanted = math.max(100, M28Team.tTeamData[iTeam][M28Team.refiEnemyT3ArtiCount] * 300 + M28Team.tTeamData[iTeam][M28Team.refiEnemyNovaxCount] * 75)
                else
                    iBPWanted = 100
                end


                if bDebugMessages == true then LOG(sFunctionRef..': Special shield defence action iBPWanted='..iBPWanted) end

                --Only use T3 engineers (even if we already have t3 engineers assigned) as want to make sure we can quickly get good concentrated build power
                --function HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist)
                HaveActionToAssign(refActionSpecialShieldDefence, 3, iBPWanted,         nil,                nil,                    nil,                        nil,                            true)
            end
        end
    end

    --Fortify zone (if flagged to fortify)
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefLZFortify] and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 2 then
        local bHaveSufficientTech = false
        local tT2PlusFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory - categories.TECH1, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tT2PlusFactories) == false then
            for iUnit, oUnit in tT2PlusFactories do
                if oUnit:GetFractionComplete() >= 1 and oUnit:GetAIBrain().M28AI then
                    bHaveSufficientTech = true
                    break
                end
            end
        end
        if bHaveSufficientTech then
            --If have capture targets then try and protect these, otherwise base destination on midpoint of the zone
            local tPointForPDConstruction
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoUnitsToCapture]) == false then
                for iUnit, oUnit in tLZTeamData[M28Map.subreftoUnitsToCapture] do
                    if M28UnitInfo.IsUnitValid(oUnit) then
                        tPointForPDConstruction = oUnit:GetPosition()
                        break
                    end
                end
            end
            if not(tPointForPDConstruction) then
                tPointForPDConstruction = M28Utilities.MoveInDirection(tLZData[M28Map.subrefMidpoint], M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase]), 40, true, false, M28Map.bIsCampaignMap)
            end
            local iCurPDThreat = GetPDThreatAboveRangeThresholdAlongPath(iPlateau, iLandZone, tLZData, tLZTeamData, iTeam, 40, tPointForPDConstruction)
            if bDebugMessages == true then LOG(sFunctionRef..': Want PD for a zone that we want to fortify, iCurPDThreat='..(iCurPDThreat or 'nil')..'; Have sufficient tech='..tostring(bHaveSufficientTech)..'; tPointForPDConstruction='..repru(tPointForPDConstruction)..'; Midpoint of zone='..repru(tLZData[M28Map.subrefMidpoint])) end
            if iCurPDThreat <= 2100 then
                iBPWanted = 40
                if not(bHaveLowMass) and not(M28Conditions.HaveLowPower(iTeam)) then iBPWanted = 80 end

                --Get T1 radar in priority to T2 PD if we already have T2 PD but no radar
                if not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and tLZTeamData[M28Map.refiRadarCoverage] <= 40 and tLZTeamData[M28Map.refbWantLandScout] and iCurPDThreat * 1.5 >= (tLZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) then
                    HaveActionToAssign(refActionBuildT1Radar, 1, iBPWanted)
                else

                    local iPDTechLevelWanted = 2
                    HaveActionToAssign(refActionBuildEmergencyPD, iPDTechLevelWanted, iBPWanted, tPointForPDConstruction)
                    if bDebugMessages == true then LOG(sFunctionRef..': Will build PD to fortify zone, iPDTechLevelWanted='..iPDTechLevelWanted..'; iBPWanted='..iBPWanted) end
                end
            end
        end
    end

    --Get T2 arti if we have lots of mexes in this zone
    iCurPriority = iCurPriority + 1
    if not(bTeammateHasBuiltHere) then GiveOrderForEmergencyT2Arti(HaveActionToAssign, bHaveLowMass, bHaveLowPower, iPlateau, iLandZone, tLZData, tLZTeamData, iTeam) end

    --Assign more BP to factories
    iCurPriority = iCurPriority + 1
    if iExistingFactory < iFactoriesWanted then
        --Dont want to build air factories at a core expansion point, instead only want land
        iBPWanted = 10
        if not(bHaveLowMass) then iBPWanted = math.min(30, 3 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]) end
        --[[local bWantAirNotLand = M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData)
    local iFactoryAction
    if bWantAirNotLand then iFactoryAction = refActionBuildAirFactory
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Want to build land factory not air factory5') end
        iFactoryAction = refActionBuildLandFactory
    end--]]
        if bDebugMessages == true then LOG(sFunctionRef..': Want more BP for land factories, iBPWanted='..iBPWanted..' iExistingFactory='..iExistingFactory..'; iFactoriesWanted='..iFactoriesWanted) end
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 750 and M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) then
            HaveActionToAssign(refActionBuildAirFactory, 1, iBPWanted, nil)
        else
            HaveActionToAssign(refActionBuildLandFactory, 1, iBPWanted, nil)
        end
    end

    --Unclaimed mex in the zone
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) == false and not(M28Overseer.bNoRushActive and M28Conditions.NoRushPreventingHydroOrMex(tLZData, true)) then
        iBPWanted = math.max(5, table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations]) * 2.5)
        if bDebugMessages == true then LOG(sFunctionRef..': We have unbuilt mex locations for this land zone, iBPWanted='..iBPWanted..', locations='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefMexUnbuiltLocations])) end
        HaveActionToAssign(refActionBuildMex, 1, iBPWanted)
        if (tLZTeamData[M28Map.subreftiBPWantedByAction][refActionBuildMex] or 0) > 0 then tLZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] = true end
    elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
        --Do we have no engineers assigned to building a mex?
        local bHaveEngisBuilding = false
        if M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
            for iEngi, oEngi in toAssignedEngineers do
                if oEngi[refiAssignedAction] == refActionBuildMex then
                    bHaveEngisBuilding = true
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of assigned engineers empty='..tostring(M28Utilities.IsTableEmpty(toAssignedEngineers))..'; bHaveEngisBuilding='..tostring(bHaveEngisBuilding)) end
        if not(bHaveEngisBuilding) then
            --Refresh list of mexes
            RefreshPartBuiltMexList(tLZTeamData)
            if bDebugMessages == true then LOG(sFunctionRef..': Refreshed part built mex list, is table of part built mexes empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]))) end
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
                HaveActionToAssign(refActionCompletePartBuiltMex, 1, 5)
                if bDebugMessages == true then LOG(sFunctionRef..': Will get engi to complete part built mex') end
            end
        end
    end

    --Zones wanting specific faction engineers (e.g. for shielding game ender)
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftFactoriesWantedForEngineers]) == false then
        local iZoneWantingEngineersOfFaction, iFactionWanted = GetZoneAndFactionForPriorityEngineerTravel(tLZTeamData, iTeam, iLandZone, iPlateau)
        if iZoneWantingEngineersOfFaction and iFactionWanted then
            HaveActionToAssign(refActionMoveToLandZone, 3, 90, iZoneWantingEngineersOfFaction, true, false, iFactionWanted)
        end
    end

    --nearby zones with unclaimed mexes and no engineers traveling there
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have available engineers to send to another LZ. GetHighestTechEngiAvailable='..GetHighestTechEngiAvailable(toAvailableEngineersByTech)) end
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    local iNearbyZonesWantingEngineers = 0
    local iPrevEngisAvailable
    local tLZWantingBPConsidered = {}
    local iAdjLZ
    if iHighestTechEngiAvailable > 0 then
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
            for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                if tPathingDetails[M28Map.subrefLZTravelDist] <= tLZData[M28Map.subrefLZFurthestAdjacentLandZoneTravelDist] then
                    iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                    local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                    if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]) then
                        local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                        if tAdjLZTeamData[M28Map.subrefTbWantBP] and tAdjLZTeamData[M28Map.subrefTBuildPowerByTechWanted][1] > 0 and M28Utilities.IsTableEmpty(tAdjLZData[M28Map.subrefMexUnbuiltLocations]) == false and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEngineersTravelingHere]) and not(tAdjLZTeamData[M28Map.subrefLZCoreExpansion]) and not(tAdjLZTeamData[M28Map.subrefLZbCoreBase]) and M28Utilities.IsTableEmpty(tAdjLZTeamData[M28Map.subrefTEnemyUnits]) then
                            HaveActionToAssign(refActionMoveToLandZone, 1, iNearbyZonesWantingEngineers * 5 + 5, iAdjLZ, true)
                            iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                            iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                            if (tLZTeamData[M28Map.subreftiBPWantedByAction][refActionMoveToLandZone] or 0) > 0 then tLZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] = true end
                            if iHighestTechEngiAvailable == 0 then break end
                        end
                    end
                else
                    break --Table shoudl be sorted closest first so if we are too far away now the later entries should be ignored
                end
            end
        end
    end

    --High priority reclaim if are low on mass or energy
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then
        LOG(sFunctionRef..': Considering if we want high priority reclaim, bHaveLowMass='..tostring(bHaveLowMass)..'; tLZData[M28Map.subrefTotalMassReclaim]='..(tLZData[M28Map.subrefTotalMassReclaim] or 'nil')..'; Significant mass reclaim='..tLZData[M28Map.subrefTotalSignificantMassReclaim])
        M28Land.DrawReclaimSegmentsInLandZone(iPlateau, iLandZone, true)
    end
    if bHaveLowMass and tLZData[M28Map.subrefTotalSignificantMassReclaim] >= 25 then
        local iReclaimFactor = 60
        if GetGameTimeSeconds() <= 540 then iReclaimFactor = 90 end
        iBPWanted = math.min(40, math.max(5, tLZData[M28Map.subrefTotalMassReclaim] / iReclaimFactor))
        if iBPWanted > 15 and GetGameTimeSeconds() <= 540 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 then
            iBPWanted = math.min(iBPWanted, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * 15)
        end
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then iBPWanted = math.max(5, iBPWanted * 0.6) end
        if bDebugMessages == true then LOG(sFunctionRef..': Higher priority reclaim, Total mass in Plateau '..iPlateau..' LZ '..iLandZone..'='..tLZData[M28Map.subrefTotalMassReclaim]) end
        HaveActionToAssign(refActionReclaimArea, 1, iBPWanted, {false, nil})
        if bDebugMessages == true then LOG(sFunctionRef..': Have just tried assigning action to reclaim area') end
    elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= 0.7 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 80 and tLZData[M28Map.subrefLZTotalEnergyReclaim] >= 100 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < 2 then
        HaveActionToAssign(refActionReclaimArea, 1, 5, {true, nil})
    end


    --TMD - TML (including mobile ACUs with TML upgrade)
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftUnitsWantingTMD]) == false and (not(bTeammateHasBuiltHere) or tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 0) then
        iBPWanted = 30
        if not(bHaveLowMass) then iBPWanted = 50 end
        if bDebugMessages == true then LOG(sFunctionRef..': We have untis wanting TMD in LZ '..iLandZone..'; will list out each unit')
            for iUnit, oUnit in tLZTeamData[M28Map.reftUnitsWantingTMD] do
                LOG(sFunctionRef..': Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Unit position='..repru(oUnit:GetPosition()))
            end
        end
        --Get the unit closest to the nearest enemy base to protect first
        local oUnitWantingTMD = M28Building.GetUnitWantingTMD(tLZData, tLZTeamData, iTeam, iLandZone)
        if bDebugMessages == true then LOG(sFunctionRef..': Is oUnitWantingTMD valid='..tostring(M28UnitInfo.IsUnitValid(oUnitWantingTMD))..'; iBPWanted='..iBPWanted) end
        if oUnitWantingTMD then
            HaveActionToAssign(refActionBuildTMD, 2, iBPWanted,  oUnitWantingTMD)
        end
    end

    --Reclaim specific units
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if have units to reclaim, is table empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoUnitsToReclaim]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoUnitsToReclaim]) == false then
        local bObjectiveToReclaim = false
        if M28Map.bIsCampaignMap then
            for iUnit, oUnit in tLZTeamData[M28Map.subreftoUnitsToReclaim] do
                if oUnit[M28UnitInfo.refbIsReclaimTarget] then bObjectiveToReclaim = true break end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Want to reclaim friendly unit, bObjectiveToReclaim='..tostring(bObjectiveToReclaim)) end
        --Dont reclaim power if we have <100% stored or low power
        local bDontReclaimYet = false
        if not(bObjectiveToReclaim) and ((bHaveLowPower) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] <= 0.98) then
            if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryPower, tLZTeamData[M28Map.subreftoUnitsToReclaim])) == false then
                bDontReclaimYet = true
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': About to reclaim a unit but still stop if have low power and we have pgens in the list of units to reclaim, bHaveLowPower='..tostring(bHaveLowPower)..'; Average% stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored]) end
        if not(bDontReclaimYet) then

            if bObjectiveToReclaim or (bHaveLowMass and not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])) then
                HaveActionToAssign(refActionReclaimFriendlyUnit, 1, math.min(1.5 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]], math.max(5, 5 * table.getn(tLZTeamData[M28Map.subreftoUnitsToReclaim]))), nil, false)
            else
                --if have engi in the zone then reclaim it, but dont request an engi
                HaveActionToAssign(refActionReclaimFriendlyUnit, 1, 5, nil, true)
            end
        end
    end

    --Unclaimed hydro in the zone (and we have less than 4k power in our team)
    iCurPriority = iCurPriority + 1
    if not(bTeammateHasBuiltHere) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 400 and M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': We have unbuilt hydro locations for this land zone, locations='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefHydroUnbuiltLocations])) end

        HaveActionToAssign(refActionBuildHydro, 1, 10)
    end

    --SMD if very high value and enemy has nukes
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefLZSValue] >= 60000 or (not(bTeammateHasBuiltHere) and tLZTeamData[M28Map.subrefLZSValue] >= 20000 and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyNukeLaunchers]) == false) or tLZTeamData[M28Map.reftObjectiveSMDLocation] then
        --Make sure we have at least 2 T3 mex in this zone (or no T2 and T1 mexes)
        if (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 or (tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10)) or (tLZTeamData[M28Map.reftObjectiveSMDLocation] and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])) then

            local bAssistSMD = false
            local oSMDToShield, oUnderConstructionShield

            iBPWanted, bAssistSMD, oSMDToShield, oUnderConstructionShield = GetBPToAssignToSMD(iPlateau, iLandZone, iTeam, tLZTeamData, false, bHaveLowMass, bWantMorePower)
            if bDebugMessages == true then LOG(sFunctionRef..': iBPWanted for SMD in minor zone='..(iBPWanted or 'nil')..'; bAssistSMD='..tostring(bAssistSMD or false)..'; oSMDToShield='..(oSMDToShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oSMDToShield) or 'nil')) end
            if iBPWanted > 0 then
                if oUnderConstructionShield then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have under construction shield we want to complete to cover SMD') end
                    HaveActionToAssign(refActionRepairUnit, 1, iBPWanted, oUnderConstructionShield)
                elseif oSMDToShield then
                    iCurPriority = iCurPriority + 1
                    if bDebugMessages == true then LOG(sFunctionRef..': Need to shield the SMD first') end
                    local iTechLevelWanted = 2
                    if (oSMDToShield[refiFailedShieldConstructionCount] or 0) > 0 or (tLZTeamData[M28Map.refiFixedShieldT2EngiFailureCount] or 0) >= 5 then iTechLevelWanted = 3 end
                    HaveActionToAssign(refActionBuildShield, iTechLevelWanted, iBPWanted, oSMDToShield)

                elseif bAssistSMD then
                    iCurPriority = iCurPriority + 2
                    if bDebugMessages == true then LOG(sFunctionRef..': Will assist existing SMD') end
                    HaveActionToAssign(refActionAssistSMD, 1, iBPWanted)
                else
                    iCurPriority = iCurPriority + 3
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to build SMD, iCurPrioriyt='..iCurPriority) end
                    HaveActionToAssign(refActionBuildSMD, 3, iBPWanted)
                end
            else
                iCurPriority = iCurPriority + 3
            end
        else
            iCurPriority = iCurPriority + 3
        end
    else
        iCurPriority = iCurPriority + 3
    end

    --TML (will only trigger atm for core expansions)
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefLZCoreExpansion] then --Redundancy - getbptoassign function also includes this condition; however might be faster by having ith ere as an excluding factor?
        iBPWanted = GetBPToAssignToBuildingTML(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam, bHaveLowMass)
        if iBPWanted > 0 then
            HaveActionToAssign(refActionBuildTML, 2, iBPWanted)
        end
    end

    --Multiple mex upgrades (minor zone) - want to assist as a higher priority
    iCurPriority = iCurPriority + 1
    if (tLZTeamData[M28Map.subrefiActiveMexUpgrades] or 0) >= 2 and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) then
        iBPWanted = 10
        if not(bHaveLowPower) then
            iBPWanted = tLZTeamData[M28Map.subrefiActiveMexUpgrades] * 10
        end
        HaveActionToAssign(refActionAssistUpgrade, 1, iBPWanted)
    end

    --Shielding
    iCurPriority = iCurPriority + 1
    local iTechLevelWanted, oUnitToShield
    iBPWanted, iTechLevelWanted, oUnitToShield = GetBPMinTechAndUnitForFixedShields(tLZData, tLZTeamData, iTeam, false, bHaveLowMass, bWantMorePower, false, iLandZone, iPlateau)
    if bDebugMessages == true then LOG(sFunctionRef..': Minor zone results of BP for shielding='..(iBPWanted or 'nil')..'; iTechLevelWanted='..(iTechLevelWanted or 'nil')..'; iCurPriority='..iCurPriority) end
    if iBPWanted > 0 then
        if bTeammateHasBuiltHere then
            if bHaveLowMass then iBPWanted = 5
            else
                iBPWanted = iBPWanted * 0.5
            end
        end
        HaveActionToAssign(refActionBuildShield, iTechLevelWanted, iBPWanted, oUnitToShield)
        if bDebugMessages == true then LOG(sFunctionRef..': Have just tried to assign an action to shield unit '..oUnitToShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToShield)) end
    end

    --Units to capture
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of units to capture empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]))) end
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]) == false then
        --Refresh the list
        local iCaptureCount = table.getn(tLZData[M28Map.subreftoUnitsToCapture])
        for iCurCount = iCaptureCount, 1, -1 do
            if not(M28UnitInfo.IsUnitValid(tLZData[M28Map.subreftoUnitsToCapture][iCurCount])) then
                table.remove(tLZData[M28Map.subreftoUnitsToCapture], iCurCount)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Have units to capture for zone '..iLandZone..', after freshing them is table empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]))) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToCapture]) == false then
            --Dont capture if are a hostile AI due to the risk we capture a campaign objective and progress the map
            if not(ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].HostileCampaignAI) then
                local oUnitToCapture
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 75 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                    local tPotentialCapture = EntityCategoryFilterDown(categories.ALLUNITS - M28UnitInfo.refCategoryT3Power, tLZData[M28Map.subreftoUnitsToCapture])
                    if M28Utilities.IsTableEmpty(tPotentialCapture) == false then
                        oUnitToCapture = M28Utilities.GetNearestUnit(tPotentialCapture, tLZData[M28Map.subrefMidpoint])
                    end
                else
                    oUnitToCapture = M28Utilities.GetNearestUnit(tLZData[M28Map.subreftoUnitsToCapture], tLZData[M28Map.subrefMidpoint])
                end
                if oUnitToCapture then
                    if bDebugMessages == true then LOG(sFunctionRef..': Unit to cpature='..oUnitToCapture.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToCapture)) end
                    iBPWanted = GetCaptureBPWanted(oUnitToCapture, bHaveLowPower, iTeam, tLZTeamData[M28Map.subrefLZbCoreBase])
                    HaveActionToAssign(refActionCaptureUnit, 1, iBPWanted, oUnitToCapture)
                end
            end

        end
    end

    --Units to repair
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of units to repair empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToRepair]))..'; iTeam='..iTeam) end
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToRepair]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Have units to repair for zone '..iLandZone..' is table empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subreftoUnitsToRepair]))) end
        if M28Conditions.IsTableOfUnitsStillValid(tLZData[M28Map.subreftoUnitsToRepair], true) then
            local oUnitToTarget = M28Utilities.GetNearestUnit(tLZData[M28Map.subreftoUnitsToRepair], tLZData[M28Map.subrefMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': Unit to repair='..oUnitToTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToTarget)..'; will flag we want some BP for this') end
            HaveActionToAssign(refActionRepairUnit, 1, 5, oUnitToTarget)
        end
    end

    --late game power (in case running out of space in core zone)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if we want power in minor zone, bHaveLowPower='..tostring(bHaveLowPower)..'; tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Mass % stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; bHaveLowMass='..tostring(bHaveLowMass)..'; MexT3 count='..tLZTeamData[M28Map.subrefMexCountByTech][3]..'; tLZTeamData[M28Map.subrefLZSValue]='..tLZTeamData[M28Map.subrefLZSValue]..'; iExistingFactory='..iExistingFactory) end
    if not(bTeammateHasBuiltHere) and (bHaveLowPower or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.8 and M28Conditions.WantMorePower(iTeam))) and not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and not(bHaveLowMass) and (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 3 or tLZTeamData[M28Map.subrefLZSValue] >= 10000 or (bAdjacentToCoreZone and tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1)) then
        --Either adjacent to core zone, or have a land fac in this zone, or relatively close to our base
        if bDebugMessages == true then LOG(sFunctionRef..': tLZTeamData[M28Map.refiModDistancePercent]='..tLZTeamData[M28Map.refiModDistancePercent]..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]) end
        if bAdjacentToCoreZone or iExistingFactory > 0 or tLZTeamData[M28Map.refiModDistancePercent] <= 0.15 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.95 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 3000) then
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 350 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.35 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.7 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 30 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 80 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 900 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) then
                iBPWanted = 90
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.85 then iBPWanted = 180 end
                HaveActionToAssign(refActionBuildPower, 3, iBPWanted)
            end
        end
    end

    --Shield assistance
    iCurPriority = iCurPriority + 1
    if not(bTeammateHasBuiltHere) then
        iBPWanted = GetBPForShieldAssistance(tLZTeamData, iTeam)
        if iBPWanted > 0 then
            HaveActionToAssign(refActionAssistShield, 1, iBPWanted)
        end
    end

    iCurPriority = iCurPriority + 1
    --(ANY CHANGES TO BELOW - CONSIDER REPLICATING FOR BOTH CORE AND NONCORE BUILDERS) Adjacent LZ that wants engineers and has unbuilt mexes (only chekc if we have available engineers)
    --(as of v24 decided to go with differences for the minior LZ (which uses a simplified appraoch) vs core base highest priority for adj LZs
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have available engineers to send to another LZ. GetHighestTechEngiAvailable='..GetHighestTechEngiAvailable(toAvailableEngineersByTech)) end
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
            for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                if tPathingDetails[M28Map.subrefLZTravelDist] <= tLZData[M28Map.subrefLZFurthestAdjacentLandZoneTravelDist] then
                    iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]

                    --tLZWantingBPConsidered[iAdjLZ] = true --Are now adding in the condition that the zone has unbuilt mexes
                    --Require unbuilt mexes:
                    local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, iAdjLZ, iPathingRef, iHighestTechEngiAvailable, true, false, true)
                    if tiBPByTechWanted then
                        for iTech = 1, iHighestTechEngiAvailable, 1 do
                            if tiBPByTechWanted[iTech] > 0 then
                                iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                HaveActionToAssign(refActionMoveToLandZone, iTech, iNearbyZonesWantingEngineers * 5 + tiBPByTechWanted[iTech], iAdjLZ, true)
                                if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                    iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                end

                                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                if iHighestTechEngiAvailable == 0 then break end
                            end
                        end
                    end
                    if iHighestTechEngiAvailable == 0 then break end
                else
                    break --Table shoudl be sorted closest first so if we are too far away now the later entries should be ignored
                end
            end
        end
    end

    iCurPriority = iCurPriority + 1
    --If have adjacent waterzone that has unbuilt mexes, wants engineers and has no combat threat then assign engi unelss it already has engis and we dont have many in this zone
    if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..'; Checking if adjacent water zones that want engis to build mexes, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
    local iCoreWZWantingSupportAsLowerPriority
    if iHighestTechEngiAvailable > 0 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
        local iCurWZ, iCurPond
        local iBPAlreadyAssigned = 0
        local bConsiderWaterZone
        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
            --Use similar logic to core land zone to avoid unintended consequences
            iCurWZ = tSubtable[M28Map.subrefAWZRef]
            iCurPond = M28Map.tiPondByWaterZone[iCurWZ]
            local tWZData = M28Map.tPondDetails[iCurPond][M28Map.subrefPondWaterZones][iCurWZ]
            if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent water zone iCurWZ='..iCurWZ..'; iCurPond='..iCurPond..'; Is table of unbuilt mex locations empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]))) end
            local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
            bConsiderWaterZone = false
            if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tWZData[M28Map.subrefMidpoint]) then
                if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]) == false then
                    bConsiderWaterZone = true
                elseif tWZTeamData[M28Map.subrefWZbCoreBase] and tWZTeamData[M28Map.subrefTbWantBP] then
                    --Do we already have a completed naval factory here and at least 1 engineer? if so not as high priority
                    bConsiderWaterZone = true
                    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                        local tFactoriesAndEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                        if M28Utilities.IsTableEmpty(tFactoriesAndEngineers) == false then
                            local iEngiCount = 0
                            local iCompletedFactoryCount = 0
                            for iUnit, oUnit in tFactoriesAndEngineers do
                                if oUnit:GetFractionComplete() == 1 then
                                    if EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oUnit.UnitId) then
                                        iCompletedFactoryCount = iCompletedFactoryCount + 1
                                    else
                                        iEngiCount = iEngiCount + 1
                                    end
                                end
                            end
                            if iCompletedFactoryCount > 0 and iCompletedFactoryCount + iEngiCount >= 3 then
                                bConsiderWaterZone = false
                            end
                        end
                    end
                    if not(bConsiderWaterZone)  and tWZTeamData[M28Map.subrefTbWantBP] then iCoreWZWantingSupportAsLowerPriority = iCurWZ end
                end
            end
            if bConsiderWaterZone then

                --or (tWZTeamData[M28Map.subrefWZbCoreBase] and (M28Utilities.IsTableEmpty(tWZTeamData[M28Map. then

                if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to send engineers to an adjaent water zone, iCurWZ='..iCurWZ..'; tWZTeamData[M28Map.subrefTbWantBP]='..tostring(tWZTeamData[M28Map.subrefTbWantBP] or false)) end
                if tWZTeamData[M28Map.subrefTbWantBP] and tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 10 then
                    iBPWanted = 5
                    if tWZTeamData[M28Map.subrefTbWantBP] then
                        iBPWanted = math.min(50, math.max(tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]], tWZTeamData[M28Map.subrefTBuildPowerByTechWanted][1]))
                    end
                    HaveActionToAssign(refActionMoveToWaterZone, 1, iBPWanted + iBPAlreadyAssigned, iCurWZ, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': BP wanted+BP assigned='..iBPWanted + iBPAlreadyAssigned) end
                    iBPAlreadyAssigned = iBPAlreadyAssigned + iBPWanted
                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                    if iHighestTechEngiAvailable == 0 or iBPAlreadyAssigned >= tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 3 then break end
                end
            end
        end
    end

    --High priority islands (early-game expansion)
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS)
    iCurPriority = iCurPriority + 1
    local iBPAlreadyTraveling = 0
    GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if bDebugMessages == true then LOG(sFunctionRef..': Core LZ considering engis for islands, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Time='..GetGameTimeSeconds()) end
    if iHighestTechEngiAvailable > 0 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of pathing to other islands empty='..tostring(tLZData[M28Map.subrefLZPathingToOtherIslands])) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
            local iDistanceThreshold = math.max(125, M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) * 0.502)
            if bDebugMessages == true then LOG(sFunctionRef..': iDistanceThreshold='..iDistanceThreshold) end

            for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iEntry='..iEntry..'; Travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; tPathingData[M28Map.subrefIslandClosestLZRef]='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; Are there enemies in this or adjacnet LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                if tPathingData[M28Map.subrefIslandTravelDist] > iDistanceThreshold then break
                else
                    --Are there enemies in the target LZ?
                    local tIslandLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]]
                    if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tIslandLZData[M28Map.subrefMidpoint]) then
                        if tPathingData[M28Map.subrefIslandClosestLZRef] and M28Utilities.IsTableEmpty(tIslandLZData[M28Map.subrefMexUnbuiltLocations]) == false and not(tIslandLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                            local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, tPathingData[M28Map.subrefIslandClosestLZRef], iEntry, iHighestTechEngiAvailable, false, true)
                            if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                            if tiBPByTechWanted then
                                --Is it either a minor zone, or a core zone that either wants lots of BP or doesnt have any engineers traveling to it?
                                for iTech = 1, iHighestTechEngiAvailable, 1 do
                                    if tiBPByTechWanted[iTech] > 0 then
                                        iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                        iBPWanted = iBPAlreadyTraveling + 5
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and assign an engineer to go to tPathingData[M28Map.subrefIslandClosestLZRef]='..tPathingData[M28Map.subrefIslandClosestLZRef]..'; BP wanted='..iBPWanted..'; iTech='..iTech..'; iPrevEngisAvailable='..iPrevEngisAvailable) end
                                        HaveActionToAssign(refActionMoveToLandZone, iTech, iBPWanted, tPathingData[M28Map.subrefIslandClosestLZRef], true)
                                        if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                            iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                            iBPAlreadyTraveling = iBPAlreadyTraveling + tiBPByTech[iTech]
                                        end

                                        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                        if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable after this='..iHighestTechEngiAvailable) end
                                        if iHighestTechEngiAvailable == 0 then break end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    --AA if approaching enemy air threat and have significant mexes here
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= math.max(400, tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] * 2) and (M28Team.tAirSubteamData[ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].M28AirSubteam][M28Team.refbFarBehindOnAir] or M28Team.tTeamData[iTeam][M28Team.subrefiOurAirAAThreat] < M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.5) then
        local iGroundAAWanted = 150 * (tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] * 4)
        if bHaveLowMass then iGroundAAWanted = iGroundAAWanted * 0.5 end
        local iNearbyEnemyAirToGroundThreat = tLZTeamData[M28Map.refiEnemyAirToGroundThreat]
        M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint])
        for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
            if tSubtable[M28Map.subrefiDistance] >= 200 then break end
            local tAltLZOrWZTeamData
            if not(tSubtable[M28Map.subrefbIsWaterZone]) then
                tAltLZOrWZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]][M28Map.subrefLZTeamData][iTeam]
            else
                tAltLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[tSubtable[M28Map.subrefiLandOrWaterZoneRef]]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]][M28Map.subrefWZTeamData][iTeam]
            end
            iNearbyEnemyAirToGroundThreat = iNearbyEnemyAirToGroundThreat + (tAltLZOrWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0)
        end
        if bHaveLowMass then iGroundAAWanted = math.max(iGroundAAWanted,  iNearbyEnemyAirToGroundThreat * 0.4)
        else iGroundAAWanted = math.max(iGroundAAWanted, iNearbyEnemyAirToGroundThreat * 0.8)
        end
        iGroundAAWanted = math.min(iGroundAAWanted, 2000)
        if bDebugMessages == true then LOG(sFunctionRef..': Approaching air threat, tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] ='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]..'; iGroundAAWanted='..iGroundAAWanted..'; Team air to ground threat='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]) end
        if tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < iGroundAAWanted then
            iBPWanted = tiBPByTech[math.max(iHighestTechEngiAvailable, 1)]
            if (tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0) >= 600 then
                if (tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] or 0) >= 1500 then
                    HaveActionToAssign(refActionBuildAA, math.max(2, iHighestTechEngiAvailable, M28Team.tTeamData[iTeam][M28Team.subrefiLowestFriendlyLandFactoryTech]), iBPWanted)
                else
                    HaveActionToAssign(refActionBuildAA, math.max(2, iHighestTechEngiAvailable), iBPWanted)
                end
            else
                HaveActionToAssign(refActionBuildAA, math.max(1, iHighestTechEngiAvailable), iBPWanted)
            end
        end
    end


    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPToAssignToAssistUpgrade(tLZTeamData, iTeam, false, bHaveLowMass, bHaveLowPower, bWantMorePower)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionAssistUpgrade, 1, iBPWanted)
    end

    --Build mass storage if we have T2+ mexes
    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPToAssignToMassStorage(iPlateau, iLandZone, iTeam, tLZData, tLZTeamData, true, bHaveLowMass, bWantMorePower)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionBuildMassStorage, 1, iBPWanted)
    end

    --Lower priority mass reclaim
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Lower priority reclaim if want mass, Total mass reclaim in zone='..(tLZData[M28Map.subrefTotalMassReclaim] or 'nil')..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Lowest mass % stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; Signif mass reclaim='..tLZData[M28Map.subrefTotalSignificantMassReclaim]) end
    if (bHaveLowMass or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.35 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.5 and tLZData[M28Map.subrefTotalSignificantMassReclaim] >= 125)) and tLZData[M28Map.subrefTotalMassReclaim] >= 5 then
        local iReclaimFactor = 25
        if GetGameTimeSeconds() <= 540 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 2 then
            iReclaimFactor = 100
            if bHaveLowMass and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.1 and tLZData[M28Map.subrefTotalSignificantMassReclaim] >= 400 then iReclaimFactor = 75 end
        end
        iBPWanted = math.min(40, math.max(5, tLZData[M28Map.subrefTotalMassReclaim] / iReclaimFactor))
        if iBPWanted > 15 and GetGameTimeSeconds() <= 540 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 then
            iBPWanted = math.min(iBPWanted, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * 10)
        end
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then iBPWanted = math.max(5, iBPWanted * 0.6) end

        if bDebugMessages == true then LOG(sFunctionRef..': Lower priority reclaim, Total mass in Plateau '..iPlateau..' LZ '..iLandZone..'='..tLZData[M28Map.subrefTotalMassReclaim]..'; iBPWanted='..iBPWanted) end
        HaveActionToAssign(refActionReclaimArea, 1, iBPWanted, {false, nil})
    end

    --SAMs for minor zones
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefLZSValue] >= 1500 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and (tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] > 0 or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 1000 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3) and (not(bTeammateHasBuiltHere) or tLZTeamData[M28Map.subrefMexCountByTech][3] > 0) then
        local iGroundAAWanted = math.max(1600, M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.2)
        if (not(M28Team.tAirSubteamData[ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].M28AirSubteam][M28Team.refbHaveAirControl] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 8) or (not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20 and M28Team.tTeamData[iTeam][M28Team.subrefiOurGunshipThreat] >= 2000)) and tLZTeamData[M28Map.subrefLZSValue] >= 1500 then
            iGroundAAWanted = math.max(3200, M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.25 + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] * 0.05)
        end
        if iGroundAAWanted > math.max(7000, tLZTeamData[M28Map.subrefLZSValue] * 0.5) then
            iGroundAAWanted = math.max(7000, math.min(iGroundAAWanted, tLZTeamData[M28Map.subrefLZSValue] * 0.5, 4000 * tLZTeamData[M28Map.subrefMexCountByTech][3]  + 1000 * tLZTeamData[M28Map.subrefMexCountByTech][2]))
        end
        --Cap amount of AA wanted

        if iGroundAAWanted > 8000 then
            if iGroundAAWanted > 20000 and tLZTeamData[M28Map.subrefMexCountByTech][3] < 4 then iGroundAAWanted = 20000 end
            local iAboveThresholdFactor = 1
            if bHaveLowMass then iAboveThresholdFactor = 0.75 end
            if bHaveLowPower then iAboveThresholdFactor = iAboveThresholdFactor * 0.75 end
            if M28Team.tAirSubteamData[ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].M28AirSubteam][M28Team.refbHaveAirControl] then iAboveThresholdFactor = iAboveThresholdFactor * 0.75 end
            if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] < 12000 then iAboveThresholdFactor = iAboveThresholdFactor * 0.75 end
            if tLZTeamData[M28Map.subrefMexCountByTech][3] < 2 then iAboveThresholdFactor = iAboveThresholdFactor * 0.75 end
            iGroundAAWanted = 8000 + (iGroundAAWanted - 8000) * iAboveThresholdFactor
            if bDebugMessages == true then LOG(sFunctionRef..': We did want more than 8k groundAA threat, reduced to '..iGroundAAWanted..'; iAboveThresholdFactor=;..iAboveThresholdFactor') end
        end

        if tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < iGroundAAWanted then
            --Do we already have fixed AA in this LZ?
            local iAACategory = M28UnitInfo.refCategoryStructureAA
            if M28Team.subrefiHighestFriendlyFactoryTech >= 3 then
                iAACategory = iAACategory * categories.TECH3
            end
            local tExistingFixedAA = EntityCategoryFilterDown(iAACategory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            --Max of 1 sam per 1 T3 mex (approx), more if we have large gunship threat and lack air control
            if M28Utilities.IsTableEmpty(tExistingFixedAA) or tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] < math.max(iNearbyEnemyAirToGroundThreat * 2, iGroundAAWanted) then
                --Further cap on number of SAMs
                if bDebugMessages == true then LOG(sFunctionRef .. ': tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]=' .. tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] .. '; iNearbyEnemyAirToGroundThreat=' .. iNearbyEnemyAirToGroundThreat .. '; iGroundAAWanted=' .. iGroundAAWanted) end
                if not (bHaveLowMass and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) and tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] >= 6000 and (tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][1]) > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] > 15 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                    iBPWanted = tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
                    if iNearbyEnemyAirToGroundThreat > 0 then
                        iBPWanted = iBPWanted * 2
                    end
                    if not (bHaveLowPower) then
                        if not (bHaveLowMass) then
                            iBPWanted = iBPWanted * 4
                        else
                            iBPWanted = iBPWanted * 2
                        end
                    end
                    HaveActionToAssign(refActionBuildAA, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], iBPWanted)
                    if bDebugMessages == true then LOG(sFunctionRef .. ': Wnat more AA for minor zone, iBPWanted=' .. iBPWanted) end
                end
            end
        end
    end

    --Higher priority T2 radar creep where we have large mass income or lots of experimentals
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': T2 radar creep - bHaveLowMass='..tostring(bHaveLowMass)..'; bWantMorePower='..tostring(bWantMorePower)..'; Radar coverage='..tLZTeamData[M28Map.refiRadarCoverage]..'; Map size='..M28Map.iMapSize..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; tLZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
    if not(bHaveLowPower) and tLZTeamData[M28Map.subrefLZSValue] >= 3000 and not(bTeammateHasBuiltHere) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 300 and tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1 and tLZTeamData[M28Map.refiRadarCoverage] < 250 and tLZTeamData[M28Map.refiRadarCoverage] < 170 and (tLZTeamData[M28Map.refiRadarCoverage] < 130 or not(bHaveLowMass)) and M28Map.iMapSize > 600 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 60 and (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 150) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 and M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryLandExperimental + M28UnitInfo.refCategoryBomber * categories.EXPERIMENTAL) >= 4 then
        --Check we dont have any radar here already (redundancy for radar coverage)
        local tExistingRadar = EntityCategoryFilterDown(M28UnitInfo.refCategoryRadar, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local bHaveRadar = false
        if M28Utilities.IsTableEmpty(tExistingRadar) == false then
            for iUnit, oUnit in tExistingRadar do
                if oUnit:GetFractionComplete() >= 1 then
                    bHaveRadar = true
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveRadar='..tostring(bHaveRadar)) end
        if not(bHaveRadar) then
            --Are we able to build radar? assume we can if we have access to T3 factories for simplicity
            if not(M28Map.bIsCampaignMap) or not(M28Overseer.bUnitRestrictionsArePresent) or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then
                HaveActionToAssign(refActionBuildT2Radar, 2, 10)
            end
        end
    end

    --Lower priority LZs wanting engineers:
    iCurPriority = iCurPriority + 1
    if iCoreWZWantingSupportAsLowerPriority and iHighestTechEngiAvailable > 0 then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if iHighestTechEngiAvailable > 0 then
            HaveActionToAssign(refActionMoveToWaterZone, 1, tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]], iCoreWZWantingSupportAsLowerPriority, true)
        end
    end
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS) Other non adjacent LZ on this plateau that wants engineers (low priority) - prioritise those nearest this zone
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if bDebugMessages == true then LOG(sFunctionRef..': About to check for further away zones wanting BP, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; iCurPriority='..iCurPriority) end
    if iHighestTechEngiAvailable > 0 then
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
            for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                if bDebugMessages == true then LOG(sFunctionRef..': Lower priority logic to send engineers to another LZ, iAdjLZ='..iAdjLZ..'; Have we alreayd considered='..tostring(tLZWantingBPConsidered[iAdjLZ] or false)) end
                if not(tLZWantingBPConsidered[iAdjLZ]) then
                    tLZWantingBPConsidered[iAdjLZ] = true
                    local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, iAdjLZ, iPathingRef, iHighestTechEngiAvailable, false)
                    if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                    if tiBPByTechWanted then
                        for iTech = 1, iHighestTechEngiAvailable, 1 do
                            if tiBPByTechWanted[iTech] > 0 then
                                iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                HaveActionToAssign(refActionMoveToLandZone, iTech, (iNearbyZonesWantingEngineers + 1) * 5, iAdjLZ, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': Sending engineers to nearby zone, BPWanted='..(iNearbyZonesWantingEngineers + 1) * 5) end
                                if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                    iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                end

                                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                if iHighestTechEngiAvailable == 0 then break end
                            end
                        end
                    end
                end
                if iHighestTechEngiAvailable == 0 then break end
            end
        end
    end

    --Islands wanting engineers (provided we dont have adjacent naval threats)
    --(ANY CHANGES TO BELOW - REPLICATE FOR BOTH CORE AND NONCORE BUILDERS)
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': About to check if minor LZ wants to send engis to an island, iHighestTechEngiAvailable='..iHighestTechEngiAvailable) end
    local iIslandDistanceThreshold
    if iHighestTechEngiAvailable > 0 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
        if bDebugMessages == true then LOG(sFunctionRef..': is pathing to other islands empty='..tostring( M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]))) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; tLZTeamData[M28Map.reftClosestEnemyBase]='..repru(tLZTeamData[M28Map.reftClosestEnemyBase])..'; tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint])) end
            iIslandDistanceThreshold = M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefMidpoint]) * 0.6
            if M28Map.bIsCampaignMap then iIslandDistanceThreshold = iIslandDistanceThreshold * 1.5 end
            if bDebugMessages == true then LOG(sFunctionRef..': Will search for islands, iIslandDistanceThreshold='..iIslandDistanceThreshold) end

            for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering island '..tPathingData[M28Map.subrefIslandNumber]..'; travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; Closest LZ ref='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; are enemies in this or adjacent LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                if tPathingData[M28Map.subrefIslandTravelDist] > iIslandDistanceThreshold then break
                else
                    --Are there enemies in the target LZ?
                    if tPathingData[M28Map.subrefIslandClosestLZRef] and not(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                        local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, tPathingData[M28Map.subrefIslandClosestLZRef], iEntry, iHighestTechEngiAvailable, false, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                        if tiBPByTechWanted then
                            --Is it either a minor zone, or a core zone that either wants lots of BP or doesnt have any engineers traveling to it?
                            for iTech = 1, iHighestTechEngiAvailable, 1 do
                                if tiBPByTechWanted[iTech] > 0 then
                                    iPrevEngisAvailable = table.getn(toAvailableEngineersByTech[iTech])
                                    HaveActionToAssign(refActionMoveToLandZone, iTech, math.max((iNearbyZonesWantingEngineers + 1) * 5, tiBPByTechWanted[iTech]), tPathingData[M28Map.subrefIslandClosestLZRef], true)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished trying to give order for engi to move to the island LZ, table.getn(toAvailableEngineersByTech[iTech])='..table.getn(toAvailableEngineersByTech[iTech])..'; iPrevEngisAvailable='..iPrevEngisAvailable) end
                                    if table.getn(toAvailableEngineersByTech[iTech]) < iPrevEngisAvailable then
                                        iNearbyZonesWantingEngineers = iNearbyZonesWantingEngineers + 1
                                    end

                                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                    if iHighestTechEngiAvailable == 0 then break end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    --If have are overflowing mass and have high income, energy, and are at T3, and this zone has mexes and no enemy units then get land factories if <=2, or an experimental or T3 power otherwise
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 3 and not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 750 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 30 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1000 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.6) and not(bTeammateHasBuiltHere) then
        --We need at least 1 T3 mex in the zone and no enemy units
        if tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) then
            local iExistingFactories = 0
            local tExistingLandFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tExistingLandFactories) == false then
                iExistingFactories = table.getn(tExistingLandFactories)
            end
            local bBuiltParagon = ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Economy.refbBuiltParagon]
            if (iExistingFactories < 2 or (bBuiltParagon and iExistingFactories < 3)) and M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone) then
                --Build air fac if in very higih mass scenario such as having a paragon
                if ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Economy.refbBuiltParagon] then
                    if bDebugMessages == true then LOG(sFunctionRef..': want air fac as we have paragon') end
                    HaveActionToAssign(refActionBuildAirFactory, 1, 40)
                else
                    --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting)
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to build land factory as only have 1 factory') end
                    HaveActionToAssign(refActionBuildLandFactory, 1, 40)
                end
            else
                --Build land experimental if enemy base is pathable by land from here and we have high gross mass, and we have a high % stored or low mod dist
                if bBuiltParagon or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 60 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 6 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.8 or tLZTeamData[M28Map.refiModDistancePercent] <= 0.1)) then
                    --If we have stalled power recently then build power, otherwise get experimental
                    if bWantMorePower and (bHaveLowPower or GetGameTimeSeconds() - M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or -100 <= 30) then
                        HaveActionToAssign(refActionBuildPower, 3, 60, nil, false, true)
                    else
                        if bBuiltParagon or (M28Team.tTeamData[iTeam][M28Team.refiConstructedExperimentalCount] >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.9) then
                            if (NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) or 0) == (NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefMidpoint]) or -1) and (tLZTeamData[M28Map.refiModDistancePercent] >= 0.35 or M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase]) <= 350) then
                                HaveActionToAssign(refActionBuildLandExperimental, 3, 60, nil, false, true)
                            else
                                HaveActionToAssign(refActionBuildExperimental, 3, 60, nil, false, true)
                            end
                        end
                    end
                end
            end
        end
    end

    --If still have an engineer available and have an adjacent LZ that wants BP and doesnt have any enemies in that LZ specifically (even if there might be in an adjacent one) then send engineer
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then

        if bDebugMessages == true then LOG(sFunctionRef..': Table of adjacnet LZs='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones])) end
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
            local iBPAlreadyTraveling = 0
            if M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
                for iEngi, oEngi in toAssignedEngineers do
                    if oEngi[refiAssignedAction] == refActionMoveToLandZone then
                        iBPAlreadyTraveling = iBPAlreadyTraveling + oEngi:GetBlueprint().Economy.BuildRate
                    end
                end
            end

            for _, iAdjLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iAdjLZ='..iAdjLZ..'; Does it want BP='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP])..'; Combat threat='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal]) end
                if not(tLZWantingBPConsidered[iAdjLZ]) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTbWantBP] and (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTBuildPowerByTechWanted][1] or 0) > 0 and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefTThreatEnemyCombatTotal] == 0 then
                    HaveActionToAssign(refActionMoveToLandZone, 1, iBPAlreadyTraveling + 5, iAdjLZ, true)
                    iBPAlreadyTraveling = iBPAlreadyTraveling + 5
                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                    if iHighestTechEngiAvailable == 0 then break end
                end
            end
        end
    end


    --Adjacent water zones that want an engineer
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have adjacent WZ that wants engineer, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Is table of adjacent water zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]))) end
    if iHighestTechEngiAvailable > 0 and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefAdjacentWaterZones]) == false then
        local iCurWZ
        local iCurPond
        local bWantBPOfOurTech
        local iMinTechWanted = 1
        for iEntry, tSubtable in tLZData[M28Map.subrefAdjacentWaterZones] do
            iCurWZ = tSubtable[M28Map.subrefAWZRef]
            iCurPond = M28Map.tiPondByWaterZone[iCurWZ]
            local tWZData = M28Map.tPondDetails[iCurPond][M28Map.subrefPondWaterZones][iCurWZ]
            if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tWZData[M28Map.subrefMidpoint]) then
                local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to send engineers to an adjaent water zone, iCurWZ='..iCurWZ..'; tWZTeamData[M28Map.subrefTbWantBP]='..tostring(tWZTeamData[M28Map.subrefTbWantBP] or false)) end
                if tWZTeamData[M28Map.subrefTbWantBP] then
                    bWantBPOfOurTech = false
                    for iTech = iHighestTechEngiAvailable, 1, -1 do
                        if tWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                            bWantBPOfOurTech = true
                            iMinTechWanted = iTech
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': bWantBPOfOurTech='..tostring(bWantBPOfOurTech)) end
                    if bWantBPOfOurTech then
                        HaveActionToAssign(refActionMoveToWaterZone, iMinTechWanted, math.min(tiBPByTech[iMinTechWanted] * 2, 50), iCurWZ, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': have tried to send BP of '..(tiBPByTech[iMinTechWanted] * 2)..' to iCurWZ '..iCurWZ) end
                        break
                    end
                end
                if bWantBPOfOurTech then break end
            end
        end
    end

    --Extra (second) shielding in a high mass scenario - will only try to shield t3 arti/game ender
    iCurPriority = iCurPriority + 1
    if (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 500 and not(bTeammateHasBuiltHere) then
        local iBPWanted, iTechLevelWanted, oUnitToShield = GetBPMinTechAndUnitForFixedShields(tLZData, tLZTeamData, iTeam, true, bHaveLowMass, bWantMorePower, true, iLandZone, iPlateau)
        if iBPWanted > 0 then
            iBPWanted = math.min(iBPWanted, 40)

            HaveActionToAssign(refActionBuildSecondShield, iTechLevelWanted, iBPWanted, oUnitToShield)
            if bDebugMessages == true then LOG(sFunctionRef..': High priority shield builder, iBPWanted='..iBPWanted) end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Dont want to assign any BP to high priority shield builder') end
        end
    end

    --Pre-emptive AA turret
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1 and not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and (not(bHaveLowMass) or tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2) and not(bHaveLowPower) then
        --Are we likely on a small island/plateau (due to having at least 50% of the island's mexes)? Or we have significant value here?
        if tLZData[M28Map.subrefLZMexCount] >= 0.5 * M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandMexCount][tLZData[M28Map.subrefLZIslandRef]] or tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1 then
            if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 300 then
                local iAAWanted = math.min(150 * (tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] * 4), M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 0.25 + (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] or 0) * 0.05)
                if not(bHaveLowMass) and not(bHaveLowPower) and tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyAirTech] >= 3 then iAAWanted = math.max(iAAWanted, 1500) end
                if M28Team.tAirSubteamData[ArmyBrains[tLZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].M28AirSubteam][M28Team.refbHaveAirControl] then iAAWanted = iAAWanted * 0.25 end
                if bDebugMessages == true then LOG(sFunctionRef..': iAAWanted='..iAAWanted..'; tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]='..tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]..'; tLZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]) end
                if iAAWanted > tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] then
                    if tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] >= 700 then
                        HaveActionToAssign(refActionBuildAA, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech], 5)
                    else
                        HaveActionToAssign(refActionBuildAA, 1, 5)
                    end
                end
            end
        end
    end


    --Low priority power builder if we have lots of mass and dont have much power
    iCurPriority = iCurPriority + 1
    if not(bTeammateHasBuiltHere) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 75 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.5 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < math.max(250, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.5) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 20) then
        local iMinTechLevelForPower = 1
        --[[if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 then
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 22 then iMinTechLevelForPower = 1
    elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] < 110 then iMinTechLevelForPower = 2
    end
end--]]
        HaveActionToAssign(refActionBuildPower, iMinTechLevelForPower, tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 6)
    end

    --Low priority air staging, if we have T3 mex, decent intel coverage, no nearby enemies, low mod distance, and need air staging
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': About to check if we need air staging for core zone, Time='..GetGameTimeSeconds()..'; Time of last shortage='..(M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastAirStagingShortage] or 'nil')) end
    if not(bTeammateHasBuiltHere) and tLZTeamData[M28Map.refiModDistancePercent] <= 0.2 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastAirStagingShortage] or 0) <= 1.1 and not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and (tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][2] >= 3) and tLZTeamData[M28Map.refiRadarCoverage] >= 100 then
        local tExistingAirStaging = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirStaging, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local iExistingAirStaging = 0
        if M28Utilities.IsTableEmpty(tExistingAirStaging) == false then
            for iStaging, oStaging in tExistingAirStaging do
                if oStaging:GetFractionComplete() == 1 and oStaging:GetAIBrain().M28AI then
                    iExistingAirStaging = iExistingAirStaging + 1
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iExistingAirStaging='..iExistingAirStaging..'; bHaveLowMass='..tostring(bHaveLowMass)) end
        if iExistingAirStaging < 1 then
            iBPWanted = 5
            if not(bHaveLowMass) then iBPWanted = iBPWanted * 2 end
            HaveActionToAssign(refActionBuildAirStaging, 1, iBPWanted, nil, false)
            if bDebugMessages == true then LOG(sFunctionRef..': Have flagged we want air staging for minor zone with iBPWanted='..iBPWanted) end
        end
    end

    --Low priority T2 radar creep
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': T2 radar creep - bHaveLowMass='..tostring(bHaveLowMass)..'; bWantMorePower='..tostring(bWantMorePower)..'; Radar coverage='..tLZTeamData[M28Map.refiRadarCoverage]..'; Map size='..M28Map.iMapSize..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; tLZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
    if not(bHaveLowMass) and not(bWantMorePower) and tLZTeamData[M28Map.refiRadarCoverage] < 100 and not(bTeammateHasBuiltHere) and M28Map.iMapSize > 512 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 300 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 18 or M28Map.bIsCampaignMap) and (tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or tLZTeamData[M28Map.subrefMexCountByTech][2] >= 2 or tLZTeamData[M28Map.subrefLZSValue] >= 1750) then
        --Check we dont have any radar here already (redundancy for radar coverage)
        local tExistingRadar = EntityCategoryFilterDown(M28UnitInfo.refCategoryRadar, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        local bHaveRadar = false
        if M28Utilities.IsTableEmpty(tExistingRadar) == false then
            for iUnit, oUnit in tExistingRadar do
                if oUnit:GetFractionComplete() >= 1 then
                    bHaveRadar = true
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveRadar='..tostring(bHaveRadar)) end
        if not(bHaveRadar) then
            --Are we able to build radar? assume we can if we have access to T3 factories for simplicity
            if not(M28Map.bIsCampaignMap) or not(M28Overseer.bUnitRestrictionsArePresent) or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then
                HaveActionToAssign(refActionBuildT2Radar, 2, 10)
            end
        end
    end

    --Low priority air staging builder (max of 1) for expansion bases
    iCurPriority = iCurPriority + 1
    if tLZTeamData[M28Map.subrefLZCoreExpansion] and not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and not(bTeammateHasBuiltHere) and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastAirStagingShortage] or -100) <= 2 and tLZTeamData[M28Map.subrefLZSValue] >= 400 and not(bHaveLowMass) and not(bHaveLowPower) then
        local bHaveAirStaging = false
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
            local tAirStaging = EntityCategoryFilterDown(M28UnitInfo.refCategoryAirStaging, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tAirStaging) == false then
                for iUnit, oUnit in tAirStaging do
                    if M28UnitInfo.IsUnitValid(oUnit) and oUnit:GetFractionComplete() == 1 then bHaveAirStaging = true break end
                end
            end
        end
        if not(bHaveAirStaging) then
            HaveActionToAssign(refActionBuildAirStaging, 1, 10)
            if bDebugMessages == true then LOG(sFunctionRef..': Low priority air staging builder') end
        end
    end


    --If still have an engineer available and there is reclaim in the LZ of any kind, and we arent overflowing, then reclaim
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.8 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] > 0.95 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] < 0.9) then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if bDebugMessages == true then LOG(sFunctionRef..': Very low priority reclaimer if have available engineers; iHighestTechEngiAvailable='..iHighestTechEngiAvailable) end
        if iHighestTechEngiAvailable > 0 then
            if tLZData[M28Map.subrefTotalMassReclaim] >= 5 then
                if bDebugMessages == true then LOG(sFunctionRef..': Lower priority reclaim, Total mass in Plateau '..iPlateau..' LZ '..iLandZone..'='..tLZData[M28Map.subrefTotalMassReclaim]..'; will request at least 100 BP, but wont request more than we already have') end
                HaveActionToAssign(refActionReclaimArea, 1, 100, {false, nil}, true)
            end
        end
    end

    --Check for any part constructed buildings in this zone if we either have available engineers, or no engineers at all
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if M28Utilities.IsTableEmpty(tEngineers) or iHighestTechEngiAvailable > 0 or (tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 and table.getn(tEngineers) < 3) then
        local tBuildings = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure + categories.EXPERIMENTAL * categories.BUILTBYTIER3ENGINEER, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tBuildings) == false then
            for iUnit, oUnit in tBuildings do
                --Dont assist part complete shields as may be for special shielding logic
                if oUnit:GetFractionComplete() < 1 and not(oUnit[refbDontIncludeAsPartCompleteBuildingForConstruction]) then
                    iBPWanted = 5
                    if EntityCategoryContains(M28UnitInfo.refCategoryExperimentalLevel, oUnit.UnitId) and oUnit:GetFractionComplete() >= 0.4 then
                        if oUnit:GetFractionComplete() >= 0.6 then iBPWanted = 120 else iBPWanted = 60 end
                    end
                    HaveActionToAssign(refActionRepairUnit, 1, iBPWanted, oUnit)
                    break
                end
            end
        end
    end

    --Build air factory if overflowing mass, ahve all T3 mexes in the zone, no adjacent enemies, and dont have low power
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Low priority factory builder: mass% stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; bHaveLowPower='..tostring(bHaveLowPower)..'; Enemies in this or adjacent zone='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Mex count by tech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; Mex count='..tLZData[M28Map.subrefLZMexCount]..'; bTeammateHasBuiltHere='..tostring(bTeammateHasBuiltHere)..'; tLZTeamData[M28Map.subrefMexCountByTech][2]='..repru(tLZTeamData[M28Map.subrefMexCountByTech][2])) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.9 and not(bHaveLowPower) and not(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and (tLZTeamData[M28Map.subrefMexCountByTech][math.min(3,M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech])] >= math.max(1, tLZData[M28Map.subrefLZMexCount]) or (not(bTeammateHasBuiltHere) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.99)) and M28Conditions.WantMoreFactories(iTeam, iPlateau, iLandZone) then
        if not(bTeammateHasBuiltHere) or tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 then
            local iActionWanted
            local iTechWanted = 1
            if M28Conditions.DoWeWantAirFactoryInsteadOfLandFactory(iTeam, tLZData, tLZTeamData) then
                iActionWanted = refActionBuildAirFactory
                iTechWanted = M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyAirFactoryTech]
            else
                iActionWanted = refActionBuildLandFactory
                iTechWanted = M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech]
            end
            HaveActionToAssign(iActionWanted, iTechWanted, tiBPByTech[iTechWanted] * 3)
            if bDebugMessages == true then LOG(sFunctionRef..': Low priority minor zone factory builder, iActionWanted='..iActionWanted..'; iTechWanted='..iTechWanted) end
        end
    end

    UpdateSpareEngineerNumber(tLZTeamData, toAvailableEngineersByTech)

    --Spare engi - assist any upgrading unit
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then
        if not(bHaveLowPower) then
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of active upgrades empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoActiveUpgrades]))..'; have spare engis so will send any spare to assist any active upgrades') end
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoActiveUpgrades]) == false then
                HaveActionToAssign(refActionAssistUpgrade, 1, 1000, false, true, nil, nil, nil, true)
                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
            end
        end

        --Spare engi - assist part complete buildings
        iCurPriority = iCurPriority + 1
        if iHighestTechEngiAvailable > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': Have a spare engi, will look to see to see if htere are any part complete buildings in the area') end
            local tFriendlyBuildings = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tFriendlyBuildings) == false then
                local oUnitToAssist
                local iClosestToCompletion = 0
                for iUnit, oUnit in tFriendlyBuildings do
                    if oUnit:GetFractionComplete() < 1 and oUnit:GetFractionComplete() > iClosestToCompletion then
                        iClosestToCompletion = oUnit:GetFractionComplete()
                        oUnitToAssist = oUnit
                    end
                end
                if oUnitToAssist then
                    HaveActionToAssign(refActionRepairUnit, 1, 1000, oUnitToAssist, true, nil, nil, nil, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Will try assisting unit '..oUnitToAssist.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToAssist)) end
                end
            end


            --Low priority island support (for any spare engineers) - will consider further away distances tahn before, up to a distance of 400, and only if the island wants T1 engineer BP
            if iHighestTechEngiAvailable > 0 and (iIslandDistanceThreshold or 0) > 0 and iIslandDistanceThreshold <= 400 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) then
                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                if iHighestTechEngiAvailable > 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': is pathing to other islands empty='..tostring( M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]))) end
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; tLZTeamData[M28Map.reftClosestEnemyBase]='..repru(tLZTeamData[M28Map.reftClosestEnemyBase])..'; tLZData[M28Map.subrefMidpoint]='..repru(tLZData[M28Map.subrefMidpoint])) end

                        if bDebugMessages == true then LOG(sFunctionRef..': Will search for islands, iIslandDistanceThreshold='..iIslandDistanceThreshold) end

                        for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering island '..tPathingData[M28Map.subrefIslandNumber]..' for lower priority travel; travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; Closest LZ ref='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; are enemies in this or adjacent LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                            if tPathingData[M28Map.subrefIslandTravelDist] > iIslandDistanceThreshold then --Have already considered islands with a shorter travel distance above
                                if tPathingData[M28Map.subrefIslandTravelDist] > 400 then break --Too far to try and travel by engineer
                                else
                                    --Are there enemies in the target LZ?
                                    if tPathingData[M28Map.subrefIslandClosestLZRef] and not(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                                        local tiBPByTechWanted = GetBPByTechWantedForAlternativeLandZone(iPlateau, iTeam, tLZData, tPathingData[M28Map.subrefIslandClosestLZRef], iEntry, iHighestTechEngiAvailable, false, true)
                                        if bDebugMessages == true then LOG(sFunctionRef..': tiBPByTechWanted='..repru(tiBPByTechWanted)) end
                                        if (tiBPByTechWanted[1] or 0) > 0 then
                                            HaveActionToAssign(refActionMoveToLandZone, 1, 5, tPathingData[M28Map.subrefIslandClosestLZRef], true) --wont flag as 'spare' since only assigning a small amount of BP
                                            if bDebugMessages == true then LOG(sFunctionRef..': Finished trying to give order for engi to move to the island LZ '..tPathingData[M28Map.subrefIslandClosestLZRef]) end
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end

            --Spare engi action - go to any nearby land or water zone that wants BP
            iCurPriority = iCurPriority + 1

            if bDebugMessages == true then LOG(sFunctionRef..': iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; If have available engis then will look for other zones wanting them, time='..GetGameTimeSeconds()..'; Is table of other land and water zones by distance empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]))) end
            if iHighestTechEngiAvailable > 0 then
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to cycle through all other land and water zones, reprs='..reprs(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance])) end
                    for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to travel to zone '..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..'; Distance='..tSubtable[M28Map.subrefiDistance]) end
                        if tSubtable[M28Map.subrefiDistance] <= 500 then
                            local tAdjLZOrWZData, tAdjLZOrWZTeamData
                            if tSubtable[M28Map.subrefbIsWaterZone] then
                                tAdjLZOrWZData =M28Map.tPondDetails[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                tAdjLZOrWZTeamData = tAdjLZOrWZData[M28Map.subrefWZTeamData][iTeam]
                            else
                                tAdjLZOrWZData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]]
                                tAdjLZOrWZTeamData = tAdjLZOrWZData[M28Map.subrefLZTeamData][iTeam]
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering zone '..tSubtable[M28Map.subrefiLandOrWaterZoneRef]..'; Wnats BP='..tostring(tAdjLZOrWZTeamData[M28Map.subrefTbWantBP])..'; In playable area='..tostring(M28Conditions.IsLocationInPlayableArea(tAdjLZOrWZData[M28Map.subrefMidpoint]))) end
                            if tAdjLZOrWZTeamData[M28Map.subrefTbWantBP] and NavUtils.GetLabel(M28Map.refPathingTypeHover, tAdjLZOrWZData[M28Map.subrefMidpoint]) == iPlateau and (bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZOrWZData[M28Map.subrefMidpoint])) then
                                local iCurBPWanted = 0
                                local iMinTechWanted = 3
                                for iTech, iBP in tAdjLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted] do
                                    iMinTechWanted = math.min(iMinTechWanted, iTech)
                                    iCurBPWanted = iCurBPWanted + iBP
                                end
                                if iCurBPWanted > 0 and iHighestTechEngiAvailable >= iMinTechWanted then
                                    if tSubtable[M28Map.subrefbIsWaterZone] then
                                        --HaveActionToAssign(iActionToAssign,   iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable,                      bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
                                        HaveActionToAssign(refActionMoveToWaterZone, iMinTechWanted, iCurBPWanted,      tSubtable[M28Map.subrefiLandOrWaterZoneRef],true, true,nil,nil, false) --Dont treat it as spare action, or else it gets orders overwritten and can end up in a loop where it moves to another zone and that zone sends it back home
                                    else
                                        HaveActionToAssign(refActionMoveToLandZone, iMinTechWanted, iCurBPWanted, tSubtable[M28Map.subrefiLandOrWaterZoneRef], true, true,                    nil,                            nil,            false) --Dont treat it as spare action, or else it gets orders overwritten and can end up in a loop where it moves to another zone and that zone sends it back home
                                    end
                                    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                    if iHighestTechEngiAvailable == 0 then break end
                                end
                            end
                        end
                    end
                else
                    M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint])
                end

                --Reclaim area if is any reclaim
                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                if bDebugMessages == true then LOG(sFunctionRef..': Spare engi action - reclaim area if any mass or energy in it, iHighestTechEngiAvailable='..iHighestTechEngiAvailable..'; Mass='..(tLZData[M28Map.subrefTotalMassReclaim] or 0)..'; Energy='..(tLZData[M28Map.subrefLZTotalEnergyReclaim] or 0)) end
                if iHighestTechEngiAvailable > 0 then
                    if (tLZData[M28Map.subrefTotalMassReclaim] or 0) > 0 or (tLZData[M28Map.subrefLZTotalEnergyReclaim] or 0) > 0 then
                        HaveActionToAssign(refActionReclaimArea, 1, 90, {(tLZData[M28Map.subrefTotalMassReclaim] or 0) == 0, nil}, true, true, nil, nil, false)
                        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                    end

                    --Adjacent core zones if we have spare engis in this zone
                    if iHighestTechEngiAvailable > 0 then
                        local iTotalAvailableEngineerBP = 0
                        for iTech, tEngineers in toAvailableEngineersByTech do
                            if M28Utilities.IsTableEmpty(tEngineers) == false then
                                iTotalAvailableEngineerBP = iTotalAvailableEngineerBP + tiBPByTech[iTech] * table.getn(tEngineers)
                            end
                        end
                        if iTotalAvailableEngineerBP >= 80 then
                            local iBPToSend = iTotalAvailableEngineerBP - 80
                            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                                for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                                    local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ]
                                    if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]) then
                                        local tAdjLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                                        if tAdjLZTeamData[M28Map.subrefLZbCoreBase] or tAdjLZTeamData[M28Map.subrefTbWantBP] then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Minor zone spare engi overflow - will send to adjacent zone '..iAdjLZ..'; iPlateau='..iPlateau..'; iBPToSend='..iBPToSend) end
                                            HaveActionToAssign(refActionMoveToLandZone, 1, iBPToSend, iAdjLZ, true, nil, nil, nil, true)
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                end

            end
        end
    end


    --Do we have stuff to reclaim in this LZ and arent about to overflow mass? Decided to leave this out as looks like it can do more harm than good
    --[[iCurPriority = iCurPriority + 1
iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
if iHighestTechEngiAvailable > 0 and tLZData[M28Map.subrefTotalMassReclaim] >= 5 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.6 then
HaveActionToAssign(refActionReclaimArea, 1, math.min(100, math.max(10, tLZData[M28Map.subrefTotalMassReclaim] / 10)), false, true)
end--]]




    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function ConsiderWaterZoneEngineerAssignment(tWZTeamData, iTeam, iPond, iWaterZone, tEngineers)
    --Called from ConsiderLandOrWaterZoneEngineerAssignment
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderWaterZoneEngineerAssignment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iBPWanted
    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
    local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)
    local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
    local iHighestTechEngiAvailable
    local iExistingWaterFactory = 0
    local bHaveFactoryHQ = false
    local bDontCheckPlayableArea = false
    if M28Map.bIsCampaignMap then
        bDontCheckPlayableArea = true
        if M28Team.tTeamData[iTeam][M28Team.rebTeamOnlyHasCampaignAI] then bDontCheckPlayableArea = false end
    end
    if tWZTeamData[M28Map.subrefWZbCoreBase] then
        local tExistingWaterFactory = EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tExistingWaterFactory) == false then
            for iFactory, oFactory in tExistingWaterFactory do
                if oFactory:GetFractionComplete() == 1 then
                    iExistingWaterFactory = iExistingWaterFactory + 1
                    if not(bHaveFactoryHQ) and EntityCategoryContains(M28UnitInfo.refCategoryNavalHQ, oFactory.UnitId) then
                        bHaveFactoryHQ = true
                    end
                elseif not(bHaveFactoryHQ) and EntityCategoryContains(M28UnitInfo.refCategoryNavalHQ, oFactory.UnitId) then
                    bHaveFactoryHQ = true
                end
            end
            --Want to set flag to rebuild naval fac if we only have support facs (this won't work 100% if e.g. a teammate has a factory of a different faction in the zone or elsewhere, but should cover majority fo cases; also have the logic to xfer support facs to a teammate of same faction which shoudl help)
            --Note that need to keep it general as otherwise would likely run into issues of infinitely building naval facs (e.g. if we have UEF and Aeon support facs in zone, and UEF has an HQ elsewhere but Aeon doesnt, if we try and build naval fac as a result, we might be building UEF naval facs on repeat)
            if iExistingWaterFactory > 0 and not(bHaveFactoryHQ) then
                --Are we lacking an appropriate HQ for the support factory?
                local bHaveHQElsewhere = false
                for iFactory, oFactory in tExistingWaterFactory do
                    if oFactory:GetAIBrain()[M28Economy.refiOurHighestNavalFactoryTech] > 0 then
                        bHaveHQElsewhere = true
                        break
                    end
                end
                if bHaveHQElsewhere then bHaveFactoryHQ = true end
            end
        end
    end




    local toAvailableEngineersByTech, toAssignedEngineers = FilterToAvailableEngineersByTech(tEngineers, false, tWZData, tWZTeamData, iTeam, iPond, iWaterZone, true)
    tWZTeamData[M28Map.subrefTBuildPowerByTechWanted] = { [1] = 0, [2] = 0, [3] = 0 }
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Time=' .. GetGameTimeSeconds() .. '; iPond=' .. iPond .. '; iWaterZone=' .. iWaterZone .. '; tWZTeamData[M28Map.subrefWZbCoreBase]=' .. tostring(tWZTeamData[M28Map.subrefWZbCoreBase] or false) .. '; iExistingWaterFactory=' .. (iExistingWaterFactory or 'nil') .. '; Have just reset BPByTech to 0 for Pond' .. iPond .. '; WZ=' .. iWaterZone .. '; repru=' .. repru(tWZTeamData[M28Map.subrefTBuildPowerByTechWanted]) .. '; bHaveLowMass=' .. tostring(bHaveLowMass or false) .. '; bHaveLowPower=' .. tostring(bHaveLowPower or false))
    end
    --local iCurCondition = 0
    local iCurPriority = 0
    local iMinTechWanted = 1

    function HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
        --Done as subfunction for convenience so can just note the key values for the action in question and add on the others that wont change
        ConsiderActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iCurPriority, tWZData, tWZTeamData, iTeam, iPond, iWaterZone, toAvailableEngineersByTech, toAssignedEngineers, true, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
    end

    --Emergency torp launcher if enemy has threat in this zone and we have a naval factory
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we need torpedo launcher, iExistingWaterFactory='..iExistingWaterFactory..'; Enemies in adj WZ='..tostring(tWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ])..'; Is table of LR units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftEnemyLongRangeUnits]))) end
    if iExistingWaterFactory > 0 and tWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftEnemyLongRangeUnits]) then
        --If enemy best DF or IF range is <50 and they dont have hover units, then build torp launcher
        local bEnemyHasLongRangeOrHover = false
        if bDebugMessages == true then LOG(sFunctionRef..': tWZTeamData[M28Map.subrefbWZOnlyHoverEnemies]='..tostring(tWZTeamData[M28Map.subrefbWZOnlyHoverEnemies])..'; tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange]='..(tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] or 0)..'; tWZTeamData[M28Map.subrefWZBestEnemyDFRange]='..(tWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0)) end
        if tWZTeamData[M28Map.subrefbWZOnlyHoverEnemies] or (tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] or 0) >= 50 or (tWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0) >= 50 then bEnemyHasLongRangeOrHover = true
        else
            local iEnemyCombatThreat = (tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
            local iOurCombatThreat = (tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0)
            if iEnemyCombatThreat > 15 and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.HOVER - categories.ENGINEER, tWZTeamData[M28Map.subrefTEnemyUnits])) == false then
                bEnemyHasLongRangeOrHover = true
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iEnemyCombatThreat='..iEnemyCombatThreat..'; bEnemyHasLongRangeOrHover='..tostring(bEnemyHasLongRangeOrHover)) end
            if not(bEnemyHasLongRangeOrHover) and M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
                for _, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                    local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                    if (tAdjWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) > 15 and M28Utilities.IsTableEmpty(tAdjWZTeamData[M28Map.subrefTEnemyUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.HOVER - categories.ENGINEER, tAdjWZTeamData[M28Map.subrefTEnemyUnits])) == false then
                        bEnemyHasLongRangeOrHover = true
                        break
                    elseif M28Utilities.IsTableEmpty(tAdjWZTeamData[M28Map.subreftEnemyLongRangeUnits]) == false then
                        bEnemyHasLongRangeOrHover = true
                        break
                    elseif (tAdjWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] or 0) >= 50 or (tAdjWZTeamData[M28Map.subrefWZBestEnemyDFRange] or 0) >= 50 then
                        bEnemyHasLongRangeOrHover = true
                        break
                    end
                    iEnemyCombatThreat = iEnemyCombatThreat + (tAdjWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)
                    iOurCombatThreat = iOurCombatThreat + (tAdjWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0)
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to build torp launchers, bEnemyHasLongRangeOrHover='..tostring(bEnemyHasLongRangeOrHover)..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; iOurCombatThreat='..iOurCombatThreat) end
            if not(bEnemyHasLongRangeOrHover) then
                --Do we not have significantly more threat than enemy?
                if bDebugMessages == true then LOG(sFunctionRef..': iEnemyCombatThreat='..iEnemyCombatThreat..'; iOurCombatThreat='..iOurCombatThreat..'; tWZTeamData[M28Map.subrefWZThreatAlliedAntiNavy]='..(tWZTeamData[M28Map.subrefWZThreatAlliedAntiNavy] or 'nil')..'; tWZTeamData[M28Map.subrefWZThreatEnemySubmersible]='..(tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] or 'nil')) end
                if iEnemyCombatThreat * 3 > iOurCombatThreat or (tWZTeamData[M28Map.subrefWZThreatAlliedAntiNavy] or 0) < 3 * (tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] or 0)  then
                    iBPWanted = 20
                    if not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) then
                        iBPWanted = math.max(40, math.min(100, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 10))
                    end
                    iMinTechWanted = 1
                    local tExistingTorpLauncher = EntityCategoryFilterDown(M28UnitInfo.refCategoryTorpedoLauncher, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    local iExistingTorpThreat = 0
                    if M28Utilities.IsTableEmpty(tExistingTorpLauncher) == false then
                        iExistingTorpThreat = M28UnitInfo.GetCombatThreatRating(tExistingTorpLauncher, false, false, false, true)
                        if iExistingTorpThreat >= 2500 or table.getn(tExistingTorpLauncher) >= 5 then
                            iMinTechWanted = 2
                        end

                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iExistingTorpThreat='..iExistingTorpThreat..'; iEnemyCombatThreat='..iEnemyCombatThreat) end
                    if iExistingTorpThreat <= math.max(3500,  iEnemyCombatThreat * 1.5) then --redundancy
                        if iMinTechWanted >= 2 then
                            HaveActionToAssign(refActionBuildTorpLauncher, iMinTechWanted, iBPWanted)
                        else
                            HaveActionToAssign(refActionBuildT1TorpLauncher, iMinTechWanted, iBPWanted)
                        end
                    end
                end
            end
        end
    end

    --High priority hydro if we have low energy and water zone start
    iCurPriority = iCurPriority + 1
    if tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] and M28Utilities.IsTableEmpty(tWZData[M28Map.subrefHydroUnbuiltLocations]) == false then
        iBPWanted = 5
        if bHaveLowPower or not (bHaveLowMass) then
            iBPWanted = 10
            if table.getn(tWZData[M28Map.subrefHydroUnbuiltLocations]) >= 2 then
                iBPWanted = 15
            end
        end
        HaveActionToAssign(refActionBuildHydro, 1, iBPWanted)
    end

    --High priority AA if we have a naval factory
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': High priority AA builder, iExistingWaterFactory='..iExistingWaterFactory..'; Enemy air to ground threat='..(tWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0)..'; Allied AA threat='..(tWZTeamData[M28Map.subrefWZThreatAlliedAA] or 'nil')) end
    if iExistingWaterFactory > 0 then
        local iAdjacentEnemyAirToGroundThreat = (tWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0)
        M28Air.RecordOtherLandAndWaterZonesByDistance(tWZData, tWZData[M28Map.subrefMidpoint])
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
            for iEntry, tSubtable in tWZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                if tSubtable[M28Map.subrefiDistance] >= 190 then
                    break
                end
                if tSubtable[M28Map.subrefbIsWaterZone] then
                    iAdjacentEnemyAirToGroundThreat = iAdjacentEnemyAirToGroundThreat + (M28Map.tPondDetails[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]][M28Map.subrefWZTeamData][iTeam][M28Map.refiEnemyAirToGroundThreat] or 0)
                else
                    iAdjacentEnemyAirToGroundThreat = iAdjacentEnemyAirToGroundThreat + (M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][tSubtable[M28Map.subrefiLandOrWaterZoneRef]][M28Map.subrefLZTeamData][iTeam][M28Map.refiEnemyAirToGroundThreat] or 0)
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iAdjacentEnemyAirToGroundThreat='..iAdjacentEnemyAirToGroundThreat) end
        if iAdjacentEnemyAirToGroundThreat * 1.5 > (tWZTeamData[M28Map.subrefWZThreatAlliedAA] or 0) or (iAdjacentEnemyAirToGroundThreat * 3 > (tWZTeamData[M28Map.subrefWZThreatAlliedAA] or 0) and tWZTeamData[M28Map.refiEnemyAirToGroundThreat] >= 200) then

            iBPWanted = 25
            if (not (bHaveLowMass) and not (bHaveLowPower)) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] or 1) >= 2) then
                iBPWanted = 50
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build AA for water zone') end
            local iTechLevelWanted = math.max(1, (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] or 1) - 1)
            if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] >= 2 and (tWZTeamData[M28Map.subrefWZThreatAlliedAA] or 0) - (tWZTeamData[M28Map.subrefWZThreatAlliedMAA] or 0) >= 2000 then iTechLevelWanted = M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] end
            HaveActionToAssign(refActionBuildAA, iTechLevelWanted, iBPWanted)
        end
    end

    --Higih priority mex if we have water zone start
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]) == false and tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] and not(M28Overseer.bNoRushActive and M28Conditions.NoRushPreventingHydroOrMex(tWZData, true)) then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': We want to build a mex asap as we have unbuilt locations and have started in water')
        end
        HaveActionToAssign(refActionBuildMex, 1, math.max(5, table.getn(tWZData[M28Map.subrefMexUnbuiltLocations]) * 2.5))
    end


    --Naval fac if this is a core WZ and we dont have any (or lack an HQ), with eco condition
    iCurPriority = iCurPriority + 1
    --Commented out as need logic for identifying build locations first
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': About to see if we want to build a naval factory, is this a core WZ base=' .. tostring(tWZTeamData[M28Map.subrefWZbCoreBase]) .. '; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; First M28 lifetime factory highest build count='..M28Team.GetFirstActiveM28Brain(iTeam)[M28Factory.refiHighestFactoryBuildCount]..'; WZ brain build count='..ArmyBrains[tWZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Factory.refiHighestFactoryBuildCount])
    end
    if (tWZTeamData[M28Map.subrefWZbCoreBase] and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 3.5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or M28Map.bIsCampaignMap or ((not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2.5) or ArmyBrains[tWZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Factory.refiHighestFactoryBuildCount] >= 30)))
            or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]
            or (not(ArmyBrains[tWZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Map.refbCanPathToEnemyBaseWithLand]) and ArmyBrains[tWZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]][M28Map.refbCanPathToEnemyBaseWithAmphibious] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2 and (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 3) and (iExistingWaterFactory > 0 or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] < 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech] < 3 and M28Conditions.GetCurrentM28UnitsOfCategoryInTeam(M28UnitInfo.refCategoryNavalFactory, iTeam) < math.min(9, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 0.6)))) then
        --Is this a priority pond for our team to expand to?
        if bDebugMessages == true then LOG(sFunctionRef..': M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]]='..(M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]] or 'nil')) end
        if (M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]] or 0) > 0 or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
            if tWZTeamData[M28Map.subrefWZbCoreBase] or (not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2 + 3 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                local iFactoriesWanted = 1
                --if bHaveLowMass then iFactoriesWanted = math.max(1, iFactoriesWanted * 0.5) end
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': iFactoriesWanted=' .. iFactoriesWanted .. '; iExistingWaterFactory=' .. iExistingWaterFactory)
                end
                if iExistingWaterFactory < iFactoriesWanted or not(bHaveFactoryHQ) then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': We want to build a naval factory')
                    end
                    HaveActionToAssign(refActionBuildNavalFactory, 1, 30, nil)
                end
            end
        end
    end

    if bDebugMessages == true then
        LOG(sFunctionRef .. ': About to consider what actions we want to give engineers for iPond=' .. iPond .. '; iWaterZone=' .. iWaterZone .. '; iTeam=' .. iTeam .. '; Is table of unbuilt mex locations empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations])) .. '; Is table of part complete mexes empty=' .. tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoPartBuiltMexes])))
    end

    --Emergency AA (slightly lower priority than above)
    iCurPriority = iCurPriority + 1
    if (tWZTeamData[M28Map.refiEnemyAirToGroundThreat] or 0) > (tWZTeamData[M28Map.subrefWZThreatAlliedAA] or 0) * 0.25 and (tWZTeamData[M28Map.subrefWZbCoreBase] or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) then
        iBPWanted = 25
        if not (bHaveLowMass) and not (bHaveLowPower) then
            iBPWanted = 50
        end
        local iTechLevelWanted = math.max(1, (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] or 1) - 1)
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] >= 2 and (tWZTeamData[M28Map.subrefWZThreatAlliedAA] or 0) - (tWZTeamData[M28Map.subrefWZThreatAlliedMAA] or 0) >= 2000 then iTechLevelWanted = M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] end
        HaveActionToAssign(refActionBuildAA, iTechLevelWanted, iBPWanted)
    end

    --Unclaimed mex in the zone
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering if unbuilt or part build mexes in t his WZ ' .. iWaterZone .. ', is subrefMexUnbuiltLocations empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations])) .. '; Is subreftoPartBuiltMexes empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subreftoPartBuiltMexes])) .. '; Is table of mex locations empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZMexLocations])) .. '; Enemy combat threat=' .. tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal])
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]) == false then
            LOG(sFunctionRef .. ': Size of unbuilt locations table=' .. table.getn(tWZData[M28Map.subrefMexUnbuiltLocations]))
        end
    end
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefMexUnbuiltLocations]) == false and not(M28Overseer.bNoRushActive and M28Conditions.NoRushPreventingHydroOrMex(tWZData, true)) then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': We want to build a mex as we have unbuilt locations')
        end
        HaveActionToAssign(refActionBuildMex, 1, math.max(5, table.getn(tWZData[M28Map.subrefMexUnbuiltLocations]) * 2.5))
    elseif M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
        --Do we have no engineers assigned to building a mex?
        local bHaveEngisBuilding = false
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Have part built mexes, is toAssignedEngineers empty=' .. tostring(M28Utilities.IsTableEmpty(toAssignedEngineers)))
        end
        if M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
            for iEngi, oEngi in toAssignedEngineers do
                if oEngi[refiAssignedAction] == refActionBuildMex then
                    bHaveEngisBuilding = true
                    break
                end
            end
        end
        if not (bHaveEngisBuilding) then
            --Refresh list of mexes
            RefreshPartBuiltMexList(tWZTeamData)
            if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
                HaveActionToAssign(refActionCompletePartBuiltMex, 1, 5)
            end
        end
    elseif M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZMexLocations]) == false then
        --Does the enemy have mexes in this WZ but doesnt have combat threat? If so then try and reclaim
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Checking if enemy has any mexes in this WZ, Is table of enemey units empty=' .. tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits])) .. '; Enemy combat threat=' .. tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal])
        end
        if tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] <= 15 and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
            local tEnemyMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tWZTeamData[M28Map.subrefTEnemyUnits])
            if bDebugMessages == true then
                LOG(sFunctionRef .. 'Is table of enemy mexes empty=' .. tostring(M28Utilities.IsTableEmpty(tEnemyMexes)))
            end
            if M28Utilities.IsTableEmpty(tEnemyMexes) == false then
                HaveActionToAssign(refActionReclaimEnemyUnit, 1, 5, tEnemyMexes)
            end
        end
    end


    --Lower priority mass reclaim where will request engineers to reclaim
    iCurPriority = iCurPriority + 1
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.35 and tWZData[M28Map.subrefTotalMassReclaim] >= 5 then
        local iReclaimFactor = 75
        if GetGameTimeSeconds() <= 540 then
            iReclaimFactor = 125
        end
        iBPWanted = math.min(40, math.max(5, tWZData[M28Map.subrefTotalMassReclaim] / iReclaimFactor))
        if iBPWanted > 15 and GetGameTimeSeconds() <= 540 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 then
            iBPWanted = math.min(iBPWanted, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * 10)
        end
        if tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then
            iBPWanted = math.max(5, iBPWanted * 0.6)
        end

        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Lower priority reclaim, Total mass in Pond ' .. iPond .. ' WZ ' .. iWaterZone .. '=' .. tWZData[M28Map.subrefTotalMassReclaim])
        end
        HaveActionToAssign(refActionReclaimArea, 1, math.min(100, math.max(5, iBPWanted)), {false, nil}, false)
    end

    --Unclaimed hydro
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefHydroUnbuiltLocations]) == false then
        iBPWanted = 10
        if table.getn(tWZData[M28Map.subrefHydroUnbuiltLocations]) >= 2 then
            iBPWanted = 20
        end
        HaveActionToAssign(refActionBuildHydro, 1, iBPWanted)
    end

    --Multiple mex upgrades (water zone) - want to assist as a higher priority
    iCurPriority = iCurPriority + 1
    if (tWZTeamData[M28Map.subrefiActiveMexUpgrades] or 0) >= 2 and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) then
        iBPWanted = 10
        if not(bHaveLowPower) then
            iBPWanted = tWZTeamData[M28Map.subrefiActiveMexUpgrades] * 15
        end
        HaveActionToAssign(refActionAssistUpgrade, 1, iBPWanted)
    end

    --Extra naval facs if need build power and dont have low mass and have positive net energy income
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': About to see if we want to build a naval factory, is this a core WZ base=' .. tostring(tWZTeamData[M28Map.subrefWZbCoreBase]) .. '; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] .. '; bHaveLowMass=' .. tostring(bHaveLowMass) .. '; bWantBP=' .. tostring(tWZTeamData[M28Map.subrefTbWantBP])..'; Time since pond last in bombardment mode='..GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBombardmentModeByPond] or -10))
    end
    if (not (bHaveLowMass) or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] or (iExistingWaterFactory > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 5.5 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]))) and (not (bHaveLowPower) or (tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > 1 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] or -100) >= 10)) and ((tWZTeamData[M28Map.subrefWZbCoreBase] and (tWZTeamData[M28Map.subrefTbWantBP] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 10000 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.8) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 6 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) or (tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 4 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and (tWZTeamData[M28Map.subrefTbWantBP] or not (bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 12 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]))) then
        if (M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]] or 0) > 0 or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
            --Dont build another naval fac if are in bombardment mode unless close to overflowing
            if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBombardmentModeByPond] or -10) >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.5 then
                local iMaxFactories = 1
                if (not (bHaveLowMass) or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart]) then
                    iMaxFactories = 2
                end
                if tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
                    iMaxFactories = math.min(8, math.max(2, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / 2))
                end
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 100 then
                    iMaxFactories = 3
                end

                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 6 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                    --Consider getting 3 factories if enemy has a naval factory in this pond and doesn't have T2+
                    local bEnemyHasT1OnlyNavalFacs = false --true if they both have T1 naval facs and dont ahve T2+
                    local bEnemyHasT2PlusFacs = false
                    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyNavyTech] == 1 and M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                        for iEntry, tSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                            if tSubtable[M28Map.subrefWZAWZDistance] >= 375 then break end
                            local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefWZAWZRef]][M28Map.subrefWZTeamData][iTeam]
                            if M28Utilities.IsTableEmpty(tAdjWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                                local tEnemyNavalFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tAdjWZTeamData[M28Map.subrefTEnemyUnits])
                                if M28Utilities.IsTableEmpty(tEnemyNavalFactories) == false then
                                    for iFactory, oFactory in tEnemyNavalFactories do
                                        if EntityCategoryContains(categories.TECH1, oFactory.UnitId) then
                                            bEnemyHasT1OnlyNavalFacs = true
                                        else
                                            bEnemyHasT1OnlyNavalFacs = false
                                            bEnemyHasT2PlusFacs = true
                                            break
                                        end
                                    end
                                end
                            end
                            if bEnemyHasT2PlusFacs then break end
                        end
                        if bEnemyHasT1OnlyNavalFacs and not(bEnemyHasT2PlusFacs) then
                            iMaxFactories = math.max(iMaxFactories + 1, 3)
                        end
                    end
                end

                --if bHaveLowMass then iFactoriesWanted = math.max(1, iFactoriesWanted * 0.5) end
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': iMaxFactories=' .. iMaxFactories .. '; iExistingWaterFactory=' .. iExistingWaterFactory)
                end
                if iExistingWaterFactory < iMaxFactories or (iExistingWaterFactory > 0 and not(bHaveFactoryHQ)) then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Lower priority builder - We want to build a naval factory')
                    end
                    if not(bHaveLowMass) then iBPWanted = 60 else
                        iBPWanted = 30
                        if not(tWZTeamData[M28Map.subrefWZbCoreBase]) then iBPWanted = 15 end
                    end
                    HaveActionToAssign(refActionBuildNavalFactory, 1, iBPWanted, nil)
                end
            end
        end
    end

    --Build sonar if no nearby enemies and lack decent coverage and have decent eco
    iCurPriority = iCurPriority + 1
    --Coverage set at 100, as can have large water zones, with sonar built on edge, meaning T2 sonar doesnt even give 100 coverage of its own midpoint
    if tWZTeamData[M28Map.refiSonarCoverage] <= 100 and not (bHaveLowMass) and not (bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 and tWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] == 0 and not (M28Team.tTeamData[iTeam][M28Team.subrefbTeamHasOmni]) then
        local iGrossMassWanted = 6
        local iGrossEnergyWanted = 125
        iBPWanted = 15
        if not (tWZTeamData[M28Map.subrefWZbCoreBase]) then
            iGrossMassWanted = iGrossMassWanted * 2
            iGrossEnergyWanted = iGrossEnergyWanted * 2
        else
            iBPWanted = 40
        end
        if tWZTeamData[M28Map.refiSonarCoverage] == 0 then
            iGrossMassWanted = iGrossMassWanted * 0.8
            iGrossEnergyWanted = iGrossEnergyWanted * 0.8
            if M28Map.bIsCampaignMap and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] < 3 then
                iGrossMassWanted = iGrossMassWanted * 0.7
                iGrossEnergyWanted = iGrossEnergyWanted * 0.7
            end
        end
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= iGrossMassWanted and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= iGrossEnergyWanted then
            --Check we dont have any T2+ sonar in this WZ as sometimes water zones are so big that they dont get great coverage from sonar
            local tFriendlySonar
            if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                tFriendlySonar = EntityCategoryFilterDown(M28UnitInfo.refCategorySonar, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            end
            if M28Utilities.IsTableEmpty(tFriendlySonar) then
                --Build t1 sonar if enemy has enemies in adjacent WZ or we have reached 400 gross mass income, T2 if no enemies in this or adjacent
                if not (tWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ]) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 40 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 750) then
                    HaveActionToAssign(refActionBuildT2Sonar, 2, iBPWanted, false, false)
                elseif tWZTeamData[M28Map.refiSonarCoverage] <= 10 then
                    HaveActionToAssign(refActionBuildT1Sonar, 1, 5, false, false)
                end
            end
        end
    end

    --Build mass storage if we have T2+ mexes
    iCurPriority = iCurPriority + 1
    iBPWanted = GetBPToAssignToMassStorage(0, iWaterZone, iTeam, tWZData, tWZTeamData, false, bHaveLowMass, bHaveLowPower)
    if iBPWanted > 0 then
        HaveActionToAssign(refActionBuildMassStorage, 1, iBPWanted)
    end

    --Experimental naval unit for very high mass levels (higher priority than naval fac assist so engis stop assisting naval fac and start building this)

    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Experimental navy builder - core base=' .. tostring(tWZTeamData[M28Map.subrefWZbCoreBase]) .. '; bHaveLowMass=' .. tostring(bHaveLowMass) .. '; Low power=' .. tostring(bHaveLowPower) .. '; Mass%=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] .. '; Gross mass=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] .. '; Net mass=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] .. '; Naval tehc=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] .. '; Enemies in adjacent QZ=' .. tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) .. '; Ally combat total=' .. tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal])
    end
    if tWZTeamData[M28Map.subrefWZbCoreBase] and not (bHaveLowMass) and not (bHaveLowPower) and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1000 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.4 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 35 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 5 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > -1 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 80)) and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] >= 3 and (not (tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) or (tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= 8000 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.7)))) then
        --Likely have the eco to get an experimental naval unit, check if we have a lifetime build count of at least 2 T3 naval units
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Think we have enough eco for experimental navy builder, lifetime battleship count=' .. M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryBattleship))
        end
        if M28Conditions.GetTeamLifetimeBuildCount(iTeam, M28UnitInfo.refCategoryBattleship) >= 2 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1000 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.8 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 100) then
            --Cap experimentals to 2 if there are no enemy naval targets (increase cap if about to overflow mass)
            local iCurNavalExperimentals = 0
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    iCurNavalExperimentals = iCurNavalExperimentals + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryAllNavy * categories.EXPERIMENTAL)
                end
            end
            local iExperimentalsWanted = 4
            if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastNoSurfaceCombatTargetByPond][iPond] or -100) <= 30 then
                iExperimentalsWanted = 2
            end
            if iCurNavalExperimentals >= iExperimentalsWanted then
                local iCurLandExperimentals = 0
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        iCurLandExperimentals = iCurLandExperimentals + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandExperimental)
                    end
                end
                iExperimentalsWanted = math.max(iExperimentalsWanted, iCurLandExperimentals)
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': iCurLandExperimentals=' .. iCurLandExperimentals)
                end
            end
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.9 then
                iExperimentalsWanted = iExperimentalsWanted * 1.5
            end
            if iCurNavalExperimentals < iExperimentalsWanted then
                iBPWanted = 45
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1000 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.6 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= 10) then
                    iBPWanted = 90
                end
                HaveActionToAssign(refActionBuildExperimentalNavy, 3, iBPWanted, false, false, true)
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Want experimental naval unit, iBPWanted=' .. iBPWanted)
                end
            elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 1000 then
                HaveActionToAssign(refActionBuildLandExperimental, 3, 90)
            end
        end
    end

    --Send engineer to a land zone adjacent to this that wants support and lacks factories
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    local iLZSentTo = 0
    if bDebugMessages == true then LOG(sFunctionRef .. ': About to see if have adjacent land zones wanting engineers, iHighestTechEngiAvailable=' .. iHighestTechEngiAvailable..'; Is table of adjacent LZs empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]))) end
    if iHighestTechEngiAvailable > 0 then
        --Do we haev adjacent land zone wanting engineer?
        local bWantBPOfOurTech
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
            for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                local iPlateau = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                local iLandZone = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                local tAdjLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAdjLZData[M28Map.subrefMidpoint]) then
                    local tLZTeamData = tAdjLZData[M28Map.subrefLZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent LZ '..(iLandZone or 'nil')..' on plateau '..(iPlateau or 'nil')..'; Does this LZ want BP='..tostring(tLZTeamData[M28Map.subrefTbWantBP])..'; Dangerous enemies in this LZ='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])..'; Allied untis in this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
                    if tLZTeamData[M28Map.subrefTbWantBP] and not (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) then
                        bWantBPOfOurTech = false
                        for iTech = iHighestTechEngiAvailable, 1, -1 do
                            if tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                bWantBPOfOurTech = true
                                iMinTechWanted = iTech
                            end
                        end
                        if bWantBPOfOurTech then
                            --For now to keep things simple will ignore minimum engineer tech requirements
                            iLZSentTo = iLZSentTo + 1
                            if bDebugMessages == true then LOG(sFunctionRef..': About to try and send engineers to iLandZOne '..(iLandZone or 'nil')..'; iPlateau='..(iPlateau or 'nil')) end
                            --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted,            vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted)
                            HaveActionToAssign(refActionMoveToLandZone, iMinTechWanted, 10 * 2 * iLZSentTo, {iPlateau, iLandZone}, true)
                            if bDebugMessages == true then LOG(sFunctionRef..': Have flagged we want to send BP of '..10 * 2 * iLZSentTo..' to land zone '..iLandZone) end
                        end
                    end
                end
            end
        end
    end


    --Send engineer to a water zone near this that wants support, or alternatively a land zone adjacent to that water zone that wants support
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': About to check if have adjacent water zones wanting engineers, iHighestTechEngiAvailable=' .. iHighestTechEngiAvailable)
    end
    if iHighestTechEngiAvailable > 0 then
        local bWantBPOfOurTech
        local iMinTechWanted       = 1
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
            for iEntry, tSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                local iAdjWZ = tSubtable[M28Map.subrefWZAWZRef]
                local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAltWZData[M28Map.subrefMidpoint]) then
                    local tAltWZTeamData = tAltWZData[M28Map.subrefWZTeamData][iTeam]
                    local bWZOrAdjacentLZWantsEngineers
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Considering iAdjWZ=' .. iAdjWZ .. '; tAltWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]=' .. tostring(tAltWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] or false) .. '; tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]=' .. (tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0) .. '; tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. (tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) .. '; tAltWZTeamData[M28Map.subrefTbWantBP]=' .. tostring(tAltWZTeamData[M28Map.subrefTbWantBP]) .. '; WZ table of unclaimed mexes is empty=' .. tostring(M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefMexUnbuiltLocations])) .. '; WZ table of unbuilt hydro is empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefHydroUnbuiltLocations]))..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subrefTEnemyUnits])))
                    end
                    if (not (tAltWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) or (tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= math.min(6000, math.max(100, tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 0.75)) or (tAltWZTeamData[M28Map.subrefWZbCoreBase] and M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subrefTEnemyUnits]) and M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.reftLZEnemyAirUnits]) and (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20)))) then
                        --WZ is safe to go to, does the WZ want engineers and/or does it have an adjacent LZ that wants engineers?
                        bWZOrAdjacentLZWantsEngineers = tAltWZTeamData[M28Map.subrefTbWantBP]
                        bWantBPOfOurTech = false
                        if bWZOrAdjacentLZWantsEngineers then
                            for iTech = iHighestTechEngiAvailable, 1, -1 do
                                if tAltWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                    bWantBPOfOurTech = true
                                    iMinTechWanted = iTech
                                end
                            end
                        end

                        if not (bWantBPOfOurTech) and M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefAdjacentLandZones]) == false then

                            for iEntry, tSubtable in tAltWZData[M28Map.subrefAdjacentLandZones] do
                                local iPlateau = tSubtable[1]
                                local iLandZone = tSubtable[2]
                                local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                                if tLZTeamData[M28Map.subrefTbWantBP] and not (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) and (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) or M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryFactory + M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) then
                                    bWantBPOfOurTech = false
                                    for iTech = iHighestTechEngiAvailable, 1, -1 do
                                        if tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                            bWantBPOfOurTech = true
                                            iMinTechWanted = iTech
                                        end
                                    end
                                    if bWantBPOfOurTech then
                                        bWZOrAdjacentLZWantsEngineers = true
                                        break
                                    end
                                end
                            end
                        end
                        if bWZOrAdjacentLZWantsEngineers then
                            iLZSentTo = iLZSentTo + 1
                            iBPWanted = 10 * 2 * iLZSentTo
                            if iExistingWaterFactory > 0 then iBPWanted = iBPWanted *0.25 end
                            HaveActionToAssign(refActionMoveToWaterZone, iMinTechWanted, iBPWanted, iAdjWZ, true)
                            if iLZSentTo >= 4 then break end
                        end
                    end
                end
            end
        end
    end

    --Naval fac if this is a core WZ and we dont have any, but have engineers available, or we have lots of mass stored
    iCurPriority = iCurPriority + 1
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then
        if tWZTeamData[M28Map.subrefWZbCoreBase] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 4 then
            if (M28Team.tTeamData[iTeam][M28Team.refiPriorityPondValues][M28Map.tiPondByWaterZone[iWaterZone]] or 0) > 0 or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
                if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeLastHadBombardmentModeByPond] or -10) >= 3 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.5 or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
                    local iFactoriesWanted = 1
                    if not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.4 then
                        iFactoriesWanted = 2
                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.7 then iFactoriesWanted = 3 end
                    end
                    --if bHaveLowMass then iFactoriesWanted = math.max(1, iFactoriesWanted * 0.5) end
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': iFactoriesWanted=' .. iFactoriesWanted .. '; iExistingWaterFactory=' .. iExistingWaterFactory)
                    end
                    if iExistingWaterFactory < iFactoriesWanted then
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Later naval fac builder We want to build a naval factory')
                        end
                        iBPWanted = 35
                        if bHaveLowMass then iBPWanted = 25 end
                        HaveActionToAssign(refActionBuildNavalFactory, 1, iBPWanted, nil)
                    end
                end
            end
        end
    end

    --Assist naval factory based on average mass income of team; assist more if enemy has naval facs
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to assist naval fac, core base='..tostring(tWZTeamData[M28Map.subrefWZbCoreBase])..'; iExistingWaterFactory='..iExistingWaterFactory..'; Is table of naval factories empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])))) end
    if tWZTeamData[M28Map.subrefWZbCoreBase] and iExistingWaterFactory > 0 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) == false then
        --e.g. 1 BP building a frigate uses 0.2 mass per second, or 0.02 mass per tick; if want 40% of team mass income spent on navy, then want to assign 20 BP per 1 mass per tick (i.e. 20 BP per 10 mass per sec)
        iBPWanted = math.min(1000, (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) * 20)
        if not (bHaveLowMass) and not (bHaveLowPower) then
            iBPWanted = iBPWanted * 1.5
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.4 then iBPWanted = iBPWanted * 1.5 end
        elseif bHaveLowMass and M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] then
            iBPWanted = iBPWanted * 0.7
        end
        iBPWanted = math.max(5, iBPWanted)
        if iBPWanted < 200 and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) then
            --Do we need more BP to keep up with enemy?
            local iEnemyBP = 0
            for iEntry, tSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                if tSubtable[M28Map.subrefWZAWZDistance] >= 375 then break end
                local tAdjWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tSubtable[M28Map.subrefWZAWZRef]][M28Map.subrefWZTeamData][iTeam]
                if M28Utilities.IsTableEmpty(tAdjWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    local tEnemyNavalFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryNavalFactory, tAdjWZTeamData[M28Map.subrefTEnemyUnits])
                    if M28Utilities.IsTableEmpty(tEnemyNavalFactories) == false then
                        for iFactory, oFactory in tEnemyNavalFactories do
                            if M28UnitInfo.IsUnitValid(oFactory) then
                                iEnemyBP = iEnemyBP + (oFactory:GetBlueprint().Economy.BuildRate or 0)
                            end
                        end
                    end
                    local tEnemyEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tAdjWZTeamData[M28Map.subrefTEnemyUnits])
                    if M28Utilities.IsTableEmpty(tEnemyEngineers) == false then
                        for iEnemyEnngineer, oEnemyEngineer in tEnemyEngineers do
                            if M28UnitInfo.IsUnitValid(oEnemyEngineer) then
                                iEnemyBP = iEnemyBP + tiBPByTech[M28UnitInfo.GetUnitTechLevel(oEnemyEngineer)]
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to increase engi assistance for naval fac due to enemy BP, iEnemyBP='..iEnemyBP..'; iExistingWaterFactory='..iExistingWaterFactory..'; iBPWanted before any adjust='..iBPWanted) end
            iBPWanted = math.max(iBPWanted, math.min(iEnemyBP * 1.25 - iExistingWaterFactory * 20), 25 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech]], (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] / (1 + (M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] - 1) * 0.5) * 40))
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Want to assist naval fac, iBPWanted='..iBPWanted) end
        HaveActionToAssign(refActionAssistNavalFactory, 1, iBPWanted, false, false)
    end

    --If already have 1 naval fac build another if high mass
    iCurPriority = iCurPriority + 1
    if bDebugMessages == true then LOG(sFunctionRef..': More naval fac if already have some and have lots of mass stored, iCurPrioriyt='..iCurPriority..'; iExistingWaterFactory='..iExistingWaterFactory..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored]..'; Time since last had nothing to build='..GetGameTimeSeconds() - (tWZTeamData[M28Map.subrefiTimeNavalFacHadNothingToBuild] or -100)..'; Have low power='..tostring(bHaveLowPower)) end
    if iExistingWaterFactory > 0 and iExistingWaterFactory < 4 and  M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.5 and not(bHaveLowPower) and GetGameTimeSeconds() - (tWZTeamData[M28Map.subrefiTimeNavalFacHadNothingToBuild] or -100) >= 30 then
        iBPWanted = 15 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech]
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.8 then iBPWanted = iBPWanted * 1.5 end
        if bDebugMessages == true then LOG(sFunctionRef..': Want to assign BP to build a naval fac, iBPWanted='..iBPWanted) end
        if not(tWZTeamData[M28Map.subrefWZbCoreBase]) then iBPWanted = iBPWanted * 0.75 end
        HaveActionToAssign(refActionBuildNavalFactory, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech], iBPWanted, nil)
    end

    --Preemptive AA builder if we are at T3 and have decent mass income, and have friendly units in the WZ or intel coverage, and no enemy units
    iCurPriority = iCurPriority + 1
    if not (bHaveLowMass) and not (bHaveLowPower) and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] or 1) >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 then
        --Build AA if we have <1.5k AA threat
        local iAAThreatWanted = 1500
        if tWZTeamData[M28Map.subrefWZbCoreBase] or tWZTeamData[M28Map.subrefWZbContainsUnderwaterStart] then
            iAAThreatWanted = 3000
        end
        if tWZTeamData[M28Map.subrefWZThreatAlliedAA] < iAAThreatWanted then
            if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) and ((tWZTeamData[M28Map.refiSonarCoverage] or 0) > 20 or M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false) then
                iBPWanted = 50
                if tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then
                    iBPWanted = 25
                end
                local iTechLevelWanted = math.max(2, (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] or 1) - 1)
                if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] >= 3 and (tWZTeamData[M28Map.subrefWZThreatAlliedAA] or 0) - (tWZTeamData[M28Map.subrefWZThreatAlliedMAA] or 0) >= 800 then iTechLevelWanted = M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] end
                HaveActionToAssign(refActionBuildAA, iTechLevelWanted, iBPWanted)
            end
        end
    end

    --Build land experimentals in water if v.high mass
    iCurPriority = iCurPriority + 1
    if not (bHaveLowMass) and not (bHaveLowPower) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.8 and (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyNavalFactoryTech] or 1) >= 3 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 40 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] >= 0.9 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20)) then
        local iT3AndExperimentalNavy = 0
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                iT3AndExperimentalNavy = iT3AndExperimentalNavy + oBrain:GetCurrentUnits(M28UnitInfo.refCategoryAllNavy * categories.EXPERIMENTAL + M28UnitInfo.refCategoryAllNavy * categories.TECH3)
            end
        end
        if iT3AndExperimentalNavy >= 4 then
            iBPWanted = 45
            HaveActionToAssign(refActionBuildLandExperimental, 3, iBPWanted, false, false, true)
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Want experimental naval unit, iBPWanted=' .. iBPWanted)
            end
        end
    end

    --Units to capture
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subreftoUnitsToCapture]) == false then
        --Refresh the list
        local iCaptureCount = table.getn(tWZData[M28Map.subreftoUnitsToCapture])
        for iCurCount = iCaptureCount, 1, -1 do
            if not (M28UnitInfo.IsUnitValid(tWZData[M28Map.subreftoUnitsToCapture][iCurCount])) then
                table.remove(tWZData[M28Map.subreftoUnitsToCapture], iCurCount)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finishedupdating if have units to capture for zone, after freshing them is table empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subreftoUnitsToCapture]))) end
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subreftoUnitsToCapture]) == false then
            --Dont capture if are a hostile AI due to the risk we capture a campaign objective and progress the map
            if not(ArmyBrains[tWZTeamData[M28Map.reftiClosestFriendlyM28BrainIndex]].HostileCampaignAI) then
                local oUnitToCapture
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 75 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] then
                    local tPotentialCapture = EntityCategoryFilterDown(categories.ALLUNITS - M28UnitInfo.refCategoryT3Power, tWZData[M28Map.subreftoUnitsToCapture])
                    if M28Utilities.IsTableEmpty(tPotentialCapture) == false then
                        oUnitToCapture = M28Utilities.GetNearestUnit(tPotentialCapture, tWZData[M28Map.subrefMidpoint])
                    end
                else
                    oUnitToCapture = M28Utilities.GetNearestUnit(tWZData[M28Map.subreftoUnitsToCapture], tWZData[M28Map.subrefMidpoint])
                end
                if oUnitToCapture then
                    if bDebugMessages == true then LOG(sFunctionRef..': Unit to cpature='..oUnitToCapture.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToCapture)) end
                    iBPWanted = GetCaptureBPWanted(oUnitToCapture, bHaveLowPower, iTeam, tWZTeamData[M28Map.subrefLZbCoreBase])
                    HaveActionToAssign(refActionCaptureUnit, 1, iBPWanted, oUnitToCapture)
                end
            end
        end
    end

    --Units to repair
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subreftoUnitsToRepair]) == false then
        --Refresh the list
        local iUnitCount = table.getn(tWZData[M28Map.subreftoUnitsToRepair])
        for iCurCount = iUnitCount, 1, -1 do
            if not(M28UnitInfo.IsUnitValid(tWZData[M28Map.subreftoUnitsToRepair][iCurCount])) then
                table.remove(tWZData[M28Map.subreftoUnitsToRepair], iCurCount)
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Have units to repair for water zone '..iWaterZone..' after freshing them is table empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subreftoUnitsToRepair]))) end
        if M28Conditions.IsTableOfUnitsStillValid(tLZData[M28Map.subreftoUnitsToRepair], true) then
            local oUnitToTarget = M28Utilities.GetNearestUnit(tWZData[M28Map.subreftoUnitsToRepair], tWZData[M28Map.subrefMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': Unit to repair='..oUnitToTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToTarget)) end
            HaveActionToAssign(refActionRepairUnit, 1, 5, oUnitToTarget)
        end
    end

    --Under construction unit
    iCurPriority = iCurPriority + 1
    if iHighestTechEngiAvailable > 0 then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if iHighestTechEngiAvailable > 0 then
            local tBuildingsInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
            if M28Utilities.IsTableEmpty(tBuildingsInZone) == false then
                for iUnit, oUnit in tBuildingsInZone do
                    if oUnit:GetFractionComplete() < 1 then
                        HaveActionToAssign(refActionRepairUnit, 1, 5, oUnit)
                        break
                    end
                end
            end
        end
    end

    --Lower priority sending engineeres to other land and water zones
    --Send engineer to a land zone adjacent to this that wants support and lacks factories
    iCurPriority = iCurPriority + 1
    if iHighestTechEngiAvailable > 0 then
        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if bDebugMessages == true then LOG(sFunctionRef .. ': Lower priority About to see if have adjacent land zones wanting engineers, iHighestTechEngiAvailable=' .. iHighestTechEngiAvailable..'; Is table of adjacent LZs empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]))) end
        if iHighestTechEngiAvailable > 0 then
            --Do we haev adjacent land zone wanting engineer?
            local bWantBPOfOurTech
            local iMinTechWanted = 1

            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
                for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                    local iPlateau = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                    local iLandZone = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                    if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then
                        local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent LZ '..(iLandZone or 'nil')..' on plateau '..(iPlateau or 'nil')..'; Does this LZ want BP='..tostring(tLZTeamData[M28Map.subrefTbWantBP])..'; Dangerous enemies in this LZ='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])..'; Allied untis in this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))) end
                        if tLZTeamData[M28Map.subrefTbWantBP] and not (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) then
                            bWantBPOfOurTech = false
                            for iTech = iHighestTechEngiAvailable, 1, -1 do
                                if tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                    bWantBPOfOurTech = true
                                    iMinTechWanted = iTech
                                end
                            end
                            if bWantBPOfOurTech then
                                --For now to keep things simple will ignore minimum engineer tech requirements
                                iLZSentTo = iLZSentTo + 1
                                if bDebugMessages == true then LOG(sFunctionRef..': About to try and send engineers to iLandZOne '..(iLandZone or 'nil')..'; iPlateau='..(iPlateau or 'nil')) end
                                --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted,            vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted)
                                HaveActionToAssign(refActionMoveToLandZone, iMinTechWanted, 10 * 2 * iLZSentTo, {iPlateau, iLandZone}, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': Have flagged we want to send BP of '..10 * 2 * iLZSentTo..' to land zone '..iLandZone) end
                            end
                        end
                    end
                end
            end
        end
    end


    --Send engineer to a water zone near this that wants support, or alternatively a land zone adjacent to that water zone that wants support
    iCurPriority = iCurPriority + 1
    if iHighestTechEngiAvailable > 0 then

        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Lower priority About to check if have adjacent water zones wanting engineers, iHighestTechEngiAvailable=' .. iHighestTechEngiAvailable)
        end
        if iHighestTechEngiAvailable > 0 then
            local bWantBPOfOurTech
            local iMinTechWanted = 1
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                for iEntry, tSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                    local iAdjWZ = tSubtable[M28Map.subrefWZAWZRef]
                    local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
                    if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAltWZData[M28Map.subrefMidpoint]) then
                        local tAltWZTeamData = tAltWZData[M28Map.subrefWZTeamData][iTeam]
                        local bWZOrAdjacentLZWantsEngineers
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Considering iAdjWZ=' .. iAdjWZ .. '; tAltWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]=' .. tostring(tAltWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] or false) .. '; tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]=' .. (tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 0) .. '; tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. (tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) .. '; tAltWZTeamData[M28Map.subrefTbWantBP]=' .. tostring(tAltWZTeamData[M28Map.subrefTbWantBP]) .. '; WZ table of unclaimed mexes is empty=' .. tostring(M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefMexUnbuiltLocations])) .. '; WZ table of unbuilt hydro is empty=' .. tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefHydroUnbuiltLocations]))..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subrefTEnemyUnits])))
                        end
                        if (not (tAltWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ]) or (tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= math.min(6000, math.max(100, tAltWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] * 0.75)) or (tAltWZTeamData[M28Map.subrefWZbCoreBase] and M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subrefTEnemyUnits]) and M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.reftLZEnemyAirUnits]) and (not(bHaveLowMass) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20)))) then
                            --WZ is safe to go to, does the WZ want engineers and/or does it have an adjacent LZ that wants engineers?
                            bWZOrAdjacentLZWantsEngineers = tAltWZTeamData[M28Map.subrefTbWantBP]
                            bWantBPOfOurTech = false
                            if bWZOrAdjacentLZWantsEngineers then

                                for iTech = iHighestTechEngiAvailable, 1, -1 do
                                    if tAltWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                        bWantBPOfOurTech = true
                                        iMinTechWanted = iTech
                                    end
                                end
                            end
                            if not (bWantBPOfOurTech) and M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefAdjacentLandZones]) == false then

                                for iEntry, tSubtable in tAltWZData[M28Map.subrefAdjacentLandZones] do
                                    local iPlateau = tSubtable[1]
                                    local iLandZone = tSubtable[2]
                                    local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                                    if tLZTeamData[M28Map.subrefTbWantBP] and not (tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) then
                                        bWantBPOfOurTech = false
                                        for iTech = iHighestTechEngiAvailable, 1, -1 do
                                            if tLZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                                bWantBPOfOurTech = true
                                                iMinTechWanted = iTech
                                            end
                                        end
                                        if bWantBPOfOurTech then
                                            bWZOrAdjacentLZWantsEngineers = true
                                            break
                                        end
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of adj land zones empty='..tostring(M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefAdjacentLandZones]))..'; bWantBPOfOurTech='..tostring(bWantBPOfOurTech)..'; bWZOrAdjacentLZWantsEngineers='..tostring(bWZOrAdjacentLZWantsEngineers)) end
                            if bWZOrAdjacentLZWantsEngineers and bWantBPOfOurTech then
                                iLZSentTo = iLZSentTo + 1
                                HaveActionToAssign(refActionMoveToWaterZone, iMinTechWanted, 10 * 2 * iLZSentTo, iAdjWZ, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': Assigned engineers to move to water zone, Total of iLZSentTo='..iLZSentTo..'; iAdjWZ='..iAdjLZ) end
                                iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                                if iLZSentTo >= 4 or iHighestTechEngiAvailable == 0 then break end
                            end
                        end
                    end
                end
            end
        end
    end


    UpdateSpareEngineerNumber(tWZTeamData, toAvailableEngineersByTech)

    --spare engis - If still have an engineer available and there is reclaim in the WZ of any kind, and we arent overflowing, then reclaim (but dont request engineers for this)
    iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
    if iHighestTechEngiAvailable > 0 then
        iCurPriority = iCurPriority + 1
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageMassPercentStored] <= 0.8 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamAverageEnergyPercentStored] < 0.9 then
            iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': iCurPriority=' .. iCurPriority .. '; considering if want to reclaim in the WZ, iHighestTechEngiAvailable=' .. iHighestTechEngiAvailable .. '; tWZData[M28Map.subrefTotalMassReclaim]=' .. (tWZData[M28Map.subrefTotalMassReclaim] or 0))
            end
            if iHighestTechEngiAvailable > 0 then
                if tWZData[M28Map.subrefTotalMassReclaim] >= 5 then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Will tell engineer to get lower priority reclaim, Total mass in pond ' .. iPond .. ' WZ ' .. iWaterZone .. '=' .. tWZData[M28Map.subrefTotalMassReclaim])
                    end
                    HaveActionToAssign(refActionReclaimArea, 1, 100, {false, nil}, true, nil, nil, nil, true)
                end
            end
        end
        --Spare engis - if have adjacent land zone wanting engineers, then send them here
        iCurPriority = iCurPriority + 1
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
            for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                local iBPWanted = 0
                local iMinTechWanted = 3
                local iPlateau = tSubtable[1]
                local iLandZone = tSubtable[2]
                local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then
                    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                    if tLZTeamData[M28Map.subrefTbWantBP] then
                        for iTech, iZoneBPWanted in tAltWZTeamData[M28Map.subrefTBuildPowerByTechWanted] do
                            iBPWanted = iBPWanted + iZoneBPWanted
                            iMinTechWanted = math.min(iZoneBPWanted, iTech)
                        end
                    end
                    if iBPWanted > 0 then
                        --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
                        HaveActionToAssign(refActionMoveToLandZone, iMinTechWanted, iBPWanted,      {iPlateau, iLandZone}, true,                    true,                       nil,                            nil,                                false) --Dont treat it as spare action, or else it gets orders overwritten and can end up in a loop where it moves to another zone and that zone sends it back home
                        iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                        if iHighestTechEngiAvailable == 0 then break end
                    end
                end
            end
        end

        --Spare engis - if still have engi available, then send engineer to the closest land or water zone wanting more BP
        iCurPriority = iCurPriority + 1
        if iHighestTechEngiAvailable > 0 and M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
            for iEntry, tSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                local iAdjWZ = tSubtable[M28Map.subrefWZAWZRef]
                local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ]
                if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tAltWZData[M28Map.subrefMidpoint]) then
                    local tAltWZTeamData = tAltWZData[M28Map.subrefWZTeamData][iTeam]
                    local iBPWanted = 0
                    local iMinTechWanted = 3
                    if tAltWZTeamData[M28Map.subrefTbWantBP] then
                        for iTech, iZoneBPWanted in tAltWZTeamData[M28Map.subrefTBuildPowerByTechWanted] do
                            iBPWanted = iBPWanted + iZoneBPWanted
                            iMinTechWanted = math.min(iZoneBPWanted, iTech)
                        end
                        if iBPWanted > 0 then
                            --HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, vOptionalVariable, bDontIncreaseLZBPWanted, bBPIsInAdditionToExisting, iOptionalSpecificFactionWanted, bDontUseLowerTechEngineersToAssist, bMarkAsSpare)
                            HaveActionToAssign(refActionMoveToWaterZone, iMinTechWanted, iBPWanted,             iAdjWZ,         true,                   true,                       nil,                            nil,                                false) --Dont treat it as spare action, or else it gets orders overwritten and can end up in a loop where it moves to another zone and that zone sends it back home
                            iHighestTechEngiAvailable = GetHighestTechEngiAvailable(toAvailableEngineersByTech)
                            if iHighestTechEngiAvailable == 0 then break end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefAdjacentLandZones]) == false then
                        for iEntry, tSubtable in tAltWZData[M28Map.subrefAdjacentLandZones] do
                            local iPlateau = tSubtable[1]
                            local iLandZone = tSubtable[2]
                            local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
                            if bDontCheckPlayableArea or M28Conditions.IsLocationInPlayableArea(tLZData[M28Map.subrefMidpoint]) then
                                local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
                                if tLZTeamData[M28Map.subrefTbWantBP] then
                                    for iTech, iZoneBPWanted in tAltWZTeamData[M28Map.subrefTBuildPowerByTechWanted] do
                                        iBPWanted = iBPWanted + iZoneBPWanted
                                        iMinTechWanted = math.min(iZoneBPWanted, iTech)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        --Spare engis - assist naval factory if dont ahve low mass
        iCurPriority = iCurPriority + 1
        if not (bHaveLowMass) and iExistingWaterFactory > 0 then
            --+5 BP a time assigned to naval factory
            HaveActionToAssign(refActionAssistNavalFactory, 1, 5, false, true, true, nil, nil, true)
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function ConsiderLandOrWaterZoneEngineerAssignment(tLZOrWZData, tLZOrWZTeamData, iTeam, iPlateauOrPond, iLandOrWaterZone, tEngineers, bIsWaterZone)
    --tEngineers might be empty if e.g. we just want to record how much build power the land zone wants
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderLandOrWaterZoneEngineerAssignment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Start of code, iTeam=' .. iTeam .. '; iPlateauOrPond=' .. iPlateauOrPond .. '; iLandOrWaterZone=' .. iLandOrWaterZone .. '; is tEngineers empty=' .. tostring(M28Utilities.IsTableEmpty(tEngineers)) .. '; Is this a core base LZ=' .. tostring(tLZOrWZTeamData[M28Map.subrefLZbCoreBase] or false) .. '; bIsWaterZone=' .. tostring(bIsWaterZone or false)..'; tLZOrWZTeamData[M28Map.subrefTbWantBP] before reset='..tostring(tLZOrWZTeamData[M28Map.subrefTbWantBP] or false)..'; iTeam='..iTeam)
    end

    --First clear any faction requests (will set to true again if we want to build something and dont have an engineer of the right faction for it)
    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted]) == false then
        for iFaction, bWantEngineers in tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted] do
            if bWantEngineers then
                if bDebugMessages == true then LOG(sFunctionRef..': We want engineers for iFaction='..iFaction..' for zone '..iLandOrWaterZone..'; if this is UEF or seraphim and we have an active gameender logic, then wont reset this flag to false, do we have active gameender logic='..tostring(M28Conditions.HaveActiveGameEnderTemplateLogic(tLZOrWZTeamData, true))..'; Is this not UEF or seraphim='..tostring(not(iFaction == M28UnitInfo.refFactionUEF) and not(iFaction == M28UnitInfo.refFactionSeraphim))) end
                if not(M28Conditions.HaveActiveGameEnderTemplateLogic(tLZOrWZTeamData, true)) or (not(iFaction == M28UnitInfo.refFactionUEF) and not(iFaction == M28UnitInfo.refFactionSeraphim)) then
                    tLZOrWZTeamData[M28Map.subreftbBPByFactionWanted][iFaction] = false
                end
            end
        end
    end
    --Clear tracking of engineers wanted by action
    tLZOrWZTeamData[M28Map.subreftiBPWantedByAction] = {}
    tLZOrWZTeamData[M28Map.refbAdjZonesWantEngiForUnbuiltMex] = false

    if bIsWaterZone then
        ConsiderWaterZoneEngineerAssignment(tLZOrWZTeamData, iTeam, iPlateauOrPond, iLandOrWaterZone, tEngineers, bIsWaterZone)
    elseif tLZOrWZTeamData[M28Map.subrefLZbCoreBase] then
        ConsiderCoreBaseLandZoneEngineerAssignment(tLZOrWZTeamData, iTeam, iPlateauOrPond, iLandOrWaterZone, tEngineers)
    else
        --Not dealing with a core base
        ConsiderMinorLandZoneEngineerAssignment(tLZOrWZTeamData, iTeam, iPlateauOrPond, iLandOrWaterZone, tEngineers)
    end

    tLZOrWZTeamData[M28Map.subrefTbWantBP] = false --set to true later if any BP wanted
    --Reduce BP wanted by any engineers assigned to this LZ from another LZ
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Checking if engineers already assigned here, Is table of traveling engis empty=' .. tostring(M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere])) .. '; BP wanted pre update for traveling engis=' .. repru(tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted]))
    end
    if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
        --Make sure the list of units traveling here is still accurate
        function KeepCurEntry(tArray, iEntry)
            if M28UnitInfo.IsUnitValid(tArray[iEntry]) then
                if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, tArray[iEntry].UnitId) then
                    if (tArray[iEntry][refiAssignedAction] == refActionRunToLandZone or tArray[iEntry][refiAssignedAction] == refActionMoveToLandZone) and tArray[iEntry][M28Land.reftiPlateauAndLZToMoveTo][2] == iLandOrWaterZone then
                        return true
                    elseif (tArray[iEntry][refiAssignedAction] == refActionMoveToWaterZone or tArray[iEntry][refiAssignedAction] == refActionRunToWaterZone) and tArray[iEntry][M28Navy.refiWZToMoveTo] == iLandOrWaterZone then
                        return true
                    else
                        return false

                    end
                else
                    --Not an engineer so dont remove from the table of traveling units as only concerned with removing engineers no longer assigned to do this
                    return true
                end
            else
                return false
            end
        end

        M28Utilities.RemoveEntriesFromArrayBasedOnCondition(tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere], KeepCurEntry)
        if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
            local tTravelingEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere])
            local iCurEngiTechLevel
            if M28Utilities.IsTableEmpty(tTravelingEngineers) == false then
                for iUnit, oUnit in tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere] do
                    --Refresh list of traveling engineers in case it is invalid

                    if M28UnitInfo.IsUnitValid(oUnit) then
                        --Is the engi still actually travelling here?
                        iCurEngiTechLevel = M28UnitInfo.GetUnitTechLevel(oUnit)
                        for iTech = iCurEngiTechLevel, 1, -1 do
                            if tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
                                --Dont ignore traveling engineers for fortify zone (so UEF M2 we still try doing a drop)
                                if iTech > 1 or not(M28Map.bIsCampaignMap) or not(tLZOrWZTeamData[M28Map.subrefLZFortify]) then
                                    tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] = tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] - oUnit:GetBlueprint().Economy.BuildRate
                                    break
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': BP wanted after updating for traveling engineers=' .. repru(tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted]))
            end
        end
    end

    --Cap BP wanted for non-core LZs and all WZs if enemies in the zone or adjacent
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Considering capping engis wnated for noncore zones; tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal]=' .. (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 'nil') .. '; tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]=' .. tostring(tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or false))
    end
    if not (tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and not (tLZOrWZTeamData[M28Map.subrefWZbCoreBase]) then
        local iBPCap
        if (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) > 10 or (bIsWaterZone and tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] > 10) then
            iBPCap = 0
            --Exception - cap of 5 for campaign with objective to repair (i.e. M2 UEF)
            if M28Map.bIsCampaignMap and tLZOrWZTeamData[M28Map.subrefLZFortify] and (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) < 1000 and M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subreftoUnitsToRepair][1] and M28UnitInfo.GetUnitHealthPercent(M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subreftoUnitsToRepair][1]) < 0.15 then
                iBPCap = 5
                --Other exception - high reclaim zone where our combat units have more threat tahn the enemy
            elseif tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim] >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * 250 then
                if (tLZOrWZTeamData[M28Map.subrefLZTAlliedCombatUnits] or 0) > (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) * 3 and (tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0) < 500 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] then
                    iBPCap = 5
                    if tLZOrWZData[M28Map.subrefTotalSignificantMassReclaim] >= 1000 then iBPCap = 2 * tiBPByTech[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] end
                end
            end
            --Clear any engineers already traveling here
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Setting BP cap to 0 (or 5 if unit to repair) and clearing engineers traveling here, iBPCap='..iBPCap..'; M28Map.bIsCampaignMap='..tostring(M28Map.bIsCampaignMap)..'; Fortify='..tostring(tLZOrWZTeamData[M28Map.subrefLZFortify] or false)..'; Fortify based on plateau and zone='..tostring(M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZFortify] or false)..'; Enemy combat='..(tLZOrWZTeamData[M28Map.subrefTThreatEnemyCombatTotal] or 0)..';1st unit to repair if there is one='..(M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subreftoUnitsToRepair][1].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subreftoUnitsToRepair][1]) or 'nil')..'; flag for iTeam '..iTeam)
            end
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere]) == false then
                local tTravelingEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subrefTEngineersTravelingHere])
                if M28Utilities.IsTableEmpty(tTravelingEngineers) == false then
                    for iEngi, oEngi in tTravelingEngineers do
                        if iBPCap > 0 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will hold off clearing engineer '..oEngi.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngi)..' and will set BP cap to 0') end
                            iBPCap = 0
                        else
                            M28Orders.IssueTrackedClearCommands(oEngi)
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iBPCap after clearing traveling engineers='..iBPCap) end
        elseif tLZOrWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or tLZOrWZTeamData[M28Map.subrefbDangerousEnemiesInAdjacentWZ] then
            iBPCap = 5
        end
        if iBPCap then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': have iBPCap of ' .. iBPCap .. '; so will limit BP wanted for this LZ')
            end
            for iTech = 1, 3 do
                if tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > iBPCap then
                    tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] = iBPCap
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if zone wants BP for any tech level 1-3, tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted]='..repru(tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted])) end
    for iTech = 1, 3 do
        if tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': Zone wants BP so setting flag to true') end
            tLZOrWZTeamData[M28Map.subrefTbWantBP] = true
            break
        end
    end
    --Clear the BP wanted flag if this is a pacifist zone
    if M28Overseer.bPacifistModeActive and tLZOrWZTeamData[M28Map.subrefTbWantBP] then
        local tLZOrWZData
        if bIsWaterZone then
            tLZOrWZData = M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        else
            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        end
        if tLZOrWZData[M28Map.subrefbPacifistArea] then
            tLZOrWZTeamData[M28Map.subrefTbWantBP] = false
            for iTech = 1, 3 do
                tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] = 0
            end
        end
    end

    --Clear any BP wanted if norush active and dealing with a non-core LZ outside any M28 norush raidius
    if M28Overseer.bNoRushActive and M28Overseer.iNoRushTimer - GetGameTimeSeconds() > 30 and tLZOrWZTeamData[M28Map.subrefTbWantBP] and not (tLZOrWZTeamData[M28Map.subrefLZbCoreBase]) and not (tLZOrWZTeamData[M28Map.subrefWZbCoreBase]) then
        local tLZOrWZData
        if bIsWaterZone then
            tLZOrWZData = M28Map.tPondDetails[iPlateauOrPond][M28Map.subrefPondWaterZones][iLandOrWaterZone]
        else
            tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrPond][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
        end
        if M28Utilities.GetDistanceBetweenPositions(tLZOrWZTeamData[M28Map.reftClosestFriendlyBase], tLZOrWZData[M28Map.subrefMidpoint]) > M28Overseer.iNoRushRange then
            for iTech = 1, 3 do
                tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted][iTech] = 0
            end
            tLZOrWZTeamData[M28Map.subrefTbWantBP] = false
            if bDebugMessages == true then LOG(sFunctionRef..': No rush override - clearing any BP wanted') end
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Finished updating the BP wanted for this land or water zone '..iLandOrWaterZone..'; iPlateauOrPond='..iPlateauOrPond..'; tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted]=' .. repru(tLZOrWZTeamData[M28Map.subrefTBuildPowerByTechWanted]) .. '; tLZOrWZTeamData[M28Map.subrefTbWantBP]=' .. tostring(tLZOrWZTeamData[M28Map.subrefTbWantBP]))
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckDestroyedBuildingLocations()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckDestroyedBuildingLocations'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iLastEntryToRemove
    local aiBrain
    for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
        aiBrain = oBrain
        if not(oBrain.M28IsDefeated) then
            break
        end
    end

    for iEntry, tSubtable in tRecentlyDestroyedBuildings do
        --As a rough test, in sandbox it looked like an Aeon T2 shield took about 3.5s to complete, so will go with 3.9s to be safe
        if GetGameTimeSeconds() - tSubtable[subrefDestroyedBuildingTime] >= 3.9 then
            iLastEntryToRemove = iEntry
            local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(tSubtable[subrefDestroyedBuildingLocation])
            local tLZOrWZData
            local tZoneBySegmentRef
            local tBlueprintSizeTableRef
            if iPlateauOrZero > 0 then
                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
                tZoneBySegmentRef = M28Map.tLandZoneBySegment
                tBlueprintSizeTableRef = tsBlueprintsBySize
            elseif iPlateauOrZero == 0 then
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
                tZoneBySegmentRef = M28Map.tWaterZoneBySegment
                tBlueprintSizeTableRef = tsWZBlueprintsBySize
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iENtry='..iEntry..'; repru='..repru(tSubtable)) end
            if iLandOrWaterZone > 0 then
                local iBuildingSize = M28UnitInfo.GetBuildingSize(tSubtable[subrefDestroyedBuildingBlueprint])
                local iBaseSegmentX, iBaseSegmentZ = M28Map.GetPathingSegmentFromPosition(tSubtable[subrefDestroyedBuildingLocation])
                --local iAffectedDistanceRadius = math.min(math.max(iBuildingSize, 8), iBuildingSize * 0.5 + iMaxBuildingSize * 0.5)

                if aiBrain then
                    SearchForBuildableLocationsNearTarget(aiBrain, tLZOrWZData, iPlateauOrZero, iLandOrWaterZone, tLZOrWZData, iBaseSegmentX, iBaseSegmentZ, iBuildingSize * 0.5)

                    --Record any mass storage locations
                    if iPlateauOrZero > 0 then
                        if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subrefLZMexLocations]) == false then
                            local bHaveNearbyMex = false
                            local iPotentialStorageDistance = iBuildingSize * 0.5 + 3
                            for iMex, tMex in tLZOrWZData[M28Map.subrefLZMexLocations] do
                                if M28Utilities.GetRoughDistanceBetweenPositions(tMex, tSubtable[subrefDestroyedBuildingLocation]) <= iPotentialStorageDistance then
                                    bHaveNearbyMex = true
                                    break
                                end
                            end
                            if bHaveNearbyMex then
                                M28Map.RecordAvailableMassStorageLocationsForLandZone(iPlateauOrZero, iLandOrWaterZone)
                            end
                        end
                    end
                else
                    M28Utilities.ErrorHandler('No longer have M28 brain')
                    if bDebugMessages == true then
                        for iBrain, oBrain in ArmyBrains do
                            LOG(sFunctionRef..': Considering iBrain='..iBrain..'; oBrain='..(oBrain.Nickname or 'nil')..'; oBrain.M28IsDefeated='..tostring(oBrain.M28IsDefeated or false)..'; .M28AI='..tostring(oBrain.M28AI or false)..'; Team='..(oBrain.M28Team or 'nil'))
                        end
                        for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                            LOG(sFunctionRef..': Cycling all active M28 Brains, iBrain='..iBrain..'; oBrain='..(oBrain.Nickname or 'nil')..'; oBrain.M28IsDefeated='..tostring(oBrain.M28IsDefeated or false))
                        end
                    end
                end
            end
        else
            iLastEntryToRemove = iEntry - 1
            break
        end
    end
    if iLastEntryToRemove > 0 then
        for iEntry = iLastEntryToRemove, 1, -1 do
            table.remove(tRecentlyDestroyedBuildings, iEntry)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DestroyedBuildingLocationMonitor()
    if not(bActiveDestroyedBuildingLoop) then
        while M28Utilities.bM28AIInGame do
            WaitTicks(1)
            if M28Utilities.IsTableEmpty(tRecentlyDestroyedBuildings) == false then
                ForkThread(CheckDestroyedBuildingLocations)
            end
        end
    end
end

function EngineerInitialisation(aiBrain)
    --Variable declaration
    aiBrain[refiEngineerCurUniqueReference] = 0
    aiBrain[M28Factory.refiHighestFactoryBuildCount] = 0

    if not (bBuildLocationLoopActive) then
        ForkThread(SlowlyRefreshBuildableLandZoneLocations, aiBrain)
        ForkThread(DestroyedBuildingLocationMonitor)
    end
    if not (bWZBuildLocationLoopActive) then
        ForkThread(RecordBuildableCoreWaterZoneLocationsNearStartOfGame)
    end
end

function GetBPToAssignToBuildingTML(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam, bHaveLowMass)
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBPToAssignToBuildingTML'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iBPWanted = 0
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': TIme=' .. GetGameTimeSeconds() .. ' iPlateau=' .. iPlateau .. '; bHaveLowMass=' .. tostring(bHaveLowMass) .. '; Is core base=' .. tostring(tLZTeamData[M28Map.subrefLZbCoreBase]) .. '; is core expansion=' .. tostring(tLZTeamData[M28Map.subrefLZCoreExpansion]) .. '; iLandZone=' .. iLandZone)
    end
    if tLZTeamData[M28Map.subrefLZbCoreBase] or (tLZTeamData[M28Map.subrefLZCoreExpansion] and not (bHaveLowMass)) then
        --Make sure we have recorded pathing in a straight line for this zone (will only run if table is empty)
        M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint])

        if bDebugMessages == true then
            LOG(sFunctionRef .. ': M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] .. '; Is table of pathing to other LZ and WZ empty=' .. tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance])))
        end
        --Decided to remove the check about max enemy tech, as they may have T2 mexes but T1 units, and performance isn't as big a concern early-game anyway
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance]) == false then
            --Do we have any TML in this LZ already?
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Do we already have TML in this LZ? Is table of TML empty=' .. tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryTML, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]))))
            end
            if M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryTML, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])) then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': About to cycle through every land zone and consider targets')
                end
                for iEntry, tSubtable in tLZData[M28Map.subrefOtherLandAndWaterZonesByDistance] do
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Zone ' .. tSubtable[M28Map.subrefiLandOrWaterZoneRef] .. ' is distance ' .. tSubtable[M28Map.subrefiDistance] .. ' away')
                    end
                    if tSubtable[M28Map.subrefiDistance] <= M28Building.iTMLMissileRange then
                        if not (tSubtable[M28Map.subrefbIsWaterZone]) then
                            local tAltLZTeamData = M28Map.tAllPlateaus[tSubtable[M28Map.subrefiPlateauOrPond]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefiLandOrWaterZoneRef]][M28Map.subrefLZTeamData][iTeam]
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Considering enemy zone ' .. tSubtable[M28Map.subrefiLandOrWaterZoneRef] .. '; Is table of enemy TMD empty=' .. tostring(M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoEnemyTMD])) .. '; is talbe of enemy potential targets empty=' .. tostring(M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoEnemyTMD])))
                            end
                            if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoEnemyTMD]) == false then
                                --Refresh the table
                                local iLastEntry = table.getn(tAltLZTeamData[M28Map.subreftoEnemyTMD])
                                for iCurEntry = iLastEntry, 1, -1 do
                                    if not (M28UnitInfo.IsUnitValid(tAltLZTeamData[M28Map.subreftoEnemyTMD][iCurEntry])) then
                                        table.remove(tAltLZTeamData[M28Map.subreftoEnemyTMD], iCurEntry)
                                    end
                                end
                                if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoEnemyTMD]) == false then
                                    break
                                end
                            end
                            if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets]) == false then
                                --Refresh the list of potential targets
                                local iLastEntry = table.getn(tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets])
                                for iCurEntry = iLastEntry, 1, -1 do
                                    if not (M28UnitInfo.IsUnitValid(tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets][iCurEntry])) then
                                        table.remove(tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets], iCurEntry)
                                    end
                                end
                                if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets]) == false then
                                    --Do we have >=50% complete T2+ mex, or 100% of a high value alt unit?
                                    local iDecentTargetCount = 0
                                    local bDontDoDistanceCheck = false
                                    if table.getn(tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets]) >= 5 then bDontDoDistanceCheck = true end
                                    for iUnit, oUnit in tAltLZTeamData[M28Map.subreftoEnemyPotentialTMLTargets] do
                                        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()..'; Distance to midpoint='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint])) end
                                        if oUnit:GetFractionComplete() >= 0.75 then
                                            if bDontDoDistanceCheck or M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= M28Building.iTMLMissileRange - 10 then
                                                if EntityCategoryContains(M28UnitInfo.refCategoryMex - categories.TECH1, oUnit.UnitId) then
                                                    iDecentTargetCount = iDecentTargetCount + 1
                                                else iDecentTargetCount = iDecentTargetCount + oUnit:GetFractionComplete() *  (oUnit:GetBlueprint().BuildCostMass or 0) / 1200
                                                end
                                                if iDecentTargetCount >= 1 then break end
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': iDecentTargetCount='..iDecentTargetCount) end
                                    if iDecentTargetCount >= 1 then
                                        iBPWanted = 40
                                        if not (bHaveLowMass) then
                                            iBPWanted = 80
                                        end
                                        break
                                    end
                                end
                            end
                        end
                    else
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Remaining zones out of range so will abort')
                        end
                        break
                    end
                end
            end
        else
            M28Air.RecordOtherLandAndWaterZonesByDistance(tLZData, tLZData[M28Map.subrefMidpoint])
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBPWanted
end

function GetStartSearchPositionForEmergencyPD(tNearestEnemy, tLZMidpoint, iPlateau, iLandZone, tLZTeamData)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetStartSearchPositionForEmergencyPD'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)




    local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(tNearestEnemy, tLZMidpoint)
    local iDistToPointToMove = iDistToTarget
    local iDistToMove = math.max(32, iDistToTarget * 0.6)
    if iDistToTarget - iDistToMove >= 60 then
        iDistToMove = iDistToTarget - 60
    end
    local iAngleFromTargetToMidpoint
    local bUseLandTravelPath
    local tFullPath, iPathSize, iDistance
    local tPointToMoveFrom
    local tTargetLocation
    if iDistToTarget >= 25 and NavUtils.GetLabel(M28Map.refPathingTypeLand, tNearestEnemy) == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZMidpoint) then bUseLandTravelPath = true
        --Generate the land travel path from the enemy to our base
        tFullPath, iPathSize, iDistance = NavUtils.PathTo(M28Map.refPathingTypeLand, tLZMidpoint, tNearestEnemy)
        if not(tFullPath) then bUseLandTravelPath = false
        end
    end
    
    if bUseLandTravelPath then

        iDistToMove = math.max(math.min(30, iDistance), math.min(iDistance * 0.6, iDistToTarget))
        local iCurPathDistance = 0
        local iCumulativePathDistance = 0
        table.insert(tFullPath, 1, tNearestEnemy)
        table.insert(tFullPath, tLZMidpoint)
        if bDebugMessages == true then
            if bDebugMessages == true then LOG(sFunctionRef..': iDistance='..iDistance..'; iDistToTarget (straightline)='..iDistToTarget..'; tFullPath='..repru(tFullPath)..'; Will draw full path') end
            for iEntry, tViaPoint in tFullPath do
                if iEntry > 1 then
                    ForkThread(M28Utilities.ForkedDrawLine, tFullPath[iEntry - 1], tViaPoint, 2, 100)
                end
            end
        end
        local iCurSegmentX, iCurSegmentZ, iDetailedCurSegmentX, iDetailedCurSegmentZ

        for iCurEntry, tViaPoint in tFullPath do
            if iCurEntry > 1 then
                iCurPathDistance = M28Utilities.GetDistanceBetweenPositions(tFullPath[iCurEntry - 1], tViaPoint)
                iCumulativePathDistance = iCumulativePathDistance + iCurPathDistance
                if bDebugMessages == true then LOG(sFunctionRef..': Are using land travel path to get PD position, iCurEntry='..iCurEntry..'; tViaPoint='..repru(tViaPoint)..'; iCurPathDistance='..iCurPathDistance..'; iCumulativePathDistance before this='..iCumulativePathDistance..'; iDistToMove='..iDistToMove) end
                if iCumulativePathDistance >= iDistToMove then
                    iCurSegmentX, iCurSegmentZ = M28Map.GetPathingSegmentFromPosition(tViaPoint)
                    if M28Map.tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] == iLandZone then
                        --Get the detailed path between these two points
                        local iCumulativeDetailedPathDistance = iCumulativePathDistance - iCurPathDistance
                        local iCurDetailedPathDistance
                        local tDetailedPath, iDetailedPathEntries, iDetailedPathLength = NavUtils.DetailedPathTo(M28Map.refPathingTypeLand, tFullPath[iCurEntry - 1], tViaPoint)
                        if tDetailedPath then
                            table.insert(tDetailedPath, 1, tFullPath[iCurEntry - 1])
                            table.insert(tFullPath, tViaPoint)
                        end
                        if M28Utilities.IsTableEmpty(tDetailedPath) == false and iDetailedPathEntries >= 1 then
                            for iDetailedEntry, tDetailedViaPoint in tDetailedPath do
                                if iDetailedEntry > 1 then
                                    iCurDetailedPathDistance = M28Utilities.GetDistanceBetweenPositions(tDetailedViaPoint, tDetailedPath[iDetailedEntry - 1])
                                    iCumulativeDetailedPathDistance = iCumulativeDetailedPathDistance + iCurDetailedPathDistance
                                    iDetailedCurSegmentX, iDetailedCurSegmentZ = M28Map.GetPathingSegmentFromPosition(tDetailedViaPoint)
                                    if M28Map.tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] == iLandZone then
                                        if iCurDetailedPathDistance >= iDistToMove then
                                            tPointToMoveFrom = M28Utilities.MoveInDirection(tDetailedPath[iDetailedEntry - 1], M28Utilities.GetAngleFromAToB(tDetailedPath[iDetailedEntry - 1], tDetailedViaPoint), math.max(0, iDistToMove - iCumulativeDetailedPathDistance), true, false, true)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Setting PD placement using detailed path, tPointToMoveFrom='..repru(tPointToMoveFrom)) end
                                            break
                                        end
                                    end
                                end
                            end
                        end
                        if not(tPointToMoveFrom) then
                            --Redundancy
                            tPointToMoveFrom = M28Utilities.MoveInDirection(tFullPath[iCurEntry - 1], M28Utilities.GetAngleFromAToB(tFullPath[iCurEntry - 1], tViaPoint), math.max(iDistToMove - iCumulativePathDistance, 0), true, false, true)
                            if bDebugMessages == true then LOG(sFunctionRef..': Setting PD placement using simplified path as redundancy, tPointToMoveFrom='..repru(tPointToMoveFrom)) end
                        end
                        break
                    else
                        --Keep looking
                    end
                else
                    --Keep looking
                end
            end
        end
        if not(tPointToMoveFrom) then
            bUseLandTravelPath = false --revert to default logic (redundancy)
        else
            iAngleFromTargetToMidpoint = M28Utilities.GetAngleFromAToB(tPointToMoveFrom, tLZMidpoint)
            tTargetLocation = { tPointToMoveFrom[1], tPointToMoveFrom[2], tPointToMoveFrom[3] }
            iDistToMove = 0 --we are starting from the target location
            iDistToPointToMove = M28Utilities.GetDistanceBetweenPositions(tPointToMoveFrom, tLZMidpoint)
        end
        --else
    end
    if not(bUseLandTravelPath) then
        tPointToMoveFrom = {tNearestEnemy[1], tNearestEnemy[2], tNearestEnemy[3]}
        iAngleFromTargetToMidpoint = M28Utilities.GetAngleFromAToB(tNearestEnemy, tLZMidpoint)
        tTargetLocation = M28Utilities.MoveInDirection(tNearestEnemy, iAngleFromTargetToMidpoint, iDistToMove, true, false, true)
    end
    --Adjust if T2 arti nearby
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
        --Get closest T2 arti
        local oClosestT2Arti
        local iClosestT2ArtiDist = 100000
        local iCurDist
        for iUnit, oUnit in tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits] do
            if not(oUnit.Dead) then
                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation)
                if iCurDist < iClosestT2ArtiDist then
                    iClosestT2ArtiDist = iCurDist
                    oClosestT2Arti = oUnit
                end
            end
        end

        if oClosestT2Arti and iClosestT2ArtiDist <= (oClosestT2Arti[M28UnitInfo.refiIndirectRange] or 120) + 4 then
            iAngleFromTargetToMidpoint = M28Utilities.GetAngleFromAToB(oClosestT2Arti:GetPosition(), tLZMidpoint)
            iDistToMove = (oClosestT2Arti[M28UnitInfo.refiIndirectRange] or 120) + 10 - iClosestT2ArtiDist
            tTargetLocation = M28Utilities.MoveInDirection(tPointToMoveFrom, iAngleFromTargetToMidpoint, iDistToMove, true, false, true)
            if bDebugMessages == true then LOG(sFunctionRef..': Adjusted for T2 arti location, iClosestT2ArtiDist='..iClosestT2ArtiDist) end
        end
    end

    --Adjust if we end up out of the zone
    local iTargetPlateau, iTargetLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Time ' .. GetGameTimeSeconds() .. '; First position with iDistToMove=' .. iDistToMove .. '=' .. repru(tTargetLocation) .. '; tLZMidpoint=' .. repru(tLZMidpoint) .. '; tPointToMoveFrom=' .. repru(tPointToMoveFrom) .. '; Dist to midpoint=' .. M28Utilities.GetDistanceBetweenPositions(tPointToMoveFrom, tLZMidpoint) .. '; Dist to original target=' .. M28Utilities.GetDistanceBetweenPositions(tNearestEnemy, tTargetLocation) .. '; iTargetPlateau=' .. (iTargetPlateau or 'nil') .. '; iTargetLandZone=' .. (iTargetLandZone or 'nil')..'; iLandZone='..iLandZone)
    end
    while not (iLandZone == iTargetLandZone) do

        iDistToMove = iDistToMove + 5
        if iDistToMove > iDistToPointToMove then
            tTargetLocation = tLZMidpoint
            break
        else
            tTargetLocation = M28Utilities.MoveInDirection(tNearestEnemy, iAngleFromTargetToMidpoint, iDistToMove, true, false, true)
        end

        iTargetPlateau, iTargetLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
        if bDebugMessages == true then LOG(sFunctionRef..': Adjusted the target location by increasing the distance to move, New location='..repru(tTargetLocation)..'; land zone='..(iTargetLandZone or 'nil')..'; iLandZone='..iLandZone) end
    end


    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Time=' .. GetGameTimeSeconds() .. '; tNearestEnemy=' .. repru(tNearestEnemy) .. '; tLZMidpoint=' .. repru(tLZMidpoint) .. '; iAngleFromTargetToMidpoint=' .. iAngleFromTargetToMidpoint .. '; iDistToTarget=' .. iDistToTarget .. '; iDistToMove=' .. iDistToMove .. '; tTargetLocation=' .. repru(tTargetLocation)..'; will draw original target location in blue and the midpoint in red, and the revised target in gold')
        M28Utilities.DrawLocation(tNearestEnemy, 1)
        M28Utilities.DrawLocation(tLZMidpoint, 2)
        M28Utilities.DrawLocation(tTargetLocation, 4)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tTargetLocation
end

function GetMaxShieldSearchRangeForEngineer(oFirstEngineer, iCategoryWanted)
    --Sets max search range to ensure we dont go outside the max shield radius available to oFirstEngineer
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetMaxShieldSearchRangeForEngineer'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                                            --GetBlueprintThatCanBuildOfCategory(aiBrain,               iCategoryCondition, oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
    local tsAvailableBlueprints = M28Factory.GetBlueprintThatCanBuildOfCategory(oFirstEngineer:GetAIBrain(), iCategoryWanted, oFirstEngineer)
    local iMaxSearchRange = 10 --Default in case something goes wrong
    if M28Utilities.IsTableEmpty(tsAvailableBlueprints) == false then
        for iShield, sShield in tsAvailableBlueprints do
            iMaxSearchRange = math.max(iMaxSearchRange, (__blueprints[sShield].ShieldSize or 0) * 0.5)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iMaxSearchRange
end

function ClearEngineersBuildingUnit(oEngineer, oJustBuilt, bClearEngineersBuildingAtSameLocation)
    --Note - oJustBuilt can also be a unit under construction (e.g. if we want to cancel construction and reclaim it)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ClearEngineersBuildingUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Ignore logic if this was built as part of the gameendertemplate logic
    if not(oEngineer[M28Building.reftArtiTemplateRefs] or oJustBuilt[M28Building.reftArtiTemplateRefs]) and not(oEngineer[refiAssignedAction] == refActionSpecialShieldDefence) and not(oEngineer[refiAssignedAction] == refActionManageGameEnderTemplate) then

        local iAction = oEngineer[refiAssignedAction]

        function ClearEngineerIfActionObseleteNow(oCurEngineer, bCalledViaRepairTracking)
            local bClearEngineer = false
            if M28UnitInfo.IsUnitValid(oCurEngineer) and not (oCurEngineer:IsUnitState('Reclaiming')) then
                --Does it have the same action, or alternatitvely is it trying to build something at this location that will now be blocked?
                local tLastOrder = oCurEngineer[M28Orders.reftiLastOrders][oCurEngineer[M28Orders.refiOrderCount]]
                local iOrderDistToJustBuilt
                --Ignore if last order was to load onto transport
                if not(tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderLoadOntoTransport) and not(oEngineer[refiAssignedAction] == refActionLoadOntoTransport) then --redundancy
                    if M28Utilities.IsTableEmpty(tLastOrder[M28Orders.subreftOrderPosition]) == false then iOrderDistToJustBuilt = M28Utilities.GetDistanceBetweenPositions(tLastOrder[M28Orders.subreftOrderPosition], oJustBuilt:GetPosition()) end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if should clear engineer, oJustBuilt='..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; oCurEngineer='..oCurEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oCurEngineer)..'; iOrderDistToJustBuilt='..iOrderDistToJustBuilt..'; tLastOrder[M28Orders.subrefoOrderUnitTarget]='..(tLastOrder[M28Orders.subrefoOrderUnitTarget].UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(tLastOrder[M28Orders.subrefoOrderUnitTarget]) or 'nil')..'; iAction='..(iAction or 'nil')..'; Cur engineer action='..(oCurEngineer[refiAssignedAction] or 'nil')) end
                    if iOrderDistToJustBuilt <= 1 or tLastOrder[M28Orders.subrefoOrderUnitTarget] == oJustBuilt then
                        bClearEngineer = true
                    elseif bCalledViaRepairTracking and oCurEngineer:GetFocusUnit() == oJustBuilt then
                        bClearEngineer = true
                        --Are we building something near here that is now blocked?
                    elseif iOrderDistToJustBuilt and iOrderDistToJustBuilt <= 10 and tLastOrder[M28Orders.subrefsOrderBlueprint] then
                        local oBlueprint = __blueprints[tLastOrder[M28Orders.subrefsOrderBlueprint]]
                        local iBuildingRadius = math.min(oBlueprint.Physics.SkirtSizeX, oBlueprint.Physics.SkirtSizeZ) * 0.5
                        if iOrderDistToJustBuilt < iBuildingRadius * 1.45 then --1.4142 should be enough, 1.45 used for prudence
                            --do more precise check
                            if math.abs(tLastOrder[M28Orders.subreftOrderPosition][1] - oJustBuilt:GetPosition()[1]) < iBuildingRadius and math.abs(tLastOrder[M28Orders.subreftOrderPosition][3] - oJustBuilt:GetPosition()[3]) < iBuildingRadius then
                                bClearEngineer = true
                            end
                        end

                    end
                end
                if bClearEngineer then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will clear engineer') end
                    M28Orders.IssueTrackedClearCommands(oCurEngineer)
                end
            end
        end

        if (tiActionOrder[iAction] == M28Orders.refiOrderIssueBuild and not (tbIgnoreEngineerAssistance[iAction])) or (oJustBuilt:GetFractionComplete() == 1 and EntityCategoryContains(M28UnitInfo.refCategoryStructure, oJustBuilt.UnitId)) then
            --FIrst clear any engineers tracked as repariing this building
            if M28Utilities.IsTableEmpty(oJustBuilt[M28Orders.toUnitsOrderedToRepairThis]) == false then
                for iCurEngineer = table.getn(oJustBuilt[M28Orders.toUnitsOrderedToRepairThis]), 1, -1 do
                    ClearEngineerIfActionObseleteNow(oJustBuilt[M28Orders.toUnitsOrderedToRepairThis][iCurEngineer], true)
                end
            end
            local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oEngineer:GetPosition())
            if (iLandOrWaterZone or 0) > 0 then
                local tLZOrWZTeamData
                local aiBrain = oEngineer:GetAIBrain()
                local iTeam = aiBrain.M28Team
                if iPlateauOrZero == 0 then
                    tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
                else
                    tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
                end
                if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                    local tAllEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                    if M28Utilities.IsTableEmpty(tAllEngineers) == false then
                        for iUnit, oUnit in tAllEngineers do
                            ClearEngineerIfActionObseleteNow(oUnit, false)
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ClearEngineersWhoseTargetIsNowBlockedByUnitConstructionStarted(oEngineer, oConstruction)
    --Idea is to prevent scenarios where two units get queued orders for the same location - once construction is started for one, it wont be possible for the other
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ClearEngineersWhoseTargetIsNowBlockedByUnitConstructionStarted'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iAction = oEngineer[refiAssignedAction]
    if tiActionOrder[iAction] == M28Orders.refiOrderIssueBuild then
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oConstruction:GetPosition())
        if (iLandOrWaterZone or 0) > 0 then
            local tLZOrWZTeamData
            local aiBrain = oEngineer:GetAIBrain()
            local iTeam = aiBrain.M28Team
            if iPlateauOrZero == 0 then
                tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
            else
                tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
            end
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                local tAllEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if M28Utilities.IsTableEmpty(tAllEngineers) == false then
                    local iBuildingSizeRadius = M28UnitInfo.GetBuildingSize(oConstruction.UnitId) * 0.5
                    local iQueuedBuildingSizeRadius
                    for iUnit, oUnit in tAllEngineers do
                        if M28UnitInfo.IsUnitValid(oUnit) and oUnit[refiAssignedAction] and not (oUnit[refiAssignedAction] == iAction) and not (oUnit:IsUnitState('Reclaiming')) and tiActionOrder[oUnit[refiAssignedAction]] == M28Orders.refiOrderIssueBuild then
                            local tLastOrder = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]]
                            if tLastOrder[M28Orders.subrefsOrderBlueprint] then
                                if M28Utilities.IsTableEmpty(tLastOrder[M28Orders.subreftOrderPosition]) == false then
                                    iQueuedBuildingSizeRadius = M28UnitInfo.GetBuildingSize(tLastOrder[M28Orders.subrefsOrderBlueprint]) * 0.5
                                    if M28Utilities.GetRoughDistanceBetweenPositions(tLastOrder[M28Orders.subreftOrderPosition], oConstruction:GetPosition()) < iBuildingSizeRadius + iQueuedBuildingSizeRadius then
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Clearing engineer ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. ' as it has a queued order ' .. reprs(tLastOrder) .. ' that is blocked by oConstruction=' .. oConstruction.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oConstruction.UnitId))
                                        end
                                        M28Orders.IssueTrackedClearCommands(oUnit)
                                    end
                                end
                            end
                        end
                    end
                end
            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function ConsiderDestroyingLowTechEngineers(oJustBuilt)
    --Intended late game where lots of low tech engis in a core base
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderDestroyingLowTechEngineers'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain = oJustBuilt:GetAIBrain()
    local iCurEngineers = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer)
    if iCurEngineers >= 100 then
        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oJustBuilt:GetPosition())
        if (iLandOrWaterZone or 0) > 0 then
            local tLZOrWZTeamData
            local iTeam = aiBrain.M28Team
            if iPlateauOrZero == 0 then
                tLZOrWZTeamData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone][M28Map.subrefWZTeamData][iTeam]
            else
                tLZOrWZTeamData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone][M28Map.subrefLZTeamData][iTeam]
            end
            if M28Utilities.IsTableEmpty(tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                local tT1AndT2EngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer * categories.TECH1 + M28UnitInfo.refCategoryEngineer * categories.TECH2, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                if M28Utilities.IsTableEmpty(tT1AndT2EngineersInZone) == false then
                    local iT1AndT2EngineersInZone = table.getn(tT1AndT2EngineersInZone)
                    if iT1AndT2EngineersInZone >= 10 or (iCurEngineers >= 150 and iT1AndT2EngineersInZone >= 4) then
                        local tT3EngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer * categories.TECH3, tLZOrWZTeamData[M28Map.subreftoLZOrWZAlliedUnits])

                        if M28Utilities.IsTableEmpty(tT3EngineersInZone) == false then
                            local iT3EngineersInZone = table.getn(tT3EngineersInZone)
                            if iT3EngineersInZone >= 40 then
                                --Ctrl-K up to 3 engineers
                                local iEngineersKilled = 0
                                local tT1Engineers = EntityCategoryFilterDown(categories.TECH1, tT1AndT2EngineersInZone)
                                local iT1Count = 0
                                function KillEngineerIfSufficientlyIdle(oEngi)
                                    if not (oEngi[refbPrimaryBuilder]) and not (oEngi:IsUnitState('Building')) and not (oEngi:IsUnitState('Reclaiming')) and not (oEngi:IsUnitState('Capturing')) and not (oEngi:IsUnitState('Repairing')) then
                                        if bDebugMessages == true then LOG(sFunctionRef .. ': Just given order to kill unit ' .. oEngi.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oEngi) .. ' as have oto many engis in this zone') end
                                        M28Orders.IssueTrackedKillUnit(oEngi)
                                        iEngineersKilled = iEngineersKilled + 1
                                    end
                                end
                                if M28Utilities.IsTableEmpty(tT1Engineers) == false then
                                    for iUnit, oUnit in tT1Engineers do
                                        if (not(oUnit[M28UnitInfo.refbCampaignTriggerAdded]) or not(M28Map.bIsCampaignMap)) then
                                            KillEngineerIfSufficientlyIdle(oUnit)
                                            if iEngineersKilled >= 3 then
                                                break
                                            end
                                        end
                                    end
                                end
                                if iEngineersKilled < 3 then
                                    local tT2Engineers = EntityCategoryFilterDown(categories.TECH2, tT1AndT2EngineersInZone)
                                    if M28Utilities.IsTableEmpty(tT2Engineers) == false then
                                        for iUnit, oUnit in tT2Engineers do
                                            if (not(oUnit[M28UnitInfo.refbCampaignTriggerAdded]) or not(M28Map.bIsCampaignMap)) then
                                                KillEngineerIfSufficientlyIdle(oUnit)
                                                if iEngineersKilled >= 3 then
                                                    break
                                                end
                                            end
                                        end
                                    end
                                end

                            end
                        end
                    end
                end
            end
        end
    end
end

function RecordUnitAsCaptureTarget(oUnit, bOptionalOnlyRecordIfSameUnitIdInCaptureList)
    --bOptionalOnlyRecordIfSameUnitIdInCaptureList - true if we only want to record oUnit if a unit with the same .UnitId is in the zone as a capture target - i.e. intended where a unit is captured that can be captured back
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordUnitAsCaptureTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if M28Map.bIsCampaignMap and not(EntityCategoryContains(categories.MOBILE, oUnit.UnitId)) then
        while not(M28Map.bWaterZoneInitialCreation) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if GetGameTimeSeconds() >= 10 then break end
        end

        local iPlateauOrZero, iLandOrWaterZone = M28Map.GetClosestPlateauOrZeroAndZoneToPosition(oUnit:GetPosition())
        local tLZOrWZData
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, time='..GetGameTimeSeconds()..';  oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; Unit position='..repru(oUnit:GetPosition())..'; Unit owner='..oUnit:GetAIBrain().Nickname) end
        if iLandOrWaterZone > 0 then
            if iPlateauOrZero == 0 then
                tLZOrWZData = M28Map.tPondDetails[M28Map.tiPondByWaterZone[iLandOrWaterZone]][M28Map.subrefPondWaterZones][iLandOrWaterZone]
            else
                tLZOrWZData = M28Map.tAllPlateaus[iPlateauOrZero][M28Map.subrefPlateauLandZones][iLandOrWaterZone]
            end
            --If this was called via onunitcaptured then want to check if the same unitid was recorded in a table of capture targets:
            local bWantToCaptureUnit = not(bOptionalOnlyRecordIfSameUnitIdInCaptureList)
            if bOptionalOnlyRecordIfSameUnitIdInCaptureList then
                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subreftoUnitsToCapture]) == false then
                    for iCaptureTarget, oCaptureTarget in tLZOrWZData[M28Map.subreftoUnitsToCapture] do
                        if oCaptureTarget.UnitId == oUnit.UnitId then
                            bWantToCaptureUnit = true
                            break
                        end
                    end
                end
            end

            --Check we havent already recorded this unit
            if bWantToCaptureUnit and oUnit[M28UnitInfo.refbIsCaptureTarget] and M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subreftoUnitsToCapture]) == false then
                for iRecordedUnit, oRecordedUnit in tLZOrWZData[M28Map.subreftoUnitsToCapture] do
                    if oRecordedUnit == oUnit then
                        bWantToCaptureUnit = false
                        break
                    end
                end
            end

            --Record unit against zone as a capture target and flag so we dont try and reclaim it
            if bDebugMessages == true then LOG(sFunctionRef..': bWantToCaptureUnit='..tostring(bWantToCaptureUnit)..'; oUnit='..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..'; iPlateauOrZero='..(iPlateauOrZero or 'nil')..'; iLandOrWaterZone='..(iLandOrWaterZone or 'nil')) end
            if bWantToCaptureUnit then
                if M28Utilities.IsTableEmpty(tLZOrWZData[M28Map.subreftoUnitsToCapture]) then tLZOrWZData[M28Map.subreftoUnitsToCapture] = {} end
                table.insert(tLZOrWZData[M28Map.subreftoUnitsToCapture], oUnit)
                oUnit[M28UnitInfo.refbIsCaptureTarget] = true
                if bDebugMessages == true then LOG(sFunctionRef..': Added unit to table of units to capture') end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckForSpecialCampaignCaptureTargets()
    --Called whenever we get a new objective or the map size changes, as a basic way of checking for extra objectives that dont use the normal objective function
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckForSpecialCampaignCaptureTargets'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --FA M6 - check for control centre building
    if bDebugMessages == true then LOG(sFunctionRef..': is ControlCentreBldg nil='..tostring(ScenarioInfo.ControlCenterBldg == nil)) end
    if ScenarioInfo.ControlCenterBldg then
        local oControlCentre = ScenarioInfo.ControlCenterBldg
        if bDebugMessages == true then LOG(sFunctionRef..': oControlCentre='..(oControlCentre.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oControlCentre) or 'nil')..'; Is capturable='..tostring(oControlCentre:IsCapturable())..'; refbIsCaptureTarget='..tostring(oControlCentre[M28UnitInfo.refbIsCaptureTarget] or false)) end
        if M28UnitInfo.IsUnitValid(oControlCentre) and oControlCentre:IsCapturable() then
            --Have we already recorded as a capturable target?
            if not(oControlCentre[M28UnitInfo.refbIsCaptureTarget]) then
                --Get first M28 brain in game
                local oFirstM28Brain
                if M28Utilities.IsTableEmpty(M28Overseer.tAllActiveM28Brains) == false then
                    for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                        if oBrain.M28AI then
                            oFirstM28Brain = oBrain
                            if not(oBrain.CampaignAI) then
                                break
                            end
                        end
                    end
                end
                if oFirstM28Brain and not(IsAlly(oFirstM28Brain:GetArmyIndex(), oControlCentre:GetAIBrain():GetArmyIndex())) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will call logic to record control centre as a capture target') end
                    RecordUnitAsCaptureTarget(oControlCentre)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function GetLocationToBuildWall(oEngineer, oJustBuilt, sWallBP)
    --Builds wall around nearby T1 PD (if there is any), subject to blacklist
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetLocationToBuildWall'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local oPDToSurround
    if EntityCategoryContains(M28UnitInfo.refCategoryPD * categories.TECH1, oJustBuilt.UnitId) then
        if oJustBuilt:GetBlueprint().Physics.SkirtSizeX <= 1 then
            oPDToSurround = oJustBuilt
        end
    else
        --Search nearby for T1 PD
        local tNearbyUnits = GetUnitsInRect(M28Utilities.GetRectAroundLocation(oJustBuilt:GetPosition(), 1.9))
        if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
            local tNearbyPD = EntityCategoryFilterDown(M28UnitInfo.refCategoryPD * categories.TECH1, tNearbyUnits)
            if M28Utilities.IsTableEmpty(tNearbyPD) == false then
                local tSuitablePDSize = {}
                for iUnit, oUnit in tNearbyPD do
                    if oUnit:GetBlueprint().Physics.SkirtSizeX <= 1 then
                        table.insert(tSuitablePDSize, oUnit)
                    end
                end
                if M28Utilities.IsTableEmpty(tSuitablePDSize) == false then
                    local iCurDist
                    local iClosestDist = 10000
                    if table.getn(tSuitablePDSize) > 1 then
                        for iPD, oPD in tSuitablePDSize do
                            iCurDist = M28Utilities.GetRoughDistanceBetweenPositions(oPD:GetPosition(), oJustBuilt:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oPDToSurround = oPD
                            end
                        end
                    else
                        oPDToSurround = tSuitablePDSize[1]
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Near start, oPDToSurround='..(oPDToSurround.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oPDToSurround) or 'nil')..'; Gametime='..GetGameTimeSeconds()..'; oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)) end
    if oPDToSurround then
        local tPDToSurround = oPDToSurround:GetPosition()
        --Get first location around the PD that is available for building, if any
        local aiBrain = oEngineer:GetAIBrain()
        for iXAdjust = -1, 1, 1 do
            for iZAdjust = -1, 1, 1 do
                if not(iXAdjust == 0 and iZAdjust == 0) then
                    local tTargetLocation = {tPDToSurround[1] + iXAdjust, tPDToSurround[2], tPDToSurround[3] + iZAdjust}
                    tTargetLocation[2] = GetSurfaceHeight(tTargetLocation[1], tTargetLocation[3])
                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                    if bDebugMessages == true then LOG(sFunctionRef..': Can engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' that has just built unit '..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..' at position '..repru(oJustBuilt:GetPosition())..' build at tTargetLocation '..repru(tTargetLocation)..'='..tostring(CanBuildAtLocation(aiBrain, sWallBP, tTargetLocation, nil, nil, nil, false, true, false, true))..'; Simple can build check='..tostring(aiBrain:CanBuildStructureAt(sWallBP, tTargetLocation))..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
                    if (iPlateau or 0) > 0 and (iLandZone or 0) > 0 then
                        --CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, iOptionalPlateauGroupOrZero, iOptionalLandOrWaterZone, iEngiActionToIgnore, bClearActionsIfNotStartedBuilding, bCheckForQueuedBuildings, bCheckForOverlappingBuildings, bCheckBlacklistIfNoGameEnder)
                        if CanBuildAtLocation(aiBrain, sWallBP,         tTargetLocation,     iPlateau,                  iLandZone, nil, false, true, false, true) then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return tTargetLocation
                        end
                    --sometimes an area might appear to be on a cliff but could still fit a wall piece
                    elseif aiBrain:CanBuildStructureAt(sWallBP, tTargetLocation) then
                        return tTargetLocation
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderClearingEngineersForUnitJustDamagedOrDestroyed(oUnit, iOptionalEngineerActionLimitation)
    --E.g. intended for building emergency PD where we built too close to the frontline and it got destroyed so we dont send more engineeres to their death but try and build further back
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderClearingEngineersForUnitJustDamagedOrDestroyed'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Time='..GetGameTimeSeconds())
        if M28UnitInfo.IsUnitValid(oUnit) then
            LOG(sFunctionRef..': Unit cur health%='..M28UnitInfo.GetUnitHealthPercent(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete())
        end
    end
    oUnit[refbDontIncludeAsPartCompleteBuildingForConstruction] = true
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
    if (iLandZone or 0) > 0 and iPlateau then
        local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
        local tEngineersInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tEngineersInZone) == false then
            local tEngineersToClear = {}
            local bIgnoreBuildDistanceCheck = not(M28UnitInfo.IsUnitValid(oUnit))
            for iEngineer, oEngineer in tEngineersInZone do
                if M28UnitInfo.IsUnitValid(oEngineer) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering engineer in zone, oENgineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Engineer assigned action='..(oEngineer[refiAssignedAction] or 'nil')) end
                    if not(iOptionalEngineerActionLimitation) or oEngineer[refiAssignedAction] == iOptionalEngineerActionLimitation then
                        local tLastOrder = oEngineer[M28Orders.reftiLastOrders][oEngineer[M28Orders.refiOrderCount]]
                        if bDebugMessages == true then LOG(sFunctionRef..': Engineer order blueprint='..(tLastOrder[M28Orders.subrefsOrderBlueprint] or 'nil')..'; Orer position='..repru(tLastOrder[M28Orders.subreftOrderPosition])..'; Dist to unit position='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), (tLastOrder[M28Orders.subreftOrderPosition] or {0,0,0}))..'; Order count='..(oEngineer[M28Orders.refiOrderCount] or 'nil')) end
                        if tLastOrder[M28Orders.subrefsOrderBlueprint] == oUnit.UnitId and tLastOrder[M28Orders.subreftOrderPosition] and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLastOrder[M28Orders.subreftOrderPosition]) <= 1 and (bIgnoreBuildDistanceCheck or M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), oUnit:GetPosition()) >= 2 + (oEngineer:GetBlueprint().Economy.MaxBuildDistance or 5)) then
                            --Clear engineer
                            if bDebugMessages == true then LOG(sFunctionRef..': Will add engiener to list of engineers whose orders are to be cleared') end
                            table.insert(tEngineersToClear, oEngineer)
                        end
                    end
                end
                end
            if M28Utilities.IsTableEmpty(tEngineersToClear) == false then
                for iUnit, oEngineer in tEngineersToClear do
                    M28Orders.IssueTrackedClearCommands(oEngineer)
                end
            end
        end
    end
end

function GiveOrderForEmergencyT2Arti(HaveActionToAssign, bHaveLowMass, bHaveLowPower, iPlateau, iLandZone, tLZData, tLZTeamData, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GiveOrderForEmergencyT2Arti'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Only want to get for core base or minor zones iwth lots of mexes that have a positive mod distance
    if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Core base='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])..'; Mex count by tech='..repru(tLZTeamData[M28Map.subrefMexCountByTech])..'; Is team stalling mass='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass])..'; Is team stalling power='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; Mod dist='..tLZTeamData[M28Map.refiModDistancePercent]..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Time='..GetGameTimeSeconds()) end
    if tLZTeamData[M28Map.subrefLZbCoreBase] or
            ((tLZTeamData[M28Map.subrefMexCountByTech][2] >= 4 or (tLZTeamData[M28Map.subrefMexCountByTech][3] >= 1 and (tLZTeamData[M28Map.subrefMexCountByTech][3] * 2 + tLZTeamData[M28Map.subrefMexCountByTech][2] >= 4))) and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) and not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and tLZTeamData[M28Map.refiModDistancePercent] > 0.05) then

        local iBPWanted = 0
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want emergency T2 arti, M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech]..'; Friendly tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Is table of pathing to other zones empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]))..'; Is tLZTeamData[M28Map.subreftEnemyFirebasesInRange] empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]))) end
        if ((tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) > 0 or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftLongRangeEnemyDFUnits]) == false or (tLZTeamData[M28Map.subrefLZbCoreBase] and tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 and GetGameTimeSeconds() - (tLZTeamData[M28Map.subrefiTimeOfMMLFiringNearTMDOrShield] or -100) <= 5) or (M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 5) and (not(M28Overseer.bNoRushActive) or M28Overseer.iNoRushTimer - GetGameTimeSeconds() <= 180 or ((not(bHaveLowMass) or tLZTeamData[M28Map.subrefMexCountByTech][3] >= 2 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 10 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and (not(bHaveLowPower) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 250 + 75 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and ((tLZTeamData[M28Map.subrefMexCountByTech][1] == 0 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 12 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) and tLZTeamData[M28Map.subrefMexCountByTech][2] + tLZTeamData[M28Map.subrefMexCountByTech][3] > 0))) then
            local iRangeThreshold = 65
            local iEnemyLongRangeThreat = 0
            local iSearchRange = 300
            local iBestEnemyRange = 0
            local iCurDFThreat, iCurIFThreat

            local iLowerThreatFactorDist = 180
            local iLowerThreatFactor = 0.5
            local iCurThreatFactor
            if not(tLZTeamData[M28Map.subrefLZbCoreBase]) and tLZTeamData[M28Map.subrefMexCountByTech][3] < 5 then
                if tLZTeamData[M28Map.subrefMexCountByTech][3] <= 3 then
                    iLowerThreatFactorDist = 160
                    iSearchRange = 250
                else
                    iSearchRange = 275
                end
            end
            local iHighestIndividiualLongRangeThreat = math.min(25000, (tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0))
            local iNearbyEnemyFixedShieldThreat = (tLZTeamData[M28Map.subrefLZThreatEnemyShield] or 0)


            if tLZTeamData[M28Map.refbBaseInSafePosition] then
                iSearchRange = 200
                iHighestIndividiualLongRangeThreat = iHighestIndividiualLongRangeThreat * 0.5
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of firebases in range empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]))) end
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
                for iFirebase, tPlateauAndZone in tLZTeamData[M28Map.subreftEnemyFirebasesInRange] do
                    iEnemyLongRangeThreat = iEnemyLongRangeThreat + math.max(1500, (M28Map.tAllPlateaus[tPlateauAndZone[1]][M28Map.subrefPlateauLandZones][tPlateauAndZone[2]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefThreatEnemyStructureTotalMass] or 0))
                    if bDebugMessages == true then LOG(sFunctionRef..': iEnemyLongRangeThreat after increasing for firebase in tPlateauAndZone '..repru(tPlateauAndZone)..'='..iEnemyLongRangeThreat) end
                end
            end
            --Only consider enemy long range threat in adjacent zones - if already in this zone then presumably too close for arti to help that much
            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
                local bHaveMobileLRThreatNearby = false
                for iEntry, tSubtable in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                    if tSubtable[M28Map.subrefLZTravelDist] > iSearchRange then break
                    else
                        iCurThreatFactor = 1
                        if tSubtable[M28Map.subrefLZTravelDist] > iLowerThreatFactorDist then iCurThreatFactor = iLowerThreatFactor end
                        local iAltLZ = tSubtable[M28Map.subrefLZNumber]
                        local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAltLZ][M28Map.subrefLZTeamData][iTeam]
                        iCurDFThreat = 0
                        iCurIFThreat = 0
                        if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) == false then
                            for iRange, iThreat in tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] do
                                if iRange >= iRangeThreshold then
                                    iCurDFThreat = iCurDFThreat + iThreat * iCurThreatFactor
                                    iBestEnemyRange = math.max(iBestEnemyRange, iRange)
                                end
                            end
                        end
                        if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange]) == false then
                            for iRange, iThreat in tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] do
                                if iRange >= iRangeThreshold then
                                    iCurIFThreat = iCurIFThreat + iThreat * iCurThreatFactor
                                    iBestEnemyRange = math.max(iBestEnemyRange, iRange)
                                end
                            end
                        end
                        iEnemyLongRangeThreat = iEnemyLongRangeThreat + math.max(iCurIFThreat, iCurDFThreat)
                        if not(tLZTeamData[M28Map.refbBaseInSafePosition]) then
                            if (tAltLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) > iHighestIndividiualLongRangeThreat then
                                if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats]) == false then
                                    bHaveMobileLRThreatNearby = false
                                    for iUnit, oUnit in tAltLZTeamData[M28Map.subrefoNearbyEnemyLongRangeThreats] do
                                        if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then
                                            iHighestIndividiualLongRangeThreat = math.max(iHighestIndividiualLongRangeThreat, M28UnitInfo.GetCombatThreatRating({ oUnit }, true))
                                        end
                                    end
                                end
                            end

                        end
                        iNearbyEnemyFixedShieldThreat = iNearbyEnemyFixedShieldThreat + (tAltLZTeamData[M28Map.subrefLZThreatEnemyShield] or 0)
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished considering iAltLZ='..iAltLZ..'; iCurIFThreat='..iCurIFThreat..'; iCurDFThreat='..iCurDFThreat..'; iEnemyLongRnageThreat='..iEnemyLongRangeThreat..'; tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]='..repru(tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange])..'; tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange]='..repru(tAltLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange])..'; iNearbyEnemyFixedShieldThreat='..iNearbyEnemyFixedShieldThreat..'; Zone dist='..tSubtable[M28Map.subrefLZTravelDist]) end
                    end
                end
            end
            local iLongRangeFurtherAwayThreat = M28Land.GetFarAwayLandThreatOfLongRangeUnits(tLZData[M28Map.subrefMidpoint], iTeam, not(tLZTeamData[M28Map.subrefLZbCoreBase])) --Will just consider mobile long range units
            if iLongRangeFurtherAwayThreat > 0 then iBestEnemyRange = math.max(90, iBestEnemyRange) end --assume enemy long range threat will be at least 90, e.g. fatboy

            if bDebugMessages == true then LOG(sFunctionRef..': iEnemyLongRangeThreat after checking all zones within dist threshold='..iEnemyLongRangeThreat..'; iHighestIndividiualLongRangeThreat='..iHighestIndividiualLongRangeThreat..'; Is table of enemy T2 arti empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]))..'; iLongRangeFurtherAwayThreat='..iLongRangeFurtherAwayThreat..'; iNearbyEnemyFixedShieldThreat='..iNearbyEnemyFixedShieldThreat) end
            if iEnemyLongRangeThreat >= 750 or iLongRangeFurtherAwayThreat >= 750 or iHighestIndividiualLongRangeThreat > 0 or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false or iNearbyEnemyFixedShieldThreat > 0 then
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then

                    --Increase long range threat based on enemy T2 arti within 175 of our midpoint
                    for iT2Arti, oT2Arti in tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits] do
                        if M28UnitInfo.IsUnitValid(oT2Arti) then
                            if M28Utilities.GetDistanceBetweenPositions(oT2Arti:GetPosition(), tLZData[M28Map.subrefMidpoint]) <= (oT2Arti[M28UnitInfo.refiIndirectRange] or 'nil') + 50 then
                                iBestEnemyRange = math.max(iBestEnemyRange, (oT2Arti[M28UnitInfo.refiIndirectRange] or 'nil'))
                                iEnemyLongRangeThreat = iEnemyLongRangeThreat + oT2Arti:GetBlueprint().Economy.BuildCostMass
                            end
                        end
                    end
                elseif iHighestIndividiualLongRangeThreat then iBestEnemyRange = math.max(iBestEnemyRange, 80)
                end



                --What is our long range threat that equals their range?
                iCurDFThreat = 0
                iCurIFThreat = 0
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
                    for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                        if iRange >= iBestEnemyRange then iCurDFThreat = iCurDFThreat + iThreat end
                    end
                end
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange]) == false then
                    for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] do
                        if iRange >= iBestEnemyRange then iCurIFThreat = iCurIFThreat + iThreat end
                    end
                end
                local iThreatWanted = math.max(iEnemyLongRangeThreat * 1.5, iHighestIndividiualLongRangeThreat * 0.75, iLongRangeFurtherAwayThreat) + iNearbyEnemyFixedShieldThreat * 5 - iCurDFThreat * 0.75 - iCurIFThreat
                if iNearbyEnemyFixedShieldThreat > 0 and iEnemyLongRangeThreat > 0 and (tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 12 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                    if iThreatWanted >= 4000 or (not(bHaveLowMass) and not(bHaveLowPower) and (tLZTeamData[M28Map.subrefMexCountByTech][3] or 0) >= math.min(4, tLZData[M28Map.subrefLZMexCount]) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 20 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                        iThreatWanted = math.max(10000, iThreatWanted)
                    elseif iNearbyEnemyFixedShieldThreat >= 1000 or iEnemyLongRangeThreat >= 1000 then
                        iThreatWanted = math.max(4000, iThreatWanted)
                    end
                end


                if iEnemyLongRangeThreat >= 1600 then iThreatWanted = math.max(iThreatWanted, 500) end --Want 1 T2 arti if enemy has significant long rnage threat, even if we have friendly units
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits]) == false then
                    iThreatWanted = math.max(iThreatWanted, 2 * M28UnitInfo.GetCombatThreatRating(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits], true, true))
                end
                if not(tLZTeamData[M28Map.subrefLZbCoreBase]) then iThreatWanted = iThreatWanted * 0.75 end

                if iThreatWanted >= 25000 then
                    if iThreatWanted >= 50000 then
                        iThreatWanted = math.min(70000, 25000 + 12500 + (iThreatWanted - 50000) * 0.2)
                    else
                        iThreatWanted = 25000 + (iThreatWanted - 25000) * 0.5
                    end
                    if not(tLZTeamData[M28Map.subrefLZbCoreBase]) then iThreatWanted = 25000 end
                end


                if bDebugMessages == true then LOG(sFunctionRef..': iCurDFThreat='..iCurDFThreat..'; iCurIFThreat='..iCurIFThreat..'; iThreatWanted='..iThreatWanted..'; iLongRangeFurtherAwayThreat='..iLongRangeFurtherAwayThreat..'; iBestEnemyRange='..iBestEnemyRange) end
                if iThreatWanted >= 500 or (iThreatWanted > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 18 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount]) then
                    --Get friendly T2 arti threat
                    local iT2ArtiThreat = 0
                    local iT2ArtiCount = 0
                    local toT2ArtiWantingShields = {}
                    local tT2Arti
                    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits]) == false then
                        tT2Arti = EntityCategoryFilterDown(M28UnitInfo.refCategoryFixedT2Arti, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                        if M28Utilities.IsTableEmpty(tT2Arti) == false then
                            iT2ArtiThreat = M28UnitInfo.GetCombatThreatRating(tT2Arti, false, true) --Will be 60% of mass cost per getcombatthreatrating
                            for iArti, oArti in tT2Arti do
                                if oArti:GetFractionComplete() == 1 then iT2ArtiCount = iT2ArtiCount + 1 end
                                if oArti[M28Building.refbUnitWantsShielding] and M28Utilities.IsTableEmpty(oArti[M28Building.reftoShieldsProvidingCoverage]) and (oArti[refiFailedShieldConstructionCount] or 0) <= 1 then
                                    table.insert(toT2ArtiWantingShields, oArti)
                                end
                            end
                        end
                    end

                    if iT2ArtiThreat >= math.max(11000, math.min(iLongRangeFurtherAwayThreat * 1.25, 30000)) then iThreatWanted = iThreatWanted * 0.8 end
                    if tLZTeamData[M28Map.refbBaseInSafePosition] then iThreatWanted = iThreatWanted * 0.75 end
                    iThreatWanted = iThreatWanted - iT2ArtiThreat
                    iBPWanted = 240 --default
                    local bAreBuildingShield = false
                    if bDebugMessages == true then LOG(sFunctionRef..': iT2ArtiThreat='..iT2ArtiThreat..'; iThreatWanted='..iThreatWanted..'; iLongRangeFurtherAwayThreat='..iLongRangeFurtherAwayThreat..'; Threat rating of all nearby enemy T2 arti='..M28UnitInfo.GetCombatThreatRating(tLZTeamData[M28Map.subreftoAllNearbyEnemyT2ArtiUnits], true, true)..'; iLongRangeFurtherAwayThreat='..iLongRangeFurtherAwayThreat) end
                    if iT2ArtiThreat > 0 and tLZTeamData[M28Map.refiRadarCoverage] <= 60 then
                        if tLZTeamData[M28Map.subrefLZbCoreBase] then
                            HaveActionToAssign(refActionBuildT2Radar, 2, iBPWanted)
                        else
                            HaveActionToAssign(refActionBuildT1Radar, 1, iBPWanted * 0.5)
                        end
                    elseif M28Utilities.IsTableEmpty(toT2ArtiWantingShields) == false and iT2ArtiCount >= 2 and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoLZUnitWantingFixedShield]) == false then
                        if table.getn(toT2ArtiWantingShields) >= 4 or iT2ArtiCount >= 6 then iBPWanted = 240
                        else iBPWanted = 120
                        end
                        if bHaveLowMass or bHaveLowPower then iBPWanted = iBPWanted * 0.5 end
                        local oArtiToShield = M28Utilities.GetNearestUnit(toT2ArtiWantingShields, tLZData[M28Map.subrefMidpoint])
                        if not(oArtiToShield) and iThreatWanted > 0 then
                            --Redundancy
                            M28Utilities.ErrorHandler('Have arti for P'..iPlateau..'Z'..iLandZone..' that want shielding but werent able to get one to shield - shoudlnt be possible')
                            --HaveActionToAssign(refActionBuildEmergencyArti, 2, iBPWanted, tLZData[M28Map.subrefMidpoint])
                        else
                            bAreBuildingShield = true
                            local iShieldTechLevelWanted = 2
                            if (tLZTeamData[M28Map.refiFixedShieldT2EngiFailureCount] or 0) >= 8 then iShieldTechLevelWanted = 3 end --normal limit elsewhere is 5
                            HaveActionToAssign(refActionBuildShield, iShieldTechLevelWanted, iBPWanted, oArtiToShield)
                            if bDebugMessages == true then LOG(sFunctionRef..': Will build shield to cover arti isntead of more arti; however will still try more arti as slightly lower priority. iShieldTechLevelWanted='..iShieldTechLevelWanted) end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we already ahve enough T2 arti threat, iThreatWanted='..iThreatWanted..'; iT2ArtiThreat='..iT2ArtiThreat..'; HaveLowMass='..tostring(bHaveLowMass)) end
                    if (iThreatWanted > iT2ArtiThreat or (iT2ArtiThreat <= 3000 and not(bHaveLowMass) and tLZTeamData[M28Map.subrefMexCountByTech][3] > 0 and (iT2ArtiThreat <= 1500 or iThreatWanted >= 800))) and (iThreatWanted >= 500 or (iThreatWanted > 0 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 18 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])) then
                        if iThreatWanted <= 4000 and iT2ArtiThreat >= 1000 then
                            iBPWanted = math.min(120, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 10 / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount])
                            if bHaveLowMass or bHaveLowPower then iBPWanted = iBPWanted * 0.5 end
                        else
                            --Presumably up against a fatboy or are outranged and have no T2 arti so need T2 arti asap
                            iBPWanted = math.min(240, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] * 10)
                            if bHaveLowMass or bHaveLowPower then iBPWanted = iBPWanted * 0.75 end
                        end
                        if bAreBuildingShield then iBPWanted = iBPWanted * 0.25 end

                        local oFactoryToAssistInstead
                        local bEnemyHasFatboyOrMegalith = false
                        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals]) == false then
                            local tFatboyOrMegalith = EntityCategoryFilterDown(M28UnitInfo.refCategoryFatboy + M28UnitInfo.refCategoryMegalith, M28Team.tTeamData[iTeam][M28Team.reftEnemyLandExperimentals])
                            if M28Utilities.IsTableEmpty(tFatboyOrMegalith) == false then
                                for iFatboy, oFatboy in tFatboyOrMegalith do
                                    if M28UnitInfo.IsUnitValid(oFatboy) and oFatboy:GetFractionComplete() >= 0.75 then
                                        bEnemyHasFatboyOrMegalith = true
                                        break
                                    end
                                end
                            end
                            if not(bEnemyHasFatboyOrMegalith) and ((tLZTeamData[M28Map.subrefiNearbyEnemyLongRangeThreat] or 0) == 0 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] == 2) then
                                --At high mass levels want to build t2 arti anyway instead of assisting a factory
                                if bHaveLowMass or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 12 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] <= 16 * M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] and (tLZTeamData[M28Map.subrefMexCountByTech][3] or 0) == 0)) then
                                    local tLandHQs = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandHQ - categories.TECH1, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                                    if M28Utilities.IsTableEmpty(tLandHQs) == false then
                                        for iFactory, oFactory in tLandHQs do
                                            if oFactory[M28Factory.refiTotalBuildCount] <= 10 or (oFactory[M28Factory.refiTotalBuildCount] <= 20 and M28Conditions.GetLifetimeBuildCount(oFactory:GetAIBrain(), M28UnitInfo.refCategoryMML) <= 15) then
                                                oFactoryToAssistInstead = oFactory
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        if not(oFactoryToAssistInstead) and not(bEnemyHasFatboyOrMegalith) and iBestEnemyRange <= 80 then
                            --If we have t3 factory nearby then assist that
                            local tLandFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory * categories.TECH3, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
                            if M28Utilities.IsTableEmpty(tLandFactories) == false then
                                for iFactory, oFactory in tLandFactories do
                                    if oFactory[M28Factory.refiTotalBuildCount] <= 20 then
                                        oFactoryToAssistInstead = oFactory
                                        break
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to assist land factory for MML, or get T2 arti, bEnemyHasFatboyOrMegalith='..tostring(bEnemyHasFatboyOrMegalith)..'; oFactoryToAssistInstead='..(oFactoryToAssistInstead.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oFactoryToAssistInstead) or 'nil')) end
                        if oFactoryToAssistInstead then
                            HaveActionToAssign(refActionAssistLandFactory, 1, iBPWanted, oFactoryToAssistInstead)
                        else
                            --adjust location to build if we already have 3 t2 arti so we build towards enemy
                            local tLocationToBuild
                            if iT2ArtiCount >= 3 and not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) then
                                tLocationToBuild = M28Utilities.MoveInDirection(tLZData[M28Map.subrefMidpoint], M28Utilities.GetAngleFromAToB(tLZData[M28Map.subrefMidpoint], tLZTeamData[M28Map.reftClosestEnemyBase]), 20, true, false)
                                if not(NavUtils.GetTerrainLabel(M28Map.refPathingTypeHover, tLocationToBuild) == iPlateau) then
                                    tLocationToBuild = {tLZData[M28Map.subrefMidpoint][1]. tLZData[M28Map.subrefMidpoint][2]. tLZData[M28Map.subrefMidpoint][3]}
                                end
                            else
                                tLocationToBuild = {tLZData[M28Map.subrefMidpoint][1], tLZData[M28Map.subrefMidpoint][2], tLZData[M28Map.subrefMidpoint][3]}
                            end
                            HaveActionToAssign(refActionBuildEmergencyArti, 2, iBPWanted, tLocationToBuild)
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to build emergency arti, iBPWanted='..iBPWanted) end
                        end

                    end
                end

            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckAndClearEngineersConstructingTargetUnit(oUnitBeingReclaimed, tLZTeamData)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckAndClearEngineersConstructingTargetUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Intended for if we have given engineers an order to reclaim a unit, although in theory could use for other things
    if not(oUnitBeingReclaimed[refbDontIncludeAsPartCompleteBuildingForConstruction]) then
        oUnitBeingReclaimed[refbDontIncludeAsPartCompleteBuildingForConstruction] = true
        local tEngisInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subreftoLZOrWZAlliedUnits])
        if M28Utilities.IsTableEmpty(tEngisInZone) == false then
            for iEngi, oEngi in tEngisInZone do
                if oEngi:IsUnitState('Repairing') or oEngi:IsUnitState('Building') then
                    if oEngi:GetFocusUnit() == oUnitBeingReclaimed then
                        if bDebugMessages == true then LOG(sFunctionRef..': Cleearing engineer from building a unit since we are trying to reclaim that same unit') end
                        M28Orders.IssueTrackedClearCommands(oEngi)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end